---
title: Co je nového v jazyce Visual Basic
ms.date: 10/24/2018
f1_keywords:
- VB.StartPage.WhatsNew
helpviewer_keywords:
- new features, Visual Basic
- what's new [Visual Basic]
- Visual Basic, what's new
ms.assetid: d7e97396-7f42-4873-a81c-4ebcc4b6ca02
ms.openlocfilehash: 3ab468f6c68429a3a5cb8706152288afae520df3
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 03/15/2020
ms.locfileid: "79187146"
---
# <a name="whats-new-for-visual-basic"></a><span data-ttu-id="7e00e-102">Co je nového v jazyce Visual Basic</span><span class="sxs-lookup"><span data-stu-id="7e00e-102">What's new for Visual Basic</span></span>

<span data-ttu-id="7e00e-103">Toto téma obsahuje seznam názvů klíčových funkcí pro každou verzi jazyka Visual Basic s podrobným popisem nových a vylepšených funkcí v nejnovějších verzích jazyka.</span><span class="sxs-lookup"><span data-stu-id="7e00e-103">This topic lists key feature names for each version of Visual Basic, with detailed descriptions of the new and enhanced features in the latest versions of the language.</span></span>

## <a name="current-version"></a><span data-ttu-id="7e00e-104">Aktuální verze</span><span class="sxs-lookup"><span data-stu-id="7e00e-104">Current version</span></span>

<span data-ttu-id="7e00e-105">Visual Basic 16.0 / Visual Studio 2019 verze 16.0</span><span class="sxs-lookup"><span data-stu-id="7e00e-105">Visual Basic 16.0 / Visual Studio 2019 version 16.0</span></span>\
<span data-ttu-id="7e00e-106">Nové funkce naleznete v [tématu Visual Basic 16.0](#visual-basic-160).</span><span class="sxs-lookup"><span data-stu-id="7e00e-106">For new features, see [Visual Basic 16.0](#visual-basic-160).</span></span>

## <a name="previous-versions"></a><span data-ttu-id="7e00e-107">Předchozí verze</span><span class="sxs-lookup"><span data-stu-id="7e00e-107">Previous versions</span></span>

<span data-ttu-id="7e00e-108">Visual Basic 15.8 / Visual Studio 2017 verze 15.8</span><span class="sxs-lookup"><span data-stu-id="7e00e-108">Visual Basic 15.8 / Visual Studio 2017 version 15.8</span></span>\
<span data-ttu-id="7e00e-109">Nové funkce naleznete v [tématu Visual Basic 15.8](#visual-basic-158).</span><span class="sxs-lookup"><span data-stu-id="7e00e-109">For new features, see [Visual Basic 15.8](#visual-basic-158).</span></span>

<span data-ttu-id="7e00e-110">Visual Basic 15.5 / Visual Studio 2017 verze 15.5</span><span class="sxs-lookup"><span data-stu-id="7e00e-110">Visual Basic 15.5 / Visual Studio 2017 version 15.5</span></span>\
<span data-ttu-id="7e00e-111">Nové funkce naleznete v [tématu Visual Basic 15.5](#visual-basic-155).</span><span class="sxs-lookup"><span data-stu-id="7e00e-111">For new features, see [Visual Basic 15.5](#visual-basic-155).</span></span>

<span data-ttu-id="7e00e-112">Visual Basic 15.3 / Visual Studio 2017 verze 15.3</span><span class="sxs-lookup"><span data-stu-id="7e00e-112">Visual Basic 15.3 / Visual Studio 2017 version 15.3</span></span>\
<span data-ttu-id="7e00e-113">Nové funkce naleznete v [tématu Visual Basic 15.3](#visual-basic-153).</span><span class="sxs-lookup"><span data-stu-id="7e00e-113">For new features, see [Visual Basic 15.3](#visual-basic-153).</span></span>

<span data-ttu-id="7e00e-114">Visual Basic 2017 / Visual Studio 2017</span><span class="sxs-lookup"><span data-stu-id="7e00e-114">Visual Basic 2017 / Visual Studio 2017</span></span>\
<span data-ttu-id="7e00e-115">Nové funkce najdete v [tématu Visual Basic 2017](#visual-basic-2017).</span><span class="sxs-lookup"><span data-stu-id="7e00e-115">For new features, see [Visual Basic 2017](#visual-basic-2017).</span></span>

<span data-ttu-id="7e00e-116">Visual Basic / Visual Studio 2015</span><span class="sxs-lookup"><span data-stu-id="7e00e-116">Visual Basic / Visual Studio 2015</span></span>\
<span data-ttu-id="7e00e-117">Nové funkce naleznete v [tématu Visual Basic 14](#visual-basic-14).</span><span class="sxs-lookup"><span data-stu-id="7e00e-117">For new features, see [Visual Basic 14](#visual-basic-14).</span></span>

<span data-ttu-id="7e00e-118">Visual Basic / Visual Studio 2013</span><span class="sxs-lookup"><span data-stu-id="7e00e-118">Visual Basic / Visual Studio 2013</span></span>\
<span data-ttu-id="7e00e-119">Technologické náhledy platformy kompilátoru .NET ("Roslyn")</span><span class="sxs-lookup"><span data-stu-id="7e00e-119">Technology previews of the .NET Compiler Platform ("Roslyn")</span></span>

<span data-ttu-id="7e00e-120">Visual Basic / Visual Studio 2012</span><span class="sxs-lookup"><span data-stu-id="7e00e-120">Visual Basic / Visual Studio 2012</span></span>\
<span data-ttu-id="7e00e-121">`Async`a `await` klíčová slova, iterátory, atributy informací o volajícím</span><span class="sxs-lookup"><span data-stu-id="7e00e-121">`Async` and `await` keywords, iterators, caller info attributes</span></span>

<span data-ttu-id="7e00e-122">Visual Basic, Visual Studio 2010</span><span class="sxs-lookup"><span data-stu-id="7e00e-122">Visual Basic, Visual Studio 2010</span></span>\
<span data-ttu-id="7e00e-123">Automaticky implementované vlastnosti, inicializátory kolekce, implicitní pokračování řádku, dynamické, obecné odchylky co/contra, globální přístup k oboru názvů</span><span class="sxs-lookup"><span data-stu-id="7e00e-123">Auto-implemented properties, collection initializers, implicit line continuation, dynamic, generic co/contra variance, global namespace access</span></span>

<span data-ttu-id="7e00e-124">Visual Basic / Visual Studio 2008</span><span class="sxs-lookup"><span data-stu-id="7e00e-124">Visual Basic / Visual Studio 2008</span></span>\
<span data-ttu-id="7e00e-125">Jazykový integrovaný dotaz (LINQ), literály XML, odvození místního typu, inicializátory objektů, anonymní typy, metody rozšíření, odvození místního `var` typu, výrazy lambda, `if` operátor, částečné metody, typy hodnot s možnou hodnotou s možnou hodnotou</span><span class="sxs-lookup"><span data-stu-id="7e00e-125">Language Integrated Query (LINQ), XML literals, local type inference, object initializers, anonymous types, extension methods, local `var` type inference, lambda expressions, `if` operator, partial methods, nullable value types</span></span>

<span data-ttu-id="7e00e-126">Visual Basic / Visual Studio 2005</span><span class="sxs-lookup"><span data-stu-id="7e00e-126">Visual Basic / Visual Studio 2005</span></span>\
<span data-ttu-id="7e00e-127">Typy `My` typů a pomocníků (přístup k aplikaci, počítači, systému souborů, síti)</span><span class="sxs-lookup"><span data-stu-id="7e00e-127">The `My` type and helper types (access to app, computer, files system, network)</span></span>

<span data-ttu-id="7e00e-128">Visual Basic / Visual Studio .NET 2003</span><span class="sxs-lookup"><span data-stu-id="7e00e-128">Visual Basic / Visual Studio .NET 2003</span></span>\
<span data-ttu-id="7e00e-129">Operátory bitového posunu, deklarace proměnné smyčky</span><span class="sxs-lookup"><span data-stu-id="7e00e-129">Bit-shift operators, loop variable declaration</span></span>

<span data-ttu-id="7e00e-130">Visual Basic / Visual Studio .NET 2002</span><span class="sxs-lookup"><span data-stu-id="7e00e-130">Visual Basic / Visual Studio .NET 2002</span></span>\
<span data-ttu-id="7e00e-131">První vydání jazyka Visual Basic .NET</span><span class="sxs-lookup"><span data-stu-id="7e00e-131">The first release of Visual Basic .NET</span></span>

## <a name="visual-basic-160"></a><span data-ttu-id="7e00e-132">Visual Basic 16.0</span><span class="sxs-lookup"><span data-stu-id="7e00e-132">Visual Basic 16.0</span></span>

<span data-ttu-id="7e00e-133">Visual Basic 16.0 se zaměřuje na poskytování více funkcí visual basic runtime (microsoft.visualbasic.dll) na .NET Core a je první verze jazyka Visual Basic zaměřené na .NET Core.</span><span class="sxs-lookup"><span data-stu-id="7e00e-133">Visual Basic 16.0 focuses on supplying more of the features of the Visual Basic Runtime (microsoft.visualbasic.dll) to .NET Core and is the first version of Visual Basic focused on .NET Core.</span></span> <span data-ttu-id="7e00e-134">Mnoho částí visual basic runtime závisí na WinForms a tyto budou přidány v novější verzi jazyka Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="7e00e-134">Many portions of the Visual Basic Runtime depend on WinForms and these will be added in a later version of Visual Basic.</span></span>

<span data-ttu-id="7e00e-135">**Komentáře povolené na více místech v rámci prohlášení**</span><span class="sxs-lookup"><span data-stu-id="7e00e-135">**Comments allowed in more places within statements**</span></span>

<span data-ttu-id="7e00e-136">V jazyce Visual Basic 15.8 a starší verze komentáře jsou povoleny pouze na prázdné řádky, na konci příkazu nebo na určitých místech v rámci příkazu, kde je povoleno implicitní pokračování řádku.</span><span class="sxs-lookup"><span data-stu-id="7e00e-136">In Visual Basic 15.8 and earlier versions, comments are only allowed on blank lines, at the end of a statement, or in specific places within a statement where an implicit line continuation is allowed.</span></span> <span data-ttu-id="7e00e-137">Počínaje Visual Basic 16.0 komentáře jsou také povoleny po explicitní pokračování řádku a v rámci příkazu na řádku začínající mezerou následuje podtržítko.</span><span class="sxs-lookup"><span data-stu-id="7e00e-137">Starting with Visual Basic 16.0, comments are also allowed after explicit line continuations and within a statement on a line beginning with a space followed by an underscore.</span></span>

```vb
Public Sub Main()
    cmd.CommandText = ' Comment is allowed here without _
        "SELECT * FROM Titles JOIN Publishers " _ ' This is a comment
        & "ON Publishers.PubId = Titles.PubID " _
 _ ' This is a comment on a line without code
        & "WHERE Publishers.State = 'CA'"
End Sub
```

## <a name="visual-basic-158"></a><span data-ttu-id="7e00e-138">Visual Basic 15.8</span><span class="sxs-lookup"><span data-stu-id="7e00e-138">Visual Basic 15.8</span></span>

<span data-ttu-id="7e00e-139">**Optimalizovaný převod s plovoucí desetinnou desetinnou na celé číslo**</span><span class="sxs-lookup"><span data-stu-id="7e00e-139">**Optimized floating-point to integer conversion**</span></span>

<span data-ttu-id="7e00e-140">V předchozích verzích jazyka Visual Basic převod [Double](../language-reference/data-types/double-data-type.md) a [Single](../language-reference/data-types/single-data-type.md) hodnoty na celá čísla nabízí relativně nízký výkon.</span><span class="sxs-lookup"><span data-stu-id="7e00e-140">In previous versions of Visual Basic, conversion of [Double](../language-reference/data-types/double-data-type.md) and [Single](../language-reference/data-types/single-data-type.md) values to integers offered relatively poor performance.</span></span> <span data-ttu-id="7e00e-141">Visual Basic 15.8 výrazně zvyšuje výkon převody s plovoucí desetinnou desetinnou hodnotou na celá čísla při předání hodnoty vrácené některou z následujících metod na jednu z [vnitřních funkcí převodu celého čísla jazyka](../language-reference/functions/type-conversion-functions.md) (CByte, CShort, CInt, CLng, CSByte, `Off`CUShort, CUInt, CULng), nebo když je hodnota vrácená některou z následujících metod implicitně přetypována na integrální typ, když je [nastavena](../language-reference/statements/option-strict-statement.md) na :</span><span class="sxs-lookup"><span data-stu-id="7e00e-141">Visual Basic 15.8 significantly enhances the performance of floating-point conversions to integers when you pass the value returned by any of the following methods to one of the [intrinsic Visual Basic integer conversion functions](../language-reference/functions/type-conversion-functions.md) (CByte, CShort, CInt, CLng, CSByte, CUShort, CUInt, CULng), or when the value returned by any of the following methods is implicitly cast to an integral type when [Option Strict](../language-reference/statements/option-strict-statement.md) is set to `Off`:</span></span>

- <xref:Microsoft.VisualBasic.Conversion.Fix(System.Double)?displayProperty=nameWithType>
- <xref:Microsoft.VisualBasic.Conversion.Fix(System.Object)?displayProperty=nameWithType>
- <xref:Microsoft.VisualBasic.Conversion.Fix(System.Single)?displayProperty=nameWithType>
- <xref:Microsoft.VisualBasic.Conversion.Int(System.Double)?displayProperty=nameWithType>
- <xref:Microsoft.VisualBasic.Conversion.Int(System.Object)?displayProperty=nameWithType>
- <xref:Microsoft.VisualBasic.Conversion.Int(System.Single)?displayProperty=nameWithType>
- <xref:System.Math.Ceiling(System.Double)?displayProperty=nameWithType>
- <xref:System.Math.Floor(System.Double)?displayProperty=nameWithType>
- <xref:System.Math.Round(System.Double)?displayProperty=nameWithType>
- <xref:System.Math.Truncate(System.Double)?displayProperty=nameWithType>

<span data-ttu-id="7e00e-142">Tato optimalizace umožňuje rychlejší spuštění kódu – až dvakrát rychleji pro kód, který provádí velký počet převodů na typy celých čísel.</span><span class="sxs-lookup"><span data-stu-id="7e00e-142">This optimization allows code to run faster -- up to twice as fast for code that does a large number of conversions to integer types.</span></span> <span data-ttu-id="7e00e-143">Následující příklad ilustruje některé jednoduché volání metod, které jsou ovlivněny touto optimalizací:</span><span class="sxs-lookup"><span data-stu-id="7e00e-143">The following example illustrates some simple method calls that are affected by this optimization:</span></span>

```vb
Dim s As Single = 173.7619
Dim d As Double = s

Dim i1 As Integer = CInt(Fix(s))               ' Result: 173
Dim b1 As Byte = CByte(Int(d))                 ' Result: 173
Dim s1 AS Short = CShort(Math.Truncate(s))     ' Result: 173
Dim i2 As Integer = CInt(Math.Ceiling(d))      ' Result: 174
Dim i3 As Integer = CInt(Math.Round(s))        ' Result: 174
```

<span data-ttu-id="7e00e-144">Všimněte si, že to zkrátí spíše než zaokrouhlit hodnoty s plovoucí desetinnou desetinnou desetinnou hodnotou.</span><span class="sxs-lookup"><span data-stu-id="7e00e-144">Note that this truncates rather than rounds floating-point values.</span></span>

## <a name="visual-basic-155"></a><span data-ttu-id="7e00e-145">Visual Basic 15.5</span><span class="sxs-lookup"><span data-stu-id="7e00e-145">Visual Basic 15.5</span></span>

[<span data-ttu-id="7e00e-146">Nekoncové pojmenované argumenty</span><span class="sxs-lookup"><span data-stu-id="7e00e-146">Non-trailing named arguments</span></span>](../programming-guide/language-features/procedures/passing-arguments-by-position-and-by-name.md#mixing-arguments-by-position-and-by-name)

<span data-ttu-id="7e00e-147">V jazyce Visual Basic 15.3 a staršíverze, když volání metody zahrnuty argumenty podle pozice a podle názvu, poziční argumenty musel předcházet pojmenované argumenty.</span><span class="sxs-lookup"><span data-stu-id="7e00e-147">In Visual Basic 15.3 and earlier versions, when a method call included arguments both by position and by name, positional arguments had to precede named arguments.</span></span> <span data-ttu-id="7e00e-148">Počínaje Visual Basic 15.5, poziční a pojmenované argumenty se mohou zobrazit v libovolném pořadí, pokud jsou všechny argumenty až do posledního pozičního argumentu ve správné poloze.</span><span class="sxs-lookup"><span data-stu-id="7e00e-148">Starting with Visual Basic 15.5, positional and named arguments can appear in any order as long as all arguments up to the last positional argument are in the correct position.</span></span> <span data-ttu-id="7e00e-149">To je užitečné zejména při pojmenované argumenty se používají k kódu čitelnější.</span><span class="sxs-lookup"><span data-stu-id="7e00e-149">This is particularly useful when named arguments are used to make code more readable.</span></span>

<span data-ttu-id="7e00e-150">Například následující volání metody má dva poziční argumenty mezi pojmenovaný míchaný argument.</span><span class="sxs-lookup"><span data-stu-id="7e00e-150">For example, the following method call has two positional arguments between a named argument.</span></span> <span data-ttu-id="7e00e-151">Pojmenovaný argument jasně ukazuje, že hodnota 19 představuje stáří.</span><span class="sxs-lookup"><span data-stu-id="7e00e-151">The named argument makes it clear that the value 19 represents an age.</span></span>

```vb
StudentInfo.Display("Mary", age:=19, #9/21/1998#)
```

[<span data-ttu-id="7e00e-152">`Private Protected`modifikátor přístupu členů</span><span class="sxs-lookup"><span data-stu-id="7e00e-152">`Private Protected` member access modifier</span></span>](../language-reference/modifiers/private-protected.md)

<span data-ttu-id="7e00e-153">Tato nová kombinace klíčových slov definuje člen, který je přístupný všem členům v jeho obsahující třídy, jakož i typy odvozené z obsahující třídy, ale pouze v případě, že jsou také nalezeny v obsahující sestavení.</span><span class="sxs-lookup"><span data-stu-id="7e00e-153">This new keyword combination defines a member that is accessible by all members in its containing class as well as by types derived from the containing class, but only if they are also found in the containing assembly.</span></span> <span data-ttu-id="7e00e-154">Vzhledem k tomu, `Private Protected` že struktury nelze zdědit, lze použít pouze pro členy třídy.</span><span class="sxs-lookup"><span data-stu-id="7e00e-154">Because structures cannot be inherited, `Private Protected` can only be applied to the members of a class.</span></span>

<span data-ttu-id="7e00e-155">**Přední hex/binární/osmičkový oddělovač**</span><span class="sxs-lookup"><span data-stu-id="7e00e-155">**Leading hex/binary/octal separator**</span></span>

<span data-ttu-id="7e00e-156">Visual Basic 2017 přidal podporu`_`znaku podtržítka ( ) jako oddělovač číslic.</span><span class="sxs-lookup"><span data-stu-id="7e00e-156">Visual Basic 2017 added support for the underscore character (`_`) as a digit separator.</span></span> <span data-ttu-id="7e00e-157">Počínaje jazykem Visual Basic 15.5 můžete použít znak podtržítka jako úvodní oddělovač mezi předponou a šestnáctkovými, binárními nebo osmičkovými číslicemi.</span><span class="sxs-lookup"><span data-stu-id="7e00e-157">Starting with Visual Basic 15.5, you can use the underscore character as a leading separator between the prefix and hexadecimal, binary, or octal digits.</span></span> <span data-ttu-id="7e00e-158">Následující příklad používá oddělovač úvodní číslice k definování 3 271 948 384 jako šestnáctkové číslo:</span><span class="sxs-lookup"><span data-stu-id="7e00e-158">The following example uses a leading digit separator to define 3,271,948,384 as a hexadecimal number:</span></span>

```vb
Dim number As Integer = &H_C305_F860
```

<span data-ttu-id="7e00e-159">Chcete-li použít znak podtržítka jako úvodní oddělovač,\*musíte do souboru projektu jazyka Visual Basic (.vbproj) přidat následující prvek:</span><span class="sxs-lookup"><span data-stu-id="7e00e-159">To use the underscore character as a leading separator, you must add the following element to your Visual Basic project (\*.vbproj) file:</span></span>

```xml
<PropertyGroup>
  <LangVersion>15.5</LangVersion>
</PropertyGroup>
```

## <a name="visual-basic-153"></a><span data-ttu-id="7e00e-160">Visual Basic 15.3</span><span class="sxs-lookup"><span data-stu-id="7e00e-160">Visual Basic 15.3</span></span>

[<span data-ttu-id="7e00e-161">**Pojmenovaný odvození n-tice**</span><span class="sxs-lookup"><span data-stu-id="7e00e-161">**Named tuple inference**</span></span>](../programming-guide/language-features/data-types/tuples.md#inferred-tuple-element-names)

<span data-ttu-id="7e00e-162">Při přiřazení hodnoty n-tice prvky z proměnných, Visual Basic odvodí název n-tice prvky z odpovídající názvy proměnných; není třeba explicitně pojmenovat prvek řazené kolekce členů.</span><span class="sxs-lookup"><span data-stu-id="7e00e-162">When you assign the value of tuple elements from variables, Visual Basic infers the name of tuple elements from the corresponding variable names; you do not have to explicitly name a tuple element.</span></span> <span data-ttu-id="7e00e-163">Následující příklad používá odvození k vytvoření řazené `state` `stateName`kolekce `capital`členů se třemi pojmenovanými prvky , , a .</span><span class="sxs-lookup"><span data-stu-id="7e00e-163">The following example uses inference to create a tuple with three named elements, `state`, `stateName`, and `capital`.</span></span>

[!code-vb[Inferred tuple names](../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/named-tuples/program.vb#2)]

<span data-ttu-id="7e00e-164">**Další přepínače kompilátoru**</span><span class="sxs-lookup"><span data-stu-id="7e00e-164">**Additional compiler switches**</span></span>

<span data-ttu-id="7e00e-165">Kompilátor příkazového řádku jazyka Visual Basic nyní podporuje možnosti kompilátoru [**-refout**](../reference/command-line-compiler/refout-compiler-option.md) a [**-refonly**](../reference/command-line-compiler/refonly-compiler-option.md) pro řízení výstupu referenčních sestavení.</span><span class="sxs-lookup"><span data-stu-id="7e00e-165">The Visual Basic command-line compiler now supports the [**-refout**](../reference/command-line-compiler/refout-compiler-option.md) and [**-refonly**](../reference/command-line-compiler/refonly-compiler-option.md) compiler options to control the output of reference assemblies.</span></span> <span data-ttu-id="7e00e-166">**-refout** definuje výstupní adresář referenčního sestavení a **-refonly** určuje, že pouze referenční sestavení má být výstupem kompilací.</span><span class="sxs-lookup"><span data-stu-id="7e00e-166">**-refout** defines the output directory of the reference assembly, and **-refonly** specifies that only a reference assembly is to be output by compilation.</span></span>

## <a name="visual-basic-2017"></a><span data-ttu-id="7e00e-167">Visual Basic 2017</span><span class="sxs-lookup"><span data-stu-id="7e00e-167">Visual Basic 2017</span></span>

[<span data-ttu-id="7e00e-168">**Záznamů**</span><span class="sxs-lookup"><span data-stu-id="7e00e-168">**Tuples**</span></span>](../programming-guide/language-features/data-types/tuples.md)

<span data-ttu-id="7e00e-169">Řazené kolekce členů jsou zjednodušené datové struktury, které se nejčastěji používá k vrácení více hodnot z volání jedné metody.</span><span class="sxs-lookup"><span data-stu-id="7e00e-169">Tuples are a lightweight data structure that most commonly is used to return multiple values from a single method call.</span></span> <span data-ttu-id="7e00e-170">Obvykle chcete-li vrátit více hodnot z metody, musíte provést jednu z následujících akcí:</span><span class="sxs-lookup"><span data-stu-id="7e00e-170">Ordinarily, to return multiple values from a method, you have to do one of the following:</span></span>

- <span data-ttu-id="7e00e-171">Definujte vlastní typ `Class` (a nebo a). `Structure`</span><span class="sxs-lookup"><span data-stu-id="7e00e-171">Define a custom type (a `Class` or a `Structure`).</span></span> <span data-ttu-id="7e00e-172">Jedná se o těžké řešení.</span><span class="sxs-lookup"><span data-stu-id="7e00e-172">This is a heavyweight solution.</span></span>

- <span data-ttu-id="7e00e-173">Definujte jeden `ByRef` nebo více parametrů, kromě vrácení hodnoty z metody.</span><span class="sxs-lookup"><span data-stu-id="7e00e-173">Define one or more `ByRef` parameters, in addition to returning a value from the method.</span></span>

<span data-ttu-id="7e00e-174">Podpora kolekce členů visual basic u n-tice umožňuje rychle definovat řazené kolekce členů, volitelně přiřadit sémantické názvy k jeho hodnotám a rychle načíst jeho hodnoty.</span><span class="sxs-lookup"><span data-stu-id="7e00e-174">Visual Basic's support for tuples lets you quickly define a tuple, optionally assign semantic names to its values, and quickly retrieve its values.</span></span> <span data-ttu-id="7e00e-175">Následující příklad zalomí volání <xref:System.Int32.TryParse%2A> metody a vrátí řazené kolekce členů.</span><span class="sxs-lookup"><span data-stu-id="7e00e-175">The following example wraps a call to the <xref:System.Int32.TryParse%2A> method and returns a tuple.</span></span>

[!code-vb[Tuple](../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple-returns.vb#2)]

<span data-ttu-id="7e00e-176">Potom můžete volat metodu a zpracování vrácené řazené kolekce členů s kódem, jako je následující.</span><span class="sxs-lookup"><span data-stu-id="7e00e-176">You can then call the method and handle the returned tuple with code like the following.</span></span>

[!code-vb[ReturnTuple](../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple-returns.vb#3)]

<span data-ttu-id="7e00e-177">**Binární literály a oddělovače číslic**</span><span class="sxs-lookup"><span data-stu-id="7e00e-177">**Binary literals and digit separators**</span></span>

<span data-ttu-id="7e00e-178">Binární literál můžete definovat pomocí `&B` předpony nebo `&b`.</span><span class="sxs-lookup"><span data-stu-id="7e00e-178">You can define a binary literal by using the prefix `&B` or `&b`.</span></span> <span data-ttu-id="7e00e-179">Kromě toho můžete použít znak `_`podtržítka , jako oddělovač číslic pro zvýšení čitelnosti.</span><span class="sxs-lookup"><span data-stu-id="7e00e-179">In addition, you can use the underscore character, `_`, as a digit separator to enhance readability.</span></span> <span data-ttu-id="7e00e-180">Následující příklad používá obě funkce `Byte` k přiřazení hodnoty a k její zobrazení jako desetinného, šestnáctkového a binárního čísla.</span><span class="sxs-lookup"><span data-stu-id="7e00e-180">The following example uses both features to assign a `Byte` value and to display it as a decimal, hexadecimal, and binary number.</span></span>

[!code-vb[Binary](../../../samples/snippets/visualbasic/getting-started/bin-example.vb#1)]

<span data-ttu-id="7e00e-181">Další informace naleznete v části "Přiřazení literálu" datových typů [Bajt](../language-reference/data-types/byte-data-type.md#literal-assignments), [Celé číslo](../language-reference/data-types/integer-data-type.md#literal-assignments), [Dlouhé](../language-reference/data-types/long-data-type.md#literal-assignments), [Krátké](../language-reference/data-types/short-data-type.md#literal-assignments), [SByte](../language-reference/data-types/sbyte-data-type.md#literal-assignments), [UInteger](../language-reference/data-types/uinteger-data-type.md#literal-assignments), [ULong](../language-reference/data-types/ulong-data-type.md#literal-assignments)a [UShort.](../language-reference/data-types/ushort-data-type.md#literal-assignments)</span><span class="sxs-lookup"><span data-stu-id="7e00e-181">For more information, see the "Literal assignments" section of the [Byte](../language-reference/data-types/byte-data-type.md#literal-assignments), [Integer](../language-reference/data-types/integer-data-type.md#literal-assignments), [Long](../language-reference/data-types/long-data-type.md#literal-assignments), [Short](../language-reference/data-types/short-data-type.md#literal-assignments), [SByte](../language-reference/data-types/sbyte-data-type.md#literal-assignments), [UInteger](../language-reference/data-types/uinteger-data-type.md#literal-assignments), [ULong](../language-reference/data-types/ulong-data-type.md#literal-assignments), and [UShort](../language-reference/data-types/ushort-data-type.md#literal-assignments) data types.</span></span>

[<span data-ttu-id="7e00e-182">**Podpora pro c# referenční vrácené hodnoty**</span><span class="sxs-lookup"><span data-stu-id="7e00e-182">**Support for C# reference return values**</span></span>](../programming-guide/language-features/procedures/ref-return-values.md)

<span data-ttu-id="7e00e-183">Počínaje C# 7.0, C# podporuje vrácené hodnoty odkazu.</span><span class="sxs-lookup"><span data-stu-id="7e00e-183">Starting with C# 7.0, C# supports reference return values.</span></span> <span data-ttu-id="7e00e-184">To znamená, že když volající metoda obdrží hodnotu vrácenou odkazem, může změnit hodnotu odkazu.</span><span class="sxs-lookup"><span data-stu-id="7e00e-184">That is, when the calling method receives a value returned by reference, it can change the value of the reference.</span></span> <span data-ttu-id="7e00e-185">Visual Basic neumožňuje vytvářet metody s referenčními vrácenými hodnotami, ale umožňuje využívat a upravovat referenční vrácené hodnoty.</span><span class="sxs-lookup"><span data-stu-id="7e00e-185">Visual Basic does not allow you to author methods with reference return values, but it does allow you to consume and modify the reference return values.</span></span>

<span data-ttu-id="7e00e-186">Například následující `Sentence` třída napsaná v `FindNext` c# obsahuje metodu, která najde další slovo ve větě, která začíná zadaným podřetězcem.</span><span class="sxs-lookup"><span data-stu-id="7e00e-186">For example, the following `Sentence` class written in C# includes a `FindNext` method that finds the next word in a sentence that begins with a specified substring.</span></span> <span data-ttu-id="7e00e-187">Řetězec je vrácen jako referenční vrácená `Boolean` hodnota a proměnná předaná odkazem na metodu označuje, zda bylo hledání úspěšné.</span><span class="sxs-lookup"><span data-stu-id="7e00e-187">The string is returned as a reference return value, and a `Boolean` variable passed by reference to the method indicates whether the search was successful.</span></span> <span data-ttu-id="7e00e-188">To znamená, že kromě čtení vrácené hodnoty volající také upravit a že `Sentence` změna se projeví ve třídě.</span><span class="sxs-lookup"><span data-stu-id="7e00e-188">This means that in addition to reading the returned value, the caller can also modify it, and that modification is reflected in the `Sentence` class.</span></span>

[!code-csharp[Ref-Return](../../../samples/snippets/visualbasic/getting-started/ref-returns.cs)]

<span data-ttu-id="7e00e-189">V nejjednodušší podobě můžete upravit slovo nalezené ve větě pomocí kódu, jako je následující.</span><span class="sxs-lookup"><span data-stu-id="7e00e-189">In its simplest form, you can modify the word found in the sentence by using code like the following.</span></span> <span data-ttu-id="7e00e-190">Všimněte si, že nepřiřazujete hodnotu metodě, ale spíše výrazu, který metoda vrací, což je referenční vrácená hodnota.</span><span class="sxs-lookup"><span data-stu-id="7e00e-190">Note that you are not assigning a value to the method, but rather to the expression that the method returns, which is the reference return value.</span></span>

[!code-vb[Ref-Return](../../../samples/snippets/visualbasic/getting-started/ref-return.vb#1)]

<span data-ttu-id="7e00e-191">Problém s tímto kódem, i když je, že pokud není nalezen a shoda, metoda vrátí první slovo.</span><span class="sxs-lookup"><span data-stu-id="7e00e-191">A problem with this code, though, is that if a match is not found, the method returns the first word.</span></span> <span data-ttu-id="7e00e-192">Vzhledem k tomu, že `Boolean` příklad nezkoumá hodnotu argumentu k určení, zda je nalezena shoda, upraví první slovo, pokud neexistuje žádná shoda.</span><span class="sxs-lookup"><span data-stu-id="7e00e-192">Since the example does not examine the value of the `Boolean` argument to determine whether a match is found, it modifies the first word if there is no match.</span></span> <span data-ttu-id="7e00e-193">Následující příklad opravuje tím, že nahradí první slovo se sebou, pokud neexistuje žádná shoda.</span><span class="sxs-lookup"><span data-stu-id="7e00e-193">The following example corrects this by replacing the first word with itself if there is no match.</span></span>

[!code-vb[Ref-Return](../../../samples/snippets/visualbasic/getting-started/ref-return.vb#2)]

<span data-ttu-id="7e00e-194">Lepším řešením je použít pomocnou metodu, na kterou je předána referenční vrácená hodnota odkazem.</span><span class="sxs-lookup"><span data-stu-id="7e00e-194">A better solution is to use a helper method to which the reference return value is passed by reference.</span></span> <span data-ttu-id="7e00e-195">Pomocná metoda pak můžete upravit argument předán odkazem.</span><span class="sxs-lookup"><span data-stu-id="7e00e-195">The helper method can then modify the argument passed to it by reference.</span></span> <span data-ttu-id="7e00e-196">Následující příklad to dělá.</span><span class="sxs-lookup"><span data-stu-id="7e00e-196">The following example does that.</span></span>

[!code-vb[Ref-Return](../../../samples/snippets/visualbasic/getting-started/ref-return-helper.vb#1)]

<span data-ttu-id="7e00e-197">Další informace naleznete v [tématu Reference Return Values](../programming-guide/language-features/procedures/ref-return-values.md).</span><span class="sxs-lookup"><span data-stu-id="7e00e-197">For more information, see [Reference Return Values](../programming-guide/language-features/procedures/ref-return-values.md).</span></span>

## <a name="visual-basic-14"></a><span data-ttu-id="7e00e-198">Visual Basic 14</span><span class="sxs-lookup"><span data-stu-id="7e00e-198">Visual Basic 14</span></span>

[<span data-ttu-id="7e00e-199">Název</span><span class="sxs-lookup"><span data-stu-id="7e00e-199">NameOf</span></span>](../language-reference/operators/nameof.md)

<span data-ttu-id="7e00e-200">Můžete získat neúplný název řetězce typu nebo člena pro použití v chybové zprávě bez pevného kódování řetězce.</span><span class="sxs-lookup"><span data-stu-id="7e00e-200">You can get the unqualified string name of a type or member for use in an error message without hard coding a string.</span></span>  <span data-ttu-id="7e00e-201">To umožňuje, aby váš kód zůstal správný při refaktoringu.</span><span class="sxs-lookup"><span data-stu-id="7e00e-201">This allows your code to remain correct when refactoring.</span></span>  <span data-ttu-id="7e00e-202">Tato funkce je také užitečná pro připojení propojení MVC řadiče zobrazení modelu a události změny vlastnosti vypalování.</span><span class="sxs-lookup"><span data-stu-id="7e00e-202">This feature is also useful for hooking up model-view-controller MVC links and firing property changed events.</span></span>

[<span data-ttu-id="7e00e-203">Interpolace řetězců</span><span class="sxs-lookup"><span data-stu-id="7e00e-203">String interpolation</span></span>](../../visual-basic/programming-guide/language-features/strings/interpolated-strings.md)

<span data-ttu-id="7e00e-204">K vytvoření řetězců můžete použít výrazy interpolace řetězců.</span><span class="sxs-lookup"><span data-stu-id="7e00e-204">You can use string interpolation expressions to construct strings.</span></span>  <span data-ttu-id="7e00e-205">Interpolovaný řetězcový výraz vypadá jako řetězec šablony, který obsahuje výrazy.</span><span class="sxs-lookup"><span data-stu-id="7e00e-205">An interpolated string expression looks like a template string that contains expressions.</span></span>  <span data-ttu-id="7e00e-206">Interpolovaný řetězec je srozumitelnější s ohledem na argumenty než [složené formátování](../../standard/base-types/composite-formatting.md).</span><span class="sxs-lookup"><span data-stu-id="7e00e-206">An interpolated string is easier to understand with respect to arguments than [Composite Formatting](../../standard/base-types/composite-formatting.md).</span></span>

[<span data-ttu-id="7e00e-207">Přístup a indexování členů s nulovým podmíněným podmínkou</span><span class="sxs-lookup"><span data-stu-id="7e00e-207">Null-conditional member access and indexing</span></span>](../language-reference/operators/null-conditional-operators.md)

<span data-ttu-id="7e00e-208">Před provedením operace přístupu člena (`?.`) nebo indexu (`?[]`) můžete otestovat hodnotu null velmi lehkým syntaktním způsobem.</span><span class="sxs-lookup"><span data-stu-id="7e00e-208">You can test for null in a very light syntactic way before performing a member access (`?.`) or index (`?[]`) operation.</span></span>  <span data-ttu-id="7e00e-209">Tyto operátory vám pomohou napsat méně kódu pro zpracování null kontroly, zejména pro sestupdo datových struktur.</span><span class="sxs-lookup"><span data-stu-id="7e00e-209">These operators help you write less code to handle null checks, especially for descending into data structures.</span></span>  <span data-ttu-id="7e00e-210">Pokud je levý operand nebo odkaz na objekt null, operace vrátí hodnotu null.</span><span class="sxs-lookup"><span data-stu-id="7e00e-210">If the left operand or object reference is null, the operations returns null.</span></span>

[<span data-ttu-id="7e00e-211">Víceřádkové řetězcové literály</span><span class="sxs-lookup"><span data-stu-id="7e00e-211">Multi-line string literals</span></span>](../../visual-basic/programming-guide/language-features/strings/string-basics.md)

<span data-ttu-id="7e00e-212">Řetězcové literály mohou obsahovat nové řádkové sekvence.</span><span class="sxs-lookup"><span data-stu-id="7e00e-212">String literals can contain newline sequences.</span></span>  <span data-ttu-id="7e00e-213">Už nepotřebujete staré řešení používání`<xml><![CDATA[...text with newlines...]]></xml>.Value`</span><span class="sxs-lookup"><span data-stu-id="7e00e-213">You no longer need the old work around of using `<xml><![CDATA[...text with newlines...]]></xml>.Value`</span></span>

<span data-ttu-id="7e00e-214">**Komentáře**</span><span class="sxs-lookup"><span data-stu-id="7e00e-214">**Comments**</span></span>

<span data-ttu-id="7e00e-215">Komentáře můžete umístit za implicitní pokračování řádku, uvnitř výrazů inicializátoru a mezi výrazy výrazu LINQ.</span><span class="sxs-lookup"><span data-stu-id="7e00e-215">You can put comments after implicit line continuations, inside initializer expressions, and among LINQ expression terms.</span></span>

<span data-ttu-id="7e00e-216">**Inteligentnější plně kvalifikované rozlišení názvů**</span><span class="sxs-lookup"><span data-stu-id="7e00e-216">**Smarter fully-qualified name resolution**</span></span>

<span data-ttu-id="7e00e-217">Daný kód, `Threading.Thread.Sleep(1000)`například , Visual Basic slouží k vyhledat obor názvů "Threading", zjistit, že byl nejednoznačný mezi System.Threading a System.Windows.Threading a potom nahlásit chybu.</span><span class="sxs-lookup"><span data-stu-id="7e00e-217">Given code such as `Threading.Thread.Sleep(1000)`, Visual Basic used to look up the namespace "Threading", discover it was ambiguous between System.Threading and System.Windows.Threading, and then report an error.</span></span>  <span data-ttu-id="7e00e-218">Visual Basic nyní zvažuje oba možné obory názvů společně.</span><span class="sxs-lookup"><span data-stu-id="7e00e-218">Visual Basic now considers both possible namespaces together.</span></span>  <span data-ttu-id="7e00e-219">Pokud zobrazíte seznam dokončení, editor sady Visual Studio uvádí členy z obou typů v seznamu dokončení.</span><span class="sxs-lookup"><span data-stu-id="7e00e-219">If you show the completion list, the Visual Studio editor lists members from both types in the completion list.</span></span>

<span data-ttu-id="7e00e-220">**Literály prvního roku**</span><span class="sxs-lookup"><span data-stu-id="7e00e-220">**Year-first date literals**</span></span>

<span data-ttu-id="7e00e-221">Můžete mít literály data ve formátu yyyy-mm-dd . `#2015-03-17 16:10 PM#`</span><span class="sxs-lookup"><span data-stu-id="7e00e-221">You can have date literals in yyyy-mm-dd format, `#2015-03-17 16:10 PM#`.</span></span>

<span data-ttu-id="7e00e-222">**Vlastnosti rozhraní jen pro čtení**</span><span class="sxs-lookup"><span data-stu-id="7e00e-222">**Readonly interface properties**</span></span>

<span data-ttu-id="7e00e-223">Vlastnosti rozhraní jen pro čtení můžete implementovat pomocí vlastnosti write.</span><span class="sxs-lookup"><span data-stu-id="7e00e-223">You can implement readonly interface properties using a readwrite property.</span></span> <span data-ttu-id="7e00e-224">Rozhraní zaručuje minimální funkčnost a nezastaví implementující třídu od povolení nastavení vlastnosti.</span><span class="sxs-lookup"><span data-stu-id="7e00e-224">The interface guarantees minimum functionality, and it does not stop an implementing class from allowing the property to be set.</span></span>

[<span data-ttu-id="7e00e-225">TypeOf \<expr> \<IsNot typ></span><span class="sxs-lookup"><span data-stu-id="7e00e-225">TypeOf \<expr> IsNot \<type></span></span>](../../visual-basic/language-reference/operators/typeof-operator.md)

<span data-ttu-id="7e00e-226">Pro větší čitelnost kódu, můžete `TypeOf` nyní `IsNot`použít s .</span><span class="sxs-lookup"><span data-stu-id="7e00e-226">For more readability of your code, you can now use `TypeOf` with `IsNot`.</span></span>

[<span data-ttu-id="7e00e-227">#Disable \<>> a \<#Enable ID upozornění</span><span class="sxs-lookup"><span data-stu-id="7e00e-227">#Disable Warning \<ID> and #Enable Warning \<ID></span></span>](../../visual-basic/language-reference/directives/index.md)

<span data-ttu-id="7e00e-228">Můžete zakázat a povolit konkrétní upozornění pro oblasti ve zdrojovém souboru.</span><span class="sxs-lookup"><span data-stu-id="7e00e-228">You can disable and enable specific warnings for regions within a source file.</span></span>

<span data-ttu-id="7e00e-229">**Vylepšení komentářů dokumentu XML**</span><span class="sxs-lookup"><span data-stu-id="7e00e-229">**XML doc comment improvements**</span></span>

<span data-ttu-id="7e00e-230">Při psaní komentáře doc, získáte inteligentní editor a vytvořit podporu `crefs` pro ověřování názvů parametrů, správné zpracování (generika, operátory, atd.), vybarvení a refaktoring.</span><span class="sxs-lookup"><span data-stu-id="7e00e-230">When writing doc comments, you get smart editor and build support for validating parameter names, proper handling of `crefs` (generics, operators, etc.), colorizing, and refactoring.</span></span>

[<span data-ttu-id="7e00e-231">Definice dílčích modulů a rozhraní</span><span class="sxs-lookup"><span data-stu-id="7e00e-231">Partial module and interface definitions</span></span>](../../visual-basic/language-reference/modifiers/partial.md)

<span data-ttu-id="7e00e-232">Kromě tříd a struktur můžete deklarovat částečné moduly a rozhraní.</span><span class="sxs-lookup"><span data-stu-id="7e00e-232">In addition to classes and structs, you can declare partial modules and interfaces.</span></span>

[<span data-ttu-id="7e00e-233">#Region direktivy uvnitř těl a metod</span><span class="sxs-lookup"><span data-stu-id="7e00e-233">#Region directives inside method bodies</span></span>](../../visual-basic/language-reference/directives/region-directive.md)

<span data-ttu-id="7e00e-234">Oddělovače #Region...#End oblast můžete umístit kamkoli do souboru, do funkcí a dokonce i do těl a napříč těly funkcí.</span><span class="sxs-lookup"><span data-stu-id="7e00e-234">You can put #Region…#End Region delimiters anywhere in a file, inside functions, and even spanning across function bodies.</span></span>

[<span data-ttu-id="7e00e-235">Definice přepsání jsou implicitně přetížení</span><span class="sxs-lookup"><span data-stu-id="7e00e-235">Overrides definitions are implicitly overloads</span></span>](../../visual-basic/language-reference/modifiers/overrides.md)

<span data-ttu-id="7e00e-236">Pokud přidáte `Overrides` modifikátor do definice, kompilátor implicitně přidá `Overloads` tak, že můžete zadat méně kódu v běžných případech.</span><span class="sxs-lookup"><span data-stu-id="7e00e-236">If you add the `Overrides` modifier to a definition, the compiler implicitly adds `Overloads` so that you can type less code in common cases.</span></span>

<span data-ttu-id="7e00e-237">**CObj povoleno v argumentech atributů**</span><span class="sxs-lookup"><span data-stu-id="7e00e-237">**CObj allowed in attributes arguments**</span></span>

<span data-ttu-id="7e00e-238">Kompilátor slouží k poskytnutí chyby, která CObj(...) nebyla konstanta při použití v konstrukcích atributů.</span><span class="sxs-lookup"><span data-stu-id="7e00e-238">The compiler used to give an error that CObj(…) was not a constant when used in attribute constructions.</span></span>

<span data-ttu-id="7e00e-239">**Deklarování a využívání nejednoznačných metod z různých rozhraní**</span><span class="sxs-lookup"><span data-stu-id="7e00e-239">**Declaring and consuming ambiguous methods from different interfaces**</span></span>

<span data-ttu-id="7e00e-240">Dříve následující kód přinesl chyby, které `IMock` vám zabránily deklarovat nebo volat `GetDetails` (pokud byly deklarovány v c#):</span><span class="sxs-lookup"><span data-stu-id="7e00e-240">Previously the following code yielded errors that prevented you from declaring `IMock` or from calling `GetDetails` (if these had been declared in C#):</span></span>

```vb
Interface ICustomer
  Sub GetDetails(x As Integer)
End Interface

Interface ITime
  Sub GetDetails(x As String)
End Interface

Interface IMock : Inherits ICustomer, ITime
  Overloads Sub GetDetails(x As Char)
End Interface

Interface IMock2 : Inherits ICustomer, ITime
End Interface
```

<span data-ttu-id="7e00e-241">Nyní kompilátor použije normální pravidla řešení přetížení `GetDetails` zvolit nejvhodnější pro volání a můžete deklarovat vztahy rozhraní v jazyce Visual Basic, jako jsou uvedeny v ukázce.</span><span class="sxs-lookup"><span data-stu-id="7e00e-241">Now the compiler will use normal overload resolution rules to choose the most appropriate `GetDetails` to call, and you can declare interface relationships in Visual Basic like those shown in the sample.</span></span>

## <a name="see-also"></a><span data-ttu-id="7e00e-242">Viz také</span><span class="sxs-lookup"><span data-stu-id="7e00e-242">See also</span></span>

- [<span data-ttu-id="7e00e-243">Novinky v sadě Visual Studio 2017</span><span class="sxs-lookup"><span data-stu-id="7e00e-243">What's New in Visual Studio 2017</span></span>](/visualstudio/ide/whats-new-visual-studio-2017)
- [<span data-ttu-id="7e00e-244">Co je nového ve Visual Studiu 2019</span><span class="sxs-lookup"><span data-stu-id="7e00e-244">What's New in Visual Studio 2019</span></span>](/visualstudio/ide/whats-new-visual-studio-2019)
