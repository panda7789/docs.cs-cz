---
title: Použití modelu syntaxe .NET Compiler Platform SDK
description: Tento přehled poskytuje pochopení typů, které používáte pro pochopení a manipulaci se syntaxmi uzlů.
ms.date: 10/15/2017
ms.custom: mvc
ms.openlocfilehash: fdb13095c2b91e54d58988a51a51b05652e57ea6
ms.sourcegitcommit: 488aced39b5f374bc0a139a4993616a54d15baf0
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 05/12/2020
ms.locfileid: "83208392"
---
# <a name="work-with-syntax"></a><span data-ttu-id="ca7a2-103">Práce se syntaxí</span><span class="sxs-lookup"><span data-stu-id="ca7a2-103">Work with syntax</span></span>

<span data-ttu-id="ca7a2-104">*Strom syntaxe* je základní struktura dat vystavená rozhraními API kompilátoru.</span><span class="sxs-lookup"><span data-stu-id="ca7a2-104">The *syntax tree* is a fundamental data structure exposed by the compiler APIs.</span></span> <span data-ttu-id="ca7a2-105">Tyto stromy reprezentují lexikální a syntaktickou strukturu zdrojového kódu.</span><span class="sxs-lookup"><span data-stu-id="ca7a2-105">These trees represent the lexical and syntactic structure of source code.</span></span> <span data-ttu-id="ca7a2-106">Slouží k tomu dva důležité účely:</span><span class="sxs-lookup"><span data-stu-id="ca7a2-106">They serve two important purposes:</span></span>

- <span data-ttu-id="ca7a2-107">Pro povolení nástrojů, jako je IDE, doplňky, nástroje pro analýzu kódu a Refaktoring – pro zobrazení a zpracování syntaktické struktury zdrojového kódu v projektu uživatele.</span><span class="sxs-lookup"><span data-stu-id="ca7a2-107">To allow tools - such as an IDE, add-ins, code analysis tools, and refactorings - to see and process the syntactic structure of source code in a user's project.</span></span>
- <span data-ttu-id="ca7a2-108">Aby bylo možné povolit nástroje, jako jsou refaktoring a IDE – pro vytvoření, úpravu a změnu uspořádání zdrojového kódu přirozeným způsobem bez nutnosti používat přímé úpravy textu.</span><span class="sxs-lookup"><span data-stu-id="ca7a2-108">To enable tools - such as refactorings and an IDE - to create, modify, and rearrange source code in a natural manner without having to use direct text edits.</span></span> <span data-ttu-id="ca7a2-109">Díky vytváření stromů a manipulaci s nimi můžou nástroje snadno vytvořit a změnit uspořádání zdrojového kódu.</span><span class="sxs-lookup"><span data-stu-id="ca7a2-109">By creating and manipulating trees, tools can easily create and rearrange source code.</span></span>

## <a name="syntax-trees"></a><span data-ttu-id="ca7a2-110">Stromy syntaxe</span><span class="sxs-lookup"><span data-stu-id="ca7a2-110">Syntax trees</span></span>

<span data-ttu-id="ca7a2-111">Stromy syntaxe jsou primární strukturou, která se používá pro kompilaci, analýzu kódu, vázání, refaktoring, funkce rozhraní IDE a generování kódu.</span><span class="sxs-lookup"><span data-stu-id="ca7a2-111">Syntax trees are the primary structure used for compilation, code analysis, binding, refactoring, IDE features, and code generation.</span></span> <span data-ttu-id="ca7a2-112">Žádná část zdrojového kódu není chápána bez toho, aby byla identifikována a zařazena do jedné z mnoha dobře známých prvků strukturálního jazyka.</span><span class="sxs-lookup"><span data-stu-id="ca7a2-112">No part of the source code is understood without it first being identified and categorized into one of many well-known structural language elements.</span></span>

<span data-ttu-id="ca7a2-113">Stromy syntaxe mají tři klíčové atributy.</span><span class="sxs-lookup"><span data-stu-id="ca7a2-113">Syntax trees have three key attributes.</span></span> <span data-ttu-id="ca7a2-114">Prvním atributem je, že stromy syntaxe uchovávají všechny informace o zdroji v plné přesnosti.</span><span class="sxs-lookup"><span data-stu-id="ca7a2-114">The first attribute is that syntax trees hold all the source information in full fidelity.</span></span> <span data-ttu-id="ca7a2-115">Plná přesnost znamená, že strom syntaxe obsahuje všechny informace, které jsou nalezeny ve zdrojovém textu, každé gramatické konstrukce, každý lexikální token a vše ostatní v rámci, včetně prázdných znaků, komentářů a direktiv preprocesoru.</span><span class="sxs-lookup"><span data-stu-id="ca7a2-115">Full fidelity means that the syntax tree contains every piece of information found in the source text, every grammatical construct, every lexical token, and everything else in between, including white space, comments, and preprocessor directives.</span></span> <span data-ttu-id="ca7a2-116">Například každý literál uvedený ve zdroji je reprezentován přesně tak, jak byl zadán.</span><span class="sxs-lookup"><span data-stu-id="ca7a2-116">For example, each literal mentioned in the source is represented exactly as it was typed.</span></span> <span data-ttu-id="ca7a2-117">Stromy syntaxe také zachycují chyby ve zdrojovém kódu, pokud je program neúplný nebo poškozený, protože představuje vynechané nebo chybějící tokeny.</span><span class="sxs-lookup"><span data-stu-id="ca7a2-117">Syntax trees also capture errors in source code when the program is incomplete or malformed by representing skipped or missing tokens.</span></span>

<span data-ttu-id="ca7a2-118">Druhý atribut stromové struktury syntaxe je, že mohou vydávat přesný text, ze kterého byly analyzovány.</span><span class="sxs-lookup"><span data-stu-id="ca7a2-118">The second attribute of syntax trees is that they can produce the exact text that they were parsed from.</span></span> <span data-ttu-id="ca7a2-119">Z libovolného uzlu syntaxe je možné získat textovou reprezentaci podstromu, který je v tomto uzlu rootem.</span><span class="sxs-lookup"><span data-stu-id="ca7a2-119">From any syntax node, it's possible to get the text representation of the subtree rooted at that node.</span></span> <span data-ttu-id="ca7a2-120">Tato možnost znamená, že stromy syntaxe lze použít jako způsob konstrukce a úpravy zdrojového textu.</span><span class="sxs-lookup"><span data-stu-id="ca7a2-120">This ability means that syntax trees can be used as a way to construct and edit source text.</span></span> <span data-ttu-id="ca7a2-121">Vytvořením stromu, který máte, vytvořením ekvivalentního textu a úpravou stromu syntaxe a vytvořením nového stromu ze změn ve stávajícím stromu jste tento text efektivně upravili.</span><span class="sxs-lookup"><span data-stu-id="ca7a2-121">By creating a tree you have, by implication, created the equivalent text, and by editing a syntax tree, making a new tree out of changes to an existing tree, you have effectively edited the text.</span></span>

<span data-ttu-id="ca7a2-122">Třetí atribut stromové struktury syntaxe je, že jsou neměnné a jsou bezpečné pro přístup z více vláken.</span><span class="sxs-lookup"><span data-stu-id="ca7a2-122">The third attribute of syntax trees is that they are immutable and thread-safe.</span></span> <span data-ttu-id="ca7a2-123">Po získání stromu se jedná o snímek aktuálního stavu kódu a nikdy se nemění.</span><span class="sxs-lookup"><span data-stu-id="ca7a2-123">After a tree is obtained, it's a snapshot of the current state of the code and never changes.</span></span> <span data-ttu-id="ca7a2-124">To umožňuje více uživatelům pracovat se stejným stromem syntaxe ve stejnou dobu v různých vláknech bez uzamčení nebo duplikace.</span><span class="sxs-lookup"><span data-stu-id="ca7a2-124">This allows multiple users to interact with the same syntax tree at the same time in different threads without locking or duplication.</span></span> <span data-ttu-id="ca7a2-125">Vzhledem k tomu, že stromy jsou neměnné a nelze provádět změny přímo ve stromu, metody továrny pomohou vytvořit a upravit stromy syntaxe vytvořením dalších snímků stromu.</span><span class="sxs-lookup"><span data-stu-id="ca7a2-125">Because the trees are immutable and no modifications can be made directly to a tree, factory methods help create and modify syntax trees by creating additional snapshots of the tree.</span></span> <span data-ttu-id="ca7a2-126">Stromy jsou efektivní způsobem, jakým znovu používají podkladové uzly, takže je možné novou verzi znovu sestavit rychle a s trochu dodatečnou pamětí.</span><span class="sxs-lookup"><span data-stu-id="ca7a2-126">The trees are efficient in the way they reuse underlying nodes, so a new version can be rebuilt fast and with little extra memory.</span></span>

<span data-ttu-id="ca7a2-127">Strom syntaxe je doslova stromovou strukturou dat, kde neterminálové strukturální prvky nadřazené jiné prvky.</span><span class="sxs-lookup"><span data-stu-id="ca7a2-127">A syntax tree is literally a tree data structure, where non-terminal structural elements parent other elements.</span></span> <span data-ttu-id="ca7a2-128">Každý strom syntaxe je tvořen uzly, tokeny a minihry.</span><span class="sxs-lookup"><span data-stu-id="ca7a2-128">Each syntax tree is made up of nodes, tokens, and trivia.</span></span>

## <a name="syntax-nodes"></a><span data-ttu-id="ca7a2-129">Uzly syntaxe</span><span class="sxs-lookup"><span data-stu-id="ca7a2-129">Syntax nodes</span></span>

<span data-ttu-id="ca7a2-130">Uzly syntaxe jsou jedním z primárních prvků stromové struktury syntaxe.</span><span class="sxs-lookup"><span data-stu-id="ca7a2-130">Syntax nodes are one of the primary elements of syntax trees.</span></span> <span data-ttu-id="ca7a2-131">Tyto uzly reprezentují syntaktické konstrukce, jako jsou deklarace, příkazy, klauzule a výrazy.</span><span class="sxs-lookup"><span data-stu-id="ca7a2-131">These nodes represent syntactic constructs such as declarations, statements, clauses, and expressions.</span></span> <span data-ttu-id="ca7a2-132">Jednotlivé kategorie uzlů syntaxe jsou reprezentovány samostatnou třídou odvozenou z <xref:Microsoft.CodeAnalysis.SyntaxNode?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="ca7a2-132">Each category of syntax nodes is represented by a separate class derived from <xref:Microsoft.CodeAnalysis.SyntaxNode?displayProperty=nameWithType>.</span></span> <span data-ttu-id="ca7a2-133">Sada tříd uzlů není rozšiřitelná.</span><span class="sxs-lookup"><span data-stu-id="ca7a2-133">The set of node classes is not extensible.</span></span>

<span data-ttu-id="ca7a2-134">Všechny uzly syntaxe jsou uzly bez terminálů ve stromu syntaxe, což znamená, že mají vždy jiné uzly a tokeny jako podřízené objekty.</span><span class="sxs-lookup"><span data-stu-id="ca7a2-134">All syntax nodes are non-terminal nodes in the syntax tree, which means they always have other nodes and tokens as children.</span></span> <span data-ttu-id="ca7a2-135">Jako podřízený uzel jiného uzlu má každý uzel nadřazený uzel, který je k dispozici prostřednictvím <xref:Microsoft.CodeAnalysis.SyntaxNode.Parent?displayProperty=nameWithType> Vlastnosti.</span><span class="sxs-lookup"><span data-stu-id="ca7a2-135">As a child of another node, each node has a parent node that can be accessed through the <xref:Microsoft.CodeAnalysis.SyntaxNode.Parent?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="ca7a2-136">Vzhledem k tomu, že uzly a stromy jsou neměnné, nadřazený uzel se nikdy nemění.</span><span class="sxs-lookup"><span data-stu-id="ca7a2-136">Because nodes and trees are immutable, the parent of a node never changes.</span></span> <span data-ttu-id="ca7a2-137">Kořen stromu má nadřazený prvek s hodnotou null.</span><span class="sxs-lookup"><span data-stu-id="ca7a2-137">The root of the tree has a null parent.</span></span>

<span data-ttu-id="ca7a2-138">Každý uzel má <xref:Microsoft.CodeAnalysis.SyntaxNode.ChildNodes?displayProperty=nameWithType> metodu, která vrátí seznam podřízených uzlů v sekvenčním pořadí na základě jejich pozice ve zdrojovém textu.</span><span class="sxs-lookup"><span data-stu-id="ca7a2-138">Each node has a <xref:Microsoft.CodeAnalysis.SyntaxNode.ChildNodes?displayProperty=nameWithType> method, which returns a list of child nodes in sequential order based on their position in the source text.</span></span> <span data-ttu-id="ca7a2-139">Tento seznam neobsahuje tokeny.</span><span class="sxs-lookup"><span data-stu-id="ca7a2-139">This list does not contain tokens.</span></span> <span data-ttu-id="ca7a2-140">Každý uzel obsahuje také metody pro prohlédnutí následníků, jako například <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodes%2A> , <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantTokens%2A> nebo <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantTrivia%2A> -reprezentující seznam všech uzlů, tokenů nebo minihryů, které existují v podstromu, které jsou v tomto uzlu rootem.</span><span class="sxs-lookup"><span data-stu-id="ca7a2-140">Each node also has methods to examine Descendants, such as <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodes%2A>, <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantTokens%2A>, or <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantTrivia%2A> - that represent a list of all the nodes, tokens, or trivia that exist in the subtree rooted by that node.</span></span>

<span data-ttu-id="ca7a2-141">Kromě toho každá podtřída uzlu syntaxe zveřejňuje všechny stejné podřízené objekty prostřednictvím vlastností silného typu.</span><span class="sxs-lookup"><span data-stu-id="ca7a2-141">In addition, each syntax node subclass exposes all the same children through strongly typed properties.</span></span> <span data-ttu-id="ca7a2-142">Například <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax> Třída Node má tři další vlastnosti, které jsou specifické pro binární operátory: <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Left> , a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.OperatorToken> <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Right> .</span><span class="sxs-lookup"><span data-stu-id="ca7a2-142">For example, a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax> node class has three additional properties specific to binary operators: <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Left>, <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.OperatorToken>, and <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Right>.</span></span> <span data-ttu-id="ca7a2-143">Typ <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Left> a je a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Right> <xref:Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax> typ <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.OperatorToken> je <xref:Microsoft.CodeAnalysis.SyntaxToken> .</span><span class="sxs-lookup"><span data-stu-id="ca7a2-143">The type of <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Left> and <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Right> is <xref:Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax>, and the type of <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.OperatorToken> is <xref:Microsoft.CodeAnalysis.SyntaxToken>.</span></span>

<span data-ttu-id="ca7a2-144">Některé uzly syntaxe mají volitelné podřízené objekty.</span><span class="sxs-lookup"><span data-stu-id="ca7a2-144">Some syntax nodes have optional children.</span></span> <span data-ttu-id="ca7a2-145">Například <xref:Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax> má volitelný <xref:Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax> .</span><span class="sxs-lookup"><span data-stu-id="ca7a2-145">For example, an <xref:Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax> has an optional <xref:Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax>.</span></span> <span data-ttu-id="ca7a2-146">Pokud podřízená položka není k dispozici, vlastnost vrátí hodnotu null.</span><span class="sxs-lookup"><span data-stu-id="ca7a2-146">If the child is not present, the property returns null.</span></span>

## <a name="syntax-tokens"></a><span data-ttu-id="ca7a2-147">Syntaktické tokeny</span><span class="sxs-lookup"><span data-stu-id="ca7a2-147">Syntax tokens</span></span>

<span data-ttu-id="ca7a2-148">Tokeny syntaxe jsou terminály jazykové gramatiky, které představují nejmenší syntaktické fragmenty kódu.</span><span class="sxs-lookup"><span data-stu-id="ca7a2-148">Syntax tokens are the terminals of the language grammar, representing the smallest syntactic fragments of the code.</span></span> <span data-ttu-id="ca7a2-149">Nejsou nikdy nadřazenými členy jiných uzlů nebo tokenů.</span><span class="sxs-lookup"><span data-stu-id="ca7a2-149">They are never parents of other nodes or tokens.</span></span> <span data-ttu-id="ca7a2-150">Tokeny syntaxe se skládají z klíčových slov, identifikátorů, literálů a interpunkce.</span><span class="sxs-lookup"><span data-stu-id="ca7a2-150">Syntax tokens consist of keywords, identifiers, literals, and punctuation.</span></span>

<span data-ttu-id="ca7a2-151">Pro účely efektivity <xref:Microsoft.CodeAnalysis.SyntaxToken> je typem hodnota typ CLR.</span><span class="sxs-lookup"><span data-stu-id="ca7a2-151">For efficiency purposes, the <xref:Microsoft.CodeAnalysis.SyntaxToken> type is a CLR value type.</span></span> <span data-ttu-id="ca7a2-152">Proto na rozdíl od uzlů syntaxe existuje pouze jedna struktura pro všechny druhy tokenů se směsí vlastností, které mají význam v závislosti na druhu tokenu, který je reprezentován.</span><span class="sxs-lookup"><span data-stu-id="ca7a2-152">Therefore, unlike syntax nodes, there is only one structure for all kinds of tokens with a mix of properties that have meaning depending on the kind of token that is being represented.</span></span>

<span data-ttu-id="ca7a2-153">Například celočíselný literálový token představuje číselnou hodnotu.</span><span class="sxs-lookup"><span data-stu-id="ca7a2-153">For example, an integer literal token represents a numeric value.</span></span> <span data-ttu-id="ca7a2-154">Kromě nezpracovaného zdrojového textu, který token pokrývá, má literální token <xref:Microsoft.CodeAnalysis.SyntaxToken.Value> vlastnost, která oznamuje přesné dekódování celočíselné hodnoty.</span><span class="sxs-lookup"><span data-stu-id="ca7a2-154">In addition to the raw source text the token spans, the literal token has a <xref:Microsoft.CodeAnalysis.SyntaxToken.Value> property that tells you the exact decoded integer value.</span></span> <span data-ttu-id="ca7a2-155">Tato vlastnost je zapsána jako, <xref:System.Object> protože může být jedním z mnoha primitivních typů.</span><span class="sxs-lookup"><span data-stu-id="ca7a2-155">This property is typed as <xref:System.Object> because it may be one of many primitive types.</span></span>

<span data-ttu-id="ca7a2-156"><xref:Microsoft.CodeAnalysis.SyntaxToken.ValueText>Vlastnost oznamuje stejné informace jako <xref:Microsoft.CodeAnalysis.SyntaxToken.Value> vlastnost; Nicméně tato vlastnost je vždy typu <xref:System.String> .</span><span class="sxs-lookup"><span data-stu-id="ca7a2-156">The <xref:Microsoft.CodeAnalysis.SyntaxToken.ValueText> property tells you the same information as the <xref:Microsoft.CodeAnalysis.SyntaxToken.Value> property; however this property is always typed as <xref:System.String>.</span></span> <span data-ttu-id="ca7a2-157">Identifikátor ve zdrojovém textu v jazyce C# může obsahovat řídicí znaky Unicode, ale syntaxe samotné sekvence escape není považována za součást názvu identifikátoru.</span><span class="sxs-lookup"><span data-stu-id="ca7a2-157">An identifier in C# source text may include Unicode escape characters, yet the syntax of the escape sequence itself is not considered part of the identifier name.</span></span> <span data-ttu-id="ca7a2-158">I když nezpracovaný text předaný tokenem zahrnuje řídicí sekvenci, <xref:Microsoft.CodeAnalysis.SyntaxToken.ValueText> vlastnost nikoli.</span><span class="sxs-lookup"><span data-stu-id="ca7a2-158">So although the raw text spanned by the token does include the escape sequence, the <xref:Microsoft.CodeAnalysis.SyntaxToken.ValueText> property does not.</span></span> <span data-ttu-id="ca7a2-159">Místo toho obsahuje znaky Unicode identifikované řídicím znakem.</span><span class="sxs-lookup"><span data-stu-id="ca7a2-159">Instead, it includes the Unicode characters identified by the escape.</span></span> <span data-ttu-id="ca7a2-160">Například pokud zdrojový text obsahuje identifikátor napsaný jako `\u03C0` , pak <xref:Microsoft.CodeAnalysis.SyntaxToken.ValueText> vlastnost pro tento token vrátí `π` .</span><span class="sxs-lookup"><span data-stu-id="ca7a2-160">For example, if the source text contains an identifier written as `\u03C0`, then the <xref:Microsoft.CodeAnalysis.SyntaxToken.ValueText> property for this token will return `π`.</span></span>

## <a name="syntax-trivia"></a><span data-ttu-id="ca7a2-161">Minihry syntaxe</span><span class="sxs-lookup"><span data-stu-id="ca7a2-161">Syntax trivia</span></span>

<span data-ttu-id="ca7a2-162">Syntaxe minihry představuje části zdrojového textu, které jsou převážně nevýznamné pro normální porozumění kódu, jako jsou prázdné znaky, komentáře a direktivy preprocesoru.</span><span class="sxs-lookup"><span data-stu-id="ca7a2-162">Syntax trivia represent the parts of the source text that are largely insignificant for normal understanding of the code, such as white space, comments, and preprocessor directives.</span></span> <span data-ttu-id="ca7a2-163">Podobně jako tokeny syntaxe jsou minihry typy hodnot.</span><span class="sxs-lookup"><span data-stu-id="ca7a2-163">Like syntax tokens, trivia are value types.</span></span> <span data-ttu-id="ca7a2-164">Jediný <xref:Microsoft.CodeAnalysis.SyntaxTrivia?displayProperty=nameWithType> typ se používá k popsání všech druhů minihry.</span><span class="sxs-lookup"><span data-stu-id="ca7a2-164">The single <xref:Microsoft.CodeAnalysis.SyntaxTrivia?displayProperty=nameWithType> type is used to describe all kinds of trivia.</span></span>

<span data-ttu-id="ca7a2-165">Vzhledem k tomu, že minihry nejsou součástí normální syntaxe jazyka a mohou se vyskytovat kdekoli mezi dvěma tokeny, nejsou zahrnuty ve stromové struktuře syntaxe jako podřízený uzel uzlu.</span><span class="sxs-lookup"><span data-stu-id="ca7a2-165">Because trivia are not part of the normal language syntax and can appear anywhere between any two tokens, they are not included in the syntax tree as a child of a node.</span></span> <span data-ttu-id="ca7a2-166">Vzhledem k tomu, že jsou důležité při implementaci funkce, jako je refaktoring a udržování plné přesnosti se zdrojovým textem, existují v rámci stromu syntaxe.</span><span class="sxs-lookup"><span data-stu-id="ca7a2-166">Yet, because they are important when implementing a feature like refactoring and to maintain full fidelity with the source text, they do exist as part of the syntax tree.</span></span>

<span data-ttu-id="ca7a2-167">K minihry se dostanete tak, že zkontrolujete <xref:Microsoft.CodeAnalysis.SyntaxToken.LeadingTrivia?displayProperty=nameWithType> kolekce nebo tokeny <xref:Microsoft.CodeAnalysis.SyntaxToken.TrailingTrivia?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="ca7a2-167">You can access trivia by inspecting a token's <xref:Microsoft.CodeAnalysis.SyntaxToken.LeadingTrivia?displayProperty=nameWithType> or <xref:Microsoft.CodeAnalysis.SyntaxToken.TrailingTrivia?displayProperty=nameWithType> collections.</span></span> <span data-ttu-id="ca7a2-168">Při analýze zdrojového textu jsou sekvence minihry přidruženy k tokenům.</span><span class="sxs-lookup"><span data-stu-id="ca7a2-168">When source text is parsed, sequences of trivia are associated with tokens.</span></span> <span data-ttu-id="ca7a2-169">Obecně platí, že token vlastní minihry po stejném řádku až na další token.</span><span class="sxs-lookup"><span data-stu-id="ca7a2-169">In general, a token owns any trivia after it on the same line up to the next token.</span></span> <span data-ttu-id="ca7a2-170">Všechny minihry po tomto řádku jsou přidruženy k následujícímu tokenu.</span><span class="sxs-lookup"><span data-stu-id="ca7a2-170">Any trivia after that line is associated with the following token.</span></span> <span data-ttu-id="ca7a2-171">První token ve zdrojovém souboru získá všechny počáteční minihry a poslední sekvence minihry v souboru se rozsměruje na token konce souboru, který má v opačném případě nulovou šířku.</span><span class="sxs-lookup"><span data-stu-id="ca7a2-171">The first token in the source file gets all the initial trivia, and the last sequence of trivia in the file is tacked onto the end-of-file token, which otherwise has zero width.</span></span>

<span data-ttu-id="ca7a2-172">Na rozdíl od syntaktických uzlů a tokenů syntaxe minihry neobsahuje rodiče.</span><span class="sxs-lookup"><span data-stu-id="ca7a2-172">Unlike syntax nodes and tokens, syntax trivia do not have parents.</span></span> <span data-ttu-id="ca7a2-173">Vzhledem k tomu, že jsou součástí stromu a každá z nich je přidružena k jednomu tokenu, můžete získat přístup k tokenu, ke kterému je přidruženo pomocí <xref:Microsoft.CodeAnalysis.SyntaxTrivia.Token?displayProperty=nameWithType> Vlastnosti.</span><span class="sxs-lookup"><span data-stu-id="ca7a2-173">Yet, because they are part of the tree and each is associated with a single token, you may access the token it is associated with using the <xref:Microsoft.CodeAnalysis.SyntaxTrivia.Token?displayProperty=nameWithType> property.</span></span>

## <a name="spans"></a><span data-ttu-id="ca7a2-174">Přes</span><span class="sxs-lookup"><span data-stu-id="ca7a2-174">Spans</span></span>

<span data-ttu-id="ca7a2-175">Každý uzel, token nebo minihry ví svou polohu v rámci zdrojového textu a počtu znaků, ze kterých se skládá.</span><span class="sxs-lookup"><span data-stu-id="ca7a2-175">Each node, token, or trivia knows its position within the source text and the number of characters it consists of.</span></span> <span data-ttu-id="ca7a2-176">Pozice textu je reprezentovaná jako 32á celočíselná hodnota, což je index založený na nule `char` .</span><span class="sxs-lookup"><span data-stu-id="ca7a2-176">A text position is represented as a 32-bit integer, which is a zero-based `char` index.</span></span> <span data-ttu-id="ca7a2-177"><xref:Microsoft.CodeAnalysis.Text.TextSpan>Objekt je počáteční pozice a počet znaků, jak představují celá čísla.</span><span class="sxs-lookup"><span data-stu-id="ca7a2-177">A <xref:Microsoft.CodeAnalysis.Text.TextSpan> object is the beginning position and a count of characters, both represented as integers.</span></span> <span data-ttu-id="ca7a2-178">Pokud <xref:Microsoft.CodeAnalysis.Text.TextSpan> má nulovou délku, odkazuje na umístění mezi dvěma znaky.</span><span class="sxs-lookup"><span data-stu-id="ca7a2-178">If <xref:Microsoft.CodeAnalysis.Text.TextSpan> has a zero length, it refers to a location between two characters.</span></span>

<span data-ttu-id="ca7a2-179">Každý uzel má dvě <xref:Microsoft.CodeAnalysis.Text.TextSpan> vlastnosti: <xref:Microsoft.CodeAnalysis.SyntaxNode.Span%2A> a <xref:Microsoft.CodeAnalysis.SyntaxNode.FullSpan%2A> .</span><span class="sxs-lookup"><span data-stu-id="ca7a2-179">Each node has two <xref:Microsoft.CodeAnalysis.Text.TextSpan> properties: <xref:Microsoft.CodeAnalysis.SyntaxNode.Span%2A> and <xref:Microsoft.CodeAnalysis.SyntaxNode.FullSpan%2A>.</span></span>

<span data-ttu-id="ca7a2-180"><xref:Microsoft.CodeAnalysis.SyntaxNode.Span%2A>Vlastnost je text v rozsahu od začátku prvního tokenu v podstromu uzlu na konec posledního tokenu.</span><span class="sxs-lookup"><span data-stu-id="ca7a2-180">The <xref:Microsoft.CodeAnalysis.SyntaxNode.Span%2A> property is the text span from the start of the first token in the node's subtree to the end of the last token.</span></span> <span data-ttu-id="ca7a2-181">Tento rozsah neobsahuje žádné počáteční ani koncové minihryy.</span><span class="sxs-lookup"><span data-stu-id="ca7a2-181">This span does not include any leading or trailing trivia.</span></span>

<span data-ttu-id="ca7a2-182"><xref:Microsoft.CodeAnalysis.SyntaxNode.FullSpan%2A>Vlastnost je textový rozsah, který zahrnuje normální rozpětí uzlu, a rozsah všech úvodních a koncových minihry.</span><span class="sxs-lookup"><span data-stu-id="ca7a2-182">The <xref:Microsoft.CodeAnalysis.SyntaxNode.FullSpan%2A> property is the text span that includes the node's normal span, plus the span of any leading or trailing trivia.</span></span>

<span data-ttu-id="ca7a2-183">Příklad:</span><span class="sxs-lookup"><span data-stu-id="ca7a2-183">For example:</span></span>

``` csharp
      if (x > 3)
      {
||        // this is bad
          |throw new Exception("Not right.");|  // better exception?||
      }
```

<span data-ttu-id="ca7a2-184">Uzel příkazu uvnitř bloku má rozpětí vyznačené jednotlivými svislými pruhy (|).</span><span class="sxs-lookup"><span data-stu-id="ca7a2-184">The statement node inside the block has a span indicated by the single vertical bars (|).</span></span> <span data-ttu-id="ca7a2-185">Obsahuje znaky `throw new Exception("Not right.");` .</span><span class="sxs-lookup"><span data-stu-id="ca7a2-185">It includes the characters `throw new Exception("Not right.");`.</span></span> <span data-ttu-id="ca7a2-186">Celý rozsah je určen dvojitými svislými pruhy (| |).</span><span class="sxs-lookup"><span data-stu-id="ca7a2-186">The full span is indicated by the double vertical bars (||).</span></span> <span data-ttu-id="ca7a2-187">Obsahuje stejné znaky jako rozsah a znaky spojené s úvodním a koncovým minihry.</span><span class="sxs-lookup"><span data-stu-id="ca7a2-187">It includes the same characters as the span and the characters associated with the leading and trailing trivia.</span></span>

## <a name="kinds"></a><span data-ttu-id="ca7a2-188">Druzí</span><span class="sxs-lookup"><span data-stu-id="ca7a2-188">Kinds</span></span>

<span data-ttu-id="ca7a2-189">Každý uzel, token nebo minihry má <xref:Microsoft.CodeAnalysis.SyntaxNode.RawKind?displayProperty=nameWithType> vlastnost typu <xref:System.Int32?displayProperty=nameWithType> , která identifikuje přesný prvek syntaxe reprezentovaný.</span><span class="sxs-lookup"><span data-stu-id="ca7a2-189">Each node, token, or trivia has a <xref:Microsoft.CodeAnalysis.SyntaxNode.RawKind?displayProperty=nameWithType> property, of type <xref:System.Int32?displayProperty=nameWithType>, that identifies the exact syntax element represented.</span></span> <span data-ttu-id="ca7a2-190">Tuto hodnotu lze přetypovat na výčet specifický pro jazyk.</span><span class="sxs-lookup"><span data-stu-id="ca7a2-190">This value can be cast to a language-specific enumeration.</span></span> <span data-ttu-id="ca7a2-191">Každý jazyk, C# nebo Visual Basic má jeden `SyntaxKind` výčet (a v <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind?displayProperty=nameWithType> <xref:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind?displayProperty=nameWithType> uvedeném pořadí), který obsahuje seznam všech možných uzlů, tokenů a minihry prvků v gramatice.</span><span class="sxs-lookup"><span data-stu-id="ca7a2-191">Each language, C# or Visual Basic, has a single `SyntaxKind` enumeration  (<xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind?displayProperty=nameWithType> and <xref:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind?displayProperty=nameWithType>, respectively) that lists all the possible nodes, tokens, and trivia elements in the grammar.</span></span> <span data-ttu-id="ca7a2-192">Tento převod lze provést automaticky přístupem k <xref:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind%2A?displayProperty=nameWithType> <xref:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.Kind%2A?displayProperty=nameWithType> metodám rozšíření nebo.</span><span class="sxs-lookup"><span data-stu-id="ca7a2-192">This conversion can be done automatically by accessing the <xref:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind%2A?displayProperty=nameWithType> or <xref:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.Kind%2A?displayProperty=nameWithType> extension methods.</span></span>

<span data-ttu-id="ca7a2-193"><xref:Microsoft.CodeAnalysis.SyntaxToken.RawKind>Vlastnost umožňuje snadnou nejednoznačnost typů uzlů syntaxe, které sdílejí stejnou třídu Node.</span><span class="sxs-lookup"><span data-stu-id="ca7a2-193">The <xref:Microsoft.CodeAnalysis.SyntaxToken.RawKind> property allows for easy disambiguation of syntax node types that share the same node class.</span></span> <span data-ttu-id="ca7a2-194">Pro tokeny a minihry je tato vlastnost jediným způsobem, jak odlišit jeden typ prvku od jiného.</span><span class="sxs-lookup"><span data-stu-id="ca7a2-194">For tokens and trivia, this property is the only way to distinguish one type of element from another.</span></span>

<span data-ttu-id="ca7a2-195">Například jedna <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax> Třída má <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Left> , <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.OperatorToken> a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Right> jako podřízené.</span><span class="sxs-lookup"><span data-stu-id="ca7a2-195">For example, a single <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax> class has <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Left>, <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.OperatorToken>, and <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Right> as children.</span></span> <span data-ttu-id="ca7a2-196"><xref:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind%2A>Vlastnost rozlišuje, zda se jedná o <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.AddExpression> , <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.SubtractExpression> nebo <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.MultiplyExpression> druh uzlu syntaxe.</span><span class="sxs-lookup"><span data-stu-id="ca7a2-196">The <xref:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind%2A> property distinguishes whether it is an <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.AddExpression>, <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.SubtractExpression>, or <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.MultiplyExpression> kind of syntax node.</span></span>

## <a name="errors"></a><span data-ttu-id="ca7a2-197">chyby</span><span class="sxs-lookup"><span data-stu-id="ca7a2-197">Errors</span></span>

<span data-ttu-id="ca7a2-198">I v případě, že zdrojový text obsahuje syntaktické chyby, je zveřejněn úplný strom syntaxe, který je k dispozici jako kulatý trippable do zdroje.</span><span class="sxs-lookup"><span data-stu-id="ca7a2-198">Even when the source text contains syntax errors, a full syntax tree that is round-trippable to the source is exposed.</span></span> <span data-ttu-id="ca7a2-199">Když analyzátor nalezne kód, který není v souladu s definovanou syntaxí jazyka, používá jeden ze dvou postupů pro vytvoření stromu syntaxe:</span><span class="sxs-lookup"><span data-stu-id="ca7a2-199">When the parser encounters code that does not conform to the defined syntax of the language, it uses one of two techniques to create a syntax tree:</span></span>

- <span data-ttu-id="ca7a2-200">Pokud analyzátor očekává určitý druh tokenu, ale nenalezne jej, může vložit chybějící token do stromu syntaxe v umístění, ve kterém byl token očekáván.</span><span class="sxs-lookup"><span data-stu-id="ca7a2-200">If the parser expects a particular kind of token but does not find it, it may insert a missing token into the syntax tree in the location that the token was expected.</span></span> <span data-ttu-id="ca7a2-201">Chybějící token představuje skutečný token, který byl očekáván, ale má prázdný rozsah a jeho <xref:Microsoft.CodeAnalysis.SyntaxNode.IsMissing?displayProperty=nameWithType> vlastnost vrací `true` .</span><span class="sxs-lookup"><span data-stu-id="ca7a2-201">A missing token represents the actual token that was expected, but it has an empty span, and its <xref:Microsoft.CodeAnalysis.SyntaxNode.IsMissing?displayProperty=nameWithType> property returns `true`.</span></span>

- <span data-ttu-id="ca7a2-202">Analyzátor může přeskočit tokeny, dokud nenalezne ten, kde může pokračovat v analýze.</span><span class="sxs-lookup"><span data-stu-id="ca7a2-202">The parser may skip tokens until it finds one where it can continue parsing.</span></span> <span data-ttu-id="ca7a2-203">V tomto případě jsou vynechané tokeny připojené jako minihry uzel s typem <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.SkippedTokensTrivia> .</span><span class="sxs-lookup"><span data-stu-id="ca7a2-203">In this case, the skipped tokens are attached as a trivia node with the kind <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.SkippedTokensTrivia>.</span></span>
