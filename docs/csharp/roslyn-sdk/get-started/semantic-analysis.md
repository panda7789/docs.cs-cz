---
title: Začínáme se sémantickou analýzou
description: Tento kurz poskytuje přehled práce s sémantickou analýzou pomocí sady SDK kompilátoru .NET.
ms.date: 02/06/2018
ms.custom: mvc
ms.openlocfilehash: a6dcaeeb86acb5c0e1602f01dc5952ffd9d5e3f5
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 03/14/2020
ms.locfileid: "78240505"
---
# <a name="get-started-with-semantic-analysis"></a><span data-ttu-id="5c5a7-103">Začínáme se sémantickou analýzou</span><span class="sxs-lookup"><span data-stu-id="5c5a7-103">Get started with semantic analysis</span></span>

<span data-ttu-id="5c5a7-104">Tento kurz předpokládá, že jste obeznámeni s rozhraním API syntaxe.</span><span class="sxs-lookup"><span data-stu-id="5c5a7-104">This tutorial assumes you're familiar with the Syntax API.</span></span> <span data-ttu-id="5c5a7-105">Začínáme [s článkem analýzy syntaxe](syntax-analysis.md) poskytuje dostatečný úvod.</span><span class="sxs-lookup"><span data-stu-id="5c5a7-105">The [get started with syntax analysis](syntax-analysis.md) article provides sufficient introduction.</span></span>

<span data-ttu-id="5c5a7-106">V tomto kurzu prozkoumat **symbol** a **vazby API**.</span><span class="sxs-lookup"><span data-stu-id="5c5a7-106">In this tutorial, you explore the **Symbol** and **Binding APIs**.</span></span> <span data-ttu-id="5c5a7-107">Tato úložiště API poskytují informace o _sémantickém významu_ programu.</span><span class="sxs-lookup"><span data-stu-id="5c5a7-107">These APIs provide information about the _semantic meaning_ of a program.</span></span> <span data-ttu-id="5c5a7-108">Umožňují vám klást otázky a odpovídat na ně o typech reprezentovaném libovolným symbolem ve vašem programu.</span><span class="sxs-lookup"><span data-stu-id="5c5a7-108">They enable you to ask and answer questions about the types represented by any symbol in your program.</span></span>

<span data-ttu-id="5c5a7-109">Budete muset nainstalovat **sdk platformy kompilátoru .NET**:</span><span class="sxs-lookup"><span data-stu-id="5c5a7-109">You'll need to install the **.NET Compiler Platform SDK**:</span></span>

[!INCLUDE[interactive-note](~/includes/roslyn-installation.md)]

## <a name="understanding-compilations-and-symbols"></a><span data-ttu-id="5c5a7-110">Principy kompilací a symbolů</span><span class="sxs-lookup"><span data-stu-id="5c5a7-110">Understanding Compilations and Symbols</span></span>

<span data-ttu-id="5c5a7-111">Při další práci s sadou SDK kompilátoru .NET se seznámíte s rozdíly mezi syntaxovým rozhraním API a sémantickým rozhraním API.</span><span class="sxs-lookup"><span data-stu-id="5c5a7-111">As you work more with the .NET Compiler SDK, you become familiar with the distinctions between Syntax API and the Semantic API.</span></span> <span data-ttu-id="5c5a7-112">**Syntaxapi** umožňuje podívat se na _strukturu_ programu.</span><span class="sxs-lookup"><span data-stu-id="5c5a7-112">The **Syntax API** allows you to look at the _structure_ of a program.</span></span> <span data-ttu-id="5c5a7-113">Často však chcete bohatší informace o sémantice nebo _významu_ programu.</span><span class="sxs-lookup"><span data-stu-id="5c5a7-113">However, often you want richer information about the semantics or _meaning_ of a program.</span></span> <span data-ttu-id="5c5a7-114">Zatímco soubor s volným kódem nebo fragment kódu jazyka Nebo Jazyka # může být syntakticky analyzován izolovaně, není smysluplné klást otázky, jako je například "jaký je typ této proměnné" ve vakuu.</span><span class="sxs-lookup"><span data-stu-id="5c5a7-114">While a loose code file or snippet of Visual Basic or C# code can be syntactically analyzed in isolation, it's not meaningful to ask questions such as "what's the type of this variable" in a vacuum.</span></span> <span data-ttu-id="5c5a7-115">Význam názvu typu může záviset na odkazech na sestavení, importech oboru názvů nebo jiných souborech kódu.</span><span class="sxs-lookup"><span data-stu-id="5c5a7-115">The meaning of a type name may be dependent on assembly references, namespace imports, or other code files.</span></span> <span data-ttu-id="5c5a7-116">Tyto otázky jsou zodpovězeny pomocí **sémantického rozhraní API**, konkrétně třídy. <xref:Microsoft.CodeAnalysis.Compilation?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="5c5a7-116">Those questions are answered using the **Semantic API**, specifically the <xref:Microsoft.CodeAnalysis.Compilation?displayProperty=nameWithType> class.</span></span>

<span data-ttu-id="5c5a7-117">Instance <xref:Microsoft.CodeAnalysis.Compilation> je obdobou jednoho projektu, jak je vidět kompilátoru a představuje vše potřebné ke kompilaci visual basic nebo C# program.</span><span class="sxs-lookup"><span data-stu-id="5c5a7-117">An instance of <xref:Microsoft.CodeAnalysis.Compilation> is analogous to a single project as seen by the compiler and represents everything needed to compile a Visual Basic or C# program.</span></span> <span data-ttu-id="5c5a7-118">**Kompilace** obsahuje sadu zdrojových souborů, které mají být kompilovány, odkazy na sestavení a možnosti kompilátoru.</span><span class="sxs-lookup"><span data-stu-id="5c5a7-118">The **compilation** includes the set of source files to be compiled, assembly references, and compiler options.</span></span> <span data-ttu-id="5c5a7-119">Můžete důvod o významu kódu pomocí všech ostatních informací v tomto kontextu.</span><span class="sxs-lookup"><span data-stu-id="5c5a7-119">You can reason about the meaning of the code using all the other information in this context.</span></span> <span data-ttu-id="5c5a7-120">A <xref:Microsoft.CodeAnalysis.Compilation> umožňuje najít **symboly** - entity, jako jsou typy, obory názvů, členy a proměnné, které názvy a jiné výrazy odkazují.</span><span class="sxs-lookup"><span data-stu-id="5c5a7-120">A <xref:Microsoft.CodeAnalysis.Compilation> allows you to find **Symbols** - entities such as types, namespaces, members, and variables which names and other expressions refer to.</span></span> <span data-ttu-id="5c5a7-121">Proces sousto názvů a výrazů se **Binding**nazývá **Binding** .</span><span class="sxs-lookup"><span data-stu-id="5c5a7-121">The process of associating names and expressions with **Symbols** is called **Binding**.</span></span>

<span data-ttu-id="5c5a7-122">Stejně jako <xref:Microsoft.CodeAnalysis.SyntaxTree?displayProperty=nameWithType>, <xref:Microsoft.CodeAnalysis.Compilation> je abstraktní třída s jazykově specifickými deriváty.</span><span class="sxs-lookup"><span data-stu-id="5c5a7-122">Like <xref:Microsoft.CodeAnalysis.SyntaxTree?displayProperty=nameWithType>, <xref:Microsoft.CodeAnalysis.Compilation> is an abstract class with language-specific derivatives.</span></span> <span data-ttu-id="5c5a7-123">Při vytváření instance Kompilace je nutné vyvolat <xref:Microsoft.CodeAnalysis.CSharp.CSharpCompilation?displayProperty=nameWithType> metodu <xref:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation?displayProperty=nameWithType>factory ve třídě (nebo).</span><span class="sxs-lookup"><span data-stu-id="5c5a7-123">When creating an instance of Compilation, you must invoke a factory method on the <xref:Microsoft.CodeAnalysis.CSharp.CSharpCompilation?displayProperty=nameWithType> (or <xref:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation?displayProperty=nameWithType>) class.</span></span>

## <a name="querying-symbols"></a><span data-ttu-id="5c5a7-124">Dotazování symbolů</span><span class="sxs-lookup"><span data-stu-id="5c5a7-124">Querying symbols</span></span>

<span data-ttu-id="5c5a7-125">V tomto kurzu se znovu podíváte na program "Hello World".</span><span class="sxs-lookup"><span data-stu-id="5c5a7-125">In this tutorial, you look at the "Hello World" program again.</span></span> <span data-ttu-id="5c5a7-126">Tentokrát dotaz symboly v programu pochopit, jaké typy tyto symboly představují.</span><span class="sxs-lookup"><span data-stu-id="5c5a7-126">This time, you query the symbols in the program to understand what types those symbols represent.</span></span> <span data-ttu-id="5c5a7-127">Dotaz na typy v oboru názvů a naučit se najít metody, které jsou k dispozici na typu.</span><span class="sxs-lookup"><span data-stu-id="5c5a7-127">You query for the types in a namespace, and learn to find the methods available on a type.</span></span>

<span data-ttu-id="5c5a7-128">Hotový kód pro tuto ukázku najdete v [našem úložišti GitHub](https://github.com/dotnet/samples/tree/master/csharp/roslyn-sdk/SemanticQuickStart).</span><span class="sxs-lookup"><span data-stu-id="5c5a7-128">You can see the finished code for this sample in [our GitHub repository](https://github.com/dotnet/samples/tree/master/csharp/roslyn-sdk/SemanticQuickStart).</span></span>

> [!NOTE]
> <span data-ttu-id="5c5a7-129">Typy stromů syntaxe používají dědičnost k popisu různých prvků syntaxe, které jsou platné na různých místech v programu.</span><span class="sxs-lookup"><span data-stu-id="5c5a7-129">The Syntax Tree types use inheritance to describe the different syntax elements that are valid at different locations in the program.</span></span> <span data-ttu-id="5c5a7-130">Použití těchto rozhraní API často znamená, že vlastnosti přetypování nebo členy kolekce na konkrétní odvozené typy.</span><span class="sxs-lookup"><span data-stu-id="5c5a7-130">Using these APIs often means casting properties or collection members to specific derived types.</span></span> <span data-ttu-id="5c5a7-131">V následujících příkladech jsou přiřazení a přetypování samostatné příkazy, které používají explicitně zadané proměnné.</span><span class="sxs-lookup"><span data-stu-id="5c5a7-131">In the following examples, the assignment and the casts are separate statements, using explicitly typed variables.</span></span> <span data-ttu-id="5c5a7-132">Můžete si přečíst kód zobrazíte návratové typy rozhraní API a typ runtime vrácených objektů.</span><span class="sxs-lookup"><span data-stu-id="5c5a7-132">You can read the code to see the return types of the API and the runtime type of the objects returned.</span></span> <span data-ttu-id="5c5a7-133">V praxi je běžnější používat implicitně zadané proměnné a spoléhat se na názvy rozhraní API k popisu typu zkoumaných objektů.</span><span class="sxs-lookup"><span data-stu-id="5c5a7-133">In practice, it's more common to use implicitly typed variables and rely on API names to describe the type of objects being examined.</span></span>

<span data-ttu-id="5c5a7-134">Vytvořte nový projekt **nástroje pro analýzu samostatného kódu** jazyka C#:</span><span class="sxs-lookup"><span data-stu-id="5c5a7-134">Create a new C# **Stand-Alone Code Analysis Tool** project:</span></span>

* <span data-ttu-id="5c5a7-135">V Sadě Visual Studio zvolte **Soubor** > **nový** > **projekt,** abyste zobrazili dialogové okno Nový projekt.</span><span class="sxs-lookup"><span data-stu-id="5c5a7-135">In Visual Studio, choose **File** > **New** > **Project** to display the New Project dialog.</span></span>
* <span data-ttu-id="5c5a7-136">V **části Visual C#** > **Rozšiřitelnost**zvolte **Nástroj pro analýzu samostatného kódu**.</span><span class="sxs-lookup"><span data-stu-id="5c5a7-136">Under **Visual C#** > **Extensibility**, choose **Stand-Alone Code Analysis Tool**.</span></span>
* <span data-ttu-id="5c5a7-137">Pojmenujte projekt **"SémanticQuickStart**" a klepněte na tlačítko OK.</span><span class="sxs-lookup"><span data-stu-id="5c5a7-137">Name your project "**SemanticQuickStart**" and click OK.</span></span>

<span data-ttu-id="5c5a7-138">Budete analyzovat základní "Hello World!"</span><span class="sxs-lookup"><span data-stu-id="5c5a7-138">You're going to analyze the basic "Hello World!"</span></span> <span data-ttu-id="5c5a7-139">program zobrazen dříve.</span><span class="sxs-lookup"><span data-stu-id="5c5a7-139">program shown earlier.</span></span>
<span data-ttu-id="5c5a7-140">Přidejte text programu Hello World jako `Program` konstantu ve své třídě:</span><span class="sxs-lookup"><span data-stu-id="5c5a7-140">Add the text for the Hello World program as a constant in your `Program` class:</span></span>

[!code-csharp[Declare the program test](../../../../samples/snippets/csharp/roslyn-sdk/SemanticQuickStart/Program.cs#1 "Declare a constant string for the program text to analyze")]

<span data-ttu-id="5c5a7-141">Dále přidejte následující kód k vytvoření stromu syntaxe pro text kódu v konstantě. `programText`</span><span class="sxs-lookup"><span data-stu-id="5c5a7-141">Next, add the following code to build the syntax tree for the code text in the `programText` constant.</span></span>  <span data-ttu-id="5c5a7-142">Do metody přidejte `Main` následující řádek:</span><span class="sxs-lookup"><span data-stu-id="5c5a7-142">Add the following line to your `Main` method:</span></span>

[!code-csharp[Create the tree](../../../../samples/snippets/csharp/roslyn-sdk/SemanticQuickStart/Program.cs#2 "Create the syntax tree")]

<span data-ttu-id="5c5a7-143">Dále vytvořte <xref:Microsoft.CodeAnalysis.CSharp.CSharpCompilation> ze stromu, který jste již vytvořili.</span><span class="sxs-lookup"><span data-stu-id="5c5a7-143">Next, build a <xref:Microsoft.CodeAnalysis.CSharp.CSharpCompilation> from the tree you already created.</span></span> <span data-ttu-id="5c5a7-144">Ukázka "Hello World" závisí <xref:System.String> <xref:System.Console> na a typy.</span><span class="sxs-lookup"><span data-stu-id="5c5a7-144">The "Hello World" sample relies on the <xref:System.String> and <xref:System.Console> types.</span></span> <span data-ttu-id="5c5a7-145">Musíte odkazovat na sestavení, které deklaruje tyto dva typy ve vaší kompilaci.</span><span class="sxs-lookup"><span data-stu-id="5c5a7-145">You need to reference the assembly that declares those two types in your compilation.</span></span> <span data-ttu-id="5c5a7-146">Přidejte do metody `Main` následující řádek a vytvořte kompilaci stromu syntaxe, včetně odkazu na příslušné sestavení:</span><span class="sxs-lookup"><span data-stu-id="5c5a7-146">Add the following line to your `Main` method to create a compilation of your syntax tree, including the reference to the appropriate assembly:</span></span>

[!code-csharp[Create the compilation](../../../../samples/snippets/csharp/roslyn-sdk/SemanticQuickStart/Program.cs#3 "Create the compilation for the semantic model")]

<span data-ttu-id="5c5a7-147">Metoda <xref:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.AddReferences%2A?displayProperty=nameWithType> přidá odkazy na kompilaci.</span><span class="sxs-lookup"><span data-stu-id="5c5a7-147">The <xref:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.AddReferences%2A?displayProperty=nameWithType> method adds references to the compilation.</span></span> <span data-ttu-id="5c5a7-148">Metoda <xref:Microsoft.CodeAnalysis.MetadataReference.CreateFromFile%2A?displayProperty=nameWithType> načte sestavení jako odkaz.</span><span class="sxs-lookup"><span data-stu-id="5c5a7-148">The <xref:Microsoft.CodeAnalysis.MetadataReference.CreateFromFile%2A?displayProperty=nameWithType> method loads an assembly as a reference.</span></span>

## <a name="querying-the-semantic-model"></a><span data-ttu-id="5c5a7-149">Dotazování na sémantický model</span><span class="sxs-lookup"><span data-stu-id="5c5a7-149">Querying the semantic model</span></span>

<span data-ttu-id="5c5a7-150">Jakmile budete <xref:Microsoft.CodeAnalysis.Compilation> mít, můžete požádat o <xref:Microsoft.CodeAnalysis.SemanticModel> pro všechny <xref:Microsoft.CodeAnalysis.SyntaxTree> obsažené v tom <xref:Microsoft.CodeAnalysis.Compilation>.</span><span class="sxs-lookup"><span data-stu-id="5c5a7-150">Once you have a <xref:Microsoft.CodeAnalysis.Compilation> you can ask it for a <xref:Microsoft.CodeAnalysis.SemanticModel> for any <xref:Microsoft.CodeAnalysis.SyntaxTree> contained in that <xref:Microsoft.CodeAnalysis.Compilation>.</span></span> <span data-ttu-id="5c5a7-151">Můžete si myslet, sémantický model jako zdroj pro všechny informace, které by normálně získat z intellisense.</span><span class="sxs-lookup"><span data-stu-id="5c5a7-151">You can think of the semantic model as the source for all the information you would normally get from intellisense.</span></span> <span data-ttu-id="5c5a7-152">A <xref:Microsoft.CodeAnalysis.SemanticModel> můžete odpovědět na otázky jako "Jaké názvy jsou v oboru v tomto umístění?", "Jaké členy jsou přístupné z této metody?", "Jaké proměnné se používají v tomto bloku textu?", a "Co tento název/výraz odkazuje?"</span><span class="sxs-lookup"><span data-stu-id="5c5a7-152">A <xref:Microsoft.CodeAnalysis.SemanticModel> can answer questions like "What names are in scope at this location?", "What members are accessible from this method?", "What variables are used in this block of text?", and "What does this name/expression refer to?"</span></span> <span data-ttu-id="5c5a7-153">Přidejte tento příkaz k vytvoření sémantického modelu:</span><span class="sxs-lookup"><span data-stu-id="5c5a7-153">Add this statement to create the semantic model:</span></span>

[!code-csharp[Create the semantic model](../../../../samples/snippets/csharp/roslyn-sdk/SemanticQuickStart/Program.cs#4 "Create the semantic model")]

## <a name="binding-a-name"></a><span data-ttu-id="5c5a7-154">Vazba názvu</span><span class="sxs-lookup"><span data-stu-id="5c5a7-154">Binding a name</span></span>

<span data-ttu-id="5c5a7-155">Vytvoří <xref:Microsoft.CodeAnalysis.Compilation> <xref:Microsoft.CodeAnalysis.SemanticModel> z <xref:Microsoft.CodeAnalysis.SyntaxTree>.</span><span class="sxs-lookup"><span data-stu-id="5c5a7-155">The <xref:Microsoft.CodeAnalysis.Compilation> creates the  <xref:Microsoft.CodeAnalysis.SemanticModel> from the <xref:Microsoft.CodeAnalysis.SyntaxTree>.</span></span> <span data-ttu-id="5c5a7-156">Po vytvoření modelu, můžete dotaz na `using` něj najít první direktivu a načíst informace o symbolu `System` pro obor názvů.</span><span class="sxs-lookup"><span data-stu-id="5c5a7-156">After creating the model, you can query it to find the first `using` directive, and retrieve the symbol information for the `System` namespace.</span></span> <span data-ttu-id="5c5a7-157">Přidejte tyto dva `Main` řádky do metody k vytvoření sémantického modelu a načíst symbol pro první příkaz using:</span><span class="sxs-lookup"><span data-stu-id="5c5a7-157">Add these two lines to your `Main` method to create the semantic model and retrieve the symbol for the first using statement:</span></span>

[!code-csharp[Find the namespace symbol for the first using](../../../../samples/snippets/csharp/roslyn-sdk/SemanticQuickStart/Program.cs#5 "Find the namespace symbol for the first using")]

<span data-ttu-id="5c5a7-158">Předchozí kód ukazuje, jak svázat název `using` v první <xref:Microsoft.CodeAnalysis.SymbolInfo?displayProperty=nameWithType> direktivě načíst pro obor `System` názvů.</span><span class="sxs-lookup"><span data-stu-id="5c5a7-158">The preceding code shows how to bind the name in the first `using` directive to retrieve a <xref:Microsoft.CodeAnalysis.SymbolInfo?displayProperty=nameWithType> for the `System` namespace.</span></span> <span data-ttu-id="5c5a7-159">Předchozí kód také ukazuje, že pomocí **modelu syntaxe** najít strukturu kódu; použijete **sémantický model** k pochopení jeho významu.</span><span class="sxs-lookup"><span data-stu-id="5c5a7-159">The preceding code also illustrates that you use the **syntax model** to find the structure of the code; you use the **semantic model** to understand its meaning.</span></span> <span data-ttu-id="5c5a7-160">Model **syntaxe** najde `System` řetězec v příkazu using.</span><span class="sxs-lookup"><span data-stu-id="5c5a7-160">The **syntax model** finds the string `System` in the using statement.</span></span> <span data-ttu-id="5c5a7-161">**Sémantický model** má všechny informace o `System` typech definovaných v oboru názvů.</span><span class="sxs-lookup"><span data-stu-id="5c5a7-161">The **semantic model** has all the information about the types defined in the `System` namespace.</span></span>

<span data-ttu-id="5c5a7-162">Z <xref:Microsoft.CodeAnalysis.SymbolInfo> objektu můžete <xref:Microsoft.CodeAnalysis.ISymbol?displayProperty=nameWithType> získat <xref:Microsoft.CodeAnalysis.SymbolInfo.Symbol?displayProperty=nameWithType> pomocí vlastnosti.</span><span class="sxs-lookup"><span data-stu-id="5c5a7-162">From the <xref:Microsoft.CodeAnalysis.SymbolInfo> object you can obtain the <xref:Microsoft.CodeAnalysis.ISymbol?displayProperty=nameWithType> using the <xref:Microsoft.CodeAnalysis.SymbolInfo.Symbol?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="5c5a7-163">Tato vlastnost vrátí symbol, na který tento výraz odkazuje.</span><span class="sxs-lookup"><span data-stu-id="5c5a7-163">This property returns the symbol this expression refers to.</span></span> <span data-ttu-id="5c5a7-164">Pro výrazy, které neodkazují na nic (například číselné `null`literály) tato vlastnost je .</span><span class="sxs-lookup"><span data-stu-id="5c5a7-164">For expressions that don't refer to anything (such as numeric literals) this property is `null`.</span></span> <span data-ttu-id="5c5a7-165">Pokud <xref:Microsoft.CodeAnalysis.SymbolInfo.Symbol?displayProperty=nameWithType> není null, <xref:Microsoft.CodeAnalysis.ISymbol.Kind?displayProperty=nameWithType> označuje typ symbolu.</span><span class="sxs-lookup"><span data-stu-id="5c5a7-165">When the <xref:Microsoft.CodeAnalysis.SymbolInfo.Symbol?displayProperty=nameWithType> is not null, the <xref:Microsoft.CodeAnalysis.ISymbol.Kind?displayProperty=nameWithType> denotes the type of the symbol.</span></span> <span data-ttu-id="5c5a7-166">V tomto příkladu <xref:Microsoft.CodeAnalysis.ISymbol.Kind?displayProperty=nameWithType> je <xref:Microsoft.CodeAnalysis.SymbolKind.Namespace?displayProperty=nameWithType>vlastnost .</span><span class="sxs-lookup"><span data-stu-id="5c5a7-166">In this example, the <xref:Microsoft.CodeAnalysis.ISymbol.Kind?displayProperty=nameWithType> property is a <xref:Microsoft.CodeAnalysis.SymbolKind.Namespace?displayProperty=nameWithType>.</span></span> <span data-ttu-id="5c5a7-167">Přidejte do `Main` metody následující kód.</span><span class="sxs-lookup"><span data-stu-id="5c5a7-167">Add the following code to your `Main` method.</span></span> <span data-ttu-id="5c5a7-168">Načte symbol pro `System` obor názvů a potom zobrazí všechny podřízené obory názvů deklarované v oboru `System` názvů:</span><span class="sxs-lookup"><span data-stu-id="5c5a7-168">It retrieves the symbol for the `System` namespace and then displays all the child namespaces declared in the `System` namespace:</span></span>

[!code-csharp[Display all the child namespaces](../../../../samples/snippets/csharp/roslyn-sdk/SemanticQuickStart/Program.cs#6 "Display all the child namespaces from this compilation")]

<span data-ttu-id="5c5a7-169">Spusťte program a měli byste vidět následující výstup:</span><span class="sxs-lookup"><span data-stu-id="5c5a7-169">Run the program and you should see the following output:</span></span>

```output
System.Collections
System.Configuration
System.Deployment
System.Diagnostics
System.Globalization
System.IO
System.Numerics
System.Reflection
System.Resources
System.Runtime
System.Security
System.StubHelpers
System.Text
System.Threading
Press any key to continue . . .
```

> [!NOTE]
> <span data-ttu-id="5c5a7-170">Výstup nezahrnuje každý obor názvů, který je `System` podřízeným oborem názvů oboru názvů.</span><span class="sxs-lookup"><span data-stu-id="5c5a7-170">The output does not include every namespace that is a child namespace of the `System` namespace.</span></span> <span data-ttu-id="5c5a7-171">Zobrazí každý obor názvů, který je přítomen v této `System.String` kompilaci, která odkazuje pouze na sestavení, kde je deklarována.</span><span class="sxs-lookup"><span data-stu-id="5c5a7-171">It displays every namespace that is present in this compilation, which only references the assembly where `System.String` is declared.</span></span> <span data-ttu-id="5c5a7-172">Všechny obory názvů deklarované v jiných sestaveních nejsou této kompilaci známy.</span><span class="sxs-lookup"><span data-stu-id="5c5a7-172">Any namespaces declared in other assemblies are not known to this compilation</span></span>

### <a name="binding-an-expression"></a><span data-ttu-id="5c5a7-173">Vazba výrazu</span><span class="sxs-lookup"><span data-stu-id="5c5a7-173">Binding an expression</span></span>

<span data-ttu-id="5c5a7-174">Předchozí kód ukazuje, jak najít symbol vazbou na název.</span><span class="sxs-lookup"><span data-stu-id="5c5a7-174">The preceding code shows how to find a symbol by binding to a name.</span></span> <span data-ttu-id="5c5a7-175">Existují jiné výrazy v programu Jazyka C#, které mohou být vázány, které nejsou názvy.</span><span class="sxs-lookup"><span data-stu-id="5c5a7-175">There are other expressions in a C# program that can be bound that aren't names.</span></span> <span data-ttu-id="5c5a7-176">Chcete-li demonstrovat tuto schopnost, pojďme přístup vazby na jednoduchý řetězec literál.</span><span class="sxs-lookup"><span data-stu-id="5c5a7-176">To demonstrate this capability, let's access the binding to a simple string literal.</span></span>

<span data-ttu-id="5c5a7-177">Program "Hello World" <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax?displayProperty=nameWithType>obsahuje program " Hello, World!"</span><span class="sxs-lookup"><span data-stu-id="5c5a7-177">The "Hello World" program contains a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax?displayProperty=nameWithType>, the "Hello, World!"</span></span> <span data-ttu-id="5c5a7-178">zobrazený řetězec na konzoli.</span><span class="sxs-lookup"><span data-stu-id="5c5a7-178">string displayed to the console.</span></span>

<span data-ttu-id="5c5a7-179">Najděte "Ahoj, světe!"</span><span class="sxs-lookup"><span data-stu-id="5c5a7-179">You find the "Hello, World!"</span></span> <span data-ttu-id="5c5a7-180">řetězce vyhledáním literálu jednoho řetězce v programu.</span><span class="sxs-lookup"><span data-stu-id="5c5a7-180">string by locating the single string literal in the program.</span></span> <span data-ttu-id="5c5a7-181">Poté, co jste lokalizovali uzel syntaxe, získejte informace o typu pro tento uzel ze sémantického modelu.</span><span class="sxs-lookup"><span data-stu-id="5c5a7-181">Then, once you've located the syntax node, get the type info for that node from the semantic model.</span></span> <span data-ttu-id="5c5a7-182">Do metody přidejte `Main` následující kód:</span><span class="sxs-lookup"><span data-stu-id="5c5a7-182">Add the following code to your `Main` method:</span></span>

[!code-csharp[Find the namespace symbol for the only using](../../../../samples/snippets/csharp/roslyn-sdk/SemanticQuickStart/Program.cs#7 "Find the namespace symbol for the only using")]

<span data-ttu-id="5c5a7-183"><xref:Microsoft.CodeAnalysis.TypeInfo?displayProperty=nameWithType> Struktura obsahuje <xref:Microsoft.CodeAnalysis.TypeInfo.Type?displayProperty=nameWithType> vlastnost, která umožňuje přístup k sémantické informace o typu literálu.</span><span class="sxs-lookup"><span data-stu-id="5c5a7-183">The <xref:Microsoft.CodeAnalysis.TypeInfo?displayProperty=nameWithType> struct includes a <xref:Microsoft.CodeAnalysis.TypeInfo.Type?displayProperty=nameWithType> property that enables access to the semantic information about the type of the literal.</span></span> <span data-ttu-id="5c5a7-184">V tomto příkladu `string` je to typ.</span><span class="sxs-lookup"><span data-stu-id="5c5a7-184">In this example, that's the `string` type.</span></span> <span data-ttu-id="5c5a7-185">Přidejte deklaraci, která přiřadí tuto vlastnost místní proměnné:</span><span class="sxs-lookup"><span data-stu-id="5c5a7-185">Add a declaration that assigns this property to a local variable:</span></span>

[!code-csharp[Find the semantic information about the string type](../../../../samples/snippets/csharp/roslyn-sdk/SemanticQuickStart/Program.cs#8 "Use the string literal to access the semantic information in the string type.")]

<span data-ttu-id="5c5a7-186">Chcete-li dokončit tento kurz, pojďme vytvořit dotaz LINQ, který vytvoří `string` posloupnost `string`všech veřejných metod deklarovaných na typu, které vracejí .</span><span class="sxs-lookup"><span data-stu-id="5c5a7-186">To finish this tutorial, let's build a LINQ query that creates a sequence of all the public methods declared on the `string` type that return a `string`.</span></span> <span data-ttu-id="5c5a7-187">Tento dotaz získá složité, takže pojďme jej vytvořit řádek po řádku, pak rekonstruovat jako jeden dotaz.</span><span class="sxs-lookup"><span data-stu-id="5c5a7-187">This query gets complex, so let's build it line by line, then reconstruct it as a single query.</span></span> <span data-ttu-id="5c5a7-188">Zdrojem pro tento dotaz je posloupnost `string` všech členů deklarovaných na typu:</span><span class="sxs-lookup"><span data-stu-id="5c5a7-188">The source for this query is the sequence of all members declared on the `string` type:</span></span>

[!code-csharp[Access the sequence of members on the string type](../../../../samples/snippets/csharp/roslyn-sdk/SemanticQuickStart/Program.cs#9 "Access the sequence of members on the string type.")]

<span data-ttu-id="5c5a7-189">Tato zdrojová sekvence obsahuje všechny členy, včetně vlastností a polí, proto je můžete filtrovat pomocí <xref:System.Collections.Immutable.ImmutableArray%601.OfType%2A?displayProperty=nameWithType> metody k vyhledání prvků, které jsou <xref:Microsoft.CodeAnalysis.IMethodSymbol?displayProperty=nameWithType> objekty:</span><span class="sxs-lookup"><span data-stu-id="5c5a7-189">That source sequence contains all members, including properties and fields, so filter it using the <xref:System.Collections.Immutable.ImmutableArray%601.OfType%2A?displayProperty=nameWithType> method to find elements that are <xref:Microsoft.CodeAnalysis.IMethodSymbol?displayProperty=nameWithType> objects:</span></span>

[!code-csharp[Filter the sequence to only methods](../../../../samples/snippets/csharp/roslyn-sdk/SemanticQuickStart/Program.cs#10 "Find the subset of the collection that is the methods.")]

<span data-ttu-id="5c5a7-190">Dále přidejte další filtr, který vrátí pouze `string`ty metody, které jsou veřejné, a vraťte :</span><span class="sxs-lookup"><span data-stu-id="5c5a7-190">Next, add another filter to return only those methods that are public and return a `string`:</span></span>

[!code-csharp[Filter on return type and accessibility](../../../../samples/snippets/csharp/roslyn-sdk/SemanticQuickStart/Program.cs#11 "Find only the public methods that return a string.")]

<span data-ttu-id="5c5a7-191">Vyberte pouze vlastnost name a pouze odlišné názvy odebráním všech přetížení:</span><span class="sxs-lookup"><span data-stu-id="5c5a7-191">Select only the name property, and only distinct names by removing any overloads:</span></span>

[!code-csharp[find the distinct names.](../../../../samples/snippets/csharp/roslyn-sdk/SemanticQuickStart/Program.cs#12 "Use the string literal to access the semantic information in the string type.")]

<span data-ttu-id="5c5a7-192">Můžete také vytvořit úplný dotaz pomocí syntaxe dotazu LINQ a potom zobrazit všechny názvy metod v konzole:</span><span class="sxs-lookup"><span data-stu-id="5c5a7-192">You can also build the full query using the LINQ query syntax, and then display all the method names in  the console:</span></span>

[!code-csharp[build and display the results of this query.](../../../../samples/snippets/csharp/roslyn-sdk/SemanticQuickStart/Program.cs#13 "Build and display the results of the query.")]

<span data-ttu-id="5c5a7-193">Sestavte a spusťte program.</span><span class="sxs-lookup"><span data-stu-id="5c5a7-193">Build and run the program.</span></span> <span data-ttu-id="5c5a7-194">Měl by se zobrazit následující výstup:</span><span class="sxs-lookup"><span data-stu-id="5c5a7-194">You should see the following output:</span></span>

```output
Join
Substring
Trim
TrimStart
TrimEnd
Normalize
PadLeft
PadRight
ToLower
ToLowerInvariant
ToUpper
ToUpperInvariant
ToString
Insert
Replace
Remove
Format
Copy
Concat
Intern
IsInterned
Press any key to continue . . .
```

<span data-ttu-id="5c5a7-195">Použili jste sémantické rozhraní API k vyhledání a zobrazení informací o symbolech, které jsou součástí tohoto programu.</span><span class="sxs-lookup"><span data-stu-id="5c5a7-195">You've used the Semantic API to find and display information about the symbols that are part of this program.</span></span>
