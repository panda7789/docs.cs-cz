---
title: Začínáme s analýzou syntaxe (rozhraní API Roslyn)
description: Úvod do procházení, dotazování a procházení stromů syntaxe.
ms.date: 02/05/2018
ms.custom: mvc
ms.openlocfilehash: 22d1303c9daa2ae35cf130b0c857cd7a5efdbe76
ms.sourcegitcommit: 43d10ef65f0f1fd6c3b515e363bde11a3fcd8d6d
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 03/03/2020
ms.locfileid: "78240510"
---
# <a name="get-started-with-syntax-analysis"></a><span data-ttu-id="b2c4b-103">Začínáme s analýzou syntaxe</span><span class="sxs-lookup"><span data-stu-id="b2c4b-103">Get started with syntax analysis</span></span>

<span data-ttu-id="b2c4b-104">V tomto kurzu prozkoumáte **rozhraní API syntaxe**.</span><span class="sxs-lookup"><span data-stu-id="b2c4b-104">In this tutorial, you'll explore the **Syntax API**.</span></span> <span data-ttu-id="b2c4b-105">Rozhraní API syntaxe poskytuje přístup k datovým strukturám, které C# popisují nebo Visual Basic program.</span><span class="sxs-lookup"><span data-stu-id="b2c4b-105">The Syntax API provides access to the data structures that describe a C# or Visual Basic program.</span></span> <span data-ttu-id="b2c4b-106">Tyto datové struktury mají dostatek podrobností, které mohou plně představovat libovolný program libovolné velikosti.</span><span class="sxs-lookup"><span data-stu-id="b2c4b-106">These data structures have enough detail that they can fully represent any program of any size.</span></span> <span data-ttu-id="b2c4b-107">Tyto struktury mohou popsat kompletní programy, které jsou zkompilovány a spouštěny správně.</span><span class="sxs-lookup"><span data-stu-id="b2c4b-107">These structures can describe complete programs that compile and run correctly.</span></span> <span data-ttu-id="b2c4b-108">Můžou také popsat nedokončené programy, jak je píšete v editoru.</span><span class="sxs-lookup"><span data-stu-id="b2c4b-108">They can also describe incomplete programs, as you write them, in the editor.</span></span>

<span data-ttu-id="b2c4b-109">Chcete-li povolit tento bohatý výraz, datové struktury a rozhraní API, které tvoří rozhraní API syntaxe, jsou nutně složité.</span><span class="sxs-lookup"><span data-stu-id="b2c4b-109">To enable this rich expression, the data structures and APIs that make up the Syntax API are necessarily complex.</span></span> <span data-ttu-id="b2c4b-110">Pojďme začít s tím, jak datová struktura vypadá jako typický program "Hello World":</span><span class="sxs-lookup"><span data-stu-id="b2c4b-110">Let's start with what the data structure looks like for the typical "Hello World" program:</span></span>

```csharp
using System;
using System.Collections.Generic;
using System.Linq;

namespace HelloWorld
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("Hello World!");
        }
    }
}
```

<span data-ttu-id="b2c4b-111">Podívejte se na text předchozího programu.</span><span class="sxs-lookup"><span data-stu-id="b2c4b-111">Look at the text of the previous program.</span></span> <span data-ttu-id="b2c4b-112">Rozpoznáváte známé prvky.</span><span class="sxs-lookup"><span data-stu-id="b2c4b-112">You recognize familiar elements.</span></span> <span data-ttu-id="b2c4b-113">Celý text představuje jeden zdrojový soubor nebo **jednotku kompilace**.</span><span class="sxs-lookup"><span data-stu-id="b2c4b-113">The entire text represents a single source file, or a **compilation unit**.</span></span> <span data-ttu-id="b2c4b-114">První tři řádky tohoto zdrojového souboru používají **direktivy**.</span><span class="sxs-lookup"><span data-stu-id="b2c4b-114">The first three lines of that source file are **using directives**.</span></span> <span data-ttu-id="b2c4b-115">Zbývající zdroj je obsažen v **deklaraci oboru názvů**.</span><span class="sxs-lookup"><span data-stu-id="b2c4b-115">The remaining source is contained in a **namespace declaration**.</span></span> <span data-ttu-id="b2c4b-116">Deklarace oboru názvů obsahuje **deklaraci podřízené třídy**.</span><span class="sxs-lookup"><span data-stu-id="b2c4b-116">The namespace declaration contains a child **class declaration**.</span></span> <span data-ttu-id="b2c4b-117">Deklarace třídy obsahuje jednu **deklaraci metody**.</span><span class="sxs-lookup"><span data-stu-id="b2c4b-117">The class declaration contains one **method declaration**.</span></span>

<span data-ttu-id="b2c4b-118">Rozhraní API syntaxe vytvoří stromovou strukturu s kořenovou jednotkou, která představuje kompilační jednotku.</span><span class="sxs-lookup"><span data-stu-id="b2c4b-118">The Syntax API creates a tree structure with the root representing the compilation unit.</span></span> <span data-ttu-id="b2c4b-119">Uzly ve stromové struktuře reprezentují direktivy using, deklaraci oboru názvů a všechny ostatní prvky programu.</span><span class="sxs-lookup"><span data-stu-id="b2c4b-119">Nodes in the tree represent the using directives, namespace declaration and all the other elements of the program.</span></span> <span data-ttu-id="b2c4b-120">Stromová struktura pokračuje na nejnižší úrovni: řetězec "Hello World!"</span><span class="sxs-lookup"><span data-stu-id="b2c4b-120">The tree structure continues down to the lowest levels: the string "Hello World!"</span></span> <span data-ttu-id="b2c4b-121">je **řetězcový literálový token** , který je odvozeným **argumentem**.</span><span class="sxs-lookup"><span data-stu-id="b2c4b-121">is a **string literal token** that is a descendent of an **argument**.</span></span> <span data-ttu-id="b2c4b-122">Rozhraní API syntaxe poskytuje přístup ke struktuře programu.</span><span class="sxs-lookup"><span data-stu-id="b2c4b-122">The Syntax API provides access to the structure of the program.</span></span> <span data-ttu-id="b2c4b-123">Můžete zadávat dotazy na konkrétní postupy kódu, procházet celý strom a porozumět kódu a vytvářet nové stromy úpravou stávajícího stromu.</span><span class="sxs-lookup"><span data-stu-id="b2c4b-123">You can query for specific code practices, walk the entire tree to understand the code, and create new trees by modifying the existing tree.</span></span>

<span data-ttu-id="b2c4b-124">Tento stručný popis poskytuje přehled o druhu dostupné informace pomocí rozhraní API syntaxe.</span><span class="sxs-lookup"><span data-stu-id="b2c4b-124">That brief description provides an overview of the kind of information accessible using the Syntax API.</span></span> <span data-ttu-id="b2c4b-125">Rozhraní API syntaxe není nic větší než formální rozhraní API, které popisuje známé konstrukce kódu, ze C#kterých se dozvíte.</span><span class="sxs-lookup"><span data-stu-id="b2c4b-125">The Syntax API is nothing more than a formal API that describes the familiar code constructs you know from C#.</span></span> <span data-ttu-id="b2c4b-126">Všechny možnosti obsahují informace o tom, jak je kód formátovaný, včetně konců řádků, mezer a odsazení.</span><span class="sxs-lookup"><span data-stu-id="b2c4b-126">The full capabilities include information about how the code is formatted including line breaks, white space, and indenting.</span></span> <span data-ttu-id="b2c4b-127">Pomocí těchto informací můžete kód plně vyjádřit jako zapsaný a načtený lidskými programátory nebo kompilátorem.</span><span class="sxs-lookup"><span data-stu-id="b2c4b-127">Using this information, you can fully represent the code as written and read by human programmers or the compiler.</span></span> <span data-ttu-id="b2c4b-128">Použití této struktury vám umožní pracovat se zdrojovým kódem na hluboko smysluplné úrovni.</span><span class="sxs-lookup"><span data-stu-id="b2c4b-128">Using this structure enables you to interact with the source code on a deeply meaningful level.</span></span> <span data-ttu-id="b2c4b-129">Již není to textový řetězec, ale data, která představují strukturu C# programu.</span><span class="sxs-lookup"><span data-stu-id="b2c4b-129">It's no longer text strings, but data that represents the structure of a C# program.</span></span>

<span data-ttu-id="b2c4b-130">Abyste mohli začít, musíte nainstalovat **sadu .NET Compiler Platform SDK**:</span><span class="sxs-lookup"><span data-stu-id="b2c4b-130">To get started, you'll need to install the **.NET Compiler Platform SDK**:</span></span>

[!INCLUDE[interactive-note](~/includes/roslyn-installation.md)]

## <a name="understanding-syntax-trees"></a><span data-ttu-id="b2c4b-131">Principy stromů syntaxe</span><span class="sxs-lookup"><span data-stu-id="b2c4b-131">Understanding syntax trees</span></span>

<span data-ttu-id="b2c4b-132">Použijete rozhraní API syntaxe pro jakoukoli analýzu struktury C# kódu.</span><span class="sxs-lookup"><span data-stu-id="b2c4b-132">You use the Syntax API for any analysis of the structure of C# code.</span></span> <span data-ttu-id="b2c4b-133">**Rozhraní API syntaxe** zveřejňuje analyzátory, stromy syntaxe a nástroje pro analýzu a sestavování stromů syntaxe.</span><span class="sxs-lookup"><span data-stu-id="b2c4b-133">The **Syntax API** exposes the parsers, the syntax trees, and utilities for analyzing and constructing syntax trees.</span></span> <span data-ttu-id="b2c4b-134">Je to způsob, jak hledat v kódu konkrétní prvky syntaxe, nebo si přečtěte kód pro program.</span><span class="sxs-lookup"><span data-stu-id="b2c4b-134">It's how you search code for specific syntax elements or read the code for a program.</span></span>

<span data-ttu-id="b2c4b-135">Strom syntaxe je datová struktura, kterou používají kompilátory C# a Visual Basic pro pochopení C# a Visual Basic programů.</span><span class="sxs-lookup"><span data-stu-id="b2c4b-135">A syntax tree is a data structure used by the C# and Visual Basic compilers to understand C# and Visual Basic programs.</span></span> <span data-ttu-id="b2c4b-136">Stromy syntaxí jsou vytvářeny stejným analyzátorem, který se spouští při sestavení projektu nebo v případě, že je vývojář povede na F5.</span><span class="sxs-lookup"><span data-stu-id="b2c4b-136">Syntax trees are produced by the same parser that runs when a project is built or a developer hits F5.</span></span> <span data-ttu-id="b2c4b-137">Stromy syntaxe mají plnou přesnost s jazykem; Všechny bitové informace v souboru kódu jsou reprezentovány ve stromové struktuře.</span><span class="sxs-lookup"><span data-stu-id="b2c4b-137">The syntax trees have full-fidelity with the language; every bit of information in a code file is represented in the tree.</span></span> <span data-ttu-id="b2c4b-138">Zápis stromu syntaxe do textu reprodukuje přesný původní text, který byl analyzován.</span><span class="sxs-lookup"><span data-stu-id="b2c4b-138">Writing a syntax tree to text reproduces the exact original text that was parsed.</span></span> <span data-ttu-id="b2c4b-139">Stromy syntaxe jsou také **neměnné**; Po vytvoření strom syntaxe nelze nikdy změnit.</span><span class="sxs-lookup"><span data-stu-id="b2c4b-139">The syntax trees are also **immutable**; once created a syntax tree can never be changed.</span></span> <span data-ttu-id="b2c4b-140">Uživatelé stromů mohou analyzovat stromy ve více vláknech, bez zámků nebo jiných měr souběžnosti, přičemž se data nikdy nemění.</span><span class="sxs-lookup"><span data-stu-id="b2c4b-140">Consumers of the trees can analyze the trees on multiple threads, without locks or other concurrency measures, knowing the data never changes.</span></span> <span data-ttu-id="b2c4b-141">Rozhraní API můžete použít k vytvoření nových stromů, které jsou výsledkem úprav existujícího stromu.</span><span class="sxs-lookup"><span data-stu-id="b2c4b-141">You can use APIs to create new trees that are the result of modifying an existing tree.</span></span>

<span data-ttu-id="b2c4b-142">Čtyři primární stavební kameny stromů syntaxe jsou:</span><span class="sxs-lookup"><span data-stu-id="b2c4b-142">The four primary building blocks of syntax trees are:</span></span>

* <span data-ttu-id="b2c4b-143">Třída <xref:Microsoft.CodeAnalysis.SyntaxTree?displayProperty=nameWithType>, instance, která představuje celý strom analýzy.</span><span class="sxs-lookup"><span data-stu-id="b2c4b-143">The <xref:Microsoft.CodeAnalysis.SyntaxTree?displayProperty=nameWithType> class, an instance of which represents an entire parse tree.</span></span> <span data-ttu-id="b2c4b-144"><xref:Microsoft.CodeAnalysis.SyntaxTree> je abstraktní třída, která obsahuje deriváty specifické pro jazyk.</span><span class="sxs-lookup"><span data-stu-id="b2c4b-144"><xref:Microsoft.CodeAnalysis.SyntaxTree> is an abstract class that has language-specific derivatives.</span></span> <span data-ttu-id="b2c4b-145">Metody Parse třídy <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree?displayProperty=nameWithType> (nebo <xref:Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxTree?displayProperty=nameWithType>) slouží k analýze textu C# nebo Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="b2c4b-145">You use the parse methods of the <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree?displayProperty=nameWithType> (or <xref:Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxTree?displayProperty=nameWithType>) class to parse text in C# or Visual Basic.</span></span>
* <span data-ttu-id="b2c4b-146"><xref:Microsoft.CodeAnalysis.SyntaxNode?displayProperty=nameWithType> třídy, jejichž instance reprezentují syntaktické konstrukce, jako jsou deklarace, příkazy, klauzule a výrazy.</span><span class="sxs-lookup"><span data-stu-id="b2c4b-146">The <xref:Microsoft.CodeAnalysis.SyntaxNode?displayProperty=nameWithType> class, instances of which represent syntactic constructs such as declarations, statements, clauses, and expressions.</span></span>
* <span data-ttu-id="b2c4b-147">Struktura <xref:Microsoft.CodeAnalysis.SyntaxToken?displayProperty=nameWithType>, která představuje jednotlivá klíčová slova, identifikátor, operátor nebo interpunkční znaménko.</span><span class="sxs-lookup"><span data-stu-id="b2c4b-147">The <xref:Microsoft.CodeAnalysis.SyntaxToken?displayProperty=nameWithType> structure, which represents an individual keyword, identifier, operator, or punctuation.</span></span>
* <span data-ttu-id="b2c4b-148">A nakonec <xref:Microsoft.CodeAnalysis.SyntaxTrivia?displayProperty=nameWithType> strukturu, která představuje syntakticky nevýznamné bity informací, jako jsou prázdné znaky mezi tokeny, direktivami předzpracování a komentáři.</span><span class="sxs-lookup"><span data-stu-id="b2c4b-148">And lastly the <xref:Microsoft.CodeAnalysis.SyntaxTrivia?displayProperty=nameWithType> structure, which represents syntactically insignificant bits of information such as the white space between tokens, preprocessing directives, and comments.</span></span>

<span data-ttu-id="b2c4b-149">Minihry, tokeny a uzly jsou vytvořeny hierarchicky pro vytvoření stromu, který zcela zastupuje vše v fragmentu Visual Basic nebo C# kódu.</span><span class="sxs-lookup"><span data-stu-id="b2c4b-149">Trivia, tokens, and nodes are composed hierarchically to form a tree that completely represents everything in a fragment of Visual Basic or C# code.</span></span> <span data-ttu-id="b2c4b-150">Tuto strukturu můžete zobrazit pomocí okna **syntax visualizer** .</span><span class="sxs-lookup"><span data-stu-id="b2c4b-150">You can see this structure using the **Syntax Visualizer** window.</span></span> <span data-ttu-id="b2c4b-151">V aplikaci Visual Studio vyberte možnost **zobrazit** > **jiné > systému Windows** **syntax visualizer**.</span><span class="sxs-lookup"><span data-stu-id="b2c4b-151">In Visual Studio, choose **View** > **Other Windows** > **Syntax Visualizer**.</span></span> <span data-ttu-id="b2c4b-152">Například předchozí C# zdrojový soubor testovaný pomocí **syntax visualizer** vypadá jako na následujícím obrázku:</span><span class="sxs-lookup"><span data-stu-id="b2c4b-152">For example, the preceding C# source file examined using the **Syntax Visualizer** looks like the following figure:</span></span>

<span data-ttu-id="b2c4b-153">**SyntaxNode**: Blue | **SyntaxToken**: zelená | **SyntaxTrivia**: Red ![C# soubor kódu](media/walkthrough-csharp-syntax-figure1.png)</span><span class="sxs-lookup"><span data-stu-id="b2c4b-153">**SyntaxNode**: Blue | **SyntaxToken**: Green | **SyntaxTrivia**: Red ![C# Code File](media/walkthrough-csharp-syntax-figure1.png)</span></span>

<span data-ttu-id="b2c4b-154">Přechodem na tuto stromovou strukturu můžete v souboru kódu najít libovolný příkaz, výraz, token nebo bitovou kopii prázdného místa.</span><span class="sxs-lookup"><span data-stu-id="b2c4b-154">By navigating this tree structure, you can find any statement, expression, token, or bit of white space in a code file.</span></span>

<span data-ttu-id="b2c4b-155">I když můžete najít cokoli v souboru kódu pomocí rozhraní API syntaxe, Většina scénářů zahrnuje zkoumání malých fragmentů kódu nebo hledání konkrétních příkazů nebo fragmentů.</span><span class="sxs-lookup"><span data-stu-id="b2c4b-155">While you can find anything in a code file using the Syntax APIs, most scenarios involve examining small snippets of code, or searching for particular statements or fragments.</span></span> <span data-ttu-id="b2c4b-156">Následující dva příklady ukazují typické použití pro procházení struktury kódu nebo hledání jednoduchých příkazů.</span><span class="sxs-lookup"><span data-stu-id="b2c4b-156">The two examples that follow show typical uses to browse the structure of code, or search for single statements.</span></span>

## <a name="traversing-trees"></a><span data-ttu-id="b2c4b-157">Procházení stromů</span><span class="sxs-lookup"><span data-stu-id="b2c4b-157">Traversing trees</span></span>

<span data-ttu-id="b2c4b-158">Uzly ve stromu syntaxe můžete prozkoumávat dvěma způsoby.</span><span class="sxs-lookup"><span data-stu-id="b2c4b-158">You can examine the nodes in a syntax tree in two ways.</span></span> <span data-ttu-id="b2c4b-159">Můžete procházet stromovou strukturou a prozkoumávat jednotlivé uzly, nebo se můžete dotazovat na konkrétní prvky nebo uzly.</span><span class="sxs-lookup"><span data-stu-id="b2c4b-159">You can traverse the tree to examine each node, or you can query for specific elements or nodes.</span></span>

### <a name="manual-traversal"></a><span data-ttu-id="b2c4b-160">Ruční procházení</span><span class="sxs-lookup"><span data-stu-id="b2c4b-160">Manual traversal</span></span>

<span data-ttu-id="b2c4b-161">Dokončený kód pro tuto ukázku najdete v [našem úložišti GitHub](https://github.com/dotnet/samples/tree/master/csharp/roslyn-sdk/SyntaxQuickStart).</span><span class="sxs-lookup"><span data-stu-id="b2c4b-161">You can see the finished code for this sample in [our GitHub repository](https://github.com/dotnet/samples/tree/master/csharp/roslyn-sdk/SyntaxQuickStart).</span></span>

> [!NOTE]
> <span data-ttu-id="b2c4b-162">Typy stromové struktury syntaxe používají dědičnost k popisu různých syntaktických prvků, které jsou platné v různých umístěních v programu.</span><span class="sxs-lookup"><span data-stu-id="b2c4b-162">The Syntax Tree types use inheritance to describe the different syntax elements that are valid at different locations in the program.</span></span> <span data-ttu-id="b2c4b-163">Použití těchto rozhraní API často znamená přetypování vlastností nebo členů kolekce na konkrétní odvozené typy.</span><span class="sxs-lookup"><span data-stu-id="b2c4b-163">Using these APIs often means casting properties or collection members to specific derived types.</span></span> <span data-ttu-id="b2c4b-164">V následujících příkladech je přiřazení a přetypování samostatné příkazy pomocí explicitně typových proměnných.</span><span class="sxs-lookup"><span data-stu-id="b2c4b-164">In the following examples, the assignment and the casts are separate statements, using explicitly typed variables.</span></span> <span data-ttu-id="b2c4b-165">Můžete si přečíst kód a zobrazit návratové typy rozhraní API a typ modulu runtime vrácených objektů.</span><span class="sxs-lookup"><span data-stu-id="b2c4b-165">You can read the code to see the return types of the API and the runtime type of the objects returned.</span></span> <span data-ttu-id="b2c4b-166">V praxi je obvyklejší používat implicitně typové proměnné a spoléhat na názvy rozhraní API k popisu typu testovaných objektů.</span><span class="sxs-lookup"><span data-stu-id="b2c4b-166">In practice, it's more common to use implicitly typed variables and rely on API names to describe the type of objects being examined.</span></span>

<span data-ttu-id="b2c4b-167">Vytvořit nový C# projekt **Nástroje pro analýzu samostatného kódu** :</span><span class="sxs-lookup"><span data-stu-id="b2c4b-167">Create a new C# **Stand-Alone Code Analysis Tool** project:</span></span>

* <span data-ttu-id="b2c4b-168">V aplikaci Visual Studio vyberte **soubor** > **Nový** > **projekt** . zobrazí se dialogové okno Nový projekt.</span><span class="sxs-lookup"><span data-stu-id="b2c4b-168">In Visual Studio, choose **File** > **New** > **Project** to display the New Project dialog.</span></span>
* <span data-ttu-id="b2c4b-169">V části **rozšiřitelnost** **vizuálního C#**  > vyberte **Nástroj pro analýzu**samostatného kódu.</span><span class="sxs-lookup"><span data-stu-id="b2c4b-169">Under **Visual C#** > **Extensibility**, choose **Stand-Alone Code Analysis Tool**.</span></span>
* <span data-ttu-id="b2c4b-170">Pojmenujte projekt "**SyntaxTreeManualTraversal**" a klikněte na tlačítko OK.</span><span class="sxs-lookup"><span data-stu-id="b2c4b-170">Name your project "**SyntaxTreeManualTraversal**" and click OK.</span></span>

<span data-ttu-id="b2c4b-171">Chystáte se analyzovat základní "Hello World!"</span><span class="sxs-lookup"><span data-stu-id="b2c4b-171">You're going to analyze the basic "Hello World!"</span></span> <span data-ttu-id="b2c4b-172">program byl zobrazen výše.</span><span class="sxs-lookup"><span data-stu-id="b2c4b-172">program shown earlier.</span></span>
<span data-ttu-id="b2c4b-173">Do `Program` třídy přidejte text pro Hello World program jako konstantu:</span><span class="sxs-lookup"><span data-stu-id="b2c4b-173">Add the text for the Hello World program as a constant in your `Program` class:</span></span>

[!code-csharp[Declare the program text](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxQuickStart/HelloSyntaxTree/Program.cs#1 "Declare a constant string for the program text to analyze")]

<span data-ttu-id="b2c4b-174">Dále přidejte následující kód, který sestaví **strom syntaxe** pro text kódu v konstantě `programText`.</span><span class="sxs-lookup"><span data-stu-id="b2c4b-174">Next, add the following code to build the **syntax tree** for the code text in the `programText` constant.</span></span>  <span data-ttu-id="b2c4b-175">Do metody `Main` přidejte následující řádek:</span><span class="sxs-lookup"><span data-stu-id="b2c4b-175">Add the following line to your `Main` method:</span></span>

[!code-csharp[Create the tree](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxQuickStart/HelloSyntaxTree/Program.cs#2 "Create the syntax tree")]

<span data-ttu-id="b2c4b-176">Tyto dva řádky vytvoří strom a načtou kořenový uzel tohoto stromu.</span><span class="sxs-lookup"><span data-stu-id="b2c4b-176">Those two lines create the tree and retrieve the root node of that tree.</span></span> <span data-ttu-id="b2c4b-177">Nyní můžete zkontrolovat uzly ve stromové struktuře.</span><span class="sxs-lookup"><span data-stu-id="b2c4b-177">You can now examine the nodes in the tree.</span></span> <span data-ttu-id="b2c4b-178">Přidejte tyto řádky do metody `Main` pro zobrazení některých vlastností kořenového uzlu ve stromové struktuře:</span><span class="sxs-lookup"><span data-stu-id="b2c4b-178">Add these lines to your `Main` method to display some of the properties of the root node in the tree:</span></span>

[!code-csharp[Examine the root node](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxQuickStart/HelloSyntaxTree/Program.cs#3 "Examine the root node")]

<span data-ttu-id="b2c4b-179">Spusťte aplikaci, abyste viděli, jak kód zjistil kořenový uzel v tomto stromu.</span><span class="sxs-lookup"><span data-stu-id="b2c4b-179">Run the application to see what your code has discovered about the root node in this tree.</span></span>

<span data-ttu-id="b2c4b-180">Obvykle byste procházeli procházením stromu, abyste se dozvěděli o kódu.</span><span class="sxs-lookup"><span data-stu-id="b2c4b-180">Typically, you'd traverse the tree to learn about the code.</span></span> <span data-ttu-id="b2c4b-181">V tomto příkladu analyzujete kód, který znáte pro zkoumání rozhraní API.</span><span class="sxs-lookup"><span data-stu-id="b2c4b-181">In this example, you're analyzing code you know to explore the APIs.</span></span> <span data-ttu-id="b2c4b-182">Přidejte následující kód pro prohlédnutí prvního členu `root` uzlu:</span><span class="sxs-lookup"><span data-stu-id="b2c4b-182">Add the following code to examine the first member of the `root` node:</span></span>

[!code-csharp[Find the first member](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxQuickStart/HelloSyntaxTree/Program.cs#4 "Find the first member")]

<span data-ttu-id="b2c4b-183">Tento člen je <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="b2c4b-183">That member is a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax?displayProperty=nameWithType>.</span></span> <span data-ttu-id="b2c4b-184">Představuje vše v rozsahu deklarace `namespace HelloWorld`.</span><span class="sxs-lookup"><span data-stu-id="b2c4b-184">It represents everything in the scope of the `namespace HelloWorld` declaration.</span></span> <span data-ttu-id="b2c4b-185">Přidejte následující kód k prohlédnutí uzlů, které jsou deklarovány v oboru názvů `HelloWorld`:</span><span class="sxs-lookup"><span data-stu-id="b2c4b-185">Add the following code to examine what nodes are declared inside the `HelloWorld` namespace:</span></span>

[!code-csharp[Find the class declaration](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxQuickStart/HelloSyntaxTree/Program.cs#5 "Find the class declaration")]

<span data-ttu-id="b2c4b-186">Spusťte program a podívejte se, co jste se naučili.</span><span class="sxs-lookup"><span data-stu-id="b2c4b-186">Run the program to see what you've learned.</span></span>

<span data-ttu-id="b2c4b-187">Teď, když víte, že je deklarace <xref:Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax?displayProperty=nameWithType>, deklarujte novou proměnnou tohoto typu pro prohlédnutí deklarace třídy.</span><span class="sxs-lookup"><span data-stu-id="b2c4b-187">Now that you know the declaration is a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax?displayProperty=nameWithType>, declare a new variable of that type to examine the class declaration.</span></span> <span data-ttu-id="b2c4b-188">Tato třída obsahuje pouze jednoho člena: metodu `Main`.</span><span class="sxs-lookup"><span data-stu-id="b2c4b-188">This class only contains one member: the `Main` method.</span></span> <span data-ttu-id="b2c4b-189">Přidejte následující kód k nalezení `Main` metody a přetypujte ji na <xref:Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="b2c4b-189">Add the following code to find the `Main` method, and cast it to a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax?displayProperty=nameWithType>.</span></span>

[!code-csharp[Find the main declaration](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxQuickStart/HelloSyntaxTree/Program.cs#6 "Find the main declaration")]

<span data-ttu-id="b2c4b-190">Uzel deklarace metody obsahuje všechny syntaktické informace o metodě.</span><span class="sxs-lookup"><span data-stu-id="b2c4b-190">The method declaration node contains all the syntactic information about the method.</span></span> <span data-ttu-id="b2c4b-191">Pojďme zobrazit návratový typ metody `Main`, číslo a typy argumentů a text těla metody.</span><span class="sxs-lookup"><span data-stu-id="b2c4b-191">Let's display the return type of the `Main` method, the number and types of the arguments, and the body text of the method.</span></span> <span data-ttu-id="b2c4b-192">Přidejte následující kód:</span><span class="sxs-lookup"><span data-stu-id="b2c4b-192">Add the following code:</span></span>

[!code-csharp[Examine the syntax of the main method](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxQuickStart/HelloSyntaxTree/Program.cs#7 "Display information about the main method")]

<span data-ttu-id="b2c4b-193">Spuštěním programu zobrazíte všechny informace, které jste zjistili o tomto programu:</span><span class="sxs-lookup"><span data-stu-id="b2c4b-193">Run the program to see all the information you've discovered about this program:</span></span>

```text
The tree is a CompilationUnit node.
The tree has 1 elements in it.
The tree has 4 using statements. They are:
        System
        System.Collections
        System.Linq
        System.Text
The first member is a NamespaceDeclaration.
There are 1 members declared in this namespace.
The first member is a ClassDeclaration.
There are 1 members declared in the Program class.
The first member is a MethodDeclaration.
The return type of the Main method is void.
The method has 1 parameters.
The type of the args parameter is string[].
The body text of the Main method follows:
        {
            Console.WriteLine("Hello, World!");
        }
```

### <a name="query-methods"></a><span data-ttu-id="b2c4b-194">Metody dotazů</span><span class="sxs-lookup"><span data-stu-id="b2c4b-194">Query methods</span></span>

<span data-ttu-id="b2c4b-195">Kromě procházení stromů můžete také prozkoumat strom syntaxe pomocí metod dotazů definovaných v <xref:Microsoft.CodeAnalysis.SyntaxNode?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="b2c4b-195">In addition to traversing trees, you can also explore the syntax tree using the query methods defined on <xref:Microsoft.CodeAnalysis.SyntaxNode?displayProperty=nameWithType>.</span></span> <span data-ttu-id="b2c4b-196">Tyto metody by se měly hned seznámit s kýmkoli, kdo zná výraz XPath.</span><span class="sxs-lookup"><span data-stu-id="b2c4b-196">These methods should be immediately familiar to anyone familiar with XPath.</span></span> <span data-ttu-id="b2c4b-197">Tyto metody můžete použít spolu s LINQ k rychlému vyhledání položek ve stromové struktuře.</span><span class="sxs-lookup"><span data-stu-id="b2c4b-197">You can use these methods with LINQ to quickly find things in a tree.</span></span> <span data-ttu-id="b2c4b-198"><xref:Microsoft.CodeAnalysis.SyntaxNode> obsahuje metody dotazů jako <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodes%2A>, <xref:Microsoft.CodeAnalysis.SyntaxNode.AncestorsAndSelf%2A> a <xref:Microsoft.CodeAnalysis.SyntaxNode.ChildNodes%2A>.</span><span class="sxs-lookup"><span data-stu-id="b2c4b-198">The <xref:Microsoft.CodeAnalysis.SyntaxNode> has query methods such as <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodes%2A>, <xref:Microsoft.CodeAnalysis.SyntaxNode.AncestorsAndSelf%2A> and <xref:Microsoft.CodeAnalysis.SyntaxNode.ChildNodes%2A>.</span></span>

<span data-ttu-id="b2c4b-199">Pomocí těchto metod dotazů můžete najít argument metody `Main` jako alternativu k navigaci stromu.</span><span class="sxs-lookup"><span data-stu-id="b2c4b-199">You can use these query methods to find the argument to the `Main` method as an alternative to navigating the tree.</span></span> <span data-ttu-id="b2c4b-200">Do dolní části `Main` metody přidejte následující kód:</span><span class="sxs-lookup"><span data-stu-id="b2c4b-200">Add the following code to the bottom of your `Main` method:</span></span>

[!code-csharp[Query the tree for the arguments to Main](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxQuickStart/HelloSyntaxTree/Program.cs#8 "Query the tree for the arguments to Main")]

<span data-ttu-id="b2c4b-201">První příkaz používá výraz LINQ a metodu <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodes%2A> k vyhledání stejného parametru jako v předchozím příkladu.</span><span class="sxs-lookup"><span data-stu-id="b2c4b-201">The first statement uses a LINQ expression and the <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodes%2A> method to locate the same parameter as in the previous example.</span></span>

<span data-ttu-id="b2c4b-202">Spusťte program a uvidíte, že výraz LINQ našel stejný parametr jako ruční navigace ve stromu.</span><span class="sxs-lookup"><span data-stu-id="b2c4b-202">Run the program, and you can see that the LINQ expression found the same parameter as manually navigating the tree.</span></span>

<span data-ttu-id="b2c4b-203">Ukázka používá `WriteLine` příkazy pro zobrazení informací o stromech syntaxe při jejich procházení.</span><span class="sxs-lookup"><span data-stu-id="b2c4b-203">The sample uses `WriteLine` statements to display information about the syntax trees as they are traversed.</span></span> <span data-ttu-id="b2c4b-204">Další informace můžete získat také spuštěním dokončeného programu v rámci ladicího programu.</span><span class="sxs-lookup"><span data-stu-id="b2c4b-204">You can also learn much more by running the finished program under the debugger.</span></span> <span data-ttu-id="b2c4b-205">Můžete prozkoumávat více vlastností a metod, které jsou součástí stromu syntaxe vytvořeného pro program Hello World.</span><span class="sxs-lookup"><span data-stu-id="b2c4b-205">You can examine more of the properties and methods that are part of the syntax tree created for the hello world program.</span></span>

## <a name="syntax-walkers"></a><span data-ttu-id="b2c4b-206">Průvodce syntaxí</span><span class="sxs-lookup"><span data-stu-id="b2c4b-206">Syntax walkers</span></span>

<span data-ttu-id="b2c4b-207">Často chcete najít všechny uzly určitého typu ve stromu syntaxe, například každou deklaraci vlastnosti v souboru.</span><span class="sxs-lookup"><span data-stu-id="b2c4b-207">Often you want to find all nodes of a specific type in a syntax tree, for example, every property declaration in a file.</span></span> <span data-ttu-id="b2c4b-208">Rozšířením třídy <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker?displayProperty=nameWithType> a přepsáním <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitPropertyDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax)> metody zpracováváte všechny deklarace vlastností ve stromu syntaxe, aniž byste museli svou strukturu předem znát.</span><span class="sxs-lookup"><span data-stu-id="b2c4b-208">By extending the <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker?displayProperty=nameWithType> class and overriding the <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitPropertyDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax)> method, you process every property declaration in a syntax tree without knowing its structure beforehand.</span></span> <span data-ttu-id="b2c4b-209"><xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker> je konkrétní druh <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor>, který rekurzivně navštíví uzel a každý z jeho podřízených objektů.</span><span class="sxs-lookup"><span data-stu-id="b2c4b-209"><xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker> is a specific kind of <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor> that recursively visits a node and each of its children.</span></span>

<span data-ttu-id="b2c4b-210">Tento příklad implementuje <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker>, který prověřuje strom syntaxe.</span><span class="sxs-lookup"><span data-stu-id="b2c4b-210">This example implements a <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker> that examines a syntax tree.</span></span> <span data-ttu-id="b2c4b-211">Shromažďuje `using` direktivy, které zjistí, že neimportují obor názvů `System`.</span><span class="sxs-lookup"><span data-stu-id="b2c4b-211">It collects `using` directives it finds that aren't importing a `System` namespace.</span></span>

<span data-ttu-id="b2c4b-212">Vytvořit nový C# projekt **Nástroje pro analýzu samostatného kódu** ; pojmenujte ho "**SyntaxWalker**".</span><span class="sxs-lookup"><span data-stu-id="b2c4b-212">Create a new C# **Stand-Alone Code Analysis Tool** project; name it "**SyntaxWalker**."</span></span>

<span data-ttu-id="b2c4b-213">Dokončený kód pro tuto ukázku najdete v [našem úložišti GitHub](https://github.com/dotnet/samples/tree/master/csharp/roslyn-sdk/SyntaxQuickStart).</span><span class="sxs-lookup"><span data-stu-id="b2c4b-213">You can see the finished code for this sample in [our GitHub repository](https://github.com/dotnet/samples/tree/master/csharp/roslyn-sdk/SyntaxQuickStart).</span></span> <span data-ttu-id="b2c4b-214">Ukázka na GitHubu obsahuje oba projekty popsané v tomto kurzu.</span><span class="sxs-lookup"><span data-stu-id="b2c4b-214">The sample on GitHub contains both projects described in this tutorial.</span></span>

<span data-ttu-id="b2c4b-215">Stejně jako v předchozím příkladu můžete definovat řetězcovou konstantu, která bude obsahovat text programu, který budete analyzovat:</span><span class="sxs-lookup"><span data-stu-id="b2c4b-215">As in the previous sample, you can define a string constant to hold the text of the program you're going to analyze:</span></span>

[!code-csharp[Define the code text to analyzer](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxQuickStart/SyntaxWalker/Program.cs#1 "Define the program text to analyze")]

<span data-ttu-id="b2c4b-216">Tento zdrojový text obsahuje `using` direktivy rozptýlené ve čtyřech různých umístěních: na úrovni souboru v oboru názvů nejvyšší úrovně a ve dvou vnořených oborech názvů.</span><span class="sxs-lookup"><span data-stu-id="b2c4b-216">This source text contains `using` directives scattered across four different locations: the file-level, in the top-level namespace, and in the two nested namespaces.</span></span> <span data-ttu-id="b2c4b-217">Tento příklad zvýrazní základní scénář použití třídy <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker> pro dotazování kódu.</span><span class="sxs-lookup"><span data-stu-id="b2c4b-217">This example highlights a core scenario for using the <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker> class to query code.</span></span> <span data-ttu-id="b2c4b-218">Je nenáročný na návštěvu všech uzlů v kořenovém stromu syntaxe pro vyhledání pomocí deklarací.</span><span class="sxs-lookup"><span data-stu-id="b2c4b-218">It would be cumbersome to visit every node in the root syntax tree to find using declarations.</span></span> <span data-ttu-id="b2c4b-219">Místo toho můžete vytvořit odvozenou třídu a přepsat metodu, která bude volána pouze v případě, že aktuální uzel ve stromové struktuře je Direktiva using.</span><span class="sxs-lookup"><span data-stu-id="b2c4b-219">Instead, you create a derived class and override the method that gets called only when the current node in the tree is a using directive.</span></span> <span data-ttu-id="b2c4b-220">Váš návštěvník neprovádí žádnou práci na žádném jiném typu uzlu.</span><span class="sxs-lookup"><span data-stu-id="b2c4b-220">Your visitor does not do any work on any other node types.</span></span> <span data-ttu-id="b2c4b-221">Tato jediná metoda prověřuje jednotlivé příkazy `using` a vytvoří kolekci oborů názvů, které nejsou v oboru názvů `System`.</span><span class="sxs-lookup"><span data-stu-id="b2c4b-221">This single method examines each of the `using` statements and builds a collection of the namespaces that aren't in the `System` namespace.</span></span> <span data-ttu-id="b2c4b-222">Sestavíte <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker>, který prověřuje všechny příkazy `using`, ale pouze příkazy `using`.</span><span class="sxs-lookup"><span data-stu-id="b2c4b-222">You build a <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker> that examines all the `using` statements, but only the `using` statements.</span></span>

<span data-ttu-id="b2c4b-223">Nyní, když jste definovali text programu, je třeba vytvořit `SyntaxTree` a získat kořen této stromové struktury:</span><span class="sxs-lookup"><span data-stu-id="b2c4b-223">Now that you've defined the program text, you need to create a `SyntaxTree` and get the root of that tree:</span></span>

[!code-csharp[Create the Syntax tree and access the root](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxQuickStart/SyntaxWalker/Program.cs#2 "Create the Syntax tree and access the root node.")]

<span data-ttu-id="b2c4b-224">Dále vytvořte novou třídu.</span><span class="sxs-lookup"><span data-stu-id="b2c4b-224">Next, create a new class.</span></span> <span data-ttu-id="b2c4b-225">V aplikaci Visual Studio vyberte **projekt** > **Přidat novou položku**.</span><span class="sxs-lookup"><span data-stu-id="b2c4b-225">In Visual Studio, choose **Project** > **Add New Item**.</span></span> <span data-ttu-id="b2c4b-226">V dialogovém okně **Přidat novou položku** jako název souboru zadejte *UsingCollector.cs* .</span><span class="sxs-lookup"><span data-stu-id="b2c4b-226">In the **Add New Item** dialog type *UsingCollector.cs* as the filename.</span></span>

<span data-ttu-id="b2c4b-227">Implementujete funkci `using` návštěvníka ve třídě `UsingCollector`.</span><span class="sxs-lookup"><span data-stu-id="b2c4b-227">You implement the `using` visitor functionality in the `UsingCollector` class.</span></span> <span data-ttu-id="b2c4b-228">Začněte tím, že třídu `UsingCollector` odvodíte z <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker>.</span><span class="sxs-lookup"><span data-stu-id="b2c4b-228">Start by making the `UsingCollector` class derive from <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker>.</span></span>

[!code-csharp[Declare the base class for the using collector](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxQuickStart/SyntaxWalker/UsingCollector.cs#3 "Declare the base class for the UsingCollector")]

<span data-ttu-id="b2c4b-229">Pro uložení uzlů oboru názvů, které shromažďujete, potřebujete úložiště.</span><span class="sxs-lookup"><span data-stu-id="b2c4b-229">You need storage to hold the namespace nodes that you're collecting.</span></span>  <span data-ttu-id="b2c4b-230">Deklarace veřejné vlastnosti jen pro čtení ve třídě `UsingCollector`; pomocí této proměnné můžete ukládat <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax> uzly, které najdete:</span><span class="sxs-lookup"><span data-stu-id="b2c4b-230">Declare a public read-only property in the `UsingCollector` class; you use this variable to store the <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax> nodes you find:</span></span>

[!code-csharp[Declare storage for the using syntax nodes](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxQuickStart/SyntaxWalker/UsingCollector.cs#4 "Declare storage for the using syntax nodes")]

<span data-ttu-id="b2c4b-231">Základní třída <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker> implementuje logiku pro návštěvě každého uzlu ve stromové struktuře syntaxe.</span><span class="sxs-lookup"><span data-stu-id="b2c4b-231">The base class, <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker> implements the logic to visit each node in the syntax tree.</span></span> <span data-ttu-id="b2c4b-232">Odvozená třída Přepisuje metody volané pro konkrétní uzly, které vás zajímají.</span><span class="sxs-lookup"><span data-stu-id="b2c4b-232">The derived class overrides the methods called for the specific nodes you're interested in.</span></span> <span data-ttu-id="b2c4b-233">V takovém případě vás zajímá jakákoli `using` direktiva.</span><span class="sxs-lookup"><span data-stu-id="b2c4b-233">In this case, you're interested in any `using` directive.</span></span> <span data-ttu-id="b2c4b-234">To znamená, že je nutné přepsat metodu <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitUsingDirective(Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax)>.</span><span class="sxs-lookup"><span data-stu-id="b2c4b-234">That means you must override the <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitUsingDirective(Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax)> method.</span></span> <span data-ttu-id="b2c4b-235">Jedním z argumentů této metody je objekt <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="b2c4b-235">The one argument to this method is a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax?displayProperty=nameWithType> object.</span></span> <span data-ttu-id="b2c4b-236">To je důležitou výhodou pro použití návštěvníků: volá přepsané metody s argumenty, které už jsou přetypování na konkrétní typ uzlu.</span><span class="sxs-lookup"><span data-stu-id="b2c4b-236">That's an important advantage to using the visitors: they call the overridden methods with arguments already cast to the specific node type.</span></span> <span data-ttu-id="b2c4b-237">Třída <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax?displayProperty=nameWithType> obsahuje vlastnost <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax.Name>, která ukládá název importovaného oboru názvů.</span><span class="sxs-lookup"><span data-stu-id="b2c4b-237">The <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax?displayProperty=nameWithType> class has a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax.Name> property that stores the name of the namespace being imported.</span></span> <span data-ttu-id="b2c4b-238">Je <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="b2c4b-238">It is a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax?displayProperty=nameWithType>.</span></span> <span data-ttu-id="b2c4b-239">Do přepsání <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitUsingDirective(Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax)> přidejte následující kód:</span><span class="sxs-lookup"><span data-stu-id="b2c4b-239">Add the following code in the <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitUsingDirective(Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax)> override:</span></span>

[!code-csharp[Examine using nodes for the System namespace](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxQuickStart/SyntaxWalker/UsingCollector.cs#5 "Examine all using nodes for the System namespace.")]

<span data-ttu-id="b2c4b-240">Stejně jako v předchozím příkladu jste přidali celou řadu `WriteLine` příkazů, které pomáhají pochopit tuto metodu.</span><span class="sxs-lookup"><span data-stu-id="b2c4b-240">As with the earlier example, you've added a variety of `WriteLine` statements to aid in understanding of this method.</span></span> <span data-ttu-id="b2c4b-241">Můžete vidět, kdy se volá a kde se do něj předávají argumenty.</span><span class="sxs-lookup"><span data-stu-id="b2c4b-241">You can see when it's called, and what arguments are passed to it each time.</span></span>

<span data-ttu-id="b2c4b-242">Nakonec potřebujete přidat dva řádky kódu pro vytvoření `UsingCollector` a pokaždé, když navštívíte kořenový uzel a budete shromažďovat všechny příkazy `using`.</span><span class="sxs-lookup"><span data-stu-id="b2c4b-242">Finally, you need to add two lines of code to create the `UsingCollector` and have it visit the root node, collecting all the `using` statements.</span></span> <span data-ttu-id="b2c4b-243">Pak přidejte smyčku `foreach` pro zobrazení všech příkazů `using`, které kolekce nalezla:</span><span class="sxs-lookup"><span data-stu-id="b2c4b-243">Then, add a `foreach` loop to display all the `using` statements your collector found:</span></span>

[!code-csharp[Create the UsingCollector and visit the root node.](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxQuickStart/SyntaxWalker/Program.cs#6 "Create the UsingCollector and visit the root node.")]

<span data-ttu-id="b2c4b-244">Zkompilujte a spusťte program.</span><span class="sxs-lookup"><span data-stu-id="b2c4b-244">Compile and run the program.</span></span> <span data-ttu-id="b2c4b-245">Měl by se zobrazit následující výstup:</span><span class="sxs-lookup"><span data-stu-id="b2c4b-245">You should see the following output:</span></span>

```console
        VisitUsingDirective called with System.
        VisitUsingDirective called with System.Collections.Generic.
        VisitUsingDirective called with System.Linq.
        VisitUsingDirective called with System.Text.
        VisitUsingDirective called with Microsoft.CodeAnalysis.
                Success. Adding Microsoft.CodeAnalysis.
        VisitUsingDirective called with Microsoft.CodeAnalysis.CSharp.
                Success. Adding Microsoft.CodeAnalysis.CSharp.
        VisitUsingDirective called with Microsoft.
                Success. Adding Microsoft.
        VisitUsingDirective called with System.ComponentModel.
        VisitUsingDirective called with Microsoft.Win32.
                Success. Adding Microsoft.Win32.
        VisitUsingDirective called with System.Runtime.InteropServices.
        VisitUsingDirective called with System.CodeDom.
        VisitUsingDirective called with Microsoft.CSharp.
                Success. Adding Microsoft.CSharp.
Microsoft.CodeAnalysis
Microsoft.CodeAnalysis.CSharp
Microsoft
Microsoft.Win32
Microsoft.CSharp
Press any key to continue . . .
```

<span data-ttu-id="b2c4b-246">Blahopřejeme!</span><span class="sxs-lookup"><span data-stu-id="b2c4b-246">Congratulations!</span></span> <span data-ttu-id="b2c4b-247">Použili jste **rozhraní API syntaxe** k vyhledání konkrétních druhů C# příkazů a deklarací ve C# zdrojovém kódu.</span><span class="sxs-lookup"><span data-stu-id="b2c4b-247">You've used the **Syntax API** to locate specific kinds of C# statements and declarations in C# source code.</span></span>
