---
title: Začínáme s transformací syntaxe (Roslyn API)
description: Úvod do procházení, dotazování a chůze syntaxe stromy.
ms.date: 06/01/2018
ms.custom: mvc
ms.openlocfilehash: 5045dca839daba1070b34720e72cc9c4f7b94828
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 03/14/2020
ms.locfileid: "78240607"
---
# <a name="get-started-with-syntax-transformation"></a><span data-ttu-id="d9b10-103">Začínáme s syntaktickou transformací</span><span class="sxs-lookup"><span data-stu-id="d9b10-103">Get started with syntax transformation</span></span>

<span data-ttu-id="d9b10-104">Tento kurz vychází z konceptů a technik prozkoumávaných v části [Začínáme s analýzou syntaxe](syntax-analysis.md) a Začínáme s rychlými starty [sémantické analýzy.](semantic-analysis.md)</span><span class="sxs-lookup"><span data-stu-id="d9b10-104">This tutorial builds on concepts and techniques explored in the [Get started with syntax analysis](syntax-analysis.md) and [Get started with semantic analysis](semantic-analysis.md) quickstarts.</span></span> <span data-ttu-id="d9b10-105">Pokud jste tak dosud neučinili, měli byste dokončit tyto rychlé starty před zahájením tohoto.</span><span class="sxs-lookup"><span data-stu-id="d9b10-105">If you haven't already, you should complete those quickstarts before beginning this one.</span></span>

<span data-ttu-id="d9b10-106">V tomto rychlém startu můžete prozkoumat techniky pro vytváření a transformaci stromů syntaxe.</span><span class="sxs-lookup"><span data-stu-id="d9b10-106">In this quickstart, you explore techniques for creating and transforming syntax trees.</span></span> <span data-ttu-id="d9b10-107">V kombinaci s technikami, které jste se naučili v předchozích rychlých startech, vytvoříte svůj první refaktoring příkazového řádku!</span><span class="sxs-lookup"><span data-stu-id="d9b10-107">In combination with the techniques you learned in previous quickstarts, you create your first command-line refactoring!</span></span>

[!INCLUDE[interactive-note](~/includes/roslyn-installation.md)]

## <a name="immutability-and-the-net-compiler-platform"></a><span data-ttu-id="d9b10-108">Neměnnost a platforma kompilátoru .NET</span><span class="sxs-lookup"><span data-stu-id="d9b10-108">Immutability and the .NET compiler platform</span></span>

<span data-ttu-id="d9b10-109">**Neměnnost** je základní princip platformy kompilátoru .NET.</span><span class="sxs-lookup"><span data-stu-id="d9b10-109">**Immutability** is a fundamental tenet of the .NET compiler platform.</span></span> <span data-ttu-id="d9b10-110">Neměnné datové struktury nelze po vytvoření změnit.</span><span class="sxs-lookup"><span data-stu-id="d9b10-110">Immutable data structures can't be changed after they're created.</span></span> <span data-ttu-id="d9b10-111">Neměnné datové struktury mohou být bezpečně sdíleny a analyzovány více příjemci současně.</span><span class="sxs-lookup"><span data-stu-id="d9b10-111">Immutable data structures can be safely shared and analyzed by multiple consumers simultaneously.</span></span> <span data-ttu-id="d9b10-112">Neexistuje žádné nebezpečí, že jeden spotřebitel ovlivňuje jiný nepředvídatelným způsobem.</span><span class="sxs-lookup"><span data-stu-id="d9b10-112">There's no danger that one consumer affects another in unpredictable ways.</span></span> <span data-ttu-id="d9b10-113">Analyzátor nepotřebuje zámky nebo jiné míry souběžnosti.</span><span class="sxs-lookup"><span data-stu-id="d9b10-113">Your analyzer doesn't need locks or other concurrency measures.</span></span> <span data-ttu-id="d9b10-114">Toto pravidlo platí pro stromy syntaxe, kompilace, symboly, sémantické modely a všechny ostatní datové struktury, se kterými se setkáte.</span><span class="sxs-lookup"><span data-stu-id="d9b10-114">This rule applies to syntax trees, compilations, symbols, semantic models, and every other data structure you encounter.</span></span> <span data-ttu-id="d9b10-115">Namísto úpravexistujících struktur vytvářejí api nové objekty na základě zadaných rozdílů se starými.</span><span class="sxs-lookup"><span data-stu-id="d9b10-115">Instead of modifying existing structures, APIs create new objects based on specified differences to the old ones.</span></span> <span data-ttu-id="d9b10-116">Tento koncept použijete na stromy syntaxe k vytvoření nových stromů pomocí transformací.</span><span class="sxs-lookup"><span data-stu-id="d9b10-116">You apply this concept to syntax trees to create new trees using transformations.</span></span>

## <a name="create-and-transform-trees"></a><span data-ttu-id="d9b10-117">Vytváření a transformace stromů</span><span class="sxs-lookup"><span data-stu-id="d9b10-117">Create and transform trees</span></span>

<span data-ttu-id="d9b10-118">Můžete zvolit jednu ze dvou strategií pro transformace syntaxe.</span><span class="sxs-lookup"><span data-stu-id="d9b10-118">You choose one of two strategies for syntax transformations.</span></span> <span data-ttu-id="d9b10-119">**Metody výroby** se nejlépe používají při hledání konkrétních uzlů, které chcete nahradit, nebo konkrétních umístění, kam chcete vložit nový kód.</span><span class="sxs-lookup"><span data-stu-id="d9b10-119">**Factory methods** are best used when you're searching for specific nodes to replace, or specific locations where you want to insert new code.</span></span> <span data-ttu-id="d9b10-120">**Rewriters** jsou nejlepší, když chcete skenovat celý projekt pro vzory kódu, které chcete nahradit.</span><span class="sxs-lookup"><span data-stu-id="d9b10-120">**Rewriters** are best when you want to scan an entire project for code patterns that you want to replace.</span></span>

### <a name="create-nodes-with-factory-methods"></a><span data-ttu-id="d9b10-121">Vytvoření uzlů pomocí metod výroby</span><span class="sxs-lookup"><span data-stu-id="d9b10-121">Create nodes with factory methods</span></span>

<span data-ttu-id="d9b10-122">První syntaktické transformace ukazuje metody výroby.</span><span class="sxs-lookup"><span data-stu-id="d9b10-122">The first syntax transformation demonstrates the factory methods.</span></span> <span data-ttu-id="d9b10-123">Nahradíte prohlášení `using System.Collections;` prohlášením. `using System.Collections.Generic;`</span><span class="sxs-lookup"><span data-stu-id="d9b10-123">You're going to replace a `using System.Collections;` statement with a `using System.Collections.Generic;` statement.</span></span> <span data-ttu-id="d9b10-124">Tento příklad ukazuje, <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode?displayProperty=nameWithType> jak vytvářet objekty pomocí <xref:Microsoft.CodeAnalysis.CSharp.SyntaxFactory?displayProperty=nameWithType> metod výroby.</span><span class="sxs-lookup"><span data-stu-id="d9b10-124">This example demonstrates how you create <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode?displayProperty=nameWithType> objects using the <xref:Microsoft.CodeAnalysis.CSharp.SyntaxFactory?displayProperty=nameWithType> factory methods.</span></span> <span data-ttu-id="d9b10-125">Pro každý druh **uzlu**, **tokenu**nebo **trivia** je metoda factory, která vytvoří instanci tohoto typu.</span><span class="sxs-lookup"><span data-stu-id="d9b10-125">For each kind of **node**, **token**, or **trivia** there's a factory method that creates an instance of that type.</span></span> <span data-ttu-id="d9b10-126">Stromy syntaxe vytvoříte hierarchicky vytvářením uzlů způsobem zdola nahoru.</span><span class="sxs-lookup"><span data-stu-id="d9b10-126">You create syntax trees by composing nodes hierarchically in a bottom-up fashion.</span></span> <span data-ttu-id="d9b10-127">Potom transformujete existující program, který nahradí existující uzly novým stromem, který jste vytvořili.</span><span class="sxs-lookup"><span data-stu-id="d9b10-127">Then, you'll transform the existing program be replacing existing nodes with the new tree you've created.</span></span>

<span data-ttu-id="d9b10-128">Spusťte Visual Studio a vytvořte nový projekt **nástroje pro analýzu samostatného kódu** jazyka C#.</span><span class="sxs-lookup"><span data-stu-id="d9b10-128">Start Visual Studio, and create a new C# **Stand-Alone Code Analysis Tool** project.</span></span> <span data-ttu-id="d9b10-129">V Sadě Visual Studio zvolte **Soubor** > **nový** > **projekt,** abyste zobrazili dialogové okno Nový projekt.</span><span class="sxs-lookup"><span data-stu-id="d9b10-129">In Visual Studio, choose **File** > **New** > **Project** to display the New Project dialog.</span></span> <span data-ttu-id="d9b10-130">V **části Visual C#** > **Rozšiřitelnost** zvolte **nástroj pro analýzu samostatného kódu**.</span><span class="sxs-lookup"><span data-stu-id="d9b10-130">Under **Visual C#** > **Extensibility** choose a **Stand-Alone Code Analysis Tool**.</span></span> <span data-ttu-id="d9b10-131">Tento rychlý start má dva ukázkové projekty, proto pojmenujte řešení **SyntaxTransformationQuickStart**a pojmenujte projekt **ConstructionCS**.</span><span class="sxs-lookup"><span data-stu-id="d9b10-131">This quickstart has two example projects, so name the solution **SyntaxTransformationQuickStart**, and name the project **ConstructionCS**.</span></span> <span data-ttu-id="d9b10-132">Klikněte na tlačítko **OK**.</span><span class="sxs-lookup"><span data-stu-id="d9b10-132">Click **OK**.</span></span>

<span data-ttu-id="d9b10-133">Tento projekt <xref:Microsoft.CodeAnalysis.CSharp.SyntaxFactory?displayProperty=nameWithType> používá metody třídy k vytvoření <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax?displayProperty=nameWithType> reprezentující obor `System.Collections.Generic` názvů.</span><span class="sxs-lookup"><span data-stu-id="d9b10-133">This project uses the <xref:Microsoft.CodeAnalysis.CSharp.SyntaxFactory?displayProperty=nameWithType> class methods to construct a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax?displayProperty=nameWithType> representing the `System.Collections.Generic` namespace.</span></span>

<span data-ttu-id="d9b10-134">Přidejte následující pomocí směrnice na `Program.cs` začátek souboru importovat metody <xref:Microsoft.CodeAnalysis.CSharp.SyntaxFactory> výroby <xref:System.Console> třídy a metody tak, aby je můžete použít později bez jejich kvalifikace:</span><span class="sxs-lookup"><span data-stu-id="d9b10-134">Add the following using directive to the top of the `Program.cs` file to import the factory methods of the <xref:Microsoft.CodeAnalysis.CSharp.SyntaxFactory> class and the methods of <xref:System.Console> so that you can use them later without qualifying them:</span></span>

[!code-csharp[import the SyntaxFactory class](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#StaticUsings "import the Syntax Factory class and the System.Console class")]

<span data-ttu-id="d9b10-135">Vytvoříte **syntaxe uzlů názvu** k vytvoření stromu, který představuje `using System.Collections.Generic;` příkaz.</span><span class="sxs-lookup"><span data-stu-id="d9b10-135">You'll create **name syntax nodes** to build the tree that represents the `using System.Collections.Generic;` statement.</span></span> <span data-ttu-id="d9b10-136"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax>je základní třída pro čtyři typy názvů, které se zobrazují v c#.</span><span class="sxs-lookup"><span data-stu-id="d9b10-136"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax> is the base class for four types of names that appear in C#.</span></span> <span data-ttu-id="d9b10-137">Tyto čtyři typy názvů vytvoříte společně a vytvoříte libovolný název, který se může zobrazit v jazyce C#:</span><span class="sxs-lookup"><span data-stu-id="d9b10-137">You compose these four types of names together to create any name that can appear in the C# language:</span></span>

* <span data-ttu-id="d9b10-138"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax?displayProperty=nameWithType>, který představuje jednoduché `System` názvy s jedním identifikátorem jako a `Microsoft`.</span><span class="sxs-lookup"><span data-stu-id="d9b10-138"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax?displayProperty=nameWithType>, which represents simple single identifier names like `System` and `Microsoft`.</span></span>
* <span data-ttu-id="d9b10-139"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax?displayProperty=nameWithType>, který představuje obecný typ nebo `List<int>`název metody, například .</span><span class="sxs-lookup"><span data-stu-id="d9b10-139"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax?displayProperty=nameWithType>, which represents a generic type or method name such as `List<int>`.</span></span>
* <span data-ttu-id="d9b10-140"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax?displayProperty=nameWithType>, který představuje kvalifikovaný název `<left-name>.<right-identifier-or-generic-name>` formuláře, například `System.IO`.</span><span class="sxs-lookup"><span data-stu-id="d9b10-140"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax?displayProperty=nameWithType>, which represents a qualified name of the form `<left-name>.<right-identifier-or-generic-name>` such as `System.IO`.</span></span>
* <span data-ttu-id="d9b10-141"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.AliasQualifiedNameSyntax?displayProperty=nameWithType>, který představuje název pomocí sestavení extern alias takové `LibraryV2::Foo`.</span><span class="sxs-lookup"><span data-stu-id="d9b10-141"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.AliasQualifiedNameSyntax?displayProperty=nameWithType>, which represents a name using an assembly extern alias such a `LibraryV2::Foo`.</span></span>

<span data-ttu-id="d9b10-142">Metoda se <xref:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.IdentifierName(System.String)> používá k <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax> vytvoření uzlu.</span><span class="sxs-lookup"><span data-stu-id="d9b10-142">You use the <xref:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.IdentifierName(System.String)> method to create a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax> node.</span></span> <span data-ttu-id="d9b10-143">Přidejte do `Main` metody následující `Program.cs`kód v aplikaci :</span><span class="sxs-lookup"><span data-stu-id="d9b10-143">Add the following code in your `Main` method in `Program.cs`:</span></span>

[!code-csharp[create the system identifier](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#CreateIdentifierName "Create and display the system name identifier")]

<span data-ttu-id="d9b10-144">Předchozí kód vytvoří <xref:Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax> objekt a přiřadí jej `name`proměnné .</span><span class="sxs-lookup"><span data-stu-id="d9b10-144">The preceding code creates an <xref:Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax> object and assigns it to the variable `name`.</span></span> <span data-ttu-id="d9b10-145">Mnoho roslyn api vrátit základní třídy, aby bylo snazší pracovat s související typy.</span><span class="sxs-lookup"><span data-stu-id="d9b10-145">Many of the Roslyn APIs return base classes to make it easier to work with related types.</span></span> <span data-ttu-id="d9b10-146">Proměnnou `name`, <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax>a , lze znovu <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax>použít při vytváření .</span><span class="sxs-lookup"><span data-stu-id="d9b10-146">The variable `name`, an <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax>, can be reused as you build the <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax>.</span></span> <span data-ttu-id="d9b10-147">Při vytváření ukázky nepoužívejte odvození typu.</span><span class="sxs-lookup"><span data-stu-id="d9b10-147">Don't use type inference as you build the sample.</span></span> <span data-ttu-id="d9b10-148">Budete automatizovat tento krok v tomto projektu.</span><span class="sxs-lookup"><span data-stu-id="d9b10-148">You'll automate that step in this project.</span></span>

<span data-ttu-id="d9b10-149">Vytvořiljsi jméno.</span><span class="sxs-lookup"><span data-stu-id="d9b10-149">You've created the name.</span></span> <span data-ttu-id="d9b10-150">Nyní je čas vybudovat více uzlů do stromu <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax>tím, že staví .</span><span class="sxs-lookup"><span data-stu-id="d9b10-150">Now, it's time to build more nodes into the tree by building a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax>.</span></span> <span data-ttu-id="d9b10-151">Nový strom `name` používá jako vlevo od názvu <xref:Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax> a `Collections` nový pro obor názvů <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax>jako pravé straně .</span><span class="sxs-lookup"><span data-stu-id="d9b10-151">The new tree uses `name` as the left of the name, and a new <xref:Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax> for the `Collections` namespace as the right side of the <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax>.</span></span> <span data-ttu-id="d9b10-152">Do této části `program.cs`přidejte následující kód:</span><span class="sxs-lookup"><span data-stu-id="d9b10-152">Add the following code to `program.cs`:</span></span>

[!code-csharp[create the collections identifier](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#CreateQualifiedIdentifierName "Build the System.Collections identifier")]

<span data-ttu-id="d9b10-153">Spusťte kód znovu a podívejte se na výsledky.</span><span class="sxs-lookup"><span data-stu-id="d9b10-153">Run the code again, and see the results.</span></span> <span data-ttu-id="d9b10-154">Vytváříte strom uzlů, který představuje kód.</span><span class="sxs-lookup"><span data-stu-id="d9b10-154">You're building a tree of nodes that represents code.</span></span> <span data-ttu-id="d9b10-155">Budete pokračovat v tomto vzoru <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax> k vytvoření `System.Collections.Generic`pro obor názvů .</span><span class="sxs-lookup"><span data-stu-id="d9b10-155">You'll continue this pattern to build the <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax> for the namespace `System.Collections.Generic`.</span></span> <span data-ttu-id="d9b10-156">Do této části `Program.cs`přidejte následující kód:</span><span class="sxs-lookup"><span data-stu-id="d9b10-156">Add the following code to `Program.cs`:</span></span>

[!code-csharp[create the full identifier](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#CreateFullNamespace "Build the System.Collections.Generic identifier")]

<span data-ttu-id="d9b10-157">Spusťte program znovu vidět, že jste vytvořili strom pro kód přidat.</span><span class="sxs-lookup"><span data-stu-id="d9b10-157">Run the program again to see that you've build the tree for the code to add.</span></span>

### <a name="create-a-modified-tree"></a><span data-ttu-id="d9b10-158">Vytvoření upraveného stromu</span><span class="sxs-lookup"><span data-stu-id="d9b10-158">Create a modified tree</span></span>

<span data-ttu-id="d9b10-159">Vytvořili jste malý strom syntaxe, který obsahuje jeden příkaz.</span><span class="sxs-lookup"><span data-stu-id="d9b10-159">You've built a small syntax tree that contains one statement.</span></span> <span data-ttu-id="d9b10-160">Api pro vytvoření nových uzlů jsou správnou volbou pro vytvoření jednoho příkazu nebo jiných bloků malých kódů.</span><span class="sxs-lookup"><span data-stu-id="d9b10-160">The APIs to create new nodes are the right choice to create single statements or other small code blocks.</span></span> <span data-ttu-id="d9b10-161">Chcete-li však vytvořit větší bloky kódu, měli byste použít metody, které nahrazují uzly nebo vkládají uzly do existujícího stromu.</span><span class="sxs-lookup"><span data-stu-id="d9b10-161">However, to build larger blocks of code, you should use methods that replace nodes or insert nodes into an existing tree.</span></span> <span data-ttu-id="d9b10-162">Nezapomeňte, že stromy syntaxe jsou neměnné.</span><span class="sxs-lookup"><span data-stu-id="d9b10-162">Remember that syntax trees are immutable.</span></span> <span data-ttu-id="d9b10-163">Syntaxe **ROZHRANÍ API** neposkytuje žádný mechanismus pro úpravu existující ho stromu syntaxe po konstrukci.</span><span class="sxs-lookup"><span data-stu-id="d9b10-163">The **Syntax API** doesn't provide any mechanism for modifying an existing syntax tree after construction.</span></span> <span data-ttu-id="d9b10-164">Místo toho poskytuje metody, které vytvářejí nové stromy na základě změn stávajících.</span><span class="sxs-lookup"><span data-stu-id="d9b10-164">Instead, it provides methods that produce new trees based on changes to existing ones.</span></span> <span data-ttu-id="d9b10-165">`With*`metody jsou definovány v <xref:Microsoft.CodeAnalysis.SyntaxNode> konkrétních třídách, <xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions> které jsou odvozeny z metod rozšíření nebo v rozšiřujících metodách deklarovaných ve třídě.</span><span class="sxs-lookup"><span data-stu-id="d9b10-165">`With*` methods are defined in concrete classes that derive from <xref:Microsoft.CodeAnalysis.SyntaxNode> or in extension methods declared in the <xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions> class.</span></span> <span data-ttu-id="d9b10-166">Tyto metody vytvoří nový uzel použitím změn na podřízené vlastnosti existujícího uzlu.</span><span class="sxs-lookup"><span data-stu-id="d9b10-166">These methods create a new node by applying changes to an existing node's child properties.</span></span> <span data-ttu-id="d9b10-167">Kromě toho <xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNode%2A> metodu rozšíření lze nahradit potomkový uzel v podstromu.</span><span class="sxs-lookup"><span data-stu-id="d9b10-167">Additionally, the <xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNode%2A> extension method can be used to replace a descendent node in a subtree.</span></span> <span data-ttu-id="d9b10-168">Tato metoda také aktualizuje nadřazený odkaz na nově vytvořené podřízené a opakuje tento proces až celý strom - proces známý jako _re-spinning_ stromu.</span><span class="sxs-lookup"><span data-stu-id="d9b10-168">This method also updates the parent to point to the newly created child and repeats this process up the entire tree - a process known as _re-spinning_ the tree.</span></span>

<span data-ttu-id="d9b10-169">Dalším krokem je vytvoření stromu, který představuje celý (malý) program a pak jej upravit.</span><span class="sxs-lookup"><span data-stu-id="d9b10-169">The next step is to create a tree that represents an entire (small) program and then modify it.</span></span> <span data-ttu-id="d9b10-170">Na začátek třídy `Program` přidejte následující kód:</span><span class="sxs-lookup"><span data-stu-id="d9b10-170">Add the following code to the beginning of the `Program` class:</span></span>

[!code-csharp[create a parse tree](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#DeclareSampleCode "Create a tree that represents a small program")]

> [!NOTE]
> <span data-ttu-id="d9b10-171">Ukázkový kód `System.Collections` používá obor názvů `System.Collections.Generic` a nikoli obor názvů.</span><span class="sxs-lookup"><span data-stu-id="d9b10-171">The example code uses the `System.Collections` namespace and not the `System.Collections.Generic` namespace.</span></span>

<span data-ttu-id="d9b10-172">Dále přidejte následující kód na `Main` konec metody, abyste oddělili text a vytvořili strom:</span><span class="sxs-lookup"><span data-stu-id="d9b10-172">Next, add the following code to the bottom of the `Main` method to parse the text and create a tree:</span></span>

[!code-csharp[create a parse tree](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#CreateParseTree "Create a tree that represents a small program")]

<span data-ttu-id="d9b10-173">Tento příklad <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax.WithName(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax)?displayProperty=NameWithType> používá metodu k <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax> nahrazení názvu v uzlu názvem vytvořeným v předchozím kódu.</span><span class="sxs-lookup"><span data-stu-id="d9b10-173">This example uses the <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax.WithName(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax)?displayProperty=NameWithType> method to replace the name in a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax> node with the one constructed in the preceding code.</span></span>

<span data-ttu-id="d9b10-174">Vytvořte <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax> nový uzel <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax.WithName(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax)> pomocí metody `System.Collections` k aktualizaci názvu s názvem, který jste vytvořili v předchozím kódu.</span><span class="sxs-lookup"><span data-stu-id="d9b10-174">Create a new <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax> node using the <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax.WithName(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax)> method to update the `System.Collections` name with the name you created in the preceding code.</span></span> <span data-ttu-id="d9b10-175">Přidejte následující kód na `Main` konec metody:</span><span class="sxs-lookup"><span data-stu-id="d9b10-175">Add the following code to the bottom of the `Main` method:</span></span>

[!code-csharp[create a new subtree](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#BuildNewUsing "Create the subtree with the replaced namespace")]

<span data-ttu-id="d9b10-176">Spusťte program a pozorně se podívejte na výstup.</span><span class="sxs-lookup"><span data-stu-id="d9b10-176">Run the program and look carefully at the output.</span></span> <span data-ttu-id="d9b10-177">Nebyl `newusing` aumístěn do kořenového stromu.</span><span class="sxs-lookup"><span data-stu-id="d9b10-177">The `newusing` hasn't been placed in the root tree.</span></span> <span data-ttu-id="d9b10-178">Původní strom nebyl změněn.</span><span class="sxs-lookup"><span data-stu-id="d9b10-178">The original tree hasn't been changed.</span></span>

<span data-ttu-id="d9b10-179">Přidejte následující kód <xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNode%2A> pomocí metody rozšíření k vytvoření nového stromu.</span><span class="sxs-lookup"><span data-stu-id="d9b10-179">Add the following code using the <xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNode%2A> extension method to create a new tree.</span></span> <span data-ttu-id="d9b10-180">Nový strom je výsledkem nahrazení existujícího importu aktualizovaným `newUsing` uzlem.</span><span class="sxs-lookup"><span data-stu-id="d9b10-180">The new tree is the result of replacing the existing import with the updated `newUsing` node.</span></span> <span data-ttu-id="d9b10-181">Tento nový strom přiřadíte existující `root` proměnné:</span><span class="sxs-lookup"><span data-stu-id="d9b10-181">You assign this new tree to the existing `root` variable:</span></span>

[!code-csharp[create a new root tree](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#TransformTree "Create the transformed root tree with the replaced namespace")]

<span data-ttu-id="d9b10-182">Spusťte program znovu.</span><span class="sxs-lookup"><span data-stu-id="d9b10-182">Run the program again.</span></span> <span data-ttu-id="d9b10-183">Tentokrát strom správně importuje `System.Collections.Generic` obor názvů.</span><span class="sxs-lookup"><span data-stu-id="d9b10-183">This time the tree now correctly imports the `System.Collections.Generic` namespace.</span></span>

### <a name="transform-trees-using-syntaxrewriters"></a><span data-ttu-id="d9b10-184">Transformace stromů pomocí`SyntaxRewriters`</span><span class="sxs-lookup"><span data-stu-id="d9b10-184">Transform trees using `SyntaxRewriters`</span></span>

<span data-ttu-id="d9b10-185">Metody `With*` <xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNode%2A> a poskytují pohodlné prostředky k transformaci jednotlivých větví syntaktického stromu.</span><span class="sxs-lookup"><span data-stu-id="d9b10-185">The `With*` and <xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNode%2A> methods provide convenient means to transform individual branches of a syntax tree.</span></span> <span data-ttu-id="d9b10-186">Třída <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter?displayProperty=nameWithType> provádí více transformací ve stromu syntaxe.</span><span class="sxs-lookup"><span data-stu-id="d9b10-186">The <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter?displayProperty=nameWithType> class performs multiple transformations on a syntax tree.</span></span> <span data-ttu-id="d9b10-187">Třída <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter?displayProperty=nameWithType> je podtřídou <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor%601?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="d9b10-187">The <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter?displayProperty=nameWithType> class is a subclass of <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor%601?displayProperty=nameWithType>.</span></span> <span data-ttu-id="d9b10-188">Použije <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter> transformace na konkrétní typ <xref:Microsoft.CodeAnalysis.SyntaxNode>.</span><span class="sxs-lookup"><span data-stu-id="d9b10-188">The <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter> applies a transformation to a specific type of <xref:Microsoft.CodeAnalysis.SyntaxNode>.</span></span> <span data-ttu-id="d9b10-189">Transformace můžete aplikovat na více <xref:Microsoft.CodeAnalysis.SyntaxNode> typů objektů všude tam, kde se zobrazují ve stromu syntaxe.</span><span class="sxs-lookup"><span data-stu-id="d9b10-189">You can apply transformations to multiple types of <xref:Microsoft.CodeAnalysis.SyntaxNode> objects wherever they appear in a syntax tree.</span></span> <span data-ttu-id="d9b10-190">Druhý projekt v tomto rychlém startu vytvoří refaktoring příkazového řádku, který odebere explicitní typy v deklaracích místních proměnných kdekoli, kde by mohl být použit odvození typu.</span><span class="sxs-lookup"><span data-stu-id="d9b10-190">The second project in this quickstart creates a command-line refactoring that removes explicit types in local variable declarations anywhere that type inference could be used.</span></span>

<span data-ttu-id="d9b10-191">Vytvořte nový projekt **nástroje pro analýzu samostatného kódu** jazyka C#.</span><span class="sxs-lookup"><span data-stu-id="d9b10-191">Create a new C# **Stand-Alone Code Analysis Tool** project.</span></span> <span data-ttu-id="d9b10-192">V sadě Visual Studio `SyntaxTransformationQuickStart` klikněte pravým tlačítkem myši na uzel řešení.</span><span class="sxs-lookup"><span data-stu-id="d9b10-192">In Visual Studio, right-click the `SyntaxTransformationQuickStart` solution node.</span></span> <span data-ttu-id="d9b10-193">Zvolte **Přidat** > **nový projekt,** chcete-li zobrazit **dialogové okno Nový projekt**.</span><span class="sxs-lookup"><span data-stu-id="d9b10-193">Choose **Add** > **New Project** to display the **New Project dialog**.</span></span> <span data-ttu-id="d9b10-194">V **části Visual C#** > **Rozšiřitelnost**zvolte **Nástroj pro analýzu samostatného kódu**.</span><span class="sxs-lookup"><span data-stu-id="d9b10-194">Under **Visual C#** > **Extensibility**, choose **Stand-Alone Code Analysis Tool**.</span></span> <span data-ttu-id="d9b10-195">Pojmenujte `TransformationCS` projekt a klikněte na OK.</span><span class="sxs-lookup"><span data-stu-id="d9b10-195">Name your project `TransformationCS` and click OK.</span></span>

<span data-ttu-id="d9b10-196">Prvním krokem je vytvořit třídu, <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter> která je odvozena od provádět transformace.</span><span class="sxs-lookup"><span data-stu-id="d9b10-196">The first step is to create a class that derives from <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter> to perform your transformations.</span></span> <span data-ttu-id="d9b10-197">Přidejte do projektu nový soubor třídy.</span><span class="sxs-lookup"><span data-stu-id="d9b10-197">Add a new class file to the project.</span></span> <span data-ttu-id="d9b10-198">V Visual Studiu zvolte **Project** > **Add Class...**. V dialogovém okně `TypeInferenceRewriter.cs` Přidat novou **položku** jako název souboru.</span><span class="sxs-lookup"><span data-stu-id="d9b10-198">In Visual Studio, choose **Project** > **Add Class...**. In the **Add New Item** dialog type `TypeInferenceRewriter.cs` as the filename.</span></span>

<span data-ttu-id="d9b10-199">Do souboru přidejte `TypeInferenceRewriter.cs` následující příkazy pomocí direktiv:</span><span class="sxs-lookup"><span data-stu-id="d9b10-199">Add the following using directives to the `TypeInferenceRewriter.cs` file:</span></span>

[!code-csharp[add necessary usings](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/TypeInferenceRewriter.cs#AddUsings "Add required usings")]

<span data-ttu-id="d9b10-200">Dále proveďte `TypeInferenceRewriter` třídu <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter> rozšířit třídu:</span><span class="sxs-lookup"><span data-stu-id="d9b10-200">Next, make the `TypeInferenceRewriter` class extend the <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter> class:</span></span>

[!code-csharp[add base class](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/TypeInferenceRewriter.cs#BaseClass "Add base class")]

<span data-ttu-id="d9b10-201">Přidejte následující kód deklarovat soukromé pole <xref:Microsoft.CodeAnalysis.SemanticModel> jen pro čtení držet a inicializovat v konstruktoru.</span><span class="sxs-lookup"><span data-stu-id="d9b10-201">Add the following code to declare a private read-only field to hold a <xref:Microsoft.CodeAnalysis.SemanticModel> and initialize it in the constructor.</span></span> <span data-ttu-id="d9b10-202">Toto pole budete později potřebovat k určení, kde lze použít odvození typu:</span><span class="sxs-lookup"><span data-stu-id="d9b10-202">You will need this field later on to determine where type inference can be used:</span></span>

[!code-csharp[initialize members](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/TypeInferenceRewriter.cs#Construction "Declare and initialize member variables")]

<span data-ttu-id="d9b10-203">Přepsat metodu: <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitLocalDeclarationStatement(Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax)></span><span class="sxs-lookup"><span data-stu-id="d9b10-203">Override the <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitLocalDeclarationStatement(Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax)> method:</span></span>

```csharp
public override SyntaxNode VisitLocalDeclarationStatement(LocalDeclarationStatementSyntax node)
{

}
```

> [!NOTE]
> <span data-ttu-id="d9b10-204">Mnoho roslyn ských api deklarovat návratové typy, které jsou základní třídy skutečné typy runtime vrácena.</span><span class="sxs-lookup"><span data-stu-id="d9b10-204">Many of the Roslyn APIs declare return types that are base classes of the actual runtime types returned.</span></span> <span data-ttu-id="d9b10-205">V mnoha scénářích může být jeden druh uzlu zcela nahrazen jiným druhem uzlu nebo dokonce odebrán.</span><span class="sxs-lookup"><span data-stu-id="d9b10-205">In many scenarios, one kind of node may be replaced by another kind of node entirely - or even removed.</span></span> <span data-ttu-id="d9b10-206">V tomto příkladu <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitLocalDeclarationStatement(Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax)> metoda <xref:Microsoft.CodeAnalysis.SyntaxNode>vrátí , namísto <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax>odvozeného typu .</span><span class="sxs-lookup"><span data-stu-id="d9b10-206">In this example, the <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitLocalDeclarationStatement(Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax)> method returns a <xref:Microsoft.CodeAnalysis.SyntaxNode>, instead of the derived type of   <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax>.</span></span> <span data-ttu-id="d9b10-207">Tento vypalovačka vrátí nový <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax> uzel na základě existujícího uzlu.</span><span class="sxs-lookup"><span data-stu-id="d9b10-207">This rewriter returns a new <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax> node based on the existing one.</span></span>

<span data-ttu-id="d9b10-208">Tento rychlý start zpracovává deklarace místní proměnné.</span><span class="sxs-lookup"><span data-stu-id="d9b10-208">This quickstart handles local variable declarations.</span></span> <span data-ttu-id="d9b10-209">Můžete rozšířit na další deklarace, `foreach` jako `for` jsou smyčky, smyčky, výrazy LINQ a lambda výrazy.</span><span class="sxs-lookup"><span data-stu-id="d9b10-209">You could extend it to other declarations such as `foreach` loops, `for` loops, LINQ expressions, and lambda expressions.</span></span> <span data-ttu-id="d9b10-210">Kromě toho tento vypalovačka transformuje pouze deklarace nejjednodušší formy:</span><span class="sxs-lookup"><span data-stu-id="d9b10-210">Furthermore this rewriter will only transform declarations of the simplest form:</span></span>

```csharp
Type variable = expression;
```

<span data-ttu-id="d9b10-211">Pokud chcete prozkoumat na vlastní pěst, zvažte rozšíření dokončené ukázky pro tyto typy deklarací proměnných:</span><span class="sxs-lookup"><span data-stu-id="d9b10-211">If you want to explore on your own, consider extending the finished sample for these types of variable declarations:</span></span>

```csharp
// Multiple variables in a single declaration.
Type variable1 = expression1,
     variable2 = expression2;
// No initializer.
Type variable;
```

<span data-ttu-id="d9b10-212">Přidejte následující kód do `VisitLocalDeclarationStatement` těla metody přeskočit přepisování těchto forem deklarací:</span><span class="sxs-lookup"><span data-stu-id="d9b10-212">Add the following code to the body of the `VisitLocalDeclarationStatement` method to skip rewriting these forms of declarations:</span></span>

[!code-csharp[exclude other declarations](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/TypeInferenceRewriter.cs#Exclusions "Exclude variables declarations not processed by this sample")]

<span data-ttu-id="d9b10-213">Metoda označuje, že žádné přepsání `node` probíhá vrácením parametru nezměněno.</span><span class="sxs-lookup"><span data-stu-id="d9b10-213">The method indicates that no rewriting takes place by returning the `node` parameter unmodified.</span></span> <span data-ttu-id="d9b10-214">Pokud ani jeden `if` z těchto výrazů jsou pravdivé, uzel představuje možné prohlášení s inicializace.</span><span class="sxs-lookup"><span data-stu-id="d9b10-214">If neither of those `if` expressions are true, the node represents a possible declaration with initialization.</span></span> <span data-ttu-id="d9b10-215">Přidejte tyto příkazy k extrahování názvu typu <xref:Microsoft.CodeAnalysis.SemanticModel> zadaného v deklaraci a svázání pomocí pole k získání symbolu typu:</span><span class="sxs-lookup"><span data-stu-id="d9b10-215">Add these statements to extract the type name specified in the declaration and bind it using the <xref:Microsoft.CodeAnalysis.SemanticModel> field to obtain a type symbol:</span></span>

[!code-csharp[extract type name](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/TypeInferenceRewriter.cs#ExtractTypeSymbol "Extract the type name specified by the declaration")]

<span data-ttu-id="d9b10-216">Nyní přidejte tento příkaz svázat výraz inicializátoru:</span><span class="sxs-lookup"><span data-stu-id="d9b10-216">Now, add this statement to bind the initializer expression:</span></span>

[!code-csharp[bind initializer](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/TypeInferenceRewriter.cs#BindInitializer "Bind the initializer expressions")]

<span data-ttu-id="d9b10-217">Nakonec přidejte `if` následující příkaz, který nahradí `var` existující název typu klíčovým slovem, pokud typ výrazu inicializátoru odpovídá zadanému typu:</span><span class="sxs-lookup"><span data-stu-id="d9b10-217">Finally, add the following `if` statement to replace the existing type name with the `var` keyword if the type of the initializer expression matches the type specified:</span></span>

[!code-csharp[ReplaceNode](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/TypeInferenceRewriter.cs#ReplaceNode "Replace the initializer node")]

<span data-ttu-id="d9b10-218">Podmínka je vyžadována, protože deklarace může přetypovat výraz inicializátoru do základní třídy nebo rozhraní.</span><span class="sxs-lookup"><span data-stu-id="d9b10-218">The conditional is required because the declaration may cast the initializer expression to a base class or interface.</span></span> <span data-ttu-id="d9b10-219">Pokud je to žádoucí, typy na levé a pravé straně přiřazení se neshodují.</span><span class="sxs-lookup"><span data-stu-id="d9b10-219">If that's desired, the types on the left and right-hand side of the assignment don't match.</span></span> <span data-ttu-id="d9b10-220">Odebrání explicitního typu v těchto případech by změnilo sémantiku programu.</span><span class="sxs-lookup"><span data-stu-id="d9b10-220">Removing the explicit type in these cases would change the semantics of a program.</span></span> <span data-ttu-id="d9b10-221">`var`je určen jako identifikátor, nikoli `var` klíčové slovo, protože je kontextové klíčové slovo.</span><span class="sxs-lookup"><span data-stu-id="d9b10-221">`var` is specified as an identifier rather than a keyword because `var` is a contextual keyword.</span></span> <span data-ttu-id="d9b10-222">Úvodní a koncové drobnosti (prázdné místo) jsou převedeny ze `var` starého názvu typu na klíčové slovo zachovat svislé prázdné místo a odsazení.</span><span class="sxs-lookup"><span data-stu-id="d9b10-222">The leading and trailing trivia (white space) are transferred from the old type name to the `var` keyword to maintain vertical white space and indentation.</span></span> <span data-ttu-id="d9b10-223">Je jednodušší použít `ReplaceNode` spíše `With*` než <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax> transformovat, protože název typu je ve skutečnosti vnouče prohlášení prohlášení.</span><span class="sxs-lookup"><span data-stu-id="d9b10-223">It's simpler to use `ReplaceNode` rather than `With*` to transform the <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax> because the type name is actually the grandchild of the declaration statement.</span></span>

<span data-ttu-id="d9b10-224">Dokončili jste `TypeInferenceRewriter`.</span><span class="sxs-lookup"><span data-stu-id="d9b10-224">You've finished the `TypeInferenceRewriter`.</span></span> <span data-ttu-id="d9b10-225">Nyní se `Program.cs` vraťte do souboru a dokončete příklad.</span><span class="sxs-lookup"><span data-stu-id="d9b10-225">Now return to your `Program.cs` file to finish the example.</span></span> <span data-ttu-id="d9b10-226">Vytvořte <xref:Microsoft.CodeAnalysis.Compilation> test a <xref:Microsoft.CodeAnalysis.SemanticModel> získat z něj.</span><span class="sxs-lookup"><span data-stu-id="d9b10-226">Create a test <xref:Microsoft.CodeAnalysis.Compilation> and obtain the <xref:Microsoft.CodeAnalysis.SemanticModel> from it.</span></span> <span data-ttu-id="d9b10-227">Použijte <xref:Microsoft.CodeAnalysis.SemanticModel> to vyzkoušet `TypeInferenceRewriter`.</span><span class="sxs-lookup"><span data-stu-id="d9b10-227">Use that <xref:Microsoft.CodeAnalysis.SemanticModel> to try your `TypeInferenceRewriter`.</span></span> <span data-ttu-id="d9b10-228">Tento krok uděláte jako poslední.</span><span class="sxs-lookup"><span data-stu-id="d9b10-228">You'll do this step last.</span></span> <span data-ttu-id="d9b10-229">Mezitím deklarujte zástupnou proměnnou představující testovací kompilaci:</span><span class="sxs-lookup"><span data-stu-id="d9b10-229">In the meantime declare a placeholder variable representing your test compilation:</span></span>

[!code-csharp[DeclareCompilation](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/Program.cs#DeclareTestCompilation "Declare the test compilation")]

<span data-ttu-id="d9b10-230">Po pozastavení chvíli, měli byste vidět chyba vlnovku se zobrazí hlášení, že neexistuje žádná `CreateTestCompilation` metoda.</span><span class="sxs-lookup"><span data-stu-id="d9b10-230">After pausing a moment, you should see an error squiggle appear reporting that no `CreateTestCompilation` method exists.</span></span> <span data-ttu-id="d9b10-231">Stisknutím **kláves Ctrl+Period** otevřete žárovku a stisknutím klávesy Enter vyvoláte příkaz **Generovat se zakázaným inzerováním metody.**</span><span class="sxs-lookup"><span data-stu-id="d9b10-231">Press **Ctrl+Period** to open the light-bulb and then press Enter to invoke the **Generate Method Stub** command.</span></span> <span data-ttu-id="d9b10-232">Tento příkaz vygeneruje zástupný `CreateTestCompilation` kód `Program` metody pro metodu ve třídě.</span><span class="sxs-lookup"><span data-stu-id="d9b10-232">This command will generate a method stub for the `CreateTestCompilation` method in the `Program` class.</span></span> <span data-ttu-id="d9b10-233">Vrátíte se k vyplnění této metody později:</span><span class="sxs-lookup"><span data-stu-id="d9b10-233">You'll come back to fill in this method later:</span></span>

![C# Generovat metodu z použití](./media/syntax-transformation/generate-from-usage.png)

<span data-ttu-id="d9b10-235">Napište následující kód iterát <xref:Microsoft.CodeAnalysis.SyntaxTree> přes <xref:Microsoft.CodeAnalysis.Compilation>každý v testu .</span><span class="sxs-lookup"><span data-stu-id="d9b10-235">Write the following code to iterate over each <xref:Microsoft.CodeAnalysis.SyntaxTree> in the test <xref:Microsoft.CodeAnalysis.Compilation>.</span></span> <span data-ttu-id="d9b10-236">Pro každý z nich inicializovat nový `TypeInferenceRewriter` s for tento <xref:Microsoft.CodeAnalysis.SemanticModel> strom:</span><span class="sxs-lookup"><span data-stu-id="d9b10-236">For each one, initialize a new `TypeInferenceRewriter` with the <xref:Microsoft.CodeAnalysis.SemanticModel> for that tree:</span></span>

[!code-csharp[IterateTrees](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/Program.cs#IterateTrees "Iterate all the source trees in the test compilation")]

<span data-ttu-id="d9b10-237">Uvnitř `foreach` příkazu, který jste vytvořili, přidejte následující kód k provedení transformace v každém zdrojovém stromu.</span><span class="sxs-lookup"><span data-stu-id="d9b10-237">Inside the `foreach` statement you created, add the following code to perform the transformation on each source tree.</span></span> <span data-ttu-id="d9b10-238">Tento kód podmíněně zapíše nový transformovaný strom, pokud byly provedeny nějaké úpravy.</span><span class="sxs-lookup"><span data-stu-id="d9b10-238">This code conditionally writes out the new transformed tree if any edits were made.</span></span> <span data-ttu-id="d9b10-239">Vypisovač by měl změnit strom pouze v případě, že narazí na jednu nebo více deklarací místních proměnných, které by mohly být zjednodušeny pomocí odvození typu:</span><span class="sxs-lookup"><span data-stu-id="d9b10-239">Your rewriter should only modify a tree if it encounters one or more local variable declarations that could be simplified using type inference:</span></span>

[!code-csharp[TransformTrees](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/Program.cs#TransformTrees "Transform and save any trees that are modified by the rewriter")]

<span data-ttu-id="d9b10-240">Měli byste vidět klikyháky pod kódem. `File.WriteAllText`</span><span class="sxs-lookup"><span data-stu-id="d9b10-240">You should see squiggles under the `File.WriteAllText` code.</span></span> <span data-ttu-id="d9b10-241">Vyberte žárovku a přidejte potřebný `using System.IO;` příkaz.</span><span class="sxs-lookup"><span data-stu-id="d9b10-241">Select the light bulb, and add the necessary `using System.IO;` statement.</span></span>

<span data-ttu-id="d9b10-242">Už jsi skoro hotov!</span><span class="sxs-lookup"><span data-stu-id="d9b10-242">You're almost done!</span></span> <span data-ttu-id="d9b10-243">Je tu jednou krok vlevo: <xref:Microsoft.CodeAnalysis.Compilation>vytvoření testu .</span><span class="sxs-lookup"><span data-stu-id="d9b10-243">There's once step left: creating a test <xref:Microsoft.CodeAnalysis.Compilation>.</span></span> <span data-ttu-id="d9b10-244">Vzhledem k tomu, že jste během tohoto rychlého startu vůbec nepoužívali odvození typu, bylo by to perfektní testovací případ.</span><span class="sxs-lookup"><span data-stu-id="d9b10-244">Since you haven't been using type inference at all during this quickstart, it would have made a perfect test case.</span></span> <span data-ttu-id="d9b10-245">Bohužel vytvoření kompilace ze souboru projektu Jazyka C# je nad rámec tohoto návodu.</span><span class="sxs-lookup"><span data-stu-id="d9b10-245">Unfortunately, creating a Compilation from a C# project file is beyond the scope of this walkthrough.</span></span> <span data-ttu-id="d9b10-246">Ale naštěstí, pokud jste byli pečlivě podle pokynů, je tu naděje.</span><span class="sxs-lookup"><span data-stu-id="d9b10-246">But fortunately, if you've been following instructions carefully, there's hope.</span></span> <span data-ttu-id="d9b10-247">Obsah metody `CreateTestCompilation` nahraďte následujícím kódem.</span><span class="sxs-lookup"><span data-stu-id="d9b10-247">Replace the contents of the `CreateTestCompilation` method with the following code.</span></span> <span data-ttu-id="d9b10-248">Vytvoří testovací kompilaci, která shodou okolností odpovídá projektu popsanému v tomto rychlém startu:</span><span class="sxs-lookup"><span data-stu-id="d9b10-248">It creates a test compilation that coincidentally matches the project described in this quickstart:</span></span>

[!code-csharp[CreateTestCompilation](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/Program.cs#CreateTestCompilation "Create a test compilation using the code written for this quickstart.")]

<span data-ttu-id="d9b10-249">Zkřížit prsty a spustit projekt.</span><span class="sxs-lookup"><span data-stu-id="d9b10-249">Cross your fingers and run the project.</span></span> <span data-ttu-id="d9b10-250">V sadě Visual Studio zvolte **Ladění** > **ladění startování**.</span><span class="sxs-lookup"><span data-stu-id="d9b10-250">In Visual Studio, choose **Debug** > **Start Debugging**.</span></span> <span data-ttu-id="d9b10-251">Měli byste být vyzváni Visual Studio, že soubory v projektu byly změněny.</span><span class="sxs-lookup"><span data-stu-id="d9b10-251">You should be prompted by Visual Studio that the files in your project have changed.</span></span> <span data-ttu-id="d9b10-252">Klepnutím na tlačítko **"Ano všem"** znovu načtěte upravené soubory.</span><span class="sxs-lookup"><span data-stu-id="d9b10-252">Click "**Yes to All**" to reload the modified files.</span></span> <span data-ttu-id="d9b10-253">Prozkoumejte je, abyste pozorovali vaši úžasnost.</span><span class="sxs-lookup"><span data-stu-id="d9b10-253">Examine them to observe your awesomeness.</span></span> <span data-ttu-id="d9b10-254">Všimněte si, kolik čistší kód vypadá bez všech těchto explicitní a redundantní specifikátory typu.</span><span class="sxs-lookup"><span data-stu-id="d9b10-254">Note how much cleaner the code looks without all those explicit and redundant type specifiers.</span></span>

<span data-ttu-id="d9b10-255">Blahopřejeme!</span><span class="sxs-lookup"><span data-stu-id="d9b10-255">Congratulations!</span></span> <span data-ttu-id="d9b10-256">Použili jste **kompilátor uapik** k napsání vlastní refaktoring, který prohledává všechny soubory v projektu C# pro určité syntaktické vzory, analyzuje sémantiku zdrojového kódu, který odpovídá tyto vzory a transformuje ji.</span><span class="sxs-lookup"><span data-stu-id="d9b10-256">You've used the **Compiler APIs** to write your own refactoring that searches all files in a C# project for certain syntactic patterns, analyzes the semantics of source code that matches those patterns, and transforms it.</span></span> <span data-ttu-id="d9b10-257">Teď jsi oficiálně refaktorující autor!</span><span class="sxs-lookup"><span data-stu-id="d9b10-257">You're now officially refactoring author!</span></span>
