---
title: Upgrade polí API pro typy odkazů s možnou hodnotou null s atributy, které definují očekávání pro hodnoty null
description: Naučte se používat popisné atributy AllowNull, DisallowNull, MaybeNull, NotNull a další plně popsat stav null vašich api.
ms.technology: csharp-null-safety
ms.date: 07/31/2019
ms.openlocfilehash: 7f78bd0224f93b4b9dcc2b9d4e3577db06497907
ms.sourcegitcommit: c91110ef6ee3fedb591f3d628dc17739c4a7071e
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 04/15/2020
ms.locfileid: "81389589"
---
# <a name="update-libraries-to-use-nullable-reference-types-and-communicate-nullable-rules-to-callers"></a><span data-ttu-id="2f20e-103">Aktualizace knihoven za účelem použití typů odkazů s možnou hodnotou null a komunikace pravidel s možnou hodnotou null volajícím</span><span class="sxs-lookup"><span data-stu-id="2f20e-103">Update libraries to use nullable reference types and communicate nullable rules to callers</span></span>

<span data-ttu-id="2f20e-104">Přidání [typů odkazů s možnou hodnotou](nullable-references.md) null `null` znamená, že můžete deklarovat, zda je hodnota povolena nebo očekávána pro každou proměnnou.</span><span class="sxs-lookup"><span data-stu-id="2f20e-104">The addition of [nullable reference types](nullable-references.md) means you can declare whether or not a `null` value is allowed or expected for every variable.</span></span> <span data-ttu-id="2f20e-105">Kromě toho `AllowNull`můžete použít řadu atributů: `DisallowNull` `MaybeNull`, `NotNull` `NotNullWhen`, `MaybeNullWhen`, `NotNullIfNotNull` , a zcela popsat nulové stavy argumentů a vrácených hodnot.</span><span class="sxs-lookup"><span data-stu-id="2f20e-105">In addition, you can apply a number of attributes: `AllowNull`, `DisallowNull`, `MaybeNull`, `NotNull`, `NotNullWhen`, `MaybeNullWhen`, and `NotNullIfNotNull` to completely describe the null states of argument and return values.</span></span> <span data-ttu-id="2f20e-106">To poskytuje skvělé zkušenosti při psaní kódu.</span><span class="sxs-lookup"><span data-stu-id="2f20e-106">That provides a great experience as you write code.</span></span> <span data-ttu-id="2f20e-107">Upozornění se vám objeví, pokud může být `null`proměnná s možnou hodnotou null nastavena na hodnotu .</span><span class="sxs-lookup"><span data-stu-id="2f20e-107">You get warnings if a non-nullable variable might be set to `null`.</span></span> <span data-ttu-id="2f20e-108">Upozornění, pokud proměnná s možnou hodnotou null není před dereferenced.</span><span class="sxs-lookup"><span data-stu-id="2f20e-108">You get warnings if a nullable variable isn't null-checked before you dereference it.</span></span> <span data-ttu-id="2f20e-109">Aktualizace knihoven může nějakou dobu trvat, ale odměny stojí za to.</span><span class="sxs-lookup"><span data-stu-id="2f20e-109">Updating your libraries can take time, but the payoffs are worth it.</span></span> <span data-ttu-id="2f20e-110">Čím více informací, které poskytnete `null` kompilátoru o *tom, kdy* je hodnota povolena nebo zakázána, tím lepší upozornění uživatelé vašeho rozhraní API získají.</span><span class="sxs-lookup"><span data-stu-id="2f20e-110">The more information you provide to the compiler about *when* a `null` value is allowed or prohibited, the better warnings users of your API will get.</span></span> <span data-ttu-id="2f20e-111">Začněme se známým příkladem.</span><span class="sxs-lookup"><span data-stu-id="2f20e-111">Let's start with a familiar example.</span></span> <span data-ttu-id="2f20e-112">Představte si, že vaše knihovna má následující rozhraní API pro načtení řetězce prostředků:</span><span class="sxs-lookup"><span data-stu-id="2f20e-112">Imagine your library has the following API to retrieve a resource string:</span></span>

```csharp
bool TryGetMessage(string key, out string message)
```

<span data-ttu-id="2f20e-113">Předchozí příklad následuje známý `Try*` vzor v rozhraní .NET.</span><span class="sxs-lookup"><span data-stu-id="2f20e-113">The preceding example follows the familiar `Try*` pattern in .NET.</span></span> <span data-ttu-id="2f20e-114">Existují dva referenční argumenty pro `key` toto `message` rozhraní API: a parametr.</span><span class="sxs-lookup"><span data-stu-id="2f20e-114">There are two reference arguments for this API: the `key` and the `message` parameter.</span></span> <span data-ttu-id="2f20e-115">Toto rozhraní API má následující pravidla týkající se nullness těchto argumentů:</span><span class="sxs-lookup"><span data-stu-id="2f20e-115">This API has the following rules relating to the nullness of these arguments:</span></span>

- <span data-ttu-id="2f20e-116">Volající by neměli `null` projít jako `key`argument pro .</span><span class="sxs-lookup"><span data-stu-id="2f20e-116">Callers shouldn't pass `null` as the argument for `key`.</span></span>
- <span data-ttu-id="2f20e-117">Volající mohou předat proměnnou, `null` jejíž `message`hodnota je jako argument pro .</span><span class="sxs-lookup"><span data-stu-id="2f20e-117">Callers can pass a variable whose value is `null` as the argument for `message`.</span></span>
- <span data-ttu-id="2f20e-118">Pokud `TryGetMessage` metoda `true`vrátí , `message` hodnota není null.</span><span class="sxs-lookup"><span data-stu-id="2f20e-118">If the `TryGetMessage` method returns `true`, the value of `message` isn't null.</span></span> <span data-ttu-id="2f20e-119">Pokud je `false,` vrácená hodnota `message` hodnota (a její stav null) je null.</span><span class="sxs-lookup"><span data-stu-id="2f20e-119">If the return value is `false,` the value of `message` (and its null state) is null.</span></span>

<span data-ttu-id="2f20e-120">Pravidlo pro `key` může být zcela vyjádřeno `key` typem proměnné: by měl být typ odkazu s hodnotou nes hotelnou hodnotou null.</span><span class="sxs-lookup"><span data-stu-id="2f20e-120">The rule for `key` can be completely expressed by the variable type: `key` should be a non-nullable reference type.</span></span> <span data-ttu-id="2f20e-121">Parametr `message` je složitější.</span><span class="sxs-lookup"><span data-stu-id="2f20e-121">The `message` parameter is more complex.</span></span> <span data-ttu-id="2f20e-122">Umožňuje `null` jako argument, ale zaručuje, že na `out` úspěch, že argument není null.</span><span class="sxs-lookup"><span data-stu-id="2f20e-122">It allows `null` as the argument, but guarantees that, on success, that `out` argument isn't null.</span></span> <span data-ttu-id="2f20e-123">Pro tyto scénáře potřebujete bohatší slovní zásobu k popisu očekávání.</span><span class="sxs-lookup"><span data-stu-id="2f20e-123">For these scenarios, you need a richer vocabulary to describe the expectations.</span></span>

<span data-ttu-id="2f20e-124">Aktualizace knihovny pro odkazy s možnou `?` hodnotou null vyžaduje více než pokrokání na některé proměnné a názvy typů.</span><span class="sxs-lookup"><span data-stu-id="2f20e-124">Updating your library for nullable references requires more than sprinkling `?` on some of the variables and type names.</span></span> <span data-ttu-id="2f20e-125">Předchozí příklad ukazuje, že je třeba prozkoumat vaše api a zvážit vaše očekávání pro každý vstupní argument.</span><span class="sxs-lookup"><span data-stu-id="2f20e-125">The preceding example shows that you need to examine your APIs and consider your expectations for each input argument.</span></span> <span data-ttu-id="2f20e-126">Zvažte záruky pro vrácenou hodnotu a všechny `out` nebo `ref` argumenty na vrácení metody.</span><span class="sxs-lookup"><span data-stu-id="2f20e-126">Consider the guarantees for the return value, and any `out` or `ref` arguments upon the method's return.</span></span> <span data-ttu-id="2f20e-127">Pak sdělte tato pravidla kompilátoru a kompilátor poskytne upozornění, když volající nedodržují tato pravidla.</span><span class="sxs-lookup"><span data-stu-id="2f20e-127">Then communicate those rules to the compiler, and the compiler will provide warnings when callers don't abide by those rules.</span></span>

<span data-ttu-id="2f20e-128">Tahle práce chce čas.</span><span class="sxs-lookup"><span data-stu-id="2f20e-128">This work takes time.</span></span> <span data-ttu-id="2f20e-129">Začněme se strategiemi, aby vaše knihovna nebo aplikace byla upozorněna na nulu a zároveň vyvažovala další požadavky a dodávky.</span><span class="sxs-lookup"><span data-stu-id="2f20e-129">Let's start with strategies to make your library or application nullable-aware, while balancing other requirements and deliverables.</span></span> <span data-ttu-id="2f20e-130">Uvidíte, jak vyvážit probíhající vývoj, který umožňuje typy odkazů s možnou hodnotou null.</span><span class="sxs-lookup"><span data-stu-id="2f20e-130">You'll see how to balance ongoing development enabling nullable reference types.</span></span> <span data-ttu-id="2f20e-131">Dozvíte se výzvy pro definice obecných typů.</span><span class="sxs-lookup"><span data-stu-id="2f20e-131">You'll learn challenges for generic type definitions.</span></span> <span data-ttu-id="2f20e-132">Naučíte se použít atributy k popisu před a po podmínkách na jednotlivých api.</span><span class="sxs-lookup"><span data-stu-id="2f20e-132">You'll learn to apply attributes to describe pre- and post-conditions on individual APIs.</span></span>

## <a name="choose-a-strategy-for-nullable-reference-types"></a><span data-ttu-id="2f20e-133">Zvolte strategii pro typy odkazů s možnou hodnotou null.</span><span class="sxs-lookup"><span data-stu-id="2f20e-133">Choose a strategy for nullable reference types</span></span>

<span data-ttu-id="2f20e-134">První volbou je, zda null typy odkazů by měly být zapnuty nebo vypnuty ve výchozím nastavení.</span><span class="sxs-lookup"><span data-stu-id="2f20e-134">The first choice is whether nullable reference types should be on or off by default.</span></span> <span data-ttu-id="2f20e-135">Máte dvě strategie:</span><span class="sxs-lookup"><span data-stu-id="2f20e-135">You have two strategies:</span></span>

- <span data-ttu-id="2f20e-136">Povolte typy odkazů s možnou hodnotou null pro celý projekt a zakažte je v kódu, který není připraven.</span><span class="sxs-lookup"><span data-stu-id="2f20e-136">Enable nullable reference types for the entire project, and disable it in code that's not ready.</span></span>
- <span data-ttu-id="2f20e-137">Povolit pouze typy odkazů s možnou hodnotou null pro kód, který byl anotován pro typy odkazů s možnou hodnotou null.</span><span class="sxs-lookup"><span data-stu-id="2f20e-137">Only enable nullable reference types for code that's been annotated for nullable reference types.</span></span>

<span data-ttu-id="2f20e-138">První strategie funguje nejlépe, když přidáváte další funkce do knihovny při aktualizaci pro typy odkazů s možnou hodnotou null.</span><span class="sxs-lookup"><span data-stu-id="2f20e-138">The first strategy works best when you're adding other features to the library as you update it for nullable reference types.</span></span> <span data-ttu-id="2f20e-139">Všechny nové vývoj je null,,,,,,,,,,,,,,,,,,,,,</span><span class="sxs-lookup"><span data-stu-id="2f20e-139">All new development is nullable aware.</span></span> <span data-ttu-id="2f20e-140">Při aktualizaci existujícího kódu povolíte v těchto třídách typy odkazů s možnou hodnotou null.</span><span class="sxs-lookup"><span data-stu-id="2f20e-140">As you update existing code, you enable nullable reference types in those classes.</span></span>

<span data-ttu-id="2f20e-141">Po této první strategii postupujte takto:</span><span class="sxs-lookup"><span data-stu-id="2f20e-141">Following this first strategy, you do the following:</span></span>

1. <span data-ttu-id="2f20e-142">Povolte typy odkazů s možnou `<Nullable>enable</Nullable>` hodnotou null pro celý projekt přidáním prvku do souborů *csproj.*</span><span class="sxs-lookup"><span data-stu-id="2f20e-142">Enable nullable reference types for the entire project by adding the `<Nullable>enable</Nullable>` element to your *csproj* files.</span></span>
1. <span data-ttu-id="2f20e-143">Přidejte `#nullable disable` pragma do každého zdrojového souboru v projektu.</span><span class="sxs-lookup"><span data-stu-id="2f20e-143">Add the `#nullable disable` pragma to every source file in your project.</span></span>
1. <span data-ttu-id="2f20e-144">Při práci na každém souboru odeberte pragmu a zřete všechna varování.</span><span class="sxs-lookup"><span data-stu-id="2f20e-144">As you work on each file, remove the pragma and address any warnings.</span></span>

<span data-ttu-id="2f20e-145">Tato první strategie má více práce předem přidat pragma do každého souboru.</span><span class="sxs-lookup"><span data-stu-id="2f20e-145">This first strategy has more up-front work to add the pragma to every file.</span></span> <span data-ttu-id="2f20e-146">Výhodou je, že každý nový soubor kódu přidaný do projektu bude mít hodnotu null povolenou hodnotou.</span><span class="sxs-lookup"><span data-stu-id="2f20e-146">The advantage is that every new code file added to the project will be nullable enabled.</span></span> <span data-ttu-id="2f20e-147">Všechny nové práce budou nullable vědomi; je třeba aktualizovat pouze existující kód.</span><span class="sxs-lookup"><span data-stu-id="2f20e-147">Any new work will be nullable aware; only existing code must be updated.</span></span>

<span data-ttu-id="2f20e-148">Druhá strategie funguje lépe, pokud je knihovna obecně stabilní a hlavním zaměřením vývoje je přijmout typy odkazů s možnou hodnotou null.</span><span class="sxs-lookup"><span data-stu-id="2f20e-148">The second strategy works better if the library is generally stable, and the main focus of the development is to adopt nullable reference types.</span></span> <span data-ttu-id="2f20e-149">Při osazování polí API zapnete typy odkazů s možnou hodnotou null.</span><span class="sxs-lookup"><span data-stu-id="2f20e-149">You turn on nullable reference types as you annotate APIs.</span></span> <span data-ttu-id="2f20e-150">Po dokončení povolíte typy odkazů s možnou hodnotou null pro celý projekt.</span><span class="sxs-lookup"><span data-stu-id="2f20e-150">When you've finished, you enable nullable reference types for the entire project.</span></span>

<span data-ttu-id="2f20e-151">V návaznosti na tuto druhou strategii postupujte takto:</span><span class="sxs-lookup"><span data-stu-id="2f20e-151">Following this second strategy you do the following:</span></span>

1. <span data-ttu-id="2f20e-152">Přidejte `#nullable enable` pragma do souboru, který chcete, aby null být vědomi.</span><span class="sxs-lookup"><span data-stu-id="2f20e-152">Add the `#nullable enable` pragma to the file you want to make nullable aware.</span></span>
1. <span data-ttu-id="2f20e-153">Adresují všechna varování.</span><span class="sxs-lookup"><span data-stu-id="2f20e-153">Address any warnings.</span></span>
1. <span data-ttu-id="2f20e-154">Pokračujte v těchto prvních dvou krocích, dokud neuvědomíte celou knihovnu, která by byla známa.</span><span class="sxs-lookup"><span data-stu-id="2f20e-154">Continue these first two steps until you've made the entire library nullable aware.</span></span>
1. <span data-ttu-id="2f20e-155">Povolte typy s možnou hodnotou null pro celý projekt přidáním `<Nullable>enable</Nullable>` prvku do souborů *csproj.*</span><span class="sxs-lookup"><span data-stu-id="2f20e-155">Enable nullable types for the entire project by adding the `<Nullable>enable</Nullable>` element to your *csproj* files.</span></span>
1. <span data-ttu-id="2f20e-156">Odstraňte `#nullable enable` pragmy, protože už nejsou potřeba.</span><span class="sxs-lookup"><span data-stu-id="2f20e-156">Remove the `#nullable enable` pragmas, as they're no longer needed.</span></span>

<span data-ttu-id="2f20e-157">Tato druhá strategie má méně práce předem.</span><span class="sxs-lookup"><span data-stu-id="2f20e-157">This second strategy has less work up-front.</span></span> <span data-ttu-id="2f20e-158">Kompromis je, že první úkol při vytváření nového souboru je přidat pragma a učinit ji nullable aware.</span><span class="sxs-lookup"><span data-stu-id="2f20e-158">The tradeoff is that the first task when you create a new file is to add the pragma and make it nullable aware.</span></span> <span data-ttu-id="2f20e-159">Pokud všichni vývojáři ve vašem týmu zapomenout, že nový kód je nyní v nevyřízených položkách práce, aby všechny kód nullable aware.</span><span class="sxs-lookup"><span data-stu-id="2f20e-159">If any developers on your team forget, that new code is now in the backlog of work to make all code nullable aware.</span></span>

<span data-ttu-id="2f20e-160">Která z těchto strategií si vyberete, závisí na tom, kolik aktivního vývoje probíhá ve vašem projektu.</span><span class="sxs-lookup"><span data-stu-id="2f20e-160">Which of these strategies you pick depends on how much active development is taking place in your project.</span></span> <span data-ttu-id="2f20e-161">Čím zralejší a stabilnější váš projekt, tím lepší je druhá strategie.</span><span class="sxs-lookup"><span data-stu-id="2f20e-161">The more mature and stable your project, the better the second strategy.</span></span> <span data-ttu-id="2f20e-162">Čím více funkcí se vyvíjí, tím lepší je první strategie.</span><span class="sxs-lookup"><span data-stu-id="2f20e-162">The more features being developed, the better the first strategy.</span></span>

## <a name="should-nullable-warnings-introduce-breaking-changes"></a><span data-ttu-id="2f20e-163">Měla by zavést neplatné výstrahy narušující změny?</span><span class="sxs-lookup"><span data-stu-id="2f20e-163">Should nullable warnings introduce breaking changes?</span></span>

<span data-ttu-id="2f20e-164">Před povolením typů odkazů s možnou hodnotou null jsou proměnné považovány za *netečné*.</span><span class="sxs-lookup"><span data-stu-id="2f20e-164">Before you enable nullable reference types, variables are considered *nullable oblivious*.</span></span> <span data-ttu-id="2f20e-165">Jakmile povolíte typy odkazů s možnou hodnotou null, všechny tyto proměnné jsou *nenulové*.</span><span class="sxs-lookup"><span data-stu-id="2f20e-165">Once you enable nullable reference types, all those variables are *non-nullable*.</span></span> <span data-ttu-id="2f20e-166">Kompilátor vydá upozornění, pokud tyto proměnné nejsou inicializovány na hodnoty bez nuly.</span><span class="sxs-lookup"><span data-stu-id="2f20e-166">The compiler will issue warnings if those variables aren't initialized to non-null values.</span></span>

<span data-ttu-id="2f20e-167">Dalším pravděpodobným zdrojem upozornění je vrácené hodnoty, pokud hodnota nebyla inicializována.</span><span class="sxs-lookup"><span data-stu-id="2f20e-167">Another likely source of warnings is return values when the value hasn't been initialized.</span></span>

<span data-ttu-id="2f20e-168">Prvním krokem při adresování upozornění kompilátoru je použití `?` anotací na parametr a návratové typy k označení, kdy argumenty nebo vrácené hodnoty mohou být nulové.</span><span class="sxs-lookup"><span data-stu-id="2f20e-168">The first step in addressing the compiler warnings is to use `?` annotations on parameter and return types to indicate when arguments or return values may be null.</span></span> <span data-ttu-id="2f20e-169">Pokud referenční proměnné nesmí být null, původní deklarace je správná.</span><span class="sxs-lookup"><span data-stu-id="2f20e-169">When reference variables must not be null, the original declaration is correct.</span></span> <span data-ttu-id="2f20e-170">Jak to uděláte, vaším cílem není jen opravit varování.</span><span class="sxs-lookup"><span data-stu-id="2f20e-170">As you do this, your goal isn't just to fix warnings.</span></span> <span data-ttu-id="2f20e-171">Důležitější je, aby kompilátor pochopil váš záměr pro potenciální hodnoty null.</span><span class="sxs-lookup"><span data-stu-id="2f20e-171">The more important goal is to make the compiler understand your intent for potential null values.</span></span> <span data-ttu-id="2f20e-172">Při zkoumání varování dosáhnete dalšího zásadního rozhodnutí pro vaši knihovnu.</span><span class="sxs-lookup"><span data-stu-id="2f20e-172">As you examine the warnings, you reach your next major decision for your library.</span></span> <span data-ttu-id="2f20e-173">Chcete zvážit úpravu podpisů rozhraní API tak, aby jasněji sdělovaly záměr návrhu?</span><span class="sxs-lookup"><span data-stu-id="2f20e-173">Do you want to consider modifying API signatures to more clearly communicate your design intent?</span></span> <span data-ttu-id="2f20e-174">Lepší podpis rozhraní `TryGetMessage` API pro dříve zkoumanou metodu může být:</span><span class="sxs-lookup"><span data-stu-id="2f20e-174">A better API signature for the `TryGetMessage` method examined earlier could be:</span></span>

```csharp
string? TryGetMessage(string key);
```

<span data-ttu-id="2f20e-175">Vrácená hodnota označuje úspěch nebo neúspěch a nese hodnotu, pokud byla nalezena hodnota.</span><span class="sxs-lookup"><span data-stu-id="2f20e-175">The return value indicates success or failure, and carries the value if the value was found.</span></span> <span data-ttu-id="2f20e-176">V mnoha případech může změna podpisů rozhraní API zlepšit způsob, jakým komunikují hodnoty null.</span><span class="sxs-lookup"><span data-stu-id="2f20e-176">In many cases, changing API signatures can improve how they communicate null values.</span></span>

<span data-ttu-id="2f20e-177">Pro veřejné knihovny nebo knihovny s velkými uživatelskými základnami však můžete upřednostňovat nezavádět žádné změny podpisu rozhraní API.</span><span class="sxs-lookup"><span data-stu-id="2f20e-177">However, for public libraries, or libraries with large user bases, you may prefer not introducing any API signature changes.</span></span> <span data-ttu-id="2f20e-178">Pro tyto případy a další běžné vzory můžete atributy použít jasněji definovat, `null`kdy argument nebo vrácená hodnota může být .</span><span class="sxs-lookup"><span data-stu-id="2f20e-178">For those cases, and other common patterns, you can apply attributes to more clearly define when an argument or return value may be `null`.</span></span> <span data-ttu-id="2f20e-179">Bez ohledu na to, zda uvažujete o změně povrchu rozhraní API, pravděpodobně zjistíte, `null` že samotné poznámky typu nejsou dostatečné pro popis hodnot argumentů nebo vrácených hodnot.</span><span class="sxs-lookup"><span data-stu-id="2f20e-179">Whether or not you consider changing the surface of your API, you'll likely find that type annotations alone aren't sufficient for describing `null` values for arguments or return values.</span></span> <span data-ttu-id="2f20e-180">V těchto případech můžete atributy použít jasněji popsat rozhraní API.</span><span class="sxs-lookup"><span data-stu-id="2f20e-180">In those instances, you can apply attributes to more clearly describe an API.</span></span>

## <a name="attributes-extend-type-annotations"></a><span data-ttu-id="2f20e-181">Atributy rozšiřují poznámky typu</span><span class="sxs-lookup"><span data-stu-id="2f20e-181">Attributes extend type annotations</span></span>

<span data-ttu-id="2f20e-182">Několik atributů byly přidány vyjádřit další informace o stavu null proměnných.</span><span class="sxs-lookup"><span data-stu-id="2f20e-182">Several attributes have been added to express additional information about the null state of variables.</span></span> <span data-ttu-id="2f20e-183">Veškerý kód, který jste napsali před c# 8 představil null reference typy byl *null nevšímavý*.</span><span class="sxs-lookup"><span data-stu-id="2f20e-183">All code you wrote before C# 8 introduced nullable reference types was *null oblivious*.</span></span> <span data-ttu-id="2f20e-184">To znamená, že všechny proměnné typu odkazu může být null, ale null kontroly nejsou vyžadovány.</span><span class="sxs-lookup"><span data-stu-id="2f20e-184">That means any reference type variable may be null, but null checks aren't required.</span></span> <span data-ttu-id="2f20e-185">Jakmile váš kód je *null,,,* tato pravidla změnit.</span><span class="sxs-lookup"><span data-stu-id="2f20e-185">Once your code is *nullable aware*, those rules change.</span></span> <span data-ttu-id="2f20e-186">Referenční typy by `null` nikdy měla být hodnota a nullable `null` typy odkazů musí být zkontrolovány proti před tím, než je odkazováno.</span><span class="sxs-lookup"><span data-stu-id="2f20e-186">Reference types should never be the `null` value, and nullable reference types must be checked against `null` before being dereferenced.</span></span>

<span data-ttu-id="2f20e-187">Pravidla pro vaše rozhraní API jsou pravděpodobně složitější, `TryGetValue` jak jste viděli u scénáře rozhraní API.</span><span class="sxs-lookup"><span data-stu-id="2f20e-187">The rules for your APIs are likely more complicated, as you saw with the `TryGetValue` API scenario.</span></span> <span data-ttu-id="2f20e-188">Mnoho vašich api mají složitější pravidla pro proměnné může `null`nebo nemůže být .</span><span class="sxs-lookup"><span data-stu-id="2f20e-188">Many of your APIs have more complex rules for when variables can or can't be `null`.</span></span> <span data-ttu-id="2f20e-189">V těchto případech budete používat atributy k vyjádření těchto pravidel.</span><span class="sxs-lookup"><span data-stu-id="2f20e-189">In these cases, you'll use attributes to express those rules.</span></span> <span data-ttu-id="2f20e-190">Atributy, které popisují sémantiku rozhraní API, najdete v článku [o atributy, které mají vliv na analýzu, kterou lze udatnou hodnotu](./language-reference/attributes/nullable-analysis.md).</span><span class="sxs-lookup"><span data-stu-id="2f20e-190">The attributes that describe the semantics of your API are found in the article on [Attributes that impact nullable analysis](./language-reference/attributes/nullable-analysis.md).</span></span>

## <a name="generic-definitions-and-nullability"></a><span data-ttu-id="2f20e-191">Obecné definice a nullability</span><span class="sxs-lookup"><span data-stu-id="2f20e-191">Generic definitions and nullability</span></span>

<span data-ttu-id="2f20e-192">Správná komunikace nulového stavu obecných typů a obecných metod vyžaduje zvláštní péči.</span><span class="sxs-lookup"><span data-stu-id="2f20e-192">Correctly communicating the null state of generic types and generic methods requires special care.</span></span> <span data-ttu-id="2f20e-193">To vyplývá ze skutečnosti, že typ hodnoty s možnou hodnotou s hodnotou null a typ odkazu s možnou hodnotou s možnou hodnotou null se zásadně liší.</span><span class="sxs-lookup"><span data-stu-id="2f20e-193">This stems from the fact that a nullable value type and a nullable reference type are fundamentally different.</span></span> <span data-ttu-id="2f20e-194">Synonymum `int?` pro `Nullable<int>`, `string?` vzhledem k tomu, že je `string` s atributem přidaným kompilátorem.</span><span class="sxs-lookup"><span data-stu-id="2f20e-194">An `int?` is a synonym for `Nullable<int>`, whereas `string?` is `string` with an attribute added by the compiler.</span></span> <span data-ttu-id="2f20e-195">Výsledkem je, že kompilátor nemůže `T?` generovat správný `T` kód, aniž by věděl, zda je `class` nebo `struct`.</span><span class="sxs-lookup"><span data-stu-id="2f20e-195">The result is that the compiler can't generate correct code for `T?` without knowing if `T` is a `class` or a `struct`.</span></span>

<span data-ttu-id="2f20e-196">To neznamená, že nelze použít typ s hodnotou null (typ hodnoty nebo typ odkazu) jako argument typu pro uzavřený obecný typ.</span><span class="sxs-lookup"><span data-stu-id="2f20e-196">This doesn't mean you can't use a nullable type (either value type or reference type) as the type argument for a closed generic type.</span></span> <span data-ttu-id="2f20e-197">Oba `List<string?>` `List<int?>` a jsou platné instance `List<T>`.</span><span class="sxs-lookup"><span data-stu-id="2f20e-197">Both `List<string?>` and `List<int?>` are valid instantiations of `List<T>`.</span></span>

<span data-ttu-id="2f20e-198">Co to znamená, že nelze `T?` použít v deklaraci obecné třídy nebo metody bez omezení.</span><span class="sxs-lookup"><span data-stu-id="2f20e-198">What it does mean is that you can't use `T?` in a generic class or method declaration without constraints.</span></span> <span data-ttu-id="2f20e-199">Například <xref:System.Linq.Enumerable.FirstOrDefault%60%601(System.Collections.Generic.IEnumerable%7B%60%600%7D)?displayProperty=nameWithType> nebude změněn na návrat `T?`.</span><span class="sxs-lookup"><span data-stu-id="2f20e-199">For example, <xref:System.Linq.Enumerable.FirstOrDefault%60%601(System.Collections.Generic.IEnumerable%7B%60%600%7D)?displayProperty=nameWithType> won't be changed to return `T?`.</span></span> <span data-ttu-id="2f20e-200">Toto omezení můžete překonat `struct` přidáním omezení nebo. `class`</span><span class="sxs-lookup"><span data-stu-id="2f20e-200">You can overcome this limitation by adding either the `struct` or `class` constraint.</span></span> <span data-ttu-id="2f20e-201">S některou z těchto omezení kompilátor ví, `T` `T?`jak generovat kód pro oba a .</span><span class="sxs-lookup"><span data-stu-id="2f20e-201">With either of those constraints, the compiler knows how to generate code for both `T` and `T?`.</span></span>

<span data-ttu-id="2f20e-202">Můžete chtít omezit typy používané pro obecný typ argumentu, které mají být nenulové typy.</span><span class="sxs-lookup"><span data-stu-id="2f20e-202">You may want to restrict the types used for a generic type argument to be non-nullable types.</span></span> <span data-ttu-id="2f20e-203">Můžete to udělat přidáním `notnull` omezení pro tento argument typu.</span><span class="sxs-lookup"><span data-stu-id="2f20e-203">You can do that by adding the `notnull` constraint on that type argument.</span></span> <span data-ttu-id="2f20e-204">When that constraint is applied, the type argument must not be a nullable type.</span><span class="sxs-lookup"><span data-stu-id="2f20e-204">When that constraint is applied, the type argument must not be a nullable type.</span></span>
