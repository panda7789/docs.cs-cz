---
title: Generování a využívání asynchronních datových proudů
description: V tomto rozšířeném kurzu se dozvíte, jak generovat a využívat asynchronní streamy. Asynchronní datové proudy poskytují přirozenější způsob práce s posloupnosti dat, která mohou být vygenerována asynchronně.
ms.date: 02/10/2019
ms.technology: csharp-async
ms.custom: mvc
ms.openlocfilehash: 03254e5208a048469f4753d632de7b0d451cde40
ms.sourcegitcommit: 5988e9a29cedb8757320817deda3c08c6f44a6aa
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 04/28/2020
ms.locfileid: "82200103"
---
# <a name="tutorial-generate-and-consume-async-streams-using-c-80-and-net-core-30"></a><span data-ttu-id="070e1-104">Kurz: generování a využívání asynchronních datových proudů pomocí C# 8,0 a .NET Core 3,0</span><span class="sxs-lookup"><span data-stu-id="070e1-104">Tutorial: Generate and consume async streams using C# 8.0 and .NET Core 3.0</span></span>

<span data-ttu-id="070e1-105">C# 8,0 zavádí **asynchronní streamy**, které modelují zdroj dat streamování.</span><span class="sxs-lookup"><span data-stu-id="070e1-105">C# 8.0 introduces **async streams**, which model a streaming source of data.</span></span> <span data-ttu-id="070e1-106">Datové proudy často načítají nebo generují prvky asynchronně.</span><span class="sxs-lookup"><span data-stu-id="070e1-106">Data streams often retrieve or generate elements asynchronously.</span></span> <span data-ttu-id="070e1-107">Asynchronní streamy spoléhají na nová rozhraní představená v .NET Standard 2,1.</span><span class="sxs-lookup"><span data-stu-id="070e1-107">Async streams rely on new interfaces introduced in .NET Standard 2.1.</span></span> <span data-ttu-id="070e1-108">Tato rozhraní jsou podporovaná v .NET Core 3,0 a novějších verzích.</span><span class="sxs-lookup"><span data-stu-id="070e1-108">These interfaces are supported in .NET Core 3.0 and later.</span></span> <span data-ttu-id="070e1-109">Poskytují přirozený programovací model pro asynchronní streamování zdrojů dat.</span><span class="sxs-lookup"><span data-stu-id="070e1-109">They provide a natural programming model for asynchronous streaming data sources.</span></span>

<span data-ttu-id="070e1-110">V tomto kurzu se naučíte:</span><span class="sxs-lookup"><span data-stu-id="070e1-110">In this tutorial, you'll learn how to:</span></span>

> [!div class="checklist"]
>
> - <span data-ttu-id="070e1-111">Vytvořte zdroj dat, který generuje posloupnost datových prvků asynchronně.</span><span class="sxs-lookup"><span data-stu-id="070e1-111">Create a data source that generates a sequence of data elements asynchronously.</span></span>
> - <span data-ttu-id="070e1-112">Spotřebujte tento zdroj dat asynchronně.</span><span class="sxs-lookup"><span data-stu-id="070e1-112">Consume that data source asynchronously.</span></span>
> - <span data-ttu-id="070e1-113">Podpora zrušení a zachycených kontextů pro asynchronní datové proudy.</span><span class="sxs-lookup"><span data-stu-id="070e1-113">Support cancellation and captured contexts for asynchronous streams.</span></span>
> - <span data-ttu-id="070e1-114">Rozpoznat, kdy je nové rozhraní a zdroj dat upřednostňováno na dřívější synchronní sekvence dat.</span><span class="sxs-lookup"><span data-stu-id="070e1-114">Recognize when the new interface and data source are preferred to earlier synchronous data sequences.</span></span>

## <a name="prerequisites"></a><span data-ttu-id="070e1-115">Požadavky</span><span class="sxs-lookup"><span data-stu-id="070e1-115">Prerequisites</span></span>

<span data-ttu-id="070e1-116">Musíte nastavit počítač tak, aby běžel .NET Core, včetně kompilátoru C# 8,0.</span><span class="sxs-lookup"><span data-stu-id="070e1-116">You'll need to set up your machine to run .NET Core, including the C# 8.0 compiler.</span></span> <span data-ttu-id="070e1-117">Kompilátor C# 8 je k dispozici počínaje [verzí Visual Studio 2019 verze 16,3](https://visualstudio.microsoft.com/downloads/?utm_medium=microsoft&utm_source=docs.microsoft.com&utm_campaign=inline+link&utm_content=download+vs2019) nebo [.NET Core 3,0 SDK](https://dotnet.microsoft.com/download).</span><span class="sxs-lookup"><span data-stu-id="070e1-117">The C# 8 compiler is available starting with [Visual Studio 2019 version 16.3](https://visualstudio.microsoft.com/downloads/?utm_medium=microsoft&utm_source=docs.microsoft.com&utm_campaign=inline+link&utm_content=download+vs2019) or [.NET Core 3.0 SDK](https://dotnet.microsoft.com/download).</span></span>

<span data-ttu-id="070e1-118">Budete muset vytvořit [přístupový token GitHubu](https://help.github.com/articles/creating-a-personal-access-token-for-the-command-line/#creating-a-token) , abyste mohli získat přístup ke koncovému bodu GraphQL GitHubu.</span><span class="sxs-lookup"><span data-stu-id="070e1-118">You'll need to create a [GitHub access token](https://help.github.com/articles/creating-a-personal-access-token-for-the-command-line/#creating-a-token) so that you can access the GitHub GraphQL endpoint.</span></span> <span data-ttu-id="070e1-119">Pro přístupový token GitHubu vyberte následující oprávnění:</span><span class="sxs-lookup"><span data-stu-id="070e1-119">Select the following permissions for your GitHub Access Token:</span></span>

- <span data-ttu-id="070e1-120">úložiště: stav</span><span class="sxs-lookup"><span data-stu-id="070e1-120">repo:status</span></span>
- <span data-ttu-id="070e1-121">public_repo</span><span class="sxs-lookup"><span data-stu-id="070e1-121">public_repo</span></span>

<span data-ttu-id="070e1-122">Uložte přístupový token na bezpečném místě, abyste ho mohli použít k získání přístupu ke koncovému bodu rozhraní API GitHubu.</span><span class="sxs-lookup"><span data-stu-id="070e1-122">Save the access token in a safe place so you can use it to gain access to the GitHub API endpoint.</span></span>

> [!WARNING]
> <span data-ttu-id="070e1-123">Udržujte svůj osobní přístupový token zabezpečený.</span><span class="sxs-lookup"><span data-stu-id="070e1-123">Keep your personal access token secure.</span></span> <span data-ttu-id="070e1-124">Libovolný software s vaším osobním přístupovým tokenem by mohl volat rozhraní API GitHubu pomocí vašich přístupových práv.</span><span class="sxs-lookup"><span data-stu-id="070e1-124">Any software with your personal access token could make GitHub API calls using your access rights.</span></span>

<span data-ttu-id="070e1-125">V tomto kurzu se předpokládá, že máte zkušenosti s jazykem C# a .NET, včetně sady Visual Studio nebo .NET Core CLI.</span><span class="sxs-lookup"><span data-stu-id="070e1-125">This tutorial assumes you're familiar with C# and .NET, including either Visual Studio or the .NET Core CLI.</span></span>

## <a name="run-the-starter-application"></a><span data-ttu-id="070e1-126">Spuštění aplikace Starter</span><span class="sxs-lookup"><span data-stu-id="070e1-126">Run the starter application</span></span>

<span data-ttu-id="070e1-127">Kód pro úvodní aplikaci použitou v tomto kurzu můžete získat z úložiště [dotnet/docs](https://github.com/dotnet/docs) ve složce [CSharp/tutorials/AsyncStreams](https://github.com/dotnet/docs/tree/master/csharp/tutorials/snippets/generate-consume-asynchronous-streams/start) .</span><span class="sxs-lookup"><span data-stu-id="070e1-127">You can get the code for the starter application used in this tutorial from the [dotnet/docs](https://github.com/dotnet/docs) repository in the [csharp/tutorials/AsyncStreams](https://github.com/dotnet/docs/tree/master/csharp/tutorials/snippets/generate-consume-asynchronous-streams/start) folder.</span></span>

<span data-ttu-id="070e1-128">Úvodní aplikace je Konzolová aplikace, která používá rozhraní [GitHub GraphQL](https://developer.github.com/v4/) k načtení nedávných problémů napsaných v úložišti [dotnet/docs](https://github.com/dotnet/docs) .</span><span class="sxs-lookup"><span data-stu-id="070e1-128">The starter application is a console application that uses the [GitHub GraphQL](https://developer.github.com/v4/) interface to retrieve recent issues written in the [dotnet/docs](https://github.com/dotnet/docs) repository.</span></span> <span data-ttu-id="070e1-129">Začněte tím, že si vyhledáte následující kód pro `Main` metodu počáteční aplikace:</span><span class="sxs-lookup"><span data-stu-id="070e1-129">Start by looking at the following code for the starter app `Main` method:</span></span>

:::code language="csharp" source="snippets/generate-consume-asynchronous-streams/start/Program.cs" id="SnippetStarterAppMain" :::

<span data-ttu-id="070e1-130">Můžete buď nastavit proměnnou `GitHubKey` prostředí na váš osobní přístupový token, nebo můžete nahradit poslední argument v volání `GenEnvVariable` pomocí tokenu vašeho osobního přístupového tokenu.</span><span class="sxs-lookup"><span data-stu-id="070e1-130">You can either set a `GitHubKey` environment variable to your personal access token, or you can replace the last argument in the call to `GenEnvVariable` with your personal access token.</span></span> <span data-ttu-id="070e1-131">Pokud budete zdroj sdílet s ostatními, neumísťujte kód pro přístup do zdrojového kódu.</span><span class="sxs-lookup"><span data-stu-id="070e1-131">Don't put your access code in source code if you'll be sharing the source with others.</span></span> <span data-ttu-id="070e1-132">Nikdy Nenahrávat přístupové kódy do sdíleného zdrojového úložiště.</span><span class="sxs-lookup"><span data-stu-id="070e1-132">Never upload access codes to a shared source repository.</span></span>

<span data-ttu-id="070e1-133">Po vytvoření klienta GitHub kód v `Main` vytvoří objekt vytváření sestav o průběhu a token zrušení.</span><span class="sxs-lookup"><span data-stu-id="070e1-133">After creating the GitHub client, the code in `Main` creates a progress reporting object and a cancellation token.</span></span> <span data-ttu-id="070e1-134">Po vytvoření těchto objektů `Main` volání `runPagedQueryAsync` načtou nejnovější 250 vytvořené problémy.</span><span class="sxs-lookup"><span data-stu-id="070e1-134">Once those objects are created, `Main` calls `runPagedQueryAsync` to retrieve the most recent 250 created issues.</span></span> <span data-ttu-id="070e1-135">Po dokončení této úlohy se zobrazí výsledky.</span><span class="sxs-lookup"><span data-stu-id="070e1-135">After that task has finished, the results are displayed.</span></span>

<span data-ttu-id="070e1-136">Při spuštění aplikace Starter můžete provést několik důležitých pozorování, jak se tato aplikace spouští.</span><span class="sxs-lookup"><span data-stu-id="070e1-136">When you run the starter application, you can make some important observations about how this application runs.</span></span>  <span data-ttu-id="070e1-137">Uvidíte průběh nahlášený pro každou stránku vrácenou z GitHubu.</span><span class="sxs-lookup"><span data-stu-id="070e1-137">You'll see progress reported for each page returned from GitHub.</span></span> <span data-ttu-id="070e1-138">Můžete sledovat, že se pozastavená pauza ještě před tím, než GitHub vrátí všechny nové stránky problémů.</span><span class="sxs-lookup"><span data-stu-id="070e1-138">You can observe a noticeable pause before GitHub returns each new page of issues.</span></span> <span data-ttu-id="070e1-139">A konečně problémy se zobrazí až po načtení všech 10 stránek z GitHubu.</span><span class="sxs-lookup"><span data-stu-id="070e1-139">Finally, the issues are displayed only after all 10 pages have been retrieved from GitHub.</span></span>

## <a name="examine-the-implementation"></a><span data-ttu-id="070e1-140">Kontrola implementace</span><span class="sxs-lookup"><span data-stu-id="070e1-140">Examine the implementation</span></span>

<span data-ttu-id="070e1-141">Implementace odhalí, proč jste pozorováni chování popsané v předchozí části.</span><span class="sxs-lookup"><span data-stu-id="070e1-141">The implementation reveals why you observed the behavior discussed in the previous section.</span></span> <span data-ttu-id="070e1-142">Projděte si kód `runPagedQueryAsync`pro:</span><span class="sxs-lookup"><span data-stu-id="070e1-142">Examine the code for `runPagedQueryAsync`:</span></span>

:::code language="csharp" source="snippets/generate-consume-asynchronous-streams/start/Program.cs" id="SnippetRunPagedQuery" :::

<span data-ttu-id="070e1-143">Pojďme se soustředit na algoritmus stránkování a asynchronní strukturu předchozího kódu.</span><span class="sxs-lookup"><span data-stu-id="070e1-143">Let's concentrate on the paging algorithm and async structure of the preceding code.</span></span> <span data-ttu-id="070e1-144">(Podrobnosti o rozhraních API GitHub GraphQL najdete v [dokumentaci k GitHubu GraphQL](https://developer.github.com/v4/guides/) .) `runPagedQueryAsync` Metoda vytvoří výčet problémů od nejnovějších k nejstarší.</span><span class="sxs-lookup"><span data-stu-id="070e1-144">(You can consult the [GitHub GraphQL documentation](https://developer.github.com/v4/guides/) for details on the GitHub GraphQL API.) The `runPagedQueryAsync` method enumerates the issues from most recent to oldest.</span></span> <span data-ttu-id="070e1-145">Vyžádá 25 problémů na stránku a prověřuje `pageInfo` strukturu odpovědi, aby pokračovala na předchozí stránce.</span><span class="sxs-lookup"><span data-stu-id="070e1-145">It requests 25 issues per page and examines the `pageInfo` structure of the response to continue with the previous page.</span></span> <span data-ttu-id="070e1-146">To sleduje standardní podporu stránkování GraphQL pro reakce na vícestránkové stránky.</span><span class="sxs-lookup"><span data-stu-id="070e1-146">That follows GraphQL's standard paging support for multi-page responses.</span></span> <span data-ttu-id="070e1-147">Odpověď obsahuje `pageInfo` objekt, který obsahuje `hasPreviousPages` hodnotu a `startCursor` hodnotu použitou k vyžádání předchozí stránky.</span><span class="sxs-lookup"><span data-stu-id="070e1-147">The response includes a `pageInfo` object that includes a `hasPreviousPages` value and a `startCursor` value used to request the previous page.</span></span> <span data-ttu-id="070e1-148">Problémy jsou v `nodes` poli.</span><span class="sxs-lookup"><span data-stu-id="070e1-148">The issues are in the `nodes` array.</span></span> <span data-ttu-id="070e1-149">`runPagedQueryAsync` Metoda připojí tyto uzly k poli, které obsahuje všechny výsledky ze všech stránek.</span><span class="sxs-lookup"><span data-stu-id="070e1-149">The `runPagedQueryAsync` method appends these nodes to an array that contains all the results from all pages.</span></span>

<span data-ttu-id="070e1-150">Po načtení a obnovení stránky výsledků se `runPagedQueryAsync` nahlásí průběh a kontrolují zrušení.</span><span class="sxs-lookup"><span data-stu-id="070e1-150">After retrieving and restoring a page of results, `runPagedQueryAsync` reports progress and checks for cancellation.</span></span> <span data-ttu-id="070e1-151">Pokud je požadováno zrušení, `runPagedQueryAsync` vyvolá výjimku. <xref:System.OperationCanceledException></span><span class="sxs-lookup"><span data-stu-id="070e1-151">If cancellation has been requested, `runPagedQueryAsync` throws an <xref:System.OperationCanceledException>.</span></span>

<span data-ttu-id="070e1-152">Tento kód obsahuje několik prvků, které lze zlepšit.</span><span class="sxs-lookup"><span data-stu-id="070e1-152">There are several elements in this code that can be improved.</span></span> <span data-ttu-id="070e1-153">Co je nejdůležitější, `runPagedQueryAsync` musí přidělit úložiště pro všechny vrácené problémy.</span><span class="sxs-lookup"><span data-stu-id="070e1-153">Most importantly, `runPagedQueryAsync` must allocate storage for all the issues returned.</span></span> <span data-ttu-id="070e1-154">Tato ukázka zastaví problémy 250, protože načtení všech otevřených problémů by vyžadovalo mnohem více paměti pro uložení všech načtených problémů.</span><span class="sxs-lookup"><span data-stu-id="070e1-154">This sample stops at 250 issues because retrieving all open issues would require much more memory to store all the retrieved issues.</span></span> <span data-ttu-id="070e1-155">Protokoly pro podporu sestav průběhu a zrušení usnadňují pochopení algoritmu při prvním čtení.</span><span class="sxs-lookup"><span data-stu-id="070e1-155">The protocols for supporting progress reports and cancellation make the algorithm harder to understand on its first reading.</span></span> <span data-ttu-id="070e1-156">Jsou zapojeny další typy a rozhraní API.</span><span class="sxs-lookup"><span data-stu-id="070e1-156">More types and APIs are involved.</span></span> <span data-ttu-id="070e1-157">Komunikaci je nutné trasovat prostřednictvím <xref:System.Threading.CancellationTokenSource> a jejího přidruženého <xref:System.Threading.CancellationToken> k pochopení, kde je požadováno zrušení a kde je uděleno.</span><span class="sxs-lookup"><span data-stu-id="070e1-157">You must trace the communications through the <xref:System.Threading.CancellationTokenSource> and its associated <xref:System.Threading.CancellationToken> to understand where cancellation is requested and where it's granted.</span></span>

## <a name="async-streams-provide-a-better-way"></a><span data-ttu-id="070e1-158">Asynchronní streamy poskytují lepší způsob</span><span class="sxs-lookup"><span data-stu-id="070e1-158">Async streams provide a better way</span></span>

<span data-ttu-id="070e1-159">Asynchronní streamy a přidružená jazyková podpora řeší všechna tyto aspekty.</span><span class="sxs-lookup"><span data-stu-id="070e1-159">Async streams and the associated language support address all those concerns.</span></span> <span data-ttu-id="070e1-160">Kód, který generuje sekvenci, teď může `yield return` použít k vrácení prvků v metodě, která byla deklarována `async` s modifikátorem.</span><span class="sxs-lookup"><span data-stu-id="070e1-160">The code that generates the sequence can now use `yield return` to return elements in a method that was declared with the `async` modifier.</span></span> <span data-ttu-id="070e1-161">Asynchronní datový proud můžete využívat pomocí `await foreach` smyčky stejně, jako byste využívali jakoukoli sekvenci `foreach` pomocí smyčky.</span><span class="sxs-lookup"><span data-stu-id="070e1-161">You can consume an async stream using an `await foreach` loop just as you consume any sequence using a `foreach` loop.</span></span>

<span data-ttu-id="070e1-162">Tyto nové funkce jazyka závisí na třech nových rozhraních přidaných do .NET Standard 2,1 a implementovaná v rozhraní .NET Core 3,0:</span><span class="sxs-lookup"><span data-stu-id="070e1-162">These new language features depend on three new interfaces added to .NET Standard 2.1 and implemented in .NET Core 3.0:</span></span>

- <xref:System.Collections.Generic.IAsyncEnumerable%601?displayProperty=nameWithType>
- <xref:System.Collections.Generic.IAsyncEnumerator%601?displayProperty=nameWithType>
- <xref:System.IAsyncDisposable?displayProperty=nameWithType>

<span data-ttu-id="070e1-163">Tato tři rozhraní by měla být obeznámena s většinou vývojářů v jazyce C#.</span><span class="sxs-lookup"><span data-stu-id="070e1-163">These three interfaces should be familiar to most C# developers.</span></span> <span data-ttu-id="070e1-164">Chovají se způsobem podobným jejich synchronním protějškům:</span><span class="sxs-lookup"><span data-stu-id="070e1-164">They behave in a manner similar to their synchronous counterparts:</span></span>

- <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType>
- <xref:System.Collections.Generic.IEnumerator%601?displayProperty=nameWithType>
- <xref:System.IDisposable?displayProperty=nameWithType>

<span data-ttu-id="070e1-165">Jeden typ, který může být neznámý <xref:System.Threading.Tasks.ValueTask?displayProperty=nameWithType>, je.</span><span class="sxs-lookup"><span data-stu-id="070e1-165">One type that may be unfamiliar is <xref:System.Threading.Tasks.ValueTask?displayProperty=nameWithType>.</span></span> <span data-ttu-id="070e1-166">`ValueTask` Struktura poskytuje podobné rozhraní API pro <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> třídu.</span><span class="sxs-lookup"><span data-stu-id="070e1-166">The `ValueTask` struct provides a similar API to the <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> class.</span></span> <span data-ttu-id="070e1-167">`ValueTask`se používá v těchto rozhraních z důvodů výkonu.</span><span class="sxs-lookup"><span data-stu-id="070e1-167">`ValueTask` is used in these interfaces for performance reasons.</span></span>

## <a name="convert-to-async-streams"></a><span data-ttu-id="070e1-168">Převést na asynchronní proudy</span><span class="sxs-lookup"><span data-stu-id="070e1-168">Convert to async streams</span></span>

<span data-ttu-id="070e1-169">Dále převeďte `runPagedQueryAsync` metodu pro generování asynchronního datového proudu.</span><span class="sxs-lookup"><span data-stu-id="070e1-169">Next, convert the `runPagedQueryAsync` method to generate an async stream.</span></span> <span data-ttu-id="070e1-170">Nejprve změňte signaturu `runPagedQueryAsync` na `IAsyncEnumerable<JToken>`, pokud chcete vrátit, a odeberte token zrušení a objekty průběhu ze seznamu parametrů, jak je znázorněno v následujícím kódu:</span><span class="sxs-lookup"><span data-stu-id="070e1-170">First, change the signature of `runPagedQueryAsync` to return an `IAsyncEnumerable<JToken>`, and remove the cancellation token and progress objects from the parameter list as shown in the following code:</span></span>

:::code language="csharp" source="snippets/generate-consume-asynchronous-streams/finished/Program.cs" id="SnippetUpdateSignature" :::

<span data-ttu-id="070e1-171">Počáteční kód zpracuje každou stránku při načtení stránky, jak je znázorněno v následujícím kódu:</span><span class="sxs-lookup"><span data-stu-id="070e1-171">The starter code processes each page as the page is retrieved, as shown in the following code:</span></span>

:::code language="csharp" source="snippets/generate-consume-asynchronous-streams/start/Program.cs" id="SnippetProcessPage" :::

<span data-ttu-id="070e1-172">Nahraďte tyto tři řádky následujícím kódem:</span><span class="sxs-lookup"><span data-stu-id="070e1-172">Replace those three lines with the following code:</span></span>

:::code language="csharp" source="snippets/generate-consume-asynchronous-streams/finished/Program.cs" id="SnippetYieldReturnPage" :::

<span data-ttu-id="070e1-173">Můžete také odebrat deklaraci `finalResults` výše v této metodě a `return` příkaz, který následuje za smyčkou, kterou jste změnili.</span><span class="sxs-lookup"><span data-stu-id="070e1-173">You can also remove the declaration of `finalResults` earlier in this method and the `return` statement that follows the loop you modified.</span></span>

<span data-ttu-id="070e1-174">Dokončili jste změny pro vygenerování asynchronního datového proudu.</span><span class="sxs-lookup"><span data-stu-id="070e1-174">You've finished the changes to generate an async stream.</span></span> <span data-ttu-id="070e1-175">Metoda dokončená by měla vypadat podobně jako následující kód:</span><span class="sxs-lookup"><span data-stu-id="070e1-175">The finished method should resemble the following code:</span></span>

:::code language="csharp" source="snippets/generate-consume-asynchronous-streams/finished/Program.cs" id="SnippetGenerateAsyncStream" :::

<span data-ttu-id="070e1-176">Dále změníte kód, který používá kolekci ke využívání asynchronního datového proudu.</span><span class="sxs-lookup"><span data-stu-id="070e1-176">Next, you change the code that consumes the collection to consume the async stream.</span></span> <span data-ttu-id="070e1-177">Vyhledejte následující kód v `Main` , který zpracovává kolekci problémů:</span><span class="sxs-lookup"><span data-stu-id="070e1-177">Find the following code in `Main` that processes the collection of issues:</span></span>

:::code language="csharp" source="snippets/generate-consume-asynchronous-streams/start/Program.cs" id="SnippetEnumerateOldStyle" :::

<span data-ttu-id="070e1-178">Nahraďte tento kód následujícím `await foreach` smyčkou:</span><span class="sxs-lookup"><span data-stu-id="070e1-178">Replace that code with the following `await foreach` loop:</span></span>

:::code language="csharp" source="snippets/generate-consume-asynchronous-streams/finished/Program.cs" id="SnippetEnumerateAsyncStream" :::

<span data-ttu-id="070e1-179">Nové rozhraní <xref:System.Collections.Generic.IAsyncEnumerator%601> je odvozeno z <xref:System.IAsyncDisposable>.</span><span class="sxs-lookup"><span data-stu-id="070e1-179">The new interface <xref:System.Collections.Generic.IAsyncEnumerator%601> derives from <xref:System.IAsyncDisposable>.</span></span> <span data-ttu-id="070e1-180">To znamená, že předchozí smyčka asynchronně odstraní Stream po dokončení smyčky.</span><span class="sxs-lookup"><span data-stu-id="070e1-180">That means the preceding loop will asynchronously dispose the stream when the loop finishes.</span></span> <span data-ttu-id="070e1-181">Můžete si představit, že smyčka vypadá jako následující kód:</span><span class="sxs-lookup"><span data-stu-id="070e1-181">You can imagine the loop looks like the following code:</span></span>

```csharp
int num = 0;
var enumerator = runPagedQueryAsync(client, PagedIssueQuery, "docs").GetEnumeratorAsync();
try
{
    while (await enumerator.MoveNextAsync())
    {
        var issue = enumerator.Current;
        Console.WriteLine(issue);
        Console.WriteLine($"Received {++num} issues in total");
    }
} finally
{
    if (enumerator != null)
        await enumerator.DisposeAsync();
}
```

<span data-ttu-id="070e1-182">Ve výchozím nastavení jsou prvky Stream zpracovávány v zachyceném kontextu.</span><span class="sxs-lookup"><span data-stu-id="070e1-182">By default, stream elements are processed in the captured context.</span></span> <span data-ttu-id="070e1-183">Pokud chcete zakázat zachycování kontextu, použijte metodu <xref:System.Threading.Tasks.TaskAsyncEnumerableExtensions.ConfigureAwait%2A?displayProperty=nameWithType> rozšíření.</span><span class="sxs-lookup"><span data-stu-id="070e1-183">If you want to disable capturing of the context, use the <xref:System.Threading.Tasks.TaskAsyncEnumerableExtensions.ConfigureAwait%2A?displayProperty=nameWithType> extension method.</span></span> <span data-ttu-id="070e1-184">Další informace o kontextech synchronizace a zaznamenávání aktuálního kontextu naleznete v článku o [využívání asynchronního vzoru založeného na úlohách](../../standard/asynchronous-programming-patterns/consuming-the-task-based-asynchronous-pattern.md).</span><span class="sxs-lookup"><span data-stu-id="070e1-184">For more information about synchronization contexts and capturing the current context, see the article on [consuming the Task-based asynchronous pattern](../../standard/asynchronous-programming-patterns/consuming-the-task-based-asynchronous-pattern.md).</span></span>

<span data-ttu-id="070e1-185">Asynchronní streamy podporují zrušení pomocí stejného protokolu jako jiné `async` metody.</span><span class="sxs-lookup"><span data-stu-id="070e1-185">Async streams support cancellation using the same protocol as other `async` methods.</span></span> <span data-ttu-id="070e1-186">Signaturu metody asynchronního iterátoru byste upravili následujícím způsobem, aby se mohla podporovat zrušení:</span><span class="sxs-lookup"><span data-stu-id="070e1-186">You would modify the signature for the async iterator method as follows to support cancellation:</span></span>

:::code language="csharp" source="snippets/generate-consume-asynchronous-streams/finished/Program.cs" id="SnippetGenerateWithCancellation" :::

<span data-ttu-id="070e1-187"><xref:System.Runtime.CompilerServices.EnumeratorCancellationAttribute?dipslayProperty=nameWithType> Atribut způsobí, že kompilátor vygeneruje kód pro <xref:System.Collections.Generic.IAsyncEnumerator%601> , který předává token k `GetAsyncEnumerator` viditelnosti textu asynchronního iterátoru jako tento argument.</span><span class="sxs-lookup"><span data-stu-id="070e1-187">The <xref:System.Runtime.CompilerServices.EnumeratorCancellationAttribute?dipslayProperty=nameWithType> attribute causes the compiler to generate code for the <xref:System.Collections.Generic.IAsyncEnumerator%601> that makes the token passed to `GetAsyncEnumerator` visible to the body of the async iterator as that argument.</span></span> <span data-ttu-id="070e1-188">Uvnitř `runQueryAsync`byste mohli prověřit stav tokenu a v případě potřeby zrušit další práci.</span><span class="sxs-lookup"><span data-stu-id="070e1-188">Inside `runQueryAsync`, you could examine the state of the token and cancel further work if requested.</span></span>

<span data-ttu-id="070e1-189">K předání tokenu zrušení do <xref:System.Threading.Tasks.TaskAsyncEnumerableExtensions.WithCancellation%2A>asynchronního datového proudu použijete jinou metodu rozšíření.</span><span class="sxs-lookup"><span data-stu-id="070e1-189">You use another extension method, <xref:System.Threading.Tasks.TaskAsyncEnumerableExtensions.WithCancellation%2A>, to pass the cancellation token to the async stream.</span></span> <span data-ttu-id="070e1-190">Provedete to tak, že se tyto problémy vyčíslují následujícím způsobem:</span><span class="sxs-lookup"><span data-stu-id="070e1-190">You would modify the loop enumerating the issues as follows:</span></span>

:::code language="csharp" source="snippets/generate-consume-asynchronous-streams/finished/Program.cs" id="SnippetEnumerateWithCancellation" :::

<span data-ttu-id="070e1-191">Kód pro dokončený kurz můžete získat z úložiště [dotnet/docs](https://github.com/dotnet/docs) ve složce [CSharp/tutorials/AsyncStreams](https://github.com/dotnet/docs/tree/master/csharp/tutorials/snippets/generate-consume-asynchronous-streams/finished) .</span><span class="sxs-lookup"><span data-stu-id="070e1-191">You can get the code for the finished tutorial from the [dotnet/docs](https://github.com/dotnet/docs) repository in the [csharp/tutorials/AsyncStreams](https://github.com/dotnet/docs/tree/master/csharp/tutorials/snippets/generate-consume-asynchronous-streams/finished) folder.</span></span>

## <a name="run-the-finished-application"></a><span data-ttu-id="070e1-192">Spuštění dokončené aplikace</span><span class="sxs-lookup"><span data-stu-id="070e1-192">Run the finished application</span></span>

<span data-ttu-id="070e1-193">Spusťte aplikaci znovu.</span><span class="sxs-lookup"><span data-stu-id="070e1-193">Run the application again.</span></span> <span data-ttu-id="070e1-194">Kontrastujte své chování s chováním úvodní aplikace.</span><span class="sxs-lookup"><span data-stu-id="070e1-194">Contrast its behavior with the behavior of the starter application.</span></span> <span data-ttu-id="070e1-195">První stránka výsledků je vyhodnocena, jakmile bude k dispozici.</span><span class="sxs-lookup"><span data-stu-id="070e1-195">The first page of results is enumerated as soon as it's available.</span></span> <span data-ttu-id="070e1-196">Je možné, že při každém vyžádání a načtení každé nové stránky dojde k pozastavení, takže se výsledky další stránky rychle vytvoří.</span><span class="sxs-lookup"><span data-stu-id="070e1-196">There's an observable pause as each new page is requested and retrieved, then the next page's results are quickly enumerated.</span></span> <span data-ttu-id="070e1-197">`try` potřebný ke zpracování zrušení: volající může zastavit výčet  /  `catch` kolekce.</span><span class="sxs-lookup"><span data-stu-id="070e1-197">The `try` / `catch` block isn't needed to handle cancellation: the caller can stop enumerating the collection.</span></span> <span data-ttu-id="070e1-198">Průběh je jasně nahlášený, protože asynchronní datový proud generuje výsledky při stažení každé stránky.</span><span class="sxs-lookup"><span data-stu-id="070e1-198">Progress is clearly reported because the async stream generates results as each page is downloaded.</span></span> <span data-ttu-id="070e1-199">Stav každého vráceného problému je hladce zahrnutý ve `await foreach` smyčce.</span><span class="sxs-lookup"><span data-stu-id="070e1-199">The status for each issue returned is seamlessly included in the `await foreach` loop.</span></span> <span data-ttu-id="070e1-200">K sledování průběhu nepotřebujete objekt zpětného volání.</span><span class="sxs-lookup"><span data-stu-id="070e1-200">You don't need a callback object to track progress.</span></span>

<span data-ttu-id="070e1-201">Vylepšení využití paměti můžete zobrazit zkoumáním kódu.</span><span class="sxs-lookup"><span data-stu-id="070e1-201">You can see improvements in memory use by examining the code.</span></span> <span data-ttu-id="070e1-202">Již nemusíte přidělovat kolekci pro uložení všech výsledků před jejich výčtem.</span><span class="sxs-lookup"><span data-stu-id="070e1-202">You no longer need to allocate a collection to store all the results before they're enumerated.</span></span> <span data-ttu-id="070e1-203">Volající může určit, jak se mají výsledky využívat, a pokud je potřeba kolekce úložiště.</span><span class="sxs-lookup"><span data-stu-id="070e1-203">The caller can determine how to consume the results and if a storage collection is needed.</span></span>

<span data-ttu-id="070e1-204">Spouštějte počáteční i hotové aplikace a můžete sledovat rozdíly mezi implementacemi pro sebe.</span><span class="sxs-lookup"><span data-stu-id="070e1-204">Run both the starter and finished applications and you can observe the differences between the implementations for yourself.</span></span> <span data-ttu-id="070e1-205">Přístupový token GitHubu, který jste vytvořili po spuštění tohoto kurzu, můžete odstranit po dokončení tohoto kurzu.</span><span class="sxs-lookup"><span data-stu-id="070e1-205">You can delete the GitHub access token you created when you started this tutorial after you've finished.</span></span> <span data-ttu-id="070e1-206">Pokud útočník získal přístup k tomuto tokenu, měl by získat přístup k rozhraním API GitHubu pomocí vašich přihlašovacích údajů.</span><span class="sxs-lookup"><span data-stu-id="070e1-206">If an attacker gained access to that token, they could access GitHub APIs using your credentials.</span></span>
