---
title: Generování a využívání asynchronních datových proudů
description: Tento pokročilý kurz ilustruje scénáře, kde generování a využívání asynchronních datových proudů poskytuje přirozenější způsob práce s sekvencemi dat, které mohou být generovány asynchronně.
ms.date: 02/10/2019
ms.technology: csharp-async
ms.custom: mvc
ms.openlocfilehash: de090eb9cc1e8b511956313ab5169ee4d07a492f
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 03/14/2020
ms.locfileid: "79156737"
---
# <a name="tutorial-generate-and-consume-async-streams-using-c-80-and-net-core-30"></a><span data-ttu-id="f1c20-103">Kurz: Generování a využívání asynchronních datových proudů pomocí c# 8.0 a .NET Core 3.0</span><span class="sxs-lookup"><span data-stu-id="f1c20-103">Tutorial: Generate and consume async streams using C# 8.0 and .NET Core 3.0</span></span>

<span data-ttu-id="f1c20-104">C# 8.0 zavádí **asynchronní proudy**, které modelují zdroj datových proudů, když mohou být prvky v datovém proudu načteny nebo generovány asynchronně.</span><span class="sxs-lookup"><span data-stu-id="f1c20-104">C# 8.0 introduces **async streams**, which model a streaming source of data when the elements in the data stream may be retrieved or generated asynchronously.</span></span> <span data-ttu-id="f1c20-105">Asynchronní proudy spoléhají na nová rozhraní zavedená v rozhraní .NET Standard 2.1 a implementovaná v rozhraní .NET Core 3.0, aby poskytla přirozený programovací model pro asynchronní zdroje dat streamování.</span><span class="sxs-lookup"><span data-stu-id="f1c20-105">Async streams rely on new interfaces introduced in .NET Standard 2.1 and implemented in .NET Core 3.0 to provide a natural programming model for asynchronous streaming data sources.</span></span>

<span data-ttu-id="f1c20-106">V tomto kurzu se naučíte:</span><span class="sxs-lookup"><span data-stu-id="f1c20-106">In this tutorial, you'll learn how to:</span></span>

> [!div class="checklist"]
>
> - <span data-ttu-id="f1c20-107">Vytvořte zdroj dat, který generuje posloupnost datových prvků asynchronně.</span><span class="sxs-lookup"><span data-stu-id="f1c20-107">Create a data source that generates a sequence of data elements asynchronously.</span></span>
> - <span data-ttu-id="f1c20-108">Spotřebovávat tento zdroj dat asynchronně.</span><span class="sxs-lookup"><span data-stu-id="f1c20-108">Consume that data source asynchronously.</span></span>
> - <span data-ttu-id="f1c20-109">Rozpoznat, kdy nové rozhraní a zdroj dat jsou upřednostňovány před starší synchronní datové sekvence.</span><span class="sxs-lookup"><span data-stu-id="f1c20-109">Recognize when the new interface and data source are preferred to earlier synchronous data sequences.</span></span>

## <a name="prerequisites"></a><span data-ttu-id="f1c20-110">Požadavky</span><span class="sxs-lookup"><span data-stu-id="f1c20-110">Prerequisites</span></span>

<span data-ttu-id="f1c20-111">Budete muset nastavit počítač pro spuštění .NET Core, včetně kompilátoru C# 8.0.</span><span class="sxs-lookup"><span data-stu-id="f1c20-111">You'll need to set up your machine to run .NET Core, including the C# 8.0 compiler.</span></span> <span data-ttu-id="f1c20-112">Kompilátor Jazyka C# 8 je k dispozici počínaje [sadou Visual Studio 2019 verze 16.3](https://visualstudio.microsoft.com/downloads/?utm_medium=microsoft&utm_source=docs.microsoft.com&utm_campaign=inline+link&utm_content=download+vs2019) nebo [.NET Core 3.0 SDK](https://dotnet.microsoft.com/download).</span><span class="sxs-lookup"><span data-stu-id="f1c20-112">The C# 8 compiler is available starting with [Visual Studio 2019 version 16.3](https://visualstudio.microsoft.com/downloads/?utm_medium=microsoft&utm_source=docs.microsoft.com&utm_campaign=inline+link&utm_content=download+vs2019) or [.NET Core 3.0 SDK](https://dotnet.microsoft.com/download).</span></span>

<span data-ttu-id="f1c20-113">Budete muset vytvořit [přístupový token GitHubu,](https://help.github.com/articles/creating-a-personal-access-token-for-the-command-line/#creating-a-token) abyste měli přístup ke koncovému bodu GitHub GraphQL.</span><span class="sxs-lookup"><span data-stu-id="f1c20-113">You'll need to create a [GitHub access token](https://help.github.com/articles/creating-a-personal-access-token-for-the-command-line/#creating-a-token) so that you can access the GitHub GraphQL endpoint.</span></span> <span data-ttu-id="f1c20-114">Vyberte následující oprávnění pro přístupový token GitHubu:</span><span class="sxs-lookup"><span data-stu-id="f1c20-114">Select the following permissions for your GitHub Access Token:</span></span>

- <span data-ttu-id="f1c20-115">repo:stav</span><span class="sxs-lookup"><span data-stu-id="f1c20-115">repo:status</span></span>
- <span data-ttu-id="f1c20-116">public_repo</span><span class="sxs-lookup"><span data-stu-id="f1c20-116">public_repo</span></span>

<span data-ttu-id="f1c20-117">Uložte přístupový token na bezpečném místě, abyste ho mohli použít k získání přístupu ke koncovému bodu rozhraní API GitHub.</span><span class="sxs-lookup"><span data-stu-id="f1c20-117">Save the access token in a safe place so you can use it to gain access to the GitHub API endpoint.</span></span>

> [!WARNING]
> <span data-ttu-id="f1c20-118">Udržujte svůj osobní přístupový token v bezpečí.</span><span class="sxs-lookup"><span data-stu-id="f1c20-118">Keep your personal access token secure.</span></span> <span data-ttu-id="f1c20-119">Jakýkoli software s vaším osobním přístupovým tokenem může volat rozhraní GitHub API pomocí vašich přístupových práv.</span><span class="sxs-lookup"><span data-stu-id="f1c20-119">Any software with your personal access token could make GitHub API calls using your access rights.</span></span>

<span data-ttu-id="f1c20-120">Tento kurz předpokládá, že jste obeznámeni s C# a .NET, včetně Visual Studio nebo .NET Core CLI.</span><span class="sxs-lookup"><span data-stu-id="f1c20-120">This tutorial assumes you're familiar with C# and .NET, including either Visual Studio or the .NET Core CLI.</span></span>

## <a name="run-the-starter-application"></a><span data-ttu-id="f1c20-121">Spuštění startovací aplikace</span><span class="sxs-lookup"><span data-stu-id="f1c20-121">Run the starter application</span></span>

<span data-ttu-id="f1c20-122">Můžete získat kód pro počáteční aplikace použité v tomto kurzu z [našeho úložiště dotnet/samples](https://github.com/dotnet/samples) ve složce [csharp/tutorials/AsyncStreams.](https://github.com/dotnet/samples/tree/master/csharp/tutorials/AsyncStreams/start)</span><span class="sxs-lookup"><span data-stu-id="f1c20-122">You can get the code for the starter application used in this tutorial from our [dotnet/samples](https://github.com/dotnet/samples) repository in the [csharp/tutorials/AsyncStreams](https://github.com/dotnet/samples/tree/master/csharp/tutorials/AsyncStreams/start) folder.</span></span>

<span data-ttu-id="f1c20-123">Počáteční aplikace je konzolová aplikace, která používá rozhraní [GitHub GraphQL](https://developer.github.com/v4/) k načtení nedávných problémů napsaných v úložišti [dotnet/docs.](https://github.com/dotnet/docs)</span><span class="sxs-lookup"><span data-stu-id="f1c20-123">The starter application is a console application that uses the [GitHub GraphQL](https://developer.github.com/v4/) interface to retrieve recent issues written in the [dotnet/docs](https://github.com/dotnet/docs) repository.</span></span> <span data-ttu-id="f1c20-124">Začněte tím, že se podíváte na následující kód pro metodu počáteční aplikace: `Main`</span><span class="sxs-lookup"><span data-stu-id="f1c20-124">Start by looking at the following code for the starter app `Main` method:</span></span>

[!code-csharp[StarterAppMain](~/samples/snippets/csharp/tutorials/AsyncStreams/start/IssuePRreport/IssuePRreport/Program.cs#StarterAppMain)]

<span data-ttu-id="f1c20-125">Můžete buď nastavit `GitHubKey` proměnnou prostředí na váš osobní přístupový token, nebo `GenEnvVariable` můžete nahradit poslední argument ve volání s vaším osobním přístupovým tokenem.</span><span class="sxs-lookup"><span data-stu-id="f1c20-125">You can either set a `GitHubKey` environment variable to your personal access token, or you can replace the last argument in the call to `GenEnvVariable` with your personal access token.</span></span> <span data-ttu-id="f1c20-126">Nevkládejte přístupový kód do zdrojového kódu, pokud budete zdroj ukládat s ostatními nebo jej ukládat do sdíleného zdrojového úložiště.</span><span class="sxs-lookup"><span data-stu-id="f1c20-126">Don't put your access code in source code if you'll be saving the source with others, or putting it in a shared source repository.</span></span>

<span data-ttu-id="f1c20-127">Po vytvoření klienta GitHub `Main` kód v vytvoří objekt hlášení průběhu a token zrušení.</span><span class="sxs-lookup"><span data-stu-id="f1c20-127">After creating the GitHub client, the code in `Main` creates a progress reporting object and a cancellation token.</span></span> <span data-ttu-id="f1c20-128">Po vytvoření těchto `Main` objektů `runPagedQueryAsync` volání načíst posledních 250 vytvořených problémů.</span><span class="sxs-lookup"><span data-stu-id="f1c20-128">Once those objects are created, `Main` calls `runPagedQueryAsync` to retrieve the most recent 250 created issues.</span></span> <span data-ttu-id="f1c20-129">Po dokončení tohoto úkolu se zobrazí výsledky.</span><span class="sxs-lookup"><span data-stu-id="f1c20-129">After that task has finished, the results are displayed.</span></span>

<span data-ttu-id="f1c20-130">Při spuštění počáteční aplikace, můžete provést některé důležité poznámky o tom, jak tato aplikace běží.</span><span class="sxs-lookup"><span data-stu-id="f1c20-130">When you run the starter application, you can make some important observations about how this application runs.</span></span>  <span data-ttu-id="f1c20-131">Uvidíte průběh hlášené pro každou stránku vrácenou z GitHubu.</span><span class="sxs-lookup"><span data-stu-id="f1c20-131">You'll see progress reported for each page returned from GitHub.</span></span> <span data-ttu-id="f1c20-132">Můžete sledovat znatelnou pauzu, než GitHub vrátí každou novou stránku problémů.</span><span class="sxs-lookup"><span data-stu-id="f1c20-132">You can observe a noticeable pause before GitHub returns each new page of issues.</span></span> <span data-ttu-id="f1c20-133">Nakonec se problémy zobrazí až po načtení všech 10 stránek z GitHubu.</span><span class="sxs-lookup"><span data-stu-id="f1c20-133">Finally, the issues are displayed only after all 10 pages have been retrieved from GitHub.</span></span>

## <a name="examine-the-implementation"></a><span data-ttu-id="f1c20-134">Prozkoumat provádění</span><span class="sxs-lookup"><span data-stu-id="f1c20-134">Examine the implementation</span></span>

<span data-ttu-id="f1c20-135">Implementace odhaluje, proč jste pozorovali chování popsané v předchozí části.</span><span class="sxs-lookup"><span data-stu-id="f1c20-135">The implementation reveals why you observed the behavior discussed in the previous section.</span></span> <span data-ttu-id="f1c20-136">Zkontrolujte kód `runPagedQueryAsync`pro :</span><span class="sxs-lookup"><span data-stu-id="f1c20-136">Examine the code for `runPagedQueryAsync`:</span></span>

[!code-csharp[RunPagedQueryStarter](~/samples/snippets/csharp/tutorials/AsyncStreams/start/IssuePRreport/IssuePRreport/Program.cs#RunPagedQuery)]

<span data-ttu-id="f1c20-137">Soustřeďme se na stránkovací algoritmus a asynchronní strukturu předchozího kódu.</span><span class="sxs-lookup"><span data-stu-id="f1c20-137">Let's concentrate on the paging algorithm and async structure of the preceding code.</span></span> <span data-ttu-id="f1c20-138">(Podrobnosti o rozhraní API GitHub GraphQL najdete v dokumentaci k [rozhraní GitHub](https://developer.github.com/v4/guides/) GraphQL.) Metoda `runPagedQueryAsync` vyjmenovává problémy od nejnovějších po nejstarší.</span><span class="sxs-lookup"><span data-stu-id="f1c20-138">(You can consult the [GitHub GraphQL documentation](https://developer.github.com/v4/guides/) for details on the GitHub GraphQL API.) The `runPagedQueryAsync` method enumerates the issues from most recent to oldest.</span></span> <span data-ttu-id="f1c20-139">Požaduje 25 otázek na stránku `pageInfo` a zkoumá strukturu odpovědi pokračovat s předchozí stránku.</span><span class="sxs-lookup"><span data-stu-id="f1c20-139">It requests 25 issues per page and examines the `pageInfo` structure of the response to continue with the previous page.</span></span> <span data-ttu-id="f1c20-140">To vyplývá graphql standardní stránkování podporu pro vícestránkové odpovědi.</span><span class="sxs-lookup"><span data-stu-id="f1c20-140">That follows GraphQL's standard paging support for multi-page responses.</span></span> <span data-ttu-id="f1c20-141">Odpověď obsahuje `pageInfo` objekt, který `hasPreviousPages` obsahuje `startCursor` hodnotu a hodnotu použitou k vyžádání předchozí stránky.</span><span class="sxs-lookup"><span data-stu-id="f1c20-141">The response includes a `pageInfo` object that includes a `hasPreviousPages` value and a `startCursor` value used to request the previous page.</span></span> <span data-ttu-id="f1c20-142">Problémy jsou `nodes` v poli.</span><span class="sxs-lookup"><span data-stu-id="f1c20-142">The issues are in the `nodes` array.</span></span> <span data-ttu-id="f1c20-143">Metoda `runPagedQueryAsync` připojí tyto uzly k poli, které obsahuje všechny výsledky ze všech stránek.</span><span class="sxs-lookup"><span data-stu-id="f1c20-143">The `runPagedQueryAsync` method appends these nodes to an array that contains all the results from all pages.</span></span>

<span data-ttu-id="f1c20-144">Po načtení a obnovení stránky `runPagedQueryAsync` výsledků, hlásí průběh a kontroly zrušení.</span><span class="sxs-lookup"><span data-stu-id="f1c20-144">After retrieving and restoring a page of results, `runPagedQueryAsync` reports progress and checks for cancellation.</span></span> <span data-ttu-id="f1c20-145">Pokud bylo požadováno `runPagedQueryAsync` zrušení, <xref:System.OperationCanceledException>vyvolá .</span><span class="sxs-lookup"><span data-stu-id="f1c20-145">If cancellation has been requested, `runPagedQueryAsync` throws an <xref:System.OperationCanceledException>.</span></span>

<span data-ttu-id="f1c20-146">Existuje několik prvků v tomto kódu, které lze zlepšit.</span><span class="sxs-lookup"><span data-stu-id="f1c20-146">There are several elements in this code that can be improved.</span></span> <span data-ttu-id="f1c20-147">A co `runPagedQueryAsync` je nejdůležitější, musí přidělit úložiště pro všechny vrácené problémy.</span><span class="sxs-lookup"><span data-stu-id="f1c20-147">Most importantly, `runPagedQueryAsync` must allocate storage for all the issues returned.</span></span> <span data-ttu-id="f1c20-148">Tato ukázka se zastaví na 250 problémy, protože načítání všech otevřených problémů by vyžadovalo mnohem více paměti pro uložení všech načtených problémů.</span><span class="sxs-lookup"><span data-stu-id="f1c20-148">This sample stops at 250 issues because retrieving all open issues would require much more memory to store all the retrieved issues.</span></span> <span data-ttu-id="f1c20-149">Kromě toho protokoly pro podporu pokroku a podporu zrušení algoritmus těžší pochopit na jeho první čtení.</span><span class="sxs-lookup"><span data-stu-id="f1c20-149">In addition, the protocols for supporting progress and supporting cancellation make the algorithm harder to understand on its first reading.</span></span> <span data-ttu-id="f1c20-150">Musíte vyhledat třídu průběhu a zjistit, kde je hlášen průběh.</span><span class="sxs-lookup"><span data-stu-id="f1c20-150">You must look for the progress class to find where progress is reported.</span></span> <span data-ttu-id="f1c20-151">Musíte také sledovat komunikaci prostřednictvím <xref:System.Threading.CancellationTokenSource> a <xref:System.Threading.CancellationToken> jeho přidružené pochopit, kde je požadováno zrušení a kde je uděleno.</span><span class="sxs-lookup"><span data-stu-id="f1c20-151">You also have to trace the communications through the <xref:System.Threading.CancellationTokenSource> and its associated <xref:System.Threading.CancellationToken> to understand where cancellation is requested and where it's granted.</span></span>

## <a name="async-streams-provide-a-better-way"></a><span data-ttu-id="f1c20-152">Asynchronní proudy poskytují lepší způsob</span><span class="sxs-lookup"><span data-stu-id="f1c20-152">Async streams provide a better way</span></span>

<span data-ttu-id="f1c20-153">Asynchronní proudy a související jazyková podpora řeší všechny tyto obavy.</span><span class="sxs-lookup"><span data-stu-id="f1c20-153">Async streams and the associated language support address all those concerns.</span></span> <span data-ttu-id="f1c20-154">Kód, který generuje sekvence nyní `yield return` můžete použít k vrácení prvků `async` v metodě, která byla deklarována s modifikátorem.</span><span class="sxs-lookup"><span data-stu-id="f1c20-154">The code that generates the sequence can now use `yield return` to return elements in a method that was declared with the `async` modifier.</span></span> <span data-ttu-id="f1c20-155">Můžete konzumovat asynchronní `await foreach` datový proud pomocí smyčky stejně jako spotřebovávají libovolné sekvence pomocí `foreach` smyčky.</span><span class="sxs-lookup"><span data-stu-id="f1c20-155">You can consume an async stream using an `await foreach` loop just as you consume any sequence using a `foreach` loop.</span></span>

<span data-ttu-id="f1c20-156">Tyto nové jazykové funkce závisí na třech nových rozhraních, která jsou přidána do standardu .NET Standard 2.1 a implementována v rozhraní .NET Core 3.0:</span><span class="sxs-lookup"><span data-stu-id="f1c20-156">These new language features depend on three new interfaces added to .NET Standard 2.1 and implemented in .NET Core 3.0:</span></span>

```csharp
namespace System.Collections.Generic
{
    public interface IAsyncEnumerable<out T>
    {
        IAsyncEnumerator<T> GetAsyncEnumerator(CancellationToken cancellationToken = default);
    }

    public interface IAsyncEnumerator<out T> : IAsyncDisposable
    {
        T Current { get; }

        ValueTask<bool> MoveNextAsync();
    }
}

namespace System
{
    public interface IAsyncDisposable
    {
        ValueTask DisposeAsync();
    }
}
```

<span data-ttu-id="f1c20-157">Tato tři rozhraní by měla být známá většině vývojářů jazyka C#.</span><span class="sxs-lookup"><span data-stu-id="f1c20-157">These three interfaces should be familiar to most C# developers.</span></span> <span data-ttu-id="f1c20-158">Chovají se podobně jako jejich synchronní protějšky:</span><span class="sxs-lookup"><span data-stu-id="f1c20-158">They behave in a manner similar to their synchronous counterparts:</span></span>

- <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType>
- <xref:System.Collections.Generic.IEnumerator%601?displayProperty=nameWithType>
- <xref:System.IDisposable?displayProperty=nameWithType>

<span data-ttu-id="f1c20-159">Jeden typ, který může <xref:System.Threading.Tasks.ValueTask?displayProperty=nameWithType>být neznámý, je .</span><span class="sxs-lookup"><span data-stu-id="f1c20-159">One type that may be unfamiliar is <xref:System.Threading.Tasks.ValueTask?displayProperty=nameWithType>.</span></span> <span data-ttu-id="f1c20-160">`ValueTask` Struktura poskytuje podobné rozhraní API <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> třídy.</span><span class="sxs-lookup"><span data-stu-id="f1c20-160">The `ValueTask` struct provides a similar API to the <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> class.</span></span> <span data-ttu-id="f1c20-161">`ValueTask`se používá v těchto rozhraních z důvodů výkonu.</span><span class="sxs-lookup"><span data-stu-id="f1c20-161">`ValueTask` is used in these interfaces for performance reasons.</span></span>

## <a name="convert-to-async-streams"></a><span data-ttu-id="f1c20-162">Převod na asynchronní datové proudy</span><span class="sxs-lookup"><span data-stu-id="f1c20-162">Convert to async streams</span></span>

<span data-ttu-id="f1c20-163">Dále převeďte metodu `runPagedQueryAsync` a vygenerujte asynchronní datový proud.</span><span class="sxs-lookup"><span data-stu-id="f1c20-163">Next, convert the `runPagedQueryAsync` method to generate an async stream.</span></span> <span data-ttu-id="f1c20-164">Nejprve změňte `runPagedQueryAsync` podpis pro `IAsyncEnumerable<JToken>`vrácení a odeberte objekty tokenu zrušení a průběhu ze seznamu parametrů, jak je znázorněno v následujícím kódu:</span><span class="sxs-lookup"><span data-stu-id="f1c20-164">First, change the signature of `runPagedQueryAsync` to return an `IAsyncEnumerable<JToken>`, and remove the cancellation token and progress objects from the parameter list as shown in the following code:</span></span>

[!code-csharp[FinishedSignature](~/samples/snippets/csharp/tutorials/AsyncStreams/finished/IssuePRreport/IssuePRreport/Program.cs#UpdateSignature)]

<span data-ttu-id="f1c20-165">Počáteční kód zpracovává každou stránku při načítání stránky, jak je znázorněno v následujícím kódu:</span><span class="sxs-lookup"><span data-stu-id="f1c20-165">The starter code processes each page as the page is retrieved, as shown in the following code:</span></span>

[!code-csharp[StarterPaging](~/samples/snippets/csharp/tutorials/AsyncStreams/start/IssuePRreport/IssuePRreport/Program.cs#ProcessPage)]

<span data-ttu-id="f1c20-166">Nahraďte tyto tři řádky následujícím kódem:</span><span class="sxs-lookup"><span data-stu-id="f1c20-166">Replace those three lines with the following code:</span></span>

[!code-csharp[FinishedPaging](~/samples/snippets/csharp/tutorials/AsyncStreams/finished/IssuePRreport/IssuePRreport/Program.cs#YieldReturnPage)]

<span data-ttu-id="f1c20-167">Můžete také odebrat `finalResults` prohlášení dříve v `return` této metodě a příkaz, který následuje za smyčky, kterou jste upravili.</span><span class="sxs-lookup"><span data-stu-id="f1c20-167">You can also remove the declaration of `finalResults` earlier in this method and the `return` statement that follows the loop you modified.</span></span>

<span data-ttu-id="f1c20-168">Dokončili jste změny pro generování asynchronního datového proudu.</span><span class="sxs-lookup"><span data-stu-id="f1c20-168">You've finished the changes to generate an async stream.</span></span> <span data-ttu-id="f1c20-169">Hotová metoda by se měla podobat níže uvedenému kódu:</span><span class="sxs-lookup"><span data-stu-id="f1c20-169">The finished method should resemble the code below:</span></span>

[!code-csharp[FinishedGenerate](~/samples/snippets/csharp/tutorials/AsyncStreams/finished/IssuePRreport/IssuePRreport/Program.cs#GenerateAsyncStream)]

<span data-ttu-id="f1c20-170">Dále změníte kód, který spotřebovává kolekce využívat asynchronní datový proud.</span><span class="sxs-lookup"><span data-stu-id="f1c20-170">Next, you change the code that consumes the collection to consume the async stream.</span></span> <span data-ttu-id="f1c20-171">V tomto zpracuje tekutou kolekci problémů následující kód: `Main`</span><span class="sxs-lookup"><span data-stu-id="f1c20-171">Find the following code in `Main` that processes the collection of issues:</span></span>

[!code-csharp[EnumerateOldStyle](~/samples/snippets/csharp/tutorials/AsyncStreams/start/IssuePRreport/IssuePRreport/Program.cs#EnumerateOldStyle)]

<span data-ttu-id="f1c20-172">Nahraďte tento `await foreach` kód následující smyčkou:</span><span class="sxs-lookup"><span data-stu-id="f1c20-172">Replace that code with the following `await foreach` loop:</span></span>

[!code-csharp[FinishedEnumerateAsyncStream](~/samples/snippets/csharp/tutorials/AsyncStreams/finished/IssuePRreport/IssuePRreport/Program.cs#EnumerateAsyncStream)]

<span data-ttu-id="f1c20-173">Ve výchozím nastavení jsou prvky datového proudu zpracovány v zachyceném kontextu.</span><span class="sxs-lookup"><span data-stu-id="f1c20-173">By default, stream elements are processed in the captured context.</span></span> <span data-ttu-id="f1c20-174">Pokud chcete zakázat zachycení kontextu, použijte <xref:System.Threading.Tasks.TaskAsyncEnumerableExtensions.ConfigureAwait%2A?displayProperty=nameWithType> metodu rozšíření.</span><span class="sxs-lookup"><span data-stu-id="f1c20-174">If you want to disable capturing of the context, use the <xref:System.Threading.Tasks.TaskAsyncEnumerableExtensions.ConfigureAwait%2A?displayProperty=nameWithType> extension method.</span></span> <span data-ttu-id="f1c20-175">Další informace o kontextech synchronizace a zachycení aktuálního kontextu naleznete v článku o [využití asynchronního vzoru založeného na úlohách](../../standard/asynchronous-programming-patterns/consuming-the-task-based-asynchronous-pattern.md).</span><span class="sxs-lookup"><span data-stu-id="f1c20-175">For more information about synchronization contexts and capturing the current context, see the article on [consuming the Task-based asynchronous pattern](../../standard/asynchronous-programming-patterns/consuming-the-task-based-asynchronous-pattern.md).</span></span>

<span data-ttu-id="f1c20-176">Můžete získat kód pro hotový kurz z [úložiště dotnet/samples](https://github.com/dotnet/samples) ve složce [csharp/tutorials/AsyncStreams.](https://github.com/dotnet/samples/tree/master/csharp/tutorials/AsyncStreams/finished)</span><span class="sxs-lookup"><span data-stu-id="f1c20-176">You can get the code for the finished tutorial from the [dotnet/samples](https://github.com/dotnet/samples) repository in the [csharp/tutorials/AsyncStreams](https://github.com/dotnet/samples/tree/master/csharp/tutorials/AsyncStreams/finished) folder.</span></span>

## <a name="run-the-finished-application"></a><span data-ttu-id="f1c20-177">Spuštění dokončené aplikace</span><span class="sxs-lookup"><span data-stu-id="f1c20-177">Run the finished application</span></span>

<span data-ttu-id="f1c20-178">Spusťte aplikaci znovu.</span><span class="sxs-lookup"><span data-stu-id="f1c20-178">Run the application again.</span></span> <span data-ttu-id="f1c20-179">Porovnejte jeho chování s chováním počáteční aplikace.</span><span class="sxs-lookup"><span data-stu-id="f1c20-179">Contrast its behavior with the behavior of the starter application.</span></span> <span data-ttu-id="f1c20-180">První stránka výsledků je uveden, jakmile je k dispozici.</span><span class="sxs-lookup"><span data-stu-id="f1c20-180">The first page of results is enumerated as soon as it's available.</span></span> <span data-ttu-id="f1c20-181">Je tu pozorovatelné pauza jako každá nová stránka je požadována a načtena, pak další stránka výsledky jsou rychle vyčísleny.</span><span class="sxs-lookup"><span data-stu-id="f1c20-181">There's an observable pause as each new page is requested and retrieved, then the next page's results are quickly enumerated.</span></span> <span data-ttu-id="f1c20-182">`try`  /  Blok `catch` není potřeba ke zpracování zrušení: volající můžete zastavit výčet kolekce.</span><span class="sxs-lookup"><span data-stu-id="f1c20-182">The `try` / `catch` block isn't needed to handle cancellation: the caller can stop enumerating the collection.</span></span> <span data-ttu-id="f1c20-183">Průběh je jasně hlášena, protože asynchronní datový proud generuje výsledky jako každá stránka je stažena.</span><span class="sxs-lookup"><span data-stu-id="f1c20-183">Progress is clearly reported because the async stream generates results as each page is downloaded.</span></span> <span data-ttu-id="f1c20-184">Stav pro každý vrácený problém je `await foreach` hladce součástí smyčky.</span><span class="sxs-lookup"><span data-stu-id="f1c20-184">The status for each issue returned is seamlessly included in the `await foreach` loop.</span></span> <span data-ttu-id="f1c20-185">Ke sledování průběhu nepotřebujete objekt zpětného volání.</span><span class="sxs-lookup"><span data-stu-id="f1c20-185">You don't need a callback object to track progress.</span></span>

<span data-ttu-id="f1c20-186">Můžete zobrazit zlepšení využití paměti kontrolou kódu.</span><span class="sxs-lookup"><span data-stu-id="f1c20-186">You can see improvements in memory use by examining the code.</span></span> <span data-ttu-id="f1c20-187">Již není nutné přidělit kolekci pro uložení všech výsledků před jejich výčtu.</span><span class="sxs-lookup"><span data-stu-id="f1c20-187">You no longer need to allocate a collection to store all the results before they're enumerated.</span></span> <span data-ttu-id="f1c20-188">Volající můžete určit, jak spotřebovat výsledky a pokud je potřeba kolekce úložiště.</span><span class="sxs-lookup"><span data-stu-id="f1c20-188">The caller can determine how to consume the results and if a storage collection is needed.</span></span>

<span data-ttu-id="f1c20-189">Spusťte počáteční i dokončené aplikace a můžete sledovat rozdíly mezi implementacemi pro sebe.</span><span class="sxs-lookup"><span data-stu-id="f1c20-189">Run both the starter and finished applications and you can observe the differences between the implementations for yourself.</span></span> <span data-ttu-id="f1c20-190">Můžete odstranit přístupový token GitHub, který jste vytvořili při spuštění tohoto kurzu po dokončení.</span><span class="sxs-lookup"><span data-stu-id="f1c20-190">You can delete the GitHub access token you created when you started this tutorial after you've finished.</span></span> <span data-ttu-id="f1c20-191">Pokud útočník získal přístup k tomuto tokenu, mohl by přistupovat k rozhraním API GitHub pomocí vašich přihlašovacích údajů.</span><span class="sxs-lookup"><span data-stu-id="f1c20-191">If an attacker gained access to that token, they could access GitHub APIs using your credentials.</span></span>
