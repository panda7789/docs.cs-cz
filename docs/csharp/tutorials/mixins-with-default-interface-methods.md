---
title: Vytváření typů mixinu pomocí výchozích metod rozhraní
description: Pomocí výchozích členů rozhraní můžete rozšířit rozhraní s volitelnými výchozími implementacemi pro implementátory.
ms.technology: csharp-advanced-concepts
ms.date: 10/04/2019
ms.openlocfilehash: ee0536ef51f9bea3e6851be23cc19fa28cc6916b
ms.sourcegitcommit: 07123a475af89b6da5bb6cc51ea40ab1e8a488f0
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 03/24/2020
ms.locfileid: "80134375"
---
# <a name="tutorial-mix-functionality-in-when-creating-classes-using-interfaces-with-default-interface-methods"></a><span data-ttu-id="42c78-103">Kurz: Kombinace funkcí při vytváření tříd pomocí rozhraní s výchozími metodami rozhraní</span><span class="sxs-lookup"><span data-stu-id="42c78-103">Tutorial: Mix functionality in when creating classes using interfaces with default interface methods</span></span>

<span data-ttu-id="42c78-104">Počínaje C# 8.0 na .NET Core 3.0, můžete definovat implementaci při deklarování člena rozhraní.</span><span class="sxs-lookup"><span data-stu-id="42c78-104">Beginning with C# 8.0 on .NET Core 3.0, you can define an implementation when you declare a member of an interface.</span></span> <span data-ttu-id="42c78-105">Tato funkce poskytuje nové funkce, kde můžete definovat výchozí implementace pro funkce deklarované v rozhraních.</span><span class="sxs-lookup"><span data-stu-id="42c78-105">This feature provides new capabilities where you can define default implementations for features declared in interfaces.</span></span> <span data-ttu-id="42c78-106">Třídy můžete vybrat, kdy přepsat funkce, kdy použít výchozí funkce a kdy nedeklarovat podporu pro diskrétní funkce.</span><span class="sxs-lookup"><span data-stu-id="42c78-106">Classes can pick when to override functionality, when to use the default functionality, and when not to declare support for discrete features.</span></span>

<span data-ttu-id="42c78-107">V tomto kurzu se naučíte:</span><span class="sxs-lookup"><span data-stu-id="42c78-107">In this tutorial, you'll learn how to:</span></span>

> [!div class="checklist"]
>
> * <span data-ttu-id="42c78-108">Vytvořte rozhraní s implementacemi, které popisují diskrétní funkce.</span><span class="sxs-lookup"><span data-stu-id="42c78-108">Create interfaces with implementations that describe discrete features.</span></span>
> * <span data-ttu-id="42c78-109">Vytvořte třídy, které používají výchozí implementace.</span><span class="sxs-lookup"><span data-stu-id="42c78-109">Create classes that use the default implementations.</span></span>
> * <span data-ttu-id="42c78-110">Vytvořte třídy, které přepíší některé nebo všechny výchozí implementace.</span><span class="sxs-lookup"><span data-stu-id="42c78-110">Create classes that override some or all of the default implementations.</span></span>

## <a name="prerequisites"></a><span data-ttu-id="42c78-111">Požadavky</span><span class="sxs-lookup"><span data-stu-id="42c78-111">Prerequisites</span></span>

<span data-ttu-id="42c78-112">Budete muset nastavit počítač pro spuštění .NET Core, včetně kompilátoru C# 8.0.</span><span class="sxs-lookup"><span data-stu-id="42c78-112">You’ll need to set up your machine to run .NET Core, including the C# 8.0 compiler.</span></span> <span data-ttu-id="42c78-113">Kompilátor Jazyka C# 8.0 je k dispozici počínaje [visual studio 2019 verze 16.3](https://visualstudio.microsoft.com/downloads/?utm_medium=microsoft&utm_source=docs.microsoft.com&utm_campaign=inline+link&utm_content=download+vs2019)nebo [.NET Core 3.0 SDK](https://dotnet.microsoft.com/download/dotnet-core) nebo novější.</span><span class="sxs-lookup"><span data-stu-id="42c78-113">The C# 8.0 compiler is available starting with [Visual Studio 2019 version 16.3](https://visualstudio.microsoft.com/downloads/?utm_medium=microsoft&utm_source=docs.microsoft.com&utm_campaign=inline+link&utm_content=download+vs2019), or the [.NET Core 3.0 SDK](https://dotnet.microsoft.com/download/dotnet-core) or later.</span></span>

## <a name="limitations-of-extension-methods"></a><span data-ttu-id="42c78-114">Omezení rozšiřujících metod</span><span class="sxs-lookup"><span data-stu-id="42c78-114">Limitations of extension methods</span></span>

<span data-ttu-id="42c78-115">Jedním ze způsobů, jak můžete implementovat chování, které se zobrazí jako součást rozhraní je definovat [metody rozšíření,](../programming-guide/classes-and-structs/extension-methods.md) které poskytují výchozí chování.</span><span class="sxs-lookup"><span data-stu-id="42c78-115">One way you can implement behavior that appears as part of an interface is to define [extension methods](../programming-guide/classes-and-structs/extension-methods.md) that provide the default behavior.</span></span> <span data-ttu-id="42c78-116">Rozhraní deklarovat minimální sadu členů a zároveň poskytuje větší plochu pro všechny třídy, která implementuje toto rozhraní.</span><span class="sxs-lookup"><span data-stu-id="42c78-116">Interfaces declare a minimum set of members while providing a greater surface area for any class that implements that interface.</span></span> <span data-ttu-id="42c78-117">Například metody rozšíření <xref:System.Linq.Enumerable> v poskytují implementaci pro všechny sekvence být zdrojem dotazu LINQ.</span><span class="sxs-lookup"><span data-stu-id="42c78-117">For example, the extension methods in <xref:System.Linq.Enumerable> provide the implementation for any sequence to be the source of a LINQ query.</span></span>

<span data-ttu-id="42c78-118">Rozšiřující metody jsou vyřešeny v době kompilace pomocí deklarovaného typu proměnné.</span><span class="sxs-lookup"><span data-stu-id="42c78-118">Extension methods are resolved at compile time, using the declared type of the variable.</span></span> <span data-ttu-id="42c78-119">Třídy, které implementují rozhraní může poskytnout lepší implementaci pro všechny metody rozšíření.</span><span class="sxs-lookup"><span data-stu-id="42c78-119">Classes that implement the interface can provide a better implementation for any extension method.</span></span> <span data-ttu-id="42c78-120">Deklarace proměnných musí odpovídat implementujícímu typu, aby kompilátor mohl tuto implementaci zvolit.</span><span class="sxs-lookup"><span data-stu-id="42c78-120">Variable declarations must match the implementing type to enable the compiler to choose that implementation.</span></span> <span data-ttu-id="42c78-121">Když typ kompilace odpovídá rozhraní, volání metody přeložit metodu rozšíření.</span><span class="sxs-lookup"><span data-stu-id="42c78-121">When the compile-time type matches the interface, method calls resolve to the extension method.</span></span> <span data-ttu-id="42c78-122">Další obavou s metodami rozšíření je, že tyto metody jsou přístupné všude tam, kde je přístupná třída obsahující metody rozšíření.</span><span class="sxs-lookup"><span data-stu-id="42c78-122">Another concern with extension methods is that those methods are accessible wherever the class containing the extension methods is accessible.</span></span> <span data-ttu-id="42c78-123">Třídy nelze deklarovat, pokud by měly nebo neměly poskytovat funkce deklarované v metodách rozšíření.</span><span class="sxs-lookup"><span data-stu-id="42c78-123">Classes cannot declare if they should or should not provide features declared in extension methods.</span></span>

<span data-ttu-id="42c78-124">Počínaje C# 8.0, můžete deklarovat výchozí implementace jako metody rozhraní.</span><span class="sxs-lookup"><span data-stu-id="42c78-124">Starting with C# 8.0, you can declare the default implementations as interface methods.</span></span> <span data-ttu-id="42c78-125">Potom každá třída automaticky používá výchozí implementaci.</span><span class="sxs-lookup"><span data-stu-id="42c78-125">Then, every class automatically uses the default implementation.</span></span> <span data-ttu-id="42c78-126">Každá třída, která může poskytnout lepší implementaci, může přepsat definici metody rozhraní pomocí lepšího algoritmu.</span><span class="sxs-lookup"><span data-stu-id="42c78-126">Any class that can provide a better implementation can override the interface method definition with a better algorithm.</span></span> <span data-ttu-id="42c78-127">V jistém smyslu tato technika zní podobně jako jak byste mohli použít [metody rozšíření](../programming-guide/classes-and-structs/extension-methods.md).</span><span class="sxs-lookup"><span data-stu-id="42c78-127">In one sense, this technique sounds similar to how you could use [extension methods](../programming-guide/classes-and-structs/extension-methods.md).</span></span>

<span data-ttu-id="42c78-128">V tomto článku se dozvíte, jak výchozí implementace rozhraní umožňují nové scénáře.</span><span class="sxs-lookup"><span data-stu-id="42c78-128">In this article, you'll learn how default interface implementations enable new scenarios.</span></span>

## <a name="design-the-application"></a><span data-ttu-id="42c78-129">Návrh aplikace</span><span class="sxs-lookup"><span data-stu-id="42c78-129">Design the application</span></span>

<span data-ttu-id="42c78-130">Zvažte aplikaci domácí automatizace.</span><span class="sxs-lookup"><span data-stu-id="42c78-130">Consider a home automation application.</span></span> <span data-ttu-id="42c78-131">Pravděpodobně máte mnoho různých typů světel a indikátorů, které by mohly být použity v celém domě.</span><span class="sxs-lookup"><span data-stu-id="42c78-131">You probably have many different types of lights and indicators that could be used throughout the house.</span></span> <span data-ttu-id="42c78-132">Každé světlo musí podporovat api je zapnout a vypnout a hlásit aktuální stav.</span><span class="sxs-lookup"><span data-stu-id="42c78-132">Every light must support APIs to turn them on and off, and to report the current state.</span></span> <span data-ttu-id="42c78-133">Některá světla a indikátory mohou podporovat další funkce, například:</span><span class="sxs-lookup"><span data-stu-id="42c78-133">Some lights and indicators may support other features, such as:</span></span>

- <span data-ttu-id="42c78-134">Zapněte světlo a po časovači jej vypněte.</span><span class="sxs-lookup"><span data-stu-id="42c78-134">Turn light on, then turn it off after a timer.</span></span>
- <span data-ttu-id="42c78-135">Po určitou dobu zabližte světlem.</span><span class="sxs-lookup"><span data-stu-id="42c78-135">Blink the light for a period of time.</span></span>

<span data-ttu-id="42c78-136">Některé z těchto rozšířených funkcí by mohly být emulovány v zařízeních, která podporují minimální sadu.</span><span class="sxs-lookup"><span data-stu-id="42c78-136">Some of these extended capabilities could be emulated in devices that support the minimal set.</span></span> <span data-ttu-id="42c78-137">To znamená, že poskytuje výchozí implementaci.</span><span class="sxs-lookup"><span data-stu-id="42c78-137">That indicates providing a default implementation.</span></span> <span data-ttu-id="42c78-138">Pro zařízení, která mají více vestavěných funkcí, by software zařízení používal nativní funkce.</span><span class="sxs-lookup"><span data-stu-id="42c78-138">For those devices that have more capabilities built in, the device software would use the native capabilities.</span></span> <span data-ttu-id="42c78-139">Pro ostatní světla mohou zvolit implementaci rozhraní a použít výchozí implementaci.</span><span class="sxs-lookup"><span data-stu-id="42c78-139">For other lights, they could choose to implement the interface and use the default implementation.</span></span>

<span data-ttu-id="42c78-140">Výchozí členové rozhraní je lepší řešení pro tento scénář než metody rozšíření.</span><span class="sxs-lookup"><span data-stu-id="42c78-140">Default interface members is a better solution for this scenario than extension methods.</span></span> <span data-ttu-id="42c78-141">Autoři třídy mohou řídit, která rozhraní se rozhodnou implementovat.</span><span class="sxs-lookup"><span data-stu-id="42c78-141">Class authors can control which interfaces they choose to implement.</span></span> <span data-ttu-id="42c78-142">Tato rozhraní, která zvolí, jsou k dispozici jako metody.</span><span class="sxs-lookup"><span data-stu-id="42c78-142">Those interfaces they choose are available as methods.</span></span> <span data-ttu-id="42c78-143">Kromě toho protože výchozí metody rozhraní jsou virtuální ve výchozím nastavení, expedice metody vždy zvolí implementaci ve třídě.</span><span class="sxs-lookup"><span data-stu-id="42c78-143">In addition, because default interface methods are virtual by default, the method dispatch always chooses the implementation in the class.</span></span>

<span data-ttu-id="42c78-144">Pojďme vytvořit kód k předvedení těchto rozdílů.</span><span class="sxs-lookup"><span data-stu-id="42c78-144">Let's create the code to demonstrate these differences.</span></span>

## <a name="create-interfaces"></a><span data-ttu-id="42c78-145">Vytváření rozhraní</span><span class="sxs-lookup"><span data-stu-id="42c78-145">Create interfaces</span></span>

<span data-ttu-id="42c78-146">Začněte vytvořením rozhraní, které definuje chování pro všechna světla:</span><span class="sxs-lookup"><span data-stu-id="42c78-146">Start by creating the interface that defines the behavior for all lights:</span></span>

[!code-csharp[Declare base interface](~/samples/snippets/csharp/tutorials/mixins-with-interfaces/UnusedExampleCode.cs?name=SnippetILightInterfaceV1)]

<span data-ttu-id="42c78-147">Základní stropní svítidlo může implementovat toto rozhraní, jak je znázorněno v následujícím kódu:</span><span class="sxs-lookup"><span data-stu-id="42c78-147">A basic overhead light fixture might implement this interface as shown in the following code:</span></span>

[!code-csharp[First overhead light](~/samples/snippets/csharp/tutorials/mixins-with-interfaces/UnusedExampleCode.cs?name=SnippetOverheadLightV1)]

<span data-ttu-id="42c78-148">V tomto kurzu kód neřídí zařízení IoT, ale emuluje tyto aktivity zápisem zpráv do konzoly.</span><span class="sxs-lookup"><span data-stu-id="42c78-148">In this tutorial, the code doesn't drive IoT devices, but emulates those activities by writing messages to the console.</span></span> <span data-ttu-id="42c78-149">Můžete prozkoumat kód bez automatizace vašeho domu.</span><span class="sxs-lookup"><span data-stu-id="42c78-149">You can explore the code without automating your house.</span></span>

<span data-ttu-id="42c78-150">Dále definujme rozhraní pro světlo, které se může automaticky vypnout po časovém odnoži:</span><span class="sxs-lookup"><span data-stu-id="42c78-150">Next, let's define the interface for a light that can automatically turn off after a timeout:</span></span>

[!code-csharp[pure Timer interface](~/samples/snippets/csharp/tutorials/mixins-with-interfaces/UnusedExampleCode.cs?name=SnippetPureTimerInterface)]

<span data-ttu-id="42c78-151">Můžete přidat základní implementaci na kontrolku režie, ale lepším řešením je `virtual` upravit tuto definici rozhraní tak, aby poskytovala výchozí implementaci:</span><span class="sxs-lookup"><span data-stu-id="42c78-151">You could add a basic implementation to the overhead light, but a better solution is to modify this interface definition to provide a `virtual` default implementation:</span></span>

[!code-csharp[Timer interface](~/samples/snippets/csharp/tutorials/mixins-with-interfaces/ITimerLight.cs?name=SnippetTimerLightFinal)]

<span data-ttu-id="42c78-152">Přidáním této změny `OverheadLight` může třída implementovat funkci časovače deklarováním podpory rozhraní:</span><span class="sxs-lookup"><span data-stu-id="42c78-152">By adding that change, the `OverheadLight` class can implement the timer function by declaring support for the interface:</span></span>

```csharp
public class OverheadLight : ITimerLight { }
```

<span data-ttu-id="42c78-153">Jiný typ světla může podporovat sofistikovanější protokol.</span><span class="sxs-lookup"><span data-stu-id="42c78-153">A different light type may support a more sophisticated protocol.</span></span> <span data-ttu-id="42c78-154">Může poskytnout vlastní implementaci `TurnOnFor`pro , jak je znázorněno v následujícím kódu:</span><span class="sxs-lookup"><span data-stu-id="42c78-154">It can provide its own implementation for `TurnOnFor`, as shown in the following code:</span></span>

[!code-csharp[Override the timer function](~/samples/snippets/csharp/tutorials/mixins-with-interfaces/HalogenLight.cs?name=SnippetHalogenLight)]

<span data-ttu-id="42c78-155">Na rozdíl od přepsání `TurnOnFor` metody `HalogenLight` virtuální třídy `override` deklarace ve třídě nepoužívá klíčové slovo.</span><span class="sxs-lookup"><span data-stu-id="42c78-155">Unlike overriding virtual class methods, the declaration of `TurnOnFor` in the `HalogenLight` class does not use the `override` keyword.</span></span>

## <a name="mix-and-match-capabilities"></a><span data-ttu-id="42c78-156">Kombinovat možnosti</span><span class="sxs-lookup"><span data-stu-id="42c78-156">Mix and match capabilities</span></span>

<span data-ttu-id="42c78-157">Výhody výchozích metod rozhraní se stávají jasnějšími, když zavádíte pokročilejší funkce.</span><span class="sxs-lookup"><span data-stu-id="42c78-157">The advantages of default interface methods become clearer as you introduce more advanced capabilities.</span></span> <span data-ttu-id="42c78-158">Pomocí rozhraní umožňuje kombinovat možnosti.</span><span class="sxs-lookup"><span data-stu-id="42c78-158">Using interfaces enables you to mix and match capabilities.</span></span> <span data-ttu-id="42c78-159">Umožňuje také každému autorovi třídy vybrat si mezi výchozí implementací a vlastní implementací.</span><span class="sxs-lookup"><span data-stu-id="42c78-159">It also enables each class author to choose between the default implementation and a custom implementation.</span></span> <span data-ttu-id="42c78-160">Přidáme rozhraní s výchozí implementací pro blikající světlo:</span><span class="sxs-lookup"><span data-stu-id="42c78-160">Let's add an interface with a default implementation for a blinking light:</span></span>

[!code-csharp[Define the blinking light interface](~/samples/snippets/csharp/tutorials/mixins-with-interfaces/IBlinkingLight.cs?name=SnippetBlinkingLight)]

<span data-ttu-id="42c78-161">Výchozí implementace umožňuje blikání libovolného světla.</span><span class="sxs-lookup"><span data-stu-id="42c78-161">The default implementation enables any light to blink.</span></span> <span data-ttu-id="42c78-162">Kontrolka nad hlavou může přidat časovač i funkce blikání pomocí výchozí implementace:</span><span class="sxs-lookup"><span data-stu-id="42c78-162">The overhead light can add both timer and blink capabilities using the default implementation:</span></span>

[!code-csharp[Use the default blink function](~/samples/snippets/csharp/tutorials/mixins-with-interfaces/OverheadLight.cs?name=SnippetOverheadLight)]

<span data-ttu-id="42c78-163">Nový typ světla, `LEDLight` podporuje jak funkci časovače, tak funkci bliknutí přímo.</span><span class="sxs-lookup"><span data-stu-id="42c78-163">A new light type, the `LEDLight` supports both the timer function and the blink function directly.</span></span> <span data-ttu-id="42c78-164">Tento styl světla implementuje `ITimerLight` rozhraní a `IBlinkingLight` rozhraní `Blink` a přepíše metodu:</span><span class="sxs-lookup"><span data-stu-id="42c78-164">This light style implements both the `ITimerLight` and `IBlinkingLight` interfaces, and overrides the `Blink` method:</span></span>

[!code-csharp[Override the blink function](~/samples/snippets/csharp/tutorials/mixins-with-interfaces/LEDLight.cs?name=SnippetLEDLight)]

<span data-ttu-id="42c78-165">Funkce `ExtraFancyLight` může podporovat funkce blikání i časovače přímo:</span><span class="sxs-lookup"><span data-stu-id="42c78-165">An `ExtraFancyLight` might support both blink and timer functions directly:</span></span>

[!code-csharp[Override the blink and timer function](~/samples/snippets/csharp/tutorials/mixins-with-interfaces/ExtraFancyLight.cs?name=SnippetExtraFancyLight)]

<span data-ttu-id="42c78-166">Dříve `HalogenLight` vytvořené vytvořené nepodporuje blikání.</span><span class="sxs-lookup"><span data-stu-id="42c78-166">The `HalogenLight` you created earlier doesn't support blinking.</span></span> <span data-ttu-id="42c78-167">Takže nepřidávejte `IBlinkingLight` seznam podporovaných rozhraní.</span><span class="sxs-lookup"><span data-stu-id="42c78-167">So, don't add the `IBlinkingLight` to the list of its supported interfaces.</span></span>

## <a name="detect-the-light-types-using-pattern-matching"></a><span data-ttu-id="42c78-168">Detekce typů světel pomocí přizpůsobení vzoru</span><span class="sxs-lookup"><span data-stu-id="42c78-168">Detect the light types using pattern matching</span></span>

<span data-ttu-id="42c78-169">Dále napíšeme nějaký testovací kód.</span><span class="sxs-lookup"><span data-stu-id="42c78-169">Next, let's write some test code.</span></span> <span data-ttu-id="42c78-170">Můžete použít c# vzor [odpovídající](../pattern-matching.md) funkce k určení světla schopnosti kontrolou, která rozhraní podporuje.</span><span class="sxs-lookup"><span data-stu-id="42c78-170">You can make use of C#'s [pattern matching](../pattern-matching.md) feature to determine a light's capabilities by examining which interfaces it supports.</span></span>  <span data-ttu-id="42c78-171">Následující metoda vykonává podporované schopnosti každého světla:</span><span class="sxs-lookup"><span data-stu-id="42c78-171">The following method exercises the supported capabilities of each light:</span></span>

[!code-csharp[Test a light's capabilities](~/samples/snippets/csharp/tutorials/mixins-with-interfaces/Program.cs?name=SnippetTestLightFunctions)]

<span data-ttu-id="42c78-172">Následující kód v `Main` metodě vytvoří každý typ světla v pořadí a testuje, že světlo:</span><span class="sxs-lookup"><span data-stu-id="42c78-172">The following code in your `Main` method creates each light type in sequence and tests that light:</span></span>

[!code-csharp[Test a light's capabilities](~/samples/snippets/csharp/tutorials/mixins-with-interfaces/Program.cs?name=SnippetMainMethod)]

## <a name="how-the-compiler-determines-best-implementation"></a><span data-ttu-id="42c78-173">Jak kompilátor určuje nejlepší implementaci</span><span class="sxs-lookup"><span data-stu-id="42c78-173">How the compiler determines best implementation</span></span>

<span data-ttu-id="42c78-174">Tento scénář zobrazuje základní rozhraní bez implementace.</span><span class="sxs-lookup"><span data-stu-id="42c78-174">This scenario shows a base interface without any implementations.</span></span> <span data-ttu-id="42c78-175">Přidání metody do `ILight` rozhraní zavádí nové složitosti.</span><span class="sxs-lookup"><span data-stu-id="42c78-175">Adding a method into the `ILight` interface introduces new complexities.</span></span> <span data-ttu-id="42c78-176">Pravidla jazyka, kterými se řídí metody výchozí rozhraní minimalizovat vliv na konkrétní třídy, které implementují více odvozených rozhraní.</span><span class="sxs-lookup"><span data-stu-id="42c78-176">The language rules governing default interface methods minimize the effect on the concrete classes that implement multiple derived interfaces.</span></span> <span data-ttu-id="42c78-177">Vylepšeme původní rozhraní novou metodou, která ukáže, jak to změní jeho použití.</span><span class="sxs-lookup"><span data-stu-id="42c78-177">Let's enhance the original interface with a new method to show how that changes its use.</span></span> <span data-ttu-id="42c78-178">Každá kontrolka může vykazovat stav napájení jako vyčíslenou hodnotu:</span><span class="sxs-lookup"><span data-stu-id="42c78-178">Every indicator light can report its power status as an enumerated value:</span></span>

[!code-csharp[Enumeration for power status](~/samples/snippets/csharp/tutorials/mixins-with-interfaces/ILight.cs?name=SnippetPowerStatus)]

<span data-ttu-id="42c78-179">Výchozí implementace nepředpokládá žádnou moc:</span><span class="sxs-lookup"><span data-stu-id="42c78-179">The default implementation assumes no power:</span></span>

[!code-csharp[Report a default power status](~/samples/snippets/csharp/tutorials/mixins-with-interfaces/ILight.cs?name=SnippetILightInterface)]

<span data-ttu-id="42c78-180">Tyto změny zkompilovat `ExtraFancyLight` čistě, i `ILight` když deklaruje `ITimerLight` podporu `IBlinkingLight`pro rozhraní a obě odvozené rozhraní a .</span><span class="sxs-lookup"><span data-stu-id="42c78-180">These changes compile cleanly, even though the `ExtraFancyLight` declares support for the `ILight` interface and both derived interfaces, `ITimerLight` and `IBlinkingLight`.</span></span> <span data-ttu-id="42c78-181">V `ILight` rozhraní je deklarována pouze jedna "nejbližší" implementace.</span><span class="sxs-lookup"><span data-stu-id="42c78-181">There's only one "closest" implementation declared in the `ILight` interface.</span></span> <span data-ttu-id="42c78-182">Každá třída, která deklarovala přepsání by se stala "nejbližší" implementací.</span><span class="sxs-lookup"><span data-stu-id="42c78-182">Any class that declared an override would become the one "closest" implementation.</span></span> <span data-ttu-id="42c78-183">Viděli jste příklady v předchozích třídách, které převyšují členy jiných odvozených rozhraní.</span><span class="sxs-lookup"><span data-stu-id="42c78-183">You saw examples in the preceding classes that overrode the members of other derived interfaces.</span></span>

<span data-ttu-id="42c78-184">Vyhněte se přepsání stejné metody ve více odvozených rozhraních.</span><span class="sxs-lookup"><span data-stu-id="42c78-184">Avoid overriding the same method in multiple derived interfaces.</span></span> <span data-ttu-id="42c78-185">Tím se vytvoří volání nejednoznačné metody vždy, když třída implementuje obě odvozená rozhraní.</span><span class="sxs-lookup"><span data-stu-id="42c78-185">Doing so creates an ambiguous method call whenever a class implements both derived interfaces.</span></span> <span data-ttu-id="42c78-186">Kompilátor nemůže vybrat jednu lepší metodu, takže vydá chybu.</span><span class="sxs-lookup"><span data-stu-id="42c78-186">The compiler can't pick a single better method so it issues an error.</span></span> <span data-ttu-id="42c78-187">Například pokud oba `IBlinkingLight` `ITimerLight` a implementované `PowerStatus`přepsání , `OverheadLight` bude muset poskytnout konkrétnější přepsání.</span><span class="sxs-lookup"><span data-stu-id="42c78-187">For example, if both the `IBlinkingLight` and `ITimerLight` implemented an override of `PowerStatus`, the `OverheadLight` would need to provide a more specific override.</span></span> <span data-ttu-id="42c78-188">V opačném případě kompilátor nelze vybrat mezi implementacemi ve dvou odvozených rozhraních.</span><span class="sxs-lookup"><span data-stu-id="42c78-188">Otherwise, the compiler can't pick between the implementations in the two derived interfaces.</span></span> <span data-ttu-id="42c78-189">Obvykle se můžete vyhnout této situaci udržováním definice rozhraní malé a zaměřené na jednu funkci.</span><span class="sxs-lookup"><span data-stu-id="42c78-189">You can usually avoid this situation by keeping interface definitions small and focused on one feature.</span></span> <span data-ttu-id="42c78-190">V tomto scénáři každá schopnost světla je jeho vlastní rozhraní; více rozhraní jsou zděděny pouze třídy.</span><span class="sxs-lookup"><span data-stu-id="42c78-190">In this scenario, each capability of a light is its own interface; multiple interfaces are only inherited by classes.</span></span>

<span data-ttu-id="42c78-191">Tato ukázka ukazuje jeden scénář, kde můžete definovat diskrétní funkce, které mohou být smíchány do tříd.</span><span class="sxs-lookup"><span data-stu-id="42c78-191">This sample shows one scenario where you can define discrete features that can be mixed into classes.</span></span> <span data-ttu-id="42c78-192">Deklarujete libovolnou sadu podporovaných funkcí deklarováním, která rozhraní třída podporuje.</span><span class="sxs-lookup"><span data-stu-id="42c78-192">You declare any set of supported functionality by declaring which interfaces a class supports.</span></span> <span data-ttu-id="42c78-193">Použití virtuálních výchozích metod rozhraní umožňuje třídám používat nebo definovat jinou implementaci pro některé nebo všechny metody rozhraní.</span><span class="sxs-lookup"><span data-stu-id="42c78-193">The use of virtual default interface methods enables classes to use or define a different implementation for any or all the interface methods.</span></span> <span data-ttu-id="42c78-194">Tato jazyková funkce poskytuje nové způsoby modelování reálných systémů, které vytváříte.</span><span class="sxs-lookup"><span data-stu-id="42c78-194">This language capability provides new ways to model the real-world systems you're building.</span></span> <span data-ttu-id="42c78-195">Výchozí metody rozhraní poskytují jasnější způsob, jak vyjádřit související třídy, které mohou kombinovat různé funkce pomocí virtuálníimplementace těchto funkcí.</span><span class="sxs-lookup"><span data-stu-id="42c78-195">Default interface methods provide a clearer way to express related classes that may mix and match different features using virtual implementations of those capabilities.</span></span>
