### YamlMime:Tutorial
title: Prozkoumejte C# 6 C# – C# Interaktivní kurz
metadata:
  title: Prozkoumat C# 6 – vyzkoušení nových funkcí v C# 6 interaktivních pomocí prohlížeče
  description: V tomto kurzu použijete prohlížeč k prozkoumání C# 6 interaktivně. Prozkoumáte novou idiomy, kterou můžete použít s C# 6, která umožní přesnější a čitelný kód.
  audience: Developer
  level: intermediate
  ms.date: 12/11/2018
  displayType: two-column
  interactive: csharp
  ms.openlocfilehash: bd11bda04ccf7d8253907bee8f17fc2b86ed76cd
  ms.sourcegitcommit: f348c84443380a1959294cdf12babcb804cfa987
  ms.translationtype: MT
  ms.contentlocale: cs-CZ
  ms.lasthandoff: 11/12/2019
  ms.locfileid: "73969493"
items:
- durationInMinutes: 1
  content: >
    Tento kurz vám umožní interaktivně C# prozkoumat 6, pomocí prohlížeče napsat C# a zobrazit výsledky kompilace a spuštění kódu. Obsahuje řadu lekcí, které upravují předchozí C# postupy použití novějších a dalších stručných C# funkcí 6. Zbývající část tohoto článku obsahuje přehled každé z těchto funkcí s odkazem na prozkoumání jednotlivých funkcí.
- title: Automatické vlastnosti jen pro čtení umožňují typy jen pro čtení.
  durationInMinutes: 2
  content: "Dvě vylepšení syntaxe automatických vlastností usnadňují používání automatických vlastností na více místech: automatické vlastnosti a Inicializátory automatických vlastností. Vezměte v úvahu tento malý program:\n\n[!code-csharp[Starter](../../../../samples/csharp/tutorials/exploration/csharp6-starter/Program.cs)]  \n\n    \n Přejděte do detailního režimu a zkopírujte předchozí kód do C# interaktivního okna. Pak vyberte *Spustit* a podívejte se, jak kód dělá. `AllCaps` má nežádoucí vedlejší účinky úprav hodnot vlastností spolu s vrácením řetězce velkých písmen. Autor třídy `Person` určil řetězce pro `FirstName` a `LastName` pro čtení. S C# 6 můžete tento záměr udělat jasným. Odeberte `private set` z obou vlastností, aby bylo možné vytvořit automatickou vlastnost určenou jen pro čtení. Výběrem možnosti *Spustit* zobrazíte, že kompilátor bude měnit dvě umístění, kde se změní vlastnosti `FirstName` a `LastName`, i když by neměly být. Chcete-li opravit chybu kompilátoru, můžete změnit metodu `AllCaps` na následující kód:\n\n```csharp\npublic string AllCaps()\n{\n  return ToString().ToUpper();\n}\n```\n\nPomocí této nové syntaxe kompilátor zajišťuje, že vlastnosti jsou neměnné.\n"
- title: Inicializovat zálohovací pole pro automatické vlastnosti
  durationInMinutes: 1
  content: "Nová syntaxe v C# 6 umožňuje použít inicializátory pro automatické vlastnosti. To je důležitější, protože třídy rozšiřují nové možnosti. Přidejte vlastnost prostřední název a nový konstruktor, který přijímá tři řetězce pro třídu `Person`:\n\n[!code-csharp[MiddleName](../../../../samples/csharp/tutorials/exploration/csharp6-finished/Program.cs#MiddleName)]  \n\nPřiřazení vlastnosti `MiddleName` je inicializátor. Inicializuje pole zálohování generované kompilátorem pro prostřední jméno.\n"
- title: Členové tvoření výrazy
  durationInMinutes: 2
  content: >
    Členové Expression-těle poskytují zjednodušenou syntaxi pro odlehčené metody. Třída `Person` má dva Skvělé kandidáty. Podívejte se na deklaraci `ToString`:


    ```csharp

    public override string ToString()

    {
        return FirstName + " " + LastName;
    }

    ```


    Nahraďte tuto deklaraci `ToString` následujícím kódem:


    ```csharp

    public override string ToString() => FirstName + " " + LastName;

    ```


    Zkuste to samé s metodou `AllCaps`. Toto je malé zlepšení, ale v případě, že je to možné, vytvoří mnohem čitelnější kód, zejména u Přenos dat objektů (DTO) a dalších typů s minimálním chováním.
- title: Import jedné třídy
  durationInMinutes: 2
  content: "Pokud opakovaně použijete jednu statickou metodu třídy v celém kódu, včetně názvu třídy, pokaždé, když je pokryta význam vašeho kódu. Třída `Person` aktuálně importuje `System` obor názvů, i když se používá pouze <xref:System.Console?displayProperty=nameWithType>. Upravte příkaz `using` následujícím způsobem:\n\n[!code-csharp[MiddleName](../../../../samples/csharp/tutorials/exploration/csharp6-finished/Program.cs#UsingStatic)]  \n\nPříkaz `static using` je užitečnější ve větších programech, které umožňují rozsáhlé použití jedné třídy s mnoha statickými metodami, jako je například třída [`string`](xref:System.String) nebo třída <xref:System.Math?displayProperty=nameWithType>.\n"
- title: Lepší formát řetězce
  durationInMinutes: 2
  content: "C#6 obsahuje novou syntaxi pro sestavování řetězců z řetězce a vložených výrazů, které jsou vyhodnocovány k vytvoření jiných řetězcových hodnot. Můžete změnit `ToString` a `AllCaps` metody pro použití této syntaxe:\n\n[!code-csharp[StringInterpolation](../../../../samples/csharp/tutorials/exploration/csharp6-finished/Program.cs#StringInterpolation)]  \n\nMísto pozičních argumentů mezi `{` a `}`zapisujete C# výrazy přímo. Můžete to samé provést v metodě `Main`. Existující kód nahraďte následujícím kódem:\n\n[!code-csharp[InterpolationMain](../../../../samples/csharp/tutorials/exploration/csharp6-finished/Program.cs#InterpolationMain)]  \n\nV těchto výrazech nejste omezeni na jednu proměnnou. Pojďme začít novým příkladem a upravit ho k předvedení dalších výrazů, které můžete použít s interpolací řetězce. Vložte následující kód do interaktivního okna v metodě `Main`:\n\n[!code-csharp[Phrases](../../../../samples/csharp/tutorials/exploration/csharp6-finished/Program.cs#Phrases)]  \nKterý používá LINQ, takže budete muset přidat následující příkaz using do horní části interaktivního okna:\n\n```csharp\nusing System.Linq;\n```\n\nMůžete odebrat místní proměnnou `average` a provést tento výpočet jako součást interpolované řetězcové výrazu. Poslední dva řádky nahraďte následujícím:\n\n```csharp\nWriteLine($\"The average word length is: {wordLength.Average()}\");\n```\n\nKdyž spustíte předchozí příklad, zjistíte, že výstup pro `Average` má více desetinných míst, než byste chtěli. Syntaxe interpolace řetězce podporuje všechny formátovací řetězce, které jsou k dispozici pomocí dřívějších metod formátování. Řetězec formátu určíte uvnitř složených závorek. Přidejte `:` za výraz, který chcete naformátovat:\n\n```csharp\nWriteLine($\"The average word length is: {wordLength.Average():F2}\");\n```\n"
- title: Rychlé a jednoduché kontroly s hodnotou null
  durationInMinutes: 2
  content: "Operátor `?.` (null Conditional) usnadňuje psaní logiky, které přebírají `null` hodnoty do účtu bez dalších `if` kontrol. Chcete-li prozkoumat tuto funkci, začněte zkopírováním následujícího kódu do interaktivního okna a vyzkoušejte:\n\n```csharp\nusing System;\n\npublic class Program\n{\n    public static void Main()\n    {\n      string s = null;\n      Console.WriteLine(s.Length);\n    }\n}\n```\n\nVyvolá <xref:System.NullReferenceException> při spuštění ukázky. Změňte operátor přístupu ke členu `.` na **podmíněný operátor s hodnotou null**:\n\n```csharp\nConsole.WriteLine(s?.Length);\n``` \n\nPo této změně není k dispozici žádný výstup. Důvodem je, že výsledkem `s?.Length` je `int?`, pokud je výsledek `s.Length` `int`. V tomto příkladu je `s?.Length` `null`. `?.` vrátí `null`, pokud je jeho levý operand `null`. Pokud je typ pravého operandu typ hodnoty, operátor `?.` vrátí typ s možnou hodnotou null pro daný typ. Kromě `?.` můžete pro přístup k poli nebo indexeru použít `?[]`. V interaktivním okně zkuste použít následující kód:\n\n ```csharp\n char? c = s?[0];\n Console.WriteLine(c.HasValue);\n ```\n\n Více podmíněných operátorů lze zkombinovat do jednoho výrazu. `null` levý operand vytvoří `null` výsledek, což usnadňuje Vyhněte se vnořeným klauzulím if pro přístup ke členům členů. Můžete například vyzkoušet následující kód v interaktivním okně:\n\n ```csharp\n string s = null;\n bool? hasMore = s?.ToCharArray()?.GetEnumerator()?.MoveNext();\n Console.WriteLine(hasMore.HasValue);\n ```\n\n Předchozí příklad lze zjednodušit pomocí **operátoru slučování null** k poskytnutí výchozí hodnoty:\n\n ```csharp\n bool hasMore = s?.ToCharArray()?.GetEnumerator()?.MoveNext() ?? false;\n Console.WriteLine(hasMore);\n ```\n\n **Podmíněný operátor s hodnotou null** vám pomůže napsat kód, který vytvoří základní logickou logiku jasný a bez problémů testuje `null` hodnoty.\n"
- title: Filtry výjimek
  durationInMinutes: 2
  content: "Filtry výjimek umožňují zachytit výjimku na základě nějaké podmínky. Typickým použitím je vytvořit metodu filtru, která protokoluje výjimky, ale nikdy tyto výjimky nezpracovává. Filtr výjimek je logický výraz, který je `true` při spuštění klauzule `catch` a `false`, pokud by výjimka neměla být zachycena klauzulí `catch`. Vyzkoušejte následující kód v interaktivním okně: zaznamená typ výjimky a zprávu do konzoly. Vrátí `false`, což znamená, že výjimku nelze zpracovat. Vyzkoušejte program v interaktivním okně.\n\n```csharp\nusing System;\n\npublic class Program\n{\n    public static void Main()\n    {\n        try \n        {\n            string s = null;\n            Console.WriteLine(s.Length);\n\n        } catch (Exception e) when (LogException(e))\n        {\n        }\n        Console.WriteLine(\"Exception must have been handled\");\n    }\n\n    private static bool LogException(Exception e)\n    {\n        Console.WriteLine($\"\\tIn the log routine. Caught {e.GetType()}\");\n        Console.WriteLine($\"\\tMessage: {e.Message}\");\n        return false;\n    }\n}\n```\n\nMěla by se zobrazit zpráva z metody `LogException` následovaná výchozí zprávou výjimky. Stačí pouze experimentovat, změnit příkaz `return false` na `return true` a znovu spustit. Nyní je výjimka zachycena a program se spustí k dokončení.\n\nKromě scénářů protokolování může být filtry výjimek nejužitečnější, pokud vlastnost výjimky určuje, jakou akci chcete provést. Můžete například zobrazit uvnitř <xref:System.AggregateException>, abyste viděli, co obsahovalo výjimky, a v závislosti na konkrétní výjimce provedete nějakou vhodnou akci.\n"
- title: Použití nameof
  durationInMinutes: 2
  content: "Operátor `nameof` vrací název jakékoli proměnné, typu nebo členu typu. Vyzkoušejte následující kód v interaktivním okně, abyste viděli, jak funguje:\n\n```csharp\nusing System;\nusing System.Collections.Generic;\n\npublic class Program\n{\n    public static void Main()\n    {\n        Console.WriteLine(nameof(System.String));\n        int j = 5;\n        Console.WriteLine(nameof(j));\n        List<string> names = new List<string>();\n        Console.WriteLine(nameof(names));\n    }\n}\n```\n\nVýstup odpovídá názvu proměnné nebo typu. I když jste zadali plně kvalifikovaný název typu (například `System.String`), operátor `nameof` vrátí Nekvalifikovaný název. Tato funkce je nejužitečnější, pokud potřebujete převést parametr nebo název vlastnosti na řetězec. Mezi příklady patří zachycení názvu argumentu pro vyvolání <xref:System.ArgumentNullException> nebo <xref:System.ArgumentException>nebo zachycení názvu změněné vlastnosti při implementaci <xref:System.ComponentModel.INotifyPropertyChanged>. \n"
- title: Nová syntaxe inicializace objektu
  durationInMinutes: 2
  content: "Syntaxe inicializátoru objektu teď podporuje inicializaci *indexerů* a také vlastnosti a pole. Tato přidání usnadňuje inicializaci slovníků a dalších typů. Začněte slovníkem. V interaktivním okně spusťte následující kód:\n\n```csharp\nvar messages = new Dictionary<int, string>\n{\n    [404] = \"Page not Found\",\n    [302] = \"Page moved, but left a forwarding address.\",\n    [500] = \"The web server can't come out to play today.\"\n};\n\nConsole.WriteLine(messages[302]);\n```\n\nTato syntaxe, která nastaví hodnotu v indexeru, může být použita pro libovolný typ, který má přístup k přístupovému objektu set pro indexer.\n\nDruhá změna usnadňuje povolení syntaxe inicializátoru pro typy, které reprezentují sekvence. Inicializátory kolekce lze použít pro libovolnou třídu, která implementuje <xref:System.Collections.IEnumerable> a má veřejně přístupnou metodu `Add`. Tato metoda `Add` nyní může být metodou rozšíření. \n\nNásledující příklad ukazuje jeden scénář pro tuto syntaxi. Vytvoří třídu `Path`, která implementuje `IEnumerable<Point3D>` a má metodu pro přidání bodů, které přijímají tři argumenty. Třída `Extensions` vytvoří další `Add` metodu pro přidání nového bodu z jeho tří součástí. Tato ukázka se aktuálně nespouští interaktivně z důvodu omezení v prostředí.\n\n```csharp\npublic class Path : IEnumerable<Point3D>\n{\n    private List<Point3D> points = new List<Point3D>();\n    public IEnumerator<Point3D> GetEnumerator() => points.GetEnumerator();\n    IEnumerator IEnumerable.GetEnumerator() => points.GetEnumerator();\n\n    public void Add(Point3D pt) => points.Add(pt);\n}\n\npublic static class Extensions\n{\n    public static void Add(this Path path, double x, double y, double z) => path.Add(new Point3D(x, y, z));\n}\n```\n"
- content: Dokončili jste průzkum nových funkcí v C# 6. Teď si je můžete vyzkoušet sami ve svých aplikacích.
