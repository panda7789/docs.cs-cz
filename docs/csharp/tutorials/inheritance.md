---
title: 'Dědičnost v jazyce C #'
description: Naučte se používat dědičnost v knihovnách a aplikacích C#.
ms.date: 07/05/2018
ms.technology: csharp-fundamentals
ms.assetid: aeb68c74-0ea0-406f-9fbe-2ce02d47ef31
ms.openlocfilehash: 70db8716bea84984ad56d79fa9e26aab3a8182fa
ms.sourcegitcommit: 7476c20d2f911a834a00b8a7f5e8926bae6804d9
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 08/11/2020
ms.locfileid: "88063507"
---
# <a name="inheritance-in-c-and-net"></a><span data-ttu-id="fdcd1-103">Dědičnost v jazyce C# a technologii .NET</span><span class="sxs-lookup"><span data-stu-id="fdcd1-103">Inheritance in C# and .NET</span></span>

<span data-ttu-id="fdcd1-104">V tomto kurzu se seznámíte s děděním v jazyce C#.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-104">This tutorial introduces you to inheritance in C#.</span></span> <span data-ttu-id="fdcd1-105">Dědičnost je funkcí objektově orientovaných programovacích jazyků, které umožňují definovat základní třídu, která poskytuje konkrétní funkce (data a chování) a definovat odvozené třídy, které obě tyto funkce dědí nebo přepíší.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-105">Inheritance is a feature of object-oriented programming languages that allows you to define a base class that provides specific functionality (data and behavior) and to define derived classes that either inherit or override that functionality.</span></span>

## <a name="prerequisites"></a><span data-ttu-id="fdcd1-106">Požadavky</span><span class="sxs-lookup"><span data-stu-id="fdcd1-106">Prerequisites</span></span>

<span data-ttu-id="fdcd1-107">V tomto kurzu se předpokládá, že jste nainstalovali .NET Core SDK.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-107">This tutorial assumes that you've installed the .NET Core SDK.</span></span> <span data-ttu-id="fdcd1-108">Navštivte stránku [ke stažení pro .NET Core](https://dotnet.microsoft.com/download) , kterou si můžete stáhnout.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-108">Visit the [.NET Core Downloads](https://dotnet.microsoft.com/download) page to download it.</span></span> <span data-ttu-id="fdcd1-109">Budete také potřebovat Editor kódu.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-109">You also need a code editor.</span></span> <span data-ttu-id="fdcd1-110">V tomto kurzu se používá [Visual Studio Code](https://code.visualstudio.com), i když můžete použít libovolný editor kódu, který si vyberete.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-110">This tutorial uses [Visual Studio Code](https://code.visualstudio.com), although you can use any code editor of your choice.</span></span>

## <a name="running-the-examples"></a><span data-ttu-id="fdcd1-111">Spuštění příkladů</span><span class="sxs-lookup"><span data-stu-id="fdcd1-111">Running the examples</span></span>

<span data-ttu-id="fdcd1-112">Chcete-li vytvořit a spustit příklady v tomto kurzu, použijte nástroj [dotnet](../../core/tools/dotnet.md) z příkazového řádku.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-112">To create and run the examples in this tutorial, you use the [dotnet](../../core/tools/dotnet.md) utility from the command line.</span></span> <span data-ttu-id="fdcd1-113">Pro každý příklad použijte tento postup:</span><span class="sxs-lookup"><span data-stu-id="fdcd1-113">Follow these steps for each example:</span></span>

1. <span data-ttu-id="fdcd1-114">Vytvořte adresář, do kterého chcete příklad Uložit.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-114">Create a directory to store the example.</span></span>
1. <span data-ttu-id="fdcd1-115">Chcete-li vytvořit nový projekt .NET Core, zadejte do příkazového řádku příkaz [dotnet New Console](../../core/tools/dotnet-new.md) .</span><span class="sxs-lookup"><span data-stu-id="fdcd1-115">Enter the [dotnet new console](../../core/tools/dotnet-new.md) command at a command prompt to create a new .NET Core project.</span></span>
1. <span data-ttu-id="fdcd1-116">Zkopírujte a vložte kód z příkladu do editoru kódu.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-116">Copy and paste the code from the example into your code editor.</span></span>
1. <span data-ttu-id="fdcd1-117">Zadejte příkaz [dotnet Restore](../../core/tools/dotnet-restore.md) z příkazového řádku, aby se načetly nebo obnovily závislosti projektu.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-117">Enter the [dotnet restore](../../core/tools/dotnet-restore.md) command from the command line to load or restore the project's dependencies.</span></span>

   [!INCLUDE[DotNet Restore Note](~/includes/dotnet-restore-note.md)]

1. <span data-ttu-id="fdcd1-118">Zadejte příkaz [dotnet Run](../../core/tools/dotnet-run.md) pro zkompilování a spuštění příkladu.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-118">Enter the [dotnet run](../../core/tools/dotnet-run.md) command to compile and execute the example.</span></span>

## <a name="background-what-is-inheritance"></a><span data-ttu-id="fdcd1-119">Pozadí: co je dědičnost?</span><span class="sxs-lookup"><span data-stu-id="fdcd1-119">Background: What is inheritance?</span></span>

<span data-ttu-id="fdcd1-120">*Dědičnost* je jedním ze základních atributů objektově orientovaného programování.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-120">*Inheritance* is one of the fundamental attributes of object-oriented programming.</span></span> <span data-ttu-id="fdcd1-121">Umožňuje definovat podřízenou třídu, která znovu používá (dědí), rozšiřuje nebo upravuje chování nadřazené třídy.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-121">It allows you to define a child class that reuses (inherits), extends, or modifies the behavior of a parent class.</span></span> <span data-ttu-id="fdcd1-122">Třída, jejíž členové jsou zděděni, se nazývají *základní třídy*.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-122">The class whose members are inherited is called the *base class*.</span></span> <span data-ttu-id="fdcd1-123">Třída, která dědí členy základní třídy, se nazývá *odvozená třída*.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-123">The class that inherits the members of the base class is called the *derived class*.</span></span>

<span data-ttu-id="fdcd1-124">C# a .NET podporují jenom *jednu dědičnost* .</span><span class="sxs-lookup"><span data-stu-id="fdcd1-124">C# and .NET support *single inheritance* only.</span></span> <span data-ttu-id="fdcd1-125">To znamená, že třída může dědit pouze z jedné třídy.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-125">That is, a class can only inherit from a single class.</span></span> <span data-ttu-id="fdcd1-126">Dědičnost je však tranzitivní, což umožňuje definovat hierarchii dědičnosti pro sadu typů.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-126">However, inheritance is transitive, which allows you to define an inheritance hierarchy for a set of types.</span></span> <span data-ttu-id="fdcd1-127">Jinými slovy typ `D` může dědit z typu `C` , který dědí z typu `B` , který dědí z typu základní třídy `A` .</span><span class="sxs-lookup"><span data-stu-id="fdcd1-127">In other words, type `D` can inherit from type `C`, which inherits from type `B`, which inherits from the base class type `A`.</span></span> <span data-ttu-id="fdcd1-128">Vzhledem k tomu, že dědičnost je tranzitivní, `A` jsou členové typu k dispozici pro typ `D` .</span><span class="sxs-lookup"><span data-stu-id="fdcd1-128">Because inheritance is transitive, the members of type `A` are available to type `D`.</span></span>

<span data-ttu-id="fdcd1-129">Ne všichni členové základní třídy jsou děděni odvozenými třídami.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-129">Not all members of a base class are inherited by derived classes.</span></span> <span data-ttu-id="fdcd1-130">Následující členové nejsou děděni:</span><span class="sxs-lookup"><span data-stu-id="fdcd1-130">The following members are not inherited:</span></span>

- <span data-ttu-id="fdcd1-131">[Statické konstruktory](../programming-guide/classes-and-structs/static-constructors.md), které inicializují statická data třídy.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-131">[Static constructors](../programming-guide/classes-and-structs/static-constructors.md), which initialize the static data of a class.</span></span>

- <span data-ttu-id="fdcd1-132">[Konstruktory instancí](../programming-guide/classes-and-structs/constructors.md), které zavoláte k vytvoření nové instance třídy.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-132">[Instance constructors](../programming-guide/classes-and-structs/constructors.md), which you call to create a new instance of the class.</span></span> <span data-ttu-id="fdcd1-133">Každá třída musí definovat vlastní konstruktory.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-133">Each class must define its own constructors.</span></span>

- <span data-ttu-id="fdcd1-134">[Finalizační metody](../programming-guide/classes-and-structs/destructors.md), které jsou volány uvolňováním paměti modulu runtime pro zničení instancí třídy.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-134">[Finalizers](../programming-guide/classes-and-structs/destructors.md), which are called by the runtime's garbage collector to destroy instances of a class.</span></span>

<span data-ttu-id="fdcd1-135">Zatímco všichni ostatní členové základní třídy jsou děděni odvozenými třídami, ať už jsou viditelné, nebo nejsou závislé na jejich přístupnost.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-135">While all other members of a base class are inherited by derived classes, whether they are visible or not depends on their accessibility.</span></span> <span data-ttu-id="fdcd1-136">Přístupnost člena má vliv na jeho viditelnost pro odvozené třídy následujícím způsobem:</span><span class="sxs-lookup"><span data-stu-id="fdcd1-136">A member's accessibility affects its visibility for derived classes as follows:</span></span>

- <span data-ttu-id="fdcd1-137">[Soukromé](../language-reference/keywords/private.md) členy jsou viditelné pouze v odvozených třídách, které jsou vnořeny do jejich základní třídy.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-137">[Private](../language-reference/keywords/private.md) members are visible only in derived classes that are nested in their base class.</span></span> <span data-ttu-id="fdcd1-138">V opačném případě nejsou viditelné v odvozených třídách.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-138">Otherwise, they are not visible in derived classes.</span></span> <span data-ttu-id="fdcd1-139">V následujícím příkladu `A.B` je vnořená třída, která je odvozena z `A` a je `C` odvozena z `A` .</span><span class="sxs-lookup"><span data-stu-id="fdcd1-139">In the following example, `A.B` is a nested class that derives from `A`, and `C` derives from `A`.</span></span> <span data-ttu-id="fdcd1-140">Soukromé `A.value` pole je viditelné v A.B.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-140">The private `A.value` field is visible in A.B.</span></span> <span data-ttu-id="fdcd1-141">Pokud však odeberete komentáře z `C.GetValue` metody a pokusíte se zkompilovat příklad, vyvolá chybu kompilátoru CS0122: "' A. Value ' je z důvodu úrovně ochrany nepřístupná."</span><span class="sxs-lookup"><span data-stu-id="fdcd1-141">However, if you remove the comments from the `C.GetValue` method and attempt to compile the example, it produces compiler error CS0122: "'A.value' is inaccessible due to its protection level."</span></span>

  [!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/private.cs#1)]

- <span data-ttu-id="fdcd1-142">[Chránění](../language-reference/keywords/protected.md) členové jsou viditelné pouze v odvozených třídách.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-142">[Protected](../language-reference/keywords/protected.md) members are visible only in derived classes.</span></span>

- <span data-ttu-id="fdcd1-143">[Interní](../language-reference/keywords/internal.md) členy jsou viditelné pouze v odvozených třídách, které jsou umístěny ve stejném sestavení jako základní třída.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-143">[Internal](../language-reference/keywords/internal.md) members are visible only in derived classes that are located in the same assembly as the base class.</span></span> <span data-ttu-id="fdcd1-144">Nejsou viditelné v odvozených třídách, které jsou umístěny v jiném sestavení ze základní třídy.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-144">They are not visible in derived classes located in a different assembly from the base class.</span></span>

- <span data-ttu-id="fdcd1-145">[Veřejné](../language-reference/keywords/public.md) členy jsou viditelné v odvozených třídách a jsou součástí veřejného rozhraní odvozené třídy.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-145">[Public](../language-reference/keywords/public.md) members are visible in derived classes and are part of the derived class' public interface.</span></span> <span data-ttu-id="fdcd1-146">Veřejné zděděné členy mohou být volány stejně, jako kdyby byly definovány v odvozené třídě.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-146">Public inherited members can be called just as if they are defined in the derived class.</span></span> <span data-ttu-id="fdcd1-147">V následujícím příkladu třída `A` definuje metodu s názvem `Method1` a třídy `B` dědí z třídy `A` .</span><span class="sxs-lookup"><span data-stu-id="fdcd1-147">In the following example, class `A` defines a method named `Method1`, and class `B` inherits from class `A`.</span></span> <span data-ttu-id="fdcd1-148">Příklad pak volá `Method1` , jako by šlo o metodu instance v `B` .</span><span class="sxs-lookup"><span data-stu-id="fdcd1-148">The example then calls `Method1` as if it were an instance method on `B`.</span></span>

  [!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/basics.cs#1)]

<span data-ttu-id="fdcd1-149">Odvozené třídy mohou také *přepsat* zděděné členy poskytnutím alternativní implementace.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-149">Derived classes can also *override* inherited members by providing an alternate implementation.</span></span> <span data-ttu-id="fdcd1-150">Aby bylo možné přepsat člena, musí být člen v základní třídě označený klíčovým slovem [Virtual](../language-reference/keywords/virtual.md) .</span><span class="sxs-lookup"><span data-stu-id="fdcd1-150">In order to be able to override a member, the member in the base class must be marked with the [virtual](../language-reference/keywords/virtual.md) keyword.</span></span> <span data-ttu-id="fdcd1-151">Ve výchozím nastavení nejsou členy základní třídy označeny jako `virtual` a nelze je přepsat.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-151">By default, base class members are not marked as `virtual` and cannot be overridden.</span></span> <span data-ttu-id="fdcd1-152">Pokus o přepsání nevirtuálního člena, jak je znázorněno v následujícím příkladu, vygeneruje chybu kompilátoru CS0506: " \<member> nemůže přepsat zděděný člen, \<member> protože není označen jako virtuální, abstraktní nebo přepsání.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-152">Attempting to override a non-virtual member, as the following example does, generates compiler error CS0506: "\<member> cannot override inherited member \<member> because it is not marked virtual, abstract, or override.</span></span>

```csharp
public class A
{
    public void Method1()
    {
        // Do something.
    }
}

public class B : A
{
    public override void Method1() // Generates CS0506.
    {
        // Do something else.
    }
}
```

<span data-ttu-id="fdcd1-153">V některých případech *musí* odvozená třída přepsat implementaci základní třídy.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-153">In some cases, a derived class *must* override the base class implementation.</span></span> <span data-ttu-id="fdcd1-154">Členy základní třídy označené pomocí klíčového slova [abstract](../language-reference/keywords/abstract.md) vyžadují, aby je přepsaly odvozené třídy.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-154">Base class members marked with the [abstract](../language-reference/keywords/abstract.md) keyword require that derived classes override them.</span></span> <span data-ttu-id="fdcd1-155">Při pokusu o zkompilování následujícího příkladu dojde k chybě kompilátoru CS0534, " &lt; Třída &gt; neimplementuje zděděný abstraktní člen &lt; &gt; ", protože třída `B` neposkytuje žádnou implementaci pro `A.Method1` .</span><span class="sxs-lookup"><span data-stu-id="fdcd1-155">Attempting to compile the following example generates compiler error CS0534, "&lt;class&gt; does not implement inherited abstract member &lt;member&gt;", because class `B` provides no implementation for `A.Method1`.</span></span>

```csharp
public abstract class A
{
    public abstract void Method1();
}

public class B : A // Generates CS0534.
{
    public void Method3()
    {
        // Do something.
    }
}
```

<span data-ttu-id="fdcd1-156">Dědičnost se vztahuje pouze na třídy a rozhraní.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-156">Inheritance applies only to classes and interfaces.</span></span> <span data-ttu-id="fdcd1-157">Jiné kategorie typů (struktury, delegáti a výčty) nepodporují dědění.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-157">Other type categories (structs, delegates, and enums) do not support inheritance.</span></span> <span data-ttu-id="fdcd1-158">Z důvodu těchto pravidel se při pokusu o zkompilování kódu, jako je následující příklad, vytvoří Chyba kompilátoru CS0527: "Type ' ValueType ' v seznamu rozhraní není rozhraní."</span><span class="sxs-lookup"><span data-stu-id="fdcd1-158">Because of these rules, attempting to compile code like the following example produces compiler error CS0527: "Type 'ValueType' in interface list is not an interface."</span></span> <span data-ttu-id="fdcd1-159">Chybová zpráva označuje, že i když můžete definovat rozhraní implementující strukturou, dědičnost není podporována.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-159">The error message indicates that, although you can define the interfaces that a struct implements, inheritance is not supported.</span></span>

```csharp
using System;

public struct ValueStructure : ValueType // Generates CS0527.
{
}
```

## <a name="implicit-inheritance"></a><span data-ttu-id="fdcd1-160">Implicitní dědičnost</span><span class="sxs-lookup"><span data-stu-id="fdcd1-160">Implicit inheritance</span></span>

<span data-ttu-id="fdcd1-161">Kromě jakýchkoli typů, které mohou dědit prostřednictvím jedné dědičnosti, všechny typy v systému typů .NET implicitně dědí z <xref:System.Object> nebo z typu odvozeného z něj.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-161">Besides any types that they may inherit from through single inheritance, all types in the .NET type system implicitly inherit from <xref:System.Object> or a type derived from it.</span></span> <span data-ttu-id="fdcd1-162">Společná funkce nástroje <xref:System.Object> je k dispozici pro libovolný typ.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-162">The common functionality of <xref:System.Object> is available to any type.</span></span>

<span data-ttu-id="fdcd1-163">Chcete-li zjistit, co implicitní dědičnost znamená, definujte novou třídu, `SimpleClass` , která je jednoduše prázdnou definicí třídy:</span><span class="sxs-lookup"><span data-stu-id="fdcd1-163">To see what implicit inheritance means, let's define a new class, `SimpleClass`, that is simply an empty class definition:</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/simpleclass.cs#1)]

<span data-ttu-id="fdcd1-164">Pak můžete použít reflexi (což vám umožní zkontrolovat metadata typu a získat informace o tomto typu) a získat tak seznam členů, kteří patří do daného `SimpleClass` typu.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-164">You can then use reflection (which lets you inspect a type's metadata to get information about that type) to get a list of the members that belong to the `SimpleClass` type.</span></span> <span data-ttu-id="fdcd1-165">I když jste nedefinovali žádné členy ve `SimpleClass` třídě, výstup z příkladu označuje, že ve skutečnosti má devět členů.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-165">Although you haven't defined any members in your `SimpleClass` class, output from the example indicates that it actually has nine members.</span></span> <span data-ttu-id="fdcd1-166">Jeden z těchto členů je konstruktor bez parametrů (nebo výchozí), který je automaticky dodán pro `SimpleClass` typ kompilátorem jazyka C#.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-166">One of these members is a parameterless (or default) constructor that is automatically supplied for the `SimpleClass` type by the C# compiler.</span></span> <span data-ttu-id="fdcd1-167">Zbývajících osm jsou členové <xref:System.Object> , typ, ze kterého všechny třídy a rozhraní v systému typů .NET jsou nakonec implicitně děděny.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-167">The remaining eight are members of <xref:System.Object>, the type from which all classes and interfaces in the .NET type system ultimately implicitly inherit.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/simpleclass.cs#2)]

<span data-ttu-id="fdcd1-168">Implicitní dědění z <xref:System.Object> třídy zpřístupňuje tyto metody pro `SimpleClass` třídu:</span><span class="sxs-lookup"><span data-stu-id="fdcd1-168">Implicit inheritance from the <xref:System.Object> class makes these methods available to the `SimpleClass` class:</span></span>

- <span data-ttu-id="fdcd1-169">Veřejná `ToString` metoda, která převede `SimpleClass` objekt na jeho řetězcovou reprezentaci, vrátí plně kvalifikovaný název typu.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-169">The public `ToString` method, which converts a `SimpleClass` object to its string representation, returns the fully qualified type name.</span></span> <span data-ttu-id="fdcd1-170">V tomto případě `ToString` Metoda vrátí řetězec "SimpleClass".</span><span class="sxs-lookup"><span data-stu-id="fdcd1-170">In this case, the `ToString` method returns the string "SimpleClass".</span></span>

- <span data-ttu-id="fdcd1-171">Tři metody, které testují rovnost dvou objektů: metodu veřejné instance `Equals(Object)` , veřejnou statickou `Equals(Object, Object)` metodu a veřejnou statickou `ReferenceEquals(Object, Object)` metodu.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-171">Three methods that test for equality of two objects: the public instance `Equals(Object)` method, the public static `Equals(Object, Object)` method, and the public static `ReferenceEquals(Object, Object)` method.</span></span> <span data-ttu-id="fdcd1-172">Ve výchozím nastavení tyto metody test rovnosti referencí; To znamená, že dva objektové proměnné musí odkazovat na stejný objekt.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-172">By default, these methods test for reference equality; that is, to be equal, two object variables must refer to the same object.</span></span>

- <span data-ttu-id="fdcd1-173">Veřejná `GetHashCode` metoda, která vypočítá hodnotu, která umožňuje použití instance typu v kolekcích s algoritmem hash.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-173">The public `GetHashCode` method, which computes a value that allows an instance of the type to be used in hashed collections.</span></span>

- <span data-ttu-id="fdcd1-174">Veřejná `GetType` metoda, která vrací <xref:System.Type> objekt, který představuje `SimpleClass` typ.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-174">The public `GetType` method, which returns a <xref:System.Type> object that represents the `SimpleClass` type.</span></span>

- <span data-ttu-id="fdcd1-175">Chráněná <xref:System.Object.Finalize%2A> metoda, která je navržena pro uvolnění nespravovaných prostředků před tím, než je paměť objektu uvolněna systémem uvolňování paměti.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-175">The protected <xref:System.Object.Finalize%2A> method, which is designed to release unmanaged resources before an object's memory is reclaimed by the garbage collector.</span></span>

- <span data-ttu-id="fdcd1-176">Chráněná <xref:System.Object.MemberwiseClone%2A> metoda, která vytvoří neomezený klon aktuálního objektu.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-176">The protected <xref:System.Object.MemberwiseClone%2A> method, which creates a shallow clone of the current object.</span></span>

<span data-ttu-id="fdcd1-177">Z důvodu implicitní dědičnosti můžete volat všechny zděděné členy z `SimpleClass` objektu stejným způsobem, jako by byl ve skutečnosti člen definovaný ve `SimpleClass` třídě.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-177">Because of implicit inheritance, you can call any inherited member from a `SimpleClass` object just as if it was actually a member defined in the `SimpleClass` class.</span></span> <span data-ttu-id="fdcd1-178">Například následující příklad volá `SimpleClass.ToString` metodu, která `SimpleClass` dědí z <xref:System.Object> .</span><span class="sxs-lookup"><span data-stu-id="fdcd1-178">For instance, the following example calls the `SimpleClass.ToString` method, which `SimpleClass` inherits from <xref:System.Object>.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/simpleclass2.cs#1)]

<span data-ttu-id="fdcd1-179">V následující tabulce jsou uvedeny kategorie typů, které lze vytvořit v jazyce C#, a typy, ze kterých jsou implicitně děděny.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-179">The following table lists the categories of types that you can create in C# and the types from which they implicitly inherit.</span></span> <span data-ttu-id="fdcd1-180">Každý základní typ zpřístupňuje jinou sadu členů prostřednictvím dědičnosti implicitně odvozeným typům.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-180">Each base type makes a different set of members available through inheritance to implicitly derived types.</span></span>

| <span data-ttu-id="fdcd1-181">Kategorie typu</span><span class="sxs-lookup"><span data-stu-id="fdcd1-181">Type category</span></span> | <span data-ttu-id="fdcd1-182">Implicitně dědí z</span><span class="sxs-lookup"><span data-stu-id="fdcd1-182">Implicitly inherits from</span></span>                                                      |
| ------------- | ----------------------------------------------------------------------------- |
| <span data-ttu-id="fdcd1-183">třída</span><span class="sxs-lookup"><span data-stu-id="fdcd1-183">class</span></span>         | <xref:System.Object>                                                          |
| <span data-ttu-id="fdcd1-184">struct</span><span class="sxs-lookup"><span data-stu-id="fdcd1-184">struct</span></span>        | <span data-ttu-id="fdcd1-185"><xref:System.ValueType>, <xref:System.Object></span><span class="sxs-lookup"><span data-stu-id="fdcd1-185"><xref:System.ValueType>, <xref:System.Object></span></span>                                 |
| <span data-ttu-id="fdcd1-186">enum</span><span class="sxs-lookup"><span data-stu-id="fdcd1-186">enum</span></span>          | <span data-ttu-id="fdcd1-187"><xref:System.Enum>, <xref:System.ValueType>, <xref:System.Object></span><span class="sxs-lookup"><span data-stu-id="fdcd1-187"><xref:System.Enum>, <xref:System.ValueType>, <xref:System.Object></span></span>             |
| <span data-ttu-id="fdcd1-188">delegát</span><span class="sxs-lookup"><span data-stu-id="fdcd1-188">delegate</span></span>      | <span data-ttu-id="fdcd1-189"><xref:System.MulticastDelegate>, <xref:System.Delegate>, <xref:System.Object></span><span class="sxs-lookup"><span data-stu-id="fdcd1-189"><xref:System.MulticastDelegate>, <xref:System.Delegate>, <xref:System.Object></span></span> |

## <a name="inheritance-and-an-is-a-relationship"></a><span data-ttu-id="fdcd1-190">Dědičnost a "je" relace</span><span class="sxs-lookup"><span data-stu-id="fdcd1-190">Inheritance and an "is a" relationship</span></span>

<span data-ttu-id="fdcd1-191">Obvykle se dědičnost používá k vyjádření vztahu "je" vztah mezi základní třídou a jednou nebo více odvozenými třídami, kde jsou odvozenými třídami specializované verze základní třídy; odvozená třída je typem základní třídy.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-191">Ordinarily, inheritance is used to express an "is a" relationship between a base class and one or more derived classes, where the derived classes are specialized versions of the base class; the derived class is a type of the base class.</span></span> <span data-ttu-id="fdcd1-192">Například `Publication` Třída představuje publikaci libovolného druhu a `Book` `Magazine` třídy a představují konkrétní typy publikací.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-192">For example, the `Publication` class represents a publication of any kind, and the `Book` and `Magazine` classes represent specific types of publications.</span></span>

> [!NOTE]
> <span data-ttu-id="fdcd1-193">Třída nebo struktura může implementovat jedno nebo více rozhraní.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-193">A class or struct can implement one or more interfaces.</span></span> <span data-ttu-id="fdcd1-194">I když je implementace rozhraní často prezentována jako alternativní řešení pro jednoduchou dědičnost nebo jako způsob použití dědičnosti s strukturami, má vyjadřovat jiný vztah ("může provádět" vztah) mezi rozhraním a jeho implementací typu než dědění.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-194">While interface implementation is often presented as a workaround for single inheritance or as a way of using inheritance with structs, it is intended to express a different relationship (a "can do" relationship) between an interface and its implementing type than inheritance.</span></span> <span data-ttu-id="fdcd1-195">Rozhraní definuje podmnožinu funkcí (například možnost testování rovnosti, pro porovnání nebo řazení objektů nebo pro podporu analýzy a formátování zohledňující jazykovou verzi), že rozhraní zpřístupňuje své implementující typy.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-195">An interface defines a subset of functionality (such as the ability to test for equality, to compare or sort objects, or to support culture-sensitive parsing and formatting) that the interface makes available to its implementing types.</span></span>

<span data-ttu-id="fdcd1-196">Všimněte si, že "je" také vyjadřuje vztah mezi typem a specifickou instancí tohoto typu.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-196">Note that "is a" also expresses the relationship between a type and a specific instantiation of that type.</span></span> <span data-ttu-id="fdcd1-197">V následujícím příkladu `Automobile` je třída, která má tři jedinečné vlastnosti jen pro čtení: `Make` , výrobce automobilu `Model` , druh automobilu a `Year` rok výroby.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-197">In the following example, `Automobile` is a class that has three unique read-only properties: `Make`, the manufacturer of the automobile; `Model`, the kind of automobile; and `Year`, its year of manufacture.</span></span> <span data-ttu-id="fdcd1-198">Vaše `Automobile` Třída má také konstruktor, jehož argumenty jsou přiřazeny hodnotám vlastností a Přepisuje <xref:System.Object.ToString%2A?displayProperty=nameWithType> metodu pro vytvoření řetězce, který jedinečně identifikuje `Automobile` instanci namísto `Automobile` třídy.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-198">Your `Automobile` class also has a constructor whose arguments are assigned to the property values, and it overrides the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method to produce a string that uniquely identifies the `Automobile` instance rather than the `Automobile` class.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/is-a.cs#1)]

<span data-ttu-id="fdcd1-199">V takovém případě byste neměli spoléhat na dědění, která představuje konkrétní automobilové a modely.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-199">In this case, you shouldn't rely on inheritance to represent specific car makes and models.</span></span> <span data-ttu-id="fdcd1-200">Například nemusíte definovat `Packard` typ pro reprezentaci Automobiles vyráběných společností společnosti Packard motorových automobilů.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-200">For example, you don't need to define a `Packard` type to represent automobiles manufactured by the Packard Motor Car Company.</span></span> <span data-ttu-id="fdcd1-201">Místo toho je lze reprezentovat vytvořením `Automobile` objektu s příslušnými hodnotami předaných konstruktoru třídy, jak je uvedeno v následujícím příkladu.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-201">Instead, you can represent them by creating an `Automobile` object with the appropriate values passed to its class constructor, as the following example does.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/is-a.cs#2)]

<span data-ttu-id="fdcd1-202">Je relace založená na dědičnosti nejvhodnější pro základní třídu a na odvozené třídy, které přidávají další členy do základní třídy nebo které vyžadují další funkce, které nejsou k dispozici v základní třídě.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-202">An is-a relationship based on inheritance is best applied to a base class and to derived classes that add additional members to the base class or that require additional functionality not present in the base class.</span></span>

## <a name="designing-the-base-class-and-derived-classes"></a><span data-ttu-id="fdcd1-203">Návrh základní třídy a odvozených tříd</span><span class="sxs-lookup"><span data-stu-id="fdcd1-203">Designing the base class and derived classes</span></span>

<span data-ttu-id="fdcd1-204">Pojďme se podívat na postup navrhování základní třídy a jejích odvozených tříd.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-204">Let's look at the process of designing a base class and its derived classes.</span></span> <span data-ttu-id="fdcd1-205">V této části definujete základní třídu, `Publication` která představuje publikaci libovolného druhu, jako je kniha, časopis, novinka, deník, článek atd. Také definujete `Book` třídu, která je odvozena z `Publication` .</span><span class="sxs-lookup"><span data-stu-id="fdcd1-205">In this section, you'll define a base class, `Publication`, which represents a publication of any kind, such as a book, a magazine, a newspaper, a journal, an article, etc. You'll also define a `Book` class that derives from `Publication`.</span></span> <span data-ttu-id="fdcd1-206">Můžete snadno zvětšit příklad pro definování dalších odvozených tříd, například `Magazine` , `Journal` , `Newspaper` a `Article` .</span><span class="sxs-lookup"><span data-stu-id="fdcd1-206">You could easily extend the example to define other derived classes, such as `Magazine`, `Journal`, `Newspaper`, and `Article`.</span></span>

### <a name="the-base-publication-class"></a><span data-ttu-id="fdcd1-207">Základní třída publikace</span><span class="sxs-lookup"><span data-stu-id="fdcd1-207">The base Publication class</span></span>

<span data-ttu-id="fdcd1-208">Při navrhování vaší `Publication` třídy je potřeba provést několik rozhodnutí o návrhu:</span><span class="sxs-lookup"><span data-stu-id="fdcd1-208">In designing your `Publication` class, you need to make several design decisions:</span></span>

- <span data-ttu-id="fdcd1-209">Jaké členy mají být zahrnuty do základní `Publication` třídy a zda `Publication` členy poskytují implementace metod nebo zda `Publication` je abstraktní základní třída, která slouží jako šablona pro odvozené třídy.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-209">What members to include in your base `Publication` class, and whether the `Publication` members provide method implementations or whether `Publication` is an abstract base class that serves as a template for its derived classes.</span></span>

  <span data-ttu-id="fdcd1-210">V tomto případě `Publication` Třída nabídne implementace metod.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-210">In this case, the `Publication` class will provide method implementations.</span></span> <span data-ttu-id="fdcd1-211">Oddíl [navrhování abstraktních základních tříd a jejich odvozené třídy](#abstract) obsahuje příklad, který používá abstraktní základní třídu k definování metod, které musí přepsat odvozené třídy.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-211">The [Designing abstract base classes and their derived classes](#abstract) section contains an example that uses an abstract base class to define the methods that derived classes must override.</span></span> <span data-ttu-id="fdcd1-212">Odvozené třídy jsou bezplatné k poskytnutí libovolné implementace, která je vhodná pro odvozený typ.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-212">Derived classes are free to provide any implementation that is suitable for the derived type.</span></span>

  <span data-ttu-id="fdcd1-213">Možnost opětovného použití kódu (to znamená, že více odvozených tříd sdílí deklaraci a implementaci metod základní třídy a není nutné je přepsat) je výhodou neabstraktních základních tříd.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-213">The ability to reuse code (that is, multiple derived classes share the declaration and implementation of base class methods and do not need to override them) is an advantage of non-abstract base classes.</span></span> <span data-ttu-id="fdcd1-214">Proto byste měli přidat členy do, `Publication` Pokud je jejich kód pravděpodobně sdílen některými nebo nejvíce specializovanými `Publication` typy.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-214">Therefore, you should add members to `Publication` if their code is likely to be shared by some or most specialized `Publication` types.</span></span> <span data-ttu-id="fdcd1-215">Pokud nebudete moci efektivně poskytovat implementace základní třídy, bude nutné, abyste v odvozených třídách poskytovali v podstatě identické implementace členů, nikoli na jednu implementaci v základní třídě.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-215">If you fail to provide base class implementations efficiently, you'll end up having to provide largely identical member implementations in derived classes rather a single implementation in the base class.</span></span> <span data-ttu-id="fdcd1-216">Nutnost udržovat duplicitní kód ve více umístěních je potenciální zdrojem chyb.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-216">The need to maintain duplicated code in multiple locations is a potential source of bugs.</span></span>

  <span data-ttu-id="fdcd1-217">Jak maximalizovat opětovné použití kódu a vytvořit logickou a intuitivní hierarchii dědičnosti, chcete mít jistotu, že zahrnete do `Publication` třídy pouze data a funkce, které jsou společné pro všechny nebo pro většinu publikací.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-217">Both to maximize code reuse and to create a logical and intuitive inheritance hierarchy, you want to be sure that you include in the `Publication` class only the data and functionality that is common to all or to most publications.</span></span> <span data-ttu-id="fdcd1-218">Odvozené třídy potom implementují členy, které jsou jedinečné pro konkrétní druhy publikace, které představují.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-218">Derived classes then implement members that are unique to the particular kinds of publication that they represent.</span></span>

- <span data-ttu-id="fdcd1-219">Jak daleko se rozšířila vaše hierarchie tříd.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-219">How far to extend your class hierarchy.</span></span> <span data-ttu-id="fdcd1-220">Chcete vytvořit hierarchii tří nebo více tříd, nikoli jednoduše základní třídu a jednu nebo více odvozených tříd?</span><span class="sxs-lookup"><span data-stu-id="fdcd1-220">Do you want to develop a hierarchy of three or more classes, rather than simply a base class and one or more derived classes?</span></span> <span data-ttu-id="fdcd1-221">Například `Publication` může být základní třída `Periodical` , která je zase základní třídou třídy `Magazine` , `Journal` a `Newspaper` .</span><span class="sxs-lookup"><span data-stu-id="fdcd1-221">For example, `Publication` could be a base class of `Periodical`, which in turn is a base class of `Magazine`, `Journal` and `Newspaper`.</span></span>

  <span data-ttu-id="fdcd1-222">Pro váš příklad budete používat malou hierarchii `Publication` třídy a jednu odvozenou třídu `Book` .</span><span class="sxs-lookup"><span data-stu-id="fdcd1-222">For your example, you'll use the small hierarchy of a `Publication` class and a single derived class, `Book`.</span></span> <span data-ttu-id="fdcd1-223">Příklad lze snadno zvětšit a vytvořit tak mnoho dalších tříd, které jsou odvozeny z `Publication` , například `Magazine` a `Article` .</span><span class="sxs-lookup"><span data-stu-id="fdcd1-223">You could easily extend the example to create a number of additional classes that derive from `Publication`, such as `Magazine` and `Article`.</span></span>

- <span data-ttu-id="fdcd1-224">Zda má smysl vytvořit instanci základní třídy.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-224">Whether it makes sense to instantiate the base class.</span></span> <span data-ttu-id="fdcd1-225">Pokud tomu tak není, měli byste použít klíčové slovo [abstract](../language-reference/keywords/abstract.md) pro třídu.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-225">If it does not, you should apply the [abstract](../language-reference/keywords/abstract.md) keyword to the class.</span></span> <span data-ttu-id="fdcd1-226">V opačném případě `Publication` může být vytvořena instance třídy voláním svého konstruktoru třídy.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-226">Otherwise, your `Publication` class can be instantiated by calling its class constructor.</span></span> <span data-ttu-id="fdcd1-227">Pokud se provede pokus o vytvoření instance třídy označené `abstract` klíčovým slovem přímým voláním konstruktoru třídy, kompilátor C# vygeneruje chybu CS0144, "nemůže vytvořit instanci abstraktní třídy nebo rozhraní."</span><span class="sxs-lookup"><span data-stu-id="fdcd1-227">If an attempt is made to instantiate a class marked with the `abstract` keyword by a direct call to its class constructor, the C# compiler generates error CS0144, "Cannot create an instance of the abstract class or interface."</span></span> <span data-ttu-id="fdcd1-228">Pokud je proveden pokus o vytvoření instance třídy pomocí reflexe, metoda Reflection vyvolá <xref:System.MemberAccessException> .</span><span class="sxs-lookup"><span data-stu-id="fdcd1-228">If an attempt is made to instantiate the class by using reflection, the reflection method throws a <xref:System.MemberAccessException>.</span></span>

  <span data-ttu-id="fdcd1-229">Ve výchozím nastavení lze vytvořit instanci základní třídy voláním svého konstruktoru třídy.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-229">By default, a base class can be instantiated by calling its class constructor.</span></span> <span data-ttu-id="fdcd1-230">Nemusíte explicitně definovat konstruktor třídy.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-230">You do not have to explicitly define a class constructor.</span></span> <span data-ttu-id="fdcd1-231">Pokud není k dispozici ve zdrojovém kódu základní třídy, kompilátor jazyka C# automaticky poskytuje výchozí konstruktor (bez parametrů).</span><span class="sxs-lookup"><span data-stu-id="fdcd1-231">If one is not present in the base class' source code, the C# compiler automatically provides a default (parameterless) constructor.</span></span>

  <span data-ttu-id="fdcd1-232">Jako příklad označíte `Publication` třídu jako [abstraktní](../language-reference/keywords/abstract.md) , aby se nedá vytvořit instance.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-232">For your example, you'll mark the `Publication` class as [abstract](../language-reference/keywords/abstract.md) so that it cannot be instantiated.</span></span>  <span data-ttu-id="fdcd1-233">`abstract`Třída bez `abstract` metod označuje, že tato třída představuje abstraktní koncept, který je sdílen mezi několika konkrétními třídami (například `Book` , `Journal` ).</span><span class="sxs-lookup"><span data-stu-id="fdcd1-233">An `abstract` class without any `abstract` methods indicates that this class represents an abstract concept that is shared among several concrete classes (like a `Book`, `Journal`).</span></span>

- <span data-ttu-id="fdcd1-234">Zda odvozené třídy musí dědit implementaci základní třídy konkrétních členů, zda mají možnost přepsat implementaci základní třídy nebo zda musí poskytovat implementaci.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-234">Whether derived classes must inherit the base class implementation of particular members, whether they have the option to override the base class implementation, or whether they must provide an implementation.</span></span> <span data-ttu-id="fdcd1-235">Pomocí klíčového slova [abstract](../language-reference/keywords/abstract.md) vynutíte odvozené třídy pro zajištění implementace.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-235">You use the [abstract](../language-reference/keywords/abstract.md) keyword to force derived classes to provide an implementation.</span></span> <span data-ttu-id="fdcd1-236">Použijete klíčové slovo [Virtual](../language-reference/keywords/virtual.md) k povolení odvozených tříd pro přepsání metody základní třídy.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-236">You use the [virtual](../language-reference/keywords/virtual.md) keyword to allow derived classes to override a base class method.</span></span> <span data-ttu-id="fdcd1-237">Ve výchozím nastavení nejsou metody definované v základní *třídě přepsatelné* .</span><span class="sxs-lookup"><span data-stu-id="fdcd1-237">By default, methods defined in the base class are *not* overridable.</span></span>

  <span data-ttu-id="fdcd1-238">`Publication`Třída nemá žádné `abstract` metody, ale samotná třída je `abstract` .</span><span class="sxs-lookup"><span data-stu-id="fdcd1-238">The `Publication` class does not have any `abstract` methods, but the class itself is `abstract`.</span></span>

- <span data-ttu-id="fdcd1-239">Zda odvozená třída představuje konečnou třídu v hierarchii dědičnosti a nemůže být použita jako základní třída pro další odvozené třídy.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-239">Whether a derived class represents the final class in the inheritance hierarchy and cannot itself be used as a base class for additional derived classes.</span></span> <span data-ttu-id="fdcd1-240">Ve výchozím nastavení může kterákoli třída sloužit jako základní třída.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-240">By default, any class can serve as a base class.</span></span> <span data-ttu-id="fdcd1-241">Můžete použít [zapečetěné](../language-reference/keywords/sealed.md) klíčové slovo k označení, že třída nemůže sloužit jako základní třída pro žádné další třídy.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-241">You can apply the [sealed](../language-reference/keywords/sealed.md) keyword to indicate that a class cannot serve as a base class for any additional classes.</span></span> <span data-ttu-id="fdcd1-242">Došlo k pokusu o odvození z zapečetěné třídy s chybou kompilátoru CS0509, "nemůže odvozovat z zapečetěného typu \<typeName> ".</span><span class="sxs-lookup"><span data-stu-id="fdcd1-242">Attempting to derive from a sealed class generated compiler error CS0509, "cannot derive from sealed type \<typeName>".</span></span>

  <span data-ttu-id="fdcd1-243">Jako příklad označíte svou odvozenou třídu jako `sealed` .</span><span class="sxs-lookup"><span data-stu-id="fdcd1-243">For your example, you'll mark your derived class as `sealed`.</span></span>

<span data-ttu-id="fdcd1-244">Následující příklad ukazuje zdrojový kód pro `Publication` třídu a také `PublicationType` výčet, který je vrácen `Publication.PublicationType` vlastností.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-244">The following example shows the source code for the `Publication` class, as well as a `PublicationType` enumeration that is returned by the `Publication.PublicationType` property.</span></span> <span data-ttu-id="fdcd1-245">Kromě členů, které dědí z <xref:System.Object> , `Publication` Třída definuje následující jedinečné členy a přepsání členů:</span><span class="sxs-lookup"><span data-stu-id="fdcd1-245">In addition to the members that it inherits from <xref:System.Object>, the `Publication` class defines the following unique members and member overrides:</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/base-and-derived.cs#1)]

- <span data-ttu-id="fdcd1-246">Konstruktor</span><span class="sxs-lookup"><span data-stu-id="fdcd1-246">A constructor</span></span>

  <span data-ttu-id="fdcd1-247">Vzhledem k tomu `Publication` , že třída je `abstract` , nemůže být vytvořena instance přímo z kódu, jako v následujícím příkladu:</span><span class="sxs-lookup"><span data-stu-id="fdcd1-247">Because the `Publication` class is `abstract`, it cannot be instantiated directly from code like the following example:</span></span>

  ```csharp
  var publication = new Publication("Tiddlywinks for Experts", "Fun and Games",
                                    PublicationType.Book);
  ```

  <span data-ttu-id="fdcd1-248">Nicméně jeho konstruktor instance lze volat přímo z konstruktorů odvozené třídy, jak ukazuje zdrojový kód `Book` třídy.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-248">However, its instance constructor can be called directly from derived class constructors, as the source code for the `Book` class shows.</span></span>

- <span data-ttu-id="fdcd1-249">Dvě vlastnosti týkající se publikace</span><span class="sxs-lookup"><span data-stu-id="fdcd1-249">Two publication-related properties</span></span>

  <span data-ttu-id="fdcd1-250">`Title`je vlastnost jen pro čtení <xref:System.String> , jejíž hodnota je dodána voláním `Publication` konstruktoru.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-250">`Title` is a read-only <xref:System.String> property whose value is supplied by calling the `Publication` constructor.</span></span>

  <span data-ttu-id="fdcd1-251">`Pages`je vlastnost pro čtení a zápis <xref:System.Int32> , která určuje, kolik celkových stránek publikace má.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-251">`Pages` is a read-write <xref:System.Int32> property that indicates how many total pages the publication has.</span></span> <span data-ttu-id="fdcd1-252">Hodnota je uložena v soukromém poli s názvem `totalPages` .</span><span class="sxs-lookup"><span data-stu-id="fdcd1-252">The value is stored in a private field named `totalPages`.</span></span> <span data-ttu-id="fdcd1-253">Musí se jednat o kladné číslo nebo <xref:System.ArgumentOutOfRangeException> je vyvolána výjimka.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-253">It must be a positive number or an <xref:System.ArgumentOutOfRangeException> is thrown.</span></span>

- <span data-ttu-id="fdcd1-254">Členové související s vydavatelem</span><span class="sxs-lookup"><span data-stu-id="fdcd1-254">Publisher-related members</span></span>

  <span data-ttu-id="fdcd1-255">Dvě vlastnosti jen pro čtení `Publisher` a `Type` .</span><span class="sxs-lookup"><span data-stu-id="fdcd1-255">Two read-only properties, `Publisher` and `Type`.</span></span> <span data-ttu-id="fdcd1-256">Hodnoty jsou původně poskytnuty voláním `Publication` konstruktoru třídy.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-256">The values are originally supplied by the call to the `Publication` class constructor.</span></span>

- <span data-ttu-id="fdcd1-257">Členové související s publikováním</span><span class="sxs-lookup"><span data-stu-id="fdcd1-257">Publishing-related members</span></span>

  <span data-ttu-id="fdcd1-258">Dvě metody `Publish` a `GetPublicationDate` nastavte a vraťte datum publikování.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-258">Two methods, `Publish` and `GetPublicationDate`, set and return the publication date.</span></span> <span data-ttu-id="fdcd1-259">`Publish`Metoda nastaví `published` příznak Private na `true` hodnotu při volání a přiřadí k němu datum předané jako argument privátního `datePublished` pole.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-259">The `Publish` method sets a private  `published` flag to `true` when it is called and assigns the date passed to it as an argument to the private `datePublished` field.</span></span> <span data-ttu-id="fdcd1-260">`GetPublicationDate`Metoda vrátí řetězec "NYP", pokud je `published` příznak `false` , a hodnotu `datePublished` pole, pokud je `true` .</span><span class="sxs-lookup"><span data-stu-id="fdcd1-260">The `GetPublicationDate` method returns the string "NYP" if the `published` flag is `false`, and the value of the `datePublished` field if it is `true`.</span></span>

- <span data-ttu-id="fdcd1-261">Členové související s copyrightem</span><span class="sxs-lookup"><span data-stu-id="fdcd1-261">Copyright-related members</span></span>

  <span data-ttu-id="fdcd1-262">`Copyright`Metoda vezme jméno vlastníka autorského práva a rok autorského práva jako argumenty a přiřadí je k `CopyrightName` `CopyrightDate` vlastnostem a.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-262">The `Copyright` method takes the name of the copyright holder and the year of the copyright as arguments and assigns them to the `CopyrightName` and `CopyrightDate` properties.</span></span>

- <span data-ttu-id="fdcd1-263">Přepsání `ToString` metody</span><span class="sxs-lookup"><span data-stu-id="fdcd1-263">An override of the `ToString` method</span></span>

  <span data-ttu-id="fdcd1-264">Pokud typ nepřepisuje <xref:System.Object.ToString%2A?displayProperty=nameWithType> metodu, vrátí plně kvalifikovaný název typu, který je malý použití při odlišení jedné instance od druhé.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-264">If a type does not override the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method, it returns the fully qualified name of the type, which is of little use in differentiating one instance from another.</span></span> <span data-ttu-id="fdcd1-265">`Publication`Třída Přepisuje, <xref:System.Object.ToString%2A?displayProperty=nameWithType> aby vracela hodnotu `Title` Vlastnosti.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-265">The `Publication` class overrides <xref:System.Object.ToString%2A?displayProperty=nameWithType> to return the value of the `Title` property.</span></span>

<span data-ttu-id="fdcd1-266">Následující obrázek znázorňuje vztah mezi základní `Publication` třídou a implicitně zděděnou <xref:System.Object> třídou.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-266">The following figure illustrates the relationship between your base `Publication` class and its implicitly inherited <xref:System.Object> class.</span></span>

![Třídy objektu a publikace](media/publication-class.jpg)

### <a name="the-book-class"></a><span data-ttu-id="fdcd1-268">`Book`Třída</span><span class="sxs-lookup"><span data-stu-id="fdcd1-268">The `Book` class</span></span>

<span data-ttu-id="fdcd1-269">`Book`Třída představuje knihu jako specializovaný typ publikace.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-269">The `Book` class represents a book as a specialized type of publication.</span></span> <span data-ttu-id="fdcd1-270">Následující příklad ukazuje zdrojový kód pro `Book` třídu.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-270">The following example shows the source code for the `Book` class.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/base-and-derived.cs#2)]

<span data-ttu-id="fdcd1-271">Kromě členů, které dědí z `Publication` , `Book` Třída definuje následující jedinečné členy a přepsání členů:</span><span class="sxs-lookup"><span data-stu-id="fdcd1-271">In addition to the members that it inherits from `Publication`, the `Book` class defines the following unique members and member overrides:</span></span>

- <span data-ttu-id="fdcd1-272">Dva konstruktory</span><span class="sxs-lookup"><span data-stu-id="fdcd1-272">Two constructors</span></span>

  <span data-ttu-id="fdcd1-273">Dva `Book` konstruktory sdílejí tři společné parametry.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-273">The two `Book` constructors share three common parameters.</span></span> <span data-ttu-id="fdcd1-274">Dva, *název* a *Vydavatel*odpovídají parametrům `Publication` konstruktoru.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-274">Two, *title* and *publisher*, correspond to parameters of the `Publication` constructor.</span></span> <span data-ttu-id="fdcd1-275">Třetí je *Autor*, který je uložený do veřejné neměnné `Author` Vlastnosti.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-275">The third is *author*, which is stored to a public immutable `Author` property.</span></span> <span data-ttu-id="fdcd1-276">Jeden konstruktor obsahuje parametr *ISBN* , který je uložený v `ISBN` Automatické vlastnosti.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-276">One constructor includes an *isbn* parameter, which is stored in the `ISBN` auto-property.</span></span>

  <span data-ttu-id="fdcd1-277">První konstruktor používá klíčové slovo [This](../language-reference/keywords/this.md) k volání druhého konstruktoru.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-277">The first constructor uses the [this](../language-reference/keywords/this.md) keyword to call the other constructor.</span></span> <span data-ttu-id="fdcd1-278">Řetězení konstruktorů je běžným vzorem v definování konstruktorů.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-278">Constructor chaining is a common pattern in defining constructors.</span></span> <span data-ttu-id="fdcd1-279">Konstruktory s menšími parametry poskytují výchozí hodnoty při volání konstruktoru s největším počtem parametrů.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-279">Constructors with fewer parameters provide default values when calling the constructor with the greatest number of parameters.</span></span>

  <span data-ttu-id="fdcd1-280">Druhý konstruktor používá klíčové slovo [Base](../language-reference/keywords/base.md) k předání názvu a názvu vydavatele konstruktoru základní třídy.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-280">The second constructor uses the [base](../language-reference/keywords/base.md) keyword to pass the title and publisher name to the base class constructor.</span></span> <span data-ttu-id="fdcd1-281">Pokud neprovedete explicitní volání konstruktoru základní třídy ve zdrojovém kódu, kompilátor jazyka C# automaticky dodá volání výchozího nebo bezparametrů konstruktoru základní třídy.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-281">If you don't make an explicit call to a base class constructor in your source code, the C# compiler automatically supplies a call to the base class' default or parameterless constructor.</span></span>

- <span data-ttu-id="fdcd1-282">Vlastnost jen pro čtení `ISBN` , která vrací `Book` číslo mezinárodní knihy standardního standardního objektu, jedinečné číslo na 10 nebo 13 číslic.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-282">A read-only `ISBN` property, which returns the `Book` object's International Standard Book Number, a unique 10- or 13-digit number.</span></span> <span data-ttu-id="fdcd1-283">ISBN je zadáno jako argument pro jeden z `Book` konstruktorů.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-283">The ISBN is supplied as an argument to one of the `Book` constructors.</span></span> <span data-ttu-id="fdcd1-284">ISBN je uložen v soukromém zálohovacím poli, které je automaticky generováno kompilátorem.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-284">The ISBN is stored in a private backing field, which is auto-generated by the compiler.</span></span>

- <span data-ttu-id="fdcd1-285">Vlastnost jen pro čtení `Author` .</span><span class="sxs-lookup"><span data-stu-id="fdcd1-285">A read-only `Author` property.</span></span> <span data-ttu-id="fdcd1-286">Jméno autora je zadáno jako argument pro oba `Book` konstruktory a je uloženo ve vlastnosti.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-286">The author name is supplied as an argument to both `Book` constructors and is stored in the property.</span></span>

- <span data-ttu-id="fdcd1-287">Dvě vlastnosti týkající se cen jen pro čtení `Price` a `Currency` .</span><span class="sxs-lookup"><span data-stu-id="fdcd1-287">Two read-only price-related properties, `Price` and `Currency`.</span></span> <span data-ttu-id="fdcd1-288">Jejich hodnoty jsou zadány jako argumenty ve `SetPrice` volání metody.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-288">Their values are provided as arguments in a `SetPrice` method call.</span></span> <span data-ttu-id="fdcd1-289">`Currency`Vlastnost je třímístný symbol měny ISO (například USD za americký dolar).</span><span class="sxs-lookup"><span data-stu-id="fdcd1-289">The `Currency` property is the three-digit ISO currency symbol (for example, USD for the U.S. dollar).</span></span> <span data-ttu-id="fdcd1-290">Z vlastnosti lze načíst symboly ISO měny <xref:System.Globalization.RegionInfo.ISOCurrencySymbol%2A> .</span><span class="sxs-lookup"><span data-stu-id="fdcd1-290">ISO currency symbols can be retrieved from the <xref:System.Globalization.RegionInfo.ISOCurrencySymbol%2A> property.</span></span> <span data-ttu-id="fdcd1-291">Obě tyto vlastnosti jsou externě jen pro čtení, ale obě lze nastavit pomocí kódu ve `Book` třídě.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-291">Both of these properties are externally read-only, but both can be set by code in the `Book` class.</span></span>

- <span data-ttu-id="fdcd1-292">`SetPrice`Metoda, která nastavuje hodnoty `Price` `Currency` vlastností a.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-292">A `SetPrice` method, which sets the values of the `Price` and `Currency` properties.</span></span> <span data-ttu-id="fdcd1-293">Tyto hodnoty jsou vraceny pomocí stejných vlastností.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-293">Those values are returned by those same properties.</span></span>

- <span data-ttu-id="fdcd1-294">Přepíše `ToString` metodu (zděděnou z `Publication` ) a <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> <xref:System.Object.GetHashCode%2A> metody a (zděděné z <xref:System.Object> ).</span><span class="sxs-lookup"><span data-stu-id="fdcd1-294">Overrides to the `ToString` method (inherited from `Publication`) and the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> and <xref:System.Object.GetHashCode%2A> methods (inherited from <xref:System.Object>).</span></span>

  <span data-ttu-id="fdcd1-295">Pokud není přepsán, <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> metoda Testuje referenční rovnost.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-295">Unless it is overridden, the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method tests for reference equality.</span></span> <span data-ttu-id="fdcd1-296">To znamená, že dvě proměnné objektu jsou považovány za stejné, pokud odkazují na stejný objekt.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-296">That is, two object variables are considered to be equal if they refer to the same object.</span></span> <span data-ttu-id="fdcd1-297">Ve `Book` třídě na druhé straně `Book` by měly být dva objekty stejné, pokud mají stejné ISBN.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-297">In the `Book` class, on the other hand, two `Book` objects should be equal if they have the same ISBN.</span></span>

  <span data-ttu-id="fdcd1-298">Při přepsání metody je <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> nutné také přepsat <xref:System.Object.GetHashCode%2A> metodu, která vrací hodnotu, kterou modul runtime používá k ukládání položek v kolekcích s algoritmem hash pro efektivní načtení.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-298">When you override the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method, you must also override the <xref:System.Object.GetHashCode%2A> method, which returns a value that the runtime uses to store items in hashed collections for efficient retrieval.</span></span> <span data-ttu-id="fdcd1-299">Kód hash by měl vracet hodnotu, která je konzistentní s testem pro rovnost.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-299">The hash code should return a value that's consistent with the test for equality.</span></span> <span data-ttu-id="fdcd1-300">Vzhledem k tomu, že jste přepsali <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> `true` , že pokud jsou vlastnosti ISBN dvou `Book` objektů stejné, vrátíte kód hash vypočítaný voláním <xref:System.String.GetHashCode%2A> metody řetězce vráceného `ISBN` vlastností.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-300">Since you've overridden <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> to return `true` if the ISBN properties of two `Book` objects are equal, you return the hash code computed by calling the <xref:System.String.GetHashCode%2A> method of the string returned by the `ISBN` property.</span></span>

<span data-ttu-id="fdcd1-301">Následující obrázek znázorňuje vztah mezi `Book` třídou a `Publication` , její základní třídou.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-301">The following figure illustrates the relationship between the `Book` class and `Publication`, its base class.</span></span>

![Třídy publikace a knihy](media/book-class.jpg)

<span data-ttu-id="fdcd1-303">Nyní můžete vytvořit instanci `Book` objektu, vyvolat jeho jedinečné i zděděné členy a předat jej jako argument metodě, která očekává parametr typu `Publication` nebo typu `Book` , jak ukazuje následující příklad.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-303">You can now instantiate a `Book` object, invoke both its unique and inherited members, and pass it as an argument to a method that expects a parameter of type `Publication` or of type `Book`, as the following example shows.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/use-publication.cs#1)]

## <a name="designing-abstract-base-classes-and-their-derived-classes"></a><span data-ttu-id="fdcd1-304">Navrhování abstraktních základních tříd a jejich odvozených tříd</span><span class="sxs-lookup"><span data-stu-id="fdcd1-304">Designing abstract base classes and their derived classes</span></span>
<a name="abstract"></a>

<span data-ttu-id="fdcd1-305">V předchozím příkladu jste definovali základní třídu, která poskytuje implementaci pro určitý počet metod, který umožňuje odvozeným třídám sdílet kód.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-305">In the previous example, you defined a base class that provided an implementation for a number of methods to allow derived classes to share code.</span></span> <span data-ttu-id="fdcd1-306">V mnoha případech však neočekáváme, že základní třída poskytuje implementaci.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-306">In many cases, however, the base class is not expected to provide an implementation.</span></span> <span data-ttu-id="fdcd1-307">Místo toho je základní třídou *abstraktní třída* , která deklaruje *abstraktní metody*; slouží jako šablona definující členy, které musí implementovat jednotlivé odvozené třídy.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-307">Instead, the base class is an *abstract class* that declares *abstract methods*; it serves as a template that defines the members that each derived class must implement.</span></span> <span data-ttu-id="fdcd1-308">Obvykle v abstraktní základní třídě je implementace každého odvozeného typu pro tento typ jedinečná.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-308">Typically in an abstract base class, the implementation of each derived type is unique to that type.</span></span> <span data-ttu-id="fdcd1-309">Označili jste třídu pomocí klíčového slova abstract, protože nemá žádný smysl pro vytvoření instance `Publication` objektu, i když třída poskytovala implementace funkcí běžných pro publikace.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-309">You marked the class with the abstract keyword because it made no sense to instantiate a `Publication` object, although the class did provide implementations of functionality common to publications.</span></span>

<span data-ttu-id="fdcd1-310">Každý uzavřený 2D tvar obsahuje například dvě vlastnosti: oblast, vnitřní rozsah tvaru; a obvodu nebo vzdálenost podél okrajů obrazce.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-310">For example, each closed two-dimensional geometric shape includes two properties: area, the inner extent of the shape; and perimeter, or the distance along the edges of the shape.</span></span> <span data-ttu-id="fdcd1-311">Způsob, jakým jsou tyto vlastnosti vypočítávány, však závisí zcela na konkrétním tvaru.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-311">The way in which these properties are calculated, however, depends completely on the specific shape.</span></span> <span data-ttu-id="fdcd1-312">Vzorec pro výpočet hraničního (nebo obvodu) kružnice, například se liší od trojúhelníku.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-312">The formula for calculating the perimeter (or circumference) of a circle, for example, is different from that of a triangle.</span></span> <span data-ttu-id="fdcd1-313">`Shape`Třída je `abstract` Třída s `abstract` metodami.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-313">The `Shape` class is an `abstract` class with `abstract` methods.</span></span> <span data-ttu-id="fdcd1-314">Který označuje, že odvozené třídy mají stejné funkce, ale tyto odvozené třídy implementují tuto funkčnost jinak.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-314">That indicates derived classes share the same functionality, but those derived classes implement that functionality differently.</span></span>

<span data-ttu-id="fdcd1-315">Následující příklad definuje abstraktní základní třídu s názvem `Shape` , která definuje dvě vlastnosti: `Area` a `Perimeter` .</span><span class="sxs-lookup"><span data-stu-id="fdcd1-315">The following example defines an abstract base class named `Shape` that defines two properties: `Area` and `Perimeter`.</span></span> <span data-ttu-id="fdcd1-316">Kromě označení třídy pomocí klíčového slova [abstract](../language-reference/keywords/abstract.md) je každý člen instance označen také pomocí klíčového slova [abstract](../language-reference/keywords/abstract.md) .</span><span class="sxs-lookup"><span data-stu-id="fdcd1-316">In addition to marking the class with the [abstract](../language-reference/keywords/abstract.md) keyword, each instance member is also marked with the [abstract](../language-reference/keywords/abstract.md) keyword.</span></span> <span data-ttu-id="fdcd1-317">V tomto případě `Shape` přepíše také metodu, <xref:System.Object.ToString%2A?displayProperty=nameWithType> která vrátí název typu, nikoli jeho plně kvalifikovaný název.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-317">In this case, `Shape` also overrides the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method to return the name of the type, rather than its fully qualified name.</span></span> <span data-ttu-id="fdcd1-318">A definuje dva statické členy `GetArea` a `GetPerimeter` , které umožňují volajícím snadno načíst oblast a obvod instance jakékoli odvozené třídy.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-318">And it defines two static members, `GetArea` and `GetPerimeter`, that allow callers to easily retrieve the area and perimeter of an instance of any derived class.</span></span> <span data-ttu-id="fdcd1-319">Pokud předáte instanci odvozené třídy jedné z těchto metod, modul runtime zavolá metodu přepsání odvozené třídy.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-319">When you pass an instance of a derived class to either of these methods, the runtime calls the method override of the derived class.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/shape.cs#1)]

<span data-ttu-id="fdcd1-320">Pak můžete odvodit některé třídy z `Shape` , které představuje konkrétní tvary.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-320">You can then derive some classes from `Shape` that represent specific shapes.</span></span> <span data-ttu-id="fdcd1-321">Následující příklad definuje tři třídy, `Triangle` , a `Rectangle` `Circle` .</span><span class="sxs-lookup"><span data-stu-id="fdcd1-321">The following example defines three classes, `Triangle`, `Rectangle`, and `Circle`.</span></span> <span data-ttu-id="fdcd1-322">Každá z nich používá vzorec jedinečný pro konkrétní obrazec k výpočtu oblasti a hraničního prostředí.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-322">Each uses a formula unique for that particular shape to compute the area and perimeter.</span></span> <span data-ttu-id="fdcd1-323">Některé odvozené třídy také definují vlastnosti, například `Rectangle.Diagonal` a `Circle.Diameter` , které jsou jedinečné pro tvar, který představují.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-323">Some of the derived classes also define properties, such as `Rectangle.Diagonal` and `Circle.Diameter`, that are unique to the shape that they represent.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/shape.cs#2)]

<span data-ttu-id="fdcd1-324">Následující příklad používá objekty odvozené z `Shape` .</span><span class="sxs-lookup"><span data-stu-id="fdcd1-324">The following example uses objects derived from `Shape`.</span></span> <span data-ttu-id="fdcd1-325">Vytvoří instanci pole objektů odvozených z `Shape` a zavolá statické metody `Shape` třídy, které zalomí hodnoty vrácených `Shape` vlastností.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-325">It instantiates an array of objects derived from `Shape` and calls the static methods of the `Shape` class, which wraps return `Shape` property values.</span></span> <span data-ttu-id="fdcd1-326">Modul runtime načítá hodnoty z potlačených vlastností odvozených typů.</span><span class="sxs-lookup"><span data-stu-id="fdcd1-326">The runtime retrieves values from the overridden properties of the derived types.</span></span> <span data-ttu-id="fdcd1-327">Příklad také přetypování každý `Shape` objekt v poli na odvozený typ a, pokud je přetypování úspěšné, načte vlastnosti této konkrétní podtřídy `Shape` .</span><span class="sxs-lookup"><span data-stu-id="fdcd1-327">The example also casts each `Shape` object in the array to its derived type and, if the cast succeeds, retrieves properties of that particular subclass of `Shape`.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/shape.cs#3)]

## <a name="see-also"></a><span data-ttu-id="fdcd1-328">Viz také</span><span class="sxs-lookup"><span data-stu-id="fdcd1-328">See also</span></span>

- [<span data-ttu-id="fdcd1-329">Dědičnost (Průvodce programováním v C#)</span><span class="sxs-lookup"><span data-stu-id="fdcd1-329">Inheritance (C# Programming Guide)</span></span>](../programming-guide/classes-and-structs/inheritance.md)
