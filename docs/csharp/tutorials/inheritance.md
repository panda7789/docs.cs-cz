---
title: 'Dědičnost v C #'
description: Naučte se používat dědičnost v knihovnách a aplikacích jazyka C#.
ms.date: 07/05/2018
ms.technology: csharp-fundamentals
ms.assetid: aeb68c74-0ea0-406f-9fbe-2ce02d47ef31
ms.openlocfilehash: b72badb7833e018dfcbf5d2583b17f17c800c382
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 03/14/2020
ms.locfileid: "79156750"
---
# <a name="inheritance-in-c-and-net"></a><span data-ttu-id="d89e7-103">Dědičnost v jazyce C# a technologii .NET</span><span class="sxs-lookup"><span data-stu-id="d89e7-103">Inheritance in C# and .NET</span></span>

<span data-ttu-id="d89e7-104">Tento kurz vás seznámí s dědičností v c#.</span><span class="sxs-lookup"><span data-stu-id="d89e7-104">This tutorial introduces you to inheritance in C#.</span></span> <span data-ttu-id="d89e7-105">Dědičnost je funkce objektově orientovaných programovacích jazyků, která umožňuje definovat základní třídu, která poskytuje specifické funkce (data a chování) a definovat odvozené třídy, které tuto funkci dědí nebo převyšují.</span><span class="sxs-lookup"><span data-stu-id="d89e7-105">Inheritance is a feature of object-oriented programming languages that allows you to define a base class that provides specific functionality (data and behavior) and to define derived classes that either inherit or override that functionality.</span></span>

## <a name="prerequisites"></a><span data-ttu-id="d89e7-106">Požadavky</span><span class="sxs-lookup"><span data-stu-id="d89e7-106">Prerequisites</span></span>

<span data-ttu-id="d89e7-107">Tento kurz předpokládá, že jste nainstalovali .NET Core SDK.</span><span class="sxs-lookup"><span data-stu-id="d89e7-107">This tutorial assumes that you've installed the .NET Core SDK.</span></span> <span data-ttu-id="d89e7-108">Navštivte stránku [stahování jádra .NET a](https://dotnet.microsoft.com/download) stáhněte si ji.</span><span class="sxs-lookup"><span data-stu-id="d89e7-108">Visit the [.NET Core Downloads](https://dotnet.microsoft.com/download) page to download it.</span></span> <span data-ttu-id="d89e7-109">Potřebujete také editor kódu.</span><span class="sxs-lookup"><span data-stu-id="d89e7-109">You also need a code editor.</span></span> <span data-ttu-id="d89e7-110">Tento kurz používá [Visual Studio Code](https://code.visualstudio.com), i když můžete použít libovolný editor kódu podle vašeho výběru.</span><span class="sxs-lookup"><span data-stu-id="d89e7-110">This tutorial uses [Visual Studio Code](https://code.visualstudio.com), although you can use any code editor of your choice.</span></span>

## <a name="running-the-examples"></a><span data-ttu-id="d89e7-111">Spuštění příkladů</span><span class="sxs-lookup"><span data-stu-id="d89e7-111">Running the examples</span></span>

<span data-ttu-id="d89e7-112">Chcete-li vytvořit a spustit příklady v tomto kurzu, použijte nástroj [dotnet](../../core/tools/dotnet.md) z příkazového řádku.</span><span class="sxs-lookup"><span data-stu-id="d89e7-112">To create and run the examples in this tutorial, you use the [dotnet](../../core/tools/dotnet.md) utility from the command line.</span></span> <span data-ttu-id="d89e7-113">Pro každý příklad postupujte takto:</span><span class="sxs-lookup"><span data-stu-id="d89e7-113">Follow these steps for each example:</span></span>

1. <span data-ttu-id="d89e7-114">Vytvořte adresář pro uložení příkladu.</span><span class="sxs-lookup"><span data-stu-id="d89e7-114">Create a directory to store the example.</span></span>
1. <span data-ttu-id="d89e7-115">Zadejte příkaz [dotnet new console](../../core/tools/dotnet-new.md) na příkazovém řádku a vytvořte nový projekt .NET Core.</span><span class="sxs-lookup"><span data-stu-id="d89e7-115">Enter the [dotnet new console](../../core/tools/dotnet-new.md) command at a command prompt to create a new .NET Core project.</span></span>
1. <span data-ttu-id="d89e7-116">Zkopírujte a vložte kód z příkladu do editoru kódu.</span><span class="sxs-lookup"><span data-stu-id="d89e7-116">Copy and paste the code from the example into your code editor.</span></span>
1. <span data-ttu-id="d89e7-117">Zadejte příkaz [dotnet restore](../../core/tools/dotnet-restore.md) z příkazového řádku, chcete-li načíst nebo obnovit závislosti projektu.</span><span class="sxs-lookup"><span data-stu-id="d89e7-117">Enter the [dotnet restore](../../core/tools/dotnet-restore.md) command from the command line to load or restore the project's dependencies.</span></span>

  [!INCLUDE[DotNet Restore Note](~/includes/dotnet-restore-note.md)]

1. <span data-ttu-id="d89e7-118">Zadejte příkaz [dotnet run](../../core/tools/dotnet-run.md) pro kompilaci a provedení příkladu.</span><span class="sxs-lookup"><span data-stu-id="d89e7-118">Enter the [dotnet run](../../core/tools/dotnet-run.md) command to compile and execute the example.</span></span>

## <a name="background-what-is-inheritance"></a><span data-ttu-id="d89e7-119">Souvislosti: Co je dědictví?</span><span class="sxs-lookup"><span data-stu-id="d89e7-119">Background: What is inheritance?</span></span>

<span data-ttu-id="d89e7-120">*Dědičnost* je jedním ze základních atributů objektově orientovaného programování.</span><span class="sxs-lookup"><span data-stu-id="d89e7-120">*Inheritance* is one of the fundamental attributes of object-oriented programming.</span></span> <span data-ttu-id="d89e7-121">Umožňuje definovat podřízenou třídu, která opakovaně používá (dědí), rozšiřuje nebo upravuje chování nadřazené třídy.</span><span class="sxs-lookup"><span data-stu-id="d89e7-121">It allows you to define a child class that reuses (inherits), extends, or modifies the behavior of a parent class.</span></span> <span data-ttu-id="d89e7-122">Třída, jejíž členové jsou zděděni, se nazývá *základní třída*.</span><span class="sxs-lookup"><span data-stu-id="d89e7-122">The class whose members are inherited is called the *base class*.</span></span> <span data-ttu-id="d89e7-123">Třída, která dědí členy základní třídy se nazývá *odvozené třídy*.</span><span class="sxs-lookup"><span data-stu-id="d89e7-123">The class that inherits the members of the base class is called the *derived class*.</span></span>

<span data-ttu-id="d89e7-124">C# a .NET podporují pouze *jednu dědičnost.*</span><span class="sxs-lookup"><span data-stu-id="d89e7-124">C# and .NET support *single inheritance* only.</span></span> <span data-ttu-id="d89e7-125">To znamená, že třída může dědit pouze z jedné třídy.</span><span class="sxs-lookup"><span data-stu-id="d89e7-125">That is, a class can only inherit from a single class.</span></span> <span data-ttu-id="d89e7-126">Dědičnost je však přenositelná, což umožňuje definovat hierarchii dědičnosti pro sadu typů.</span><span class="sxs-lookup"><span data-stu-id="d89e7-126">However, inheritance is transitive, which allows you to define an inheritance hierarchy for a set of types.</span></span> <span data-ttu-id="d89e7-127">Jinými slovy, `D` typ může `C`dědit z `B`typu , který dědí `A`z typu , který dědí z typu základní třídy .</span><span class="sxs-lookup"><span data-stu-id="d89e7-127">In other words, type `D` can inherit from type `C`, which inherits from type `B`, which inherits from the base class type `A`.</span></span> <span data-ttu-id="d89e7-128">Vzhledem k tomu, že dědičnost je přenositá, jsou členové typu `A` k dispozici pro typ `D`.</span><span class="sxs-lookup"><span data-stu-id="d89e7-128">Because inheritance is transitive, the members of type `A` are available to type `D`.</span></span>

<span data-ttu-id="d89e7-129">Ne všichni členové základní třídy jsou zděděni odvozenými třídami.</span><span class="sxs-lookup"><span data-stu-id="d89e7-129">Not all members of a base class are inherited by derived classes.</span></span> <span data-ttu-id="d89e7-130">Následující členové nejsou zděděni:</span><span class="sxs-lookup"><span data-stu-id="d89e7-130">The following members are not inherited:</span></span>

- <span data-ttu-id="d89e7-131">[Statické konstruktory](../programming-guide/classes-and-structs/static-constructors.md), které inicializují statická data třídy.</span><span class="sxs-lookup"><span data-stu-id="d89e7-131">[Static constructors](../programming-guide/classes-and-structs/static-constructors.md), which initialize the static data of a class.</span></span>

- <span data-ttu-id="d89e7-132">[Instance konstruktory](../programming-guide/classes-and-structs/constructors.md), které voláte k vytvoření nové instance třídy.</span><span class="sxs-lookup"><span data-stu-id="d89e7-132">[Instance constructors](../programming-guide/classes-and-structs/constructors.md), which you call to create a new instance of the class.</span></span> <span data-ttu-id="d89e7-133">Každá třída musí definovat své vlastní konstruktory.</span><span class="sxs-lookup"><span data-stu-id="d89e7-133">Each class must define its own constructors.</span></span>

- <span data-ttu-id="d89e7-134">[Finalizační metody](../programming-guide/classes-and-structs/destructors.md), které jsou volány systémem uvolňování paměti za běhu ke zničení instancí třídy.</span><span class="sxs-lookup"><span data-stu-id="d89e7-134">[Finalizers](../programming-guide/classes-and-structs/destructors.md), which are called by the runtime's garbage collector to destroy instances of a class.</span></span>

<span data-ttu-id="d89e7-135">Zatímco všechny ostatní členy základní třídy jsou zděděny odvozené třídy, zda jsou viditelné nebo ne, závisí na jejich usnadnění přístupu.</span><span class="sxs-lookup"><span data-stu-id="d89e7-135">While all other members of a base class are inherited by derived classes, whether they are visible or not depends on their accessibility.</span></span> <span data-ttu-id="d89e7-136">Usnadnění přístupu člena ovlivňuje jeho viditelnost pro odvozené třídy následujícím způsobem:</span><span class="sxs-lookup"><span data-stu-id="d89e7-136">A member's accessibility affects its visibility for derived classes as follows:</span></span>

- <span data-ttu-id="d89e7-137">[Soukromé](../language-reference/keywords/private.md) členy jsou viditelné pouze v odvozených třídách, které jsou vnořeny do své základní třídy.</span><span class="sxs-lookup"><span data-stu-id="d89e7-137">[Private](../language-reference/keywords/private.md) members are visible only in derived classes that are nested in their base class.</span></span> <span data-ttu-id="d89e7-138">V opačném případě nejsou viditelné v odvozených třídách.</span><span class="sxs-lookup"><span data-stu-id="d89e7-138">Otherwise, they are not visible in derived classes.</span></span> <span data-ttu-id="d89e7-139">V následujícím příkladu je `A.B` vnořená `A`třída, `C` která `A`je odvozena od , a pochází z .</span><span class="sxs-lookup"><span data-stu-id="d89e7-139">In the following example, `A.B` is a nested class that derives from `A`, and `C` derives from `A`.</span></span> <span data-ttu-id="d89e7-140">Soukromé `A.value` pole je viditelné v A.B.</span><span class="sxs-lookup"><span data-stu-id="d89e7-140">The private `A.value` field is visible in A.B.</span></span> <span data-ttu-id="d89e7-141">Pokud však odeberete `C.GetValue` komentáře z metody a pokusíte se zkompilovat příklad, vytvoří chybu kompilátoru CS0122: "'Hodnota' je nepřístupná z důvodu úrovně ochrany."</span><span class="sxs-lookup"><span data-stu-id="d89e7-141">However, if you remove the comments from the `C.GetValue` method and attempt to compile the example, it produces compiler error CS0122: "'A.value' is inaccessible due to its protection level."</span></span>

  [!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/private.cs#1)]

- <span data-ttu-id="d89e7-142">[Chráněné](../language-reference/keywords/protected.md) členy jsou viditelné pouze v odvozených třídách.</span><span class="sxs-lookup"><span data-stu-id="d89e7-142">[Protected](../language-reference/keywords/protected.md) members are visible only in derived classes.</span></span>

- <span data-ttu-id="d89e7-143">[Vnitřní](../language-reference/keywords/internal.md) členy jsou viditelné pouze v odvozených třídách, které jsou umístěny ve stejném sestavení jako základní třída.</span><span class="sxs-lookup"><span data-stu-id="d89e7-143">[Internal](../language-reference/keywords/internal.md) members are visible only in derived classes that are located in the same assembly as the base class.</span></span> <span data-ttu-id="d89e7-144">Nejsou viditelné v odvozených třídách umístěných v jiném sestavení od základní třídy.</span><span class="sxs-lookup"><span data-stu-id="d89e7-144">They are not visible in derived classes located in a different assembly from the base class.</span></span>

- <span data-ttu-id="d89e7-145">[Veřejné](../language-reference/keywords/public.md) členy jsou viditelné v odvozené třídy a jsou součástí veřejné rozhraní odvozené třídy.</span><span class="sxs-lookup"><span data-stu-id="d89e7-145">[Public](../language-reference/keywords/public.md) members are visible in derived classes and are part of the derived class' public interface.</span></span> <span data-ttu-id="d89e7-146">Veřejné zděděné členy lze volat stejně jako pokud jsou definovány v odvozené třídě.</span><span class="sxs-lookup"><span data-stu-id="d89e7-146">Public inherited members can be called just as if they are defined in the derived class.</span></span> <span data-ttu-id="d89e7-147">V následujícím příkladu `A` třída definuje `Method1`metodu `B` s názvem `A`a třída dědí z třídy .</span><span class="sxs-lookup"><span data-stu-id="d89e7-147">In the following example, class `A` defines a method named `Method1`, and class `B` inherits from class `A`.</span></span> <span data-ttu-id="d89e7-148">Příklad pak `Method1` volá, jako by se `B`jednalo o metodu instance na .</span><span class="sxs-lookup"><span data-stu-id="d89e7-148">The example then calls `Method1` as if it were an instance method on `B`.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/basics.cs#1)]

<span data-ttu-id="d89e7-149">Odvozené třídy můžete také *přepsat* zděděné členy poskytnutím alternativní implementace.</span><span class="sxs-lookup"><span data-stu-id="d89e7-149">Derived classes can also *override* inherited members by providing an alternate implementation.</span></span> <span data-ttu-id="d89e7-150">Aby bylo možné přepsat člena, musí být člen v základní třídě označen [virtuálním](../language-reference/keywords/virtual.md) klíčovým slovem.</span><span class="sxs-lookup"><span data-stu-id="d89e7-150">In order to be able to override a member, the member in the base class must be marked with the [virtual](../language-reference/keywords/virtual.md) keyword.</span></span> <span data-ttu-id="d89e7-151">Ve výchozím nastavení nejsou členové `virtual` základní třídy označeni jako a nelze je přepsat.</span><span class="sxs-lookup"><span data-stu-id="d89e7-151">By default, base class members are not marked as `virtual` and cannot be overridden.</span></span> <span data-ttu-id="d89e7-152">Při pokusu o přepsání nevirtuálního člena, jak to dělá následující příklad,\<generuje chyba kompilátoru \<CS0506: " člen> nemůže přepsat zděděný člen> protože není označen virtuální, abstraktní nebo přepsání.</span><span class="sxs-lookup"><span data-stu-id="d89e7-152">Attempting to override a non-virtual member, as the following example does, generates compiler error CS0506: "\<member> cannot override inherited member \<member> because it is not marked virtual, abstract, or override.</span></span>

```csharp
public class A
{
    public void Method1()
    {
        // Do something.
    }
}

public class B : A
{
    public override void Method1() // Generates CS0506.
    {
        // Do something else.
    }
}
```

<span data-ttu-id="d89e7-153">V některých případech *musí* odvozená třída přepsat implementaci základní třídy.</span><span class="sxs-lookup"><span data-stu-id="d89e7-153">In some cases, a derived class *must* override the base class implementation.</span></span> <span data-ttu-id="d89e7-154">Členové základní třídy označeni [abstraktním](../language-reference/keywords/abstract.md) klíčovým slovem vyžadují, aby je odvozené třídy přepsaly.</span><span class="sxs-lookup"><span data-stu-id="d89e7-154">Base class members marked with the [abstract](../language-reference/keywords/abstract.md) keyword require that derived classes override them.</span></span> <span data-ttu-id="d89e7-155">Pokus o kompilaci následujícípříklad generuje chybu kompilátoru&lt;CS0534, " třída&gt; neimplementuje zděděný &lt;abstraktní člen&gt;", protože třída `B` poskytuje žádné implementace pro `A.Method1`.</span><span class="sxs-lookup"><span data-stu-id="d89e7-155">Attempting to compile the following example generates compiler error CS0534, "&lt;class&gt; does not implement inherited abstract member &lt;member&gt;", because class `B` provides no implementation for `A.Method1`.</span></span>

```csharp
public abstract class A
{
    public abstract void Method1();
}

public class B : A // Generates CS0534.
{
    public void Method3()
    {
        // Do something.
    }
}
```

<span data-ttu-id="d89e7-156">Dědičnost platí pouze pro třídy a rozhraní.</span><span class="sxs-lookup"><span data-stu-id="d89e7-156">Inheritance applies only to classes and interfaces.</span></span> <span data-ttu-id="d89e7-157">Jiné kategorie typů (struktury, delegáti a výčty) nepodporují dědičnost.</span><span class="sxs-lookup"><span data-stu-id="d89e7-157">Other type categories (structs, delegates, and enums) do not support inheritance.</span></span> <span data-ttu-id="d89e7-158">Z důvodu těchto pravidel, pokus o kompilaci kódu, jako je následující příklad produkuje chybu kompilátoru CS0527: "Typ ValueType' v seznamu rozhraní není rozhraní."</span><span class="sxs-lookup"><span data-stu-id="d89e7-158">Because of these rules, attempting to compile code like the following example produces compiler error CS0527: "Type 'ValueType' in interface list is not an interface."</span></span> <span data-ttu-id="d89e7-159">Chybová zpráva označuje, že i když můžete definovat rozhraní, která implementuje struktury, dědičnost není podporována.</span><span class="sxs-lookup"><span data-stu-id="d89e7-159">The error message indicates that, although you can define the interfaces that a struct implements, inheritance is not supported.</span></span>

```csharp
using System;

public struct ValueStructure : ValueType // Generates CS0527.
{
}
```

## <a name="implicit-inheritance"></a><span data-ttu-id="d89e7-160">Implicitní dědičnost</span><span class="sxs-lookup"><span data-stu-id="d89e7-160">Implicit inheritance</span></span>

<span data-ttu-id="d89e7-161">Kromě všech typů, které mohou dědit z prostřednictvím jedné dědičnosti, <xref:System.Object> všechny typy v systému typu .NET implicitně dědí z nebo typ odvozený z něj.</span><span class="sxs-lookup"><span data-stu-id="d89e7-161">Besides any types that they may inherit from through single inheritance, all types in the .NET type system implicitly inherit from <xref:System.Object> or a type derived from it.</span></span> <span data-ttu-id="d89e7-162">Běžné funkce <xref:System.Object> je k dispozici pro všechny typy.</span><span class="sxs-lookup"><span data-stu-id="d89e7-162">The common functionality of <xref:System.Object> is available to any type.</span></span>

<span data-ttu-id="d89e7-163">Chcete-li zjistit, co implicitní dědičnost `SimpleClass`znamená, definujme novou třídu , která je jednoduše prázdnou definicí třídy:</span><span class="sxs-lookup"><span data-stu-id="d89e7-163">To see what implicit inheritance means, let's define a new class, `SimpleClass`, that is simply an empty class definition:</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/simpleclass.cs#1)]

<span data-ttu-id="d89e7-164">Potom můžete použít reflexe (který umožňuje zkontrolovat metadata typu získat informace o tomto typu) získat seznam `SimpleClass` členů, které patří do typu.</span><span class="sxs-lookup"><span data-stu-id="d89e7-164">You can then use reflection (which lets you inspect a type's metadata to get information about that type) to get a list of the members that belong to the `SimpleClass` type.</span></span> <span data-ttu-id="d89e7-165">I když jste nedefinovali `SimpleClass` žádné členy ve vaší třídě, výstup z příkladu označuje, že ve skutečnosti má devět členů.</span><span class="sxs-lookup"><span data-stu-id="d89e7-165">Although you haven't defined any members in your `SimpleClass` class, output from the example indicates that it actually has nine members.</span></span> <span data-ttu-id="d89e7-166">Jeden z těchto členů je konstruktor bez parametrů (nebo `SimpleClass` výchozí), který je automaticky dodáván pro typ kompilátorem Jazyka C#.</span><span class="sxs-lookup"><span data-stu-id="d89e7-166">One of these members is a parameterless (or default) constructor that is automatically supplied for the `SimpleClass` type by the C# compiler.</span></span> <span data-ttu-id="d89e7-167">Zbývajících osm jsou <xref:System.Object>členy , typ, ze kterého všechny třídy a rozhraní v systému typu .NET nakonec implicitně dědí.</span><span class="sxs-lookup"><span data-stu-id="d89e7-167">The remaining eight are members of <xref:System.Object>, the type from which all classes and interfaces in the .NET type system ultimately implicitly inherit.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/simpleclass.cs#2)]

<span data-ttu-id="d89e7-168">Implicitní dědičnost z třídy <xref:System.Object> `SimpleClass` zpřístupňuje tyto metody pro třídu:</span><span class="sxs-lookup"><span data-stu-id="d89e7-168">Implicit inheritance from the <xref:System.Object> class makes these methods available to the `SimpleClass` class:</span></span>

- <span data-ttu-id="d89e7-169">Veřejná `ToString` metoda, která `SimpleClass` převádí objekt na jeho řetězcovou reprezentaci, vrátí plně kvalifikovaný název typu.</span><span class="sxs-lookup"><span data-stu-id="d89e7-169">The public `ToString` method, which converts a `SimpleClass` object to its string representation, returns the fully qualified type name.</span></span> <span data-ttu-id="d89e7-170">V tomto případě `ToString` metoda vrátí řetězec "SimpleClass".</span><span class="sxs-lookup"><span data-stu-id="d89e7-170">In this case, the `ToString` method returns the string "SimpleClass".</span></span>

- <span data-ttu-id="d89e7-171">Tři metody, které testují rovnost dvou `Equals(Object)` objektů: metodu `Equals(Object, Object)` veřejné instance, `ReferenceEquals(Object, Object)` veřejnou statickou metodu a veřejnou statickou metodu.</span><span class="sxs-lookup"><span data-stu-id="d89e7-171">Three methods that test for equality of two objects: the public instance `Equals(Object)` method, the public static `Equals(Object, Object)` method, and the public static `ReferenceEquals(Object, Object)` method.</span></span> <span data-ttu-id="d89e7-172">Ve výchozím nastavení tyto metody testují referenční rovnost; to znamená, že se rovná dvě proměnné objektu musí odkazovat na stejný objekt.</span><span class="sxs-lookup"><span data-stu-id="d89e7-172">By default, these methods test for reference equality; that is, to be equal, two object variables must refer to the same object.</span></span>

- <span data-ttu-id="d89e7-173">Public `GetHashCode` Metoda, která vypočítá hodnotu, která umožňuje instanci typu, který má být použit v zachycované kolekce.</span><span class="sxs-lookup"><span data-stu-id="d89e7-173">The public `GetHashCode` method, which computes a value that allows an instance of the type to be used in hashed collections.</span></span>

- <span data-ttu-id="d89e7-174">Public `GetType` Metoda, která <xref:System.Type> vrátí objekt, `SimpleClass` který představuje typ.</span><span class="sxs-lookup"><span data-stu-id="d89e7-174">The public `GetType` method, which returns a <xref:System.Type> object that represents the `SimpleClass` type.</span></span>

- <span data-ttu-id="d89e7-175">Chráněná <xref:System.Object.Finalize%2A> metoda, která je určena k uvolnění nespravovaných prostředků před uvolněním paměti objektu uvolněnou systémem uvolňování paměti.</span><span class="sxs-lookup"><span data-stu-id="d89e7-175">The protected <xref:System.Object.Finalize%2A> method, which is designed to release unmanaged resources before an object's memory is reclaimed by the garbage collector.</span></span>

- <span data-ttu-id="d89e7-176">Chráněná <xref:System.Object.MemberwiseClone%2A> metoda, která vytvoří mělký klon aktuálního objektu.</span><span class="sxs-lookup"><span data-stu-id="d89e7-176">The protected <xref:System.Object.MemberwiseClone%2A> method, which creates a shallow clone of the current object.</span></span>

<span data-ttu-id="d89e7-177">Z důvodu implicitní dědičnosti můžete volat `SimpleClass` libovolný zděděný člen z objektu, stejně jako kdyby byl ve skutečnosti členem definovaným `SimpleClass` ve třídě.</span><span class="sxs-lookup"><span data-stu-id="d89e7-177">Because of implicit inheritance, you can call any inherited member from a `SimpleClass` object just as if it was actually a member defined in the `SimpleClass` class.</span></span> <span data-ttu-id="d89e7-178">Například následující příklad volá `SimpleClass.ToString` metodu, `SimpleClass` která <xref:System.Object>dědí z .</span><span class="sxs-lookup"><span data-stu-id="d89e7-178">For instance, the following example calls the `SimpleClass.ToString` method, which `SimpleClass` inherits from <xref:System.Object>.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/simpleclass2.cs#1)]

<span data-ttu-id="d89e7-179">V následující tabulce jsou uvedeny kategorie typů, které můžete vytvořit v jazyce C# a typy, ze kterých implicitně dědí.</span><span class="sxs-lookup"><span data-stu-id="d89e7-179">The following table lists the categories of types that you can create in C# and the types from which they implicitly inherit.</span></span> <span data-ttu-id="d89e7-180">Každý základní typ zpřístupňuje jinou sadu členů prostřednictvím dědičnosti implicitně odvozené typy.</span><span class="sxs-lookup"><span data-stu-id="d89e7-180">Each base type makes a different set of members available through inheritance to implicitly derived types.</span></span>

| <span data-ttu-id="d89e7-181">Kategorie typu</span><span class="sxs-lookup"><span data-stu-id="d89e7-181">Type category</span></span> | <span data-ttu-id="d89e7-182">Implicitně dědí z</span><span class="sxs-lookup"><span data-stu-id="d89e7-182">Implicitly inherits from</span></span>                                                      |
| ------------- | ----------------------------------------------------------------------------- |
| <span data-ttu-id="d89e7-183">třída</span><span class="sxs-lookup"><span data-stu-id="d89e7-183">class</span></span>         | <xref:System.Object>                                                          |
| <span data-ttu-id="d89e7-184">struct </span><span class="sxs-lookup"><span data-stu-id="d89e7-184">struct</span></span>        | <span data-ttu-id="d89e7-185"><xref:System.ValueType>, <xref:System.Object></span><span class="sxs-lookup"><span data-stu-id="d89e7-185"><xref:System.ValueType>, <xref:System.Object></span></span>                                 |
| <span data-ttu-id="d89e7-186">enum</span><span class="sxs-lookup"><span data-stu-id="d89e7-186">enum</span></span>          | <span data-ttu-id="d89e7-187"><xref:System.Enum>, <xref:System.ValueType>, <xref:System.Object></span><span class="sxs-lookup"><span data-stu-id="d89e7-187"><xref:System.Enum>, <xref:System.ValueType>, <xref:System.Object></span></span>             |
| <span data-ttu-id="d89e7-188">delegát</span><span class="sxs-lookup"><span data-stu-id="d89e7-188">delegate</span></span>      | <span data-ttu-id="d89e7-189"><xref:System.MulticastDelegate>, <xref:System.Delegate>, <xref:System.Object></span><span class="sxs-lookup"><span data-stu-id="d89e7-189"><xref:System.MulticastDelegate>, <xref:System.Delegate>, <xref:System.Object></span></span> |

## <a name="inheritance-and-an-is-a-relationship"></a><span data-ttu-id="d89e7-190">Dědičnost a vztah "je"</span><span class="sxs-lookup"><span data-stu-id="d89e7-190">Inheritance and an "is a" relationship</span></span>

<span data-ttu-id="d89e7-191">Dědičnost se obvykle používá k vyjádření vztahu "is a" mezi základní třídou a jednou nebo více odvozenými třídami, kde odvozené třídy jsou specializované verze základní třídy; odvozená třída je typ základní třídy.</span><span class="sxs-lookup"><span data-stu-id="d89e7-191">Ordinarily, inheritance is used to express an "is a" relationship between a base class and one or more derived classes, where the derived classes are specialized versions of the base class; the derived class is a type of the base class.</span></span> <span data-ttu-id="d89e7-192">Například `Publication` třída představuje publikace jakéhokoli druhu a `Book` `Magazine` a třídy představují určité typy publikací.</span><span class="sxs-lookup"><span data-stu-id="d89e7-192">For example, the `Publication` class represents a publication of any kind, and the `Book` and `Magazine` classes represent specific types of publications.</span></span>

> [!NOTE]
> <span data-ttu-id="d89e7-193">Třída nebo struktura může implementovat jedno nebo více rozhraní.</span><span class="sxs-lookup"><span data-stu-id="d89e7-193">A class or struct can implement one or more interfaces.</span></span> <span data-ttu-id="d89e7-194">Zatímco implementace rozhraní je často prezentována jako řešení pro jednu dědičnost nebo jako způsob použití dědičnosti se strukturami, je určena k vyjádření jiného vztahu (vztah "může udělat") mezi rozhraním a jeho implementačním typem než Dědičnosti.</span><span class="sxs-lookup"><span data-stu-id="d89e7-194">While interface implementation is often presented as a workaround for single inheritance or as a way of using inheritance with structs, it is intended to express a different relationship (a "can do" relationship) between an interface and its implementing type than inheritance.</span></span> <span data-ttu-id="d89e7-195">Rozhraní definuje podmnožinu funkcí (například schopnost testovat rovnost, porovnávat nebo řadit objekty nebo podporovat analýzu a formátování zkoumaná jazykovou verzí), kterou rozhraní zpřístupní implementujícím typům.</span><span class="sxs-lookup"><span data-stu-id="d89e7-195">An interface defines a subset of functionality (such as the ability to test for equality, to compare or sort objects, or to support culture-sensitive parsing and formatting) that the interface makes available to its implementing types.</span></span>

<span data-ttu-id="d89e7-196">Všimněte si, že "je a" také vyjadřuje vztah mezi typem a konkrétní konkretiace tohoto typu.</span><span class="sxs-lookup"><span data-stu-id="d89e7-196">Note that "is a" also expresses the relationship between a type and a specific instantiation of that type.</span></span> <span data-ttu-id="d89e7-197">V následujícím příkladu je třída, `Automobile` která má tři `Make`jedinečné vlastnosti jen pro čtení: , výrobce automobilu; `Model`, druh automobilu; a `Year`, rok výroby.</span><span class="sxs-lookup"><span data-stu-id="d89e7-197">In the following example, `Automobile` is a class that has three unique read-only properties: `Make`, the manufacturer of the automobile; `Model`, the kind of automobile; and `Year`, its year of manufacture.</span></span> <span data-ttu-id="d89e7-198">Vaše `Automobile` třída má také konstruktor, jehož argumenty jsou přiřazeny <xref:System.Object.ToString%2A?displayProperty=nameWithType> k hodnotám vlastností a `Automobile` přepíše metodu k vytvoření řetězce, který jednoznačně identifikuje instanci spíše než třídu. `Automobile`</span><span class="sxs-lookup"><span data-stu-id="d89e7-198">Your `Automobile` class also has a constructor whose arguments are assigned to the property values, and it overrides the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method to produce a string that uniquely identifies the `Automobile` instance rather than the `Automobile` class.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/is-a.cs#1)]

<span data-ttu-id="d89e7-199">V tomto případě byste se neměli spoléhat na dědictví reprezentovat konkrétní auto dělá a modelů.</span><span class="sxs-lookup"><span data-stu-id="d89e7-199">In this case, you shouldn't rely on inheritance to represent specific car makes and models.</span></span> <span data-ttu-id="d89e7-200">Například není nutné definovat `Packard` typ představující automobily vyrobené packardovou společností.</span><span class="sxs-lookup"><span data-stu-id="d89e7-200">For example, you don't need to define a `Packard` type to represent automobiles manufactured by the Packard Motor Car Company.</span></span> <span data-ttu-id="d89e7-201">Místo toho je můžete reprezentovat `Automobile` vytvořením objektu s příslušnými hodnotami předanými jeho konstruktoru třídy, jak to dělá následující příklad.</span><span class="sxs-lookup"><span data-stu-id="d89e7-201">Instead, you can represent them by creating an `Automobile` object with the appropriate values passed to its class constructor, as the following example does.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/is-a.cs#2)]

<span data-ttu-id="d89e7-202">Vztah is-a založený na dědičnosti je nejlépe použita pro základní třídu a odvozené třídy, které přidávají další členy do základní třídy nebo které vyžadují další funkce, které nejsou k dispozici v základní třídě.</span><span class="sxs-lookup"><span data-stu-id="d89e7-202">An is-a relationship based on inheritance is best applied to a base class and to derived classes that add additional members to the base class or that require additional functionality not present in the base class.</span></span>

## <a name="designing-the-base-class-and-derived-classes"></a><span data-ttu-id="d89e7-203">Návrh základní třídy a odvozených tříd</span><span class="sxs-lookup"><span data-stu-id="d89e7-203">Designing the base class and derived classes</span></span>

<span data-ttu-id="d89e7-204">Podívejme se na proces navrhování základní třídy a její odvozené třídy.</span><span class="sxs-lookup"><span data-stu-id="d89e7-204">Let's look at the process of designing a base class and its derived classes.</span></span> <span data-ttu-id="d89e7-205">V této části definujete základní třídu , `Publication`která představuje publikaci jakéhokoli druhu, například knihu, časopis, noviny, časopis, článek atd. Budete také definovat `Book` třídu, která `Publication`je odvozena od .</span><span class="sxs-lookup"><span data-stu-id="d89e7-205">In this section, you'll define a base class, `Publication`, which represents a publication of any kind, such as a book, a magazine, a newspaper, a journal, an article, etc. You'll also define a `Book` class that derives from `Publication`.</span></span> <span data-ttu-id="d89e7-206">Příklad můžete snadno rozšířit a definovat další odvozené `Journal` `Newspaper`třídy, například `Magazine`, , a `Article`.</span><span class="sxs-lookup"><span data-stu-id="d89e7-206">You could easily extend the example to define other derived classes, such as `Magazine`, `Journal`, `Newspaper`, and `Article`.</span></span>

### <a name="the-base-publication-class"></a><span data-ttu-id="d89e7-207">Základní třída Publication</span><span class="sxs-lookup"><span data-stu-id="d89e7-207">The base Publication class</span></span>

<span data-ttu-id="d89e7-208">Při navrhování `Publication` vaší třídy je třeba provést několik rozhodnutí o návrhu:</span><span class="sxs-lookup"><span data-stu-id="d89e7-208">In designing your `Publication` class, you need to make several design decisions:</span></span>

- <span data-ttu-id="d89e7-209">Jaké členy zahrnout do `Publication` základní třídy `Publication` a zda členové `Publication` poskytují implementace metody nebo zda je abstraktní základní třída, která slouží jako šablona pro odvozené třídy.</span><span class="sxs-lookup"><span data-stu-id="d89e7-209">What members to include in your base `Publication` class, and whether the `Publication` members provide method implementations or whether `Publication` is an abstract base class that serves as a template for its derived classes.</span></span>

  <span data-ttu-id="d89e7-210">V tomto případě `Publication` bude třída poskytovat implementace metody.</span><span class="sxs-lookup"><span data-stu-id="d89e7-210">In this case, the `Publication` class will provide method implementations.</span></span> <span data-ttu-id="d89e7-211">[Návrh abstraktní základní třídy a jejich odvozené třídy](#abstract) sekce obsahuje příklad, který používá abstraktní základní třídy definovat metody, které odvozené třídy musí přepsat.</span><span class="sxs-lookup"><span data-stu-id="d89e7-211">The [Designing abstract base classes and their derived classes](#abstract) section contains an example that uses an abstract base class to define the methods that derived classes must override.</span></span> <span data-ttu-id="d89e7-212">Odvozené třídy jsou zdarma poskytnout všechny implementace, která je vhodná pro odvozený typ.</span><span class="sxs-lookup"><span data-stu-id="d89e7-212">Derived classes are free to provide any implementation that is suitable for the derived type.</span></span>

  <span data-ttu-id="d89e7-213">Schopnost znovu použít kód (to znamená, že více odvozených tříd sdílí deklaraci a implementaci metod základní třídy a není nutné je přepsat) je výhodou neabstraktních základních tříd.</span><span class="sxs-lookup"><span data-stu-id="d89e7-213">The ability to reuse code (that is, multiple derived classes share the declaration and implementation of base class methods and do not need to override them) is an advantage of non-abstract base classes.</span></span> <span data-ttu-id="d89e7-214">Proto byste měli přidat `Publication` členy, pokud jejich kód je pravděpodobně `Publication` sdílet některé nebo většina specializovaných typů.</span><span class="sxs-lookup"><span data-stu-id="d89e7-214">Therefore, you should add members to `Publication` if their code is likely to be shared by some or most specialized `Publication` types.</span></span> <span data-ttu-id="d89e7-215">Pokud se vám nepodaří poskytnout implementace základní třídy efektivně, budete nakonec muset poskytnout do značné míry identické členské implementace v odvozených třídách spíše jednu implementaci v základní třídě.</span><span class="sxs-lookup"><span data-stu-id="d89e7-215">If you fail to provide base class implementations efficiently, you'll end up having to provide largely identical member implementations in derived classes rather a single implementation in the base class.</span></span> <span data-ttu-id="d89e7-216">Potřeba udržovat duplicitní kód na více místech je potenciálním zdrojem chyb.</span><span class="sxs-lookup"><span data-stu-id="d89e7-216">The need to maintain duplicated code in multiple locations is a potential source of bugs.</span></span>

  <span data-ttu-id="d89e7-217">Chcete-li maximalizovat opakované použití kódu a vytvořit logickou a intuitivní hierarchii `Publication` dědičnosti, měli byste mít jistotu, že do třídy zahrnete pouze data a funkce, které jsou společné pro všechny nebo pro většinu publikací.</span><span class="sxs-lookup"><span data-stu-id="d89e7-217">Both to maximize code reuse and to create a logical and intuitive inheritance hierarchy, you want to be sure that you include in the `Publication` class only the data and functionality that is common to all or to most publications.</span></span> <span data-ttu-id="d89e7-218">Odvozené třídy pak implementovat členy, které jsou jedinečné pro konkrétní druhy publikace, které představují.</span><span class="sxs-lookup"><span data-stu-id="d89e7-218">Derived classes then implement members that are unique to the particular kinds of publication that they represent.</span></span>

- <span data-ttu-id="d89e7-219">Jak daleko rozšířit hierarchii tříd.</span><span class="sxs-lookup"><span data-stu-id="d89e7-219">How far to extend your class hierarchy.</span></span> <span data-ttu-id="d89e7-220">Chcete vytvořit hierarchii tří nebo více tříd, nikoli pouze základní třídy a jedné nebo více odvozených tříd?</span><span class="sxs-lookup"><span data-stu-id="d89e7-220">Do you want to develop a hierarchy of three or more classes, rather than simply a base class and one or more derived classes?</span></span> <span data-ttu-id="d89e7-221">Může se `Publication` například jedná `Periodical`o základní třídu , `Magazine`která `Journal` `Newspaper`je zase základní třídou . a .</span><span class="sxs-lookup"><span data-stu-id="d89e7-221">For example, `Publication` could be a base class of `Periodical`, which in turn is a base class of `Magazine`, `Journal` and `Newspaper`.</span></span>

  <span data-ttu-id="d89e7-222">V příkladu použijete malou hierarchii `Publication` třídy a jednu `Book`odvozenou třídu .</span><span class="sxs-lookup"><span data-stu-id="d89e7-222">For your example, you'll use the small hierarchy of a `Publication` class and a single derived class, `Book`.</span></span> <span data-ttu-id="d89e7-223">Můžete snadno rozšířit příklad vytvořit řadu dalších tříd, které `Magazine` `Article`jsou odvozeny z `Publication`, například a .</span><span class="sxs-lookup"><span data-stu-id="d89e7-223">You could easily extend the example to create a number of additional   classes that derive from `Publication`, such as `Magazine` and `Article`.</span></span>

- <span data-ttu-id="d89e7-224">Zda má smysl vytvořit konkretizovat základní třídu.</span><span class="sxs-lookup"><span data-stu-id="d89e7-224">Whether it makes sense to instantiate the base class.</span></span> <span data-ttu-id="d89e7-225">Pokud tomu tak není, měli byste použít [abstraktní](../language-reference/keywords/abstract.md) klíčové slovo na třídu.</span><span class="sxs-lookup"><span data-stu-id="d89e7-225">If it does not, you should apply the [abstract](../language-reference/keywords/abstract.md) keyword to the class.</span></span> <span data-ttu-id="d89e7-226">V opačném `Publication` případě může být vaše třída vytvořena instance voláním jeho konstruktoru třídy.</span><span class="sxs-lookup"><span data-stu-id="d89e7-226">Otherwise, your `Publication` class can be instantiated by calling its class constructor.</span></span> <span data-ttu-id="d89e7-227">Pokud je proveden pokus o vytvoření instance třídy označené `abstract` klíčovým slovem přímým voláním konstruktoru třídy, kompilátor Jazyka C# generuje chybu CS0144, "Nelze vytvořit instanci abstraktní třídy nebo rozhraní."</span><span class="sxs-lookup"><span data-stu-id="d89e7-227">If an attempt is made to instantiate a class marked with the `abstract` keyword by a direct call to its class constructor, the C# compiler generates error CS0144, "Cannot create an instance of the abstract class or interface."</span></span> <span data-ttu-id="d89e7-228">Pokud je proveden pokus o vytvoření instance třídy pomocí reflexe, <xref:System.MemberAccessException>metoda odrazu vyvolá .</span><span class="sxs-lookup"><span data-stu-id="d89e7-228">If an attempt is made to instantiate the class by using reflection, the reflection method throws a <xref:System.MemberAccessException>.</span></span>

  <span data-ttu-id="d89e7-229">Ve výchozím nastavení lze vytvořit instanci základní třídy voláním svého konstruktoru třídy.</span><span class="sxs-lookup"><span data-stu-id="d89e7-229">By default, a base class can be instantiated by calling its class constructor.</span></span> <span data-ttu-id="d89e7-230">Není třeba explicitně definovat konstruktor třídy.</span><span class="sxs-lookup"><span data-stu-id="d89e7-230">You do not have to explicitly define a class constructor.</span></span> <span data-ttu-id="d89e7-231">Pokud jeden není k dispozici ve zdrojovém kódu základní třídy, kompilátor Jazyka C# automaticky poskytuje výchozí (parametrless) konstruktor.</span><span class="sxs-lookup"><span data-stu-id="d89e7-231">If one is not present in the base class' source code, the C# compiler automatically provides a default (parameterless) constructor.</span></span>

  <span data-ttu-id="d89e7-232">V příkladu označíte `Publication` třídu jako [abstraktní,](../language-reference/keywords/abstract.md) aby ji nebylo možné vytvořit.</span><span class="sxs-lookup"><span data-stu-id="d89e7-232">For your example, you'll mark the `Publication` class as [abstract](../language-reference/keywords/abstract.md) so that it cannot be instantiated.</span></span>  <span data-ttu-id="d89e7-233">Třída `abstract` bez `abstract` jakékoli metody označuje, že tato třída představuje abstraktní koncept, `Book` `Journal`který je sdílen mezi několik konkrétních tříd (například , ).</span><span class="sxs-lookup"><span data-stu-id="d89e7-233">An `abstract` class without any `abstract` methods indicates that this class represents an abstract concept that is shared among several concrete classes (like a `Book`, `Journal`).</span></span>

- <span data-ttu-id="d89e7-234">Zda odvozené třídy musí dědit implementaci základní třídy konkrétní chčlenů, zda mají možnost přepsat implementaci základní třídy, nebo zda musí poskytnout implementaci.</span><span class="sxs-lookup"><span data-stu-id="d89e7-234">Whether derived classes must inherit the base class implementation of particular members, whether they have the option to override the base class implementation, or whether they must provide an implementation.</span></span> <span data-ttu-id="d89e7-235">Pomocí [abstraktního](../language-reference/keywords/abstract.md) klíčového slova vynutíte odvozené třídy k poskytnutí implementace.</span><span class="sxs-lookup"><span data-stu-id="d89e7-235">You use the [abstract](../language-reference/keywords/abstract.md) keyword to force derived classes to provide an implementation.</span></span> <span data-ttu-id="d89e7-236">Virtuální [klíčové](../language-reference/keywords/virtual.md) slovo slouží k povolení odvozených tříd přepsat metodu základní třídy.</span><span class="sxs-lookup"><span data-stu-id="d89e7-236">You use the [virtual](../language-reference/keywords/virtual.md) keyword to allow derived classes to override a base class method.</span></span> <span data-ttu-id="d89e7-237">Ve výchozím nastavení metody definované v základní třídě *nejsou* overridable.</span><span class="sxs-lookup"><span data-stu-id="d89e7-237">By default, methods defined in the base class are *not* overridable.</span></span>

 <span data-ttu-id="d89e7-238">Třída `Publication` nemá žádné `abstract` metody, ale třída `abstract`sama je .</span><span class="sxs-lookup"><span data-stu-id="d89e7-238">The `Publication` class does not have any `abstract` methods, but the class itself is `abstract`.</span></span>

- <span data-ttu-id="d89e7-239">Zda odvozená třída představuje konečnou třídu v hierarchii dědičnosti a nemůže být sama použita jako základní třída pro další odvozené třídy.</span><span class="sxs-lookup"><span data-stu-id="d89e7-239">Whether a derived class represents the final class in the inheritance hierarchy and cannot itself be used as a base class for additional derived classes.</span></span> <span data-ttu-id="d89e7-240">Ve výchozím nastavení může každá třída sloužit jako základní třída.</span><span class="sxs-lookup"><span data-stu-id="d89e7-240">By default, any class can serve as a base class.</span></span> <span data-ttu-id="d89e7-241">Můžete použít [zapečetěné](../language-reference/keywords/sealed.md) klíčové slovo označující, že třída nemůže sloužit jako základní třída pro všechny další třídy.</span><span class="sxs-lookup"><span data-stu-id="d89e7-241">You can apply the [sealed](../language-reference/keywords/sealed.md) keyword to indicate that a class cannot serve as a base class for any additional classes.</span></span> <span data-ttu-id="d89e7-242">Pokus o odvození z zapečetěné třídy generované chyba kompilátoru CS0509, "nelze odvodit z zapečetěného typu \<typeName>".</span><span class="sxs-lookup"><span data-stu-id="d89e7-242">Attempting to derive from a sealed class generated compiler error CS0509, "cannot derive from sealed type \<typeName>".</span></span>

  <span data-ttu-id="d89e7-243">V příkladu označíte odvozenou `sealed`třídu jako .</span><span class="sxs-lookup"><span data-stu-id="d89e7-243">For your example, you'll mark your derived class as `sealed`.</span></span>

<span data-ttu-id="d89e7-244">Následující příklad ukazuje zdrojový kód `Publication` pro třídu, `PublicationType` stejně jako výčet, který je vrácen vlastností. `Publication.PublicationType`</span><span class="sxs-lookup"><span data-stu-id="d89e7-244">The following example shows the source code for the `Publication` class, as well as a `PublicationType` enumeration that is returned by the `Publication.PublicationType` property.</span></span> <span data-ttu-id="d89e7-245">Kromě členů, které dědí <xref:System.Object>z `Publication` , třída definuje následující jedinečné členy a přepsání členů:</span><span class="sxs-lookup"><span data-stu-id="d89e7-245">In addition to the members that it inherits from <xref:System.Object>, the `Publication` class defines the following unique members and member overrides:</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/base-and-derived.cs#1)]

- <span data-ttu-id="d89e7-246">Konstruktor</span><span class="sxs-lookup"><span data-stu-id="d89e7-246">A constructor</span></span>

  <span data-ttu-id="d89e7-247">Vzhledem `Publication` k `abstract`tomu, že třída je , nelze vytvořit instanci přímo z kódu, jako je následující příklad:</span><span class="sxs-lookup"><span data-stu-id="d89e7-247">Because the `Publication` class is `abstract`, it cannot be instantiated directly from code like the following example:</span></span>

  ```csharp
  var publication = new Publication("Tiddlywinks for Experts", "Fun and Games",
                                    PublicationType.Book);
  ```

  <span data-ttu-id="d89e7-248">Jeho instance konstruktor však může být volána přímo z konstruktorů `Book` odvozené třídy, jak ukazuje zdrojový kód pro třídu.</span><span class="sxs-lookup"><span data-stu-id="d89e7-248">However, its instance constructor can be called directly from derived class constructors, as the source code for the `Book` class shows.</span></span>

- <span data-ttu-id="d89e7-249">Dvě vlastnosti související s publikací</span><span class="sxs-lookup"><span data-stu-id="d89e7-249">Two publication-related properties</span></span>

  <span data-ttu-id="d89e7-250">`Title`je vlastnost jen <xref:System.String> pro čtení, jejíž `Publication` hodnota je zadána voláním konstruktoru.</span><span class="sxs-lookup"><span data-stu-id="d89e7-250">`Title` is a read-only <xref:System.String> property whose value is supplied by calling the `Publication` constructor.</span></span>

  <span data-ttu-id="d89e7-251">`Pages`je vlastnost pro <xref:System.Int32> čtení a zápis, která označuje, kolik celkových stránek publikace má.</span><span class="sxs-lookup"><span data-stu-id="d89e7-251">`Pages` is a read-write <xref:System.Int32> property that indicates how many total pages the publication has.</span></span> <span data-ttu-id="d89e7-252">Hodnota je uložena v `totalPages`soukromém poli s názvem .</span><span class="sxs-lookup"><span data-stu-id="d89e7-252">The value is stored in a private field named `totalPages`.</span></span> <span data-ttu-id="d89e7-253">Musí to být kladné <xref:System.ArgumentOutOfRangeException> číslo nebo je hozen.</span><span class="sxs-lookup"><span data-stu-id="d89e7-253">It must be a positive number or an <xref:System.ArgumentOutOfRangeException> is thrown.</span></span>

- <span data-ttu-id="d89e7-254">Členové související s vydavatelem</span><span class="sxs-lookup"><span data-stu-id="d89e7-254">Publisher-related members</span></span>

  <span data-ttu-id="d89e7-255">Dvě vlastnosti jen `Publisher` `Type`pro čtení a .</span><span class="sxs-lookup"><span data-stu-id="d89e7-255">Two read-only properties, `Publisher` and `Type`.</span></span> <span data-ttu-id="d89e7-256">Hodnoty jsou původně dodávány voláním konstruktoru `Publication` třídy.</span><span class="sxs-lookup"><span data-stu-id="d89e7-256">The values are originally supplied by the call to the `Publication` class constructor.</span></span>

- <span data-ttu-id="d89e7-257">Členové související s publikováním</span><span class="sxs-lookup"><span data-stu-id="d89e7-257">Publishing-related members</span></span>

  <span data-ttu-id="d89e7-258">Dvě metody `Publish` `GetPublicationDate`a , nastavte a vraťte datum publikování.</span><span class="sxs-lookup"><span data-stu-id="d89e7-258">Two methods, `Publish` and `GetPublicationDate`, set and return the publication date.</span></span> <span data-ttu-id="d89e7-259">Metoda `Publish` nastaví `published` soukromý `true` příznak, když je volána a přiřadí datum, `datePublished` které mu bylo předáno jako argument do soukromého pole.</span><span class="sxs-lookup"><span data-stu-id="d89e7-259">The `Publish` method sets a private  `published` flag to `true` when it is called and assigns the date passed to it as an argument to the private `datePublished` field.</span></span> <span data-ttu-id="d89e7-260">Metoda `GetPublicationDate` vrátí řetězec "NYP", `published` pokud `false`je příznak , `datePublished` a hodnota `true`pole, pokud je .</span><span class="sxs-lookup"><span data-stu-id="d89e7-260">The `GetPublicationDate` method returns the string "NYP" if the `published` flag is `false`, and the value of the `datePublished` field if it is `true`.</span></span>

- <span data-ttu-id="d89e7-261">Členové související s autorskými právy</span><span class="sxs-lookup"><span data-stu-id="d89e7-261">Copyright-related members</span></span>

  <span data-ttu-id="d89e7-262">Metoda `Copyright` bere jméno držitele autorských práv a rok autorského práva jako `CopyrightName` argumenty a přiřazuje je k vlastnostem a. `CopyrightDate`</span><span class="sxs-lookup"><span data-stu-id="d89e7-262">The `Copyright` method takes the name of the copyright holder and the year of the copyright as arguments and assigns them to the `CopyrightName` and `CopyrightDate` properties.</span></span>

- <span data-ttu-id="d89e7-263">Přepsání `ToString` metody</span><span class="sxs-lookup"><span data-stu-id="d89e7-263">An override of the `ToString` method</span></span>

  <span data-ttu-id="d89e7-264">Pokud typ nepřepíše <xref:System.Object.ToString%2A?displayProperty=nameWithType> metodu, vrátí plně kvalifikovaný název typu, který je málo použitelný při odlišení jedné instance od druhé.</span><span class="sxs-lookup"><span data-stu-id="d89e7-264">If a type does not override the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method, it returns the fully qualified name of the type, which is of little use in differentiating one instance from another.</span></span> <span data-ttu-id="d89e7-265">Třída `Publication` přepíše <xref:System.Object.ToString%2A?displayProperty=nameWithType> vrátit hodnotu `Title` vlastnosti.</span><span class="sxs-lookup"><span data-stu-id="d89e7-265">The `Publication` class overrides <xref:System.Object.ToString%2A?displayProperty=nameWithType> to return the value of the `Title` property.</span></span>

<span data-ttu-id="d89e7-266">Následující obrázek znázorňuje vztah `Publication` mezi základní třídou <xref:System.Object> a její implicitně zděděnou třídou.</span><span class="sxs-lookup"><span data-stu-id="d89e7-266">The following figure illustrates the relationship between your base `Publication` class and its implicitly inherited <xref:System.Object> class.</span></span>

![Třídy Object and Publication](media/publication-class.jpg)

### <a name="the-book-class"></a><span data-ttu-id="d89e7-268">Třída `Book`</span><span class="sxs-lookup"><span data-stu-id="d89e7-268">The `Book` class</span></span>

<span data-ttu-id="d89e7-269">Třída `Book` představuje knihu jako specializovaný typ publikace.</span><span class="sxs-lookup"><span data-stu-id="d89e7-269">The `Book` class represents a book as a specialized type of publication.</span></span> <span data-ttu-id="d89e7-270">Následující příklad ukazuje zdrojový kód `Book` pro třídu.</span><span class="sxs-lookup"><span data-stu-id="d89e7-270">The following example shows the source code for the `Book` class.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/base-and-derived.cs#2)]

<span data-ttu-id="d89e7-271">Kromě členů, které dědí `Publication`z `Book` , třída definuje následující jedinečné členy a přepsání členů:</span><span class="sxs-lookup"><span data-stu-id="d89e7-271">In addition to the members that it inherits from `Publication`, the `Book` class defines the following unique members and member overrides:</span></span>

- <span data-ttu-id="d89e7-272">Dva konstruktory</span><span class="sxs-lookup"><span data-stu-id="d89e7-272">Two constructors</span></span>

  <span data-ttu-id="d89e7-273">Dva `Book` konstruktory sdílejí tři společné parametry.</span><span class="sxs-lookup"><span data-stu-id="d89e7-273">The two `Book` constructors share three common parameters.</span></span> <span data-ttu-id="d89e7-274">Dva, *název* a *vydavatel*, odpovídají `Publication` parametrům konstruktoru.</span><span class="sxs-lookup"><span data-stu-id="d89e7-274">Two, *title* and *publisher*, correspond to parameters of the `Publication` constructor.</span></span> <span data-ttu-id="d89e7-275">Třetí je *autor*, který je uložen na `Author` veřejné neměnné vlastnosti.</span><span class="sxs-lookup"><span data-stu-id="d89e7-275">The third is *author*, which is stored to a public immutable `Author` property.</span></span> <span data-ttu-id="d89e7-276">Jeden konstruktor obsahuje *isbn* parametr, který `ISBN` je uložen v auto-vlastnost.</span><span class="sxs-lookup"><span data-stu-id="d89e7-276">One constructor includes an *isbn* parameter, which is stored in the `ISBN` auto-property.</span></span>

  <span data-ttu-id="d89e7-277">První konstruktor používá klíčové slovo [this](../language-reference/keywords/this.md) k volání jiného konstruktoru.</span><span class="sxs-lookup"><span data-stu-id="d89e7-277">The first constructor uses the [this](../language-reference/keywords/this.md) keyword to call the other constructor.</span></span> <span data-ttu-id="d89e7-278">Řetězení konstruktoru je běžný vzor při definování konstruktorů.</span><span class="sxs-lookup"><span data-stu-id="d89e7-278">Constructor chaining is a common pattern in defining constructors.</span></span> <span data-ttu-id="d89e7-279">Konstruktory s menším počtem parametrů poskytují výchozí hodnoty při volání konstruktoru s největším počtem parametrů.</span><span class="sxs-lookup"><span data-stu-id="d89e7-279">Constructors with fewer parameters provide default values when calling the constructor with the greatest number of parameters.</span></span>

  <span data-ttu-id="d89e7-280">Druhý konstruktor používá [základní](../language-reference/keywords/base.md) klíčové slovo předat název a název vydavatele konstruktoru základní třídy.</span><span class="sxs-lookup"><span data-stu-id="d89e7-280">The second constructor uses the [base](../language-reference/keywords/base.md) keyword to pass the title and publisher name to the base class constructor.</span></span> <span data-ttu-id="d89e7-281">Pokud neprovedete explicitní volání konstruktoru základní třídy ve zdrojovém kódu, kompilátor Jazyka C# automaticky dodá volání výchozího konstruktoru základní třídy nebo konstruktoru bez parametrů.</span><span class="sxs-lookup"><span data-stu-id="d89e7-281">If you don't make an explicit call to a base class constructor in your source code, the C# compiler automatically supplies a call to the base class' default or parameterless constructor.</span></span>

- <span data-ttu-id="d89e7-282">Vlastnost jen `ISBN` pro čtení, `Book` která vrací mezinárodní standardní číslo knihy objektu, jedinečné 10 nebo 13místné číslo.</span><span class="sxs-lookup"><span data-stu-id="d89e7-282">A read-only `ISBN` property, which returns the `Book` object's International Standard Book Number, a unique 10- or 13-digit number.</span></span> <span data-ttu-id="d89e7-283">ISBN je dodáván jako argument jednomu `Book` z konstruktorů.</span><span class="sxs-lookup"><span data-stu-id="d89e7-283">The ISBN is supplied as an argument to one of the `Book` constructors.</span></span> <span data-ttu-id="d89e7-284">ISBN je uložen v privátní záložní pole, které je automaticky generováno kompilátorem.</span><span class="sxs-lookup"><span data-stu-id="d89e7-284">The ISBN is stored in a private backing field, which is auto-generated by the compiler.</span></span>

- <span data-ttu-id="d89e7-285">Vlastnost jen `Author` pro čtení.</span><span class="sxs-lookup"><span data-stu-id="d89e7-285">A read-only `Author` property.</span></span> <span data-ttu-id="d89e7-286">Jméno autora je zadáno `Book` jako argument oběma konstruktorům a je uloženo ve vlastnosti.</span><span class="sxs-lookup"><span data-stu-id="d89e7-286">The author name is supplied as an argument to both `Book` constructors and is stored in the property.</span></span>

- <span data-ttu-id="d89e7-287">Dvě vlastnosti související s `Price` cenou `Currency`jen pro čtení a .</span><span class="sxs-lookup"><span data-stu-id="d89e7-287">Two read-only price-related properties, `Price` and `Currency`.</span></span> <span data-ttu-id="d89e7-288">Jejich hodnoty jsou uvedeny jako `SetPrice` argumenty v volání metody.</span><span class="sxs-lookup"><span data-stu-id="d89e7-288">Their values are provided as arguments in a `SetPrice` method call.</span></span> <span data-ttu-id="d89e7-289">Vlastnost `Currency` je třímístný symbol měny ISO (například USD pro americký dolar).</span><span class="sxs-lookup"><span data-stu-id="d89e7-289">The `Currency` property is the three-digit ISO currency symbol (for example, USD for the U.S. dollar).</span></span> <span data-ttu-id="d89e7-290">Symboly měny ISO lze <xref:System.Globalization.RegionInfo.ISOCurrencySymbol%2A> načíst z vlastnosti.</span><span class="sxs-lookup"><span data-stu-id="d89e7-290">ISO currency symbols can be retrieved from the <xref:System.Globalization.RegionInfo.ISOCurrencySymbol%2A> property.</span></span> <span data-ttu-id="d89e7-291">Obě tyto vlastnosti jsou externě jen pro čtení, `Book` ale obě lze nastavit podle kódu ve třídě.</span><span class="sxs-lookup"><span data-stu-id="d89e7-291">Both of these properties are externally read-only, but both can be set by code in the `Book` class.</span></span>

- <span data-ttu-id="d89e7-292">Metoda, `SetPrice` která nastaví hodnoty `Price` `Currency` vlastnosti a.</span><span class="sxs-lookup"><span data-stu-id="d89e7-292">A `SetPrice` method, which sets the values of the `Price` and `Currency` properties.</span></span> <span data-ttu-id="d89e7-293">Tyto hodnoty jsou vráceny stejnými vlastnostmi.</span><span class="sxs-lookup"><span data-stu-id="d89e7-293">Those values are returned by those same properties.</span></span>

- <span data-ttu-id="d89e7-294">Přepíše `ToString` metodu (zděděnou z) `Publication`a metody <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> a <xref:System.Object.GetHashCode%2A> (zděděné z). <xref:System.Object></span><span class="sxs-lookup"><span data-stu-id="d89e7-294">Overrides to the `ToString` method (inherited from `Publication`) and the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> and <xref:System.Object.GetHashCode%2A> methods (inherited from <xref:System.Object>).</span></span>

  <span data-ttu-id="d89e7-295">Pokud není přepsána, <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> metoda testuje rovnost odkazů.</span><span class="sxs-lookup"><span data-stu-id="d89e7-295">Unless it is overridden, the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method tests for reference equality.</span></span> <span data-ttu-id="d89e7-296">To znamená, že dvě proměnné objektu jsou považovány za stejné, pokud odkazují na stejný objekt.</span><span class="sxs-lookup"><span data-stu-id="d89e7-296">That is, two object variables are considered to be equal if they refer to the same object.</span></span> <span data-ttu-id="d89e7-297">Ve `Book` třídě, na druhé straně `Book` dva objekty by měly být stejné, pokud mají stejné ISBN.</span><span class="sxs-lookup"><span data-stu-id="d89e7-297">In the `Book` class, on the other hand, two `Book` objects should be equal if they have the same ISBN.</span></span>

  <span data-ttu-id="d89e7-298">Při přepsání <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> metody, musíte také <xref:System.Object.GetHashCode%2A> přepsat metodu, která vrátí hodnotu, která runtime používá k ukládání položek v zachycované kolekce pro efektivní načítání.</span><span class="sxs-lookup"><span data-stu-id="d89e7-298">When you override the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method, you must also override the <xref:System.Object.GetHashCode%2A> method, which returns a value that the runtime uses to store items in hashed collections for efficient retrieval.</span></span> <span data-ttu-id="d89e7-299">Kód hash by měl vrátit hodnotu, která je konzistentní s testem rovnosti.</span><span class="sxs-lookup"><span data-stu-id="d89e7-299">The hash code should return a value that's consistent with the test for equality.</span></span> <span data-ttu-id="d89e7-300">Vzhledem k tomu, že jste přepsáni <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> vrátit, `true` pokud ISBN vlastnosti dvou `Book` objektů <xref:System.String.GetHashCode%2A> jsou stejné, vrátíte hash kód vypočítaný voláním metody řetězce vrácené `ISBN` vlastností.</span><span class="sxs-lookup"><span data-stu-id="d89e7-300">Since you've overridden <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> to return `true` if the ISBN properties of two `Book` objects are equal, you return the hash code computed by calling the <xref:System.String.GetHashCode%2A> method of the string returned by the `ISBN` property.</span></span>

<span data-ttu-id="d89e7-301">Následující obrázek znázorňuje `Book` vztah `Publication`mezi třídou a jeho základní třídou.</span><span class="sxs-lookup"><span data-stu-id="d89e7-301">The following figure illustrates the relationship between the `Book` class and `Publication`, its base class.</span></span>

![Publikační a knižní třídy](media/book-class.jpg)

<span data-ttu-id="d89e7-303">Nyní můžete vytvořit instanci objektu, `Book` vyvolat jeho jedinečné i zděděné členy a předat jej `Publication` jako argument `Book`metodě, která očekává parametr typu nebo typu , jak ukazuje následující příklad.</span><span class="sxs-lookup"><span data-stu-id="d89e7-303">You can now instantiate a `Book` object, invoke both its unique and inherited members, and pass it as an argument to a method that expects a parameter of type `Publication` or of type `Book`, as the following example shows.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/use-publication.cs#1)]

## <a name="designing-abstract-base-classes-and-their-derived-classes"></a><span data-ttu-id="d89e7-304">Navrhování abstraktních základních tříd a jejich odvozených tříd</span><span class="sxs-lookup"><span data-stu-id="d89e7-304">Designing abstract base classes and their derived classes</span></span>
<a name="abstract"></a>

<span data-ttu-id="d89e7-305">V předchozím příkladu jste definovali základní třídu, která poskytla implementaci pro řadu metod, které umožňují odvozeným třídám sdílet kód.</span><span class="sxs-lookup"><span data-stu-id="d89e7-305">In the previous example, you defined a base class that provided an implementation for a number of methods to allow derived classes to share code.</span></span> <span data-ttu-id="d89e7-306">V mnoha případech se však neočekává, že základní třída poskytuje implementaci.</span><span class="sxs-lookup"><span data-stu-id="d89e7-306">In many cases, however, the base class is not expected to provide an implementation.</span></span> <span data-ttu-id="d89e7-307">Místo toho základní třída je *abstraktní třída,* která deklaruje *abstraktní metody*; slouží jako šablona, která definuje členy, které musí každá odvozená třída implementovat.</span><span class="sxs-lookup"><span data-stu-id="d89e7-307">Instead, the base class is an *abstract class* that declares *abstract methods*; it serves as a template that defines the members that each derived class must implement.</span></span> <span data-ttu-id="d89e7-308">Obvykle v abstraktní základní třídy implementace každého odvozeného typu je jedinečný pro tento typ.</span><span class="sxs-lookup"><span data-stu-id="d89e7-308">Typically in an abstract base class, the implementation of each derived type is unique to that type.</span></span> <span data-ttu-id="d89e7-309">Třídu jste označili abstraktním klíčovým slovem, protože `Publication` nemělo smysl vytvořit instanci objektu, i když třída poskytovala implementace funkcí, které jsou společné pro publikace.</span><span class="sxs-lookup"><span data-stu-id="d89e7-309">You marked the class with the abstract keyword because it made no sense to instantiate a `Publication` object, although the class did provide implementations of functionality common to publications.</span></span>

<span data-ttu-id="d89e7-310">Například každý uzavřený dvourozměrný geometrický tvar obsahuje dvě vlastnosti: oblast, vnitřní rozsah tvaru; a obvodu, nebo vzdálenost podél okrajů tvaru.</span><span class="sxs-lookup"><span data-stu-id="d89e7-310">For example, each closed two-dimensional geometric shape includes two properties: area, the inner extent of the shape; and perimeter, or the distance along the edges of the shape.</span></span> <span data-ttu-id="d89e7-311">Způsob výpočtu těchto vlastností však zcela závisí na konkrétním tvaru.</span><span class="sxs-lookup"><span data-stu-id="d89e7-311">The way in which these properties are calculated, however, depends completely on the specific shape.</span></span> <span data-ttu-id="d89e7-312">Vzorec pro výpočet obvodu (nebo obvodu) kruhu se například liší od vzorce trojúhelníku.</span><span class="sxs-lookup"><span data-stu-id="d89e7-312">The formula for calculating the perimeter (or circumference) of a circle, for example, is different from that of a triangle.</span></span> <span data-ttu-id="d89e7-313">Třída `Shape` je `abstract` třída `abstract` s metodami.</span><span class="sxs-lookup"><span data-stu-id="d89e7-313">The `Shape` class is an `abstract` class with `abstract` methods.</span></span> <span data-ttu-id="d89e7-314">To znamená, že odvozené třídy sdílejí stejné funkce, ale tyto odvozené třídy implementují tuto funkci odlišně.</span><span class="sxs-lookup"><span data-stu-id="d89e7-314">That indicates derived classes share the same functionality, but those derived classes implement that functionality differently.</span></span>

<span data-ttu-id="d89e7-315">Následující příklad definuje abstraktní základní `Shape` třídu s názvem, která definuje dvě vlastnosti: `Area` a `Perimeter`.</span><span class="sxs-lookup"><span data-stu-id="d89e7-315">The following example defines an abstract base class named `Shape` that defines two properties: `Area` and `Perimeter`.</span></span> <span data-ttu-id="d89e7-316">Kromě označení třídy [pomocí klíčového](../language-reference/keywords/abstract.md) slova abstract je každý člen instance také označen [abstraktním](../language-reference/keywords/abstract.md) klíčovým slovem.</span><span class="sxs-lookup"><span data-stu-id="d89e7-316">In addition to marking the class with the [abstract](../language-reference/keywords/abstract.md) keyword, each instance member is also marked with the [abstract](../language-reference/keywords/abstract.md) keyword.</span></span> <span data-ttu-id="d89e7-317">V tomto `Shape` případě také <xref:System.Object.ToString%2A?displayProperty=nameWithType> přepíše metodu vrátit název typu, spíše než jeho plně kvalifikovaný název.</span><span class="sxs-lookup"><span data-stu-id="d89e7-317">In this case, `Shape` also overrides the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method to return the name of the type, rather than its fully qualified name.</span></span> <span data-ttu-id="d89e7-318">A definuje dva statické `GetArea` členy `GetPerimeter`a , které umožňují volajícím snadno načíst oblast a obvod instance libovolné odvozené třídy.</span><span class="sxs-lookup"><span data-stu-id="d89e7-318">And it defines two static members, `GetArea` and `GetPerimeter`, that allow callers to easily retrieve the area and perimeter of an instance of any derived class.</span></span> <span data-ttu-id="d89e7-319">Když předáte instanci odvozené třídy jedné z těchto metod, runtime volá přepsání metody odvozené třídy.</span><span class="sxs-lookup"><span data-stu-id="d89e7-319">When you pass an instance of a derived class to either of these methods, the runtime calls the method override of the derived class.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/shape.cs#1)]

<span data-ttu-id="d89e7-320">Potom můžete odvodit některé třídy z, `Shape` které představují určité obrazce.</span><span class="sxs-lookup"><span data-stu-id="d89e7-320">You can then derive some classes from `Shape` that represent specific shapes.</span></span> <span data-ttu-id="d89e7-321">Následující příklad definuje tři `Triangle`třídy , `Rectangle`, a `Circle`.</span><span class="sxs-lookup"><span data-stu-id="d89e7-321">The following example defines three classes, `Triangle`, `Rectangle`, and `Circle`.</span></span> <span data-ttu-id="d89e7-322">Každý používá vzorec jedinečný pro daný obrazec k výpočtu plochy a obvodu.</span><span class="sxs-lookup"><span data-stu-id="d89e7-322">Each uses a formula unique for that particular shape to compute the area and perimeter.</span></span> <span data-ttu-id="d89e7-323">Některé odvozené třídy také definují vlastnosti, například `Rectangle.Diagonal` a `Circle.Diameter`, které jsou jedinečné pro obrazec, který představují.</span><span class="sxs-lookup"><span data-stu-id="d89e7-323">Some of the derived classes also define properties, such as `Rectangle.Diagonal` and `Circle.Diameter`, that are unique to the shape that they represent.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/shape.cs#2)]

<span data-ttu-id="d89e7-324">Následující příklad používá objekty `Shape`odvozené z .</span><span class="sxs-lookup"><span data-stu-id="d89e7-324">The following example uses objects derived from `Shape`.</span></span> <span data-ttu-id="d89e7-325">Konkretizovat pole objektů odvozených z `Shape` a volá `Shape` statické metody třídy, která obtéká hodnoty vlastností vrátit. `Shape`</span><span class="sxs-lookup"><span data-stu-id="d89e7-325">It instantiates an array of objects derived from `Shape` and calls the static methods of the `Shape` class, which wraps return `Shape` property values.</span></span> <span data-ttu-id="d89e7-326">Runtime načte hodnoty z přepsaných vlastností odvozených typů.</span><span class="sxs-lookup"><span data-stu-id="d89e7-326">The runtime retrieves values from the overridden properties of the derived types.</span></span> <span data-ttu-id="d89e7-327">Příklad také přetypuje každý `Shape` objekt v poli na jeho odvozený typ a pokud je `Shape`přetypovost úspěšná, načte vlastnosti této konkrétní podtřídy .</span><span class="sxs-lookup"><span data-stu-id="d89e7-327">The example also casts each `Shape` object in the array to its derived type and, if the cast succeeds, retrieves properties of that particular subclass of `Shape`.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/shape.cs#3)]

## <a name="see-also"></a><span data-ttu-id="d89e7-328">Viz také</span><span class="sxs-lookup"><span data-stu-id="d89e7-328">See also</span></span>

- [<span data-ttu-id="d89e7-329">Třídy a objekty</span><span class="sxs-lookup"><span data-stu-id="d89e7-329">Classes and objects</span></span>](../tour-of-csharp/classes-and-objects.md)
- [<span data-ttu-id="d89e7-330">Dědičnost (Průvodce programováním v C#)</span><span class="sxs-lookup"><span data-stu-id="d89e7-330">Inheritance (C# Programming Guide)</span></span>](../programming-guide/classes-and-structs/inheritance.md)
