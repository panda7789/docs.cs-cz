---
title: Jak porovnat řetězce - Průvodce C#
description: Naučte se, jak porovnat a seřadit hodnoty řetězce, s nebo bez případu, s nebo bez pořadí specifické pro jazykovou verzi
ms.date: 10/03/2018
helpviewer_keywords:
- strings [C#], comparison
- comparing strings [C#]
ms.openlocfilehash: dda3ec8cb6a0131867e6ea3bb0cf7199d86058ff
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 03/14/2020
ms.locfileid: "73973324"
---
# <a name="how-to-compare-strings-in-c"></a><span data-ttu-id="f5363-103">Jak porovnat řetězce v C\#</span><span class="sxs-lookup"><span data-stu-id="f5363-103">How to compare strings in C\#</span></span>

<span data-ttu-id="f5363-104">Porovnáte řetězce odpovědět na jednu ze dvou otázek: "Jsou tyto dva řetězce stejné?"</span><span class="sxs-lookup"><span data-stu-id="f5363-104">You compare strings to answer one of two questions: "Are these two strings equal?"</span></span> <span data-ttu-id="f5363-105">nebo "V jakém pořadí by měly být tyto řetězce umístěny při jejich třídění?"</span><span class="sxs-lookup"><span data-stu-id="f5363-105">or "In what order should these strings be placed when sorting them?"</span></span>

<span data-ttu-id="f5363-106">Tyto dvě otázky jsou komplikovány faktory, které ovlivňují porovnání řetězců:</span><span class="sxs-lookup"><span data-stu-id="f5363-106">Those two questions are complicated by factors that affect string comparisons:</span></span>

- <span data-ttu-id="f5363-107">Můžete zvolit posuzované nebo jazykové srovnání.</span><span class="sxs-lookup"><span data-stu-id="f5363-107">You can choose an ordinal or linguistic comparison.</span></span>
- <span data-ttu-id="f5363-108">Můžete si vybrat, jestli záleží na případu.</span><span class="sxs-lookup"><span data-stu-id="f5363-108">You can choose if case matters.</span></span>
- <span data-ttu-id="f5363-109">Můžete zvolit porovnání specifické pro jazykovou verzi.</span><span class="sxs-lookup"><span data-stu-id="f5363-109">You can choose culture-specific comparisons.</span></span>
- <span data-ttu-id="f5363-110">Jazykové porovnání jsou závislé na jazykové verzi a platformě.</span><span class="sxs-lookup"><span data-stu-id="f5363-110">Linguistic comparisons are culture and platform-dependent.</span></span>

[!INCLUDE[interactive-note](~/includes/csharp-interactive-note.md)]

<span data-ttu-id="f5363-111">Při porovnávání řetězců, definujete pořadí mezi nimi.</span><span class="sxs-lookup"><span data-stu-id="f5363-111">When you compare strings, you define an order among them.</span></span> <span data-ttu-id="f5363-112">Porovnání se používají k řazení posloupnosti řetězců.</span><span class="sxs-lookup"><span data-stu-id="f5363-112">Comparisons are used to sort a sequence of strings.</span></span> <span data-ttu-id="f5363-113">Jakmile je sekvence ve známém pořadí, je snazší vyhledávat, a to jak pro software, tak pro člověka.</span><span class="sxs-lookup"><span data-stu-id="f5363-113">Once the sequence is in a known order, it is easier to search, both for software and for humans.</span></span> <span data-ttu-id="f5363-114">Jiné porovnání může zkontrolovat, zda řetězce jsou stejné.</span><span class="sxs-lookup"><span data-stu-id="f5363-114">Other comparisons may check if strings are the same.</span></span> <span data-ttu-id="f5363-115">Tyto kontroly stejnosti jsou podobné rovnosti, ale některé rozdíly, jako jsou rozdíly v případech, mohou být ignorovány.</span><span class="sxs-lookup"><span data-stu-id="f5363-115">These sameness checks are similar to equality, but some differences, such as case differences, may be ignored.</span></span>

## <a name="default-ordinal-comparisons"></a><span data-ttu-id="f5363-116">Výchozí číselné porovnání</span><span class="sxs-lookup"><span data-stu-id="f5363-116">Default ordinal comparisons</span></span>

<span data-ttu-id="f5363-117">Ve výchozím nastavení nejběžnější operace:</span><span class="sxs-lookup"><span data-stu-id="f5363-117">By default, the most common operations:</span></span>

- <xref:System.String.CompareTo%2A?displayProperty=nameWithType>
- <xref:System.String.Equals%2A?displayProperty=nameWithType>
- <span data-ttu-id="f5363-118"><xref:System.String.op_Equality%2A?displayProperty=nameWithType>a <xref:System.String.op_Inequality%2A?displayProperty=nameWithType>, to [znamená, `==` `!=`že provozovatelé rovnosti a ](../language-reference/operators/equality-operators.md#string-equality), resp.</span><span class="sxs-lookup"><span data-stu-id="f5363-118"><xref:System.String.op_Equality%2A?displayProperty=nameWithType> and <xref:System.String.op_Inequality%2A?displayProperty=nameWithType>, that is, [equality operators `==` and `!=`](../language-reference/operators/equality-operators.md#string-equality), respectively</span></span>

<span data-ttu-id="f5363-119">proveďte řadové porovnání rozlišující malá a velká písmena a v případě potřeby použijte aktuální jazykovou verzi.</span><span class="sxs-lookup"><span data-stu-id="f5363-119">perform a case-sensitive ordinal comparison and, if necessary, use the current culture.</span></span> <span data-ttu-id="f5363-120">Následující příklad ukazuje, že:</span><span class="sxs-lookup"><span data-stu-id="f5363-120">The following example demonstrates that:</span></span>

[!code-csharp-interactive[Comparing strings using an ordinal comparison](../../../samples/snippets/csharp/how-to/strings/CompareStrings.cs#1)]

<span data-ttu-id="f5363-121">Výchozí řadové porovnání nebere v úvahu jazyková pravidla při porovnávání řetězců.</span><span class="sxs-lookup"><span data-stu-id="f5363-121">The default ordinal comparison doesn't take linguistic rules into account when comparing strings.</span></span> <span data-ttu-id="f5363-122">Porovnává binární hodnotu každého <xref:System.Char> objektu ve dvou řetězcích.</span><span class="sxs-lookup"><span data-stu-id="f5363-122">It compares the binary value of each <xref:System.Char> object in two strings.</span></span> <span data-ttu-id="f5363-123">V důsledku toho je výchozí řadové porovnání také rozlišování velkých a malých písmen.</span><span class="sxs-lookup"><span data-stu-id="f5363-123">As a result, the default ordinal comparison is also case-sensitive.</span></span>

<span data-ttu-id="f5363-124">Všimněte si, že <xref:System.String.Equals%2A?displayProperty=nameWithType> test `==` rovnosti s a a `!=` <xref:System.String.CompareTo%2A?displayProperty=nameWithType> operátory se liší od porovnání řetězců pomocí metody a. <xref:System.String.Compare(System.String,System.String)?displayProperty=nameWithType)></span><span class="sxs-lookup"><span data-stu-id="f5363-124">Note that the test for equality with <xref:System.String.Equals%2A?displayProperty=nameWithType> and the `==` and `!=` operators differs from string comparison using the <xref:System.String.CompareTo%2A?displayProperty=nameWithType> and <xref:System.String.Compare(System.String,System.String)?displayProperty=nameWithType)> methods.</span></span> <span data-ttu-id="f5363-125">Zatímco testy rovnosti provést případ rozlišování ordinální porovnání, metody porovnání provést případ rozlišování, jazyková verze citlivé porovnání pomocí aktuální jazykové verze.</span><span class="sxs-lookup"><span data-stu-id="f5363-125">While the tests for equality perform a case-sensitive ordinal comparison, the comparison methods perform a case-sensitive, culture-sensitive comparison using the current culture.</span></span> <span data-ttu-id="f5363-126">Vzhledem k tomu, že výchozí metody porovnání často provádět různé typy porovnání, doporučujeme vždy provést záměr kódu jasné voláním přetížení, které explicitně určuje typ porovnání provést.</span><span class="sxs-lookup"><span data-stu-id="f5363-126">Because the default comparison methods often perform different types of comparisons, we recommend that you always make the intent of your code clear by calling an overload that explicitly specifies the type of comparison to perform.</span></span>

## <a name="case-insensitive-ordinal-comparisons"></a><span data-ttu-id="f5363-127">Ordinální porovnání bez rozlišování velkých a malých písmen</span><span class="sxs-lookup"><span data-stu-id="f5363-127">Case-insensitive ordinal comparisons</span></span>

<span data-ttu-id="f5363-128">Tato <xref:System.String.Equals(System.String,System.StringComparison)?displayProperty=nameWithType> metoda umožňuje zadat <xref:System.StringComparison> hodnotu<xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="f5363-128">The <xref:System.String.Equals(System.String,System.StringComparison)?displayProperty=nameWithType> method enables you to specify a <xref:System.StringComparison> value of <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType></span></span>
<span data-ttu-id="f5363-129">pro poslané číslovky bez rozlišování velkých a malých písmen.</span><span class="sxs-lookup"><span data-stu-id="f5363-129">for a case-insensitive ordinal comparison.</span></span> <span data-ttu-id="f5363-130">Existuje také statická <xref:System.String.Compare(System.String,System.String,System.StringComparison)?displayProperty=nameWithType> metoda, která provádí porovnání ordinal bez rozlišování velkých a malých písmen, pokud zadáte hodnotu <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> argumentu. <xref:System.StringComparison></span><span class="sxs-lookup"><span data-stu-id="f5363-130">There is also a static <xref:System.String.Compare(System.String,System.String,System.StringComparison)?displayProperty=nameWithType> method that performs a case-insensitive ordinal comparison if you specify a value of <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> for the <xref:System.StringComparison> argument.</span></span> <span data-ttu-id="f5363-131">Ty jsou uvedeny v následujícím kódu:</span><span class="sxs-lookup"><span data-stu-id="f5363-131">These are shown in the following code:</span></span>

[!code-csharp-interactive[Comparing strings ignoring case](../../../samples/snippets/csharp/how-to/strings/CompareStrings.cs#2)]

<span data-ttu-id="f5363-132">Při provádění rozlišování velkých a malých písmen řadové porovnání, tyto metody používají konvencí skříně [invariantní jazykové verze](xref:System.Globalization.CultureInfo.InvariantCulture).</span><span class="sxs-lookup"><span data-stu-id="f5363-132">When performing a case-insensitive ordinal comparison, these methods use the casing conventions of the [invariant culture](xref:System.Globalization.CultureInfo.InvariantCulture).</span></span>

## <a name="linguistic-comparisons"></a><span data-ttu-id="f5363-133">Jazyková srovnání</span><span class="sxs-lookup"><span data-stu-id="f5363-133">Linguistic comparisons</span></span>

<span data-ttu-id="f5363-134">Řetězce lze také objednat pomocí jazykových pravidel pro aktuální jazykovou verzi.</span><span class="sxs-lookup"><span data-stu-id="f5363-134">Strings can also be ordered using linguistic rules for the current culture.</span></span>
<span data-ttu-id="f5363-135">To se někdy označuje jako "pořadí řazení slov".</span><span class="sxs-lookup"><span data-stu-id="f5363-135">This is sometimes referred to as "word sort order."</span></span> <span data-ttu-id="f5363-136">Při provádění jazykového porovnání mohou mít některé nealfanumerické znaky unicode přiřazeny speciální váhy.</span><span class="sxs-lookup"><span data-stu-id="f5363-136">When you perform a linguistic comparison, some nonalphanumeric Unicode characters might have special weights assigned.</span></span> <span data-ttu-id="f5363-137">Například pomlčka "-" může mít velmi malou váhu přiřazenou tak, aby se vedle sebe vedle sebe zobrazovaly "co-op" a "coop" v pořadí řazení.</span><span class="sxs-lookup"><span data-stu-id="f5363-137">For example, the hyphen "-" may have a very small weight assigned to it so that "co-op" and "coop" appear next to each other in sort order.</span></span> <span data-ttu-id="f5363-138">Kromě toho některé znaky Unicode může být <xref:System.Char> ekvivalentní posloupnost instancí.</span><span class="sxs-lookup"><span data-stu-id="f5363-138">In addition, some Unicode characters may be equivalent to a sequence of <xref:System.Char> instances.</span></span> <span data-ttu-id="f5363-139">Následující příklad používá frázi "Tančí na ulici".</span><span class="sxs-lookup"><span data-stu-id="f5363-139">The following example uses the phrase "They dance in the street."</span></span> <span data-ttu-id="f5363-140">v němčině s "ss" (U+0073 U+0073) v jednom řetězci a "ß" (U+00DF) v jiném.</span><span class="sxs-lookup"><span data-stu-id="f5363-140">in German with the "ss" (U+0073 U+0073) in one string and 'ß' (U+00DF) in another.</span></span> <span data-ttu-id="f5363-141">Lingvisticky (v systému Windows), "ss" se rovná německé Esszet: 'ß' znak v obou "en-US" a "de-DE" kultury.</span><span class="sxs-lookup"><span data-stu-id="f5363-141">Linguistically (in Windows), "ss" is equal to the German Esszet: 'ß' character in both the "en-US" and "de-DE" cultures.</span></span>

[!code-csharp-interactive[Comparing strings using linguistic rules](../../../samples/snippets/csharp/how-to/strings/CompareStrings.cs#3)]

<span data-ttu-id="f5363-142">Tato ukázka ukazuje povahu jazykového porovnání závislé na operačním systému.</span><span class="sxs-lookup"><span data-stu-id="f5363-142">This sample demonstrates the operating system-dependent nature of linguistic comparisons.</span></span> <span data-ttu-id="f5363-143">Hostitelem interaktivního okna je hostitel Linuxu.</span><span class="sxs-lookup"><span data-stu-id="f5363-143">The host for the interactive window is a Linux host.</span></span> <span data-ttu-id="f5363-144">Jazykové a posvěcené porovnání dosáhnout stejných výsledků.</span><span class="sxs-lookup"><span data-stu-id="f5363-144">The linguistic and ordinal comparisons produce the same results.</span></span> <span data-ttu-id="f5363-145">Pokud jste spustili stejnou ukázku na hostiteli systému Windows, zobrazí se následující výstup:</span><span class="sxs-lookup"><span data-stu-id="f5363-145">If you ran this same sample on a Windows host, you would see the following output:</span></span>

```console
<coop> is less than <co-op> using invariant culture
<coop> is greater than <co-op> using ordinal comparison
<coop> is less than <cop> using invariant culture
<coop> is less than <cop> using ordinal comparison
<co-op> is less than <cop> using invariant culture
<co-op> is less than <cop> using ordinal comparison
```

<span data-ttu-id="f5363-146">V systému Windows se pořadí řazení "cop", "coop" a "co-op" změní, když změníte z jazykového porovnání na řadové porovnání.</span><span class="sxs-lookup"><span data-stu-id="f5363-146">On Windows, the sort order of "cop", "coop", and "co-op" change when you change from a linguistic comparison to an ordinal comparison.</span></span> <span data-ttu-id="f5363-147">Dvě německé věty také porovnávají odlišně pomocí různých typů porovnání.</span><span class="sxs-lookup"><span data-stu-id="f5363-147">The two German sentences also compare differently using the different comparison types.</span></span>

## <a name="comparisons-using-specific-cultures"></a><span data-ttu-id="f5363-148">Porovnání pomocí specifických kultur</span><span class="sxs-lookup"><span data-stu-id="f5363-148">Comparisons using specific cultures</span></span>

<span data-ttu-id="f5363-149">Tato ukázka ukládá <xref:System.Globalization.CultureInfo> objekty pro jazykové verze en US a de-DE.</span><span class="sxs-lookup"><span data-stu-id="f5363-149">This sample stores <xref:System.Globalization.CultureInfo> objects for the en-US and de-DE cultures.</span></span>
<span data-ttu-id="f5363-150">Porovnání se provádí pomocí <xref:System.Globalization.CultureInfo> objektu k zajištění porovnání specifické pro jazykovou verzi.</span><span class="sxs-lookup"><span data-stu-id="f5363-150">The comparisons are performed using a <xref:System.Globalization.CultureInfo> object to ensure a culture-specific comparison.</span></span>

<span data-ttu-id="f5363-151">Použitá jazyková verze ovlivňuje jazykové porovnání.</span><span class="sxs-lookup"><span data-stu-id="f5363-151">The culture used affects linguistic comparisons.</span></span> <span data-ttu-id="f5363-152">Následující příklad ukazuje výsledky porovnání dvou německých vět pomocí jazykové verze "en US" a jazykové verze "de-DE":</span><span class="sxs-lookup"><span data-stu-id="f5363-152">The following example shows the results of comparing the two German sentences using the "en-US" culture and the "de-DE" culture:</span></span>

[!code-csharp-interactive[Comparing strings across cultures](../../../samples/snippets/csharp/how-to/strings/CompareStrings.cs#4)]

<span data-ttu-id="f5363-153">Porovnání zkoumaná jazykovou verzi se obvykle používají k porovnání a řazení řetězců vstup uživatelů s jinými řetězci vstup uživatelů.</span><span class="sxs-lookup"><span data-stu-id="f5363-153">Culture-sensitive comparisons are typically used to compare and sort strings input by users with other strings input by users.</span></span> <span data-ttu-id="f5363-154">Znaky a konvence řazení těchto řetězců se mohou lišit v závislosti na národním prostředí počítače uživatele.</span><span class="sxs-lookup"><span data-stu-id="f5363-154">The characters and sorting conventions of these strings might vary depending on the locale of the user's computer.</span></span> <span data-ttu-id="f5363-155">Dokonce i řetězce, které obsahují identické znaky mohou řadit odlišně v závislosti na jazykové verzi aktuálního vlákna.</span><span class="sxs-lookup"><span data-stu-id="f5363-155">Even strings that contain identical characters might sort differently depending on the culture of the current thread.</span></span> <span data-ttu-id="f5363-156">Kromě toho zkuste tento ukázkový kód místně na počítači se systémem Windows a budete mít následující výsledky:</span><span class="sxs-lookup"><span data-stu-id="f5363-156">In addition, try this sample code locally on a Windows machine, and you will the following results:</span></span>

```console
<coop> is less than <co-op> using en-US culture
<coop> is greater than <co-op> using ordinal comparison
<coop> is less than <cop> using en-US culture
<coop> is less than <cop> using ordinal comparison
<co-op> is less than <cop> using en-US culture
<co-op> is less than <cop> using ordinal comparison
```

<span data-ttu-id="f5363-157">Jazykové porovnání jsou závislé na aktuální jazykové verzi a jsou závislé na os.</span><span class="sxs-lookup"><span data-stu-id="f5363-157">Linguistic comparisons are dependent on the current culture, and are OS dependent.</span></span> <span data-ttu-id="f5363-158">Musíte vzít v úvahu, že při práci s porovnání řetězců.</span><span class="sxs-lookup"><span data-stu-id="f5363-158">You must take that into account when you work with string comparisons.</span></span>

## <a name="linguistic-sorting-and-searching-strings-in-arrays"></a><span data-ttu-id="f5363-159">Jazykové řazení a hledání řetězců v polích</span><span class="sxs-lookup"><span data-stu-id="f5363-159">Linguistic sorting and searching strings in arrays</span></span>

<span data-ttu-id="f5363-160">Následující příklady ukazují, jak řadit a vyhledávat řetězce v poli pomocí jazykového porovnání závislého na aktuální jazykové verzi.</span><span class="sxs-lookup"><span data-stu-id="f5363-160">The following examples show how to sort and search for strings in an array using a linguistic comparison dependent on the current culture.</span></span> <span data-ttu-id="f5363-161">Použijete statické <xref:System.Array> metody, <xref:System.StringComparer?displayProperty=nameWithType> které trvat parametr.</span><span class="sxs-lookup"><span data-stu-id="f5363-161">You use the static <xref:System.Array> methods that take a <xref:System.StringComparer?displayProperty=nameWithType> parameter.</span></span>

<span data-ttu-id="f5363-162">Tento příklad ukazuje, jak seřadit pole řetězců pomocí aktuální jazykové verze:</span><span class="sxs-lookup"><span data-stu-id="f5363-162">This example shows how to sort an array of strings using the current culture:</span></span>

[!code-csharp-interactive[Sorting an array of strings](../../../samples/snippets/csharp/how-to/strings/CompareStrings.cs#5)]

<span data-ttu-id="f5363-163">Po seřazení pole můžete vyhledávat položky pomocí binárního vyhledávání.</span><span class="sxs-lookup"><span data-stu-id="f5363-163">Once the array is sorted, you can search for entries using a binary search.</span></span> <span data-ttu-id="f5363-164">Binární hledání začíná uprostřed kolekce k určení, která polovina kolekce bude obsahovat požadovaný řetězec.</span><span class="sxs-lookup"><span data-stu-id="f5363-164">A binary search starts in the middle of the collection to determine which half of the collection would contain the sought string.</span></span> <span data-ttu-id="f5363-165">Každé následné porovnání rozdělí zbývající část kolekce na polovinu.</span><span class="sxs-lookup"><span data-stu-id="f5363-165">Each subsequent comparison subdivides the remaining part of the collection in half.</span></span>  <span data-ttu-id="f5363-166">Pole je seřazeno pomocí . <xref:System.StringComparer.CurrentCulture?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="f5363-166">The array is sorted using the <xref:System.StringComparer.CurrentCulture?displayProperty=nameWithType>.</span></span> <span data-ttu-id="f5363-167">Místní funkce `ShowWhere` zobrazuje informace o tom, kde byl řetězec nalezen.</span><span class="sxs-lookup"><span data-stu-id="f5363-167">The local function `ShowWhere` displays information about where the string was found.</span></span> <span data-ttu-id="f5363-168">Pokud řetězec nebyl nalezen, vrácená hodnota označuje, kde by byl, kdyby byl nalezen.</span><span class="sxs-lookup"><span data-stu-id="f5363-168">If the string was not found, the returned value indicates where it would be if it were found.</span></span>

[!code-csharp-interactive[Searching in a sorted array](../../../samples/snippets/csharp/how-to/strings/CompareStrings.cs#6)]

## <a name="ordinal-sorting-and-searching-in-collections"></a><span data-ttu-id="f5363-169">Řadové třídění a vyhledávání ve sbírkách</span><span class="sxs-lookup"><span data-stu-id="f5363-169">Ordinal sorting and searching in collections</span></span>

<span data-ttu-id="f5363-170">Následující kód používá <xref:System.Collections.Generic.List%601?displayProperty=nameWithType> třídu kolekce k ukládání řetězců.</span><span class="sxs-lookup"><span data-stu-id="f5363-170">The following code uses the <xref:System.Collections.Generic.List%601?displayProperty=nameWithType> collection class to store strings.</span></span> <span data-ttu-id="f5363-171">Řetězce jsou seřazeny <xref:System.Collections.Generic.List%601.Sort%2A?displayProperty=nameWithType> pomocí metody.</span><span class="sxs-lookup"><span data-stu-id="f5363-171">The strings are sorted using the <xref:System.Collections.Generic.List%601.Sort%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="f5363-172">Tato metoda potřebuje delegáta, který porovnává a objednávky dva řetězce.</span><span class="sxs-lookup"><span data-stu-id="f5363-172">This method needs a delegate that compares and orders two strings.</span></span> <span data-ttu-id="f5363-173">Metoda <xref:System.String.CompareTo%2A?displayProperty=nameWithType> poskytuje tuto funkci porovnání.</span><span class="sxs-lookup"><span data-stu-id="f5363-173">The <xref:System.String.CompareTo%2A?displayProperty=nameWithType> method provides that comparison function.</span></span> <span data-ttu-id="f5363-174">Spusťte ukázku a dodržujte pořadí.</span><span class="sxs-lookup"><span data-stu-id="f5363-174">Run the sample and observe the order.</span></span> <span data-ttu-id="f5363-175">Tato operace řazení používá řadové řazení rozlišující malá a velká písmena.</span><span class="sxs-lookup"><span data-stu-id="f5363-175">This sort operation uses an ordinal case sensitive sort.</span></span> <span data-ttu-id="f5363-176">Statické <xref:System.String.Compare%2A?displayProperty=nameWithType> metody byste použili k určení různých pravidel porovnání.</span><span class="sxs-lookup"><span data-stu-id="f5363-176">You would use the static <xref:System.String.Compare%2A?displayProperty=nameWithType> methods to specify different comparison rules.</span></span>

[!code-csharp-interactive[Sorting a list of strings](../../../samples/snippets/csharp/how-to/strings/CompareStrings.cs#7)]

<span data-ttu-id="f5363-177">Po seřazení lze seznam řetězců prohledávat pomocí binárního vyhledávání.</span><span class="sxs-lookup"><span data-stu-id="f5363-177">Once sorted, the list of strings can be searched using a binary search.</span></span> <span data-ttu-id="f5363-178">Následující ukázka ukazuje, jak prohledávat seřazené uvedené pomocí stejné funkce porovnání.</span><span class="sxs-lookup"><span data-stu-id="f5363-178">The following sample shows how to search the sorted listed using the same comparison function.</span></span> <span data-ttu-id="f5363-179">Místní funkce `ShowWhere` ukazuje, kde je nebo by byl hledaný text:</span><span class="sxs-lookup"><span data-stu-id="f5363-179">The local function `ShowWhere` shows where the sought text is or would be:</span></span>

[!code-csharp-interactive[csProgGuideStrings#11](../../../samples/snippets/csharp/how-to/strings/CompareStrings.cs#8)]

<span data-ttu-id="f5363-180">Při řazení a vyhledávání vždy používejte stejný typ porovnání.</span><span class="sxs-lookup"><span data-stu-id="f5363-180">Always make sure to use the same type of comparison for sorting and searching.</span></span> <span data-ttu-id="f5363-181">Použití různých typů porovnání pro řazení a vyhledávání přináší neočekávané výsledky.</span><span class="sxs-lookup"><span data-stu-id="f5363-181">Using different comparison types for sorting and searching produces unexpected results.</span></span>

<span data-ttu-id="f5363-182">Kolekce <xref:System.Collections.Hashtable?displayProperty=nameWithType>třídy, jako <xref:System.Collections.Generic.List%601?displayProperty=nameWithType> je například , <xref:System.StringComparer?displayProperty=nameWithType> <xref:System.Collections.Generic.Dictionary%602?displayProperty=nameWithType>a mají konstruktory, `string`které berou parametr, když je typ prvků nebo klíčů .</span><span class="sxs-lookup"><span data-stu-id="f5363-182">Collection classes such as <xref:System.Collections.Hashtable?displayProperty=nameWithType>, <xref:System.Collections.Generic.Dictionary%602?displayProperty=nameWithType>, and <xref:System.Collections.Generic.List%601?displayProperty=nameWithType> have constructors that take a <xref:System.StringComparer?displayProperty=nameWithType> parameter when the type of the elements or keys is `string`.</span></span> <span data-ttu-id="f5363-183">Obecně byste měli použít tyto konstruktory, kdykoli <xref:System.StringComparer.Ordinal?displayProperty=nameWithType> <xref:System.StringComparer.OrdinalIgnoreCase?displayProperty=nameWithType>je to možné, a určit buď nebo .</span><span class="sxs-lookup"><span data-stu-id="f5363-183">In general, you should use these constructors whenever possible, and specify either <xref:System.StringComparer.Ordinal?displayProperty=nameWithType> or <xref:System.StringComparer.OrdinalIgnoreCase?displayProperty=nameWithType>.</span></span>

## <a name="reference-equality-and-string-interning"></a><span data-ttu-id="f5363-184">Referenční rovnost a interning řetězců</span><span class="sxs-lookup"><span data-stu-id="f5363-184">Reference equality and string interning</span></span>

<span data-ttu-id="f5363-185">Žádný ze vzorků <xref:System.Object.ReferenceEquals%2A>nepoužil .</span><span class="sxs-lookup"><span data-stu-id="f5363-185">None of the samples have used <xref:System.Object.ReferenceEquals%2A>.</span></span> <span data-ttu-id="f5363-186">Tato metoda určuje, pokud dva řetězce jsou stejný objekt.</span><span class="sxs-lookup"><span data-stu-id="f5363-186">This method determines if two strings are the same object.</span></span> <span data-ttu-id="f5363-187">To může vést k nekonzistentní výsledky v porovnání řetězců.</span><span class="sxs-lookup"><span data-stu-id="f5363-187">This can lead to inconsistent results in string comparisons.</span></span> <span data-ttu-id="f5363-188">Následující příklad ukazuje *funkci interning řetězce* jazyka C#.</span><span class="sxs-lookup"><span data-stu-id="f5363-188">The following example demonstrates the *string interning* feature of C#.</span></span> <span data-ttu-id="f5363-189">Když program deklaruje dvě nebo více identických proměnných řetězce, kompilátor je všechny uloží do stejného umístění.</span><span class="sxs-lookup"><span data-stu-id="f5363-189">When a program declares two or more identical string variables, the compiler stores them all in the same location.</span></span> <span data-ttu-id="f5363-190">Voláním <xref:System.Object.ReferenceEquals%2A> metody uvidíte, že dva řetězce skutečně odkazují na stejný objekt v paměti.</span><span class="sxs-lookup"><span data-stu-id="f5363-190">By calling the <xref:System.Object.ReferenceEquals%2A> method, you can see that the two strings actually refer to the same object in memory.</span></span> <span data-ttu-id="f5363-191">Použijte <xref:System.String.Copy%2A?displayProperty=nameWithType> metodu, aby se zabránilo interning.</span><span class="sxs-lookup"><span data-stu-id="f5363-191">Use the <xref:System.String.Copy%2A?displayProperty=nameWithType> method to avoid interning.</span></span> <span data-ttu-id="f5363-192">Po nastolování kopie mají dva řetězce různá umístění úložiště, i když mají stejnou hodnotu.</span><span class="sxs-lookup"><span data-stu-id="f5363-192">After the copy has been made, the two strings have different storage locations, even though they have the same value.</span></span> <span data-ttu-id="f5363-193">Spusťte následující ukázku, `a` `b` která ukazuje, že řetězce a jsou *internovány,* což znamená, že sdílejí stejné úložiště.</span><span class="sxs-lookup"><span data-stu-id="f5363-193">Run the following sample to show that strings `a` and `b` are *interned* meaning they share the same storage.</span></span> <span data-ttu-id="f5363-194">Struny `a` a `c` nejsou.</span><span class="sxs-lookup"><span data-stu-id="f5363-194">The strings `a` and `c` are not.</span></span>

[!code-csharp-interactive[Demonstrating string interning](../../../samples/snippets/csharp/how-to/strings/CompareStrings.cs#9)]

> [!NOTE]
> <span data-ttu-id="f5363-195">Při testování rovnosti řetězců, měli byste použít metody, které explicitně určit, jaký druh porovnání máte v úmyslu provést.</span><span class="sxs-lookup"><span data-stu-id="f5363-195">When you test for equality of strings, you should use the methods that explicitly specify what kind of comparison you intend to perform.</span></span> <span data-ttu-id="f5363-196">Váš kód je mnohem více udržovatelný a čitelný.</span><span class="sxs-lookup"><span data-stu-id="f5363-196">Your code is much more maintainable and readable.</span></span> <span data-ttu-id="f5363-197">Použijte přetížení metody <xref:System.String?displayProperty=nameWithType> a <xref:System.Array?displayProperty=nameWithType> třídy, které <xref:System.StringComparison> mají parametr výčtu.</span><span class="sxs-lookup"><span data-stu-id="f5363-197">Use the overloads of the methods of the <xref:System.String?displayProperty=nameWithType> and <xref:System.Array?displayProperty=nameWithType> classes that take a <xref:System.StringComparison> enumeration parameter.</span></span> <span data-ttu-id="f5363-198">Můžete zadat, jaký typ porovnání provést.</span><span class="sxs-lookup"><span data-stu-id="f5363-198">You specify which type of comparison to perform.</span></span> <span data-ttu-id="f5363-199">Vyhněte `==` `!=` se použití a operátory při testování rovnosti.</span><span class="sxs-lookup"><span data-stu-id="f5363-199">Avoid using the `==` and `!=` operators when you test for equality.</span></span> <span data-ttu-id="f5363-200">Metody <xref:System.String.CompareTo%2A?displayProperty=nameWithType> instance vždy provádět řadové porovnání rozlišování velkých a malých písmen.</span><span class="sxs-lookup"><span data-stu-id="f5363-200">The <xref:System.String.CompareTo%2A?displayProperty=nameWithType> instance methods always perform an ordinal case-sensitive comparison.</span></span> <span data-ttu-id="f5363-201">Jsou primárně vhodné pro řazení řetězců abecedně.</span><span class="sxs-lookup"><span data-stu-id="f5363-201">They are primarily suited for ordering strings alphabetically.</span></span>

<span data-ttu-id="f5363-202">Můžete intern řetězec nebo načíst odkaz na existující internovaný řetězec voláním <xref:System.String.Intern%2A?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="f5363-202">You can intern a string or retrieve a reference to an existing interned string by calling the <xref:System.String.Intern%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="f5363-203">Chcete-li zjistit, zda je <xref:System.String.IsInterned%2A?displayProperty=nameWithType> řetězec internován, zavolejte metodu.</span><span class="sxs-lookup"><span data-stu-id="f5363-203">To determine whether a string is interned, call the <xref:System.String.IsInterned%2A?displayProperty=nameWithType> method.</span></span>

## <a name="see-also"></a><span data-ttu-id="f5363-204">Viz také</span><span class="sxs-lookup"><span data-stu-id="f5363-204">See also</span></span>

- <xref:System.Globalization.CultureInfo?displayProperty=nameWithType>
- <xref:System.StringComparer?displayProperty=nameWithType>
- [<span data-ttu-id="f5363-205">Řetězce</span><span class="sxs-lookup"><span data-stu-id="f5363-205">Strings</span></span>](../programming-guide/strings/index.md)
- [<span data-ttu-id="f5363-206">Porovnávání řetězců</span><span class="sxs-lookup"><span data-stu-id="f5363-206">Comparing Strings</span></span>](../../standard/base-types/comparing.md)
- [<span data-ttu-id="f5363-207">Globalizace a lokalizace aplikací</span><span class="sxs-lookup"><span data-stu-id="f5363-207">Globalizing and Localizing Applications</span></span>](/visualstudio/ide/globalizing-and-localizing-applications)
