---
title: 'Asynchronní programování v jazyce C #'
description: Přehled podpory jazyka C# pro asynchronní programování pomocí asynchronního, operátoru await, úlohy a úlohy<T>
ms.date: 06/04/2020
ms.openlocfilehash: 992ccd3a015653ea9ee13dfc309d47711ad0fca4
ms.sourcegitcommit: e02d17b2cf9c1258dadda4810a5e6072a0089aee
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 07/01/2020
ms.locfileid: "85619712"
---
# <a name="asynchronous-programming-with-async-and-await"></a><span data-ttu-id="00962-103">Asynchronní programování pomocí modifikátoru Async a operátoru Await</span><span class="sxs-lookup"><span data-stu-id="00962-103">Asynchronous programming with async and await</span></span>

<span data-ttu-id="00962-104">[Asynchronní programovací model úlohy (klepněte na)](task-asynchronous-programming-model.md) poskytuje abstrakci pro asynchronní kód.</span><span class="sxs-lookup"><span data-stu-id="00962-104">The [Task asynchronous programming model (TAP)](task-asynchronous-programming-model.md) provides an abstraction over asynchronous code.</span></span> <span data-ttu-id="00962-105">Kód můžete napsat jako posloupnost příkazů, stejně jako vždycky.</span><span class="sxs-lookup"><span data-stu-id="00962-105">You write code as a sequence of statements, just like always.</span></span> <span data-ttu-id="00962-106">Tento kód si můžete přečíst, jako by byl každý příkaz dokončen před dalším začátkem.</span><span class="sxs-lookup"><span data-stu-id="00962-106">You can read that code as though each statement completes before the next begins.</span></span> <span data-ttu-id="00962-107">Kompilátor provádí řadu transformací, protože některé z těchto příkazů mohou začít pracovat a vracet <xref:System.Threading.Tasks.Task> , který představuje probíhající práci.</span><span class="sxs-lookup"><span data-stu-id="00962-107">The compiler performs a number of transformations because some of those statements may start work and return a <xref:System.Threading.Tasks.Task> that represents the ongoing work.</span></span>

<span data-ttu-id="00962-108">To je cílem této syntaxe: umožňuje povolit kód, který se čte jako sekvence příkazů, ale provádí se v mnohem složitějším pořadí založeném na externím přidělení prostředků a po dokončení úkolů.</span><span class="sxs-lookup"><span data-stu-id="00962-108">That's the goal of this syntax: enable code that reads like a sequence of statements, but executes in a much more complicated order based on external resource allocation and when tasks complete.</span></span> <span data-ttu-id="00962-109">Podobá se tomu, jak lidé dávají pokyny pro procesy, které zahrnují asynchronní úlohy.</span><span class="sxs-lookup"><span data-stu-id="00962-109">It's analogous to how people give instructions for processes that include asynchronous tasks.</span></span> <span data-ttu-id="00962-110">V tomto článku použijete příklad pokynů pro vytvoření snídani k tomu, abyste viděli, jak `async` `await` klíčová slova a usnadňují odůvodnění kódu, který obsahuje řadu asynchronních instrukcí.</span><span class="sxs-lookup"><span data-stu-id="00962-110">Throughout this article, you'll use an example of instructions for making a breakfast to see how the `async` and `await` keywords make it easier to reason about code, that includes a series of asynchronous instructions.</span></span> <span data-ttu-id="00962-111">Měli byste napsat pokyny, jako je v následujícím seznamu, abyste se vysvětlují, jak vytvořit snídani:</span><span class="sxs-lookup"><span data-stu-id="00962-111">You'd write the instructions something like the following list to explain how to make a breakfast:</span></span>

1. <span data-ttu-id="00962-112">Nalijte konvičku z kávy.</span><span class="sxs-lookup"><span data-stu-id="00962-112">Pour a cup of coffee.</span></span>
1. <span data-ttu-id="00962-113">Zastavte pánev a pak dvě vejce v SRJ.</span><span class="sxs-lookup"><span data-stu-id="00962-113">Heat up a pan, then fry two eggs.</span></span>
1. <span data-ttu-id="00962-114">SRJ tři řezy slanina</span><span class="sxs-lookup"><span data-stu-id="00962-114">Fry three slices of bacon.</span></span>
1. <span data-ttu-id="00962-115">Informační zprávy jsou dvě části chleba.</span><span class="sxs-lookup"><span data-stu-id="00962-115">Toast two pieces of bread.</span></span>
1. <span data-ttu-id="00962-116">Přidejte máslo a zaseknutí do informačních zpráv.</span><span class="sxs-lookup"><span data-stu-id="00962-116">Add butter and jam to the toast.</span></span>
1. <span data-ttu-id="00962-117">Nalijte sklo oranžové šťávy.</span><span class="sxs-lookup"><span data-stu-id="00962-117">Pour a glass of orange juice.</span></span>

<span data-ttu-id="00962-118">Pokud máte zkušenosti s vařením, spusťte tyto pokyny **asynchronně**.</span><span class="sxs-lookup"><span data-stu-id="00962-118">If you have experience with cooking, you'd execute those instructions **asynchronously**.</span></span> <span data-ttu-id="00962-119">Začnete zahříváním pánev pro vejce a pak zahájíte slanina.</span><span class="sxs-lookup"><span data-stu-id="00962-119">You'd start warming the pan for eggs, then start the bacon.</span></span> <span data-ttu-id="00962-120">Vložili jste chléb do informačního pole a pak vejce začali.</span><span class="sxs-lookup"><span data-stu-id="00962-120">You'd put the bread in the toaster, then start the eggs.</span></span> <span data-ttu-id="00962-121">V každém kroku procesu byste úlohu spustili a pak jste si měli pozor na úkoly, které jsou připravené na vaši pozornost.</span><span class="sxs-lookup"><span data-stu-id="00962-121">At each step of the process, you'd start a task, then turn your attention to tasks that are ready for your attention.</span></span>

<span data-ttu-id="00962-122">Vaření snídaně je dobrým příkladem asynchronní práce, která není paralelní.</span><span class="sxs-lookup"><span data-stu-id="00962-122">Cooking breakfast is a good example of asynchronous work that isn't parallel.</span></span> <span data-ttu-id="00962-123">Všechny tyto úlohy může zvládnout jedna osoba (nebo vlákno).</span><span class="sxs-lookup"><span data-stu-id="00962-123">One person (or thread) can handle all these tasks.</span></span> <span data-ttu-id="00962-124">Pokračováním v analogovém režimu může jedna osoba provést asynchronní zpracování asynchronně spuštěním další úlohy před prvním dokončením.</span><span class="sxs-lookup"><span data-stu-id="00962-124">Continuing the breakfast analogy, one person can make breakfast asynchronously by starting the next task before the first completes.</span></span> <span data-ttu-id="00962-125">Vaření bude postupovat bez ohledu na to, jestli ho někdo sleduje.</span><span class="sxs-lookup"><span data-stu-id="00962-125">The cooking progresses whether or not someone is watching it.</span></span> <span data-ttu-id="00962-126">Jakmile začnete zahříváním pánev pro vejce, můžete začít Frying slanina.</span><span class="sxs-lookup"><span data-stu-id="00962-126">As soon as you start warming the pan for the eggs, you can begin frying the bacon.</span></span> <span data-ttu-id="00962-127">Po spuštění slanina můžete přidat chléb do informačního části.</span><span class="sxs-lookup"><span data-stu-id="00962-127">Once the bacon starts, you can put the bread into the toaster.</span></span>

<span data-ttu-id="00962-128">Pro paralelní algoritmus budete potřebovat více cooků (neboli vláken).</span><span class="sxs-lookup"><span data-stu-id="00962-128">For a parallel algorithm, you'd need multiple cooks (or threads).</span></span> <span data-ttu-id="00962-129">To by mělo být vejce, jedna slanina a tak dále.</span><span class="sxs-lookup"><span data-stu-id="00962-129">One would make the eggs, one the bacon, and so on.</span></span> <span data-ttu-id="00962-130">Každé z nich by se zaměřilo jenom na jeden úkol.</span><span class="sxs-lookup"><span data-stu-id="00962-130">Each one would be focused on just that one task.</span></span> <span data-ttu-id="00962-131">Každé Cookovy (nebo vlákno) se zablokuje synchronně, čeká se, až bude slanina připravený k převrácení, nebo informační zprávy, které se mají blokovat.</span><span class="sxs-lookup"><span data-stu-id="00962-131">Each cook (or thread) would be blocked synchronously waiting for bacon to be ready to flip, or the toast to pop.</span></span>

<span data-ttu-id="00962-132">Nyní zvažte stejné pokyny, které jsou zapsány jako příkazy jazyka C#:</span><span class="sxs-lookup"><span data-stu-id="00962-132">Now, consider those same instructions written as C# statements:</span></span>

:::code language="csharp" source="snippets/index/AsyncBreakfast-starter/Program.cs" highlight="8-27":::

:::image type="content" source="media/synchronous-breakfast.png" alt-text="synchronní snídaně":::

<span data-ttu-id="00962-134">Synchronně připravený úkol snídaně trval přibližně 30 minut, protože celková hodnota je součet každé jednotlivé úlohy.</span><span class="sxs-lookup"><span data-stu-id="00962-134">The synchronously prepared breakfast, took roughly 30 minutes because the total is the sum of each individual task.</span></span>

> [!NOTE]
> <span data-ttu-id="00962-135">`Coffee`Třídy, `Egg` ,, a `Bacon` `Toast` `Juice` jsou prázdné.</span><span class="sxs-lookup"><span data-stu-id="00962-135">The `Coffee`, `Egg`, `Bacon`, `Toast`, and `Juice` classes are empty.</span></span> <span data-ttu-id="00962-136">Jsou pouze třídy značek pro účely ukázky, neobsahují žádné vlastnosti a neposkytují žádné jiné účely.</span><span class="sxs-lookup"><span data-stu-id="00962-136">They are simply marker classes for the purpose of demonstration, contain no properties, and serve no other purpose.</span></span>

<span data-ttu-id="00962-137">Počítače neinterpretují tyto pokyny stejným způsobem jako lidé.</span><span class="sxs-lookup"><span data-stu-id="00962-137">Computers don't interpret those instructions the same way people do.</span></span> <span data-ttu-id="00962-138">Počítač bude zablokovat každý příkaz, dokud nebude dokončeno dokončení práce, než přejde k dalšímu příkazu.</span><span class="sxs-lookup"><span data-stu-id="00962-138">The computer will block on each statement until the work is complete before moving on to the next statement.</span></span> <span data-ttu-id="00962-139">Tím se vytvoří nevyhovující snídaně.</span><span class="sxs-lookup"><span data-stu-id="00962-139">That creates an unsatisfying breakfast.</span></span> <span data-ttu-id="00962-140">Pozdější úkoly by nemusely být spuštěny, dokud se předchozí úkoly nedokončí.</span><span class="sxs-lookup"><span data-stu-id="00962-140">The later tasks wouldn't be started until the earlier tasks had completed.</span></span> <span data-ttu-id="00962-141">Vytvoření snídaně by trvat mnohem delší dobu a některé položky by byly před odesláním nedoručeny.</span><span class="sxs-lookup"><span data-stu-id="00962-141">It would take much longer to create the breakfast, and some items would have gotten cold before being served.</span></span>

<span data-ttu-id="00962-142">Pokud chcete, aby počítač prováděl výše uvedené pokyny asynchronně, je nutné napsat asynchronní kód.</span><span class="sxs-lookup"><span data-stu-id="00962-142">If you want the computer to execute the above instructions asynchronously, you must write asynchronous code.</span></span>

<span data-ttu-id="00962-143">Tyto aspekty jsou důležité pro programy, které dnes napíšete.</span><span class="sxs-lookup"><span data-stu-id="00962-143">These concerns are important for the programs you write today.</span></span> <span data-ttu-id="00962-144">Při psaní klientských programů budete chtít, aby uživatelské rozhraní reagovalo na vstup uživatele.</span><span class="sxs-lookup"><span data-stu-id="00962-144">When you write client programs, you want the UI to be responsive to user input.</span></span> <span data-ttu-id="00962-145">Vaše aplikace by se neměla po stažení dat z webu jevit jako zmrazená.</span><span class="sxs-lookup"><span data-stu-id="00962-145">Your application shouldn't make a phone appear frozen while it's downloading data from the web.</span></span> <span data-ttu-id="00962-146">Když píšete serverové programy, nechcete, aby byla vlákna blokovaná.</span><span class="sxs-lookup"><span data-stu-id="00962-146">When you write server programs, you don't want threads blocked.</span></span> <span data-ttu-id="00962-147">Tato vlákna mohou obsluhovat jiné požadavky.</span><span class="sxs-lookup"><span data-stu-id="00962-147">Those threads could be serving other requests.</span></span> <span data-ttu-id="00962-148">Použití synchronního kódu v případě, že existují asynchronní alternativy, neuškodí schopnost horizontálního navýšení kapacity snížit kapacitu.</span><span class="sxs-lookup"><span data-stu-id="00962-148">Using synchronous code when asynchronous alternatives exist hurts your ability to scale out less expensively.</span></span> <span data-ttu-id="00962-149">Platíte za tato blokovaná vlákna.</span><span class="sxs-lookup"><span data-stu-id="00962-149">You pay for those blocked threads.</span></span>

<span data-ttu-id="00962-150">Úspěšné moderní aplikace vyžadují asynchronní kód.</span><span class="sxs-lookup"><span data-stu-id="00962-150">Successful modern applications require asynchronous code.</span></span> <span data-ttu-id="00962-151">Bez podpory jazyků, psaní zpětných volání vyžadovaných asynchronním kódem, události dokončení nebo jiné způsob, který zakrývá původní záměr kódu.</span><span class="sxs-lookup"><span data-stu-id="00962-151">Without language support, writing asynchronous code required callbacks, completion events, or other means that obscured the original intent of the code.</span></span> <span data-ttu-id="00962-152">Výhodou synchronního kódu je, že je snadné ho pochopit.</span><span class="sxs-lookup"><span data-stu-id="00962-152">The advantage of the synchronous code is that it's easy to understand.</span></span> <span data-ttu-id="00962-153">Podrobné akce usnadňují kontrolu a pochopení.</span><span class="sxs-lookup"><span data-stu-id="00962-153">The step-by-step actions make it easy to scan and understand.</span></span> <span data-ttu-id="00962-154">Tradiční asynchronní modely vám pomohly soustředit se na asynchronní povahu kódu, nikoli na základní akce kódu.</span><span class="sxs-lookup"><span data-stu-id="00962-154">Traditional asynchronous models forced you to focus on the asynchronous nature of the code, not on the fundamental actions of the code.</span></span>

## <a name="dont-block-await-instead"></a><span data-ttu-id="00962-155">Neblokovat, místo toho očekávat</span><span class="sxs-lookup"><span data-stu-id="00962-155">Don't block, await instead</span></span>

<span data-ttu-id="00962-156">Předchozí kód demonstruje špatný postup: sestavení synchronního kódu pro provádění asynchronních operací.</span><span class="sxs-lookup"><span data-stu-id="00962-156">The preceding code demonstrates a bad practice: constructing synchronous code to perform asynchronous operations.</span></span> <span data-ttu-id="00962-157">Jak je zapsáno, tento kód zablokuje vlákno, které ho spouští, od jakékoli jiné práce.</span><span class="sxs-lookup"><span data-stu-id="00962-157">As written, this code blocks the thread executing it from doing any other work.</span></span> <span data-ttu-id="00962-158">Nedojde k přerušení, dokud nebudou dokončeny žádné úlohy.</span><span class="sxs-lookup"><span data-stu-id="00962-158">It won't be interrupted while any of the tasks are in progress.</span></span> <span data-ttu-id="00962-159">Může to být tak, jak jste v informačním části postari po vložení chleba do.</span><span class="sxs-lookup"><span data-stu-id="00962-159">It would be as though you stared at the toaster after putting the bread in.</span></span> <span data-ttu-id="00962-160">Na vás bude nikdo mluvit, dokud nebudou informační zprávy odebrány.</span><span class="sxs-lookup"><span data-stu-id="00962-160">You'd ignore anyone talking to you until the toast popped.</span></span>

<span data-ttu-id="00962-161">Pojďme začít aktualizací tohoto kódu, aby vlákno neblokovalo úlohy spuštěné.</span><span class="sxs-lookup"><span data-stu-id="00962-161">Let's start by updating this code so that the thread doesn't block while tasks are running.</span></span> <span data-ttu-id="00962-162">`await`Klíčové slovo poskytuje neblokující způsob spuštění úlohy a pak pokračuje v provádění po dokončení této úlohy.</span><span class="sxs-lookup"><span data-stu-id="00962-162">The `await` keyword provides a non-blocking way to start a task, then continue execution when that task completes.</span></span> <span data-ttu-id="00962-163">Jednoduchá asynchronní verze kódu pro vytvoření snídani by vypadala jako následující fragment kódu:</span><span class="sxs-lookup"><span data-stu-id="00962-163">A simple asynchronous version of the make a breakfast code would look like the following snippet:</span></span>

:::code language="csharp" source="snippets/index/AsyncBreakfast-V2/Program.cs" id="SnippetMain":::

> [!IMPORTANT]
> <span data-ttu-id="00962-164">Celkový uplynulý čas je zhruba stejný jako počáteční verze synchonous.</span><span class="sxs-lookup"><span data-stu-id="00962-164">The total elapsed time is roughly the same as the initial synchonous version.</span></span> <span data-ttu-id="00962-165">Kód ještě využije některé klíčové funkce asynchronního programování.</span><span class="sxs-lookup"><span data-stu-id="00962-165">The code has yet to take advantage of some of the key features of asynchronous programming.</span></span>

> [!TIP]
> <span data-ttu-id="00962-166">Tělo metody `FryEggsAsync` , `FryBaconAsync` a `ToastBreadAsync` byly aktualizovány, aby vracely hodnoty, `Task<Egg>` `Task<Bacon>` a `Task<Toast>` v uvedeném pořadí.</span><span class="sxs-lookup"><span data-stu-id="00962-166">The method bodies of the `FryEggsAsync`, `FryBaconAsync`, and `ToastBreadAsync` have all been updated to return `Task<Egg>`, `Task<Bacon>`, and `Task<Toast>` respectively.</span></span> <span data-ttu-id="00962-167">Metody se přejmenují z původní verze tak, aby zahrnovaly příponu "Async".</span><span class="sxs-lookup"><span data-stu-id="00962-167">The methods are renamed from their original version to include the "Async" suffix.</span></span> <span data-ttu-id="00962-168">Jejich implementace se zobrazují jako součást [finální verze](#final-version) dále v tomto článku.</span><span class="sxs-lookup"><span data-stu-id="00962-168">Their implementations are shown as part of the [final version](#final-version) later in this article.</span></span>

<span data-ttu-id="00962-169">Tento kód se neblokuje, pokud jsou vejce nebo slanina vaření.</span><span class="sxs-lookup"><span data-stu-id="00962-169">This code doesn't block while the eggs or the bacon are cooking.</span></span> <span data-ttu-id="00962-170">Tento kód v takovém případě nespustí žádné další úlohy.</span><span class="sxs-lookup"><span data-stu-id="00962-170">This code won't start any other tasks though.</span></span> <span data-ttu-id="00962-171">Informační zprávy do informačního oddělení byste pořád umístili do informačních zpráv a tam, kde se neobjeví.</span><span class="sxs-lookup"><span data-stu-id="00962-171">You'd still put the toast in the toaster and stare at it until it pops.</span></span> <span data-ttu-id="00962-172">Ale aspoň, budete reagovat na kohokoli, kdo si přeje vaši pozornost.</span><span class="sxs-lookup"><span data-stu-id="00962-172">But at least, you'd respond to anyone that wanted your attention.</span></span> <span data-ttu-id="00962-173">V rámci restaurace, kde je umístěno více objednávek, může Cook Cook začít jinou snídani, zatímco první je vaření.</span><span class="sxs-lookup"><span data-stu-id="00962-173">In a restaurant where multiple orders are placed, the cook could start another breakfast while the first is cooking.</span></span>

<span data-ttu-id="00962-174">Vlákno, které pracuje na snídani, není nyní blokované při čekání na spuštěnou úlohu, která ještě nebyla dokončena.</span><span class="sxs-lookup"><span data-stu-id="00962-174">Now, the thread working on the breakfast isn't blocked while awaiting any started task that hasn't yet finished.</span></span> <span data-ttu-id="00962-175">U některých aplikací je tato změna potřebná.</span><span class="sxs-lookup"><span data-stu-id="00962-175">For some applications, this change is all that's needed.</span></span> <span data-ttu-id="00962-176">Aplikace grafického uživatelského rozhraní pořád reaguje na uživatele pouze touto změnou.</span><span class="sxs-lookup"><span data-stu-id="00962-176">A GUI application still responds to the user with just this change.</span></span> <span data-ttu-id="00962-177">V tomto scénáři ale potřebujete víc.</span><span class="sxs-lookup"><span data-stu-id="00962-177">However, for this scenario, you want more.</span></span> <span data-ttu-id="00962-178">Nechcete, aby se jednotlivé úlohy komponenty prováděly sekvenčně.</span><span class="sxs-lookup"><span data-stu-id="00962-178">You don't want each of the component tasks to be executed sequentially.</span></span> <span data-ttu-id="00962-179">Před čekáním na dokončení předchozího úkolu je lepší spustit každou z těchto úloh.</span><span class="sxs-lookup"><span data-stu-id="00962-179">It's better to start each of the component tasks before awaiting the previous task's completion.</span></span>

## <a name="start-tasks-concurrently"></a><span data-ttu-id="00962-180">Spustit souběžně úlohy</span><span class="sxs-lookup"><span data-stu-id="00962-180">Start tasks concurrently</span></span>

<span data-ttu-id="00962-181">V mnoha scénářích chcete okamžitě spustit několik nezávislých úloh.</span><span class="sxs-lookup"><span data-stu-id="00962-181">In many scenarios, you want to start several independent tasks immediately.</span></span> <span data-ttu-id="00962-182">Po dokončení jednotlivých úkolů můžete pokračovat v práci, která je připravená.</span><span class="sxs-lookup"><span data-stu-id="00962-182">Then, as each task finishes, you can continue other work that's ready.</span></span> <span data-ttu-id="00962-183">V analogické pracovní snídaně to je způsob, jak rychle získat snídani.</span><span class="sxs-lookup"><span data-stu-id="00962-183">In the breakfast analogy, that's how you get breakfast done more quickly.</span></span> <span data-ttu-id="00962-184">Všechno se ale také dokončí blízko stejnou dobu.</span><span class="sxs-lookup"><span data-stu-id="00962-184">You also get everything done close to the same time.</span></span> <span data-ttu-id="00962-185">Získáte horkou snídani.</span><span class="sxs-lookup"><span data-stu-id="00962-185">You'll get a hot breakfast.</span></span>

<span data-ttu-id="00962-186"><xref:System.Threading.Tasks.Task?displayProperty=nameWithType>Související typy jsou třídy, které můžete použít k odůvodnění úloh, které probíhají.</span><span class="sxs-lookup"><span data-stu-id="00962-186">The <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> and related types are classes you can use to reason about tasks that are in progress.</span></span> <span data-ttu-id="00962-187">To vám umožňuje psát kód, který se bude lépe podobat způsobu, jakým jste ve skutečnosti vytvořili snídani.</span><span class="sxs-lookup"><span data-stu-id="00962-187">That enables you to write code that more closely resembles the way you'd actually create breakfast.</span></span> <span data-ttu-id="00962-188">Začít vaření na vejce, slanina a informační zprávy ve stejnou dobu.</span><span class="sxs-lookup"><span data-stu-id="00962-188">You'd start cooking the eggs, bacon, and toast at the same time.</span></span> <span data-ttu-id="00962-189">Vzhledem k tomu, že každá z nich vyžaduje akci, byste měli věnovat pozornost této úloze, pořídit další akci a pak očekávat něco jiného, co vyžaduje vaši pozornost.</span><span class="sxs-lookup"><span data-stu-id="00962-189">As each requires action, you'd turn your attention to that task, take care of the next action, then await for something else that requires your attention.</span></span>

<span data-ttu-id="00962-190">Spustíte úlohu a podržíte ji pro <xref:System.Threading.Tasks.Task> objekt, který představuje práci.</span><span class="sxs-lookup"><span data-stu-id="00962-190">You start a task and hold on to the <xref:System.Threading.Tasks.Task> object that represents the work.</span></span> <span data-ttu-id="00962-191">Než budete `await` s jeho výsledkem pracovat, budete mít každý úkol.</span><span class="sxs-lookup"><span data-stu-id="00962-191">You'll `await` each task before working with its result.</span></span>

<span data-ttu-id="00962-192">Pojďme udělat tyto změny kódu snídani.</span><span class="sxs-lookup"><span data-stu-id="00962-192">Let's make these changes to the breakfast code.</span></span> <span data-ttu-id="00962-193">Prvním krokem je ukládat úlohy pro operace, když se spouštějí, a nečekají na ně:</span><span class="sxs-lookup"><span data-stu-id="00962-193">The first step is to store the tasks for operations when they start, rather than awaiting them:</span></span>

```csharp
Coffee cup = PourCoffee();
Console.WriteLine("coffee is ready");

Task<Egg> eggsTask = FryEggsAsync(2);
Egg eggs = await eggsTask;
Console.WriteLine("eggs are ready");

Task<Bacon> baconTask = FryBaconAsync(3);
Bacon bacon = await baconTask;
Console.WriteLine("bacon is ready");

Task<Toast> toastTask = ToastBreadAsync(2);
Toast toast = await toastTask;
ApplyButter(toast);
ApplyJam(toast);
Console.WriteLine("toast is ready");

Juice oj = PourOJ();
Console.WriteLine("oj is ready");
Console.WriteLine("Breakfast is ready!");
```

<span data-ttu-id="00962-194">Dále můžete přesunout `await` příkazy pro slanina a vejce na konec metody před obsluhou snídaně:</span><span class="sxs-lookup"><span data-stu-id="00962-194">Next, you can move the `await` statements for the bacon and eggs to the end of the method, before serving breakfast:</span></span>

```csharp
Coffee cup = PourCoffee();
Console.WriteLine("coffee is ready");

Task<Egg> eggsTask = FryEggsAsync(2);
Task<Bacon> baconTask = FryBaconAsync(3);
Task<Toast> toastTask = ToastBreadAsync(2);

Toast toast = await toastTask;
ApplyButter(toast);
ApplyJam(toast);
Console.WriteLine("toast is ready");
Juice oj = PourOJ();
Console.WriteLine("oj is ready");

Egg eggs = await eggsTask;
Console.WriteLine("eggs are ready");
Bacon bacon = await baconTask;
Console.WriteLine("bacon is ready");

Console.WriteLine("Breakfast is ready!");
```

:::image type="content" source="media/asynchronous-breakfast.png" alt-text="asynchronní snídaně":::

<span data-ttu-id="00962-196">Asynchronně připravená snídaně trvala přibližně 20 minut, protože některé úlohy byly schopné spustit souběžně.</span><span class="sxs-lookup"><span data-stu-id="00962-196">The asynchronously prepared breakfast took roughly 20 minutes, this is because some tasks were able to run concurrently.</span></span>

<span data-ttu-id="00962-197">Předchozí kód funguje lépe.</span><span class="sxs-lookup"><span data-stu-id="00962-197">The preceding code works better.</span></span> <span data-ttu-id="00962-198">Současně spustíte všechny asynchronní úlohy.</span><span class="sxs-lookup"><span data-stu-id="00962-198">You start all the asynchronous tasks at once.</span></span> <span data-ttu-id="00962-199">Každou úlohu můžete očekávat pouze v případě, že potřebujete výsledky.</span><span class="sxs-lookup"><span data-stu-id="00962-199">You await each task only when you need the results.</span></span> <span data-ttu-id="00962-200">Předchozí kód může být podobný kódu ve webové aplikaci, který vytváří požadavky na různé mikroslužby, a pak kombinuje výsledky do jediné stránky.</span><span class="sxs-lookup"><span data-stu-id="00962-200">The preceding code may be similar to code in a web application that makes requests of different microservices, then combines the results into a single page.</span></span> <span data-ttu-id="00962-201">Všechny požadavky okamžitě provedete `await` a pak všechny tyto úlohy a vytvoříte webovou stránku.</span><span class="sxs-lookup"><span data-stu-id="00962-201">You'll make all the requests immediately, then `await` all those tasks and compose the web page.</span></span>

## <a name="composition-with-tasks"></a><span data-ttu-id="00962-202">Složení s úkoly</span><span class="sxs-lookup"><span data-stu-id="00962-202">Composition with tasks</span></span>

 <span data-ttu-id="00962-203">Máte všechno připravené k snídani ve stejnou dobu s výjimkou informačních zpráv.</span><span class="sxs-lookup"><span data-stu-id="00962-203">You have everything ready for breakfast at the same time except the toast.</span></span> <span data-ttu-id="00962-204">Zpřístupnění informačních zpráv je složením asynchronní operace (informační zpráva o příchodu) a synchronní operace (přidání másla a zaseknutí).</span><span class="sxs-lookup"><span data-stu-id="00962-204">Making the toast is the composition of an asynchronous operation (toasting the bread), and synchronous operations (adding the butter and the jam).</span></span> <span data-ttu-id="00962-205">Aktualizace tohoto kódu ilustruje důležitý koncept:</span><span class="sxs-lookup"><span data-stu-id="00962-205">Updating this code illustrates an important concept:</span></span>

> [!IMPORTANT]
> <span data-ttu-id="00962-206">Složení asynchronní operace následované synchronní prací je asynchronní operace.</span><span class="sxs-lookup"><span data-stu-id="00962-206">The composition of an asynchronous operation followed by synchronous work is an asynchronous operation.</span></span> <span data-ttu-id="00962-207">Pokud je libovolná část operace asynchronní, je celá operace asynchronní, pokud je uvedena jinak.</span><span class="sxs-lookup"><span data-stu-id="00962-207">Stated another way, if any portion of an operation is asynchronous, the entire operation is asynchronous.</span></span>

<span data-ttu-id="00962-208">Předchozí kód vám ukázal, že můžete použít <xref:System.Threading.Tasks.Task> objekty nebo <xref:System.Threading.Tasks.Task%601> pro udržení spuštěných úloh.</span><span class="sxs-lookup"><span data-stu-id="00962-208">The preceding code showed you that you can use <xref:System.Threading.Tasks.Task> or <xref:System.Threading.Tasks.Task%601> objects to hold running tasks.</span></span> <span data-ttu-id="00962-209">`await`Každý úkol před použitím jeho výsledku.</span><span class="sxs-lookup"><span data-stu-id="00962-209">You `await` each task before using its result.</span></span> <span data-ttu-id="00962-210">Dalším krokem je vytvoření metod, které reprezentují kombinaci jiné práce.</span><span class="sxs-lookup"><span data-stu-id="00962-210">The next step is to create methods that represent the combination of other work.</span></span> <span data-ttu-id="00962-211">Před tím, než zachováte snídani, chcete čekat na úkol, který představuje informační zprávu, před přidáním másla a zaseknutím.</span><span class="sxs-lookup"><span data-stu-id="00962-211">Before serving breakfast, you want to await the task that represents toasting the bread before adding butter and jam.</span></span> <span data-ttu-id="00962-212">Tuto práci můžete vyjádřit pomocí následujícího kódu:</span><span class="sxs-lookup"><span data-stu-id="00962-212">You can represent that work with the following code:</span></span>

:::code language="csharp" source="snippets/index/AsyncBreakfast-V3/Program.cs" id="SnippetComposeToastTask":::

<span data-ttu-id="00962-213">Předchozí metoda má `async` v podpisu modifikátor.</span><span class="sxs-lookup"><span data-stu-id="00962-213">The preceding method has the `async` modifier in its signature.</span></span> <span data-ttu-id="00962-214">To signalizuje kompilátoru, že tato metoda obsahuje `await` příkaz, obsahuje asynchronní operace.</span><span class="sxs-lookup"><span data-stu-id="00962-214">That signals to the compiler that this method contains an `await` statement; it contains asynchronous operations.</span></span> <span data-ttu-id="00962-215">Tato metoda představuje úkol, který označuje chléb a pak přidá máslo a zaseknutí.</span><span class="sxs-lookup"><span data-stu-id="00962-215">This method represents the task that toasts the bread, then adds butter and jam.</span></span> <span data-ttu-id="00962-216">Tato metoda vrátí hodnotu <xref:System.Threading.Tasks.Task%601> , která představuje složení těchto tří operací.</span><span class="sxs-lookup"><span data-stu-id="00962-216">This method returns a <xref:System.Threading.Tasks.Task%601> that represents the composition of those three operations.</span></span> <span data-ttu-id="00962-217">Hlavní blok kódu teď bude:</span><span class="sxs-lookup"><span data-stu-id="00962-217">The main block of code now becomes:</span></span>

:::code language="csharp" source="snippets/index/AsyncBreakfast-V3/Program.cs" id="SnippetMain":::

<span data-ttu-id="00962-218">Předchozí změna ukázala důležitou techniku pro práci s asynchronním kódem.</span><span class="sxs-lookup"><span data-stu-id="00962-218">The previous change illustrated an important technique for working with asynchronous code.</span></span> <span data-ttu-id="00962-219">Můžete vytvářet úkoly oddělením operací s novou metodou, která vrací úlohu.</span><span class="sxs-lookup"><span data-stu-id="00962-219">You compose tasks by separating the operations into a new method that returns a task.</span></span> <span data-ttu-id="00962-220">Můžete vybrat, kdy se má tento úkol očekávat.</span><span class="sxs-lookup"><span data-stu-id="00962-220">You can choose when to await that task.</span></span> <span data-ttu-id="00962-221">Můžete spustit souběžně jiné úkoly.</span><span class="sxs-lookup"><span data-stu-id="00962-221">You can start other tasks concurrently.</span></span>

## <a name="await-tasks-efficiently"></a><span data-ttu-id="00962-222">Pro úlohy čekají efektivně</span><span class="sxs-lookup"><span data-stu-id="00962-222">Await tasks efficiently</span></span>

<span data-ttu-id="00962-223">Řadu `await` příkazů na konci předchozího kódu lze zlepšit pomocí metod `Task` třídy.</span><span class="sxs-lookup"><span data-stu-id="00962-223">The series of `await` statements at the end of the preceding code can be improved by using methods of the `Task` class.</span></span> <span data-ttu-id="00962-224">Jedno z těchto rozhraní API je <xref:System.Threading.Tasks.Task.WhenAll%2A> , což vrátí, <xref:System.Threading.Tasks.Task> která se dokončí po dokončení všech úkolů v seznamu argumentů, jak je znázorněno v následujícím kódu:</span><span class="sxs-lookup"><span data-stu-id="00962-224">One of those APIs is <xref:System.Threading.Tasks.Task.WhenAll%2A>, which returns a <xref:System.Threading.Tasks.Task> that completes when all the tasks in its argument list have completed, as shown in the following code:</span></span>

```csharp
await Task.WhenAll(eggsTask, baconTask, toastTask);
Console.WriteLine("eggs are ready");
Console.WriteLine("bacon is ready");
Console.WriteLine("toast is ready");
Console.WriteLine("Breakfast is ready!");
```

<span data-ttu-id="00962-225">Další možností je použít <xref:System.Threading.Tasks.Task.WhenAny%2A> , který vrátí a `Task<Task>` , který se dokončí po dokončení některého z jeho argumentů.</span><span class="sxs-lookup"><span data-stu-id="00962-225">Another option is to use <xref:System.Threading.Tasks.Task.WhenAny%2A>, which returns a `Task<Task>` that completes when any of its arguments completes.</span></span> <span data-ttu-id="00962-226">Můžete očekávat vrácenou úlohu s vědomím, že již byla dokončena.</span><span class="sxs-lookup"><span data-stu-id="00962-226">You can await the returned task, knowing that it has already finished.</span></span> <span data-ttu-id="00962-227">Následující kód ukazuje, jak můžete použít <xref:System.Threading.Tasks.Task.WhenAny%2A> k čekání na dokončení první úlohy a následnému zpracování výsledku.</span><span class="sxs-lookup"><span data-stu-id="00962-227">The following code shows how you could use <xref:System.Threading.Tasks.Task.WhenAny%2A> to await the first task to finish and then process its result.</span></span> <span data-ttu-id="00962-228">Po zpracování výsledku z dokončené úlohy odstraníte tuto dokončenou úlohu ze seznamu úkolů předaných do `WhenAny` .</span><span class="sxs-lookup"><span data-stu-id="00962-228">After processing the result from the completed task, you remove that completed task from the list of tasks passed to `WhenAny`.</span></span>

```csharp
var breakfastTasks = new List<Task> { eggsTask, baconTask, toastTask };
while (breakfastTasks.Count > 0)
{
    Task finishedTask = await Task.WhenAny(breakfastTasks);
    if (finishedTask == eggsTask)
    {
        Console.WriteLine("eggs are ready");
    }
    else if (finishedTask == baconTask)
    {
        Console.WriteLine("bacon is ready");
    }
    else if (finishedTask == toastTask)
    {
        Console.WriteLine("toast is ready");
    }
    breakfastTasks.Remove(finishedTask);
}
```

<span data-ttu-id="00962-229">Po všech změnách bude finální verze kódu vypadat takto:<a id="final-version"></a></span><span class="sxs-lookup"><span data-stu-id="00962-229">After all those changes, the final version of the code looks like this: <a id="final-version"></a></span></span>
:::code language="csharp" source="snippets/index/AsyncBreakfast-final/Program.cs" highlight="9-40":::

:::image type="content" source="media/whenany-async-breakfast.png" alt-text="Když jakákoli asynchronní snídaně":::

<span data-ttu-id="00962-231">Konečná verze asynchronní přípravy snídaně trvala zhruba 15 minut, protože některé úlohy byly schopné spustit souběžně a kód byl schopný monitorovat více úloh najednou a v případě potřeby provést akci.</span><span class="sxs-lookup"><span data-stu-id="00962-231">The final version of the asynchronously prepared breakfast took roughly 15 minutes, this is because some tasks were able to run concurrently, and the code was able to monitor multiple tasks at once and only take action when it was needed.</span></span>

<span data-ttu-id="00962-232">Tento konečný kód je asynchronní.</span><span class="sxs-lookup"><span data-stu-id="00962-232">This final code is asynchronous.</span></span> <span data-ttu-id="00962-233">Přesněji odráží, jak by osoba navařené snídani.</span><span class="sxs-lookup"><span data-stu-id="00962-233">It more accurately reflects how a person would cook a breakfast.</span></span> <span data-ttu-id="00962-234">Porovnejte předchozí kód s první ukázkou kódu v tomto článku.</span><span class="sxs-lookup"><span data-stu-id="00962-234">Compare the preceding code with the first code sample in this article.</span></span> <span data-ttu-id="00962-235">Základní akce jsou stále jasné z čtení kódu.</span><span class="sxs-lookup"><span data-stu-id="00962-235">The core actions are still clear from reading the code.</span></span> <span data-ttu-id="00962-236">Tento kód si můžete přečíst stejným způsobem, jakým jste si přečetli tyto pokyny pro vytvoření snídaně na začátku tohoto článku.</span><span class="sxs-lookup"><span data-stu-id="00962-236">You can read this code the same way you'd read those instructions for making a breakfast at the beginning of this article.</span></span> <span data-ttu-id="00962-237">Jazykové funkce pro `async` a `await` poskytují překlad pro všechny uživatele, kteří se dodávají podle těchto písemných pokynů: spustit úlohy jako vy a neblokovat čekání na dokončení úkolů.</span><span class="sxs-lookup"><span data-stu-id="00962-237">The language features for `async` and `await` provide the translation every person makes to follow those written instructions: start tasks as you can and don't block waiting for tasks to complete.</span></span>

## <a name="next-steps"></a><span data-ttu-id="00962-238">Další kroky</span><span class="sxs-lookup"><span data-stu-id="00962-238">Next steps</span></span>

> [!div class="nextstepaction"]
> [<span data-ttu-id="00962-239">Další informace o modelu asynchronního programování úloh</span><span class="sxs-lookup"><span data-stu-id="00962-239">Learn about the task asynchronous programming model</span></span>](task-asynchronous-programming-model.md)
