---
title: 'Asynchronní programování v C #'
description: Přehled podpory jazyka C# pro asynchronní programování pomocí async, await, Task a Task<T>
ms.date: 03/18/2019
ms.openlocfilehash: 4cbbff0f2c48f0ec2f8befa234ea5023465a1c5d
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 03/15/2020
ms.locfileid: "79169906"
---
# <a name="asynchronous-programming-with-async-and-await"></a><span data-ttu-id="df653-103">Asynchronní programování pomocí modifikátoru Async a operátoru Await</span><span class="sxs-lookup"><span data-stu-id="df653-103">Asynchronous programming with async and await</span></span>

<span data-ttu-id="df653-104">Úloha asynchronní programovací model (TAP) poskytuje abstrakce přes asynchronní kód.</span><span class="sxs-lookup"><span data-stu-id="df653-104">The Task asynchronous programming model (TAP) provides an abstraction over asynchronous code.</span></span> <span data-ttu-id="df653-105">Píšete kód jako posloupnost příkazů, stejně jako vždy.</span><span class="sxs-lookup"><span data-stu-id="df653-105">You write code as a sequence of statements, just like always.</span></span> <span data-ttu-id="df653-106">Tento kód si můžete přečíst, jako by každý příkaz dokončen před dalším zahájením.</span><span class="sxs-lookup"><span data-stu-id="df653-106">You can read that code as though each statement completes before the next begins.</span></span> <span data-ttu-id="df653-107">Kompilátor provádí počet transformací, protože některé z těchto <xref:System.Threading.Tasks.Task> příkazů může začít pracovat a vrátit, který představuje probíhající práci.</span><span class="sxs-lookup"><span data-stu-id="df653-107">The compiler performs a number of transformations because some of those statements may start work and return a <xref:System.Threading.Tasks.Task> that represents the ongoing work.</span></span>

<span data-ttu-id="df653-108">To je cílem této syntaxe: povolit kód, který čte jako posloupnost příkazů, ale provádí v mnohem složitější pořadí na základě přidělení externích prostředků a po dokončení úkolů.</span><span class="sxs-lookup"><span data-stu-id="df653-108">That's the goal of this syntax: enable code that reads like a sequence of statements, but executes in a much more complicated order based on external resource allocation and when tasks complete.</span></span> <span data-ttu-id="df653-109">Je to analogické, jak lidé dávají pokyny pro procesy, které zahrnují asynchronní úkoly.</span><span class="sxs-lookup"><span data-stu-id="df653-109">It's analogous to how people give instructions for processes that include asynchronous tasks.</span></span> <span data-ttu-id="df653-110">V tomto článku použijete příklad pokynů pro provedení snídaně, `async` abyste `await` zjistili, jak klíčová slova a usnadňují důvod týkající se kódu, který obsahuje řadu asynchronních pokynů.</span><span class="sxs-lookup"><span data-stu-id="df653-110">Throughout this article, you'll use an example of instructions for making a breakfast to see how the `async` and `await` keywords make it easier to reason about code that includes a series of asynchronous instructions.</span></span> <span data-ttu-id="df653-111">Napsali byste pokyny něco jako následující seznam, abyste vysvětlili, jak udělat snídani:</span><span class="sxs-lookup"><span data-stu-id="df653-111">You'd write the instructions something like the following list to explain how to make a breakfast:</span></span>

1. <span data-ttu-id="df653-112">Nalijte šálek kávy.</span><span class="sxs-lookup"><span data-stu-id="df653-112">Pour a cup of coffee.</span></span>
1. <span data-ttu-id="df653-113">Zahřejte pánev, pak smažte dvě vejce.</span><span class="sxs-lookup"><span data-stu-id="df653-113">Heat up a pan, then fry two eggs.</span></span>
1. <span data-ttu-id="df653-114">Smažte tři plátky slaniny.</span><span class="sxs-lookup"><span data-stu-id="df653-114">Fry three slices of bacon.</span></span>
1. <span data-ttu-id="df653-115">Opékejte dva kusy chleba.</span><span class="sxs-lookup"><span data-stu-id="df653-115">Toast two pieces of bread.</span></span>
1. <span data-ttu-id="df653-116">Přidejte máslo a džem do toastu.</span><span class="sxs-lookup"><span data-stu-id="df653-116">Add butter and jam to the toast.</span></span>
1. <span data-ttu-id="df653-117">Nalijte sklenici pomerančového džusu.</span><span class="sxs-lookup"><span data-stu-id="df653-117">Pour a glass of orange juice.</span></span>

<span data-ttu-id="df653-118">Pokud máte zkušenosti s vařením, provedete tyto pokyny **asynchronně**.</span><span class="sxs-lookup"><span data-stu-id="df653-118">If you have experience with cooking, you'd execute those instructions **asynchronously**.</span></span> <span data-ttu-id="df653-119">Začal bys ohřívat pánev na vajíčka a pak začal slaninu.</span><span class="sxs-lookup"><span data-stu-id="df653-119">You'd start warming the pan for eggs, then start the bacon.</span></span> <span data-ttu-id="df653-120">Dal bys chleba do toustovače a pak začal s vejci.</span><span class="sxs-lookup"><span data-stu-id="df653-120">You'd put the bread in the toaster, then start the eggs.</span></span> <span data-ttu-id="df653-121">V každém kroku procesu byste zahájili úkol a pak obrátili svou pozornost na úkoly, které jsou připraveny pro vaši pozornost.</span><span class="sxs-lookup"><span data-stu-id="df653-121">At each step of the process, you'd start a task, then turn your attention to tasks that are ready for your attention.</span></span>

<span data-ttu-id="df653-122">Vaření snídaně je dobrým příkladem asynchronní práce, která není paralelní.</span><span class="sxs-lookup"><span data-stu-id="df653-122">Cooking breakfast is a good example of asynchronous work that isn't parallel.</span></span> <span data-ttu-id="df653-123">Všechny tyto úkoly zvládne jedna osoba (nebo vlákno).</span><span class="sxs-lookup"><span data-stu-id="df653-123">One person (or thread) can handle all these tasks.</span></span> <span data-ttu-id="df653-124">Pokračování snídaně analogie, jedna osoba může snídani asynchronně spuštěním další úkol před prvním dokončením.</span><span class="sxs-lookup"><span data-stu-id="df653-124">Continuing the breakfast analogy, one person can make breakfast asynchronously by starting the next task before the first completes.</span></span> <span data-ttu-id="df653-125">Vaření postupuje, zda se na to někdo dívá.</span><span class="sxs-lookup"><span data-stu-id="df653-125">The cooking progresses whether or not someone is watching it.</span></span> <span data-ttu-id="df653-126">Jakmile začnete zahřívat pánev na vejce, můžete začít smažit slaninu.</span><span class="sxs-lookup"><span data-stu-id="df653-126">As soon as you start warming the pan for the eggs, you can begin frying the bacon.</span></span> <span data-ttu-id="df653-127">Jakmile začne slanina, můžete dát chléb do toustovače.</span><span class="sxs-lookup"><span data-stu-id="df653-127">Once the bacon starts, you can put the bread into the toaster.</span></span>

<span data-ttu-id="df653-128">Pro paralelní algoritmus budete potřebovat více kuchařů (nebo vláken).</span><span class="sxs-lookup"><span data-stu-id="df653-128">For a parallel algorithm, you'd need multiple cooks (or threads).</span></span> <span data-ttu-id="df653-129">Jeden by udělal vejce, jednu slaninu a tak dále.</span><span class="sxs-lookup"><span data-stu-id="df653-129">One would make the eggs, one the bacon, and so on.</span></span> <span data-ttu-id="df653-130">Každý z nich by se zaměřil jen na jeden úkol.</span><span class="sxs-lookup"><span data-stu-id="df653-130">Each one would be focused on just that one task.</span></span> <span data-ttu-id="df653-131">Každý kuchař (nebo vlákno) by být blokovány synchronně čeká na slaninu, aby byl připraven k flip, nebo přípitek na pop.</span><span class="sxs-lookup"><span data-stu-id="df653-131">Each cook (or thread) would be blocked synchronously waiting for bacon to be ready to flip, or the toast to pop.</span></span>

<span data-ttu-id="df653-132">Nyní zvažte stejné pokyny napsané jako příkazy Jazyka C#:</span><span class="sxs-lookup"><span data-stu-id="df653-132">Now, consider those same instructions written as C# statements:</span></span>

[!code-csharp[SynchronousBreakfast](~/samples/snippets/csharp/tour-of-async/AsyncBreakfast-starter/Program.cs#Main)]

<span data-ttu-id="df653-133">Počítače neinterpretují tyto pokyny stejným způsobem jako lidé.</span><span class="sxs-lookup"><span data-stu-id="df653-133">Computers don't interpret those instructions the same way people do.</span></span> <span data-ttu-id="df653-134">Počítač bude blokovat na každém příkazu, dokud práce je dokončena před přechodem na další příkaz.</span><span class="sxs-lookup"><span data-stu-id="df653-134">The computer will block on each statement until the work is complete before moving on to the next statement.</span></span> <span data-ttu-id="df653-135">To vytváří neuspokojivou snídani.</span><span class="sxs-lookup"><span data-stu-id="df653-135">That creates an unsatisfying breakfast.</span></span> <span data-ttu-id="df653-136">Pozdější úkoly nebudou zahájeny, dokud nebudou dokončeny předchozí úkoly.</span><span class="sxs-lookup"><span data-stu-id="df653-136">The later tasks wouldn't be started until the earlier tasks had completed.</span></span> <span data-ttu-id="df653-137">Trvalo by mnohem déle, než by se snídaně vytvořila, a některé položky by se před podáváním ochladila.</span><span class="sxs-lookup"><span data-stu-id="df653-137">It would take much longer to create the breakfast, and some items would have gotten cold before being served.</span></span>

<span data-ttu-id="df653-138">Pokud chcete, aby počítač provedl výše uvedené pokyny asynchronně, musíte napsat asynchronní kód.</span><span class="sxs-lookup"><span data-stu-id="df653-138">If you want the computer to execute the above instructions asynchronously, you must write asynchronous code.</span></span>

<span data-ttu-id="df653-139">Tyto obavy jsou důležité pro programy, které píšete dnes.</span><span class="sxs-lookup"><span data-stu-id="df653-139">These concerns are important for the programs you write today.</span></span> <span data-ttu-id="df653-140">Při psaní klientských programů chcete, aby uživatelské rozhraní reagovalo na vstup uživatele.</span><span class="sxs-lookup"><span data-stu-id="df653-140">When you write client programs, you want the UI to be responsive to user input.</span></span> <span data-ttu-id="df653-141">Aplikace by neměla způsobit, že by telefon při stahování dat z webu vypadal zmrazený.</span><span class="sxs-lookup"><span data-stu-id="df653-141">Your application shouldn't make a phone appear frozen while it's downloading data from the web.</span></span> <span data-ttu-id="df653-142">Při psaní serverových programů nechcete blokovat vlákna.</span><span class="sxs-lookup"><span data-stu-id="df653-142">When you write server programs, you don't want threads blocked.</span></span> <span data-ttu-id="df653-143">Tato vlákna mohou obsluhují jiné požadavky.</span><span class="sxs-lookup"><span data-stu-id="df653-143">Those threads could be serving other requests.</span></span> <span data-ttu-id="df653-144">Použití synchronního kódu při existenci asynchronních alternativ poškozuje vaši schopnost škálovat levněji.</span><span class="sxs-lookup"><span data-stu-id="df653-144">Using synchronous code when asynchronous alternatives exist hurts your ability to scale out less expensively.</span></span> <span data-ttu-id="df653-145">Platíte za ty zablokované vlákna.</span><span class="sxs-lookup"><span data-stu-id="df653-145">You pay for those blocked threads.</span></span>

<span data-ttu-id="df653-146">Úspěšné moderní aplikace vyžadují asynchronní kód.</span><span class="sxs-lookup"><span data-stu-id="df653-146">Successful modern applications require asynchronous code.</span></span> <span data-ttu-id="df653-147">Bez jazykové podpory, psaní asynchronní kód vyžaduje zpětná volání, události dokončení nebo jiné prostředky, které zakrývaly původní záměr kódu.</span><span class="sxs-lookup"><span data-stu-id="df653-147">Without language support, writing asynchronous code required callbacks, completion events, or other means that obscured the original intent of the code.</span></span> <span data-ttu-id="df653-148">Výhodou synchronního kódu je, že je snadno pochopitelný.</span><span class="sxs-lookup"><span data-stu-id="df653-148">The advantage of the synchronous code is that it's easy to understand.</span></span> <span data-ttu-id="df653-149">Akce krok za krokem usnadňují skenování a pochopení.</span><span class="sxs-lookup"><span data-stu-id="df653-149">The step-by-step actions make it easy to scan and understand.</span></span> <span data-ttu-id="df653-150">Tradiční asynchronní modely nuceni zaměřit se na asynchronní povahu kódu, nikoli na základní akce kódu.</span><span class="sxs-lookup"><span data-stu-id="df653-150">Traditional asynchronous models forced you to focus on the asynchronous nature of the code, not on the fundamental actions of the code.</span></span>

## <a name="dont-block-await-instead"></a><span data-ttu-id="df653-151">Neblokujte, čekejte místo toho</span><span class="sxs-lookup"><span data-stu-id="df653-151">Don't block, await instead</span></span>

<span data-ttu-id="df653-152">Předchozí kód ukazuje chybný postup: vytvoření synchronního kódu k provádění asynchronních operací.</span><span class="sxs-lookup"><span data-stu-id="df653-152">The preceding code demonstrates a bad practice: constructing synchronous code to perform asynchronous operations.</span></span> <span data-ttu-id="df653-153">Jak je napsáno, tento kód blokuje vlákno provádění jej z provádění jakékoli jiné práce.</span><span class="sxs-lookup"><span data-stu-id="df653-153">As written, this code blocks the thread executing it from doing any other work.</span></span> <span data-ttu-id="df653-154">Nebude přerušena, zatímco některý z úkolů probíhá.</span><span class="sxs-lookup"><span data-stu-id="df653-154">It won't be interrupted while any of the tasks are in progress.</span></span> <span data-ttu-id="df653-155">Bylo by to, jako bys zíral na toustovač po chleba.</span><span class="sxs-lookup"><span data-stu-id="df653-155">It would be as though you stared at the toaster after putting the bread in.</span></span> <span data-ttu-id="df653-156">Ignoroval bys každého, kdo by s tebou mluvil, dokud by se neobjevil přípitek.</span><span class="sxs-lookup"><span data-stu-id="df653-156">You'd ignore anyone talking to you until the toast popped.</span></span>

<span data-ttu-id="df653-157">Začněme aktualizací tohoto kódu tak, aby vlákno neblokovalo, když jsou spuštěny úlohy.</span><span class="sxs-lookup"><span data-stu-id="df653-157">Let's start by updating this code so that the thread doesn't block while tasks are running.</span></span> <span data-ttu-id="df653-158">Klíčové `await` slovo poskytuje neblokující způsob spuštění úlohy a po dokončení této úlohy pokračujte v provádění.</span><span class="sxs-lookup"><span data-stu-id="df653-158">The `await` keyword provides a non-blocking way to start a task, then continue execution when that task completes.</span></span> <span data-ttu-id="df653-159">Jednoduchá asynchronní verze kódu make a breakfast by vypadala jako následující úryvek:</span><span class="sxs-lookup"><span data-stu-id="df653-159">A simple asynchronous version of the make a breakfast code would look like the following snippet:</span></span>

[!code-csharp[SimpleAsyncBreakfast](~/samples/snippets/csharp/tour-of-async/AsyncBreakfast-V2/Program.cs#Main)]

<span data-ttu-id="df653-160">Tento kód neblokuje, když vejce nebo slanina jsou vaření.</span><span class="sxs-lookup"><span data-stu-id="df653-160">This code doesn't block while the eggs or the bacon are cooking.</span></span> <span data-ttu-id="df653-161">Tento kód však nespustí žádné další úkoly.</span><span class="sxs-lookup"><span data-stu-id="df653-161">This code won't start any other tasks though.</span></span> <span data-ttu-id="df653-162">Pořád bys dával přípitek do toustovače a zíral na něj, dokud nevyskočil.</span><span class="sxs-lookup"><span data-stu-id="df653-162">You'd still put the toast in the toaster and stare at it until it pops.</span></span> <span data-ttu-id="df653-163">Ale aspoň bys reagoval na každého, kdo by chtěl tvou pozornost.</span><span class="sxs-lookup"><span data-stu-id="df653-163">But at least, you'd respond to anyone that wanted your attention.</span></span> <span data-ttu-id="df653-164">V restauraci, kde je umístěno více objednávek, by kuchař mohl začít další snídani, zatímco první je vaření.</span><span class="sxs-lookup"><span data-stu-id="df653-164">In a restaurant where multiple orders are placed, the cook could start another breakfast while the first is cooking.</span></span>

<span data-ttu-id="df653-165">Nyní vlákno pracující na snídani není blokováno, zatímco čeká na jakýkoli zahájený úkol, který ještě nebyl dokončen.</span><span class="sxs-lookup"><span data-stu-id="df653-165">Now, the thread working on the breakfast isn't blocked while awaiting any started task that hasn't yet finished.</span></span> <span data-ttu-id="df653-166">Pro některé aplikace je tato změna vše, co je potřeba.</span><span class="sxs-lookup"><span data-stu-id="df653-166">For some applications, this change is all that's needed.</span></span> <span data-ttu-id="df653-167">Gui aplikace stále reaguje na uživatele právě s touto změnou.</span><span class="sxs-lookup"><span data-stu-id="df653-167">A GUI application still responds to the user with just this change.</span></span> <span data-ttu-id="df653-168">Však pro tento scénář chcete další.</span><span class="sxs-lookup"><span data-stu-id="df653-168">However, for this scenario, you want more.</span></span> <span data-ttu-id="df653-169">Nechcete, aby každý z úloh komponenty, které mají být provedeny postupně.</span><span class="sxs-lookup"><span data-stu-id="df653-169">You don't want each of the component tasks to be executed sequentially.</span></span> <span data-ttu-id="df653-170">Je lepší spustit každý z úloh komponenty před čekáním na dokončení předchozího úkolu.</span><span class="sxs-lookup"><span data-stu-id="df653-170">It's better to start each of the component tasks before awaiting the previous task's completion.</span></span>

## <a name="start-tasks-concurrently"></a><span data-ttu-id="df653-171">Souběžné zahájení úloh</span><span class="sxs-lookup"><span data-stu-id="df653-171">Start tasks concurrently</span></span>

<span data-ttu-id="df653-172">V mnoha scénářích chcete okamžitě spustit několik nezávislých úloh.</span><span class="sxs-lookup"><span data-stu-id="df653-172">In many scenarios, you want to start several independent tasks immediately.</span></span> <span data-ttu-id="df653-173">Po dokončení každého úkolu pak můžete pokračovat v další práci, která je připravena.</span><span class="sxs-lookup"><span data-stu-id="df653-173">Then, as each task finishes, you can continue other work that's ready.</span></span> <span data-ttu-id="df653-174">V analogie snídaně, to je, jak se dostanete snídani udělat rychleji.</span><span class="sxs-lookup"><span data-stu-id="df653-174">In the breakfast analogy, that's how you get breakfast done more quickly.</span></span> <span data-ttu-id="df653-175">Také dostanete všechno udělat blízko ke stejnému času.</span><span class="sxs-lookup"><span data-stu-id="df653-175">You also get everything done close to the same time.</span></span> <span data-ttu-id="df653-176">Dostaneš teplou snídani.</span><span class="sxs-lookup"><span data-stu-id="df653-176">You'll get a hot breakfast.</span></span>

<span data-ttu-id="df653-177">A <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> související typy jsou třídy, které můžete použít k důvodu o probíhajících úkolech.</span><span class="sxs-lookup"><span data-stu-id="df653-177">The <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> and related types are classes you can use to reason about tasks that are in progress.</span></span> <span data-ttu-id="df653-178">To vám umožní napsat kód, který se více podobá způsobu, jakým byste skutečně vytvořit snídani.</span><span class="sxs-lookup"><span data-stu-id="df653-178">That enables you to write code that more closely resembles the way you'd actually create breakfast.</span></span> <span data-ttu-id="df653-179">Začal bys vařit vejce, slaninu a toast ve stejnou dobu.</span><span class="sxs-lookup"><span data-stu-id="df653-179">You'd start cooking the eggs, bacon, and toast at the same time.</span></span> <span data-ttu-id="df653-180">Jako každý vyžaduje akci, měli byste obrátit svou pozornost k tomuto úkolu, postarat se o další akci, pak čekají na něco jiného, co vyžaduje vaši pozornost.</span><span class="sxs-lookup"><span data-stu-id="df653-180">As each requires action, you'd turn your attention to that task, take care of the next action, then await for something else that requires your attention.</span></span>

<span data-ttu-id="df653-181">Můžete zahájit úkol a <xref:System.Threading.Tasks.Task> podržte objekt, který představuje práci.</span><span class="sxs-lookup"><span data-stu-id="df653-181">You start a task and hold on to the <xref:System.Threading.Tasks.Task> object that represents the work.</span></span> <span data-ttu-id="df653-182">Budete `await` každý úkol před prací s jeho výsledkem.</span><span class="sxs-lookup"><span data-stu-id="df653-182">You'll `await` each task before working with its result.</span></span>

<span data-ttu-id="df653-183">Pojďme udělat tyto změny v kódu snídaně.</span><span class="sxs-lookup"><span data-stu-id="df653-183">Let's make these changes to the breakfast code.</span></span> <span data-ttu-id="df653-184">Prvním krokem je uložení úkolů pro operace při jejich spuštění, nikoli jejich čekání:</span><span class="sxs-lookup"><span data-stu-id="df653-184">The first step is to store the tasks for operations when they start, rather than awaiting them:</span></span>

```csharp
Coffee cup = PourCoffee();
Console.WriteLine("coffee is ready");
Task<Egg> eggsTask = FryEggs(2);
Egg eggs = await eggsTask;
Console.WriteLine("eggs are ready");
Task<Bacon> baconTask = FryBacon(3);
Bacon bacon = await baconTask;
Console.WriteLine("bacon is ready");
Task<Toast> toastTask = ToastBread(2);
Toast toast = await toastTask;
ApplyButter(toast);
ApplyJam(toast);
Console.WriteLine("toast is ready");
Juice oj = PourOJ();
Console.WriteLine("oj is ready");

Console.WriteLine("Breakfast is ready!");
```

<span data-ttu-id="df653-185">Dále můžete přesunout `await` prohlášení o slanině a vejcích na konec metody, než servírujete snídani:</span><span class="sxs-lookup"><span data-stu-id="df653-185">Next, you can move the `await` statements for the bacon and eggs to the end of the method, before serving breakfast:</span></span>

```csharp
Coffee cup = PourCoffee();
Console.WriteLine("coffee is ready");
Task<Egg> eggsTask = FryEggs(2);
Task<Bacon> baconTask = FryBacon(3);
Task<Toast> toastTask = ToastBread(2);
Toast toast = await toastTask;
ApplyButter(toast);
ApplyJam(toast);
Console.WriteLine("toast is ready");
Juice oj = PourOJ();
Console.WriteLine("oj is ready");

Egg eggs = await eggsTask;
Console.WriteLine("eggs are ready");
Bacon bacon = await baconTask;
Console.WriteLine("bacon is ready");

Console.WriteLine("Breakfast is ready!");
```

<span data-ttu-id="df653-186">Předchozí kód funguje lépe.</span><span class="sxs-lookup"><span data-stu-id="df653-186">The preceding code works better.</span></span> <span data-ttu-id="df653-187">Spuštění všech asynchronních úloh najednou.</span><span class="sxs-lookup"><span data-stu-id="df653-187">You start all the asynchronous tasks at once.</span></span> <span data-ttu-id="df653-188">Na každý úkol čekáte pouze v případě, že potřebujete výsledky.</span><span class="sxs-lookup"><span data-stu-id="df653-188">You await each task only when you need the results.</span></span> <span data-ttu-id="df653-189">Předchozí kód může být podobný kódu ve webové aplikaci, která provádí požadavky různých mikroslužeb, pak kombinuje výsledky do jedné stránky.</span><span class="sxs-lookup"><span data-stu-id="df653-189">The preceding code may be similar to code in a web application that makes requests of different microservices, then combines the results into a single page.</span></span> <span data-ttu-id="df653-190">Budete dělat všechny požadavky okamžitě, `await` pak všechny tyto úkoly a tvoří webové stránky.</span><span class="sxs-lookup"><span data-stu-id="df653-190">You'll make all the requests immediately, then `await` all those tasks and compose the web page.</span></span>

## <a name="composition-with-tasks"></a><span data-ttu-id="df653-191">Složení s úkoly</span><span class="sxs-lookup"><span data-stu-id="df653-191">Composition with tasks</span></span>

 <span data-ttu-id="df653-192">Máte vše připravené k snídani ve stejnou dobu kromě přípitku.</span><span class="sxs-lookup"><span data-stu-id="df653-192">You have everything ready for breakfast at the same time except the toast.</span></span> <span data-ttu-id="df653-193">Tvorba toast je složení asynchronní operace (opékání chleba), a synchronní operace (přidání másla a džemu).</span><span class="sxs-lookup"><span data-stu-id="df653-193">Making the toast is the composition of an asynchronous operation (toasting the bread), and synchronous operations (adding the butter and the jam).</span></span> <span data-ttu-id="df653-194">Aktualizace tohoto kódu ilustruje důležitý koncept:</span><span class="sxs-lookup"><span data-stu-id="df653-194">Updating this code illustrates an important concept:</span></span>

> [!IMPORTANT]
> <span data-ttu-id="df653-195">Složení asynchronní operace následované synchronní prací je asynchronní operace.</span><span class="sxs-lookup"><span data-stu-id="df653-195">The composition of an asynchronous operation followed by synchronous work is an asynchronous operation.</span></span> <span data-ttu-id="df653-196">Uvedeno jiným způsobem, pokud je jakákoli část operace asynchronní, je celá operace asynchronní.</span><span class="sxs-lookup"><span data-stu-id="df653-196">Stated another way, if any portion of an operation is asynchronous, the entire operation is asynchronous.</span></span>

<span data-ttu-id="df653-197">Předchozí kód ukázal, že můžete <xref:System.Threading.Tasks.Task> <xref:System.Threading.Tasks.Task%601> použít nebo objekty pro uložení spuštěných úloh.</span><span class="sxs-lookup"><span data-stu-id="df653-197">The preceding code showed you that you can use <xref:System.Threading.Tasks.Task> or <xref:System.Threading.Tasks.Task%601> objects to hold running tasks.</span></span> <span data-ttu-id="df653-198">Každý `await` úkol před použitím jeho výsledek.</span><span class="sxs-lookup"><span data-stu-id="df653-198">You `await` each task before using its result.</span></span> <span data-ttu-id="df653-199">Dalším krokem je vytvoření metod, které představují kombinaci jiné práce.</span><span class="sxs-lookup"><span data-stu-id="df653-199">The next step is to create methods that represent the combination of other work.</span></span> <span data-ttu-id="df653-200">Před podáváním snídaně, chcete počkat na úkol, který představuje opékání chleba před přidáním másla a džemu.</span><span class="sxs-lookup"><span data-stu-id="df653-200">Before serving breakfast, you want to await the task that represents toasting the bread before adding butter and jam.</span></span> <span data-ttu-id="df653-201">Tuto práci můžete reprezentovat pomocí následujícího kódu:</span><span class="sxs-lookup"><span data-stu-id="df653-201">You can represent that work with the following code:</span></span>

[!code-csharp[ComposeToastTask](~/samples/snippets/csharp/tour-of-async/AsyncBreakfast-V3/Program.cs#ComposeToastTask)]

<span data-ttu-id="df653-202">Předchozí metoda má `async` modifikátor ve svém podpisu.</span><span class="sxs-lookup"><span data-stu-id="df653-202">The preceding method has the `async` modifier in its signature.</span></span> <span data-ttu-id="df653-203">To signalizuje kompilátoru, `await` že tato metoda obsahuje příkaz; obsahuje asynchronní operace.</span><span class="sxs-lookup"><span data-stu-id="df653-203">That signals to the compiler that this method contains an `await` statement; it contains asynchronous operations.</span></span> <span data-ttu-id="df653-204">Tato metoda představuje úkol, který opéká chléb, pak přidá máslo a džem.</span><span class="sxs-lookup"><span data-stu-id="df653-204">This method represents the task that toasts the bread, then adds butter and jam.</span></span> <span data-ttu-id="df653-205">Tato metoda <xref:System.Threading.Tasks.Task%601> vrátí, který představuje složení těchto tří operací.</span><span class="sxs-lookup"><span data-stu-id="df653-205">This method returns a <xref:System.Threading.Tasks.Task%601> that represents the composition of those three operations.</span></span> <span data-ttu-id="df653-206">Hlavní blok kódu se nyní stane:</span><span class="sxs-lookup"><span data-stu-id="df653-206">The main block of code now becomes:</span></span>

[!code-csharp[StartConcurrentTasks](~/samples/snippets/csharp/tour-of-async/AsyncBreakfast-V3/Program.cs#Main)]

<span data-ttu-id="df653-207">Předchozí změna ilustrovala důležitou techniku pro práci s asynchronním kódem.</span><span class="sxs-lookup"><span data-stu-id="df653-207">The previous change illustrated an important technique for working with asynchronous code.</span></span> <span data-ttu-id="df653-208">Úlohy můžete vytvořit oddělením operací do nové metody, která vrací úkol.</span><span class="sxs-lookup"><span data-stu-id="df653-208">You compose tasks by separating the operations into a new method that returns a task.</span></span> <span data-ttu-id="df653-209">Můžete si vybrat, kdy na tento úkol čekat.</span><span class="sxs-lookup"><span data-stu-id="df653-209">You can choose when to await that task.</span></span> <span data-ttu-id="df653-210">Další úkoly můžete spustit současně.</span><span class="sxs-lookup"><span data-stu-id="df653-210">You can start other tasks concurrently.</span></span>

## <a name="await-tasks-efficiently"></a><span data-ttu-id="df653-211">Vyčkejte efektivně na úkoly</span><span class="sxs-lookup"><span data-stu-id="df653-211">Await tasks efficiently</span></span>

<span data-ttu-id="df653-212">Řada `await` příkazů na konci předchozího kódu lze zlepšit pomocí metod `Task` třídy.</span><span class="sxs-lookup"><span data-stu-id="df653-212">The series of `await` statements at the end of the preceding code can be improved by using methods of the `Task` class.</span></span> <span data-ttu-id="df653-213">Jedním z těchto <xref:System.Threading.Tasks.Task.WhenAll%2A>api je <xref:System.Threading.Tasks.Task> , který vrátí, který dokončí po dokončení všech úkolů v seznamu argumentů, jak je znázorněno v následujícím kódu:</span><span class="sxs-lookup"><span data-stu-id="df653-213">One of those APIs is <xref:System.Threading.Tasks.Task.WhenAll%2A>, which returns a <xref:System.Threading.Tasks.Task> that completes when all the tasks in its argument list have completed, as shown in the following code:</span></span>

```csharp
await Task.WhenAll(eggsTask, baconTask, toastTask);
Console.WriteLine("eggs are ready");
Console.WriteLine("bacon is ready");
Console.WriteLine("toast is ready");
Console.WriteLine("Breakfast is ready!");
```

<span data-ttu-id="df653-214">Další možností je <xref:System.Threading.Tasks.Task.WhenAny%2A>použití , `Task<Task>` který vrátí, který dokončí po dokončení některého z jeho argumentů.</span><span class="sxs-lookup"><span data-stu-id="df653-214">Another option is to use <xref:System.Threading.Tasks.Task.WhenAny%2A>, which returns a `Task<Task>` that completes when any of its arguments completes.</span></span> <span data-ttu-id="df653-215">Můžete čekat na vrácený úkol s vědomím, že již byla dokončena.</span><span class="sxs-lookup"><span data-stu-id="df653-215">You can await the returned task, knowing that it has already finished.</span></span> <span data-ttu-id="df653-216">Následující kód ukazuje, jak <xref:System.Threading.Tasks.Task.WhenAny%2A> můžete použít čekat na první úkol k dokončení a potom zpracovat jeho výsledek.</span><span class="sxs-lookup"><span data-stu-id="df653-216">The following code shows how you could use <xref:System.Threading.Tasks.Task.WhenAny%2A> to await the first task to finish and then process its result.</span></span> <span data-ttu-id="df653-217">Po zpracování výsledku dokončeného úkolu odeberete tento dokončený `WhenAny`úkol ze seznamu úkolů předaných aplikaci .</span><span class="sxs-lookup"><span data-stu-id="df653-217">After processing the result from the completed task, you remove that completed task from the list of tasks passed to `WhenAny`.</span></span>

[!code-csharp[AwaitAnyTask](~/samples/snippets/csharp/tour-of-async/AsyncBreakfast-final/Program.cs#AwaitAnyTask)]

<span data-ttu-id="df653-218">Po všech těchto změnách `Main` vypadá konečná verze aplikace následující kód:</span><span class="sxs-lookup"><span data-stu-id="df653-218">After all those changes, the final version of `Main` looks like the following code:</span></span>

[!code-csharp[Final](~/samples/snippets/csharp/tour-of-async/AsyncBreakfast-final/Program.cs#Main)]

<span data-ttu-id="df653-219">Tento konečný kód je asynchronní.</span><span class="sxs-lookup"><span data-stu-id="df653-219">This final code is asynchronous.</span></span> <span data-ttu-id="df653-220">To přesněji odráží, jak by člověk vařit snídani.</span><span class="sxs-lookup"><span data-stu-id="df653-220">It more accurately reflects how a person would cook a breakfast.</span></span> <span data-ttu-id="df653-221">Porovnejte předchozí kód s první ukázkou kódu v tomto článku.</span><span class="sxs-lookup"><span data-stu-id="df653-221">Compare the preceding code with the first code sample in this article.</span></span> <span data-ttu-id="df653-222">Základní akce jsou stále jasné ze čtení kódu.</span><span class="sxs-lookup"><span data-stu-id="df653-222">The core actions are still clear from reading the code.</span></span> <span data-ttu-id="df653-223">Tento kód si můžete přečíst stejným způsobem, jakým jste si přečetli tyto pokyny pro snídani na začátku tohoto článku.</span><span class="sxs-lookup"><span data-stu-id="df653-223">You can read this code the same way you'd read those instructions for making a breakfast at the beginning of this article.</span></span> <span data-ttu-id="df653-224">Jazykové funkce `async` pro `await` a poskytují překlad každý člověk dělá následovat tyto písemné pokyny: spuštění úkolů, jak můžete a neblokujte čekání na dokončení úkolů.</span><span class="sxs-lookup"><span data-stu-id="df653-224">The language features for `async` and `await` provide the translation every person makes to follow those written instructions: start tasks as you can and don't block waiting for tasks to complete.</span></span>
