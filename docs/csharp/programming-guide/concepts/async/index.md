---
title: 'Asynchronní programování v jazyce C #'
description: Přehled podpory jazyka C# pro asynchronní programování pomocí asynchronního, operátoru await, úlohy a úlohy<T>
ms.date: 05/26/2020
ms.openlocfilehash: 703392ca6ba4e6fb08dd8a88817babc167394788
ms.sourcegitcommit: 03fec33630b46e78d5e81e91b40518f32c4bd7b5
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 05/27/2020
ms.locfileid: "84007959"
---
# <a name="asynchronous-programming-with-async-and-await"></a><span data-ttu-id="ca046-103">Asynchronní programování pomocí modifikátoru Async a operátoru Await</span><span class="sxs-lookup"><span data-stu-id="ca046-103">Asynchronous programming with async and await</span></span>

<span data-ttu-id="ca046-104">[Asynchronní programovací model úlohy (klepněte na)](task-asynchronous-programming-model.md) poskytuje abstrakci pro asynchronní kód.</span><span class="sxs-lookup"><span data-stu-id="ca046-104">The [Task asynchronous programming model (TAP)](task-asynchronous-programming-model.md) provides an abstraction over asynchronous code.</span></span> <span data-ttu-id="ca046-105">Kód můžete napsat jako posloupnost příkazů, stejně jako vždycky.</span><span class="sxs-lookup"><span data-stu-id="ca046-105">You write code as a sequence of statements, just like always.</span></span> <span data-ttu-id="ca046-106">Tento kód si můžete přečíst, jako by byl každý příkaz dokončen před dalším začátkem.</span><span class="sxs-lookup"><span data-stu-id="ca046-106">You can read that code as though each statement completes before the next begins.</span></span> <span data-ttu-id="ca046-107">Kompilátor provádí řadu transformací, protože některé z těchto příkazů mohou začít pracovat a vracet <xref:System.Threading.Tasks.Task> , který představuje probíhající práci.</span><span class="sxs-lookup"><span data-stu-id="ca046-107">The compiler performs a number of transformations because some of those statements may start work and return a <xref:System.Threading.Tasks.Task> that represents the ongoing work.</span></span>

<span data-ttu-id="ca046-108">To je cílem této syntaxe: umožňuje povolit kód, který se čte jako sekvence příkazů, ale provádí se v mnohem složitějším pořadí založeném na externím přidělení prostředků a po dokončení úkolů.</span><span class="sxs-lookup"><span data-stu-id="ca046-108">That's the goal of this syntax: enable code that reads like a sequence of statements, but executes in a much more complicated order based on external resource allocation and when tasks complete.</span></span> <span data-ttu-id="ca046-109">Podobá se tomu, jak lidé dávají pokyny pro procesy, které zahrnují asynchronní úlohy.</span><span class="sxs-lookup"><span data-stu-id="ca046-109">It's analogous to how people give instructions for processes that include asynchronous tasks.</span></span> <span data-ttu-id="ca046-110">V tomto článku použijete příklad pokynů pro vytvoření snídani k tomu, abyste viděli, jak `async` `await` klíčová slova a usnadňují odůvodnění kódu, který obsahuje řadu asynchronních instrukcí.</span><span class="sxs-lookup"><span data-stu-id="ca046-110">Throughout this article, you'll use an example of instructions for making a breakfast to see how the `async` and `await` keywords make it easier to reason about code, that includes a series of asynchronous instructions.</span></span> <span data-ttu-id="ca046-111">Měli byste napsat pokyny, jako je v následujícím seznamu, abyste se vysvětlují, jak vytvořit snídani:</span><span class="sxs-lookup"><span data-stu-id="ca046-111">You'd write the instructions something like the following list to explain how to make a breakfast:</span></span>

1. <span data-ttu-id="ca046-112">Nalijte konvičku z kávy.</span><span class="sxs-lookup"><span data-stu-id="ca046-112">Pour a cup of coffee.</span></span>
1. <span data-ttu-id="ca046-113">Zastavte pánev a pak dvě vejce v SRJ.</span><span class="sxs-lookup"><span data-stu-id="ca046-113">Heat up a pan, then fry two eggs.</span></span>
1. <span data-ttu-id="ca046-114">SRJ tři řezy slanina</span><span class="sxs-lookup"><span data-stu-id="ca046-114">Fry three slices of bacon.</span></span>
1. <span data-ttu-id="ca046-115">Informační zprávy jsou dvě části chleba.</span><span class="sxs-lookup"><span data-stu-id="ca046-115">Toast two pieces of bread.</span></span>
1. <span data-ttu-id="ca046-116">Přidejte máslo a zaseknutí do informačních zpráv.</span><span class="sxs-lookup"><span data-stu-id="ca046-116">Add butter and jam to the toast.</span></span>
1. <span data-ttu-id="ca046-117">Nalijte sklo oranžové šťávy.</span><span class="sxs-lookup"><span data-stu-id="ca046-117">Pour a glass of orange juice.</span></span>

<span data-ttu-id="ca046-118">Pokud máte zkušenosti s vařením, spusťte tyto pokyny **asynchronně**.</span><span class="sxs-lookup"><span data-stu-id="ca046-118">If you have experience with cooking, you'd execute those instructions **asynchronously**.</span></span> <span data-ttu-id="ca046-119">Začnete zahříváním pánev pro vejce a pak zahájíte slanina.</span><span class="sxs-lookup"><span data-stu-id="ca046-119">You'd start warming the pan for eggs, then start the bacon.</span></span> <span data-ttu-id="ca046-120">Vložili jste chléb do informačního pole a pak vejce začali.</span><span class="sxs-lookup"><span data-stu-id="ca046-120">You'd put the bread in the toaster, then start the eggs.</span></span> <span data-ttu-id="ca046-121">V každém kroku procesu byste úlohu spustili a pak jste si měli pozor na úkoly, které jsou připravené na vaši pozornost.</span><span class="sxs-lookup"><span data-stu-id="ca046-121">At each step of the process, you'd start a task, then turn your attention to tasks that are ready for your attention.</span></span>

<span data-ttu-id="ca046-122">Vaření snídaně je dobrým příkladem asynchronní práce, která není paralelní.</span><span class="sxs-lookup"><span data-stu-id="ca046-122">Cooking breakfast is a good example of asynchronous work that isn't parallel.</span></span> <span data-ttu-id="ca046-123">Všechny tyto úlohy může zvládnout jedna osoba (nebo vlákno).</span><span class="sxs-lookup"><span data-stu-id="ca046-123">One person (or thread) can handle all these tasks.</span></span> <span data-ttu-id="ca046-124">Pokračováním v analogovém režimu může jedna osoba provést asynchronní zpracování asynchronně spuštěním další úlohy před prvním dokončením.</span><span class="sxs-lookup"><span data-stu-id="ca046-124">Continuing the breakfast analogy, one person can make breakfast asynchronously by starting the next task before the first completes.</span></span> <span data-ttu-id="ca046-125">Vaření bude postupovat bez ohledu na to, jestli ho někdo sleduje.</span><span class="sxs-lookup"><span data-stu-id="ca046-125">The cooking progresses whether or not someone is watching it.</span></span> <span data-ttu-id="ca046-126">Jakmile začnete zahříváním pánev pro vejce, můžete začít Frying slanina.</span><span class="sxs-lookup"><span data-stu-id="ca046-126">As soon as you start warming the pan for the eggs, you can begin frying the bacon.</span></span> <span data-ttu-id="ca046-127">Po spuštění slanina můžete přidat chléb do informačního části.</span><span class="sxs-lookup"><span data-stu-id="ca046-127">Once the bacon starts, you can put the bread into the toaster.</span></span>

<span data-ttu-id="ca046-128">Pro paralelní algoritmus budete potřebovat více cooků (neboli vláken).</span><span class="sxs-lookup"><span data-stu-id="ca046-128">For a parallel algorithm, you'd need multiple cooks (or threads).</span></span> <span data-ttu-id="ca046-129">To by mělo být vejce, jedna slanina a tak dále.</span><span class="sxs-lookup"><span data-stu-id="ca046-129">One would make the eggs, one the bacon, and so on.</span></span> <span data-ttu-id="ca046-130">Každé z nich by se zaměřilo jenom na jeden úkol.</span><span class="sxs-lookup"><span data-stu-id="ca046-130">Each one would be focused on just that one task.</span></span> <span data-ttu-id="ca046-131">Každé Cookovy (nebo vlákno) se zablokuje synchronně, čeká se, až bude slanina připravený k převrácení, nebo informační zprávy, které se mají blokovat.</span><span class="sxs-lookup"><span data-stu-id="ca046-131">Each cook (or thread) would be blocked synchronously waiting for bacon to be ready to flip, or the toast to pop.</span></span>

<span data-ttu-id="ca046-132">Nyní zvažte stejné pokyny, které jsou zapsány jako příkazy jazyka C#:</span><span class="sxs-lookup"><span data-stu-id="ca046-132">Now, consider those same instructions written as C# statements:</span></span>

:::code language="csharp" source="snippets/index/AsyncBreakfast-starter/Program.cs" highlight="8-27":::

> [!NOTE]
> <span data-ttu-id="ca046-133">`Coffee`Třídy, `Egg` ,, a `Bacon` `Toast` `Juice` jsou prázdné.</span><span class="sxs-lookup"><span data-stu-id="ca046-133">The `Coffee`, `Egg`, `Bacon`, `Toast`, and `Juice` classes are empty.</span></span> <span data-ttu-id="ca046-134">Jsou pouze třídy značek pro účely ukázky, neobsahují žádné vlastnosti a neposkytují žádné jiné účely.</span><span class="sxs-lookup"><span data-stu-id="ca046-134">They are simply marker classes for the purpose of demonstration, contain no properties, and serve no other purpose.</span></span>

<span data-ttu-id="ca046-135">Počítače neinterpretují tyto pokyny stejným způsobem jako lidé.</span><span class="sxs-lookup"><span data-stu-id="ca046-135">Computers don't interpret those instructions the same way people do.</span></span> <span data-ttu-id="ca046-136">Počítač bude zablokovat každý příkaz, dokud nebude dokončeno dokončení práce, než přejde k dalšímu příkazu.</span><span class="sxs-lookup"><span data-stu-id="ca046-136">The computer will block on each statement until the work is complete before moving on to the next statement.</span></span> <span data-ttu-id="ca046-137">Tím se vytvoří nevyhovující snídaně.</span><span class="sxs-lookup"><span data-stu-id="ca046-137">That creates an unsatisfying breakfast.</span></span> <span data-ttu-id="ca046-138">Pozdější úkoly by nemusely být spuštěny, dokud se předchozí úkoly nedokončí.</span><span class="sxs-lookup"><span data-stu-id="ca046-138">The later tasks wouldn't be started until the earlier tasks had completed.</span></span> <span data-ttu-id="ca046-139">Vytvoření snídaně by trvat mnohem delší dobu a některé položky by byly před odesláním nedoručeny.</span><span class="sxs-lookup"><span data-stu-id="ca046-139">It would take much longer to create the breakfast, and some items would have gotten cold before being served.</span></span>

<span data-ttu-id="ca046-140">Pokud chcete, aby počítač prováděl výše uvedené pokyny asynchronně, je nutné napsat asynchronní kód.</span><span class="sxs-lookup"><span data-stu-id="ca046-140">If you want the computer to execute the above instructions asynchronously, you must write asynchronous code.</span></span>

<span data-ttu-id="ca046-141">Tyto aspekty jsou důležité pro programy, které dnes napíšete.</span><span class="sxs-lookup"><span data-stu-id="ca046-141">These concerns are important for the programs you write today.</span></span> <span data-ttu-id="ca046-142">Při psaní klientských programů budete chtít, aby uživatelské rozhraní reagovalo na vstup uživatele.</span><span class="sxs-lookup"><span data-stu-id="ca046-142">When you write client programs, you want the UI to be responsive to user input.</span></span> <span data-ttu-id="ca046-143">Vaše aplikace by se neměla po stažení dat z webu jevit jako zmrazená.</span><span class="sxs-lookup"><span data-stu-id="ca046-143">Your application shouldn't make a phone appear frozen while it's downloading data from the web.</span></span> <span data-ttu-id="ca046-144">Když píšete serverové programy, nechcete, aby byla vlákna blokovaná.</span><span class="sxs-lookup"><span data-stu-id="ca046-144">When you write server programs, you don't want threads blocked.</span></span> <span data-ttu-id="ca046-145">Tato vlákna mohou obsluhovat jiné požadavky.</span><span class="sxs-lookup"><span data-stu-id="ca046-145">Those threads could be serving other requests.</span></span> <span data-ttu-id="ca046-146">Použití synchronního kódu v případě, že existují asynchronní alternativy, neuškodí schopnost horizontálního navýšení kapacity snížit kapacitu.</span><span class="sxs-lookup"><span data-stu-id="ca046-146">Using synchronous code when asynchronous alternatives exist hurts your ability to scale out less expensively.</span></span> <span data-ttu-id="ca046-147">Platíte za tato blokovaná vlákna.</span><span class="sxs-lookup"><span data-stu-id="ca046-147">You pay for those blocked threads.</span></span>

<span data-ttu-id="ca046-148">Úspěšné moderní aplikace vyžadují asynchronní kód.</span><span class="sxs-lookup"><span data-stu-id="ca046-148">Successful modern applications require asynchronous code.</span></span> <span data-ttu-id="ca046-149">Bez podpory jazyků, psaní zpětných volání vyžadovaných asynchronním kódem, události dokončení nebo jiné způsob, který zakrývá původní záměr kódu.</span><span class="sxs-lookup"><span data-stu-id="ca046-149">Without language support, writing asynchronous code required callbacks, completion events, or other means that obscured the original intent of the code.</span></span> <span data-ttu-id="ca046-150">Výhodou synchronního kódu je, že je snadné ho pochopit.</span><span class="sxs-lookup"><span data-stu-id="ca046-150">The advantage of the synchronous code is that it's easy to understand.</span></span> <span data-ttu-id="ca046-151">Podrobné akce usnadňují kontrolu a pochopení.</span><span class="sxs-lookup"><span data-stu-id="ca046-151">The step-by-step actions make it easy to scan and understand.</span></span> <span data-ttu-id="ca046-152">Tradiční asynchronní modely vám pomohly soustředit se na asynchronní povahu kódu, nikoli na základní akce kódu.</span><span class="sxs-lookup"><span data-stu-id="ca046-152">Traditional asynchronous models forced you to focus on the asynchronous nature of the code, not on the fundamental actions of the code.</span></span>

## <a name="dont-block-await-instead"></a><span data-ttu-id="ca046-153">Neblokovat, místo toho očekávat</span><span class="sxs-lookup"><span data-stu-id="ca046-153">Don't block, await instead</span></span>

<span data-ttu-id="ca046-154">Předchozí kód demonstruje špatný postup: sestavení synchronního kódu pro provádění asynchronních operací.</span><span class="sxs-lookup"><span data-stu-id="ca046-154">The preceding code demonstrates a bad practice: constructing synchronous code to perform asynchronous operations.</span></span> <span data-ttu-id="ca046-155">Jak je zapsáno, tento kód zablokuje vlákno, které ho spouští, od jakékoli jiné práce.</span><span class="sxs-lookup"><span data-stu-id="ca046-155">As written, this code blocks the thread executing it from doing any other work.</span></span> <span data-ttu-id="ca046-156">Nedojde k přerušení, dokud nebudou dokončeny žádné úlohy.</span><span class="sxs-lookup"><span data-stu-id="ca046-156">It won't be interrupted while any of the tasks are in progress.</span></span> <span data-ttu-id="ca046-157">Může to být tak, jak jste v informačním části postari po vložení chleba do.</span><span class="sxs-lookup"><span data-stu-id="ca046-157">It would be as though you stared at the toaster after putting the bread in.</span></span> <span data-ttu-id="ca046-158">Na vás bude nikdo mluvit, dokud nebudou informační zprávy odebrány.</span><span class="sxs-lookup"><span data-stu-id="ca046-158">You'd ignore anyone talking to you until the toast popped.</span></span>

<span data-ttu-id="ca046-159">Pojďme začít aktualizací tohoto kódu, aby vlákno neblokovalo úlohy spuštěné.</span><span class="sxs-lookup"><span data-stu-id="ca046-159">Let's start by updating this code so that the thread doesn't block while tasks are running.</span></span> <span data-ttu-id="ca046-160">`await`Klíčové slovo poskytuje neblokující způsob spuštění úlohy a pak pokračuje v provádění po dokončení této úlohy.</span><span class="sxs-lookup"><span data-stu-id="ca046-160">The `await` keyword provides a non-blocking way to start a task, then continue execution when that task completes.</span></span> <span data-ttu-id="ca046-161">Jednoduchá asynchronní verze kódu pro vytvoření snídani by vypadala jako následující fragment kódu:</span><span class="sxs-lookup"><span data-stu-id="ca046-161">A simple asynchronous version of the make a breakfast code would look like the following snippet:</span></span>

:::code language="csharp" source="snippets/index/AsyncBreakfast-V2/Program.cs" id="SnippetMain":::

> [!TIP]
> <span data-ttu-id="ca046-162">Tělo metody `FryEggsAsync` , `FryBaconAsync` a `ToastBreadAsync` byly aktualizovány, aby vracely hodnoty, `Task<Egg>` `Task<Bacon>` a `Task<Toast>` v uvedeném pořadí.</span><span class="sxs-lookup"><span data-stu-id="ca046-162">The method bodies of the `FryEggsAsync`, `FryBaconAsync`, and `ToastBreadAsync` have all been updated to return `Task<Egg>`, `Task<Bacon>`, and `Task<Toast>` respectively.</span></span> <span data-ttu-id="ca046-163">Metody se přejmenují z původní verze tak, aby zahrnovaly příponu "Async".</span><span class="sxs-lookup"><span data-stu-id="ca046-163">The methods are renamed from their original version to include the "Async" suffix.</span></span> <span data-ttu-id="ca046-164">Jejich implementace se zobrazují jako součást [finální verze](#final-version) dále v tomto článku.</span><span class="sxs-lookup"><span data-stu-id="ca046-164">Their implementations are shown as part of the [final version](#final-version) later in this article.</span></span>

<span data-ttu-id="ca046-165">Tento kód se neblokuje, pokud jsou vejce nebo slanina vaření.</span><span class="sxs-lookup"><span data-stu-id="ca046-165">This code doesn't block while the eggs or the bacon are cooking.</span></span> <span data-ttu-id="ca046-166">Tento kód v takovém případě nespustí žádné další úlohy.</span><span class="sxs-lookup"><span data-stu-id="ca046-166">This code won't start any other tasks though.</span></span> <span data-ttu-id="ca046-167">Informační zprávy do informačního oddělení byste pořád umístili do informačních zpráv a tam, kde se neobjeví.</span><span class="sxs-lookup"><span data-stu-id="ca046-167">You'd still put the toast in the toaster and stare at it until it pops.</span></span> <span data-ttu-id="ca046-168">Ale aspoň, budete reagovat na kohokoli, kdo si přeje vaši pozornost.</span><span class="sxs-lookup"><span data-stu-id="ca046-168">But at least, you'd respond to anyone that wanted your attention.</span></span> <span data-ttu-id="ca046-169">V rámci restaurace, kde je umístěno více objednávek, může Cook Cook začít jinou snídani, zatímco první je vaření.</span><span class="sxs-lookup"><span data-stu-id="ca046-169">In a restaurant where multiple orders are placed, the cook could start another breakfast while the first is cooking.</span></span>

<span data-ttu-id="ca046-170">Vlákno, které pracuje na snídani, není nyní blokované při čekání na spuštěnou úlohu, která ještě nebyla dokončena.</span><span class="sxs-lookup"><span data-stu-id="ca046-170">Now, the thread working on the breakfast isn't blocked while awaiting any started task that hasn't yet finished.</span></span> <span data-ttu-id="ca046-171">U některých aplikací je tato změna potřebná.</span><span class="sxs-lookup"><span data-stu-id="ca046-171">For some applications, this change is all that's needed.</span></span> <span data-ttu-id="ca046-172">Aplikace grafického uživatelského rozhraní pořád reaguje na uživatele pouze touto změnou.</span><span class="sxs-lookup"><span data-stu-id="ca046-172">A GUI application still responds to the user with just this change.</span></span> <span data-ttu-id="ca046-173">V tomto scénáři ale potřebujete víc.</span><span class="sxs-lookup"><span data-stu-id="ca046-173">However, for this scenario, you want more.</span></span> <span data-ttu-id="ca046-174">Nechcete, aby se jednotlivé úlohy komponenty prováděly sekvenčně.</span><span class="sxs-lookup"><span data-stu-id="ca046-174">You don't want each of the component tasks to be executed sequentially.</span></span> <span data-ttu-id="ca046-175">Před čekáním na dokončení předchozího úkolu je lepší spustit každou z těchto úloh.</span><span class="sxs-lookup"><span data-stu-id="ca046-175">It's better to start each of the component tasks before awaiting the previous task's completion.</span></span>

## <a name="start-tasks-concurrently"></a><span data-ttu-id="ca046-176">Spustit souběžně úlohy</span><span class="sxs-lookup"><span data-stu-id="ca046-176">Start tasks concurrently</span></span>

<span data-ttu-id="ca046-177">V mnoha scénářích chcete okamžitě spustit několik nezávislých úloh.</span><span class="sxs-lookup"><span data-stu-id="ca046-177">In many scenarios, you want to start several independent tasks immediately.</span></span> <span data-ttu-id="ca046-178">Po dokončení jednotlivých úkolů můžete pokračovat v práci, která je připravená.</span><span class="sxs-lookup"><span data-stu-id="ca046-178">Then, as each task finishes, you can continue other work that's ready.</span></span> <span data-ttu-id="ca046-179">V analogické pracovní snídaně to je způsob, jak rychle získat snídani.</span><span class="sxs-lookup"><span data-stu-id="ca046-179">In the breakfast analogy, that's how you get breakfast done more quickly.</span></span> <span data-ttu-id="ca046-180">Všechno se ale také dokončí blízko stejnou dobu.</span><span class="sxs-lookup"><span data-stu-id="ca046-180">You also get everything done close to the same time.</span></span> <span data-ttu-id="ca046-181">Získáte horkou snídani.</span><span class="sxs-lookup"><span data-stu-id="ca046-181">You'll get a hot breakfast.</span></span>

<span data-ttu-id="ca046-182"><xref:System.Threading.Tasks.Task?displayProperty=nameWithType>Související typy jsou třídy, které můžete použít k odůvodnění úloh, které probíhají.</span><span class="sxs-lookup"><span data-stu-id="ca046-182">The <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> and related types are classes you can use to reason about tasks that are in progress.</span></span> <span data-ttu-id="ca046-183">To vám umožňuje psát kód, který se bude lépe podobat způsobu, jakým jste ve skutečnosti vytvořili snídani.</span><span class="sxs-lookup"><span data-stu-id="ca046-183">That enables you to write code that more closely resembles the way you'd actually create breakfast.</span></span> <span data-ttu-id="ca046-184">Začít vaření na vejce, slanina a informační zprávy ve stejnou dobu.</span><span class="sxs-lookup"><span data-stu-id="ca046-184">You'd start cooking the eggs, bacon, and toast at the same time.</span></span> <span data-ttu-id="ca046-185">Vzhledem k tomu, že každá z nich vyžaduje akci, byste měli věnovat pozornost této úloze, pořídit další akci a pak očekávat něco jiného, co vyžaduje vaši pozornost.</span><span class="sxs-lookup"><span data-stu-id="ca046-185">As each requires action, you'd turn your attention to that task, take care of the next action, then await for something else that requires your attention.</span></span>

<span data-ttu-id="ca046-186">Spustíte úlohu a podržíte ji pro <xref:System.Threading.Tasks.Task> objekt, který představuje práci.</span><span class="sxs-lookup"><span data-stu-id="ca046-186">You start a task and hold on to the <xref:System.Threading.Tasks.Task> object that represents the work.</span></span> <span data-ttu-id="ca046-187">Než budete `await` s jeho výsledkem pracovat, budete mít každý úkol.</span><span class="sxs-lookup"><span data-stu-id="ca046-187">You'll `await` each task before working with its result.</span></span>

<span data-ttu-id="ca046-188">Pojďme udělat tyto změny kódu snídani.</span><span class="sxs-lookup"><span data-stu-id="ca046-188">Let's make these changes to the breakfast code.</span></span> <span data-ttu-id="ca046-189">Prvním krokem je ukládat úlohy pro operace, když se spouštějí, a nečekají na ně:</span><span class="sxs-lookup"><span data-stu-id="ca046-189">The first step is to store the tasks for operations when they start, rather than awaiting them:</span></span>

```csharp
Coffee cup = PourCoffee();
Console.WriteLine("coffee is ready");

Task<Egg> eggsTask = FryEggsAsync(2);
Egg eggs = await eggsTask;
Console.WriteLine("eggs are ready");

Task<Bacon> baconTask = FryBaconAsync(3);
Bacon bacon = await baconTask;
Console.WriteLine("bacon is ready");

Task<Toast> toastTask = ToastBreadAsync(2);
Toast toast = await toastTask;
ApplyButter(toast);
ApplyJam(toast);
Console.WriteLine("toast is ready");

Juice oj = PourOJ();
Console.WriteLine("oj is ready");
Console.WriteLine("Breakfast is ready!");
```

<span data-ttu-id="ca046-190">Dále můžete přesunout `await` příkazy pro slanina a vejce na konec metody před obsluhou snídaně:</span><span class="sxs-lookup"><span data-stu-id="ca046-190">Next, you can move the `await` statements for the bacon and eggs to the end of the method, before serving breakfast:</span></span>

```csharp
Coffee cup = PourCoffee();
Console.WriteLine("coffee is ready");

Task<Egg> eggsTask = FryEggsAsync(2);
Task<Bacon> baconTask = FryBaconAsync(3);
Task<Toast> toastTask = ToastBreadAsync(2);

Toast toast = await toastTask;
ApplyButter(toast);
ApplyJam(toast);
Console.WriteLine("toast is ready");
Juice oj = PourOJ();
Console.WriteLine("oj is ready");

Egg eggs = await eggsTask;
Console.WriteLine("eggs are ready");
Bacon bacon = await baconTask;
Console.WriteLine("bacon is ready");

Console.WriteLine("Breakfast is ready!");
```

<span data-ttu-id="ca046-191">Předchozí kód funguje lépe.</span><span class="sxs-lookup"><span data-stu-id="ca046-191">The preceding code works better.</span></span> <span data-ttu-id="ca046-192">Současně spustíte všechny asynchronní úlohy.</span><span class="sxs-lookup"><span data-stu-id="ca046-192">You start all the asynchronous tasks at once.</span></span> <span data-ttu-id="ca046-193">Každou úlohu můžete očekávat pouze v případě, že potřebujete výsledky.</span><span class="sxs-lookup"><span data-stu-id="ca046-193">You await each task only when you need the results.</span></span> <span data-ttu-id="ca046-194">Předchozí kód může být podobný kódu ve webové aplikaci, který vytváří požadavky na různé mikroslužby, a pak kombinuje výsledky do jediné stránky.</span><span class="sxs-lookup"><span data-stu-id="ca046-194">The preceding code may be similar to code in a web application that makes requests of different microservices, then combines the results into a single page.</span></span> <span data-ttu-id="ca046-195">Všechny požadavky okamžitě provedete `await` a pak všechny tyto úlohy a vytvoříte webovou stránku.</span><span class="sxs-lookup"><span data-stu-id="ca046-195">You'll make all the requests immediately, then `await` all those tasks and compose the web page.</span></span>

## <a name="composition-with-tasks"></a><span data-ttu-id="ca046-196">Složení s úkoly</span><span class="sxs-lookup"><span data-stu-id="ca046-196">Composition with tasks</span></span>

 <span data-ttu-id="ca046-197">Máte všechno připravené k snídani ve stejnou dobu s výjimkou informačních zpráv.</span><span class="sxs-lookup"><span data-stu-id="ca046-197">You have everything ready for breakfast at the same time except the toast.</span></span> <span data-ttu-id="ca046-198">Zpřístupnění informačních zpráv je složením asynchronní operace (informační zpráva o příchodu) a synchronní operace (přidání másla a zaseknutí).</span><span class="sxs-lookup"><span data-stu-id="ca046-198">Making the toast is the composition of an asynchronous operation (toasting the bread), and synchronous operations (adding the butter and the jam).</span></span> <span data-ttu-id="ca046-199">Aktualizace tohoto kódu ilustruje důležitý koncept:</span><span class="sxs-lookup"><span data-stu-id="ca046-199">Updating this code illustrates an important concept:</span></span>

> [!IMPORTANT]
> <span data-ttu-id="ca046-200">Složení asynchronní operace následované synchronní prací je asynchronní operace.</span><span class="sxs-lookup"><span data-stu-id="ca046-200">The composition of an asynchronous operation followed by synchronous work is an asynchronous operation.</span></span> <span data-ttu-id="ca046-201">Pokud je libovolná část operace asynchronní, je celá operace asynchronní, pokud je uvedena jinak.</span><span class="sxs-lookup"><span data-stu-id="ca046-201">Stated another way, if any portion of an operation is asynchronous, the entire operation is asynchronous.</span></span>

<span data-ttu-id="ca046-202">Předchozí kód vám ukázal, že můžete použít <xref:System.Threading.Tasks.Task> objekty nebo <xref:System.Threading.Tasks.Task%601> pro udržení spuštěných úloh.</span><span class="sxs-lookup"><span data-stu-id="ca046-202">The preceding code showed you that you can use <xref:System.Threading.Tasks.Task> or <xref:System.Threading.Tasks.Task%601> objects to hold running tasks.</span></span> <span data-ttu-id="ca046-203">`await`Každý úkol před použitím jeho výsledku.</span><span class="sxs-lookup"><span data-stu-id="ca046-203">You `await` each task before using its result.</span></span> <span data-ttu-id="ca046-204">Dalším krokem je vytvoření metod, které reprezentují kombinaci jiné práce.</span><span class="sxs-lookup"><span data-stu-id="ca046-204">The next step is to create methods that represent the combination of other work.</span></span> <span data-ttu-id="ca046-205">Před tím, než zachováte snídani, chcete čekat na úkol, který představuje informační zprávu, před přidáním másla a zaseknutím.</span><span class="sxs-lookup"><span data-stu-id="ca046-205">Before serving breakfast, you want to await the task that represents toasting the bread before adding butter and jam.</span></span> <span data-ttu-id="ca046-206">Tuto práci můžete vyjádřit pomocí následujícího kódu:</span><span class="sxs-lookup"><span data-stu-id="ca046-206">You can represent that work with the following code:</span></span>

:::code language="csharp" source="snippets/index/AsyncBreakfast-V3/Program.cs" id="SnippetComposeToastTask":::

<span data-ttu-id="ca046-207">Předchozí metoda má `async` v podpisu modifikátor.</span><span class="sxs-lookup"><span data-stu-id="ca046-207">The preceding method has the `async` modifier in its signature.</span></span> <span data-ttu-id="ca046-208">To signalizuje kompilátoru, že tato metoda obsahuje `await` příkaz, obsahuje asynchronní operace.</span><span class="sxs-lookup"><span data-stu-id="ca046-208">That signals to the compiler that this method contains an `await` statement; it contains asynchronous operations.</span></span> <span data-ttu-id="ca046-209">Tato metoda představuje úkol, který označuje chléb a pak přidá máslo a zaseknutí.</span><span class="sxs-lookup"><span data-stu-id="ca046-209">This method represents the task that toasts the bread, then adds butter and jam.</span></span> <span data-ttu-id="ca046-210">Tato metoda vrátí hodnotu <xref:System.Threading.Tasks.Task%601> , která představuje složení těchto tří operací.</span><span class="sxs-lookup"><span data-stu-id="ca046-210">This method returns a <xref:System.Threading.Tasks.Task%601> that represents the composition of those three operations.</span></span> <span data-ttu-id="ca046-211">Hlavní blok kódu teď bude:</span><span class="sxs-lookup"><span data-stu-id="ca046-211">The main block of code now becomes:</span></span>

:::code language="csharp" source="snippets/index/AsyncBreakfast-V3/Program.cs" id="SnippetMain":::

<span data-ttu-id="ca046-212">Předchozí změna ukázala důležitou techniku pro práci s asynchronním kódem.</span><span class="sxs-lookup"><span data-stu-id="ca046-212">The previous change illustrated an important technique for working with asynchronous code.</span></span> <span data-ttu-id="ca046-213">Můžete vytvářet úkoly oddělením operací s novou metodou, která vrací úlohu.</span><span class="sxs-lookup"><span data-stu-id="ca046-213">You compose tasks by separating the operations into a new method that returns a task.</span></span> <span data-ttu-id="ca046-214">Můžete vybrat, kdy se má tento úkol očekávat.</span><span class="sxs-lookup"><span data-stu-id="ca046-214">You can choose when to await that task.</span></span> <span data-ttu-id="ca046-215">Můžete spustit souběžně jiné úkoly.</span><span class="sxs-lookup"><span data-stu-id="ca046-215">You can start other tasks concurrently.</span></span>

## <a name="await-tasks-efficiently"></a><span data-ttu-id="ca046-216">Pro úlohy čekají efektivně</span><span class="sxs-lookup"><span data-stu-id="ca046-216">Await tasks efficiently</span></span>

<span data-ttu-id="ca046-217">Řadu `await` příkazů na konci předchozího kódu lze zlepšit pomocí metod `Task` třídy.</span><span class="sxs-lookup"><span data-stu-id="ca046-217">The series of `await` statements at the end of the preceding code can be improved by using methods of the `Task` class.</span></span> <span data-ttu-id="ca046-218">Jedno z těchto rozhraní API je <xref:System.Threading.Tasks.Task.WhenAll%2A> , což vrátí, <xref:System.Threading.Tasks.Task> která se dokončí po dokončení všech úkolů v seznamu argumentů, jak je znázorněno v následujícím kódu:</span><span class="sxs-lookup"><span data-stu-id="ca046-218">One of those APIs is <xref:System.Threading.Tasks.Task.WhenAll%2A>, which returns a <xref:System.Threading.Tasks.Task> that completes when all the tasks in its argument list have completed, as shown in the following code:</span></span>

```csharp
await Task.WhenAll(eggsTask, baconTask, toastTask);
Console.WriteLine("eggs are ready");
Console.WriteLine("bacon is ready");
Console.WriteLine("toast is ready");
Console.WriteLine("Breakfast is ready!");
```

<span data-ttu-id="ca046-219">Další možností je použít <xref:System.Threading.Tasks.Task.WhenAny%2A> , který vrátí a `Task<Task>` , který se dokončí po dokončení některého z jeho argumentů.</span><span class="sxs-lookup"><span data-stu-id="ca046-219">Another option is to use <xref:System.Threading.Tasks.Task.WhenAny%2A>, which returns a `Task<Task>` that completes when any of its arguments completes.</span></span> <span data-ttu-id="ca046-220">Můžete očekávat vrácenou úlohu s vědomím, že již byla dokončena.</span><span class="sxs-lookup"><span data-stu-id="ca046-220">You can await the returned task, knowing that it has already finished.</span></span> <span data-ttu-id="ca046-221">Následující kód ukazuje, jak můžete použít <xref:System.Threading.Tasks.Task.WhenAny%2A> k čekání na dokončení první úlohy a následnému zpracování výsledku.</span><span class="sxs-lookup"><span data-stu-id="ca046-221">The following code shows how you could use <xref:System.Threading.Tasks.Task.WhenAny%2A> to await the first task to finish and then process its result.</span></span> <span data-ttu-id="ca046-222">Po zpracování výsledku z dokončené úlohy odstraníte tuto dokončenou úlohu ze seznamu úkolů předaných do `WhenAny` .</span><span class="sxs-lookup"><span data-stu-id="ca046-222">After processing the result from the completed task, you remove that completed task from the list of tasks passed to `WhenAny`.</span></span>

```csharp
var breakfastTasks = new List<Task> { eggsTask, baconTask, toastTask };
while (breakfastTasks.Count > 0)
{
    Task finishedTask = await Task.WhenAny(breakfastTasks);
    if (finishedTask == eggsTask)
    {
        Console.WriteLine("eggs are ready");
    }
    else if (finishedTask == baconTask)
    {
        Console.WriteLine("bacon is ready");
    }
    else if (finishedTask == toastTask)
    {
        Console.WriteLine("toast is ready");
    }
    breakfastTasks.Remove(finishedTask);
}
```

<span data-ttu-id="ca046-223">Po všech změnách bude finální verze kódu vypadat takto:<a id="final-version"></a></span><span class="sxs-lookup"><span data-stu-id="ca046-223">After all those changes, the final version of the code looks like this: <a id="final-version"></a></span></span>
:::code language="csharp" source="snippets/index/AsyncBreakfast-final/Program.cs" highlight="9-40":::

<span data-ttu-id="ca046-224">Tento konečný kód je asynchronní.</span><span class="sxs-lookup"><span data-stu-id="ca046-224">This final code is asynchronous.</span></span> <span data-ttu-id="ca046-225">Přesněji odráží, jak by osoba navařené snídani.</span><span class="sxs-lookup"><span data-stu-id="ca046-225">It more accurately reflects how a person would cook a breakfast.</span></span> <span data-ttu-id="ca046-226">Porovnejte předchozí kód s první ukázkou kódu v tomto článku.</span><span class="sxs-lookup"><span data-stu-id="ca046-226">Compare the preceding code with the first code sample in this article.</span></span> <span data-ttu-id="ca046-227">Základní akce jsou stále jasné z čtení kódu.</span><span class="sxs-lookup"><span data-stu-id="ca046-227">The core actions are still clear from reading the code.</span></span> <span data-ttu-id="ca046-228">Tento kód si můžete přečíst stejným způsobem, jakým jste si přečetli tyto pokyny pro vytvoření snídaně na začátku tohoto článku.</span><span class="sxs-lookup"><span data-stu-id="ca046-228">You can read this code the same way you'd read those instructions for making a breakfast at the beginning of this article.</span></span> <span data-ttu-id="ca046-229">Jazykové funkce pro `async` a `await` poskytují překlad pro všechny uživatele, kteří se dodávají podle těchto písemných pokynů: spustit úlohy jako vy a neblokovat čekání na dokončení úkolů.</span><span class="sxs-lookup"><span data-stu-id="ca046-229">The language features for `async` and `await` provide the translation every person makes to follow those written instructions: start tasks as you can and don't block waiting for tasks to complete.</span></span>

## <a name="next-steps"></a><span data-ttu-id="ca046-230">Další kroky</span><span class="sxs-lookup"><span data-stu-id="ca046-230">Next steps</span></span>

> [!div class="nextstepaction"]
> [<span data-ttu-id="ca046-231">Další informace o modelu asynchronního programování úloh</span><span class="sxs-lookup"><span data-stu-id="ca046-231">Learn about the task asynchronous programming model</span></span>](task-asynchronous-programming-model.md)
