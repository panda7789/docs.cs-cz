---
title: Postup iterace prostřednictvím adresářového stromu – Průvodce programováním v C#
description: Naučte se iterovat v adresářovém stromu. Přístup ke každému souboru v každém vnořeném podadresáři v zadané kořenové složce.
ms.date: 07/20/2015
helpviewer_keywords:
- iterating through folders [C#]
- file iteration [C#]
ms.assetid: c4be4a75-6b1b-46a7-9d38-bab353091ed7
ms.openlocfilehash: c49a9d1eaea9d4d8967b105d753f2a611d80e795
ms.sourcegitcommit: 6f58a5f75ceeb936f8ee5b786e9adb81a9a3bee9
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 07/28/2020
ms.locfileid: "87301980"
---
# <a name="how-to-iterate-through-a-directory-tree-c-programming-guide"></a><span data-ttu-id="57424-104">Postup iterace v adresářovém stromu (Průvodce programováním v C#)</span><span class="sxs-lookup"><span data-stu-id="57424-104">How to iterate through a directory tree (C# Programming Guide)</span></span>
<span data-ttu-id="57424-105">Fráze "iterace stromu adresářů" znamená přístup ke každému souboru v každém vnořeném podadresáři v zadané kořenové složce, a to v jakékoli hloubce.</span><span class="sxs-lookup"><span data-stu-id="57424-105">The phrase "iterate a directory tree" means to access each file in each nested subdirectory under a specified root folder, to any depth.</span></span> <span data-ttu-id="57424-106">Nemusíte nutně otevírat jednotlivé soubory.</span><span class="sxs-lookup"><span data-stu-id="57424-106">You do not necessarily have to open each file.</span></span> <span data-ttu-id="57424-107">Můžete jednoduše načíst název souboru nebo podadresáře jako `string` , nebo můžete načíst další informace ve formě <xref:System.IO.FileInfo?displayProperty=nameWithType> <xref:System.IO.DirectoryInfo?displayProperty=nameWithType> objektu nebo.</span><span class="sxs-lookup"><span data-stu-id="57424-107">You can just retrieve the name of the file or subdirectory as a `string`, or you can retrieve additional information in the form of a <xref:System.IO.FileInfo?displayProperty=nameWithType> or <xref:System.IO.DirectoryInfo?displayProperty=nameWithType> object.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="57424-108">V systému Windows se výrazy "adresář" a "složka" používají zaměnitelné.</span><span class="sxs-lookup"><span data-stu-id="57424-108">In Windows, the terms "directory" and "folder" are used interchangeably.</span></span> <span data-ttu-id="57424-109">Většina dokumentace a text uživatelského rozhraní používá termín "složka", ale knihovny tříd .NET používají pojem "adresář".</span><span class="sxs-lookup"><span data-stu-id="57424-109">Most documentation and user interface text uses the term "folder," but .NET class libraries use the term "directory."</span></span>  
  
 <span data-ttu-id="57424-110">V nejjednodušším případě, ve kterém víte, že máte přístupová oprávnění ke všem adresářům v zadaném kořenu, můžete použít `System.IO.SearchOption.AllDirectories` příznak.</span><span class="sxs-lookup"><span data-stu-id="57424-110">In the simplest case, in which you know for certain that you have access permissions for all directories under a specified root, you can use the `System.IO.SearchOption.AllDirectories` flag.</span></span> <span data-ttu-id="57424-111">Tento příznak vrátí všechny vnořené podadresáře, které odpovídají zadanému vzoru.</span><span class="sxs-lookup"><span data-stu-id="57424-111">This flag returns all the nested subdirectories that match the specified pattern.</span></span> <span data-ttu-id="57424-112">Následující příklad ukazuje, jak použít tento příznak.</span><span class="sxs-lookup"><span data-stu-id="57424-112">The following example shows how to use this flag.</span></span>  
  
```csharp  
root.GetDirectories("*.*", System.IO.SearchOption.AllDirectories);  
```  
  
 <span data-ttu-id="57424-113">Slabé stránky v tomto přístupu je to, že pokud některý z podadresářů v rámci zadaného kořenu způsobí <xref:System.IO.DirectoryNotFoundException> nebo <xref:System.UnauthorizedAccessException> , pak celá metoda neproběhne a nevrátí žádné adresáře.</span><span class="sxs-lookup"><span data-stu-id="57424-113">The weakness in this approach is that if any one of the subdirectories under the specified root causes a <xref:System.IO.DirectoryNotFoundException> or <xref:System.UnauthorizedAccessException>, the whole method fails and returns no directories.</span></span> <span data-ttu-id="57424-114">Totéž platí, pokud použijete <xref:System.IO.DirectoryInfo.GetFiles%2A> metodu.</span><span class="sxs-lookup"><span data-stu-id="57424-114">The same is true when you use the <xref:System.IO.DirectoryInfo.GetFiles%2A> method.</span></span> <span data-ttu-id="57424-115">Pokud je nutné tyto výjimky zpracovat u konkrétních podsložek, je nutné ručně projít adresářový strom, jak je znázorněno v následujících příkladech.</span><span class="sxs-lookup"><span data-stu-id="57424-115">If you have to handle these exceptions on specific subfolders, you must manually walk the directory tree, as shown in the following examples.</span></span>  
  
 <span data-ttu-id="57424-116">Když ručně provedete strom adresářů, můžete nejprve zpracovat podadresáře (*před procházením*) nebo nejprve soubory (*Procházet po objednání*).</span><span class="sxs-lookup"><span data-stu-id="57424-116">When you manually walk a directory tree, you can handle the subdirectories first (*pre-order traversal*), or the files first (*post-order traversal*).</span></span> <span data-ttu-id="57424-117">Pokud provedete předběžné pořadí procházení, provedete celý strom v rámci aktuální složky před iterací souborů, které jsou přímo v této složce.</span><span class="sxs-lookup"><span data-stu-id="57424-117">If you perform a pre-order traversal, you walk the whole tree under the current folder before iterating through the files that are directly in that folder itself.</span></span> <span data-ttu-id="57424-118">Příklady dále v tomto dokumentu provádějí procházení po jednotlivých objednávkách, ale můžete je snadno upravit, aby se prováděly předběžné pořadí procházení.</span><span class="sxs-lookup"><span data-stu-id="57424-118">The examples later in this document perform post-order traversal, but you can easily modify them to perform pre-order traversal.</span></span>  
  
 <span data-ttu-id="57424-119">Další možností je, zda použít rekurzi nebo procházení založené na zásobníku.</span><span class="sxs-lookup"><span data-stu-id="57424-119">Another option is whether to use recursion or a stack-based traversal.</span></span> <span data-ttu-id="57424-120">Příklady níže v tomto dokumentu ukazují oba přístupy.</span><span class="sxs-lookup"><span data-stu-id="57424-120">The examples later in this document show both approaches.</span></span>  
  
 <span data-ttu-id="57424-121">Pokud potřebujete provést různé operace se soubory a složkami, můžete naplánovat modularizaci tyto příklady refaktoringem operace do samostatných funkcí, které můžete vyvolat pomocí jednoho delegáta.</span><span class="sxs-lookup"><span data-stu-id="57424-121">If you have to perform a variety of operations on files and folders, you can modularize these examples by refactoring the operation into separate functions that you can invoke by using a single delegate.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="57424-122">Systémy souborů NTFS můžou obsahovat *body rozboru* ve formě *spojovacích bodů*, *symbolických odkazů*a *pevných odkazů*.</span><span class="sxs-lookup"><span data-stu-id="57424-122">NTFS file systems can contain *reparse points* in the form of *junction points*, *symbolic links*, and *hard links*.</span></span> <span data-ttu-id="57424-123">Metody .NET, jako například <xref:System.IO.DirectoryInfo.GetFiles%2A> a, nebudou <xref:System.IO.DirectoryInfo.GetDirectories%2A> vracet žádné podadresáře v rámci spojovacího bodu.</span><span class="sxs-lookup"><span data-stu-id="57424-123">.NET methods such as <xref:System.IO.DirectoryInfo.GetFiles%2A> and <xref:System.IO.DirectoryInfo.GetDirectories%2A> will not return any subdirectories under a reparse point.</span></span> <span data-ttu-id="57424-124">Toto chování chrání před rizikem vstupu do nekonečné smyčky, když dva body rozboru odkazují na sebe navzájem.</span><span class="sxs-lookup"><span data-stu-id="57424-124">This behavior guards against the risk of entering into an infinite loop when two reparse points refer to each other.</span></span> <span data-ttu-id="57424-125">Obecně platí, že byste měli při práci s body rozboru použít extrémní opatrnost, abyste se ujistili, že neúmyslně neupravují ani neodstraňují soubory.</span><span class="sxs-lookup"><span data-stu-id="57424-125">In general, you should use extreme caution when you deal with reparse points to ensure that you do not unintentionally modify or delete files.</span></span> <span data-ttu-id="57424-126">Pokud potřebujete přesnou kontrolu nad body rozboru, použijte vyvolání nebo nativní kód platformy k přímému volání odpovídajících metod systému souborů Win32.</span><span class="sxs-lookup"><span data-stu-id="57424-126">If you require precise control over reparse points, use platform invoke or native code to call the appropriate Win32 file system methods directly.</span></span>  
  
## <a name="example"></a><span data-ttu-id="57424-127">Příklad</span><span class="sxs-lookup"><span data-stu-id="57424-127">Example</span></span>  
 <span data-ttu-id="57424-128">Následující příklad ukazuje, jak projít adresářový strom pomocí rekurze.</span><span class="sxs-lookup"><span data-stu-id="57424-128">The following example shows how to walk a directory tree by using recursion.</span></span> <span data-ttu-id="57424-129">Rekurzivní přístup je elegantní, ale má potenciál způsobit výjimku přetečení zásobníku, pokud je strom adresáře velký a hluboko vnořený.</span><span class="sxs-lookup"><span data-stu-id="57424-129">The recursive approach is elegant but has the potential to cause a stack overflow exception if the directory tree is large and deeply nested.</span></span>  
  
 <span data-ttu-id="57424-130">Konkrétní výjimky, které jsou zpracovávány, a konkrétní akce, které jsou provedeny u jednotlivých souborů nebo složek, jsou uvedeny pouze jako příklady.</span><span class="sxs-lookup"><span data-stu-id="57424-130">The particular exceptions that are handled, and the particular actions that are performed on each file or folder, are provided as examples only.</span></span> <span data-ttu-id="57424-131">Tento kód byste měli upravit tak, aby splňoval vaše konkrétní požadavky.</span><span class="sxs-lookup"><span data-stu-id="57424-131">You should modify this code to meet your specific requirements.</span></span> <span data-ttu-id="57424-132">Další informace najdete v komentářích v kódu.</span><span class="sxs-lookup"><span data-stu-id="57424-132">See the comments in the code for more information.</span></span>  
  
 [!code-csharp[csFilesandFolders#1](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csFilesAndFolders/CS/FileIteration.cs#1)]  
  
## <a name="example"></a><span data-ttu-id="57424-133">Příklad</span><span class="sxs-lookup"><span data-stu-id="57424-133">Example</span></span>  
 <span data-ttu-id="57424-134">Následující příklad ukazuje, jak iterovat soubory a složky ve stromu adresářů bez použití rekurze.</span><span class="sxs-lookup"><span data-stu-id="57424-134">The following example shows how to iterate through files and folders in a directory tree without using recursion.</span></span> <span data-ttu-id="57424-135">Tato technika používá typ obecné <xref:System.Collections.Generic.Stack%601> kolekce, což je poslední v zásobníku LIFO.</span><span class="sxs-lookup"><span data-stu-id="57424-135">This technique uses the generic <xref:System.Collections.Generic.Stack%601> collection type, which is a last in first out (LIFO) stack.</span></span>  
  
 <span data-ttu-id="57424-136">Konkrétní výjimky, které jsou zpracovávány, a konkrétní akce, které jsou provedeny u jednotlivých souborů nebo složek, jsou uvedeny pouze jako příklady.</span><span class="sxs-lookup"><span data-stu-id="57424-136">The particular exceptions that are handled, and the particular actions that are performed on each file or folder, are provided as examples only.</span></span> <span data-ttu-id="57424-137">Tento kód byste měli upravit tak, aby splňoval vaše konkrétní požadavky.</span><span class="sxs-lookup"><span data-stu-id="57424-137">You should modify this code to meet your specific requirements.</span></span> <span data-ttu-id="57424-138">Další informace najdete v komentářích v kódu.</span><span class="sxs-lookup"><span data-stu-id="57424-138">See the comments in the code for more information.</span></span>  
  
 [!code-csharp[csFilesandFolders#2](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csFilesAndFolders/CS/FileIteration.cs#2)]  
  
 <span data-ttu-id="57424-139">Je obvykle příliš časově náročná na testování každé složky, aby bylo možné určit, zda má vaše aplikace oprávnění k jejímu otevření.</span><span class="sxs-lookup"><span data-stu-id="57424-139">It is generally too time-consuming to test every folder to determine whether your application has permission to open it.</span></span> <span data-ttu-id="57424-140">Proto příklad kódu pouze obklopuje část operace v `try/catch` bloku.</span><span class="sxs-lookup"><span data-stu-id="57424-140">Therefore, the code example just encloses that part of the operation in a `try/catch` block.</span></span> <span data-ttu-id="57424-141">Blok můžete změnit `catch` tak, aby při odepření přístupu ke složce se pokusili zvýšit oprávnění a pak k nim znovu získat přístup.</span><span class="sxs-lookup"><span data-stu-id="57424-141">You can modify the `catch` block so that when you are denied access to a folder, you try to elevate your permissions and then access it again.</span></span> <span data-ttu-id="57424-142">Jako pravidlo Zachyťte pouze ty výjimky, které lze zpracovat bez ukončení aplikace v neznámém stavu.</span><span class="sxs-lookup"><span data-stu-id="57424-142">As a rule, only catch those exceptions that you can handle without leaving your application in an unknown state.</span></span>  
  
 <span data-ttu-id="57424-143">Pokud je nutné uložit obsah stromu adresáře, buď v paměti nebo na disku, je nejlepší možností uložit pouze <xref:System.IO.FileSystemInfo.FullName%2A> vlastnost (typu `string` ) pro každý soubor.</span><span class="sxs-lookup"><span data-stu-id="57424-143">If you must store the contents of a directory tree, either in memory or on disk, the best option is to store only the <xref:System.IO.FileSystemInfo.FullName%2A> property (of type `string`) for each file.</span></span> <span data-ttu-id="57424-144">Pak můžete použít tento řetězec k vytvoření nového <xref:System.IO.FileInfo> <xref:System.IO.DirectoryInfo> objektu nebo v případě potřeby, nebo otevřít libovolný soubor, který vyžaduje další zpracování.</span><span class="sxs-lookup"><span data-stu-id="57424-144">You can then use this string to create a new <xref:System.IO.FileInfo> or <xref:System.IO.DirectoryInfo> object as necessary, or open any file that requires additional processing.</span></span>  
  
## <a name="robust-programming"></a><span data-ttu-id="57424-145">Robustní programování</span><span class="sxs-lookup"><span data-stu-id="57424-145">Robust Programming</span></span>  
 <span data-ttu-id="57424-146">Robustní kód pro iteraci souborů musí brát v úvahu mnoho složitých operací systému souborů.</span><span class="sxs-lookup"><span data-stu-id="57424-146">Robust file iteration code must take into account many complexities of the file system.</span></span> <span data-ttu-id="57424-147">Další informace o systému souborů systému Windows najdete v tématu [Přehled systému souborů NTFS](/windows-server/storage/file-server/ntfs-overview).</span><span class="sxs-lookup"><span data-stu-id="57424-147">For more information on the Windows file system, see [NTFS overview](/windows-server/storage/file-server/ntfs-overview).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="57424-148">Viz také:</span><span class="sxs-lookup"><span data-stu-id="57424-148">See also</span></span>

- <xref:System.IO>
- [<span data-ttu-id="57424-149">LINQ a souborové adresáře</span><span class="sxs-lookup"><span data-stu-id="57424-149">LINQ and File Directories</span></span>](../concepts/linq/linq-and-file-directories.md)
- [<span data-ttu-id="57424-150">Systém souborů a registr (Průvodce programováním v C#)</span><span class="sxs-lookup"><span data-stu-id="57424-150">File System and the Registry (C# Programming Guide)</span></span>](./index.md)
