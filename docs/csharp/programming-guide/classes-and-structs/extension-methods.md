---
title: Metody rozšíření – průvodce programováním jazyka C#
ms.date: 03/19/2020
helpviewer_keywords:
- methods [C#], adding to existing types
- extension methods [C#]
- methods [C#], extension
ms.assetid: 175ce3ff-9bbf-4e64-8421-faeb81a0bb51
ms.openlocfilehash: 0b35ad523fc7f0949cb5243edbdc50cd3e927999
ms.sourcegitcommit: 99b153b93bf94d0fecf7c7bcecb58ac424dfa47c
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 03/25/2020
ms.locfileid: "80249217"
---
# <a name="extension-methods-c-programming-guide"></a><span data-ttu-id="1a3e3-102">Metody rozšíření (Průvodce programováním v C#)</span><span class="sxs-lookup"><span data-stu-id="1a3e3-102">Extension Methods (C# Programming Guide)</span></span>

<span data-ttu-id="1a3e3-103">Metody rozšíření umožňují „přidávat“ metody ke stávajícím typům bez vytváření nového odvozeného typu, rekompilace nebo jiné změny původního typu.</span><span class="sxs-lookup"><span data-stu-id="1a3e3-103">Extension methods enable you to "add" methods to existing types without creating a new derived type, recompiling, or otherwise modifying the original type.</span></span> <span data-ttu-id="1a3e3-104">Rozšiřující metody jsou statické metody, ale jsou volány, jako by byly instance metody na rozšířený typ.</span><span class="sxs-lookup"><span data-stu-id="1a3e3-104">Extension methods are static methods, but they're called as if they were instance methods on the extended type.</span></span> <span data-ttu-id="1a3e3-105">Pro kód klienta napsaný v jazyce C#, F# a Visual Basic, neexistuje žádný zjevný rozdíl mezi voláním metody rozšíření a metodami definovanými v typu.</span><span class="sxs-lookup"><span data-stu-id="1a3e3-105">For client code written in C#, F# and Visual Basic, there's no apparent difference between calling an extension method and the methods defined in a type.</span></span>

<span data-ttu-id="1a3e3-106">Nejběžnější metody rozšíření jsou linq standardní dotaz operátory, které <xref:System.Collections.IEnumerable?displayProperty=nameWithType> <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> přidávají funkce dotazu na existující a typy.</span><span class="sxs-lookup"><span data-stu-id="1a3e3-106">The most common extension methods are the LINQ standard query operators that add query functionality to the existing <xref:System.Collections.IEnumerable?displayProperty=nameWithType> and <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> types.</span></span> <span data-ttu-id="1a3e3-107">Chcete-li použít standardní operátory dotazu, `using System.Linq` nejprve je uvést do oboru pomocí směrnice.</span><span class="sxs-lookup"><span data-stu-id="1a3e3-107">To use the standard query operators, first bring them into scope with a `using System.Linq` directive.</span></span> <span data-ttu-id="1a3e3-108">Pak libovolný typ, <xref:System.Collections.Generic.IEnumerable%601> který implementuje <xref:System.Linq.Enumerable.GroupBy%2A>zdá <xref:System.Linq.Enumerable.OrderBy%2A> <xref:System.Linq.Enumerable.Average%2A>mít instance metody, jako je například , , a tak dále.</span><span class="sxs-lookup"><span data-stu-id="1a3e3-108">Then any type that implements <xref:System.Collections.Generic.IEnumerable%601> appears to have instance methods such as <xref:System.Linq.Enumerable.GroupBy%2A>, <xref:System.Linq.Enumerable.OrderBy%2A>, <xref:System.Linq.Enumerable.Average%2A>, and so on.</span></span> <span data-ttu-id="1a3e3-109">Tyto další metody můžete vidět v příkazu IntelliSense dokončení, když <xref:System.Collections.Generic.IEnumerable%601> zadáte "tečka" za instanci typu, jako <xref:System.Collections.Generic.List%601> je například nebo <xref:System.Array>.</span><span class="sxs-lookup"><span data-stu-id="1a3e3-109">You can see these additional methods in IntelliSense statement completion when you type "dot" after an instance of an <xref:System.Collections.Generic.IEnumerable%601> type such as <xref:System.Collections.Generic.List%601> or <xref:System.Array>.</span></span>

### <a name="orderby-example"></a><span data-ttu-id="1a3e3-110">OrderBy Příklad</span><span class="sxs-lookup"><span data-stu-id="1a3e3-110">OrderBy Example</span></span>

<span data-ttu-id="1a3e3-111">Následující příklad ukazuje, jak volat `OrderBy` metodu operátoru standardního dotazu v poli celá čísla.</span><span class="sxs-lookup"><span data-stu-id="1a3e3-111">The following example shows how to call the standard query operator `OrderBy` method on an array of integers.</span></span> <span data-ttu-id="1a3e3-112">Výraz v závorkách je výraz lambda.</span><span class="sxs-lookup"><span data-stu-id="1a3e3-112">The expression in parentheses is a lambda expression.</span></span> <span data-ttu-id="1a3e3-113">Mnoho operátorů standardní dotaz ubírají lambda výrazy jako parametry, ale to není požadavek pro metody rozšíření.</span><span class="sxs-lookup"><span data-stu-id="1a3e3-113">Many standard query operators take lambda expressions as parameters, but this isn't a requirement for extension methods.</span></span> <span data-ttu-id="1a3e3-114">Další informace naleznete v tématu [Lambda Expressions](../statements-expressions-operators/lambda-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="1a3e3-114">For more information, see [Lambda Expressions](../statements-expressions-operators/lambda-expressions.md).</span></span>

[!code-csharp[csProgGuideExtensionMethods#3](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideExtensionMethods/cs/extensionmethods.cs#3)]

<span data-ttu-id="1a3e3-115">Metody rozšíření jsou definovány jako statické metody, ale jsou volány pomocí syntaxe metody instance.</span><span class="sxs-lookup"><span data-stu-id="1a3e3-115">Extension methods are defined as static methods but are called by using instance method syntax.</span></span> <span data-ttu-id="1a3e3-116">Jejich první parametr určuje, na kterém typu metoda pracuje.</span><span class="sxs-lookup"><span data-stu-id="1a3e3-116">Their first parameter specifies which type the method operates on.</span></span> <span data-ttu-id="1a3e3-117">Parametru předchází [tento](../../language-reference/keywords/this.md) modifikátor.</span><span class="sxs-lookup"><span data-stu-id="1a3e3-117">The parameter is preceded by the [this](../../language-reference/keywords/this.md) modifier.</span></span> <span data-ttu-id="1a3e3-118">Metody rozšíření jsou pouze v oboru, když explicitně importovat obor názvů do zdrojového kódu pomocí `using` směrnice.</span><span class="sxs-lookup"><span data-stu-id="1a3e3-118">Extension methods are only in scope when you explicitly import the namespace into your source code with a `using` directive.</span></span>

<span data-ttu-id="1a3e3-119">Následující příklad ukazuje metodu rozšíření <xref:System.String?displayProperty=nameWithType> definovanou pro třídu.</span><span class="sxs-lookup"><span data-stu-id="1a3e3-119">The following example shows an extension method defined for the <xref:System.String?displayProperty=nameWithType> class.</span></span> <span data-ttu-id="1a3e3-120">Je definována uvnitř nevnořené, neobecné statické třídy:</span><span class="sxs-lookup"><span data-stu-id="1a3e3-120">It's defined inside a non-nested, non-generic static class:</span></span>

[!code-csharp[csProgGuideExtensionMethods#4](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideExtensionMethods/cs/extensionmethods.cs#4)]

<span data-ttu-id="1a3e3-121">Metoda `WordCount` rozšíření může být uvedena `using` do oblasti působnosti s touto směrnicí:</span><span class="sxs-lookup"><span data-stu-id="1a3e3-121">The `WordCount` extension method can be brought into scope with this `using` directive:</span></span>

```csharp
using ExtensionMethods;
```

<span data-ttu-id="1a3e3-122">A může být volána z aplikace pomocí následující syntaxe:</span><span class="sxs-lookup"><span data-stu-id="1a3e3-122">And it can be called from an application by using this syntax:</span></span>

```csharp
string s = "Hello Extension Methods";
int i = s.WordCount();
```

<span data-ttu-id="1a3e3-123">Metodu rozšíření v kódu vyvoláte se syntaxí metody instance.</span><span class="sxs-lookup"><span data-stu-id="1a3e3-123">You invoke the extension method in your code with instance method syntax.</span></span> <span data-ttu-id="1a3e3-124">Zprostředkující jazyk (IL) generovaný kompilátorem převede váš kód do volání statické metody.</span><span class="sxs-lookup"><span data-stu-id="1a3e3-124">The intermediate language (IL) generated by the compiler translates your code into a call on the static method.</span></span> <span data-ttu-id="1a3e3-125">Princip zapouzdření není ve skutečnosti porušován.</span><span class="sxs-lookup"><span data-stu-id="1a3e3-125">The principle of encapsulation is not really being violated.</span></span> <span data-ttu-id="1a3e3-126">Rozšiřující metody nemají přístup k soukromým proměnným v typu, který rozšiřují.</span><span class="sxs-lookup"><span data-stu-id="1a3e3-126">Extension methods cannot access private variables in the type they are extending.</span></span>

<span data-ttu-id="1a3e3-127">Další informace naleznete v [tématu Jak implementovat a volat vlastní metodu rozšíření](./how-to-implement-and-call-a-custom-extension-method.md).</span><span class="sxs-lookup"><span data-stu-id="1a3e3-127">For more information, see [How to implement and call a custom  extension method](./how-to-implement-and-call-a-custom-extension-method.md).</span></span>

<span data-ttu-id="1a3e3-128">Obecně platí, že budete pravděpodobně volat metody rozšíření mnohem častěji než implementace vlastní.</span><span class="sxs-lookup"><span data-stu-id="1a3e3-128">In general, you'll probably be calling extension methods far more often than implementing your own.</span></span> <span data-ttu-id="1a3e3-129">Vzhledem k tomu, že metody rozšíření jsou volány pomocí syntaxe metody instance, není vyžadována žádná zvláštní znalost, abyste je mohli použít v klientském kódu.</span><span class="sxs-lookup"><span data-stu-id="1a3e3-129">Because extension methods are called by using instance method syntax, no special knowledge is required to use them from client code.</span></span> <span data-ttu-id="1a3e3-130">Chcete-li povolit metody rozšíření pro `using` určitý typ, stačí přidat direktivu pro obor názvů, ve kterém jsou definovány metody.</span><span class="sxs-lookup"><span data-stu-id="1a3e3-130">To enable extension methods for a particular type, just add a `using` directive for the namespace in which the methods are defined.</span></span> <span data-ttu-id="1a3e3-131">Chcete-li například použít standardní operátory dotazů, přidejte tuto `using` direktivu do kódu:</span><span class="sxs-lookup"><span data-stu-id="1a3e3-131">For example, to use the standard query operators, add this `using` directive to your code:</span></span>

```csharp
using System.Linq;
```

<span data-ttu-id="1a3e3-132">(Možná budete muset také přidat odkaz na soubor System.Core.dll.) Všimněte si, že standardní operátory dotazů se nyní zobrazují <xref:System.Collections.Generic.IEnumerable%601> v aplikaci IntelliSense jako další metody, které jsou k dispozici pro většinu typů.</span><span class="sxs-lookup"><span data-stu-id="1a3e3-132">(You may also have to add a reference to System.Core.dll.) You'll notice that the standard query operators now appear in IntelliSense as additional methods available for most <xref:System.Collections.Generic.IEnumerable%601> types.</span></span>

## <a name="binding-extension-methods-at-compile-time"></a><span data-ttu-id="1a3e3-133">Vytváření vazeb na metody rozšíření v době kompilace</span><span class="sxs-lookup"><span data-stu-id="1a3e3-133">Binding Extension Methods at Compile Time</span></span>

<span data-ttu-id="1a3e3-134">Metody rozšíření můžete použít k rozšíření třídy nebo rozhraní, nikoli však k jejich přepsání.</span><span class="sxs-lookup"><span data-stu-id="1a3e3-134">You can use extension methods to extend a class or interface, but not to override them.</span></span> <span data-ttu-id="1a3e3-135">Metoda rozšíření se stejným názvem a signaturou, jako má rozhraní nebo metoda třídy, nebude nikdy volána.</span><span class="sxs-lookup"><span data-stu-id="1a3e3-135">An extension method with the same name and signature as an interface or class method will never be called.</span></span> <span data-ttu-id="1a3e3-136">V době kompilace mají metody rozšíření vždy nižší prioritu než metody instance definované v samotném typu.</span><span class="sxs-lookup"><span data-stu-id="1a3e3-136">At compile time, extension methods always have lower priority than instance methods defined in the type itself.</span></span> <span data-ttu-id="1a3e3-137">Jinými slovy, pokud má typ `Process(int i)`metodu s názvem a máte metodu rozšíření se stejným podpisem, kompilátor se vždy sváže s metodou instance.</span><span class="sxs-lookup"><span data-stu-id="1a3e3-137">In other words, if a type has a method named `Process(int i)`, and you have an extension method with the same signature, the compiler will always bind to the instance method.</span></span> <span data-ttu-id="1a3e3-138">Pokud kompilátor narazí na vyvolání metody, nejprve vyhledá shodu v metodách instance tohoto typu.</span><span class="sxs-lookup"><span data-stu-id="1a3e3-138">When the compiler encounters a method invocation, it first looks for a match in the type's instance methods.</span></span> <span data-ttu-id="1a3e3-139">Pokud není nalezena žádná shoda, budou vyhledány jakékoli metody rozšíření, které jsou definovány pro daný typ, a budou připojeny k první vyhledané metodě rozšíření.</span><span class="sxs-lookup"><span data-stu-id="1a3e3-139">If no match is found, it will search for any extension methods that are defined for the type, and bind to the first extension method that it finds.</span></span> <span data-ttu-id="1a3e3-140">Následující příklad znázorňuje, jakým způsobem kompilátor určuje, se kterou metodou rozšíření nebo metodou instance má vytvořit vazbu.</span><span class="sxs-lookup"><span data-stu-id="1a3e3-140">The following example demonstrates how the compiler determines which extension method or instance method to bind to.</span></span>

## <a name="example"></a><span data-ttu-id="1a3e3-141">Příklad</span><span class="sxs-lookup"><span data-stu-id="1a3e3-141">Example</span></span>

<span data-ttu-id="1a3e3-142">Následující příklad znázorňuje pravidla, které u kompilátoru jazyka C# určují, zda vytvořit vazbu volání metody s metodou instance v rámci typu, nebo s metodou rozšíření.</span><span class="sxs-lookup"><span data-stu-id="1a3e3-142">The following example demonstrates the rules that the C# compiler follows in determining whether to bind a method call to an instance method on the type, or to an extension method.</span></span> <span data-ttu-id="1a3e3-143">Statická `Extensions` třída obsahuje rozšiřující metody definované `IMyInterface`pro libovolný typ, který implementuje .</span><span class="sxs-lookup"><span data-stu-id="1a3e3-143">The static class `Extensions` contains extension methods defined for any type that implements `IMyInterface`.</span></span> <span data-ttu-id="1a3e3-144">`A`Třídy `B`, `C` a všechny implementovat rozhraní.</span><span class="sxs-lookup"><span data-stu-id="1a3e3-144">Classes `A`, `B`, and `C` all implement the interface.</span></span>

<span data-ttu-id="1a3e3-145">Metoda `MethodB` rozšíření je nikdy volána, protože její název a podpis přesně odpovídají metodám, které již byly implementovány třídami.</span><span class="sxs-lookup"><span data-stu-id="1a3e3-145">The `MethodB` extension method is never called because its name and signature exactly match methods already implemented by the classes.</span></span>

<span data-ttu-id="1a3e3-146">Když kompilátor nemůže najít metodu instance s odpovídajícím podpisem, sváže se s odpovídající metodou rozšíření, pokud existuje.</span><span class="sxs-lookup"><span data-stu-id="1a3e3-146">When the compiler can't find an instance method with a matching signature, it will bind to a matching extension method if one exists.</span></span>

[!code-csharp[csProgGuideExtensionMethods#5](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideExtensionMethods/cs/extensionmethods.cs#5)]

## <a name="common-usage-patterns"></a><span data-ttu-id="1a3e3-147">Běžné vzory použití</span><span class="sxs-lookup"><span data-stu-id="1a3e3-147">Common Usage Patterns</span></span>

### <a name="collection-functionality"></a><span data-ttu-id="1a3e3-148">Funkce kolekce</span><span class="sxs-lookup"><span data-stu-id="1a3e3-148">Collection Functionality</span></span>

<span data-ttu-id="1a3e3-149">V minulosti bylo běžné vytvořit "Třídy kolekce", které <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> implementovaly rozhraní pro daný typ a obsahovaly funkce, které fungovaly na kolekcích tohoto typu.</span><span class="sxs-lookup"><span data-stu-id="1a3e3-149">In the past, it was common to create "Collection Classes" that implemented the <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> interface for a given type and contained functionality that acted on collections of that type.</span></span> <span data-ttu-id="1a3e3-150">I když není nic špatného na vytvoření tohoto typu objektu kolekce, stejné <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType>funkce lze dosáhnout pomocí rozšíření na .</span><span class="sxs-lookup"><span data-stu-id="1a3e3-150">While there's nothing wrong with creating this type of collection object, the same functionality can be achieved by using an extension on the <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType>.</span></span> <span data-ttu-id="1a3e3-151">Rozšíření mají tu výhodu, že umožňuje funkce, které mají <xref:System.Array?displayProperty=nameWithType> být <xref:System.Collections.Generic.List%601?displayProperty=nameWithType> volány <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> z libovolné kolekce, jako je například nebo který implementuje na tento typ.</span><span class="sxs-lookup"><span data-stu-id="1a3e3-151">Extensions have the advantage of allowing the functionality to be called from any collection such as an <xref:System.Array?displayProperty=nameWithType> or <xref:System.Collections.Generic.List%601?displayProperty=nameWithType> that implements <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> on that type.</span></span> <span data-ttu-id="1a3e3-152">Příklad tohoto použití pole Int32 lze nalézt [dříve v tomto článku](#orderby-example).</span><span class="sxs-lookup"><span data-stu-id="1a3e3-152">An example of this using an Array of Int32 can be found [earlier in this article](#orderby-example).</span></span>

### <a name="layer-specific-functionality"></a><span data-ttu-id="1a3e3-153">Funkce specifické pro vrstvu</span><span class="sxs-lookup"><span data-stu-id="1a3e3-153">Layer-Specific Functionality</span></span>

<span data-ttu-id="1a3e3-154">Při použití architektury cibule nebo jiné vrstvené aplikace návrhu, je běžné mít sadu entit domény nebo přenosu dat objekty, které lze použít ke komunikaci přes hranice aplikace.</span><span class="sxs-lookup"><span data-stu-id="1a3e3-154">When using an Onion Architecture or other layered application design, it's common to have a set of Domain Entities or Data Transfer Objects that can be used to communicate across application boundaries.</span></span> <span data-ttu-id="1a3e3-155">Tyto objekty obecně neobsahují žádné funkce nebo pouze minimální funkce, které platí pro všechny vrstvy aplikace.</span><span class="sxs-lookup"><span data-stu-id="1a3e3-155">These objects generally contain no functionality, or only minimal functionality that applies to all layers of the application.</span></span> <span data-ttu-id="1a3e3-156">Rozšiřující metody lze použít k přidání funkce, která je specifická pro každou aplikační vrstvu bez načtení objektu pomocí metod, které nejsou potřeba nebo jsou žádoucí v jiných vrstvách.</span><span class="sxs-lookup"><span data-stu-id="1a3e3-156">Extension methods can be used to add functionality that is specific to each application layer without loading the object down with methods not needed or wanted in other layers.</span></span>

```aspx-csharp
public class DomainEntity
{
    public int Id { get; set; }
    public string FirstName { get; set; }
    public string LastName { get; set; }
}

static class DomainEntityExtensions
{
    static string FullName(this DomainEntity value)
        => $"{value.FirstName} {value.LastName}";
}
```

### <a name="extending-predefined-types"></a><span data-ttu-id="1a3e3-157">Rozšíření předdefinovaných typů</span><span class="sxs-lookup"><span data-stu-id="1a3e3-157">Extending Predefined Types</span></span>

<span data-ttu-id="1a3e3-158">Spíše než vytváření nových objektů při opakovaně použitelné funkce je třeba vytvořit, můžeme často rozšířit existující typ, jako je například .NET Framework nebo CLR typu.</span><span class="sxs-lookup"><span data-stu-id="1a3e3-158">Rather than creating new objects when reusable functionality needs to be created, we can often extend an existing type such as a .NET Framework or CLR type.</span></span> <span data-ttu-id="1a3e3-159">Jako příklad pokud nepoužíváme metody rozšíření, můžeme vytvořit `Engine` `Query` nebo třídy provést práci provádění dotazu na SQL Server, který může být volána z více míst v našem kódu.</span><span class="sxs-lookup"><span data-stu-id="1a3e3-159">As an example, if we don't use extension methods, we might create an `Engine` or `Query` class to do the work of executing a query on a SQL Server that may be called from multiple places in our code.</span></span> <span data-ttu-id="1a3e3-160">Nicméně můžeme místo <xref:System.Data.SqlClient.SqlConnection?displayProperty=nameWithType> toho rozšířit třídu pomocí rozšiřujících metod k provedení tohoto dotazu z libovolného místa, kde máme připojení k SERVERU SQL.</span><span class="sxs-lookup"><span data-stu-id="1a3e3-160">However we can instead extend the <xref:System.Data.SqlClient.SqlConnection?displayProperty=nameWithType> class using extension methods to perform that query from anywhere we have a connection to a SQL Server.</span></span> <span data-ttu-id="1a3e3-161">Dalšími příklady mohou být přidání <xref:System.String?displayProperty=nameWithType> běžných funkcí do třídy, <xref:System.IO.Stream?displayProperty=nameWithType> rozšíření <xref:System.Exception?displayProperty=nameWithType> možností zpracování dat objektů <xref:System.IO.File?displayProperty=nameWithType> a objektů a objektů pro konkrétní funkce zpracování chyb.</span><span class="sxs-lookup"><span data-stu-id="1a3e3-161">Other examples might be to add common functionality to the <xref:System.String?displayProperty=nameWithType> class, extend the data processing capabilities of the <xref:System.IO.File?displayProperty=nameWithType> and <xref:System.IO.Stream?displayProperty=nameWithType> objects, and <xref:System.Exception?displayProperty=nameWithType> objects for specific error handling functionality.</span></span> <span data-ttu-id="1a3e3-162">Tyto typy případů použití jsou omezeny pouze vaší představivostí a zdravým rozumem.</span><span class="sxs-lookup"><span data-stu-id="1a3e3-162">These types of use-cases are limited only by your imagination and good sense.</span></span>

<span data-ttu-id="1a3e3-163">Rozšíření předdefinovaných typů může `struct` být obtížné s typy, protože jsou předány hodnotou metodám.</span><span class="sxs-lookup"><span data-stu-id="1a3e3-163">Extending predefined types can be difficult with `struct` types because they're passed by value to methods.</span></span> <span data-ttu-id="1a3e3-164">To znamená, že všechny změny struktury jsou provedeny na kopii struktury.</span><span class="sxs-lookup"><span data-stu-id="1a3e3-164">That means any changes to the struct are made to a copy of the struct.</span></span> <span data-ttu-id="1a3e3-165">Tyto změny nejsou viditelné po ukončení metody rozšíření.</span><span class="sxs-lookup"><span data-stu-id="1a3e3-165">Those changes aren't visible once the extension method exits.</span></span> <span data-ttu-id="1a3e3-166">Počínaje C# 7.2, můžete `ref` přidat modifikátor k prvnímu argumentu metody rozšíření.</span><span class="sxs-lookup"><span data-stu-id="1a3e3-166">Beginning with C# 7.2, you can add the `ref` modifier to the first argument of an extension method.</span></span> <span data-ttu-id="1a3e3-167">Přidání `ref` modifikátoru znamená, že první argument je předán odkazem.</span><span class="sxs-lookup"><span data-stu-id="1a3e3-167">Adding the `ref` modifier means the first argument is passed by reference.</span></span> <span data-ttu-id="1a3e3-168">To umožňuje psát metody rozšíření, které mění stav struktury, která je rozšířena.</span><span class="sxs-lookup"><span data-stu-id="1a3e3-168">This enables you to write extension methods that change the state of the struct being extended.</span></span>

## <a name="general-guidelines"></a><span data-ttu-id="1a3e3-169">Obecné pokyny</span><span class="sxs-lookup"><span data-stu-id="1a3e3-169">General Guidelines</span></span>

<span data-ttu-id="1a3e3-170">I když je stále považováno za vhodnější přidat funkce úpravou kódu objektu nebo odvozením nového typu, kdykoli je to rozumné a možné, metody rozšíření se staly klíčovou možností pro vytváření opakovaně použitelných funkcí v celé .NET Ekosystému.</span><span class="sxs-lookup"><span data-stu-id="1a3e3-170">While it's still considered preferable to add functionality by modifying an object's code or deriving a new type whenever it's reasonable and possible to do so, extension methods have become a crucial option for creating reusable functionality throughout the .NET ecosystem.</span></span> <span data-ttu-id="1a3e3-171">Pro ty případy, kdy původní zdroj není pod vaší kontrolou, když odvozený objekt je nevhodné nebo nemožné, nebo když funkce by neměla být vystaveny mimo jeho příslušný rozsah, Extension metody jsou vynikající volbou.</span><span class="sxs-lookup"><span data-stu-id="1a3e3-171">For those occasions when the original source isn't under your control, when a derived object is inappropriate or impossible, or when the functionality shouldn't be exposed beyond its applicable scope, Extension methods are an excellent choice.</span></span>

<span data-ttu-id="1a3e3-172">Další informace o odvozených typech naleznete v [tématu Dědičnost](./inheritance.md).</span><span class="sxs-lookup"><span data-stu-id="1a3e3-172">For more information on derived types, see [Inheritance](./inheritance.md).</span></span>

<span data-ttu-id="1a3e3-173">Při použití metody rozšíření rozšířit typ, jehož zdrojový kód, který nejste pod kontrolou, riskujete, že změna v implementaci typu způsobí, že se metoda rozšíření přeruší.</span><span class="sxs-lookup"><span data-stu-id="1a3e3-173">When using an extension method to extend a type whose source code you aren't in control of, you run the risk that a change in the implementation of the type will cause your extension method to break.</span></span>

<span data-ttu-id="1a3e3-174">Pokud implementujete metody rozšíření pro daný typ, nezapomeňte na následující body:</span><span class="sxs-lookup"><span data-stu-id="1a3e3-174">If you do implement extension methods for a given type, remember the following points:</span></span>

- <span data-ttu-id="1a3e3-175">Metoda rozšíření nebude nikdy volána, pokud má stejnou signaturu jako metoda definovaná v typu.</span><span class="sxs-lookup"><span data-stu-id="1a3e3-175">An extension method will never be called if it has the same signature as a method defined in the type.</span></span>
- <span data-ttu-id="1a3e3-176">Dále jsou metody rozšíření přeneseny do rozsahu na úrovni oboru názvů.</span><span class="sxs-lookup"><span data-stu-id="1a3e3-176">Extension methods are brought into scope at the namespace level.</span></span> <span data-ttu-id="1a3e3-177">Například pokud máte více statických tříd, které obsahují `Extensions`metody rozšíření v jednom oboru názvů `using Extensions;` s názvem , budou všechny uvedeny do oboru směrnice.</span><span class="sxs-lookup"><span data-stu-id="1a3e3-177">For example, if you have multiple static classes that contain extension methods in a single namespace named `Extensions`, they'll all be brought into scope by the `using Extensions;` directive.</span></span>

<span data-ttu-id="1a3e3-178">Chcete-li zamezit zvýšení čísla verze sestavení, neměli byste pro implementovanou knihovnu metody rozšíření používat.</span><span class="sxs-lookup"><span data-stu-id="1a3e3-178">For a class library that you implemented, you shouldn't use extension methods to avoid incrementing the version number of an assembly.</span></span> <span data-ttu-id="1a3e3-179">Pokud chcete přidat významné funkce do knihovny, jejíž zdrojový kód vlastníte, měli byste postupovat podle standardních pokynů pro rozhraní .NET Framework pro správu verzí sestavení.</span><span class="sxs-lookup"><span data-stu-id="1a3e3-179">If you want to add significant functionality to a library for which you own the source code, you should follow the standard .NET Framework guidelines for assembly versioning.</span></span> <span data-ttu-id="1a3e3-180">Další informace naleznete v [tématu Správa verzí sestavení](../../../standard/assembly/versioning.md).</span><span class="sxs-lookup"><span data-stu-id="1a3e3-180">For more information, see [Assembly Versioning](../../../standard/assembly/versioning.md).</span></span>

## <a name="see-also"></a><span data-ttu-id="1a3e3-181">Viz také</span><span class="sxs-lookup"><span data-stu-id="1a3e3-181">See also</span></span>

- [<span data-ttu-id="1a3e3-182">Programovací příručka jazyka C#</span><span class="sxs-lookup"><span data-stu-id="1a3e3-182">C# Programming Guide</span></span>](../index.md)
- [<span data-ttu-id="1a3e3-183">Ukázky paralelního programování (mezi ně patří mnoho ukázkových metod rozšíření)</span><span class="sxs-lookup"><span data-stu-id="1a3e3-183">Parallel Programming Samples (these include many example extension methods)</span></span>](https://code.msdn.microsoft.com/Samples-for-Parallel-b4b76364)
- [<span data-ttu-id="1a3e3-184">Lambda výrazy</span><span class="sxs-lookup"><span data-stu-id="1a3e3-184">Lambda Expressions</span></span>](../statements-expressions-operators/lambda-expressions.md)
- [<span data-ttu-id="1a3e3-185">Přehled standardních operátorů dotazu</span><span class="sxs-lookup"><span data-stu-id="1a3e3-185">Standard Query Operators Overview</span></span>](../concepts/linq/standard-query-operators-overview.md)
- [<span data-ttu-id="1a3e3-186">Pravidla převodu parametrů instance a jejich dopad</span><span class="sxs-lookup"><span data-stu-id="1a3e3-186">Conversion rules for Instance parameters and their impact</span></span>](https://docs.microsoft.com/archive/blogs/sreekarc/conversion-rules-for-instance-parameters-and-their-impact)
- [<span data-ttu-id="1a3e3-187">Metody rozšíření Interoperabilita mezi jazyky</span><span class="sxs-lookup"><span data-stu-id="1a3e3-187">Extension methods Interoperability between languages</span></span>](https://docs.microsoft.com/archive/blogs/sreekarc/extension-methods-interoperability-between-languages)
- [<span data-ttu-id="1a3e3-188">Rozšiřující metody a curried delegáti</span><span class="sxs-lookup"><span data-stu-id="1a3e3-188">Extension methods and Curried Delegates</span></span>](https://docs.microsoft.com/archive/blogs/sreekarc/extension-methods-and-curried-delegates)
- [<span data-ttu-id="1a3e3-189">Vazby metody rozšíření a hlášení chyb</span><span class="sxs-lookup"><span data-stu-id="1a3e3-189">Extension method Binding and Error reporting</span></span>](https://docs.microsoft.com/archive/blogs/sreekarc/extension-method-binding-and-error-reporting)
