---
title: Třídy a struktury - C# Programovací průvodce
description: Popisuje použití tříd a struktur (struktur) v c#.
ms.date: 01/17/2016
helpviewer_keywords:
- structs [C#], about structs
- classes [C#], overview
- C# language, structs
- C# language, objects
- objects [C#]
- C# language, classes
ms.assetid: cc39dbda-8754-423e-b5b1-16a1db0734c0
ms.openlocfilehash: afd9e688bd716375bafb370fad4af082a9498411
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 03/15/2020
ms.locfileid: "79399852"
---
# <a name="classes-and-structs-c-programming-guide"></a><span data-ttu-id="f57df-103">Třídy a struktury (Průvodce programováním v C#)</span><span class="sxs-lookup"><span data-stu-id="f57df-103">Classes and Structs (C# Programming Guide)</span></span>
<span data-ttu-id="f57df-104">Třídy a struktury jsou dvě základní konstrukce společného systému typů v rozhraní .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="f57df-104">Classes and structs are two of the basic constructs of the common type system in the .NET Framework.</span></span> <span data-ttu-id="f57df-105">Každý z nich je v podstatě datová struktura, která zapouzdřuje sadu dat a chování, které patří k sobě jako logická jednotka.</span><span class="sxs-lookup"><span data-stu-id="f57df-105">Each is essentially a data structure that encapsulates a set of data and behaviors that belong together as a logical unit.</span></span> <span data-ttu-id="f57df-106">Data a chování jsou *členy* třídy nebo struktury a zahrnují jeho metody, vlastnosti a události a tak dále, jak je uvedeno dále v tomto tématu.</span><span class="sxs-lookup"><span data-stu-id="f57df-106">The data and behaviors are the *members* of the class or struct, and they include its methods, properties, and events, and so on, as listed later in this topic.</span></span>  
  
 <span data-ttu-id="f57df-107">Deklarace třídy nebo struktury je jako podrobný plán, který se používá k vytvoření instancí nebo objektů za běhu.</span><span class="sxs-lookup"><span data-stu-id="f57df-107">A class or struct declaration is like a blueprint that is used to create instances or objects at run time.</span></span> <span data-ttu-id="f57df-108">Pokud definujete třídu nebo `Person` `Person` strukturu s názvem , je název typu.</span><span class="sxs-lookup"><span data-stu-id="f57df-108">If you define a class or struct called `Person`, `Person` is the name of the type.</span></span> <span data-ttu-id="f57df-109">Pokud deklarujete `p` a `Person`inicializujete proměnnou typu , `p` znamená to, že je objekt nebo instance aplikace `Person`.</span><span class="sxs-lookup"><span data-stu-id="f57df-109">If you declare and initialize a variable `p` of type `Person`, `p` is said to be an object or instance of `Person`.</span></span> <span data-ttu-id="f57df-110">Lze vytvořit více `Person` instancí stejného typu a každá instance může mít ve svých vlastnostech a polích různé hodnoty.</span><span class="sxs-lookup"><span data-stu-id="f57df-110">Multiple instances of the same `Person` type can be created, and each instance can have different values in its properties and fields.</span></span>  
  
 <span data-ttu-id="f57df-111">Třída je typ odkazu.</span><span class="sxs-lookup"><span data-stu-id="f57df-111">A class is a reference type.</span></span> <span data-ttu-id="f57df-112">Při vytvoření objektu třídy proměnná, ke které je objekt přiřazen, obsahuje pouze odkaz na tuto paměť.</span><span class="sxs-lookup"><span data-stu-id="f57df-112">When an object of the class is created, the variable to which the object is assigned holds only a reference to that memory.</span></span> <span data-ttu-id="f57df-113">Když je odkaz na objekt přiřazen nové proměnné, nová proměnná odkazuje na původní objekt.</span><span class="sxs-lookup"><span data-stu-id="f57df-113">When the object reference is assigned to a new variable, the new variable refers to the original object.</span></span> <span data-ttu-id="f57df-114">Změny provedené prostřednictvím jedné proměnné se projeví v druhé proměnné, protože obě odkazují na stejná data.</span><span class="sxs-lookup"><span data-stu-id="f57df-114">Changes made through one variable are reflected in the other variable because they both refer to the same data.</span></span>  
  
 <span data-ttu-id="f57df-115">Struktura je typ hodnoty.</span><span class="sxs-lookup"><span data-stu-id="f57df-115">A struct is a value type.</span></span> <span data-ttu-id="f57df-116">Při vytvoření struktury, proměnná, ke které je přiřazena struktura obsahuje aktuální data struktury.</span><span class="sxs-lookup"><span data-stu-id="f57df-116">When a struct is created, the variable to which the struct is assigned holds the struct's actual data.</span></span> <span data-ttu-id="f57df-117">Když je struktura přiřazena nové proměnné, zkopíruje se.</span><span class="sxs-lookup"><span data-stu-id="f57df-117">When the struct is assigned to a new variable, it is copied.</span></span> <span data-ttu-id="f57df-118">Nová proměnná a původní proměnná proto obsahují dvě samostatné kopie stejných dat.</span><span class="sxs-lookup"><span data-stu-id="f57df-118">The new variable and the original variable therefore contain two separate copies of the same data.</span></span> <span data-ttu-id="f57df-119">Změny provedené v jedné kopii nemají vliv na druhou kopii.</span><span class="sxs-lookup"><span data-stu-id="f57df-119">Changes made to one copy do not affect the other copy.</span></span>  
  
 <span data-ttu-id="f57df-120">Obecně platí, že třídy se používají k modelování složitější chování nebo data, která je určena k úpravě po vytvoření objektu třídy.</span><span class="sxs-lookup"><span data-stu-id="f57df-120">In general, classes are used to model more complex behavior, or data that is intended to be modified after a class object is created.</span></span> <span data-ttu-id="f57df-121">Struktury jsou nejvhodnější pro malé datové struktury, které obsahují především data, která není určena k úpravě po vytvoření struktury.</span><span class="sxs-lookup"><span data-stu-id="f57df-121">Structs are best suited for small data structures that contain primarily data that is not intended to be modified after the struct is created.</span></span>  
  
 <span data-ttu-id="f57df-122">Další informace naleznete v [tématu Třídy](./classes.md), [Objekty](./objects.md)a [Structure typy](../../language-reference/builtin-types/struct.md).</span><span class="sxs-lookup"><span data-stu-id="f57df-122">For more information, see [Classes](./classes.md), [Objects](./objects.md), and [Structure types](../../language-reference/builtin-types/struct.md).</span></span>  
  
## <a name="example"></a><span data-ttu-id="f57df-123">Příklad</span><span class="sxs-lookup"><span data-stu-id="f57df-123">Example</span></span>  
 <span data-ttu-id="f57df-124">V `CustomClass` následujícím příkladu `ProgrammingGuide` má v oboru názvů tři členy: konstruktor instance, vlastnost s názvem `Number`a metodu s názvem `Multiply`.</span><span class="sxs-lookup"><span data-stu-id="f57df-124">In the following example, `CustomClass` in the `ProgrammingGuide` namespace has three members: an instance constructor, a property named `Number`, and a method named `Multiply`.</span></span> <span data-ttu-id="f57df-125">Metoda `Main` ve `Program` třídě vytvoří instanci `CustomClass`(objekt) aplikace a metoda a vlastnost objektu jsou přístupné pomocí tečkového zápisu.</span><span class="sxs-lookup"><span data-stu-id="f57df-125">The `Main` method in the `Program` class creates an instance (object) of `CustomClass`, and the object’s method and property are accessed by using dot notation.</span></span>
  
 [!code-csharp[csProgGuideObjects#1](../../../../samples/snippets/csharp/programming-guide/classes-and-structs/class1.cs#1)]  
  
## <a name="encapsulation"></a><span data-ttu-id="f57df-126">Zapouzdření</span><span class="sxs-lookup"><span data-stu-id="f57df-126">Encapsulation</span></span>  
 <span data-ttu-id="f57df-127">*Zapouzdření* se někdy označuje jako první pilíř nebo princip objektově orientovaného programování.</span><span class="sxs-lookup"><span data-stu-id="f57df-127">*Encapsulation* is sometimes referred to as the first pillar or principle of object-oriented programming.</span></span> <span data-ttu-id="f57df-128">Podle principu zapouzdření může třída nebo struktura určit, jak je každý z jeho členů přístupný kódu mimo třídu nebo strukturu.</span><span class="sxs-lookup"><span data-stu-id="f57df-128">According to the principle of encapsulation, a class or struct can specify how accessible each of its members is to code outside of the class or struct.</span></span> <span data-ttu-id="f57df-129">Metody a proměnné, které nejsou určeny k použití mimo třídu nebo sestavení, mohou být skryty, aby se omezilpotenciál chyb kódování nebo škodlivých zneužití.</span><span class="sxs-lookup"><span data-stu-id="f57df-129">Methods and variables that are not intended to be used from outside of the class or assembly can be hidden to limit the potential for coding errors or malicious exploits.</span></span>  
  
 <span data-ttu-id="f57df-130">Další informace o třídách naleznete v [tématu Třídy](./classes.md) a [objekty](./objects.md).</span><span class="sxs-lookup"><span data-stu-id="f57df-130">For more information about classes, see [Classes](./classes.md) and [Objects](./objects.md).</span></span>  
  
### <a name="members"></a><span data-ttu-id="f57df-131">Členové</span><span class="sxs-lookup"><span data-stu-id="f57df-131">Members</span></span>  
 <span data-ttu-id="f57df-132">Všechny metody, pole, konstanty, vlastnosti a události musí být deklarovány v rámci typu; tyto se nazývají *členy* typu.</span><span class="sxs-lookup"><span data-stu-id="f57df-132">All methods, fields, constants, properties, and events must be declared within a type; these are called the *members* of the type.</span></span> <span data-ttu-id="f57df-133">V jazyce C# neexistují žádné globální proměnné nebo metody, jako jsou v některých jiných jazycích.</span><span class="sxs-lookup"><span data-stu-id="f57df-133">In C#, there are no global variables or methods as there are in some other languages.</span></span> <span data-ttu-id="f57df-134">I vstupní bod programu, `Main` metoda, musí být deklarován v rámci třídy nebo struktury.</span><span class="sxs-lookup"><span data-stu-id="f57df-134">Even a program's entry point, the `Main` method, must be declared within a class or struct.</span></span> <span data-ttu-id="f57df-135">Následující seznam obsahuje všechny různé druhy členů, které mohou být deklarovány ve třídě nebo struktuře.</span><span class="sxs-lookup"><span data-stu-id="f57df-135">The following list includes all the various kinds of members that may be declared in a class or struct.</span></span>  
  
- [<span data-ttu-id="f57df-136">Pole</span><span class="sxs-lookup"><span data-stu-id="f57df-136">Fields</span></span>](./fields.md)  
  
- [<span data-ttu-id="f57df-137">Konstanty</span><span class="sxs-lookup"><span data-stu-id="f57df-137">Constants</span></span>](./constants.md)  
  
- [<span data-ttu-id="f57df-138">Vlastnosti</span><span class="sxs-lookup"><span data-stu-id="f57df-138">Properties</span></span>](./properties.md)  
  
- [<span data-ttu-id="f57df-139">Metody</span><span class="sxs-lookup"><span data-stu-id="f57df-139">Methods</span></span>](./methods.md)  
  
- [<span data-ttu-id="f57df-140">Konstruktory</span><span class="sxs-lookup"><span data-stu-id="f57df-140">Constructors</span></span>](./constructors.md)  
  
- [<span data-ttu-id="f57df-141">Akce</span><span class="sxs-lookup"><span data-stu-id="f57df-141">Events</span></span>](../events/index.md)  
  
- [<span data-ttu-id="f57df-142">Finalizační metody</span><span class="sxs-lookup"><span data-stu-id="f57df-142">Finalizers</span></span>](./destructors.md)  
  
- [<span data-ttu-id="f57df-143">Indexery</span><span class="sxs-lookup"><span data-stu-id="f57df-143">Indexers</span></span>](../indexers/index.md)  
  
- [<span data-ttu-id="f57df-144">Operátory</span><span class="sxs-lookup"><span data-stu-id="f57df-144">Operators</span></span>](../../language-reference/operators/index.md)  
  
- [<span data-ttu-id="f57df-145">Vnořené typy</span><span class="sxs-lookup"><span data-stu-id="f57df-145">Nested Types</span></span>](./nested-types.md)  
  
### <a name="accessibility"></a><span data-ttu-id="f57df-146">Přístupnost</span><span class="sxs-lookup"><span data-stu-id="f57df-146">Accessibility</span></span>  
 <span data-ttu-id="f57df-147">Některé metody a vlastnosti jsou určeny k volání nebo přístup z kódu mimo vaši třídu nebo strukturu, známé jako *klientský kód*.</span><span class="sxs-lookup"><span data-stu-id="f57df-147">Some methods and properties are meant to be called or accessed from code outside your class or struct, known as *client code*.</span></span> <span data-ttu-id="f57df-148">Jiné metody a vlastnosti mohou být pouze pro použití ve třídě nebo struktuře samotné.</span><span class="sxs-lookup"><span data-stu-id="f57df-148">Other methods and properties might be only for use in the class or struct itself.</span></span> <span data-ttu-id="f57df-149">Je důležité omezit přístupnost kódu tak, aby k němu mohl dosáhnout pouze zamýšlený klientský kód.</span><span class="sxs-lookup"><span data-stu-id="f57df-149">It is important to limit the accessibility of your code so that only the intended client code can reach it.</span></span> <span data-ttu-id="f57df-150">Můžete určit, jak přístupné jsou vaše typy a jejich členy klientského kódu pomocí modifikátorů přístupu [veřejné](../../language-reference/keywords/public.md), [chráněné](../../language-reference/keywords/protected.md), [interní](../../language-reference/keywords/internal.md), [chráněné interní,](../../language-reference/keywords/protected-internal.md) [soukromé](../../language-reference/keywords/private.md) a [soukromé chráněné](../../language-reference/keywords/private-protected.md).</span><span class="sxs-lookup"><span data-stu-id="f57df-150">You specify how accessible your types and their members are to client code by using the access modifiers [public](../../language-reference/keywords/public.md), [protected](../../language-reference/keywords/protected.md), [internal](../../language-reference/keywords/internal.md), [protected internal](../../language-reference/keywords/protected-internal.md), [private](../../language-reference/keywords/private.md) and [private protected](../../language-reference/keywords/private-protected.md).</span></span> <span data-ttu-id="f57df-151">Výchozí usnadnění `private`přístupu je .</span><span class="sxs-lookup"><span data-stu-id="f57df-151">The default accessibility is `private`.</span></span> <span data-ttu-id="f57df-152">Další informace naleznete [v tématu Access Modifiers](./access-modifiers.md).</span><span class="sxs-lookup"><span data-stu-id="f57df-152">For more information, see [Access Modifiers](./access-modifiers.md).</span></span>  
  
### <a name="inheritance"></a><span data-ttu-id="f57df-153">Dědičnost</span><span class="sxs-lookup"><span data-stu-id="f57df-153">Inheritance</span></span>  
 <span data-ttu-id="f57df-154">Třídy (ale ne struktury) podporují koncept dědičnosti.</span><span class="sxs-lookup"><span data-stu-id="f57df-154">Classes (but not structs) support the concept of inheritance.</span></span> <span data-ttu-id="f57df-155">Třída, která je odvozena z jiné třídy *(základní třída)* automaticky obsahuje všechny veřejné, chráněné a interní členy základní třídy s výjimkou jejích konstruktorů a finalizačních metod.</span><span class="sxs-lookup"><span data-stu-id="f57df-155">A class that derives from another class (the *base class*) automatically contains all the public, protected, and internal members of the base class except its constructors and finalizers.</span></span> <span data-ttu-id="f57df-156">Další informace naleznete v [tématu Dědičnost](./inheritance.md) a [polymorfismus](./polymorphism.md).</span><span class="sxs-lookup"><span data-stu-id="f57df-156">For more information, see [Inheritance](./inheritance.md) and [Polymorphism](./polymorphism.md).</span></span>  
  
 <span data-ttu-id="f57df-157">Třídy mohou být deklarovány jako [abstraktní](../../language-reference/keywords/abstract.md), což znamená, že jedna nebo více jejich metod nemá žádnou implementaci.</span><span class="sxs-lookup"><span data-stu-id="f57df-157">Classes may be declared as [abstract](../../language-reference/keywords/abstract.md), which means that one or more of their methods have no implementation.</span></span> <span data-ttu-id="f57df-158">Přestože abstraktní třídy nelze vytvořit instanci přímo, mohou sloužit jako základní třídy pro jiné třídy, které poskytují chybějící implementaci.</span><span class="sxs-lookup"><span data-stu-id="f57df-158">Although abstract classes cannot be instantiated directly, they can serve as base classes for other classes that provide the missing implementation.</span></span> <span data-ttu-id="f57df-159">Třídy mohou být také deklarovány jako [zapečetěné,](../../language-reference/keywords/sealed.md) aby se zabránilo dědění jiných tříd z nich.</span><span class="sxs-lookup"><span data-stu-id="f57df-159">Classes can also be declared as [sealed](../../language-reference/keywords/sealed.md) to prevent other classes from inheriting from them.</span></span> <span data-ttu-id="f57df-160">Další informace naleznete [v tématu Abstract and Sealed Classes and Class Members](./abstract-and-sealed-classes-and-class-members.md).</span><span class="sxs-lookup"><span data-stu-id="f57df-160">For more information, see [Abstract and Sealed Classes and Class Members](./abstract-and-sealed-classes-and-class-members.md).</span></span>  
  
### <a name="interfaces"></a><span data-ttu-id="f57df-161">Rozhraní</span><span class="sxs-lookup"><span data-stu-id="f57df-161">Interfaces</span></span>  
 <span data-ttu-id="f57df-162">Třídy a struktury mohou dědit více rozhraní.</span><span class="sxs-lookup"><span data-stu-id="f57df-162">Classes and structs can inherit multiple interfaces.</span></span> <span data-ttu-id="f57df-163">Chcete-li dědit z rozhraní znamená, že typ implementuje všechny metody definované v rozhraní.</span><span class="sxs-lookup"><span data-stu-id="f57df-163">To inherit from an interface means that the type implements all the methods defined in the interface.</span></span> <span data-ttu-id="f57df-164">Další informace naleznete v [tématu Rozhraní](../interfaces/index.md).</span><span class="sxs-lookup"><span data-stu-id="f57df-164">For more information, see [Interfaces](../interfaces/index.md).</span></span>  
  
### <a name="generic-types"></a><span data-ttu-id="f57df-165">Obecné typy</span><span class="sxs-lookup"><span data-stu-id="f57df-165">Generic Types</span></span>  
 <span data-ttu-id="f57df-166">Třídy a struktury lze definovat pomocí jednoho nebo více parametrů typu.</span><span class="sxs-lookup"><span data-stu-id="f57df-166">Classes and structs can be defined with one or more type parameters.</span></span> <span data-ttu-id="f57df-167">Kód klienta dodává typ při vytváření instance typu.</span><span class="sxs-lookup"><span data-stu-id="f57df-167">Client code supplies the type when it creates an instance of the type.</span></span> <span data-ttu-id="f57df-168">Například <xref:System.Collections.Generic.List%601> Třída v <xref:System.Collections.Generic> oboru názvů je definována s jedním parametrem typu.</span><span class="sxs-lookup"><span data-stu-id="f57df-168">For example The <xref:System.Collections.Generic.List%601> class in the <xref:System.Collections.Generic> namespace is defined with one type parameter.</span></span> <span data-ttu-id="f57df-169">Kód klienta vytvoří `List<string>` instanci nebo `List<int>` určit typ, který bude obsahovat seznam.</span><span class="sxs-lookup"><span data-stu-id="f57df-169">Client code creates an instance of a `List<string>` or `List<int>` to specify the type that the list will hold.</span></span> <span data-ttu-id="f57df-170">Další informace naleznete [v tématu Generics](../generics/index.md).</span><span class="sxs-lookup"><span data-stu-id="f57df-170">For more information, see [Generics](../generics/index.md).</span></span>  
  
### <a name="static-types"></a><span data-ttu-id="f57df-171">Statické typy</span><span class="sxs-lookup"><span data-stu-id="f57df-171">Static Types</span></span>  
 <span data-ttu-id="f57df-172">Třídy (ale ne struktury) lze deklarovat jako [statické](../../language-reference/keywords/static.md).</span><span class="sxs-lookup"><span data-stu-id="f57df-172">Classes (but not structs) can be declared as [static](../../language-reference/keywords/static.md).</span></span> <span data-ttu-id="f57df-173">Statická třída může obsahovat pouze statické členy a nelze vytvořit instanci s novým klíčovým slovem.</span><span class="sxs-lookup"><span data-stu-id="f57df-173">A static class can contain only static members and cannot be instantiated with the new keyword.</span></span> <span data-ttu-id="f57df-174">Jedna kopie třídy je načtena do paměti při načtení programu a jeho členové jsou přístupné prostřednictvím názvu třídy.</span><span class="sxs-lookup"><span data-stu-id="f57df-174">One copy of the class is loaded into memory when the program loads, and its members are accessed through the class name.</span></span> <span data-ttu-id="f57df-175">Třídy i struktury mohou obsahovat statické členy.</span><span class="sxs-lookup"><span data-stu-id="f57df-175">Both classes and structs can contain static members.</span></span> <span data-ttu-id="f57df-176">Další informace naleznete [v tématu Statické třídy a statické členy třídy](./static-classes-and-static-class-members.md).</span><span class="sxs-lookup"><span data-stu-id="f57df-176">For more information, see [Static Classes and Static Class Members](./static-classes-and-static-class-members.md).</span></span>  
  
### <a name="nested-types"></a><span data-ttu-id="f57df-177">Vnořené typy</span><span class="sxs-lookup"><span data-stu-id="f57df-177">Nested Types</span></span>  
 <span data-ttu-id="f57df-178">Třídu nebo strukturu lze vnořit do jiné třídy nebo struktury.</span><span class="sxs-lookup"><span data-stu-id="f57df-178">A class or struct can be nested within another class or struct.</span></span> <span data-ttu-id="f57df-179">Další informace naleznete v [tématu Vnořené typy](./nested-types.md).</span><span class="sxs-lookup"><span data-stu-id="f57df-179">For more information, see [Nested Types](./nested-types.md).</span></span>  
  
### <a name="partial-types"></a><span data-ttu-id="f57df-180">Částečné typy</span><span class="sxs-lookup"><span data-stu-id="f57df-180">Partial Types</span></span>  
 <span data-ttu-id="f57df-181">Můžete definovat část třídy, struktury nebo metody v jednom souboru kódu a další část v samostatném souboru kódu.</span><span class="sxs-lookup"><span data-stu-id="f57df-181">You can define part of a class, struct or method in one code file and another part in a separate code file.</span></span> <span data-ttu-id="f57df-182">Další informace naleznete [v tématu Částečné třídy a metody](./partial-classes-and-methods.md).</span><span class="sxs-lookup"><span data-stu-id="f57df-182">For more information, see [Partial Classes and Methods](./partial-classes-and-methods.md).</span></span>  
  
### <a name="object-initializers"></a><span data-ttu-id="f57df-183">Inicializátory objektů</span><span class="sxs-lookup"><span data-stu-id="f57df-183">Object Initializers</span></span>  
 <span data-ttu-id="f57df-184">Můžete vytvořit inkonializovat a inicializovat třídy nebo struktury objekty a kolekce objektů, aniž by explicitně volat jejich konstruktor.</span><span class="sxs-lookup"><span data-stu-id="f57df-184">You can instantiate and initialize class or struct objects, and collections of objects, without explicitly calling their constructor.</span></span> <span data-ttu-id="f57df-185">Další informace naleznete v [tématu Objekt a kolekce Initializers](./object-and-collection-initializers.md).</span><span class="sxs-lookup"><span data-stu-id="f57df-185">For more information, see [Object and Collection Initializers](./object-and-collection-initializers.md).</span></span>  
  
### <a name="anonymous-types"></a><span data-ttu-id="f57df-186">Anonymní typy</span><span class="sxs-lookup"><span data-stu-id="f57df-186">Anonymous Types</span></span>  
 <span data-ttu-id="f57df-187">V situacích, kdy není vhodné nebo nutné vytvořit pojmenovanou třídu, například při vyplnění seznamu datovými strukturami, které není nutné zachovat nebo předat jiné metodě, použijete anonymní typy.</span><span class="sxs-lookup"><span data-stu-id="f57df-187">In situations where it is not convenient or necessary to create a named class, for example when you are populating a list with data structures that you do not have to persist or pass to another method, you use anonymous types.</span></span> <span data-ttu-id="f57df-188">Další informace naleznete [v tématu Anonymní typy](./anonymous-types.md).</span><span class="sxs-lookup"><span data-stu-id="f57df-188">For more information, see [Anonymous Types](./anonymous-types.md).</span></span>  
  
### <a name="extension-methods"></a><span data-ttu-id="f57df-189">Metody rozšíření</span><span class="sxs-lookup"><span data-stu-id="f57df-189">Extension Methods</span></span>  
 <span data-ttu-id="f57df-190">Třídu můžete "rozšířit" bez vytvoření odvozené třídy vytvořením samostatného typu, jehož metody lze volat, jako by patřily k původnímu typu.</span><span class="sxs-lookup"><span data-stu-id="f57df-190">You can "extend" a class without creating a derived class by creating a separate type whose methods can be called as if they belonged to the original type.</span></span> <span data-ttu-id="f57df-191">Další informace naleznete v [tématu Metody rozšíření](./extension-methods.md).</span><span class="sxs-lookup"><span data-stu-id="f57df-191">For more information, see [Extension Methods](./extension-methods.md).</span></span>  
  
### <a name="implicitly-typed-local-variables"></a><span data-ttu-id="f57df-192">Implicitně typované lokální proměnné</span><span class="sxs-lookup"><span data-stu-id="f57df-192">Implicitly Typed Local Variables</span></span>  
 <span data-ttu-id="f57df-193">V rámci metody třídy nebo struktury můžete použít implicitní psaní k instruování kompilátoru k určení správného typu v době kompilace.</span><span class="sxs-lookup"><span data-stu-id="f57df-193">Within a class or struct method, you can use implicit typing to instruct the compiler to determine the correct type at compile time.</span></span> <span data-ttu-id="f57df-194">Další informace naleznete [v tématu Implicitně zadané místní proměnné](./implicitly-typed-local-variables.md).</span><span class="sxs-lookup"><span data-stu-id="f57df-194">For more information, see [Implicitly Typed Local Variables](./implicitly-typed-local-variables.md).</span></span>  
  
## <a name="c-language-specification"></a><span data-ttu-id="f57df-195">Specifikace jazyka C#</span><span class="sxs-lookup"><span data-stu-id="f57df-195">C# Language Specification</span></span>  
 [!INCLUDE[CSharplangspec](~/includes/csharplangspec-md.md)]  
  
## <a name="see-also"></a><span data-ttu-id="f57df-196">Viz také</span><span class="sxs-lookup"><span data-stu-id="f57df-196">See also</span></span>

- [<span data-ttu-id="f57df-197">Programovací příručka jazyka C#</span><span class="sxs-lookup"><span data-stu-id="f57df-197">C# Programming Guide</span></span>](../index.md)
