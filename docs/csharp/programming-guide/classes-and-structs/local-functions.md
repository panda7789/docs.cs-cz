---
title: Místní funkce – Průvodce programováním v C#
description: Místní funkce v jazyce C# jsou soukromé metody, které jsou vnořené v jiném členu a mohou být volány z jejich nadřazeného člena.
ms.date: 06/14/2017
helpviewer_keywords:
- local functions [C#]
ms.openlocfilehash: 9987d6d5ad57c1dceb3a4bffbae22a81c240c794
ms.sourcegitcommit: 3d84eac0818099c9949035feb96bbe0346358504
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 07/21/2020
ms.locfileid: "86864524"
---
# <a name="local-functions-c-programming-guide"></a><span data-ttu-id="26f2b-103">Místní funkce (Průvodce programováním v C#)</span><span class="sxs-lookup"><span data-stu-id="26f2b-103">Local functions (C# Programming Guide)</span></span>

<span data-ttu-id="26f2b-104">Počínaje jazykem C# 7,0 podporuje jazyk C# *místní funkce*.</span><span class="sxs-lookup"><span data-stu-id="26f2b-104">Starting with C# 7.0, C# supports *local functions*.</span></span> <span data-ttu-id="26f2b-105">Lokální funkce jsou soukromé metody typu, které jsou vnořené v jiném členu.</span><span class="sxs-lookup"><span data-stu-id="26f2b-105">Local functions are private methods of a type that are nested in another member.</span></span> <span data-ttu-id="26f2b-106">Mohou být volány pouze ze svých nadřazených členů.</span><span class="sxs-lookup"><span data-stu-id="26f2b-106">They can only be called from their containing member.</span></span> <span data-ttu-id="26f2b-107">Místní funkce mohou být deklarovány v a volány z:</span><span class="sxs-lookup"><span data-stu-id="26f2b-107">Local functions can be declared in and called from:</span></span>

- <span data-ttu-id="26f2b-108">Metody, zejména iterátorové metody a asynchronní metody</span><span class="sxs-lookup"><span data-stu-id="26f2b-108">Methods, especially iterator methods and async methods</span></span>
- <span data-ttu-id="26f2b-109">Konstruktory</span><span class="sxs-lookup"><span data-stu-id="26f2b-109">Constructors</span></span>
- <span data-ttu-id="26f2b-110">Přistupující objekty vlastnosti</span><span class="sxs-lookup"><span data-stu-id="26f2b-110">Property accessors</span></span>
- <span data-ttu-id="26f2b-111">Přístupové objekty událostí</span><span class="sxs-lookup"><span data-stu-id="26f2b-111">Event accessors</span></span>
- <span data-ttu-id="26f2b-112">Anonymní metody</span><span class="sxs-lookup"><span data-stu-id="26f2b-112">Anonymous methods</span></span>
- <span data-ttu-id="26f2b-113">Výrazy lambda</span><span class="sxs-lookup"><span data-stu-id="26f2b-113">Lambda expressions</span></span>
- <span data-ttu-id="26f2b-114">Finalizační metody</span><span class="sxs-lookup"><span data-stu-id="26f2b-114">Finalizers</span></span>
- <span data-ttu-id="26f2b-115">Jiné místní funkce</span><span class="sxs-lookup"><span data-stu-id="26f2b-115">Other local functions</span></span>

<span data-ttu-id="26f2b-116">Místní funkce však nelze deklarovat uvnitř člena Expression-těle.</span><span class="sxs-lookup"><span data-stu-id="26f2b-116">However, local functions can't be declared inside an expression-bodied member.</span></span>

> [!NOTE]
> <span data-ttu-id="26f2b-117">V některých případech můžete použít výraz lambda pro implementaci funkcí, které podporuje také místní funkce.</span><span class="sxs-lookup"><span data-stu-id="26f2b-117">In some cases, you can use a lambda expression to implement functionality also supported by a local function.</span></span> <span data-ttu-id="26f2b-118">Porovnání naleznete v tématu [místní funkce vs. lambda výrazy](#local-functions-vs-lambda-expressions).</span><span class="sxs-lookup"><span data-stu-id="26f2b-118">For a comparison, see [Local functions vs. lambda expressions](#local-functions-vs-lambda-expressions).</span></span>

<span data-ttu-id="26f2b-119">Místní funkce usnadňují záměr vašeho kódu.</span><span class="sxs-lookup"><span data-stu-id="26f2b-119">Local functions make the intent of your code clear.</span></span> <span data-ttu-id="26f2b-120">Každý, kdo čte váš kód, uvidí, že metoda není možné volat s výjimkou obsahující metody.</span><span class="sxs-lookup"><span data-stu-id="26f2b-120">Anyone reading your code can see that the method is not callable except by the containing method.</span></span> <span data-ttu-id="26f2b-121">U týmových projektů také znemožňuje, aby jiný vývojář omylem volal metodu přímo z jiného místa ve třídě nebo struktuře.</span><span class="sxs-lookup"><span data-stu-id="26f2b-121">For team projects, they also make it impossible for another developer to mistakenly call the method directly from elsewhere in the class or struct.</span></span>

## <a name="local-function-syntax"></a><span data-ttu-id="26f2b-122">Syntaxe lokální funkce</span><span class="sxs-lookup"><span data-stu-id="26f2b-122">Local function syntax</span></span>

<span data-ttu-id="26f2b-123">Lokální funkce je definována jako vnořená metoda uvnitř nadřazeného člena.</span><span class="sxs-lookup"><span data-stu-id="26f2b-123">A local function is defined as a nested method inside a containing member.</span></span> <span data-ttu-id="26f2b-124">Jeho definice má následující syntaxi:</span><span class="sxs-lookup"><span data-stu-id="26f2b-124">Its definition has the following syntax:</span></span>

```csharp
<modifiers: async | unsafe> <return-type> <method-name> <parameter-list>
```

<span data-ttu-id="26f2b-125">Místní funkce můžou používat modifikátory [Async](../../language-reference/keywords/async.md) a [unsafe](../../language-reference/keywords/unsafe.md) .</span><span class="sxs-lookup"><span data-stu-id="26f2b-125">Local functions can use the [async](../../language-reference/keywords/async.md) and [unsafe](../../language-reference/keywords/unsafe.md) modifiers.</span></span>

<span data-ttu-id="26f2b-126">Všimněte si, že všechny místní proměnné, které jsou definovány v nadřazeném členu, včetně jeho parametrů metody, jsou přístupné v místní funkci.</span><span class="sxs-lookup"><span data-stu-id="26f2b-126">Note that all local variables that are defined in the containing member, including its method parameters, are accessible in the local function.</span></span>

<span data-ttu-id="26f2b-127">Na rozdíl od definice metody nemůže definice lokální funkce zahrnovat modifikátor přístupu ke členu.</span><span class="sxs-lookup"><span data-stu-id="26f2b-127">Unlike a method definition, a local function definition cannot include the member access modifier.</span></span> <span data-ttu-id="26f2b-128">Vzhledem k tomu, že všechny místní funkce jsou soukromé, včetně modifikátoru přístupu, jako je `private` klíčové slovo, vygeneruje chybu kompilátoru CS0106, modifikátor Private není pro tuto položku platný.</span><span class="sxs-lookup"><span data-stu-id="26f2b-128">Because all local functions are private, including an access modifier, such as the `private` keyword, generates compiler error CS0106, "The modifier 'private' is not valid for this item."</span></span>

> [!NOTE]
> <span data-ttu-id="26f2b-129">Před jazykem C# 8,0 nemohou místní funkce obsahovat `static` modifikátor.</span><span class="sxs-lookup"><span data-stu-id="26f2b-129">Prior to C# 8.0, local functions cannot include the `static` modifier.</span></span> <span data-ttu-id="26f2b-130">Zahrnutí `static` klíčového slova generuje chybu kompilátoru CS0106, modifikátor "static" není pro tuto položku platný. "</span><span class="sxs-lookup"><span data-stu-id="26f2b-130">Including the `static` keyword generates compiler error CS0106, "The modifier 'static' is not valid for this item."</span></span>

<span data-ttu-id="26f2b-131">Kromě toho nelze atributy použít pro místní funkci nebo její parametry a parametry typu.</span><span class="sxs-lookup"><span data-stu-id="26f2b-131">In addition, attributes can't be applied to the local function or to its parameters and type parameters.</span></span>

<span data-ttu-id="26f2b-132">Následující příklad definuje místní funkci s názvem `AppendPathSeparator` , která je soukromá pro metodu s názvem `GetText` :</span><span class="sxs-lookup"><span data-stu-id="26f2b-132">The following example defines a local function named `AppendPathSeparator` that is private to a method named `GetText`:</span></span>

[!code-csharp[LocalFunctionExample](~/samples/snippets/csharp/programming-guide/classes-and-structs/local-functions1.cs)]  

## <a name="local-functions-and-exceptions"></a><span data-ttu-id="26f2b-133">Místní funkce a výjimky</span><span class="sxs-lookup"><span data-stu-id="26f2b-133">Local functions and exceptions</span></span>

<span data-ttu-id="26f2b-134">Jednou z užitečných funkcí lokálních funkcí je to, že může dojít k okamžitému povrchování výjimek.</span><span class="sxs-lookup"><span data-stu-id="26f2b-134">One of the useful features of local functions is that they can allow exceptions to surface immediately.</span></span> <span data-ttu-id="26f2b-135">U iterátorů metod jsou výjimky vyhodnoceny pouze v případě, že je vyhodnocena vrácená sekvence, a ne při načtení iterátoru.</span><span class="sxs-lookup"><span data-stu-id="26f2b-135">For method iterators, exceptions are surfaced only when the returned sequence is enumerated, and not when the iterator is retrieved.</span></span> <span data-ttu-id="26f2b-136">Pro asynchronní metody jsou při očekávaných úlohách pozorovány jakékoli výjimky vyvolané v asynchronní metodě.</span><span class="sxs-lookup"><span data-stu-id="26f2b-136">For async methods, any exceptions thrown in an async method are observed when the returned task is awaited.</span></span>

<span data-ttu-id="26f2b-137">Následující příklad definuje `OddSequence` metodu, která vytváří výčty lichých čísel mezi zadaným rozsahem.</span><span class="sxs-lookup"><span data-stu-id="26f2b-137">The following example defines an `OddSequence` method that enumerates odd numbers between a specified range.</span></span> <span data-ttu-id="26f2b-138">Protože předá metodě Enumerator číslo větší než 100 `OddSequence` , vyvolá metoda <xref:System.ArgumentOutOfRangeException> .</span><span class="sxs-lookup"><span data-stu-id="26f2b-138">Because it passes a number greater than 100 to the `OddSequence` enumerator method, the method throws an <xref:System.ArgumentOutOfRangeException>.</span></span> <span data-ttu-id="26f2b-139">Jak výstup z příkladu ukazuje, plochy výjimky pouze při iteraci čísel, a ne při načtení čítače výčtu.</span><span class="sxs-lookup"><span data-stu-id="26f2b-139">As the output from the example shows, the exception surfaces only when you iterate the numbers, and not when you retrieve the enumerator.</span></span>

[!code-csharp[LocalFunctionIterator1](~/samples/snippets/csharp/programming-guide/classes-and-structs/local-functions-iterator1.cs)]

<span data-ttu-id="26f2b-140">Místo toho můžete vyvolat výjimku při provádění ověřování a před načtením iterátoru vrácením iterátoru z místní funkce, jak ukazuje následující příklad.</span><span class="sxs-lookup"><span data-stu-id="26f2b-140">Instead, you can throw an exception when performing validation and before retrieving the iterator by returning the iterator from a local function, as the following example shows.</span></span>

[!code-csharp[LocalFunctionIterator2](~/samples/snippets/csharp/programming-guide/classes-and-structs/local-functions-iterator2.cs)]

<span data-ttu-id="26f2b-141">Místní funkce lze použít podobným způsobem pro zpracování výjimek mimo asynchronní operaci.</span><span class="sxs-lookup"><span data-stu-id="26f2b-141">Local functions can be used in a similar way to handle exceptions outside of the asynchronous operation.</span></span> <span data-ttu-id="26f2b-142">Výjimky vyvolané v asynchronní metodě obvykle vyžadují, abyste prozkoumali vnitřní výjimky <xref:System.AggregateException> .</span><span class="sxs-lookup"><span data-stu-id="26f2b-142">Ordinarily, exceptions thrown in async method require that you examine the inner exceptions of an <xref:System.AggregateException>.</span></span> <span data-ttu-id="26f2b-143">Místní funkce umožňují vašemu kódu selhání rychle a umožňují, aby vaše výjimka byla vyvolána a byla sledována synchronně.</span><span class="sxs-lookup"><span data-stu-id="26f2b-143">Local functions allow your code to fail fast and allow your exception to be both thrown and observed synchronously.</span></span>

<span data-ttu-id="26f2b-144">Následující příklad používá asynchronní metodu pojmenovanou `GetMultipleAsync` k pozastavení po zadaný počet sekund a vrátí hodnotu, která je náhodné násobek tohoto počtu sekund.</span><span class="sxs-lookup"><span data-stu-id="26f2b-144">The following example uses an asynchronous method named `GetMultipleAsync` to pause for a specified number of seconds and return a value that is a random multiple of that number of seconds.</span></span> <span data-ttu-id="26f2b-145">Maximální zpoždění je 5 sekund; <xref:System.ArgumentOutOfRangeException>výsledkem je, že je hodnota větší než 5.</span><span class="sxs-lookup"><span data-stu-id="26f2b-145">The maximum delay is 5 seconds; an <xref:System.ArgumentOutOfRangeException> results if the value is greater than 5.</span></span> <span data-ttu-id="26f2b-146">Jak ukazuje následující příklad, výjimka, která je vyvolána, když je předána hodnota 6 `GetMultipleAsync` metodě, je zabalena do metody <xref:System.AggregateException> po `GetMultipleAsync` zahájení provádění.</span><span class="sxs-lookup"><span data-stu-id="26f2b-146">As the following example shows, the exception that is thrown when a value of 6 is passed to the `GetMultipleAsync` method is wrapped in an <xref:System.AggregateException> after the `GetMultipleAsync` method begins execution.</span></span>

[!code-csharp[LocalFunctionAsync](~/samples/snippets/csharp/programming-guide/classes-and-structs/local-functions-async1.cs)]

<span data-ttu-id="26f2b-147">Stejně jako u metody iterátoru můžeme kód z tohoto příkladu Refaktorovat, aby bylo ověřování provedeno před voláním asynchronní metody.</span><span class="sxs-lookup"><span data-stu-id="26f2b-147">As we did with the method iterator, we can refactor the code from this example to perform the validation before calling the asynchronous method.</span></span> <span data-ttu-id="26f2b-148">Jak ukazuje výstup z následujícího příkladu, není <xref:System.ArgumentOutOfRangeException> zabalen do <xref:System.AggregateException> .</span><span class="sxs-lookup"><span data-stu-id="26f2b-148">As the output from the following example shows, the <xref:System.ArgumentOutOfRangeException> is not wrapped in a <xref:System.AggregateException>.</span></span>

[!code-csharp[LocalFunctionAsync](~/samples/snippets/csharp/programming-guide/classes-and-structs/local-functions-async2.cs)]

## <a name="local-functions-vs-lambda-expressions"></a><span data-ttu-id="26f2b-149">Lokální funkce vs. výrazy lambda</span><span class="sxs-lookup"><span data-stu-id="26f2b-149">Local functions vs. lambda expressions</span></span>

<span data-ttu-id="26f2b-150">Na první pohled jsou místní funkce a [výrazy lambda](../statements-expressions-operators/lambda-expressions.md) velmi podobné.</span><span class="sxs-lookup"><span data-stu-id="26f2b-150">At first glance, local functions and [lambda expressions](../statements-expressions-operators/lambda-expressions.md) are very similar.</span></span> <span data-ttu-id="26f2b-151">V mnoha případech je volba mezi používáním výrazů lambda a místními funkcemi v oblasti stylu a osobní preference.</span><span class="sxs-lookup"><span data-stu-id="26f2b-151">In many cases, the choice between using lambda expressions and local functions is a matter of style and personal preference.</span></span> <span data-ttu-id="26f2b-152">Existují však reálné rozdíly v tom, kde můžete použít jednu nebo druhou, o které byste měli vědět.</span><span class="sxs-lookup"><span data-stu-id="26f2b-152">However, there are real differences in where you can use one or the other that you should be aware of.</span></span>

<span data-ttu-id="26f2b-153">Pojďme se podívat na rozdíly mezi implementací algoritmu faktoriál lokální funkce a výrazu lambda.</span><span class="sxs-lookup"><span data-stu-id="26f2b-153">Let's examine the differences between the local function and lambda expression implementations of the factorial algorithm.</span></span> <span data-ttu-id="26f2b-154">První verze pomocí místní funkce:</span><span class="sxs-lookup"><span data-stu-id="26f2b-154">First the version using a local function:</span></span>

[!code-csharp[LocalFunctionFactorial](../../../../samples/snippets/csharp/new-in-7/MathUtilities.cs#37_LocalFunctionFactorial "Recursive factorial using local function")]

<span data-ttu-id="26f2b-155">Naproti tomu implementace s verzí, která používá výrazy lambda:</span><span class="sxs-lookup"><span data-stu-id="26f2b-155">Contrast that implementation with a version that uses lambda expressions:</span></span>

[!code-csharp[26_LambdaFactorial](../../../../samples/snippets/csharp/new-in-7/MathUtilities.cs#38_LambdaFactorial "Recursive factorial using lambda expressions")]

<span data-ttu-id="26f2b-156">Místní funkce mají názvy.</span><span class="sxs-lookup"><span data-stu-id="26f2b-156">The local functions have names.</span></span> <span data-ttu-id="26f2b-157">Výrazy lambda jsou anonymní metody, které jsou přiřazeny k proměnným, které jsou `Func` nebo `Action` typy.</span><span class="sxs-lookup"><span data-stu-id="26f2b-157">The lambda expressions are anonymous methods that are assigned to variables that are `Func` or `Action` types.</span></span> <span data-ttu-id="26f2b-158">Při deklaraci místní funkce jsou typy argumentů a návratový typ součástí deklarace funkce.</span><span class="sxs-lookup"><span data-stu-id="26f2b-158">When you declare a local function, the argument types and return type are part of the function declaration.</span></span> <span data-ttu-id="26f2b-159">Namísto části těla výrazu lambda jsou typy argumentů a návratový typ součástí deklarace typu proměnné výrazu lambda.</span><span class="sxs-lookup"><span data-stu-id="26f2b-159">Instead of being part of the body of the lambda expression, the argument types and return type are part of the lambda expression's variable type declaration.</span></span> <span data-ttu-id="26f2b-160">Tyto dvě rozdíly mohou být způsobeny jasným kódem.</span><span class="sxs-lookup"><span data-stu-id="26f2b-160">Those two differences may result in clearer code.</span></span>

<span data-ttu-id="26f2b-161">Místní funkce mají různá pravidla pro jednoznačné přiřazení než výrazy lambda.</span><span class="sxs-lookup"><span data-stu-id="26f2b-161">Local functions have different rules for definite assignment than lambda expressions.</span></span> <span data-ttu-id="26f2b-162">Na deklaraci místní funkce se dá odkazovat z libovolného umístění kódu, kde se nachází v oboru.</span><span class="sxs-lookup"><span data-stu-id="26f2b-162">A local function declaration can be referenced from any code location where it is in scope.</span></span> <span data-ttu-id="26f2b-163">Výraz lambda musí být přiřazen proměnné delegáta před tím, než bude k němu možné přistupovat (nebo volat prostřednictvím delegáta odkazujícího na výraz lambda).</span><span class="sxs-lookup"><span data-stu-id="26f2b-163">A lambda expression must be assigned to a delegate variable before it can be accessed (or called through the delegate referencing the lambda expression).</span></span> <span data-ttu-id="26f2b-164">Všimněte si, že verze, která používá výraz lambda, musí deklarovat a inicializovat výraz lambda `nthFactorial` před jeho definováním.</span><span class="sxs-lookup"><span data-stu-id="26f2b-164">Notice that the version using the lambda expression must declare and initialize the lambda expression `nthFactorial` before defining it.</span></span> <span data-ttu-id="26f2b-165">Neprovádí se proto Chyba kompilace pro odkazování `nthFactorial` před přiřazením.</span><span class="sxs-lookup"><span data-stu-id="26f2b-165">Not doing so results in a compile time error for referencing `nthFactorial` before assigning it.</span></span> <span data-ttu-id="26f2b-166">Tyto rozdíly znamenají, že rekurzivní algoritmy je snazší vytvořit pomocí místních funkcí.</span><span class="sxs-lookup"><span data-stu-id="26f2b-166">These differences mean that recursive algorithms are easier to create using local functions.</span></span> <span data-ttu-id="26f2b-167">Můžete deklarovat a definovat místní funkci, která volá sama sebe.</span><span class="sxs-lookup"><span data-stu-id="26f2b-167">You can declare and define a local function that calls itself.</span></span> <span data-ttu-id="26f2b-168">Lambda výrazy musí být deklarovány a přiřazena výchozí hodnota, aby bylo možné je znovu přiřadit k těle, který odkazuje na stejný výraz lambda.</span><span class="sxs-lookup"><span data-stu-id="26f2b-168">Lambda expressions must be declared, and assigned a default value before they can be re-assigned to a body that references the same lambda expression.</span></span>

<span data-ttu-id="26f2b-169">Pravidla přiřazení mají vliv také na všechny proměnné, které jsou zachyceny místní funkcí nebo výrazem lambda.</span><span class="sxs-lookup"><span data-stu-id="26f2b-169">Definite assignment rules also affect any variables that are captured by the local function or lambda expression.</span></span> <span data-ttu-id="26f2b-170">Místní funkce i pravidla výrazů lambda vyžadují, aby všechny zachycené proměnné byly jednoznačně přiřazeny v okamžiku, kdy je místní funkce nebo lambda výraz převedena na delegáta.</span><span class="sxs-lookup"><span data-stu-id="26f2b-170">Both local functions and lambda expression rules demand that any captured variables are definitely assigned at the point when the local function or lambda expression is converted to a delegate.</span></span> <span data-ttu-id="26f2b-171">Rozdílem je, že výrazy lambda jsou převedeny na delegáty při jejich deklaraci.</span><span class="sxs-lookup"><span data-stu-id="26f2b-171">The difference is that lambda expressions are converted to delegates when they are declared.</span></span> <span data-ttu-id="26f2b-172">Lokální funkce jsou převedeny na delegáty pouze v případě, že se používají jako delegát.</span><span class="sxs-lookup"><span data-stu-id="26f2b-172">Local functions are converted to delegates only when used as a delegate.</span></span> <span data-ttu-id="26f2b-173">Deklarujete-li místní funkci a pouze na ni odkazujete tak, že ji zavoláte jako metodu, nebude převedena na delegáta.</span><span class="sxs-lookup"><span data-stu-id="26f2b-173">If you declare a local function and only reference it by calling it like a method, it will not be converted to a delegate.</span></span> <span data-ttu-id="26f2b-174">Toto pravidlo umožňuje deklarovat místní funkci v jakémkoli vhodném umístění v jeho ohraničujícím oboru.</span><span class="sxs-lookup"><span data-stu-id="26f2b-174">That rule enables you to declare a local function at any convenient location in its enclosing scope.</span></span> <span data-ttu-id="26f2b-175">Je běžné deklarovat místní funkce na konci nadřazené metody za libovolnými návratovými příkazy.</span><span class="sxs-lookup"><span data-stu-id="26f2b-175">It's common to declare local functions at the end of the parent method, after any return statements.</span></span>

<span data-ttu-id="26f2b-176">Třetí, kompilátor může provádět statickou analýzu, která umožňuje místním funkcím omezit přiřazení zachycených proměnných v ohraničujícím oboru.</span><span class="sxs-lookup"><span data-stu-id="26f2b-176">Third, the compiler can perform static analysis that enables local functions to definitely assign captured variables in the enclosing scope.</span></span> <span data-ttu-id="26f2b-177">Vezměte v úvahu tento příklad:</span><span class="sxs-lookup"><span data-stu-id="26f2b-177">Consider this example:</span></span>

```csharp
int M()
{
    int y;
    LocalFunction();
    return y;

    void LocalFunction() => y = 0;
}
```

<span data-ttu-id="26f2b-178">Kompilátor může určit, že se `LocalFunction` při volání jednoznačně přiřadí `y` .</span><span class="sxs-lookup"><span data-stu-id="26f2b-178">The compiler can determine that `LocalFunction` definitely assigns `y` when called.</span></span> <span data-ttu-id="26f2b-179">Protože `LocalFunction` je volána před `return` příkazem, `y` je jednoznačně přiřazen v `return` příkazu.</span><span class="sxs-lookup"><span data-stu-id="26f2b-179">Because `LocalFunction` is called before the `return` statement, `y` is definitely assigned at the `return` statement.</span></span>

<span data-ttu-id="26f2b-180">Analýza, která umožňuje ukázkovou analýzu, umožňuje čtvrtý rozdíl.</span><span class="sxs-lookup"><span data-stu-id="26f2b-180">The analysis that enables the example analysis enables the fourth difference.</span></span> <span data-ttu-id="26f2b-181">V závislosti na jejich použití se můžou místní funkce vyhnout přidělení haldy, které jsou vždy nutné pro výrazy lambda.</span><span class="sxs-lookup"><span data-stu-id="26f2b-181">Depending on their use, local functions can avoid heap allocations that are always necessary for lambda expressions.</span></span> <span data-ttu-id="26f2b-182">Pokud místní funkce není nikdy převedena na delegáta a žádná z proměnných zachycených lokální funkcí není zachycena jinými výrazy lambda nebo místními funkcemi, které jsou převedeny na delegáty, kompilátor může vyhnout přidělení haldy.</span><span class="sxs-lookup"><span data-stu-id="26f2b-182">If a local function is never converted to a delegate, and none of the variables captured by the local function is captured by other lambdas or local functions that are converted to delegates, the compiler can avoid heap allocations.</span></span>

<span data-ttu-id="26f2b-183">Vezměte v úvahu tento asynchronní příklad:</span><span class="sxs-lookup"><span data-stu-id="26f2b-183">Consider this async example:</span></span>

[!code-csharp[TaskLambdaExample](../../../../samples/snippets/csharp/new-in-7/AsyncWork.cs#36_TaskLambdaExample "Task returning method with lambda expression")]

<span data-ttu-id="26f2b-184">Uzavření tohoto výrazu lambda obsahuje `address` `index` `name` proměnné a.</span><span class="sxs-lookup"><span data-stu-id="26f2b-184">The closure for this lambda expression contains the `address`, `index` and `name` variables.</span></span> <span data-ttu-id="26f2b-185">V případě místních funkcí může být objekt, který implementuje uzávěr, `struct` typu.</span><span class="sxs-lookup"><span data-stu-id="26f2b-185">In the case of local functions, the object that implements the closure may be a `struct` type.</span></span> <span data-ttu-id="26f2b-186">Tento typ struktury by byl předán odkazem na místní funkci.</span><span class="sxs-lookup"><span data-stu-id="26f2b-186">That struct type would be passed by reference to the local function.</span></span> <span data-ttu-id="26f2b-187">Tento rozdíl v implementaci by byl uložen při přidělení.</span><span class="sxs-lookup"><span data-stu-id="26f2b-187">This difference in implementation would save on an allocation.</span></span>

<span data-ttu-id="26f2b-188">Vytváření instancí nezbytných pro výrazy lambda znamená dodatečné přidělení paměti, což může být výkonový faktor v časově důležitých cestách kódu.</span><span class="sxs-lookup"><span data-stu-id="26f2b-188">The instantiation necessary for lambda expressions means extra memory allocations, which may be a performance factor in time-critical code paths.</span></span> <span data-ttu-id="26f2b-189">Místní funkce tyto režie neúčtují.</span><span class="sxs-lookup"><span data-stu-id="26f2b-189">Local functions do not incur this overhead.</span></span> <span data-ttu-id="26f2b-190">V příkladu výše má verze lokálních funkcí 2 méně přidělení než verze výrazu lambda.</span><span class="sxs-lookup"><span data-stu-id="26f2b-190">In the example above, the local functions version has 2 fewer allocations than the lambda expression version.</span></span>

> [!NOTE]
> <span data-ttu-id="26f2b-191">Lokální funkce ekvivalentní této metodě používá také třídu pro uzavření.</span><span class="sxs-lookup"><span data-stu-id="26f2b-191">The local function equivalent of this method also uses a class for the closure.</span></span> <span data-ttu-id="26f2b-192">Zda je uzavření místní funkce implementováno jako `class` nebo jako `struct` Podrobnosti implementace.</span><span class="sxs-lookup"><span data-stu-id="26f2b-192">Whether the closure for a local function is implemented as a `class` or a `struct` is an implementation detail.</span></span> <span data-ttu-id="26f2b-193">Místní funkce může používat, `struct` zatímco lambda bude vždy používat `class` .</span><span class="sxs-lookup"><span data-stu-id="26f2b-193">A local function may use a `struct` whereas a lambda will always use a `class`.</span></span>

[!code-csharp[TaskLocalFunctionExample](../../../../samples/snippets/csharp/new-in-7/AsyncWork.cs#TaskExample "Task returning method with local function")]

<span data-ttu-id="26f2b-194">Jedna poslední výhoda není v této ukázce znázorněna, protože lokální funkce lze implementovat jako iterátory pomocí `yield return` syntaxe k vytvoření sekvence hodnot.</span><span class="sxs-lookup"><span data-stu-id="26f2b-194">One final advantage not demonstrated in this sample is that local functions can be implemented as iterators, using the `yield return` syntax to produce a sequence of values.</span></span> <span data-ttu-id="26f2b-195">`yield return`Příkaz není ve výrazech lambda povolen.</span><span class="sxs-lookup"><span data-stu-id="26f2b-195">The `yield return` statement is not allowed in lambda expressions.</span></span>

<span data-ttu-id="26f2b-196">I když se místní funkce můžou jevit jako redundantní pro lambda výrazy, mají ve skutečnosti různé účely a mají odlišná použití.</span><span class="sxs-lookup"><span data-stu-id="26f2b-196">While local functions may seem redundant to lambda expressions, they actually serve different purposes and have different uses.</span></span> <span data-ttu-id="26f2b-197">Lokální funkce jsou efektivnější pro případ, když chcete napsat funkci, která je volána pouze z kontextu jiné metody.</span><span class="sxs-lookup"><span data-stu-id="26f2b-197">Local functions are more efficient for the case when you want to write a function that is called only from the context of another method.</span></span>

## <a name="see-also"></a><span data-ttu-id="26f2b-198">Viz také</span><span class="sxs-lookup"><span data-stu-id="26f2b-198">See also</span></span>

- [<span data-ttu-id="26f2b-199">Metody</span><span class="sxs-lookup"><span data-stu-id="26f2b-199">Methods</span></span>](methods.md)
