---
title: Polymorfismus – C# Průvodce programováním
ms.date: 07/20/2015
helpviewer_keywords:
- C# language, polymorphism
- polymorphism [C#]
ms.assetid: 086af969-29a5-4ce8-a993-0b7d53839dab
ms.openlocfilehash: 4f65082ad5094eb0aab28edeb06790a9af4019c6
ms.sourcegitcommit: 5f236cd78cf09593c8945a7d753e0850e96a0b80
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 01/07/2020
ms.locfileid: "75714734"
---
# <a name="polymorphism-c-programming-guide"></a><span data-ttu-id="f032f-102">Polymorfismus (Průvodce programováním v C#)</span><span class="sxs-lookup"><span data-stu-id="f032f-102">Polymorphism (C# Programming Guide)</span></span>
<span data-ttu-id="f032f-103">Polymorfismus se často označuje jako třetí pilíř objektově orientovaného programování, a to po zapouzdření a dědičnosti.</span><span class="sxs-lookup"><span data-stu-id="f032f-103">Polymorphism is often referred to as the third pillar of object-oriented programming, after encapsulation and inheritance.</span></span> <span data-ttu-id="f032f-104">Polymorfismus je řecký Word, který znamená "velký tvar" a má dva odlišné aspekty:</span><span class="sxs-lookup"><span data-stu-id="f032f-104">Polymorphism is a Greek word that means "many-shaped" and it has two distinct aspects:</span></span>  
  
- <span data-ttu-id="f032f-105">V době běhu lze objekty odvozené třídy považovat za objekty základní třídy v místech, jako jsou parametry metody a kolekce nebo pole.</span><span class="sxs-lookup"><span data-stu-id="f032f-105">At run time, objects of a derived class may be treated as objects of a base class in places such as method parameters and collections or arrays.</span></span> <span data-ttu-id="f032f-106">Pokud k tomu dojde, deklarovaný typ objektu již není totožný s jeho typem za běhu.</span><span class="sxs-lookup"><span data-stu-id="f032f-106">When this occurs, the object's declared type is no longer identical to its run-time type.</span></span>  
  
- <span data-ttu-id="f032f-107">Základní třídy mohou definovat a implementovat [virtuální](../../language-reference/keywords/virtual.md) *metody*a odvozené třídy je mohou [přepsat](../../language-reference/keywords/override.md) , což znamená, že poskytují svou vlastní definici a implementaci.</span><span class="sxs-lookup"><span data-stu-id="f032f-107">Base classes may define and implement [virtual](../../language-reference/keywords/virtual.md) *methods*, and derived classes can [override](../../language-reference/keywords/override.md) them, which means they provide their own definition and implementation.</span></span> <span data-ttu-id="f032f-108">V době běhu, když kód klienta volá metodu, modul CLR vyhledá typ za běhu objektu a vyvolá přepsání virtuální metody.</span><span class="sxs-lookup"><span data-stu-id="f032f-108">At run-time, when client code calls the method, the CLR looks up the run-time type of the object, and invokes that override of the virtual method.</span></span> <span data-ttu-id="f032f-109">Proto ve vašem zdrojovém kódu můžete zavolat metodu pro základní třídu a způsobit spuštění odvozené třídy verze metody.</span><span class="sxs-lookup"><span data-stu-id="f032f-109">Thus in your source code you can call a method on a base class, and cause a derived class's version of the method to be executed.</span></span>  
  
 <span data-ttu-id="f032f-110">Virtuální metody umožňují pracovat se skupinami souvisejících objektů jednotným způsobem.</span><span class="sxs-lookup"><span data-stu-id="f032f-110">Virtual methods enable you to work with groups of related objects in a uniform way.</span></span> <span data-ttu-id="f032f-111">Předpokládejme například, že máte aplikaci pro kreslení, která umožňuje uživateli vytvářet různé druhy tvarů na kreslicí ploše.</span><span class="sxs-lookup"><span data-stu-id="f032f-111">For example, suppose you have a drawing application that enables a user to create various kinds of shapes on a drawing surface.</span></span> <span data-ttu-id="f032f-112">V době kompilace neznáte, které konkrétní typy tvarů uživatel vytvoří.</span><span class="sxs-lookup"><span data-stu-id="f032f-112">You do not know at compile time which specific types of shapes the user will create.</span></span> <span data-ttu-id="f032f-113">Aplikace však musí sledovat všechny různé typy tvarů, které byly vytvořeny, a musí je aktualizovat v reakci na akce myši uživatele.</span><span class="sxs-lookup"><span data-stu-id="f032f-113">However, the application has to keep track of all the various types of shapes that are created, and it has to update them in response to user mouse actions.</span></span> <span data-ttu-id="f032f-114">K vyřešení tohoto problému můžete použít polymorfismus ve dvou základních krocích:</span><span class="sxs-lookup"><span data-stu-id="f032f-114">You can use polymorphism to solve this problem in two basic steps:</span></span>  
  
1. <span data-ttu-id="f032f-115">Vytvořte hierarchii třídy, ve které jsou jednotlivé konkrétní třídy tvarů odvozeny ze společné základní třídy.</span><span class="sxs-lookup"><span data-stu-id="f032f-115">Create a class hierarchy in which each specific shape class derives from a common base class.</span></span>  
  
2. <span data-ttu-id="f032f-116">Použijte virtuální metodu k vyvolání vhodné metody pro jakoukoli odvozenou třídu prostřednictvím jediného volání metody základní třídy.</span><span class="sxs-lookup"><span data-stu-id="f032f-116">Use a virtual method to invoke the appropriate method on any derived class through a single call to the base class method.</span></span>  
  
 <span data-ttu-id="f032f-117">Nejprve vytvořte základní třídu s názvem `Shape`a odvozené třídy jako `Rectangle`, `Circle`a `Triangle`.</span><span class="sxs-lookup"><span data-stu-id="f032f-117">First, create a base class called `Shape`, and derived classes such as `Rectangle`, `Circle`, and `Triangle`.</span></span> <span data-ttu-id="f032f-118">Poskytněte třídu `Shape` virtuální metodu nazvanou `Draw`a přepište ji v každé odvozené třídě pro vykreslení konkrétního tvaru, který třída představuje.</span><span class="sxs-lookup"><span data-stu-id="f032f-118">Give the `Shape` class a virtual method called `Draw`, and override it in each derived class to draw the particular shape that the class represents.</span></span> <span data-ttu-id="f032f-119">Vytvořte objekt `List<Shape>` a přidejte do něj kruh, trojúhelník a obdélník.</span><span class="sxs-lookup"><span data-stu-id="f032f-119">Create a `List<Shape>` object and add a Circle, Triangle and Rectangle to it.</span></span> <span data-ttu-id="f032f-120">Chcete-li aktualizovat plochu pro kreslení, použijte smyčku [foreach](../../language-reference/keywords/foreach-in.md) k iterování seznamu a zavolejte metodu `Draw` u každého objektu `Shape` v seznamu.</span><span class="sxs-lookup"><span data-stu-id="f032f-120">To update the drawing surface, use a [foreach](../../language-reference/keywords/foreach-in.md) loop to iterate through the list and call the `Draw` method on each `Shape` object in the list.</span></span> <span data-ttu-id="f032f-121">I když každý objekt v seznamu má deklarovaný typ `Shape`, je typ za běhu (přepsaná verze metody v každé odvozené třídě), která bude vyvolána.</span><span class="sxs-lookup"><span data-stu-id="f032f-121">Even though each object in the list has a declared type of `Shape`, it is the run-time type (the overridden version of the method in each derived class) that will be invoked.</span></span>  
  
 [!code-csharp[csProgGuideInheritance#50](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideInheritance/CS/Inheritance.cs#50)]  
  
 <span data-ttu-id="f032f-122">V C#je každý typ polymorfní, protože všechny typy, včetně uživatelsky definovaných typů, dědí z <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="f032f-122">In C#, every type is polymorphic because all types, including user-defined types, inherit from <xref:System.Object>.</span></span>  
  
## <a name="polymorphism-overview"></a><span data-ttu-id="f032f-123">Přehled polymorfismu</span><span class="sxs-lookup"><span data-stu-id="f032f-123">Polymorphism Overview</span></span>  
  
### <a name="virtual-members"></a><span data-ttu-id="f032f-124">Virtuální členové</span><span class="sxs-lookup"><span data-stu-id="f032f-124">Virtual Members</span></span>  
 <span data-ttu-id="f032f-125">Když odvozená třída dědí ze základní třídy, získá všechny metody, pole, vlastnosti a události základní třídy.</span><span class="sxs-lookup"><span data-stu-id="f032f-125">When a derived class inherits from a base class, it gains all the methods, fields, properties and events of the base class.</span></span> <span data-ttu-id="f032f-126">Návrhář odvozené třídy může zvolit, zda se má</span><span class="sxs-lookup"><span data-stu-id="f032f-126">The designer of the derived class can choose whether to</span></span>  
  
- <span data-ttu-id="f032f-127">přepsat virtuální členy v základní třídě,</span><span class="sxs-lookup"><span data-stu-id="f032f-127">override virtual members in the base class,</span></span>  
  
- <span data-ttu-id="f032f-128">Zdědit nejbližší metodu základní třídy bez přepsání</span><span class="sxs-lookup"><span data-stu-id="f032f-128">inherit the closest base class method without overriding it</span></span>  
  
- <span data-ttu-id="f032f-129">Definujte novou nevirtuální implementaci těchto členů, kteří skryjí implementace základní třídy.</span><span class="sxs-lookup"><span data-stu-id="f032f-129">define new non-virtual implementation of those members that hide the base class implementations</span></span>  
  
 <span data-ttu-id="f032f-130">Odvozená třída může přepsat člen základní třídy pouze v případě, že je člen základní třídy deklarován jako [virtuální](../../language-reference/keywords/virtual.md) nebo [abstraktní](../../language-reference/keywords/abstract.md).</span><span class="sxs-lookup"><span data-stu-id="f032f-130">A derived class can override a base class member only if the base class member is declared as [virtual](../../language-reference/keywords/virtual.md) or [abstract](../../language-reference/keywords/abstract.md).</span></span> <span data-ttu-id="f032f-131">Odvozený člen musí použít klíčové slovo [override](../../language-reference/keywords/override.md) k explicitnímu označení toho, že je metoda určena k účasti ve virtuálním vyvolání.</span><span class="sxs-lookup"><span data-stu-id="f032f-131">The derived member must use the [override](../../language-reference/keywords/override.md) keyword to explicitly indicate that the method is intended to participate in virtual invocation.</span></span> <span data-ttu-id="f032f-132">Následující kód poskytuje příklad:</span><span class="sxs-lookup"><span data-stu-id="f032f-132">The following code provides an example:</span></span>  
  
 [!code-csharp[csProgGuideInheritance#20](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideInheritance/CS/Inheritance.cs#20)]  
  
 <span data-ttu-id="f032f-133">Pole nemůžou být virtuální. virtuální můžou být jenom metody, vlastnosti, události a indexery.</span><span class="sxs-lookup"><span data-stu-id="f032f-133">Fields cannot be virtual; only methods, properties, events and indexers can be virtual.</span></span> <span data-ttu-id="f032f-134">Když odvozená třída přepíše virtuální člen, je tento člen volán i v případě, že instance této třídy je k dispozici jako instance základní třídy.</span><span class="sxs-lookup"><span data-stu-id="f032f-134">When a derived class overrides a virtual member, that member is called even when an instance of that class is being accessed as an instance of the base class.</span></span> <span data-ttu-id="f032f-135">Následující kód poskytuje příklad:</span><span class="sxs-lookup"><span data-stu-id="f032f-135">The following code provides an example:</span></span>  
  
 [!code-csharp[csProgGuideInheritance#21](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideInheritance/CS/Inheritance.cs#21)]  
  
 <span data-ttu-id="f032f-136">Virtuální metody a vlastnosti umožňují odvozeným třídám rozšiřuje základní třídu bez nutnosti použití implementace základní třídy metody.</span><span class="sxs-lookup"><span data-stu-id="f032f-136">Virtual methods and properties enable derived classes to extend a base class without needing to use the base class implementation of a method.</span></span> <span data-ttu-id="f032f-137">Další informace najdete v tématu [Správa verzí pomocí klíčových slov override a New](./versioning-with-the-override-and-new-keywords.md).</span><span class="sxs-lookup"><span data-stu-id="f032f-137">For more information, see [Versioning with the Override and New Keywords](./versioning-with-the-override-and-new-keywords.md).</span></span> <span data-ttu-id="f032f-138">Rozhraní poskytuje další způsob, jak definovat metodu nebo sadu metod, jejichž implementace je ponechána na odvozené třídy.</span><span class="sxs-lookup"><span data-stu-id="f032f-138">An interface provides another way to define a method or set of methods whose implementation is left to derived classes.</span></span> <span data-ttu-id="f032f-139">Další informace naleznete v tématu [rozhraní](../interfaces/index.md).</span><span class="sxs-lookup"><span data-stu-id="f032f-139">For more information, see [Interfaces](../interfaces/index.md).</span></span>  
  
### <a name="hiding-base-class-members-with-new-members"></a><span data-ttu-id="f032f-140">Skrytí členů základní třídy novými členy</span><span class="sxs-lookup"><span data-stu-id="f032f-140">Hiding Base Class Members with New Members</span></span>  
 <span data-ttu-id="f032f-141">Pokud chcete, aby měl váš odvozený člen stejný název jako člen v základní třídě, ale nechcete, aby se účastnil ve virtuálním vyvolání, můžete použít klíčové slovo [New](../../language-reference/keywords/new-modifier.md) .</span><span class="sxs-lookup"><span data-stu-id="f032f-141">If you want your derived member to have the same name as a member in a base class, but you do not want it to participate in virtual invocation, you can use the [new](../../language-reference/keywords/new-modifier.md) keyword.</span></span> <span data-ttu-id="f032f-142">Klíčové slovo `new` je vloženo před návratový typ člena třídy, který se nahrazuje.</span><span class="sxs-lookup"><span data-stu-id="f032f-142">The `new` keyword is put before the return type of a class member that is being replaced.</span></span> <span data-ttu-id="f032f-143">Následující kód poskytuje příklad:</span><span class="sxs-lookup"><span data-stu-id="f032f-143">The following code provides an example:</span></span>  
  
 [!code-csharp[csProgGuideInheritance#18](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideInheritance/CS/Inheritance.cs#18)]  
  
 <span data-ttu-id="f032f-144">Skryté členy základní třídy lze stále přihlašovat z klientského kódu přetypováním instance odvozené třídy do instance základní třídy.</span><span class="sxs-lookup"><span data-stu-id="f032f-144">Hidden base class members can still be accessed from client code by casting the instance of the derived class to an instance of the base class.</span></span> <span data-ttu-id="f032f-145">Příklad:</span><span class="sxs-lookup"><span data-stu-id="f032f-145">For example:</span></span>  
  
 [!code-csharp[csProgGuideInheritance#19](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideInheritance/CS/Inheritance.cs#19)]  
  
### <a name="preventing-derived-classes-from-overriding-virtual-members"></a><span data-ttu-id="f032f-146">Prevence odvozených tříd od přepsání virtuálních členů</span><span class="sxs-lookup"><span data-stu-id="f032f-146">Preventing Derived Classes from Overriding Virtual Members</span></span>  
 <span data-ttu-id="f032f-147">Virtuální členové zůstávají virtuální neomezeně, bez ohledu na to, kolik tříd bylo deklarováno mezi virtuálním členem a třídou, která ji původně deklarovala.</span><span class="sxs-lookup"><span data-stu-id="f032f-147">Virtual members remain virtual indefinitely, regardless of how many classes have been declared between the virtual member and the class that originally declared it.</span></span> <span data-ttu-id="f032f-148">Pokud třída A deklaruje virtuální člen a třída B je odvozena z třídy a třída C je odvozena z B, třída C dědí virtuální člen a má možnost ho přepsat, bez ohledu na to, zda třída B deklaruje přepsání pro daného člena.</span><span class="sxs-lookup"><span data-stu-id="f032f-148">If class A declares a virtual member, and class B derives from A, and class C derives from B, class C inherits the virtual member, and has the option to override it, regardless of whether class B declared an override for that member.</span></span> <span data-ttu-id="f032f-149">Následující kód poskytuje příklad:</span><span class="sxs-lookup"><span data-stu-id="f032f-149">The following code provides an example:</span></span>  
  
 [!code-csharp[csProgGuideInheritance#22](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideInheritance/CS/Inheritance.cs#22)]  
  
 <span data-ttu-id="f032f-150">Odvozená třída může zastavit virtuální dědičnost deklarací override jako [sealed](../../language-reference/keywords/sealed.md).</span><span class="sxs-lookup"><span data-stu-id="f032f-150">A derived class can stop virtual inheritance by declaring an override as [sealed](../../language-reference/keywords/sealed.md).</span></span> <span data-ttu-id="f032f-151">To vyžaduje vložení klíčového slova `sealed` před klíčovým slovem `override` v deklaraci člena třídy.</span><span class="sxs-lookup"><span data-stu-id="f032f-151">This requires putting the `sealed` keyword before the `override` keyword in the class member declaration.</span></span> <span data-ttu-id="f032f-152">Následující kód poskytuje příklad:</span><span class="sxs-lookup"><span data-stu-id="f032f-152">The following code provides an example:</span></span>  
  
 [!code-csharp[csProgGuideInheritance#24](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideInheritance/CS/Inheritance.cs#24)]  
  
 <span data-ttu-id="f032f-153">V předchozím příkladu je `DoWork` metody již nevirtuální pro žádnou třídu odvozenou z jazyka C. Je stále Virtual pro instance C, i když jsou přetypování na typ B nebo typ A. zapečetěné metody lze nahradit odvozenými třídami pomocí klíčového slova `new`, jak ukazuje následující příklad:</span><span class="sxs-lookup"><span data-stu-id="f032f-153">In the previous example, the method `DoWork` is no longer virtual to any class derived from C. It is still virtual for instances of C, even if they are cast to type B or type A. Sealed methods can be replaced by derived classes by using the `new` keyword, as the following example shows:</span></span>  
  
 [!code-csharp[csProgGuideInheritance#25](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideInheritance/CS/Inheritance.cs#25)]  
  
 <span data-ttu-id="f032f-154">V tomto případě, pokud je `DoWork` volána na D pomocí proměnné typu D, je volána nová `DoWork`.</span><span class="sxs-lookup"><span data-stu-id="f032f-154">In this case, if `DoWork` is called on D using a variable of type D, the new `DoWork` is called.</span></span> <span data-ttu-id="f032f-155">Pokud proměnná typu C, B nebo A se používá pro přístup k instanci D, volání `DoWork` bude následovat pravidla virtuální dědičnosti, směrování těchto volání do implementace `DoWork` na třídu C.</span><span class="sxs-lookup"><span data-stu-id="f032f-155">If a variable of type C, B, or A is used to access an instance of D, a call to `DoWork` will follow the rules of virtual inheritance, routing those calls to the implementation of `DoWork` on class C.</span></span>  
  
### <a name="accessing-base-class-virtual-members-from-derived-classes"></a><span data-ttu-id="f032f-156">Přístup k virtuálním členům základní třídy z odvozených tříd</span><span class="sxs-lookup"><span data-stu-id="f032f-156">Accessing Base Class Virtual Members from Derived Classes</span></span>  
 <span data-ttu-id="f032f-157">Odvozená třída, která nahradila nebo přepsala metodu nebo vlastnost, může stále přistupovat k metodě nebo vlastnosti základní třídy pomocí klíčového slova `base`.</span><span class="sxs-lookup"><span data-stu-id="f032f-157">A derived class that has replaced or overridden a method or property can still access the method or property on the base class using the `base` keyword.</span></span> <span data-ttu-id="f032f-158">Následující kód poskytuje příklad:</span><span class="sxs-lookup"><span data-stu-id="f032f-158">The following code provides an example:</span></span>  
  
 [!code-csharp[csProgGuideInheritance#26](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideInheritance/CS/Inheritance.cs#26)]  
  
 <span data-ttu-id="f032f-159">Další informace naleznete v tématu [Base](../../language-reference/keywords/base.md).</span><span class="sxs-lookup"><span data-stu-id="f032f-159">For more information, see [base](../../language-reference/keywords/base.md).</span></span>  
  
> [!NOTE]
> <span data-ttu-id="f032f-160">Doporučuje se, aby virtuální členové používali `base` k volání implementace základní třídy tohoto člena ve vlastní implementaci.</span><span class="sxs-lookup"><span data-stu-id="f032f-160">It is recommended that virtual members use `base` to call the base class implementation of that member in their own implementation.</span></span> <span data-ttu-id="f032f-161">V případě, že dojde k chování základní třídy, umožňuje odvozeným třídám soustředit se na implementaci konkrétního chování, které je specifické pro odvozenou třídu.</span><span class="sxs-lookup"><span data-stu-id="f032f-161">Letting the base class behavior occur enables the derived class to concentrate on implementing behavior specific to the derived class.</span></span> <span data-ttu-id="f032f-162">Pokud není volána implementace základní třídy, je až do odvozené třídy, aby jejich chování bylo kompatibilní s chováním základní třídy.</span><span class="sxs-lookup"><span data-stu-id="f032f-162">If the base class implementation is not called, it is up to the derived class to make their behavior compatible with the behavior of the base class.</span></span>  
  
## <a name="in-this-section"></a><span data-ttu-id="f032f-163">V tomto oddílu</span><span class="sxs-lookup"><span data-stu-id="f032f-163">In This Section</span></span>  
  
- [<span data-ttu-id="f032f-164">Správa verzí pomocí klíčových slov override a new</span><span class="sxs-lookup"><span data-stu-id="f032f-164">Versioning with the Override and New Keywords</span></span>](./versioning-with-the-override-and-new-keywords.md)  
  
- [<span data-ttu-id="f032f-165">Znalost, kdy použít klíčová slova override a new</span><span class="sxs-lookup"><span data-stu-id="f032f-165">Knowing When to Use Override and New Keywords</span></span>](./knowing-when-to-use-override-and-new-keywords.md)  
  
- [<span data-ttu-id="f032f-166">Jak přepsat metodu ToString</span><span class="sxs-lookup"><span data-stu-id="f032f-166">How to override the ToString method</span></span>](./how-to-override-the-tostring-method.md)
  
## <a name="see-also"></a><span data-ttu-id="f032f-167">Viz také:</span><span class="sxs-lookup"><span data-stu-id="f032f-167">See also</span></span>

- [<span data-ttu-id="f032f-168">Průvodce programováním v jazyce C#</span><span class="sxs-lookup"><span data-stu-id="f032f-168">C# Programming Guide</span></span>](../index.md)
- [<span data-ttu-id="f032f-169">Dědičnost</span><span class="sxs-lookup"><span data-stu-id="f032f-169">Inheritance</span></span>](./inheritance.md)
- [<span data-ttu-id="f032f-170">Abstraktní a uzavřené třídy a jejich členové</span><span class="sxs-lookup"><span data-stu-id="f032f-170">Abstract and Sealed Classes and Class Members</span></span>](./abstract-and-sealed-classes-and-class-members.md)
- [<span data-ttu-id="f032f-171">Metody</span><span class="sxs-lookup"><span data-stu-id="f032f-171">Methods</span></span>](./methods.md)
- [<span data-ttu-id="f032f-172">Události</span><span class="sxs-lookup"><span data-stu-id="f032f-172">Events</span></span>](../events/index.md)
- [<span data-ttu-id="f032f-173">Vlastnosti</span><span class="sxs-lookup"><span data-stu-id="f032f-173">Properties</span></span>](./properties.md)
- [<span data-ttu-id="f032f-174">Indexery</span><span class="sxs-lookup"><span data-stu-id="f032f-174">Indexers</span></span>](../indexers/index.md)
- [<span data-ttu-id="f032f-175">Typy</span><span class="sxs-lookup"><span data-stu-id="f032f-175">Types</span></span>](../types/index.md)
