---
title: Polymorfismus - C# Programovací průvodce
ms.date: 02/08/2020
helpviewer_keywords:
- C# language, polymorphism
- polymorphism [C#]
ms.assetid: 086af969-29a5-4ce8-a993-0b7d53839dab
ms.openlocfilehash: 58980bd0d70d8a778cdb208f56d31ee8465871a4
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 03/14/2020
ms.locfileid: "79170166"
---
# <a name="polymorphism-c-programming-guide"></a><span data-ttu-id="b376e-102">Polymorfismus (Průvodce programováním v C#)</span><span class="sxs-lookup"><span data-stu-id="b376e-102">Polymorphism (C# Programming Guide)</span></span>

<span data-ttu-id="b376e-103">Polymorfismus je často označován jako třetí pilíř objektově orientovaného programování po zapouzdření a dědičnosti.</span><span class="sxs-lookup"><span data-stu-id="b376e-103">Polymorphism is often referred to as the third pillar of object-oriented programming, after encapsulation and inheritance.</span></span> <span data-ttu-id="b376e-104">Polymorfismus je řecké slovo, které znamená "mnoho-formoval" a má dva odlišné aspekty:</span><span class="sxs-lookup"><span data-stu-id="b376e-104">Polymorphism is a Greek word that means "many-shaped" and it has two distinct aspects:</span></span>
  
- <span data-ttu-id="b376e-105">Za běhu objekty odvozené třídy mohou být považovány za objekty základní třídy v místech, jako jsou parametry metody a kolekce nebo pole.</span><span class="sxs-lookup"><span data-stu-id="b376e-105">At run time, objects of a derived class may be treated as objects of a base class in places such as method parameters and collections or arrays.</span></span> <span data-ttu-id="b376e-106">Dojde-li k tomuto polymorfismu, deklarovaný typ objektu již není shodný s typem za běhu.</span><span class="sxs-lookup"><span data-stu-id="b376e-106">When this polymorphism occurs, the object's declared type is no longer identical to its run-time type.</span></span>
- <span data-ttu-id="b376e-107">Základní třídy mohou definovat a implementovat [virtuální](../../language-reference/keywords/virtual.md) *metody*a odvozené třídy je mohou [přepsat,](../../language-reference/keywords/override.md) což znamená, že poskytují vlastní definici a implementaci.</span><span class="sxs-lookup"><span data-stu-id="b376e-107">Base classes may define and implement [virtual](../../language-reference/keywords/virtual.md) *methods*, and derived classes can [override](../../language-reference/keywords/override.md) them, which means they provide their own definition and implementation.</span></span> <span data-ttu-id="b376e-108">Za běhu, když kód klienta volá metodu, CLR vyhledá typ běhu objektu a vyvolá toto přepsání virtuální metody.</span><span class="sxs-lookup"><span data-stu-id="b376e-108">At run-time, when client code calls the method, the CLR looks up the run-time type of the object, and invokes that override of the virtual method.</span></span> <span data-ttu-id="b376e-109">Ve zdrojovém kódu můžete volat metodu na základní třídy a způsobit odvozené třídy verze metody, které mají být provedeny.</span><span class="sxs-lookup"><span data-stu-id="b376e-109">In your source code you can call a method on a base class, and cause a derived class's version of the method to be executed.</span></span>

<span data-ttu-id="b376e-110">Virtuální metody umožňují pracovat se skupinami souvisejících objektů jednotným způsobem.</span><span class="sxs-lookup"><span data-stu-id="b376e-110">Virtual methods enable you to work with groups of related objects in a uniform way.</span></span> <span data-ttu-id="b376e-111">Předpokládejme například, že máte kreslicí aplikaci, která umožňuje uživateli vytvářet různé druhy obrazců na kreslicí ploše.</span><span class="sxs-lookup"><span data-stu-id="b376e-111">For example, suppose you have a drawing application that enables a user to create various kinds of shapes on a drawing surface.</span></span> <span data-ttu-id="b376e-112">V době kompilace nevíte, které konkrétní typy obrazců uživatel vytvoří.</span><span class="sxs-lookup"><span data-stu-id="b376e-112">You do not know at compile time which specific types of shapes the user will create.</span></span> <span data-ttu-id="b376e-113">Aplikace však musí sledovat všechny různé typy obrazců, které jsou vytvořeny a musí je aktualizovat v reakci na akce myši uživatele.</span><span class="sxs-lookup"><span data-stu-id="b376e-113">However, the application has to keep track of all the various types of shapes that are created, and it has to update them in response to user mouse actions.</span></span> <span data-ttu-id="b376e-114">Polymorfismus můžete použít k vyřešení tohoto problému ve dvou základních krocích:</span><span class="sxs-lookup"><span data-stu-id="b376e-114">You can use polymorphism to solve this problem in two basic steps:</span></span>

1. <span data-ttu-id="b376e-115">Vytvořte hierarchii tříd, ve které každá konkrétní třída tvarů pochází ze společné základní třídy.</span><span class="sxs-lookup"><span data-stu-id="b376e-115">Create a class hierarchy in which each specific shape class derives from a common base class.</span></span>
1. <span data-ttu-id="b376e-116">Virtuální metoda slouží k vyvolání příslušné metody pro všechny odvozené třídy prostřednictvím jednoho volání metody základní třídy.</span><span class="sxs-lookup"><span data-stu-id="b376e-116">Use a virtual method to invoke the appropriate method on any derived class through a single call to the base class method.</span></span>

<span data-ttu-id="b376e-117">Nejprve vytvořte základní `Shape`třídu s názvem `Rectangle` `Circle`a `Triangle`odvozené třídy, například , a .</span><span class="sxs-lookup"><span data-stu-id="b376e-117">First, create a base class called `Shape`, and derived classes such as `Rectangle`, `Circle`, and `Triangle`.</span></span> <span data-ttu-id="b376e-118">Pojmenujte třídu `Shape` `Draw`virtuální metodou s názvem a přepište ji v každé odvozené třídě, abyste nakreslili konkrétní tvar, který třída představuje.</span><span class="sxs-lookup"><span data-stu-id="b376e-118">Give the `Shape` class a virtual method called `Draw`, and override it in each derived class to draw the particular shape that the class represents.</span></span> <span data-ttu-id="b376e-119">Vytvořte `List<Shape>` objekt a `Circle` `Triangle`přidejte `Rectangle` k němu a .</span><span class="sxs-lookup"><span data-stu-id="b376e-119">Create a `List<Shape>` object and add a `Circle`, `Triangle`, and `Rectangle` to it.</span></span>

[!code-csharp[Polymorphism overview](~/samples/snippets/csharp/objectoriented/Inheritance.cs#PolymorphismOverview)]

<span data-ttu-id="b376e-120">Chcete-li aktualizovat kreslicí plochu, použijte [foreach](../../language-reference/keywords/foreach-in.md) smyčky `Draw` iterát prostřednictvím seznamu a volání metody na každý `Shape` objekt v seznamu.</span><span class="sxs-lookup"><span data-stu-id="b376e-120">To update the drawing surface, use a [foreach](../../language-reference/keywords/foreach-in.md) loop to iterate through the list and call the `Draw` method on each `Shape` object in the list.</span></span> <span data-ttu-id="b376e-121">I když každý objekt v seznamu `Shape`má deklarovaný typ , je to typ run-time (přepsané verze metody v každé odvozené třídě), která bude vyvolána.</span><span class="sxs-lookup"><span data-stu-id="b376e-121">Even though each object in the list has a declared type of `Shape`, it's the run-time type (the overridden version of the method in each derived class) that will be invoked.</span></span>

[!code-csharp[Polymorphism overview](~/samples/snippets/csharp/objectoriented/Inheritance.cs#UsePolymorphism)]

<span data-ttu-id="b376e-122">V jazyce C# je každý typ polymorfní, protože všechny <xref:System.Object>typy, včetně uživatelem definovaných typů, dědí z .</span><span class="sxs-lookup"><span data-stu-id="b376e-122">In C#, every type is polymorphic because all types, including user-defined types, inherit from <xref:System.Object>.</span></span>  

## <a name="polymorphism-overview"></a><span data-ttu-id="b376e-123">Přehled polymorfismu</span><span class="sxs-lookup"><span data-stu-id="b376e-123">Polymorphism overview</span></span>

### <a name="virtual-members"></a><span data-ttu-id="b376e-124">Virtuální členové</span><span class="sxs-lookup"><span data-stu-id="b376e-124">Virtual members</span></span>

<span data-ttu-id="b376e-125">Když odvozená třída dědí ze základní třídy, získá všechny metody, pole, vlastnosti a události základní třídy.</span><span class="sxs-lookup"><span data-stu-id="b376e-125">When a derived class inherits from a base class, it gains all the methods, fields, properties, and events of the base class.</span></span> <span data-ttu-id="b376e-126">Návrhář odvozené třídy může různé volby pro chování virtuálních metod:</span><span class="sxs-lookup"><span data-stu-id="b376e-126">The designer of the derived class can different choices for the behavior of virtual methods:</span></span>

- <span data-ttu-id="b376e-127">Odvozená třída může přepsat virtuální členy v základní třídě a definovat nové chování.</span><span class="sxs-lookup"><span data-stu-id="b376e-127">The derived class may override virtual members in the base class, defining new behavior.</span></span>
- <span data-ttu-id="b376e-128">Odvozená třída dědí nejbližší metodu základní třídy bez jejího přepsání, zachování existujícího chování, ale povolení dalších odvozených tříd k přepsání metody.</span><span class="sxs-lookup"><span data-stu-id="b376e-128">The derived class inherit the closest base class method without overriding it, preserving the existing behavior but enabling further derived classes to override the method.</span></span>
- <span data-ttu-id="b376e-129">Odvozené třídy může definovat nové nevirtuální implementace těchto členů, které skrýt implementace základní třídy.</span><span class="sxs-lookup"><span data-stu-id="b376e-129">The derived class may define new non-virtual implementation of those members that hide the base class implementations.</span></span>

<span data-ttu-id="b376e-130">Odvozená třída může přepsat člen základní třídy pouze v případě, že člen základní třídy je deklarován jako [virtuální](../../language-reference/keywords/virtual.md) nebo [abstraktní](../../language-reference/keywords/abstract.md).</span><span class="sxs-lookup"><span data-stu-id="b376e-130">A derived class can override a base class member only if the base class member is declared as [virtual](../../language-reference/keywords/virtual.md) or [abstract](../../language-reference/keywords/abstract.md).</span></span> <span data-ttu-id="b376e-131">Odvozený člen musí použít klíčové slovo [přepsat](../../language-reference/keywords/override.md) explicitně označit, že metoda je určena k účasti na virtuální vyvolání.</span><span class="sxs-lookup"><span data-stu-id="b376e-131">The derived member must use the [override](../../language-reference/keywords/override.md) keyword to explicitly indicate that the method is intended to participate in virtual invocation.</span></span> <span data-ttu-id="b376e-132">Následující kód obsahuje příklad:</span><span class="sxs-lookup"><span data-stu-id="b376e-132">The following code provides an example:</span></span>

[!code-csharp[Virtual overview](~/samples/snippets/csharp/objectoriented/Inheritance.cs#VirtualMethods)]

<span data-ttu-id="b376e-133">Pole nemohou být virtuální. pouze metody, vlastnosti, události a indexery mohou být virtuální.</span><span class="sxs-lookup"><span data-stu-id="b376e-133">Fields cannot be virtual; only methods, properties, events, and indexers can be virtual.</span></span> <span data-ttu-id="b376e-134">Když odvozená třída přepíše virtuální člen, tento člen je volán i v případě, že instance této třídy je přístupná jako instance základní třídy.</span><span class="sxs-lookup"><span data-stu-id="b376e-134">When a derived class overrides a virtual member, that member is called even when an instance of that class is being accessed as an instance of the base class.</span></span> <span data-ttu-id="b376e-135">Následující kód obsahuje příklad:</span><span class="sxs-lookup"><span data-stu-id="b376e-135">The following code provides an example:</span></span>

[!code-csharp[Virtual overview example](~/samples/snippets/csharp/objectoriented/Inheritance.cs#VirtualMethods)]

<span data-ttu-id="b376e-136">Virtuální metody a vlastnosti umožňují odvozeným třídám rozšířit základní třídu bez nutnosti použití implementace základní třídy metody.</span><span class="sxs-lookup"><span data-stu-id="b376e-136">Virtual methods and properties enable derived classes to extend a base class without needing to use the base class implementation of a method.</span></span> <span data-ttu-id="b376e-137">Další informace naleznete v [tématu Versioning with the Override and New Keywords](./versioning-with-the-override-and-new-keywords.md).</span><span class="sxs-lookup"><span data-stu-id="b376e-137">For more information, see [Versioning with the Override and New Keywords](./versioning-with-the-override-and-new-keywords.md).</span></span> <span data-ttu-id="b376e-138">Rozhraní poskytuje jiný způsob, jak definovat metodu nebo sadu metod, jejichž implementace je ponechána na odvozené třídy.</span><span class="sxs-lookup"><span data-stu-id="b376e-138">An interface provides another way to define a method or set of methods whose implementation is left to derived classes.</span></span> <span data-ttu-id="b376e-139">Další informace naleznete v [tématu Rozhraní](../interfaces/index.md).</span><span class="sxs-lookup"><span data-stu-id="b376e-139">For more information, see [Interfaces](../interfaces/index.md).</span></span>

### <a name="hide-base-class-members-with-new-members"></a><span data-ttu-id="b376e-140">Skrýt členy základní třídy s novými členy</span><span class="sxs-lookup"><span data-stu-id="b376e-140">Hide base class members with new members</span></span>

<span data-ttu-id="b376e-141">Pokud chcete, aby vaše odvozená třída měla člena se stejným názvem jako člen v základní třídě, můžete použít [nové](../../language-reference/keywords/new-modifier.md) klíčové slovo ke skrytí člena základní třídy.</span><span class="sxs-lookup"><span data-stu-id="b376e-141">If you want your derived class to have a member with the same name as a member in a base class, you can use the [new](../../language-reference/keywords/new-modifier.md) keyword to hide the base class member.</span></span> <span data-ttu-id="b376e-142">Klíčové `new` slovo je umístěn před návratový typ člena třídy, který je nahrazen.</span><span class="sxs-lookup"><span data-stu-id="b376e-142">The `new` keyword is put before the return type of a class member that is being replaced.</span></span> <span data-ttu-id="b376e-143">Následující kód obsahuje příklad:</span><span class="sxs-lookup"><span data-stu-id="b376e-143">The following code provides an example:</span></span>

[!code-csharp[New method overview example](~/samples/snippets/csharp/objectoriented/Inheritance.cs#NewMethods)]

<span data-ttu-id="b376e-144">Členové skryté základní třídy mohou být přístupné z kódu klienta přetypování instance odvozené třídy na instanci základní třídy.</span><span class="sxs-lookup"><span data-stu-id="b376e-144">Hidden base class members may be accessed from client code by casting the instance of the derived class to an instance of the base class.</span></span> <span data-ttu-id="b376e-145">Například:</span><span class="sxs-lookup"><span data-stu-id="b376e-145">For example:</span></span>

[!code-csharp[New method overview usage](~/samples/snippets/csharp/objectoriented/Inheritance.cs#UseNewMethods)]

### <a name="prevent-derived-classes-from-overriding-virtual-members"></a><span data-ttu-id="b376e-146">Zabránit odvozeným třídám v přepsání virtuálních členů</span><span class="sxs-lookup"><span data-stu-id="b376e-146">Prevent derived classes from overriding virtual members</span></span>  

<span data-ttu-id="b376e-147">Virtuální členové zůstávají virtuální, bez ohledu na to, kolik tříd byly deklarovány mezi virtuální člen a třídy, která původně deklaroval.</span><span class="sxs-lookup"><span data-stu-id="b376e-147">Virtual members remain virtual, regardless of how many classes have been declared between the virtual member and the class that originally declared it.</span></span> <span data-ttu-id="b376e-148">Pokud `A` třída deklaruje `B` virtuální člen `A`a `C` třída je `B`odvozena od , a třída je odvozena z , třída `C` dědí virtuální člen a může přepsat, bez ohledu na to, zda třída `B` deklarovala přepsání pro tento člen.</span><span class="sxs-lookup"><span data-stu-id="b376e-148">If class `A` declares a virtual member, and class `B` derives from `A`, and class `C` derives from `B`, class `C` inherits the virtual member, and may override it, regardless of whether class `B` declared an override for that member.</span></span> <span data-ttu-id="b376e-149">Následující kód obsahuje příklad:</span><span class="sxs-lookup"><span data-stu-id="b376e-149">The following code provides an example:</span></span>

[!code-csharp[Basic hierarchy](~/samples/snippets/csharp/objectoriented/Hierarchy.cs#FirstHierarchy)]

<span data-ttu-id="b376e-150">Odvozená třída může zastavit virtuální dědičnost deklarováním přepsání jako [zapečetěné](../../language-reference/keywords/sealed.md).</span><span class="sxs-lookup"><span data-stu-id="b376e-150">A derived class can stop virtual inheritance by declaring an override as [sealed](../../language-reference/keywords/sealed.md).</span></span> <span data-ttu-id="b376e-151">Zastavení dědičnosti `sealed` vyžaduje uvedení `override` klíčového slova před klíčové slovo v deklaraci člena třídy.</span><span class="sxs-lookup"><span data-stu-id="b376e-151">Stopping inheritance requires putting the `sealed` keyword before the `override` keyword in the class member declaration.</span></span> <span data-ttu-id="b376e-152">Následující kód obsahuje příklad:</span><span class="sxs-lookup"><span data-stu-id="b376e-152">The following code provides an example:</span></span>

[!code-csharp[A sealed overridden member](~/samples/snippets/csharp/objectoriented/Hierarchy.cs#SealedOverride)]

<span data-ttu-id="b376e-153">V předchozím příkladu `DoWork` metoda již není virtuální pro `C`všechny třídy odvozené z .</span><span class="sxs-lookup"><span data-stu-id="b376e-153">In the previous example, the method `DoWork` is no longer virtual to any class derived from `C`.</span></span> <span data-ttu-id="b376e-154">Je to stále virtuální pro `C`instance , i když `B` jsou `A`přetypována na typ nebo typ .</span><span class="sxs-lookup"><span data-stu-id="b376e-154">It's still virtual for instances of `C`, even if they're cast to type `B` or type `A`.</span></span> <span data-ttu-id="b376e-155">Zapečetěné metody mohou být nahrazeny odvozenými třídami pomocí klíčového `new` slova, jak ukazuje následující příklad:</span><span class="sxs-lookup"><span data-stu-id="b376e-155">Sealed methods can be replaced by derived classes by using the `new` keyword, as the following example shows:</span></span>

[!code-csharp[New method declaration](~/samples/snippets/csharp/objectoriented/Hierarchy.cs#NewDeclaration)]

<span data-ttu-id="b376e-156">V `DoWork` tomto případě, pokud `D` je volána `D`pomocí `DoWork` proměnné typu , je volána nová.</span><span class="sxs-lookup"><span data-stu-id="b376e-156">In this case, if `DoWork` is called on `D` using a variable of type `D`, the new `DoWork` is called.</span></span> <span data-ttu-id="b376e-157">Pokud proměnná `C`typu `B`, `A` , nebo se `D`používá pro `DoWork` přístup k instanci , volání bude dodržovat `DoWork` pravidla `C`virtuální dědičnosti, směrování těchto volání k implementaci na třídu .</span><span class="sxs-lookup"><span data-stu-id="b376e-157">If a variable of type `C`, `B`, or `A` is used to access an instance of `D`, a call to `DoWork` will follow the rules of virtual inheritance, routing those calls to the implementation of `DoWork` on class `C`.</span></span>

### <a name="access-base-class-virtual-members-from-derived-classes"></a><span data-ttu-id="b376e-158">Přístup k virtuálním členům základní třídy z odvozených tříd</span><span class="sxs-lookup"><span data-stu-id="b376e-158">Access base class virtual members from derived classes</span></span>

<span data-ttu-id="b376e-159">Odvozená třída, která nahradila nebo přepsala metodu nebo vlastnost, může stále `base` přistupovat k metodě nebo vlastnosti základní třídy pomocí klíčového slova.</span><span class="sxs-lookup"><span data-stu-id="b376e-159">A derived class that has replaced or overridden a method or property can still access the method or property on the base class using the `base` keyword.</span></span> <span data-ttu-id="b376e-160">Následující kód obsahuje příklad:</span><span class="sxs-lookup"><span data-stu-id="b376e-160">The following code provides an example:</span></span>

```csharp
public class Base
{
    public virtual void DoWork() {/*...*/ }
}
public class Derived : Base
{
    public override void DoWork()
    {
        //Perform Derived's work here
        //...
        // Call DoWork on base class
        base.DoWork();
    }
}
```

<span data-ttu-id="b376e-161">Další informace naleznete v [tématu base](../../language-reference/keywords/base.md).</span><span class="sxs-lookup"><span data-stu-id="b376e-161">For more information, see [base](../../language-reference/keywords/base.md).</span></span>

> [!NOTE]
> <span data-ttu-id="b376e-162">Doporučuje se, aby `base` virtuální členové použít k volání implementace základní třídy tohoto člena v jejich vlastní implementaci.</span><span class="sxs-lookup"><span data-stu-id="b376e-162">It is recommended that virtual members use `base` to call the base class implementation of that member in their own implementation.</span></span> <span data-ttu-id="b376e-163">Umožňuje základní třídy chování umožňuje odvozené třídy soustředit se na implementaci chování specifické pro odvozené třídy.</span><span class="sxs-lookup"><span data-stu-id="b376e-163">Letting the base class behavior occur enables the derived class to concentrate on implementing behavior specific to the derived class.</span></span> <span data-ttu-id="b376e-164">Pokud není volána implementace základní třídy, je na odvozené třídě, aby jejich chování bylo kompatibilní s chováním základní třídy.</span><span class="sxs-lookup"><span data-stu-id="b376e-164">If the base class implementation is not called, it is up to the derived class to make their behavior compatible with the behavior of the base class.</span></span>

## <a name="in-this-section"></a><span data-ttu-id="b376e-165">V tomto oddílu</span><span class="sxs-lookup"><span data-stu-id="b376e-165">In this section</span></span>

- [<span data-ttu-id="b376e-166">Správa verzí pomocí klíčových slov override a new</span><span class="sxs-lookup"><span data-stu-id="b376e-166">Versioning with the Override and New Keywords</span></span>](./versioning-with-the-override-and-new-keywords.md)
- [<span data-ttu-id="b376e-167">Znalost, kdy použít klíčová slova override a new</span><span class="sxs-lookup"><span data-stu-id="b376e-167">Knowing When to Use Override and New Keywords</span></span>](./knowing-when-to-use-override-and-new-keywords.md)
- [<span data-ttu-id="b376e-168">Jak přepsat metodu ToString</span><span class="sxs-lookup"><span data-stu-id="b376e-168">How to override the ToString method</span></span>](./how-to-override-the-tostring-method.md)

## <a name="see-also"></a><span data-ttu-id="b376e-169">Viz také</span><span class="sxs-lookup"><span data-stu-id="b376e-169">See also</span></span>

- [<span data-ttu-id="b376e-170">Programovací příručka jazyka C#</span><span class="sxs-lookup"><span data-stu-id="b376e-170">C# Programming Guide</span></span>](../index.md)
- [<span data-ttu-id="b376e-171">Dědičnost</span><span class="sxs-lookup"><span data-stu-id="b376e-171">Inheritance</span></span>](./inheritance.md)
- [<span data-ttu-id="b376e-172">Abstraktní a uzavřené třídy a jejich členové</span><span class="sxs-lookup"><span data-stu-id="b376e-172">Abstract and Sealed Classes and Class Members</span></span>](./abstract-and-sealed-classes-and-class-members.md)
- [<span data-ttu-id="b376e-173">Metody</span><span class="sxs-lookup"><span data-stu-id="b376e-173">Methods</span></span>](./methods.md)
- [<span data-ttu-id="b376e-174">Akce</span><span class="sxs-lookup"><span data-stu-id="b376e-174">Events</span></span>](../events/index.md)
- [<span data-ttu-id="b376e-175">Vlastnosti</span><span class="sxs-lookup"><span data-stu-id="b376e-175">Properties</span></span>](./properties.md)
- [<span data-ttu-id="b376e-176">Indexery</span><span class="sxs-lookup"><span data-stu-id="b376e-176">Indexers</span></span>](../indexers/index.md)
- [<span data-ttu-id="b376e-177">Typy</span><span class="sxs-lookup"><span data-stu-id="b376e-177">Types</span></span>](../types/index.md)
