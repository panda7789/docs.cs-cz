---
title: Vysvětlení stromů výrazů
description: Zjistěte o stromech výrazů a o tom, jak jsou užitečné při překladu algoritmů pro externí spuštění a kontrolu kódu před jeho spuštěním.
ms.date: 06/20/2016
ms.technology: csharp-advanced-concepts
ms.assetid: bbcdd339-86eb-4ae5-9911-4c214a39a92d
ms.openlocfilehash: 12093e9c9246c87cc5ea3aedaca6ba34acacce4d
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 03/14/2020
ms.locfileid: "73036996"
---
# <a name="expression-trees-explained"></a><span data-ttu-id="23c72-103">Vysvětlení stromů výrazů</span><span class="sxs-lookup"><span data-stu-id="23c72-103">Expression Trees Explained</span></span>

[<span data-ttu-id="23c72-104">Předchozí -- Přehled</span><span class="sxs-lookup"><span data-stu-id="23c72-104">Previous -- Overview</span></span>](expression-trees.md)

<span data-ttu-id="23c72-105">Strom výrazů je datová struktura, která definuje kód.</span><span class="sxs-lookup"><span data-stu-id="23c72-105">An Expression Tree is a data structure that defines code.</span></span> <span data-ttu-id="23c72-106">Jsou založeny na stejné struktury, které kompilátor používá k analýze kódu a generovat zkompilovaný výstup.</span><span class="sxs-lookup"><span data-stu-id="23c72-106">They are based on the same structures that a compiler uses to analyze code and generate the compiled output.</span></span> <span data-ttu-id="23c72-107">Při čtení tohoto kurzu si všimnete poměrně dost podobnosti mezi stromy výrazů a typy používanými v roslynských apich k sestavení [analyzátorů a oprav kódu](https://github.com/dotnet/roslyn-analyzers).</span><span class="sxs-lookup"><span data-stu-id="23c72-107">As you read through this tutorial, you will notice quite a bit of similarity between Expression Trees and the types used in the Roslyn APIs to build [Analyzers and CodeFixes](https://github.com/dotnet/roslyn-analyzers).</span></span>
<span data-ttu-id="23c72-108">(Analyzátory a codefixes jsou balíčky NuGet, které provádějí statickou analýzu kódu a mohou navrhnout potenciální opravy pro vývojáře.) Koncepty jsou podobné a konečným výsledkem je datová struktura, která umožňuje smysluplnou kontrolu zdrojového kódu.</span><span class="sxs-lookup"><span data-stu-id="23c72-108">(Analyzers and CodeFixes are NuGet packages that perform static analysis on code and can suggest potential fixes for a developer.) The concepts are similar, and the end result is a data structure that allows examination of the source code in a meaningful way.</span></span> <span data-ttu-id="23c72-109">Stromy výrazů jsou však založeny na zcela jinou sadu tříd a api než Roslyn API.</span><span class="sxs-lookup"><span data-stu-id="23c72-109">However, Expression Trees are based on a totally different set of classes and APIs than the Roslyn APIs.</span></span>

<span data-ttu-id="23c72-110">Podívejme se na jednoduchý příklad.</span><span class="sxs-lookup"><span data-stu-id="23c72-110">Let's look at a simple example.</span></span>
<span data-ttu-id="23c72-111">Tady je řádek kódu:</span><span class="sxs-lookup"><span data-stu-id="23c72-111">Here's a line of code:</span></span>

```csharp
var sum = 1 + 2;
```

<span data-ttu-id="23c72-112">Pokud byste to měli analyzovat jako strom výrazů, strom obsahuje několik uzlů.</span><span class="sxs-lookup"><span data-stu-id="23c72-112">If you were to analyze this as an expression tree, the tree contains several nodes.</span></span>
<span data-ttu-id="23c72-113">Nejvzdálenější uzel je deklarace proměnné s`var sum = 1 + 2;`přiřazením ( ) Tento nejvzdálenější uzel obsahuje několik podřízených uzlů: deklaraci proměnné, operátor přiřazení a výraz představující pravou stranu znaménko rovná se.</span><span class="sxs-lookup"><span data-stu-id="23c72-113">The outermost node is a variable declaration statement with assignment (`var sum = 1 + 2;`) That outermost node contains several child nodes: a variable declaration, an assignment operator, and an expression representing the right hand side of the equals sign.</span></span> <span data-ttu-id="23c72-114">Tento výraz je dále rozdělen na výrazy, které představují operaci sčítání a levé a pravé operandy přidání.</span><span class="sxs-lookup"><span data-stu-id="23c72-114">That expression is further subdivided into expressions that represent the addition operation, and left and right operands of the addition.</span></span>

<span data-ttu-id="23c72-115">Podívejme se trochu dále do výrazů, které tvoří pravou stranu znaménko rovná se.</span><span class="sxs-lookup"><span data-stu-id="23c72-115">Let's drill down a bit more into the expressions that make up the right side of the equals sign.</span></span>
<span data-ttu-id="23c72-116">Výraz je `1 + 2`.</span><span class="sxs-lookup"><span data-stu-id="23c72-116">The expression is `1 + 2`.</span></span> <span data-ttu-id="23c72-117">To je binární výraz.</span><span class="sxs-lookup"><span data-stu-id="23c72-117">That's a binary expression.</span></span> <span data-ttu-id="23c72-118">Přesněji řečeno, je to binární doplněk výraz.</span><span class="sxs-lookup"><span data-stu-id="23c72-118">More specifically, it's a binary addition expression.</span></span> <span data-ttu-id="23c72-119">Binární doplněk výraz má dvě podřízené objekty, představující levé a pravé uzly výrazu sčítání.</span><span class="sxs-lookup"><span data-stu-id="23c72-119">A binary addition expression has two children, representing the left and right nodes of the addition expression.</span></span> <span data-ttu-id="23c72-120">Zde jsou oba uzly konstantní výrazy: Levý `1`operand je hodnota a `2`pravý operand je hodnota .</span><span class="sxs-lookup"><span data-stu-id="23c72-120">Here, both nodes are constant expressions: The left operand is the value `1`, and the right operand is the value `2`.</span></span>

<span data-ttu-id="23c72-121">Vizuálně je celý příkaz strom: Můžete začít u kořenového uzlu a cestovat do každého uzlu ve stromu, abyste viděli kód, který tvoří příkaz:</span><span class="sxs-lookup"><span data-stu-id="23c72-121">Visually, the entire statement is a tree: You could start at the root node, and travel to each node in the tree to see the code that makes up the statement:</span></span>

- <span data-ttu-id="23c72-122">Prohlášení proměnné s`var sum = 1 + 2;`přiřazením ( )</span><span class="sxs-lookup"><span data-stu-id="23c72-122">Variable declaration statement with assignment (`var sum = 1 + 2;`)</span></span>
  - <span data-ttu-id="23c72-123">Implicitní deklarace`var sum`typu proměnné ( )</span><span class="sxs-lookup"><span data-stu-id="23c72-123">Implicit variable type declaration (`var sum`)</span></span>
    - <span data-ttu-id="23c72-124">Implicitní klíčové`var`slovo var ( )</span><span class="sxs-lookup"><span data-stu-id="23c72-124">Implicit var keyword (`var`)</span></span>
    - <span data-ttu-id="23c72-125">Deklarace názvu`sum`proměnné ( )</span><span class="sxs-lookup"><span data-stu-id="23c72-125">Variable name declaration (`sum`)</span></span>
  - <span data-ttu-id="23c72-126">Operátor přiřazení`=`( )</span><span class="sxs-lookup"><span data-stu-id="23c72-126">Assignment operator (`=`)</span></span>
  - <span data-ttu-id="23c72-127">Binární přídavek`1 + 2`výraz ( )</span><span class="sxs-lookup"><span data-stu-id="23c72-127">Binary addition expression (`1 + 2`)</span></span>
    - <span data-ttu-id="23c72-128">Levý operand`1`( )</span><span class="sxs-lookup"><span data-stu-id="23c72-128">Left operand (`1`)</span></span>
    - <span data-ttu-id="23c72-129">Operátor sčítání`+`( )</span><span class="sxs-lookup"><span data-stu-id="23c72-129">Addition operator (`+`)</span></span>
    - <span data-ttu-id="23c72-130">Pravý operand`2`( )</span><span class="sxs-lookup"><span data-stu-id="23c72-130">Right operand (`2`)</span></span>

<span data-ttu-id="23c72-131">To může vypadat komplikovaně, ale je to velmi silné.</span><span class="sxs-lookup"><span data-stu-id="23c72-131">This may look complicated, but it is very powerful.</span></span> <span data-ttu-id="23c72-132">Stejným postupem můžete rozložit mnohem složitější výrazy.</span><span class="sxs-lookup"><span data-stu-id="23c72-132">Following the same process, you can decompose much more complicated expressions.</span></span> <span data-ttu-id="23c72-133">Zvažte tento výraz:</span><span class="sxs-lookup"><span data-stu-id="23c72-133">Consider this expression:</span></span>

```csharp
var finalAnswer = this.SecretSauceFunction(
    currentState.createInterimResult(), currentState.createSecondValue(1, 2),
    decisionServer.considerFinalOptions("hello")) +
    MoreSecretSauce('A', DateTime.Now, true);
```

<span data-ttu-id="23c72-134">Výše uvedený výraz je také deklarace proměnné s přiřazením.</span><span class="sxs-lookup"><span data-stu-id="23c72-134">The expression above is also a variable declaration with an assignment.</span></span>
<span data-ttu-id="23c72-135">V tomto případě je pravá strana přiřazení mnohem složitější strom.</span><span class="sxs-lookup"><span data-stu-id="23c72-135">In this instance, the right hand side of the assignment is a much more complicated tree.</span></span>
<span data-ttu-id="23c72-136">Nebudu rozkládat tento výraz, ale zvážit, jaké by mohly být různé uzly.</span><span class="sxs-lookup"><span data-stu-id="23c72-136">I'm not going to decompose this expression, but consider what the different nodes might be.</span></span> <span data-ttu-id="23c72-137">Existují volání metody pomocí aktuálního objektu jako příjemce, ten, který má explicitní `this` příjemce, ten, který nemá.</span><span class="sxs-lookup"><span data-stu-id="23c72-137">There are method calls using the current object as a receiver, one that has an explicit `this` receiver, one that does not.</span></span> <span data-ttu-id="23c72-138">Existují volání metody pomocí jiných objektů příjemce, existují konstantní argumenty různých typů.</span><span class="sxs-lookup"><span data-stu-id="23c72-138">There are method calls using other receiver objects, there are constant arguments of different types.</span></span> <span data-ttu-id="23c72-139">A konečně, tam je binární sčítání operátor.</span><span class="sxs-lookup"><span data-stu-id="23c72-139">And finally, there is a binary addition operator.</span></span> <span data-ttu-id="23c72-140">V závislosti na `SecretSauceFunction()` návratový typ nebo `MoreSecretSauce()`, že binární sčítání operátor může být volání metody potlačené sčítání operátor, řešení statické metody volání binární sčítání operátor definované pro třídu.</span><span class="sxs-lookup"><span data-stu-id="23c72-140">Depending on the return type of `SecretSauceFunction()` or `MoreSecretSauce()`, that binary addition operator may be a method call to an overridden addition operator, resolving to a static method call to the binary addition operator defined for a class.</span></span>

<span data-ttu-id="23c72-141">Navzdory této složitosti, výše uvedený výraz vytvoří stromovou strukturu, která může být navigována stejně snadno jako první vzorek.</span><span class="sxs-lookup"><span data-stu-id="23c72-141">Despite this perceived complexity, the expression above creates a tree structure that can be navigated as easily as the first sample.</span></span> <span data-ttu-id="23c72-142">Můžete pokračovat v procházení podřízených uzlů najít listové uzly ve výrazu.</span><span class="sxs-lookup"><span data-stu-id="23c72-142">You can keep traversing child nodes to find leaf nodes in the expression.</span></span> <span data-ttu-id="23c72-143">Nadřazené uzly budou mít odkazy na své podřízené položky a každý uzel má vlastnost, která popisuje, jaký druh uzlu je.</span><span class="sxs-lookup"><span data-stu-id="23c72-143">Parent nodes will have references to their children, and each node has a property that describes what kind of node it is.</span></span>

<span data-ttu-id="23c72-144">Struktura stromu výrazů je velmi konzistentní.</span><span class="sxs-lookup"><span data-stu-id="23c72-144">The structure of an expression tree is very consistent.</span></span> <span data-ttu-id="23c72-145">Jakmile se naučíte základy, můžete pochopit i nejsložitější kód, když je reprezentován jako strom výrazů.</span><span class="sxs-lookup"><span data-stu-id="23c72-145">Once you've learned the basics, you can understand even the most complex code when it is represented as an expression tree.</span></span> <span data-ttu-id="23c72-146">Elegance v datové struktuře vysvětluje, jak kompilátor Jazyka C# můžete analyzovat nejsložitější c# programy a vytvořit správný výstup z tohoto složitého zdrojového kódu.</span><span class="sxs-lookup"><span data-stu-id="23c72-146">The elegance in the data structure explains how the C# compiler can analyze the most complex C# programs and create proper output from that complicated source code.</span></span>

<span data-ttu-id="23c72-147">Jakmile se seznámíte se strukturou stromů výrazů, zjistíte, že znalosti, které jste získali rychle, vám umožní pracovat s mnoha dalšími a pokročilejšími scénáři.</span><span class="sxs-lookup"><span data-stu-id="23c72-147">Once you become familiar with the structure of expression trees, you will find that knowledge you've gained quickly enables you to work with many more and more advanced scenarios.</span></span> <span data-ttu-id="23c72-148">Tam je neuvěřitelná síla výrazu stromů.</span><span class="sxs-lookup"><span data-stu-id="23c72-148">There is incredible power to expression trees.</span></span>

<span data-ttu-id="23c72-149">Kromě překladu algoritmů pro spuštění v jiných prostředích lze stromy výrazů usnadnit zápis algoritmů, které kontrolují kód před jeho spuštěním.</span><span class="sxs-lookup"><span data-stu-id="23c72-149">In addition to translating algorithms to execute in other environments, expression trees can be used to make it easier to write algorithms that inspect code before executing it.</span></span> <span data-ttu-id="23c72-150">Můžete napsat metodu, jejíž argumenty jsou výrazy a potom zkontrolujte tyto výrazy před spuštěním kódu.</span><span class="sxs-lookup"><span data-stu-id="23c72-150">You can write a method whose arguments are expressions and then examine those expressions before executing the code.</span></span> <span data-ttu-id="23c72-151">Strom výrazů je úplnou reprezentací kódu: můžete zobrazit hodnoty libovolného dílčího výrazu.</span><span class="sxs-lookup"><span data-stu-id="23c72-151">The Expression Tree is a full representation of the code: you can see values of any sub-expression.</span></span>
<span data-ttu-id="23c72-152">Můžete zobrazit názvy metod a vlastností.</span><span class="sxs-lookup"><span data-stu-id="23c72-152">You can see method and property names.</span></span> <span data-ttu-id="23c72-153">Můžete zobrazit hodnotu všech konstantních výrazů.</span><span class="sxs-lookup"><span data-stu-id="23c72-153">You can see the value of any constant expressions.</span></span>
<span data-ttu-id="23c72-154">Můžete také převést strom výrazů na spustitelného delegáta a spustit kód.</span><span class="sxs-lookup"><span data-stu-id="23c72-154">You can also convert an expression tree into an executable delegate, and execute the code.</span></span>

<span data-ttu-id="23c72-155">Api pro stromy výrazů umožňují vytvářet stromy, které představují téměř všechny platné konstrukce kódu.</span><span class="sxs-lookup"><span data-stu-id="23c72-155">The APIs for Expression Trees enable you to create trees that represent almost any valid code construct.</span></span> <span data-ttu-id="23c72-156">Chcete-li však zachovat věci co nejjednodušší, některé idiomy jazyka C# nelze vytvořit ve stromu výrazů.</span><span class="sxs-lookup"><span data-stu-id="23c72-156">However, to keep things as simple as possible, some C# idioms cannot be created in an expression tree.</span></span> <span data-ttu-id="23c72-157">Jedním z příkladů jsou asynchronní `async` výrazy (pomocí `await` a klíčová slova).</span><span class="sxs-lookup"><span data-stu-id="23c72-157">One example is asynchronous expressions (using the `async` and `await` keywords).</span></span> <span data-ttu-id="23c72-158">Pokud vaše potřeby vyžadují asynchronní algoritmy, budete `Task` muset manipulovat s objekty přímo, spíše než spoléhat na podporu kompilátoru.</span><span class="sxs-lookup"><span data-stu-id="23c72-158">If your needs require asynchronous algorithms, you would need to manipulate the `Task` objects directly, rather than rely on the compiler support.</span></span> <span data-ttu-id="23c72-159">Dalším je vytváření smyček.</span><span class="sxs-lookup"><span data-stu-id="23c72-159">Another is in creating loops.</span></span> <span data-ttu-id="23c72-160">Obvykle je vytvoříte pomocí `for` `foreach`, `while` `do` , nebo smyčky.</span><span class="sxs-lookup"><span data-stu-id="23c72-160">Typically, you create these by using `for`, `foreach`, `while` or `do` loops.</span></span> <span data-ttu-id="23c72-161">Jak uvidíte [dále v této řadě](expression-trees-building.md), api pro stromy výrazů podporují výraz jedné smyčky, s `break` výrazy a `continue` výrazy, které řídí opakování smyčky.</span><span class="sxs-lookup"><span data-stu-id="23c72-161">As you'll see [later in this series](expression-trees-building.md), the APIs for expression trees support a single loop expression, with `break` and `continue` expressions that control repeating the loop.</span></span>

<span data-ttu-id="23c72-162">Jedna věc, kterou nemůžete udělat, je upravit strom výrazů.</span><span class="sxs-lookup"><span data-stu-id="23c72-162">The one thing you can't do is modify an expression tree.</span></span>  <span data-ttu-id="23c72-163">Výraz stromy jsou neměnné datové struktury.</span><span class="sxs-lookup"><span data-stu-id="23c72-163">Expression Trees are immutable data structures.</span></span> <span data-ttu-id="23c72-164">Pokud chcete zmutovat (změnit) strom výrazů, musíte vytvořit nový strom, který je kopií originálu, ale s požadovanými změnami.</span><span class="sxs-lookup"><span data-stu-id="23c72-164">If you want to mutate (change) an expression tree, you must create a new tree that is a copy of the original, but with your desired changes.</span></span>

[<span data-ttu-id="23c72-165">Další -- Typy architektury podporující stromy výrazů</span><span class="sxs-lookup"><span data-stu-id="23c72-165">Next -- Framework Types Supporting Expression Trees</span></span>](expression-classes.md)
