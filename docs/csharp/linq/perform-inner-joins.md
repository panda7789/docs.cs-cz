---
title: Provedení vnitřních spojení (LINQ v C#)
description: Zjistěte, jak provádět vnitřní spojení pomocí LINQ v C#.
ms.date: 12/01/2016
ms.assetid: 45bceed6-f549-4114-a9b1-b44feb497742
ms.openlocfilehash: a3e8e9bd97ec630797bc48a3302b27ed45d9103e
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 03/14/2020
ms.locfileid: "61659836"
---
# <a name="perform-inner-joins"></a><span data-ttu-id="9c8ef-103">Provádění vnitřních spojení</span><span class="sxs-lookup"><span data-stu-id="9c8ef-103">Perform inner joins</span></span>

<span data-ttu-id="9c8ef-104">V relační chod databáze termíny *vnitřní spojení* vytvoří sadu výsledků, ve kterém každý prvek první kolekce se zobrazí jednou pro každý odpovídající prvek v druhé kolekci.</span><span class="sxs-lookup"><span data-stu-id="9c8ef-104">In relational database terms, an *inner join* produces a result set in which each element of the first collection appears one time for every matching element in the second collection.</span></span> <span data-ttu-id="9c8ef-105">Pokud prvek v první kolekci nemá žádné odpovídající prvky, nezobrazí se v sadě výsledků.</span><span class="sxs-lookup"><span data-stu-id="9c8ef-105">If an element in the first collection has no matching elements, it does not appear in the result set.</span></span> <span data-ttu-id="9c8ef-106">Metoda, <xref:System.Linq.Enumerable.Join%2A> která je volána `join` klauzulí v c#, implementuje vnitřní spojení.</span><span class="sxs-lookup"><span data-stu-id="9c8ef-106">The <xref:System.Linq.Enumerable.Join%2A> method, which is called by the `join` clause in C#, implements an inner join.</span></span>

<span data-ttu-id="9c8ef-107">Tento článek ukazuje, jak provést čtyři varianty vnitřního spojení:</span><span class="sxs-lookup"><span data-stu-id="9c8ef-107">This article shows you how to perform four variations of an inner join:</span></span>

- <span data-ttu-id="9c8ef-108">Jednoduché vnitřní spojení, které koreluje prvky ze dvou zdrojů dat na základě jednoduchého klíče.</span><span class="sxs-lookup"><span data-stu-id="9c8ef-108">A simple inner join that correlates elements from two data sources based on a simple key.</span></span>

- <span data-ttu-id="9c8ef-109">Vnitřní spojení, které koreluje prvky ze dvou zdrojů dat na základě *složeného* klíče.</span><span class="sxs-lookup"><span data-stu-id="9c8ef-109">An inner join that correlates elements from two data sources based on a *composite* key.</span></span> <span data-ttu-id="9c8ef-110">Složený klíč, který je klíč, který se skládá z více než jednu hodnotu, umožňuje korelovat prvky založené na více než jednu vlastnost.</span><span class="sxs-lookup"><span data-stu-id="9c8ef-110">A composite key, which is a key that consists of more than one value, enables you to correlate elements based on more than one property.</span></span>

- <span data-ttu-id="9c8ef-111">*Více násobné spojení,* ve kterém jsou vzájemně připojeny po sobě po sobě po sobě po sobě jdoucí operace spojení.</span><span class="sxs-lookup"><span data-stu-id="9c8ef-111">A *multiple join* in which successive join operations are appended to each other.</span></span>

- <span data-ttu-id="9c8ef-112">Vnitřní spojení, které je implementováno pomocí spojení skupiny.</span><span class="sxs-lookup"><span data-stu-id="9c8ef-112">An inner join that is implemented by using a group join.</span></span>

## <a name="example---simple-key-join"></a><span data-ttu-id="9c8ef-113">Příklad - Jednoduché spojení s klíčem</span><span class="sxs-lookup"><span data-stu-id="9c8ef-113">Example - Simple key join</span></span>

<span data-ttu-id="9c8ef-114">Následující příklad vytvoří dvě kolekce, které obsahují objekty `Person` `Pet`dvou typů definovaných uživatelem a .</span><span class="sxs-lookup"><span data-stu-id="9c8ef-114">The following example creates two collections that contain objects of two user-defined types, `Person` and `Pet`.</span></span> <span data-ttu-id="9c8ef-115">Dotaz používá `join` klauzuli v c# `Pet` tak, `Owner` aby `Person`odpovídala `Person` objektům s objekty, jejichž je to .</span><span class="sxs-lookup"><span data-stu-id="9c8ef-115">The query uses the `join` clause in C# to match `Person` objects with `Pet` objects whose `Owner` is that `Person`.</span></span> <span data-ttu-id="9c8ef-116">Klauzule `select` v C# definuje, jak budou výsledné objekty vypadat.</span><span class="sxs-lookup"><span data-stu-id="9c8ef-116">The `select` clause in C# defines how the resulting objects will look.</span></span> <span data-ttu-id="9c8ef-117">V tomto příkladu výsledné objekty jsou anonymní typy, které se skládají z křestního jména vlastníka a názvu domácího mazlíčka.</span><span class="sxs-lookup"><span data-stu-id="9c8ef-117">In this example the resulting objects are anonymous types that consist of the owner's first name and the pet's name.</span></span>

[!code-csharp[CsLINQProgJoining#1](~/samples/snippets/csharp/concepts/linq/how-to-perform-inner-joins_1.cs)]

<span data-ttu-id="9c8ef-118">Všimněte `Person` si, `LastName` že objekt, jehož je "Huff" `Pet` se nezobrazí v sadě výsledků, protože neexistuje žádný objekt, který má `Pet.Owner` rovno . `Person`</span><span class="sxs-lookup"><span data-stu-id="9c8ef-118">Note that the `Person` object whose `LastName` is "Huff" does not appear in the result set because there is no `Pet` object that has `Pet.Owner` equal to that `Person`.</span></span>

## <a name="example---composite-key-join"></a><span data-ttu-id="9c8ef-119">Příklad - Spojení složeného klíče</span><span class="sxs-lookup"><span data-stu-id="9c8ef-119">Example - Composite key join</span></span>

<span data-ttu-id="9c8ef-120">Namísto korelace prvků založených pouze na jedné vlastnosti můžete použít složený klíč k porovnání prvků založených na více vlastnostech.</span><span class="sxs-lookup"><span data-stu-id="9c8ef-120">Instead of correlating elements based on just one property, you can use a composite key to compare elements based on multiple properties.</span></span> <span data-ttu-id="9c8ef-121">Chcete-li to provést, zadejte funkci selektoru klíčů pro každou kolekci, chcete-li vrátit anonymní typ, který se skládá z vlastností, které chcete porovnat.</span><span class="sxs-lookup"><span data-stu-id="9c8ef-121">To do this, specify the key selector function for each collection to return an anonymous type that consists of the properties you want to compare.</span></span> <span data-ttu-id="9c8ef-122">Pokud označíte vlastnosti, musí mít stejný popisek v anonymním typu každého klíče.</span><span class="sxs-lookup"><span data-stu-id="9c8ef-122">If you label the properties, they must have the same label in each key's anonymous type.</span></span> <span data-ttu-id="9c8ef-123">Vlastnosti se musí také zobrazit ve stejném pořadí.</span><span class="sxs-lookup"><span data-stu-id="9c8ef-123">The properties must also appear in the same order.</span></span>

<span data-ttu-id="9c8ef-124">Následující příklad používá seznam `Employee` objektů a `Student` seznam objektů k určení, kteří zaměstnanci jsou také studenti.</span><span class="sxs-lookup"><span data-stu-id="9c8ef-124">The following example uses a list of `Employee` objects and a list of `Student` objects to determine which employees are also students.</span></span> <span data-ttu-id="9c8ef-125">Oba tyto typy `FirstName` mají `LastName` a vlastnost <xref:System.String>typu .</span><span class="sxs-lookup"><span data-stu-id="9c8ef-125">Both of these types have a `FirstName` and a `LastName` property of type <xref:System.String>.</span></span> <span data-ttu-id="9c8ef-126">Funkce, které vytvářejí klíče spojení z prvků každého seznamu vrátit anonymní `FirstName` `LastName` typ, který se skládá z a vlastnosti každého prvku.</span><span class="sxs-lookup"><span data-stu-id="9c8ef-126">The functions that create the join keys from each list's elements return an anonymous type that consists of the `FirstName` and `LastName` properties of each element.</span></span> <span data-ttu-id="9c8ef-127">Operace spojení porovná tyto složené klíče pro rovnost a vrátí dvojice objektů z každého seznamu, kde se shoduje křestní jméno i příjmení.</span><span class="sxs-lookup"><span data-stu-id="9c8ef-127">The join operation compares these composite keys for equality and returns pairs of objects from each list where both the first name and the last name match.</span></span>

[!code-csharp[CsLINQProgJoining#2](~/samples/snippets/csharp/concepts/linq/how-to-perform-inner-joins_2.cs)]

## <a name="example---multiple-join"></a><span data-ttu-id="9c8ef-128">Příklad – vícenásobné spojení</span><span class="sxs-lookup"><span data-stu-id="9c8ef-128">Example - Multiple join</span></span>

<span data-ttu-id="9c8ef-129">Libovolný počet operací spojení lze připojit k sobě navzájem provést více spojit.</span><span class="sxs-lookup"><span data-stu-id="9c8ef-129">Any number of join operations can be appended to each other to perform a multiple join.</span></span> <span data-ttu-id="9c8ef-130">Každá `join` klauzule v C# koreluje zadaný zdroj dat s výsledky předchozího spojení.</span><span class="sxs-lookup"><span data-stu-id="9c8ef-130">Each `join` clause in C# correlates a specified data source with the results of the previous join.</span></span>

<span data-ttu-id="9c8ef-131">Následující příklad vytvoří tři kolekce: `Person` seznam objektů, `Cat` seznam objektů a `Dog` seznam objektů.</span><span class="sxs-lookup"><span data-stu-id="9c8ef-131">The following example creates three collections: a list of `Person` objects, a list of `Cat` objects, and a list of `Dog` objects.</span></span>

<span data-ttu-id="9c8ef-132">První `join` klauzule v C# odpovídá lidem `Person` a `Cat.Owner`kočkám na základě odpovídajícího objektu .</span><span class="sxs-lookup"><span data-stu-id="9c8ef-132">The first `join` clause in C# matches people and cats based on a `Person` object matching `Cat.Owner`.</span></span> <span data-ttu-id="9c8ef-133">Vrátí posloupnost anonymních typů, které obsahují `Person` objekt a `Cat.Name`.</span><span class="sxs-lookup"><span data-stu-id="9c8ef-133">It returns a sequence of anonymous types that contain the `Person` object and `Cat.Name`.</span></span>

<span data-ttu-id="9c8ef-134">Druhá `join` klauzule v C# koreluje anonymní typy `Dog` vrácené první spojení s objekty v zadaném seznamu `Owner` psů, `Person`na základě složený klíč, který se skládá z vlastnosti typu a první písmeno názvu zvířete.</span><span class="sxs-lookup"><span data-stu-id="9c8ef-134">The second `join` clause in C# correlates the anonymous types returned by the first join with `Dog` objects in the supplied list of dogs, based on a composite key that consists of the `Owner` property of type `Person`, and the first letter of the animal's name.</span></span> <span data-ttu-id="9c8ef-135">Vrátí posloupnost anonymnítypy, `Cat.Name` které `Dog.Name` obsahují vlastnosti a z každé odpovídající dvojice.</span><span class="sxs-lookup"><span data-stu-id="9c8ef-135">It returns a sequence of anonymous types that contain the `Cat.Name` and `Dog.Name` properties from each matching pair.</span></span> <span data-ttu-id="9c8ef-136">Vzhledem k tomu, že se jedná o vnitřní spojení, jsou vráceny pouze ty objekty z prvního zdroje dat, které mají shodu ve druhém zdroji dat.</span><span class="sxs-lookup"><span data-stu-id="9c8ef-136">Because this is an inner join, only those objects from the first data source that have a match in the second data source are returned.</span></span>

[!code-csharp[CsLINQProgJoining#3](~/samples/snippets/csharp/concepts/linq/how-to-perform-inner-joins_3.cs)]

## <a name="example---inner-join-by-using-grouped-join"></a><span data-ttu-id="9c8ef-137">Příklad – vnitřní spojení pomocí seskupeného spojení</span><span class="sxs-lookup"><span data-stu-id="9c8ef-137">Example - Inner join by using grouped join</span></span>

<span data-ttu-id="9c8ef-138">Následující příklad ukazuje, jak implementovat vnitřní spojení pomocí spojení skupiny.</span><span class="sxs-lookup"><span data-stu-id="9c8ef-138">The following example shows you how to implement an inner join by using a group join.</span></span>

<span data-ttu-id="9c8ef-139">V `query1`oblasti je `Person` seznam objektů spojen se `Pet` skupinovým seznamem objektů na základě `Person` odpovídající vlastnosti. `Pet.Owner`</span><span class="sxs-lookup"><span data-stu-id="9c8ef-139">In `query1`, the list of `Person` objects is group-joined to the list of `Pet` objects based on the `Person` matching the `Pet.Owner` property.</span></span> <span data-ttu-id="9c8ef-140">Spojení skupiny vytvoří kolekci zprostředkujících skupin, `Person` kde každá skupina `Pet` se skládá z objektu a posloupnosti odpovídajících objektů.</span><span class="sxs-lookup"><span data-stu-id="9c8ef-140">The group join creates a collection of intermediate groups, where each group consists of a `Person` object and a sequence of matching `Pet` objects.</span></span>

<span data-ttu-id="9c8ef-141">Přidáním druhé `from` klauzule do dotazu je tato sekvence kombinována (nebo sloučena) do jedné delší sekvence.</span><span class="sxs-lookup"><span data-stu-id="9c8ef-141">By adding a second `from` clause to the query, this sequence of sequences is combined (or flattened) into one longer sequence.</span></span> <span data-ttu-id="9c8ef-142">Typ prvků konečné sekvence je určen klauzulí. `select`</span><span class="sxs-lookup"><span data-stu-id="9c8ef-142">The type of the elements of the final sequence is specified by the `select` clause.</span></span> <span data-ttu-id="9c8ef-143">V tomto příkladu je tento typ anonymní `Person.FirstName` typ, který se skládá z vlastností a `Pet.Name` pro každou odpovídající dvojici.</span><span class="sxs-lookup"><span data-stu-id="9c8ef-143">In this example, that type is an anonymous type that consists of the `Person.FirstName` and `Pet.Name` properties for each matching pair.</span></span>

<span data-ttu-id="9c8ef-144">Výsledek `query1` je ekvivalentní sadu výsledků, které by byly `join` získány `into` pomocí klauzule bez klauzule k provedení vnitřní spojení.</span><span class="sxs-lookup"><span data-stu-id="9c8ef-144">The result of `query1` is equivalent to the result set that would have been obtained by using the `join` clause without the `into` clause to perform an inner join.</span></span> <span data-ttu-id="9c8ef-145">Proměnná `query2` ukazuje tento ekvivalentní dotaz.</span><span class="sxs-lookup"><span data-stu-id="9c8ef-145">The `query2` variable demonstrates this equivalent query.</span></span>

[!code-csharp[CsLINQProgJoining#4](~/samples/snippets/csharp/concepts/linq/how-to-perform-inner-joins_4.cs)]

## <a name="see-also"></a><span data-ttu-id="9c8ef-146">Viz také</span><span class="sxs-lookup"><span data-stu-id="9c8ef-146">See also</span></span>

- <xref:System.Linq.Enumerable.Join%2A>
- <xref:System.Linq.Enumerable.GroupJoin%2A>
- [<span data-ttu-id="9c8ef-147">Provádění seskupených spojení</span><span class="sxs-lookup"><span data-stu-id="9c8ef-147">Perform grouped joins</span></span>](perform-grouped-joins.md)
- [<span data-ttu-id="9c8ef-148">Provedení levých vnějších spojení</span><span class="sxs-lookup"><span data-stu-id="9c8ef-148">Perform left outer joins</span></span>](perform-left-outer-joins.md)
- [<span data-ttu-id="9c8ef-149">Anonymní typy</span><span class="sxs-lookup"><span data-stu-id="9c8ef-149">Anonymous types</span></span>](../programming-guide/classes-and-structs/anonymous-types.md)
