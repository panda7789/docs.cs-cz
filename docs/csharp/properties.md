---
title: Vlastnosti
description: Další informace o vlastnostech jazyka C#, které zahrnují funkce pro ověřování, vypočítané hodnoty, opožděné vyhodnocení a oznámení o změně vlastnosti.
ms.technology: csharp-fundamentals
ms.date: 04/25/2018
ms.openlocfilehash: bda8a4f58f71b57248296dd4ba9f9bf4cbed40d4
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 03/14/2020
ms.locfileid: "79399411"
---
# <a name="properties"></a><span data-ttu-id="0c3b0-103">Vlastnosti</span><span class="sxs-lookup"><span data-stu-id="0c3b0-103">Properties</span></span>

<span data-ttu-id="0c3b0-104">Vlastnosti jsou občané první třídy v C#.</span><span class="sxs-lookup"><span data-stu-id="0c3b0-104">Properties are first class citizens in C#.</span></span> <span data-ttu-id="0c3b0-105">Jazyk definuje syntaxi, která umožňuje vývojářům psát kód, který přesně vyjadřuje jejich záměr návrhu.</span><span class="sxs-lookup"><span data-stu-id="0c3b0-105">The language defines syntax that enables developers to write code that accurately expresses their design intent.</span></span>

<span data-ttu-id="0c3b0-106">Vlastnosti se chovají jako pole při přístupu.</span><span class="sxs-lookup"><span data-stu-id="0c3b0-106">Properties behave like fields when they are accessed.</span></span>
<span data-ttu-id="0c3b0-107">Na rozdíl od polí jsou však vlastnosti implementovány s přistupujícími objekty, které definují příkazy provedené při přístupu k vlastnosti nebo jejich přiřazení.</span><span class="sxs-lookup"><span data-stu-id="0c3b0-107">However, unlike fields, properties are implemented with accessors that define the statements executed when a property is accessed or assigned.</span></span>

## <a name="property-syntax"></a><span data-ttu-id="0c3b0-108">Syntaxe vlastnosti</span><span class="sxs-lookup"><span data-stu-id="0c3b0-108">Property syntax</span></span>

<span data-ttu-id="0c3b0-109">Syntaxe vlastností je přirozeným rozšířením polí.</span><span class="sxs-lookup"><span data-stu-id="0c3b0-109">The syntax for properties is a natural extension to fields.</span></span> <span data-ttu-id="0c3b0-110">Pole definuje umístění úložiště:</span><span class="sxs-lookup"><span data-stu-id="0c3b0-110">A field defines a storage location:</span></span>

[!code-csharp[Person class with public fields](../../samples/snippets/csharp/properties/Person.cs#1)]

<span data-ttu-id="0c3b0-111">Definice vlastnosti obsahuje deklarace pro `get` a `set` přistupující objekt, který načte a přiřadí hodnotu této vlastnosti:</span><span class="sxs-lookup"><span data-stu-id="0c3b0-111">A property definition contains declarations for a `get` and `set` accessor that retrieves and assigns the value of that property:</span></span>

[!code-csharp[Person class with public properties](../../samples/snippets/csharp/properties/Person.cs#2)]

<span data-ttu-id="0c3b0-112">Syntaxe uvedená výše je syntaxe *vlastnosti auto.*</span><span class="sxs-lookup"><span data-stu-id="0c3b0-112">The syntax shown above is the *auto property* syntax.</span></span> <span data-ttu-id="0c3b0-113">Kompilátor generuje umístění úložiště pro pole, které zálohuje vlastnost.</span><span class="sxs-lookup"><span data-stu-id="0c3b0-113">The compiler generates the storage location for the field that backs up the property.</span></span> <span data-ttu-id="0c3b0-114">Kompilátor také implementuje `get` tělo `set` přístupové body a.</span><span class="sxs-lookup"><span data-stu-id="0c3b0-114">The compiler also implements the body of the `get` and `set` accessors.</span></span>

<span data-ttu-id="0c3b0-115">V některých případě je třeba inicializovat vlastnost na hodnotu jinou než výchozí pro její typ.</span><span class="sxs-lookup"><span data-stu-id="0c3b0-115">Sometimes, you need to initialize a property to a value other than the default for its type.</span></span>  <span data-ttu-id="0c3b0-116">C# umožňuje, že nastavením hodnoty za uzavírací složená závorka pro vlastnost.</span><span class="sxs-lookup"><span data-stu-id="0c3b0-116">C# enables that by setting a value after the closing brace for the property.</span></span> <span data-ttu-id="0c3b0-117">Můžete dát přednost počáteční `FirstName` hodnotu vlastnosti být `null`prázdný řetězec spíše než .</span><span class="sxs-lookup"><span data-stu-id="0c3b0-117">You may prefer the initial value for the `FirstName` property to be the empty string rather than `null`.</span></span> <span data-ttu-id="0c3b0-118">Určit, jak je znázorněno níže:</span><span class="sxs-lookup"><span data-stu-id="0c3b0-118">You would specify that as shown below:</span></span>

[!code-csharp[Person class with properties and initializer](../../samples/snippets/csharp/properties/Person.cs#3)]

<span data-ttu-id="0c3b0-119">Konkrétní inicializace je nejužitečnější pro vlastnosti jen pro čtení, jak uvidíte dále v tomto článku.</span><span class="sxs-lookup"><span data-stu-id="0c3b0-119">Specific initialization is most useful for read-only properties, as you'll see later in this article.</span></span>

<span data-ttu-id="0c3b0-120">Úložiště můžete také definovat sami, jak je znázorněno níže:</span><span class="sxs-lookup"><span data-stu-id="0c3b0-120">You can also define the storage yourself, as shown below:</span></span>

[!code-csharp[Person class with properties and backing field](../../samples/snippets/csharp/properties/Person.cs#4)]

<span data-ttu-id="0c3b0-121">Pokud je implementace vlastnosti jeden výraz, můžete použít *členy s výrazem pro* getter nebo setter:</span><span class="sxs-lookup"><span data-stu-id="0c3b0-121">When a property implementation is a single expression, you can use *expression-bodied members* for the getter or setter:</span></span>

[!code-csharp[Person class with properties and expression bodied getters and setters](../../samples/snippets/csharp/properties/Person.cs#5)]

<span data-ttu-id="0c3b0-122">Tato zjednodušená syntaxe bude použita tam, kde je to možné v tomto článku.</span><span class="sxs-lookup"><span data-stu-id="0c3b0-122">This simplified syntax will be used where applicable throughout this article.</span></span>

<span data-ttu-id="0c3b0-123">Definice vlastnosti je vlastnost pro čtení a zápis.</span><span class="sxs-lookup"><span data-stu-id="0c3b0-123">The property definition shown above is a read-write property.</span></span> <span data-ttu-id="0c3b0-124">Všimněte `value` si klíčového slova v přistupujícím přístupovém oru sady.</span><span class="sxs-lookup"><span data-stu-id="0c3b0-124">Notice the keyword `value` in the set accessor.</span></span> <span data-ttu-id="0c3b0-125">Přistupující `set` objekt má `value`vždy jeden parametr s názvem .</span><span class="sxs-lookup"><span data-stu-id="0c3b0-125">The `set` accessor always has a single parameter named `value`.</span></span> <span data-ttu-id="0c3b0-126">Přistupující `get` objekt musí vrátit hodnotu, která`string` je konvertibilní na typ vlastnosti ( v tomto příkladu).</span><span class="sxs-lookup"><span data-stu-id="0c3b0-126">The `get` accessor must return a value that is convertible to the type of the property (`string` in this example).</span></span>

<span data-ttu-id="0c3b0-127">To jsou základy syntaxe.</span><span class="sxs-lookup"><span data-stu-id="0c3b0-127">That's the basics of the syntax.</span></span> <span data-ttu-id="0c3b0-128">Existuje mnoho různých variant, které podporují různé designové idiomy.</span><span class="sxs-lookup"><span data-stu-id="0c3b0-128">There are many different variations that support a variety of different design idioms.</span></span> <span data-ttu-id="0c3b0-129">Pojďme prozkoumat, a naučit se možnosti syntaxe pro každého.</span><span class="sxs-lookup"><span data-stu-id="0c3b0-129">Let's explore, and learn the syntax options for each.</span></span>

## <a name="scenarios"></a><span data-ttu-id="0c3b0-130">Scénáře</span><span class="sxs-lookup"><span data-stu-id="0c3b0-130">Scenarios</span></span>

<span data-ttu-id="0c3b0-131">Výše uvedené příklady ukázaly jeden z nejjednodušších případů definice vlastnosti: vlastnost pro čtení a zápis bez ověření.</span><span class="sxs-lookup"><span data-stu-id="0c3b0-131">The examples above showed one of the simplest cases of property definition: a read-write property with no validation.</span></span> <span data-ttu-id="0c3b0-132">Psaníkódu, který chcete `get` v `set` přístupových prostředcích a, můžete vytvořit mnoho různých scénářů.</span><span class="sxs-lookup"><span data-stu-id="0c3b0-132">By writing the code you want in the `get` and `set` accessors, you can create many different scenarios.</span></span>

### <a name="validation"></a><span data-ttu-id="0c3b0-133">Ověřování</span><span class="sxs-lookup"><span data-stu-id="0c3b0-133">Validation</span></span>

<span data-ttu-id="0c3b0-134">Můžete napsat kód `set` v přistupujícím objektu k zajištění, že hodnoty reprezentované vlastností jsou vždy platné.</span><span class="sxs-lookup"><span data-stu-id="0c3b0-134">You can write code in the `set` accessor to ensure that the values represented by a property are always valid.</span></span> <span data-ttu-id="0c3b0-135">Předpokládejme například, že `Person` jedno pravidlo pro třídu je, že název nemůže být prázdný nebo prázdné.</span><span class="sxs-lookup"><span data-stu-id="0c3b0-135">For example, suppose one rule for the `Person` class is that the name cannot be blank or white space.</span></span> <span data-ttu-id="0c3b0-136">Dalo byste napsat, že takto:</span><span class="sxs-lookup"><span data-stu-id="0c3b0-136">You would write that as follows:</span></span>

[!code-csharp[Validating property setters](../../samples/snippets/csharp/properties/Person.cs#6)]

<span data-ttu-id="0c3b0-137">Předchozí příklad lze zjednodušit pomocí`throw` výrazu jako součást ověření nastavení vlastností:</span><span class="sxs-lookup"><span data-stu-id="0c3b0-137">The preceding example can be simplified by using a`throw` expression as part of the property setter validation:</span></span>

[!code-csharp[Validating property setters](../../samples/snippets/csharp/properties/Person.cs#7)]

<span data-ttu-id="0c3b0-138">Výše uvedený příklad vynucuje pravidlo, že křestní jméno nesmí být prázdné nebo prázdné.</span><span class="sxs-lookup"><span data-stu-id="0c3b0-138">The example above enforces the rule that the first name must not be blank or white space.</span></span> <span data-ttu-id="0c3b0-139">Pokud vývojář zapíše</span><span class="sxs-lookup"><span data-stu-id="0c3b0-139">If a developer writes</span></span>

```csharp
hero.FirstName = "";
```

<span data-ttu-id="0c3b0-140">Toto přiřazení `ArgumentException`vyvolá .</span><span class="sxs-lookup"><span data-stu-id="0c3b0-140">That assignment throws an `ArgumentException`.</span></span> <span data-ttu-id="0c3b0-141">Vzhledem k tomu, že přistupující objekt sady vlastností musí mít prázdný návratový typ, ohlásíte chyby v přistupujícím objektu set vyvoláním výjimky.</span><span class="sxs-lookup"><span data-stu-id="0c3b0-141">Because a property set accessor must have a void return type, you report errors in the set accessor by throwing an exception.</span></span>

<span data-ttu-id="0c3b0-142">Můžete rozšířit stejnou syntaxi na vše potřebné ve vašem scénáři.</span><span class="sxs-lookup"><span data-stu-id="0c3b0-142">You can extend this same syntax to anything needed in your scenario.</span></span> <span data-ttu-id="0c3b0-143">Můžete zkontrolovat vztahy mezi různými vlastnostmi nebo ověřit proti jakékoli externí podmínky.</span><span class="sxs-lookup"><span data-stu-id="0c3b0-143">You can check the relationships between different properties, or validate against any external conditions.</span></span> <span data-ttu-id="0c3b0-144">Všechny platné příkazy Jazyka C# jsou platné v přistupujícím objektu vlastnosti.</span><span class="sxs-lookup"><span data-stu-id="0c3b0-144">Any valid C# statements are valid in a property accessor.</span></span>

### <a name="read-only"></a><span data-ttu-id="0c3b0-145">Jen pro čtení</span><span class="sxs-lookup"><span data-stu-id="0c3b0-145">Read-only</span></span>

<span data-ttu-id="0c3b0-146">Až do tohoto okamžiku jsou všechny definice vlastností, které jste viděli, vlastnosti pro čtení a zápis s veřejnými přistupujícími objekty.</span><span class="sxs-lookup"><span data-stu-id="0c3b0-146">Up to this point, all the property definitions you have seen are read/write properties with public accessors.</span></span> <span data-ttu-id="0c3b0-147">To není jediná platná přístupnost pro vlastnosti.</span><span class="sxs-lookup"><span data-stu-id="0c3b0-147">That's not the only valid accessibility for properties.</span></span>
<span data-ttu-id="0c3b0-148">Můžete vytvořit vlastnosti jen pro čtení nebo dát různé usnadnění přístupu k sadě a získat přístupové objekty.</span><span class="sxs-lookup"><span data-stu-id="0c3b0-148">You can create read-only properties, or give different accessibility to the set and get accessors.</span></span> <span data-ttu-id="0c3b0-149">Předpokládejme, `Person` že vaše třída by `FirstName` měla povolit pouze změnu hodnoty vlastnosti z jiných metod v této třídě.</span><span class="sxs-lookup"><span data-stu-id="0c3b0-149">Suppose that your `Person` class should only enable changing the value of the `FirstName` property from other methods in that class.</span></span> <span data-ttu-id="0c3b0-150">Můžete poskytnout přístupkový `private` nástroj `public`pro přístup k nastavení namísto:</span><span class="sxs-lookup"><span data-stu-id="0c3b0-150">You could give the set accessor `private` accessibility instead of `public`:</span></span>

[!code-csharp[Using a private setter for a publicly readonly property](../../samples/snippets/csharp/properties/Person.cs#8)]

<span data-ttu-id="0c3b0-151">Nyní `FirstName` vlastnost lze přistupovat z libovolného kódu, ale lze ji `Person` přiřadit pouze z jiného kódu ve třídě.</span><span class="sxs-lookup"><span data-stu-id="0c3b0-151">Now, the `FirstName` property can be accessed from any code, but it can only be assigned from other code in the `Person` class.</span></span>

<span data-ttu-id="0c3b0-152">Můžete přidat libovolný omezující modifikátor přístupu buď nastavit nebo získat přístupové(."Můžete přidat všechny omezující přístup modifikátor y set nebo získat přístupové(."Můžete přidat všechny omezující přístup modifikátor y set nebo získat přístupové(."Access</span><span class="sxs-lookup"><span data-stu-id="0c3b0-152">You can add any restrictive access modifier to either the set or get accessors.</span></span> <span data-ttu-id="0c3b0-153">Všechny modifikátory přístupu, které umístíte na jednotlivé přistupující objekt, musí být omezenější než modifikátor přístupu v definici vlastnosti.</span><span class="sxs-lookup"><span data-stu-id="0c3b0-153">Any access modifier you place on the individual accessor must be more limited than the access modifier on the property definition.</span></span> <span data-ttu-id="0c3b0-154">Výše uvedené je `FirstName` legální, `public`protože vlastnost je `private`, ale nastavit přistupující objekt je .</span><span class="sxs-lookup"><span data-stu-id="0c3b0-154">The above is legal because the `FirstName` property is `public`, but the set accessor is `private`.</span></span> <span data-ttu-id="0c3b0-155">Nelze deklarovat `private` vlastnost `public` s přistupujícím objektem.</span><span class="sxs-lookup"><span data-stu-id="0c3b0-155">You could not declare a `private` property with a `public` accessor.</span></span> <span data-ttu-id="0c3b0-156">Prohlášení o vlastnostech `protected`lze `internal` `protected internal`také deklarovat , , nebo dokonce `private`.</span><span class="sxs-lookup"><span data-stu-id="0c3b0-156">Property declarations can also be declared `protected`, `internal`, `protected internal`, or, even `private`.</span></span>

<span data-ttu-id="0c3b0-157">Je také legální umístit více omezující modifikátor na přistupujícího oru. `get`</span><span class="sxs-lookup"><span data-stu-id="0c3b0-157">It is also legal to place the more restrictive modifier on the `get` accessor.</span></span> <span data-ttu-id="0c3b0-158">Můžete mít například `public` vlastnost, ale `get` omezit přistupující objekt na `private`.</span><span class="sxs-lookup"><span data-stu-id="0c3b0-158">For example, you could have a `public` property, but restrict the `get` accessor to `private`.</span></span> <span data-ttu-id="0c3b0-159">Tento scénář se v praxi provádí jen zřídka.</span><span class="sxs-lookup"><span data-stu-id="0c3b0-159">That scenario is rarely done in practice.</span></span>

<span data-ttu-id="0c3b0-160">Můžete také omezit změny vlastnosti tak, aby ji lze nastavit pouze v konstruktoru nebo inicializátorvlastnosti.</span><span class="sxs-lookup"><span data-stu-id="0c3b0-160">You can also restrict modifications to a property so that it can only be set in a constructor or a property initializer.</span></span> <span data-ttu-id="0c3b0-161">Třídu `Person` můžete upravit takto:</span><span class="sxs-lookup"><span data-stu-id="0c3b0-161">You can modify the `Person` class so as follows:</span></span>

[!code-csharp[A readonly auto implemented property](../../samples/snippets/csharp/properties/Person.cs#9)]

<span data-ttu-id="0c3b0-162">Tato funkce se nejčastěji používá pro inicializaci kolekcí, které jsou vystaveny jako vlastnosti jen pro čtení:</span><span class="sxs-lookup"><span data-stu-id="0c3b0-162">This feature is most commonly used for initializing collections that are exposed as read-only properties:</span></span>

```csharp
public class Measurements
{
    public ICollection<DataPoint> points { get; } = new List<DataPoint>();
}
```

### <a name="computed-properties"></a><span data-ttu-id="0c3b0-163">Vypočítané vlastnosti</span><span class="sxs-lookup"><span data-stu-id="0c3b0-163">Computed properties</span></span>

<span data-ttu-id="0c3b0-164">Vlastnost nemusí jednoduše vrátit hodnotu členského pole.</span><span class="sxs-lookup"><span data-stu-id="0c3b0-164">A property does not need to simply return the value of a member field.</span></span> <span data-ttu-id="0c3b0-165">Můžete vytvořit vlastnosti, které vrátí vypočítanou hodnotu.</span><span class="sxs-lookup"><span data-stu-id="0c3b0-165">You can create properties that return a computed value.</span></span> <span data-ttu-id="0c3b0-166">Rozbalíme objekt `Person` a vrátíme celé jméno vypočítané zřetězením křestního jména a příjmení:</span><span class="sxs-lookup"><span data-stu-id="0c3b0-166">Let's expand the `Person` object to return the full name, computed by concatenating the first and last names:</span></span>

[!code-csharp[A computed property](../../samples/snippets/csharp/properties/Person.cs#10)]

<span data-ttu-id="0c3b0-167">Výše uvedený příklad používá funkci [interpolace řetězce](./language-reference/tokens/interpolated.md) k vytvoření formátovaného řetězce pro celý název.</span><span class="sxs-lookup"><span data-stu-id="0c3b0-167">The example above uses the [string interpolation](./language-reference/tokens/interpolated.md) feature to create the formatted string for the full name.</span></span>

<span data-ttu-id="0c3b0-168">Můžete také použít *člen s výrazem ,* který poskytuje stručnější způsob vytvoření `FullName` vypočítané vlastnosti:</span><span class="sxs-lookup"><span data-stu-id="0c3b0-168">You can also use an *expression-bodied member*, which provides a more succinct way to create the computed `FullName` property:</span></span>

[!code-csharp[A computed property using an expression bodied member](../../samples/snippets/csharp/properties/Person.cs#11)]

<span data-ttu-id="0c3b0-169">*Členové s výrazem* používají syntaxi *výrazu lambda* k definování metod, které obsahují jeden výraz.</span><span class="sxs-lookup"><span data-stu-id="0c3b0-169">*Expression-bodied members* use the *lambda expression* syntax to define methods that contain a single expression.</span></span> <span data-ttu-id="0c3b0-170">Zde tento výraz vrátí celé jméno objektu osoby.</span><span class="sxs-lookup"><span data-stu-id="0c3b0-170">Here, that expression returns the full name for the person object.</span></span>

### <a name="cached-evaluated-properties"></a><span data-ttu-id="0c3b0-171">Vlastnosti vyhodnocované v mezipaměti</span><span class="sxs-lookup"><span data-stu-id="0c3b0-171">Cached evaluated properties</span></span>

<span data-ttu-id="0c3b0-172">Můžete kombinovat koncept vypočítané vlastnosti s úložištěm a vytvořit *vlastnost vyhodnocovanou v mezipaměti*.</span><span class="sxs-lookup"><span data-stu-id="0c3b0-172">You can mix the concept of a computed property with storage and create a *cached evaluated property*.</span></span>  <span data-ttu-id="0c3b0-173">Můžete například aktualizovat `FullName` vlastnost tak, aby formátování řetězce proběhlo pouze při prvním přístupu:</span><span class="sxs-lookup"><span data-stu-id="0c3b0-173">For example, you could update the `FullName` property so that the string formatting only happened the first time it was accessed:</span></span>

[!code-csharp[Caching the value of a computed property](../../samples/snippets/csharp/properties/Person.cs#12)]

<span data-ttu-id="0c3b0-174">Výše uvedený kód obsahuje chybu ačkoli.</span><span class="sxs-lookup"><span data-stu-id="0c3b0-174">The above code contains a bug though.</span></span> <span data-ttu-id="0c3b0-175">Pokud kód aktualizuje hodnotu `FirstName` `LastName` vlastnosti nebo, `fullName` je dříve vyhodnocené pole neplatné.</span><span class="sxs-lookup"><span data-stu-id="0c3b0-175">If code updates the value of either the `FirstName` or `LastName` property, the previously evaluated `fullName` field is invalid.</span></span> <span data-ttu-id="0c3b0-176">Můžete upravit `set` přístupové objekty vlastnosti `FirstName` a `LastName` tak, aby `fullName` se pole znovu vypočítala:</span><span class="sxs-lookup"><span data-stu-id="0c3b0-176">You modify the `set` accessors of the `FirstName` and `LastName` property so that the `fullName` field is calculated again:</span></span>

[!code-csharp[Invalidating the cache correctly](../../samples/snippets/csharp/properties/Person.cs#13)]

<span data-ttu-id="0c3b0-177">Tato konečná verze `FullName` vyhodnotí vlastnost pouze v případě potřeby.</span><span class="sxs-lookup"><span data-stu-id="0c3b0-177">This final version evaluates the `FullName` property only when needed.</span></span>
<span data-ttu-id="0c3b0-178">Pokud je dříve vypočtená verze platná, použije se.</span><span class="sxs-lookup"><span data-stu-id="0c3b0-178">If the previously calculated version is valid, it's used.</span></span> <span data-ttu-id="0c3b0-179">Pokud jiná změna stavu zruší platnost dříve vypočtené verze, bude přepočítána.</span><span class="sxs-lookup"><span data-stu-id="0c3b0-179">If another state change invalidates the previously calculated version, it will be recalculated.</span></span> <span data-ttu-id="0c3b0-180">Vývojáři, kteří používají tuto třídu, nepotřebují znát podrobnosti implementace.</span><span class="sxs-lookup"><span data-stu-id="0c3b0-180">Developers that use this class do not need to know the details of the implementation.</span></span> <span data-ttu-id="0c3b0-181">Žádná z těchto vnitřních změn nemá vliv na použití objektu Person.</span><span class="sxs-lookup"><span data-stu-id="0c3b0-181">None of these internal changes affect the use of the Person object.</span></span> <span data-ttu-id="0c3b0-182">To je hlavní důvod pro použití Vlastnosti vystavit datové členy objektu.</span><span class="sxs-lookup"><span data-stu-id="0c3b0-182">That's the key reason for using Properties to expose data members of an object.</span></span>

### <a name="attaching-attributes-to-auto-implemented-properties"></a><span data-ttu-id="0c3b0-183">Připojení atributů k automaticky implementovaným vlastnostem</span><span class="sxs-lookup"><span data-stu-id="0c3b0-183">Attaching attributes to auto-implemented properties</span></span>

<span data-ttu-id="0c3b0-184">Počínaje C# 7.3, atributy pole lze připojit k kompilátoru generované záložní pole v automaticky implementované vlastnosti.</span><span class="sxs-lookup"><span data-stu-id="0c3b0-184">Beginning with C# 7.3, field attributes can be attached to the compiler generated backing field in auto-implemented properties.</span></span> <span data-ttu-id="0c3b0-185">Zvažte například revizi `Person` třídy, která přidá `Id` jedinečnou celou vlastnost.</span><span class="sxs-lookup"><span data-stu-id="0c3b0-185">For example, consider a revision to the `Person` class that adds a unique integer `Id` property.</span></span>
<span data-ttu-id="0c3b0-186">Vlastnost napíšete`Id` pomocí automaticky implementované vlastnosti, ale váš `Id` návrh nevolá pro zachování vlastnosti.</span><span class="sxs-lookup"><span data-stu-id="0c3b0-186">You write the`Id` property using an auto-implemented property, but your design does not call for persisting the `Id` property.</span></span> <span data-ttu-id="0c3b0-187">Lze <xref:System.NonSerializedAttribute> připojit pouze k polím, nikoli k vlastnostem.</span><span class="sxs-lookup"><span data-stu-id="0c3b0-187">The <xref:System.NonSerializedAttribute> can only be attached to fields, not properties.</span></span> <span data-ttu-id="0c3b0-188">K záložnímu <xref:System.NonSerializedAttribute> poli vlastnosti `Id` můžete připojit `field:` pomocí specifikátoru atributu, jak je znázorněno v následujícím příkladu:</span><span class="sxs-lookup"><span data-stu-id="0c3b0-188">You can attach the <xref:System.NonSerializedAttribute> to the backing field for the `Id` property by using the `field:` specifier on the attribute, as shown in the following example:</span></span>

[!code-csharp[Attaching attributes to a backing field](../../samples/snippets/csharp/properties/Person.cs#14)]

<span data-ttu-id="0c3b0-189">Tato technika funguje pro všechny atributy, které připojíte k záložnímu poli v automaticky implementované vlastnosti.</span><span class="sxs-lookup"><span data-stu-id="0c3b0-189">This technique works for any attribute you attach to the backing field on the auto-implemented property.</span></span>

### <a name="implementing-inotifypropertychanged"></a><span data-ttu-id="0c3b0-190">Implementace vlastnosti INotifyPropertyZměněn</span><span class="sxs-lookup"><span data-stu-id="0c3b0-190">Implementing INotifyPropertyChanged</span></span>

<span data-ttu-id="0c3b0-191">Konečný scénář, kde je třeba napsat kód v přistupujícím objektu vlastnosti je podporovat <xref:System.ComponentModel.INotifyPropertyChanged> rozhraní používané k upozornění klientů datové vazby, že hodnota se změnila.</span><span class="sxs-lookup"><span data-stu-id="0c3b0-191">A final scenario where you need to write code in a property accessor is to support the <xref:System.ComponentModel.INotifyPropertyChanged> interface used to notify data binding clients that a value has changed.</span></span> <span data-ttu-id="0c3b0-192">Když se změní hodnota vlastnosti, <xref:System.ComponentModel.INotifyPropertyChanged.PropertyChanged?displayProperty=nameWithType> objekt vyvolá událost k označení změny.</span><span class="sxs-lookup"><span data-stu-id="0c3b0-192">When the value of a property changes, the object raises the <xref:System.ComponentModel.INotifyPropertyChanged.PropertyChanged?displayProperty=nameWithType> event to indicate the change.</span></span> <span data-ttu-id="0c3b0-193">Knihovny datových vazeb zase aktualizují prvky zobrazení na základě této změny.</span><span class="sxs-lookup"><span data-stu-id="0c3b0-193">The data binding libraries, in turn, update display elements based on that change.</span></span> <span data-ttu-id="0c3b0-194">Níže uvedený kód ukazuje, `INotifyPropertyChanged` jak `FirstName` byste implementovat pro vlastnost této třídy osoby.</span><span class="sxs-lookup"><span data-stu-id="0c3b0-194">The code below shows how you would implement `INotifyPropertyChanged` for the `FirstName` property of this person class.</span></span>

[!code-csharp[invalidating the cache correctly](../../samples/snippets/csharp/properties/Person.cs#15)]

<span data-ttu-id="0c3b0-195">Operátor `?.` se nazývá *operátor null conditional*.</span><span class="sxs-lookup"><span data-stu-id="0c3b0-195">The `?.` operator is called the *null conditional operator*.</span></span> <span data-ttu-id="0c3b0-196">Zkontroluje odkaz null před vyhodnocením pravé straně operátoru.</span><span class="sxs-lookup"><span data-stu-id="0c3b0-196">It checks for a null reference before evaluating the right side of the operator.</span></span> <span data-ttu-id="0c3b0-197">Konečným výsledkem je, že pokud neexistují `PropertyChanged` žádné předplatitelé události, kód pro zvýšení události se nespustí.</span><span class="sxs-lookup"><span data-stu-id="0c3b0-197">The end result is that if there are no subscribers to the `PropertyChanged` event, the code to raise the event doesn't execute.</span></span> <span data-ttu-id="0c3b0-198">V tom `NullReferenceException` kufříku by to bez kontroly.</span><span class="sxs-lookup"><span data-stu-id="0c3b0-198">It would throw a `NullReferenceException` without this check in that case.</span></span> <span data-ttu-id="0c3b0-199">Další informace naleznete [`events`](events-overview.md)v tématu .</span><span class="sxs-lookup"><span data-stu-id="0c3b0-199">For more information, see [`events`](events-overview.md).</span></span> <span data-ttu-id="0c3b0-200">Tento příklad také `nameof` používá nový operátor k převodu ze symbolu názvu vlastnosti na jeho textovou reprezentaci.</span><span class="sxs-lookup"><span data-stu-id="0c3b0-200">This example also uses the new `nameof` operator to convert from the property name symbol to its text representation.</span></span>
<span data-ttu-id="0c3b0-201">Použití `nameof` může snížit chyby, kde jste nesprávně zadali název vlastnosti.</span><span class="sxs-lookup"><span data-stu-id="0c3b0-201">Using `nameof` can reduce errors where you have mistyped the name of the property.</span></span>

<span data-ttu-id="0c3b0-202">Opět platí, <xref:System.ComponentModel.INotifyPropertyChanged> že implementace je příkladem případu, kde můžete napsat kód v přístupových objektech pro podporu scénáře, které potřebujete.</span><span class="sxs-lookup"><span data-stu-id="0c3b0-202">Again, implementing <xref:System.ComponentModel.INotifyPropertyChanged> is an example of a case where you can write code in your accessors to support the scenarios you need.</span></span>

## <a name="summing-up"></a><span data-ttu-id="0c3b0-203">Sečtením</span><span class="sxs-lookup"><span data-stu-id="0c3b0-203">Summing up</span></span>

<span data-ttu-id="0c3b0-204">Vlastnosti jsou formou inteligentních polí ve třídě nebo objektu.</span><span class="sxs-lookup"><span data-stu-id="0c3b0-204">Properties are a form of smart fields in a class or object.</span></span> <span data-ttu-id="0c3b0-205">Mimo objekt vypadají jako pole v objektu.</span><span class="sxs-lookup"><span data-stu-id="0c3b0-205">From outside the object, they appear like fields in the object.</span></span> <span data-ttu-id="0c3b0-206">Vlastnosti však mohou být implementovány pomocí úplné palety c# funkce.</span><span class="sxs-lookup"><span data-stu-id="0c3b0-206">However, properties can be implemented using the full palette of C# functionality.</span></span>
<span data-ttu-id="0c3b0-207">Můžete poskytnout ověření, různé usnadnění přístupu, opožděné vyhodnocení nebo všechny požadavky, které vaše scénáře potřebují.</span><span class="sxs-lookup"><span data-stu-id="0c3b0-207">You can provide validation, different accessibility, lazy evaluation, or any requirements your scenarios need.</span></span>
