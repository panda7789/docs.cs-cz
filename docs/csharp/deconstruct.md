---
title: Dekonstrukce řazených kolekcí členů a dalších typů
description: Naučte se, jak dekonstruovat řazené kolekce členů a jiné typy.
ms.technology: csharp-fundamentals
ms.date: 11/23/2017
ms.assetid: 0b0c4b0f-4a47-4f66-9b8e-f5c63b195960
ms.openlocfilehash: 8defd75a7cdff3490d2b0a6097ec2a898576e113
ms.sourcegitcommit: cb27c01a8b0b4630148374638aff4e2221f90b22
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 07/09/2020
ms.locfileid: "86174163"
---
# <a name="deconstructing-tuples-and-other-types"></a><span data-ttu-id="b8bb2-103">Dekonstrukce řazených kolekcí členů a dalších typů</span><span class="sxs-lookup"><span data-stu-id="b8bb2-103">Deconstructing tuples and other types</span></span>

<span data-ttu-id="b8bb2-104">Řazená kolekce členů poskytuje jednoduchý způsob, jak načíst více hodnot z volání metody.</span><span class="sxs-lookup"><span data-stu-id="b8bb2-104">A tuple provides a lightweight way to retrieve multiple values from a method call.</span></span> <span data-ttu-id="b8bb2-105">Po načtení řazené kolekce členů je ale nutné zpracovat jeho jednotlivé prvky.</span><span class="sxs-lookup"><span data-stu-id="b8bb2-105">But once you retrieve the tuple, you have to handle its individual elements.</span></span> <span data-ttu-id="b8bb2-106">Provedení tohoto postupu na základě prvku je náročné, jak ukazuje následující příklad.</span><span class="sxs-lookup"><span data-stu-id="b8bb2-106">Doing this on an element-by-element basis is cumbersome, as the following example shows.</span></span> <span data-ttu-id="b8bb2-107">`QueryCityData`Metoda vrací tři řazené kolekce členů a každý z jejích elementů je přiřazena proměnné v samostatné operaci.</span><span class="sxs-lookup"><span data-stu-id="b8bb2-107">The `QueryCityData` method returns a 3-tuple, and each of its elements is assigned to a variable in a separate operation.</span></span>

[!code-csharp[WithoutDeconstruction](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-tuple1.cs)]

<span data-ttu-id="b8bb2-108">Načítání více hodnot polí a vlastností z objektu může být stejně náročné: je nutné přiřadit hodnotu pole nebo vlastnosti proměnné na členě v rámci člena.</span><span class="sxs-lookup"><span data-stu-id="b8bb2-108">Retrieving multiple field and property values from an object can be equally cumbersome: you have to assign a field or property value to a variable on a member-by-member basis.</span></span>

<span data-ttu-id="b8bb2-109">Počínaje jazykem C# 7,0 můžete načíst více prvků z řazené kolekce členů nebo načíst více polí, vlastností a vypočítaných hodnot z objektu v rámci jediné operace *dekonstrukce* .</span><span class="sxs-lookup"><span data-stu-id="b8bb2-109">Starting with C# 7.0, you can retrieve multiple elements from a tuple or retrieve multiple field, property, and computed values from an object in a single *deconstruct* operation.</span></span> <span data-ttu-id="b8bb2-110">Při dekonstrukci řazené kolekce členů přiřadíte jeho prvky jednotlivým proměnným.</span><span class="sxs-lookup"><span data-stu-id="b8bb2-110">When you deconstruct a tuple, you assign its elements to individual variables.</span></span> <span data-ttu-id="b8bb2-111">Při dekonstrukci objektu přiřadíte vybrané hodnoty jednotlivým proměnným.</span><span class="sxs-lookup"><span data-stu-id="b8bb2-111">When you deconstruct an object, you assign selected values to individual variables.</span></span>

## <a name="deconstructing-a-tuple"></a><span data-ttu-id="b8bb2-112">Dekonstrukce řazené kolekce členů</span><span class="sxs-lookup"><span data-stu-id="b8bb2-112">Deconstructing a tuple</span></span>

<span data-ttu-id="b8bb2-113">Funkce C# nabízí integrovanou podporu pro dekonstrukci řazených kolekcí členů, která umožňuje odbalit všechny položky v řazené kolekci členů v rámci jedné operace.</span><span class="sxs-lookup"><span data-stu-id="b8bb2-113">C# features built-in support for deconstructing tuples, which lets you unpackage all the items in a tuple in a single operation.</span></span> <span data-ttu-id="b8bb2-114">Obecná syntaxe pro dekonstrukci řazené kolekce členů je podobná syntaxi pro definování jednoho: můžete uzavřít proměnné, ke kterým je každý element přiřazen v závorkách na levé straně příkazu přiřazení.</span><span class="sxs-lookup"><span data-stu-id="b8bb2-114">The general syntax for deconstructing a tuple is similar to the syntax for defining one: you enclose the variables to which each element is to be assigned in parentheses in the left side of an assignment statement.</span></span> <span data-ttu-id="b8bb2-115">Například následující příkaz přiřadí prvky množiny o 4-tice ke čtyřem samostatným proměnným:</span><span class="sxs-lookup"><span data-stu-id="b8bb2-115">For example, the following statement assigns the elements of a 4-tuple to four separate variables:</span></span>

```csharp
var (name, address, city, zip) = contact.GetAddressInfo();
```

<span data-ttu-id="b8bb2-116">Existují tři způsoby, jak vytvořit řazenou kolekci členů:</span><span class="sxs-lookup"><span data-stu-id="b8bb2-116">There are three ways to deconstruct a tuple:</span></span>

- <span data-ttu-id="b8bb2-117">Můžete explicitně deklarovat typ každého pole uvnitř závorek.</span><span class="sxs-lookup"><span data-stu-id="b8bb2-117">You can explicitly declare the type of each field inside parentheses.</span></span> <span data-ttu-id="b8bb2-118">Následující příklad používá tento přístup k dekonstrukci 3 – řazené kolekce členů vráceného `QueryCityData` metodou.</span><span class="sxs-lookup"><span data-stu-id="b8bb2-118">The following example uses this approach to deconstruct the 3-tuple returned by the `QueryCityData` method.</span></span>

    [!code-csharp[Deconstruction-Explicit](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-tuple2.cs#1)]

- <span data-ttu-id="b8bb2-119">Klíčové slovo lze použít `var` tak, aby C# odvodí typ každé proměnné.</span><span class="sxs-lookup"><span data-stu-id="b8bb2-119">You can use the `var` keyword so that C# infers the type of each variable.</span></span> <span data-ttu-id="b8bb2-120">`var`Klíčové slovo umístíte mimo závorky.</span><span class="sxs-lookup"><span data-stu-id="b8bb2-120">You place the `var` keyword outside of the parentheses.</span></span> <span data-ttu-id="b8bb2-121">Následující příklad používá odvození typu při dekonstrukci 3 – řazené kolekce členů vráceného `QueryCityData` metodou.</span><span class="sxs-lookup"><span data-stu-id="b8bb2-121">The following example uses type inference when deconstructing the 3-tuple returned by the `QueryCityData` method.</span></span>

    [!code-csharp[Deconstruction-Infer](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-tuple3.cs#1)]

    <span data-ttu-id="b8bb2-122">Klíčové slovo lze použít také `var` jednotlivě spolu se všemi nebo všemi deklaracemi proměnných uvnitř závorek.</span><span class="sxs-lookup"><span data-stu-id="b8bb2-122">You can also use the `var` keyword individually with any or all of the variable declarations inside the parentheses.</span></span>

    [!code-csharp[Deconstruction-Infer-Some](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-tuple4.cs#1)]

    <span data-ttu-id="b8bb2-123">To je náročné a nedoporučuje se.</span><span class="sxs-lookup"><span data-stu-id="b8bb2-123">This is cumbersome and is not recommended.</span></span>

- <span data-ttu-id="b8bb2-124">Nakonec můžete vytvořit řazenou kolekci členů do proměnných, které již byly deklarovány.</span><span class="sxs-lookup"><span data-stu-id="b8bb2-124">Lastly, you may deconstruct the tuple into variables that have already been declared.</span></span>

    [!code-csharp[Deconstruction-Declared](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-tuple5.cs#1)]

<span data-ttu-id="b8bb2-125">Všimněte si, že nemůžete zadat konkrétní typ mimo závorky, a to ani v případě, že každé pole v řazené kolekci členů má stejný typ.</span><span class="sxs-lookup"><span data-stu-id="b8bb2-125">Note that you cannot specify a specific type outside the parentheses even if every field in the tuple has the same type.</span></span> <span data-ttu-id="b8bb2-126">Tím dojde k chybě kompilátoru CS8136, "Dekonstrukce ' var (...) Form nepovoluje konkrétní typ pro ' var '.</span><span class="sxs-lookup"><span data-stu-id="b8bb2-126">This generates compiler error CS8136, "Deconstruction 'var (...)' form disallows a specific type for 'var'.".</span></span>

<span data-ttu-id="b8bb2-127">Všimněte si, že musíte také přiřadit každý prvek řazené kolekce členů k proměnné.</span><span class="sxs-lookup"><span data-stu-id="b8bb2-127">Note that you must also assign each element of the tuple to a variable.</span></span> <span data-ttu-id="b8bb2-128">Vynecháte-li nějaké prvky, kompilátor vygeneruje chybu CS8132, "nelze dekonstruovat řazenou kolekci členů" x "elementů do proměnných" y ".</span><span class="sxs-lookup"><span data-stu-id="b8bb2-128">If you omit any elements, the compiler generates error CS8132, "Cannot deconstruct a tuple of 'x' elements into 'y' variables."</span></span>

<span data-ttu-id="b8bb2-129">Všimněte si, že nemůžete kombinovat deklarace a přiřazení k existujícím proměnným na levé straně dekonstrukce.</span><span class="sxs-lookup"><span data-stu-id="b8bb2-129">Note that you cannot mix declarations and assignments to existing variables on the left-hand side of a deconstruction.</span></span> <span data-ttu-id="b8bb2-130">Kompilátor generuje chybu CS8184, "Dekonstrukce nemůže kombinovat deklarace a výrazy na levé straně."</span><span class="sxs-lookup"><span data-stu-id="b8bb2-130">The compiler generates error CS8184, "a deconstruction cannot mix declarations and expressions on the left-hand-side."</span></span> <span data-ttu-id="b8bb2-131">Když členové obsahují nově deklarované a existující proměnné.</span><span class="sxs-lookup"><span data-stu-id="b8bb2-131">when the members include newly declared and existing variables.</span></span>

## <a name="deconstructing-tuple-elements-with-discards"></a><span data-ttu-id="b8bb2-132">Rekonstrukce elementů řazené kolekce členů s výměty</span><span class="sxs-lookup"><span data-stu-id="b8bb2-132">Deconstructing tuple elements with discards</span></span>

<span data-ttu-id="b8bb2-133">Při dekonstrukci řazené kolekce členů se často zajímá hodnoty jenom některých prvků.</span><span class="sxs-lookup"><span data-stu-id="b8bb2-133">Often when deconstructing a tuple, you're interested in the values of only some elements.</span></span> <span data-ttu-id="b8bb2-134">Počínaje jazykem C# 7,0 můžete využít výhod podpory jazyka C# pro *zahození*, což jsou proměnné pouze pro zápis, jejichž hodnoty jste se rozhodli ignorovat.</span><span class="sxs-lookup"><span data-stu-id="b8bb2-134">Starting with C# 7.0, you can take advantage of C#'s support for *discards*, which are write-only variables whose values you've chosen to ignore.</span></span> <span data-ttu-id="b8bb2-135">Zahození je určeno znakem podtržítka (" \_ ") v přiřazení.</span><span class="sxs-lookup"><span data-stu-id="b8bb2-135">A discard is designated by an underscore character ("\_") in an assignment.</span></span> <span data-ttu-id="b8bb2-136">Můžete zahodit libovolný počet hodnot, které chcete. Všechny jsou reprezentovány jediným zahozením, `_` .</span><span class="sxs-lookup"><span data-stu-id="b8bb2-136">You can discard as many values as you like; all are represented by the single discard, `_`.</span></span>

<span data-ttu-id="b8bb2-137">Následující příklad znázorňuje použití řazených kolekcí členů s výměty.</span><span class="sxs-lookup"><span data-stu-id="b8bb2-137">The following example illustrates the use of tuples with discards.</span></span> <span data-ttu-id="b8bb2-138">`QueryCityDataForYears`Metoda vrátí 6 – řazené kolekce členů s názvem města, jeho oblastí, rokem, populacem města pro daný rok, druhým rokem a plněním města pro daný druhý rok.</span><span class="sxs-lookup"><span data-stu-id="b8bb2-138">The `QueryCityDataForYears` method returns a 6-tuple with the name of a city, its area, a year, the city's population for that year, a second year, and the city's population for that second year.</span></span> <span data-ttu-id="b8bb2-139">V tomto příkladu se zobrazuje změna populace mezi těmito dvěma roky.</span><span class="sxs-lookup"><span data-stu-id="b8bb2-139">The example shows the change in population between those two years.</span></span> <span data-ttu-id="b8bb2-140">Z dat, která jsou k dispozici v rámci řazené kolekce členů, jsme nevěděli s oblastí město a znali jsme název města a dvě datum v době návrhu.</span><span class="sxs-lookup"><span data-stu-id="b8bb2-140">Of the data available from the tuple, we're unconcerned with the city area, and we know the city name and the two dates at design-time.</span></span> <span data-ttu-id="b8bb2-141">V důsledku toho se zajímá jenom o dvě hodnoty populace uložené v řazené kolekci členů a můžou své zbývající hodnoty zpracovat jako zahozené.</span><span class="sxs-lookup"><span data-stu-id="b8bb2-141">As a result, we're only interested in the two population values stored in the tuple, and can handle its remaining values as discards.</span></span>  

[!code-csharp[Tuple-discard](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/discard-tuple1.cs)]

## <a name="deconstructing-user-defined-types"></a><span data-ttu-id="b8bb2-142">Dekonstrukce uživatelem definovaných typů</span><span class="sxs-lookup"><span data-stu-id="b8bb2-142">Deconstructing user-defined types</span></span>

<span data-ttu-id="b8bb2-143">Jazyk C# nenabízí integrovanou podporu pro dekonstrukci typů, které nejsou řazené kolekce členů.</span><span class="sxs-lookup"><span data-stu-id="b8bb2-143">C# does not offer built-in support for deconstructing non-tuple types.</span></span> <span data-ttu-id="b8bb2-144">Nicméně jako autor třídy, struktury nebo rozhraní můžete dovolit, aby byly instance typu dekonstruovány implementací jedné nebo více `Deconstruct` metod.</span><span class="sxs-lookup"><span data-stu-id="b8bb2-144">However, as the author of a class, a struct, or an interface, you can allow instances of the type to be deconstructed by implementing one or more `Deconstruct` methods.</span></span> <span data-ttu-id="b8bb2-145">Metoda vrací typ void a každá hodnota, která má být dekonstruována, je v signatuře metody označena [výstupním](language-reference/keywords/out-parameter-modifier.md) parametrem.</span><span class="sxs-lookup"><span data-stu-id="b8bb2-145">The method returns void, and each value to be deconstructed is indicated by an [out](language-reference/keywords/out-parameter-modifier.md) parameter in the method signature.</span></span> <span data-ttu-id="b8bb2-146">Například následující `Deconstruct` Metoda `Person` třídy vrátí první, střední a poslední název:</span><span class="sxs-lookup"><span data-stu-id="b8bb2-146">For example, the following `Deconstruct` method of a `Person` class returns the first, middle, and last name:</span></span>

[!code-csharp[Class-deconstruct](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-class1.cs#1)]

<span data-ttu-id="b8bb2-147">Pak můžete dekonstruovat instanci `Person` třídy s názvem `p` s přiřazením, jako je následující:</span><span class="sxs-lookup"><span data-stu-id="b8bb2-147">You can then deconstruct an instance of the `Person` class named `p` with an assignment like the following:</span></span>

[!code-csharp[Class-deconstruct](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-class1.cs#2)]

<span data-ttu-id="b8bb2-148">Následující příklad přetěžuje `Deconstruct` metodu pro vrácení různých kombinací vlastností `Person` objektu.</span><span class="sxs-lookup"><span data-stu-id="b8bb2-148">The following example overloads the `Deconstruct` method to return various combinations of properties of a `Person` object.</span></span> <span data-ttu-id="b8bb2-149">Jednotlivá přetížení vrátí:</span><span class="sxs-lookup"><span data-stu-id="b8bb2-149">Individual overloads return:</span></span>

- <span data-ttu-id="b8bb2-150">Křestní jméno a příjmení.</span><span class="sxs-lookup"><span data-stu-id="b8bb2-150">A first and last name.</span></span>
- <span data-ttu-id="b8bb2-151">První, poslední a prostřední jméno.</span><span class="sxs-lookup"><span data-stu-id="b8bb2-151">A first, last, and middle name.</span></span>
- <span data-ttu-id="b8bb2-152">Křestní jméno, příjmení, název města a název stavu.</span><span class="sxs-lookup"><span data-stu-id="b8bb2-152">A first name, a last name, a city name, and a state name.</span></span>

[!code-csharp[Class-deconstruct](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-class2.cs)]

<span data-ttu-id="b8bb2-153">Vzhledem k tomu, že `Deconstruct` metodu lze přetížit tak, aby odrážela skupiny dat, které jsou běžně extrahovány z objektu, měli byste pečlivě definovat `Deconstruct` metody s signaturami, které jsou charakteristické a jednoznačné.</span><span class="sxs-lookup"><span data-stu-id="b8bb2-153">Because you can overload the `Deconstruct` method to reflect groups of data that are commonly extracted from an object, you should be careful to define `Deconstruct` methods with signatures that are distinctive and unambiguous.</span></span> <span data-ttu-id="b8bb2-154">Více `Deconstruct` metod, které mají stejný počet `out` parametrů nebo stejný počet a typ `out` parametrů v jiném pořadí, může způsobit nejasnost.</span><span class="sxs-lookup"><span data-stu-id="b8bb2-154">Multiple `Deconstruct` methods that have the same number of `out` parameters or the same number and type of `out` parameters in a different order can cause confusion.</span></span>

<span data-ttu-id="b8bb2-155">Přetížená `Deconstruct` metoda v následujícím příkladu znázorňuje jeden možný zdroj nejasností.</span><span class="sxs-lookup"><span data-stu-id="b8bb2-155">The overloaded `Deconstruct` method in the following example illustrates one possible source of confusion.</span></span> <span data-ttu-id="b8bb2-156">První přetížení vrátí křestní jméno, prostřední jméno, příjmení a stáří `Person` objektu v tomto pořadí.</span><span class="sxs-lookup"><span data-stu-id="b8bb2-156">The first overload returns the first name, middle name, last name, and age of a `Person` object, in that order.</span></span> <span data-ttu-id="b8bb2-157">Druhé přetížení vrátí pouze informace o názvu společně s ročním příjmem, ale první, prostřední a příjmení jsou v jiném pořadí.</span><span class="sxs-lookup"><span data-stu-id="b8bb2-157">The second overload returns name information only along with annual income, but the first, middle, and last name are in a different order.</span></span> <span data-ttu-id="b8bb2-158">Díky tomu je snadné Zaměňujte pořadí argumentů při dekonstrukci `Person` instance.</span><span class="sxs-lookup"><span data-stu-id="b8bb2-158">This makes it easy to confuse the order of arguments when deconstructing a `Person` instance.</span></span>

[!code-csharp[Deconstruct-ambiguity](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-ambiguous.cs)]

## <a name="deconstructing-a-user-defined-type-with-discards"></a><span data-ttu-id="b8bb2-159">Dekonstrukce uživatelsky definovaného typu s zahozením</span><span class="sxs-lookup"><span data-stu-id="b8bb2-159">Deconstructing a user-defined type with discards</span></span>

<span data-ttu-id="b8bb2-160">Stejně jako v případě [řazených kolekcí členů](#deconstructing-tuple-elements-with-discards)můžete použít zahození pro ignorování vybraných položek vrácených `Deconstruct` metodou.</span><span class="sxs-lookup"><span data-stu-id="b8bb2-160">Just as you do with [tuples](#deconstructing-tuple-elements-with-discards), you can use discards to ignore selected items returned by a `Deconstruct` method.</span></span> <span data-ttu-id="b8bb2-161">Každé zrušení je definováno proměnnou s názvem " \_ " a jedinou operací dekonstrukce může zahrnovat více zahození.</span><span class="sxs-lookup"><span data-stu-id="b8bb2-161">Each discard is defined by a variable named "\_", and a single deconstruction operation can include multiple discards.</span></span>

<span data-ttu-id="b8bb2-162">Následující příklad dekonstruuje `Person` objekt do čtyř řetězců (křestní jméno a příjmení, město a stav), ale zahodí příjmení a stav.</span><span class="sxs-lookup"><span data-stu-id="b8bb2-162">The following example deconstructs a `Person` object into four strings (the first and last names, the city, and the state) but discards the last name and the state.</span></span>

[!code-csharp[Class-discard](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/class-discard1.cs#1)]

## <a name="deconstructing-a-user-defined-type-with-an-extension-method"></a><span data-ttu-id="b8bb2-163">Dekonstrukce uživatelsky definovaného typu s metodou rozšíření</span><span class="sxs-lookup"><span data-stu-id="b8bb2-163">Deconstructing a user-defined type with an extension method</span></span>

<span data-ttu-id="b8bb2-164">Pokud jste nevytvořili třídu, strukturu nebo rozhraní, můžete stále dekonstruovat objekty tohoto typu implementací jedné nebo více `Deconstruct` [rozšiřujících metod](programming-guide/classes-and-structs/extension-methods.md) , které vrátí hodnoty, které vás zajímají.</span><span class="sxs-lookup"><span data-stu-id="b8bb2-164">If you didn't author a class, struct, or interface, you can still deconstruct objects of that type by implementing one or more `Deconstruct` [extension methods](programming-guide/classes-and-structs/extension-methods.md) to return the values in which you're interested.</span></span>

<span data-ttu-id="b8bb2-165">Následující příklad definuje dvě `Deconstruct` metody rozšíření pro <xref:System.Reflection.PropertyInfo?displayProperty=nameWithType> třídu.</span><span class="sxs-lookup"><span data-stu-id="b8bb2-165">The following example defines two `Deconstruct` extension methods for the <xref:System.Reflection.PropertyInfo?displayProperty=nameWithType> class.</span></span> <span data-ttu-id="b8bb2-166">První vrátí sadu hodnot, které určují vlastnosti vlastnosti, včetně jejího typu, bez ohledu na to, zda je statická nebo instance, zda je pouze pro čtení a zda je indexována.</span><span class="sxs-lookup"><span data-stu-id="b8bb2-166">The first returns a set of values that indicate the characteristics of the property, including its type, whether it's static or instance, whether it's read-only, and whether it's indexed.</span></span> <span data-ttu-id="b8bb2-167">Druhý označuje přístupnost vlastnosti.</span><span class="sxs-lookup"><span data-stu-id="b8bb2-167">The second indicates the property's accessibility.</span></span> <span data-ttu-id="b8bb2-168">Vzhledem k tomu, že přístupnost přístupových objektů Get a set se může lišit, logické hodnoty označují, zda má vlastnost samostatné přístupové objekty get a set, a pokud má, zda mají stejné přístupnost.</span><span class="sxs-lookup"><span data-stu-id="b8bb2-168">Because the accessibility of get and set accessors can differ, Boolean values indicate whether the property has separate get and set accessors and, if it does, whether they have the same accessibility.</span></span> <span data-ttu-id="b8bb2-169">Je-li k dispozici pouze jeden přistupující objekt, nebo přistupující objekt get i Set musí mít stejné přístupnost, `access` Proměnná označuje přístupnost vlastnosti jako celku.</span><span class="sxs-lookup"><span data-stu-id="b8bb2-169">If there is only one accessor or both the get and the set accessor have the same accessibility, the `access` variable indicates the accessibility of the property as a whole.</span></span> <span data-ttu-id="b8bb2-170">V opačném případě přístupnost přístupových objektů Get a set jsou označeny `getAccess` `setAccess` proměnnými a.</span><span class="sxs-lookup"><span data-stu-id="b8bb2-170">Otherwise, the accessibility of the get and set accessors are indicated by the `getAccess` and `setAccess` variables.</span></span>

[!code-csharp[Extension-deconstruct](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-extension1.cs)]

## <a name="see-also"></a><span data-ttu-id="b8bb2-171">Viz také</span><span class="sxs-lookup"><span data-stu-id="b8bb2-171">See also</span></span>

- [<span data-ttu-id="b8bb2-172">Zahození</span><span class="sxs-lookup"><span data-stu-id="b8bb2-172">Discards</span></span>](discards.md)
- [<span data-ttu-id="b8bb2-173">Typy řazené kolekce členů</span><span class="sxs-lookup"><span data-stu-id="b8bb2-173">Tuple types</span></span>](language-reference/builtin-types/value-tuples.md)
