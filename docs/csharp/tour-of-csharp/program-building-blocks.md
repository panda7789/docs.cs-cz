---
title: Stavební kameny programů v jazyce C# "
description: Přečtěte si o členech, výrazech a příkazech jazyka C#. Typy obsahují členy, které zapisujete. Tyto členy jsou sestaveny z příkazů a výrazů.
ms.date: 08/06/2020
ms.openlocfilehash: 3bdc6a4da6ae76148c7d1d5cb8ccb65d91fda61a
ms.sourcegitcommit: ae2e8a61a93c5cf3f0035c59e6b064fa2f812d14
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 09/02/2020
ms.locfileid: "89358814"
---
# <a name="program-building-blocks"></a><span data-ttu-id="5d7a6-105">Stavební bloky programu</span><span class="sxs-lookup"><span data-stu-id="5d7a6-105">Program building blocks</span></span>

<span data-ttu-id="5d7a6-106">Typy popsané v předchozím článku jsou sestaveny pomocí těchto stavebních bloků: [***členy***](../programming-guide/classes-and-structs/members.md), [ ***výrazy***a ***příkazy***](../programming-guide/statements-expressions-operators/index.md).</span><span class="sxs-lookup"><span data-stu-id="5d7a6-106">The types described in the previous article are built using these building blocks: [***members***](../programming-guide/classes-and-structs/members.md), [***expressions***, and ***statements***](../programming-guide/statements-expressions-operators/index.md).</span></span>

## <a name="members"></a><span data-ttu-id="5d7a6-107">Členové</span><span class="sxs-lookup"><span data-stu-id="5d7a6-107">Members</span></span>

<span data-ttu-id="5d7a6-108">Členové a `class` jsou buď ***statickými členy*** , nebo ***členy instance***.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-108">The members of a `class` are either ***static members*** or ***instance members***.</span></span> <span data-ttu-id="5d7a6-109">Statické členy patří ke třídám a členy instance patří do objektů (instance tříd).</span><span class="sxs-lookup"><span data-stu-id="5d7a6-109">Static members belong to classes, and instance members belong to objects (instances of classes).</span></span>

<span data-ttu-id="5d7a6-110">Následující seznam obsahuje přehled druhů členů, které třída může obsahovat.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-110">The following list provides an overview of the kinds of members a class can contain.</span></span>

- <span data-ttu-id="5d7a6-111">**Konstanty**: konstantní hodnoty přidružené ke třídě</span><span class="sxs-lookup"><span data-stu-id="5d7a6-111">**Constants**: Constant values associated with the class</span></span>
- <span data-ttu-id="5d7a6-112">**Pole**: proměnné, které jsou přidruženy ke třídě</span><span class="sxs-lookup"><span data-stu-id="5d7a6-112">**Fields**:  Variables that are associated of the class</span></span>
- <span data-ttu-id="5d7a6-113">**Metody**: akce, které mohou být provedeny třídou</span><span class="sxs-lookup"><span data-stu-id="5d7a6-113">**Methods**:  Actions that can be performed by the class</span></span>
- <span data-ttu-id="5d7a6-114">**Vlastnosti**: akce spojené s čtením a zápisem s názvem vlastnosti třídy</span><span class="sxs-lookup"><span data-stu-id="5d7a6-114">**Properties**: Actions associated with reading and writing named properties of the class</span></span>
- <span data-ttu-id="5d7a6-115">**Indexery**: akce přidružené k indexování instancí třídy, jako je pole</span><span class="sxs-lookup"><span data-stu-id="5d7a6-115">**Indexers**: Actions associated with indexing instances of the class like an array</span></span>
- <span data-ttu-id="5d7a6-116">**Události**: oznámení, která mohou být vygenerována třídou</span><span class="sxs-lookup"><span data-stu-id="5d7a6-116">**Events**: Notifications that can be generated by the class</span></span>
- <span data-ttu-id="5d7a6-117">**Operátory**: převody a operátory výrazů podporované třídou</span><span class="sxs-lookup"><span data-stu-id="5d7a6-117">**Operators**: Conversions and expression operators supported by the class</span></span>
- <span data-ttu-id="5d7a6-118">**Konstruktory**: akce vyžadované pro inicializaci instancí třídy nebo samotné třídy</span><span class="sxs-lookup"><span data-stu-id="5d7a6-118">**Constructors**: Actions required to initialize instances of the class or the class itself</span></span>
- <span data-ttu-id="5d7a6-119">**Finalizační metody**: akce provedené před trvalým zahozením instancí třídy</span><span class="sxs-lookup"><span data-stu-id="5d7a6-119">**Finalizers**: Actions performed before instances of the class are permanently discarded</span></span>
- <span data-ttu-id="5d7a6-120">**Typy**: vnořené typy deklarované třídou</span><span class="sxs-lookup"><span data-stu-id="5d7a6-120">**Types**: Nested types declared by the class</span></span>

## <a name="accessibility"></a><span data-ttu-id="5d7a6-121">Usnadnění</span><span class="sxs-lookup"><span data-stu-id="5d7a6-121">Accessibility</span></span>

<span data-ttu-id="5d7a6-122">Každý člen třídy má přidruženou přístupnost, která řídí oblasti textu programu, které mají přístup ke členu.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-122">Each member of a class has an associated accessibility, which controls the regions of program text that can access the member.</span></span> <span data-ttu-id="5d7a6-123">Existuje šest možných forem usnadnění přístupu.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-123">There are six possible forms of accessibility.</span></span> <span data-ttu-id="5d7a6-124">Modifikátory přístupu jsou shrnuty níže.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-124">The access modifiers are summarized below.</span></span>

- <span data-ttu-id="5d7a6-125">`public`: Přístup není omezený.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-125">`public`: Access isn't limited.</span></span>
- <span data-ttu-id="5d7a6-126">`private`: Přístup je omezen na tuto třídu.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-126">`private`: Access is limited to this class.</span></span>
- <span data-ttu-id="5d7a6-127">`protected`: Přístup je omezen na tuto třídu nebo třídy odvozené z této třídy.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-127">`protected`: Access is limited to this class or classes derived from this class.</span></span>
- <span data-ttu-id="5d7a6-128">`internal`: Přístup je omezen na aktuální sestavení ( `.exe` nebo `.dll` ).</span><span class="sxs-lookup"><span data-stu-id="5d7a6-128">`internal`: Access is limited to the current assembly (`.exe` or `.dll`).</span></span>
- <span data-ttu-id="5d7a6-129">`protected internal`: Přístup je omezen na tuto třídu, třídy odvozené z této třídy nebo třídy v rámci stejného sestavení.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-129">`protected internal`: Access is limited to this class, classes derived from this class, or classes within the same assembly.</span></span>
- <span data-ttu-id="5d7a6-130">`private protected`: Přístup je omezen na tuto třídu nebo třídy odvozené z tohoto typu v rámci stejného sestavení.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-130">`private protected`: Access is limited to this class or classes derived from this type within the same assembly.</span></span>

## <a name="fields"></a><span data-ttu-id="5d7a6-131">Pole</span><span class="sxs-lookup"><span data-stu-id="5d7a6-131">Fields</span></span>

<span data-ttu-id="5d7a6-132">*Pole* je proměnná, která je přidružena ke třídě nebo s instancí třídy.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-132">A *field* is a variable that is associated with a class or with an instance of a class.</span></span>

<span data-ttu-id="5d7a6-133">Pole deklarované pomocí statického modifikátoru definuje statické pole.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-133">A field declared with the static modifier defines a static field.</span></span> <span data-ttu-id="5d7a6-134">Statické pole identifikuje právě jedno umístění úložiště.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-134">A static field identifies exactly one storage location.</span></span> <span data-ttu-id="5d7a6-135">Bez ohledu na to, kolik instancí třídy je vytvořeno, je k dispozici pouze jedna kopie statického pole.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-135">No matter how many instances of a class are created, there's only ever one copy of a static field.</span></span>

<span data-ttu-id="5d7a6-136">Pole deklarované bez statického modifikátoru definuje pole instance.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-136">A field declared without the static modifier defines an instance field.</span></span> <span data-ttu-id="5d7a6-137">Každá instance třídy obsahuje samostatnou kopii všech polí instance této třídy.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-137">Every instance of a class contains a separate copy of all the instance fields of that class.</span></span>

<span data-ttu-id="5d7a6-138">V následujícím příkladu má každá instance `Color` třídy samostatnou kopii `r` `g` `b` polí instance, a, ale existuje pouze jedna kopie `Black` `White` pole,, `Red` , `Green` a `Blue` statických polí:</span><span class="sxs-lookup"><span data-stu-id="5d7a6-138">In the following example, each instance of the `Color` class has a separate copy of the `r`, `g`, and `b` instance fields, but there's only one copy of the `Black`, `White`, `Red`, `Green`, and `Blue` static fields:</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="ColorClassDefinition":::

<span data-ttu-id="5d7a6-139">Jak je znázorněno v předchozím příkladu, *pole jen pro čtení* mohou být deklarována s `readonly` modifikátorem.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-139">As shown in the previous example, *read-only fields* may be declared with a `readonly` modifier.</span></span> <span data-ttu-id="5d7a6-140">Přiřazení k poli jen pro čtení se může vyskytovat pouze v rámci deklarace pole nebo v konstruktoru ve stejné třídě.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-140">Assignment to a read-only field can only occur as part of the field’s declaration or in a constructor in the same class.</span></span>

## <a name="methods"></a><span data-ttu-id="5d7a6-141">Metody</span><span class="sxs-lookup"><span data-stu-id="5d7a6-141">Methods</span></span>

<span data-ttu-id="5d7a6-142">*Metoda* je člen, který implementuje výpočet nebo akci, kterou lze provést pomocí objektu nebo třídy.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-142">A *method* is a member that implements a computation or action that can be performed by an object or class.</span></span> <span data-ttu-id="5d7a6-143">*Statické metody* jsou k dispozici prostřednictvím třídy.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-143">*Static methods* are accessed through the class.</span></span> <span data-ttu-id="5d7a6-144">*Metody instance* jsou k dispozici prostřednictvím instancí třídy.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-144">*Instance methods* are accessed through instances of the class.</span></span>

<span data-ttu-id="5d7a6-145">Metody mohou mít seznam *parametrů*, které reprezentují hodnoty nebo odkazy na proměnné předané metodě.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-145">Methods may have a list of *parameters*, which represent values or variable references passed to the method.</span></span> <span data-ttu-id="5d7a6-146">Metody mají *návratový typ*, který určuje typ počítané hodnoty a vrácený metodou.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-146">Methods have a *return type*, which specifies the type of the value computed and returned by the method.</span></span> <span data-ttu-id="5d7a6-147">Návratový typ metody je `void` , pokud nevrací hodnotu.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-147">A method’s return type is `void` if it doesn't return a value.</span></span>

<span data-ttu-id="5d7a6-148">Podobně jako typy mohou metody mít také sadu parametrů typu, pro které argumenty typu musí být zadány při volání metody.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-148">Like types, methods may also have a set of type parameters, for which type arguments must be specified when the method is called.</span></span> <span data-ttu-id="5d7a6-149">Na rozdíl od typů lze argumenty typu často odvodit z argumentů volání metody a nemusí být explicitně předány.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-149">Unlike types, the type arguments can often be inferred from the arguments of a method call and need not be explicitly given.</span></span>

<span data-ttu-id="5d7a6-150">*Signatura* metody musí být jedinečná ve třídě, ve které je metoda deklarovaná.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-150">The *signature* of a method must be unique in the class in which the method is declared.</span></span> <span data-ttu-id="5d7a6-151">Signatura metody se skládá z názvu metody, počtu parametrů typu a počtu, modifikátorů a typů jeho parametrů.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-151">The signature of a method consists of the name of the method, the number of type parameters, and the number, modifiers, and types of its parameters.</span></span> <span data-ttu-id="5d7a6-152">Signatura metody neobsahuje návratový typ.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-152">The signature of a method doesn't include the return type.</span></span>

<span data-ttu-id="5d7a6-153">Je-li tělo metody jeden výraz, lze metodu definovat pomocí formátu kompaktního výrazu, jak je znázorněno v následujícím příkladu:</span><span class="sxs-lookup"><span data-stu-id="5d7a6-153">When a method body is a single expression, the method can be defined using a compact expression format, as shown in the following example:</span></span>

```csharp
public override ToString() => "This is an object";
```

### <a name="parameters"></a><span data-ttu-id="5d7a6-154">Parametry</span><span class="sxs-lookup"><span data-stu-id="5d7a6-154">Parameters</span></span>

<span data-ttu-id="5d7a6-155">Parametry slouží k předání hodnot nebo odkazů na proměnné metody.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-155">Parameters are used to pass values or variable references to methods.</span></span> <span data-ttu-id="5d7a6-156">Parametry metody získají jejich skutečné hodnoty z *argumentů* , které jsou zadány při volání metody.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-156">The parameters of a method get their actual values from the *arguments* that are specified when the method is invoked.</span></span> <span data-ttu-id="5d7a6-157">Existují čtyři typy parametrů: parametry hodnoty, parametry odkazu, výstupní parametry a pole parametrů.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-157">There are four kinds of parameters: value parameters, reference parameters, output parameters, and parameter arrays.</span></span>

<span data-ttu-id="5d7a6-158">*Parametr hodnoty* se používá pro předávání vstupních argumentů.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-158">A *value parameter* is used for passing input arguments.</span></span> <span data-ttu-id="5d7a6-159">Parametr hodnoty odpovídá místní proměnné, která vrací počáteční hodnotu z argumentu předaného pro parametr.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-159">A value parameter corresponds to a local variable that gets its initial value from the argument that was passed for the parameter.</span></span> <span data-ttu-id="5d7a6-160">Úpravy parametru hodnoty neovlivňují argument, který byl předán parametru.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-160">Modifications to a value parameter don't affect the argument that was passed for the parameter.</span></span>

<span data-ttu-id="5d7a6-161">Parametry hodnoty mohou být volitelné, zadáním výchozí hodnoty, aby bylo možné vynechat odpovídající argumenty.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-161">Value parameters can be optional, by specifying a default value so that corresponding arguments can be omitted.</span></span>

<span data-ttu-id="5d7a6-162">*Parametr reference* se používá pro předávání argumentů odkazem.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-162">A *reference parameter* is used for passing arguments by reference.</span></span> <span data-ttu-id="5d7a6-163">Argument předaný parametru reference musí být proměnná s určitou hodnotou.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-163">The argument passed for a reference parameter must be a variable with a definite value.</span></span> <span data-ttu-id="5d7a6-164">Během provádění metody představuje parametr reference stejné umístění úložiště jako proměnná argumentu.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-164">During execution of the method, the reference parameter represents the same storage location as the argument variable.</span></span> <span data-ttu-id="5d7a6-165">Parametr reference je deklarován s `ref` modifikátorem.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-165">A reference parameter is declared with the `ref` modifier.</span></span> <span data-ttu-id="5d7a6-166">Následující příklad ukazuje použití `ref` parametrů.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-166">The following example shows the use of `ref` parameters.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="RefExample":::

<span data-ttu-id="5d7a6-167">*Výstupní parametr* se používá pro předávání argumentů odkazem.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-167">An *output parameter* is used for passing arguments by reference.</span></span> <span data-ttu-id="5d7a6-168">Je podobná referenčnímu parametru, s tím rozdílem, že nevyžaduje explicitně přiřadit hodnotu k argumentu, který je k dispozici volajícímu.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-168">It's similar to a reference parameter, except that it doesn't require that you explicitly assign a value to the caller-provided argument.</span></span> <span data-ttu-id="5d7a6-169">Výstupní parametr je deklarován s `out` modifikátorem.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-169">An output parameter is declared with the `out` modifier.</span></span> <span data-ttu-id="5d7a6-170">Následující příklad ukazuje použití `out` parametrů pomocí syntaxe představené v jazyce C# 7.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-170">The following example shows the use of `out` parameters using the syntax introduced in C# 7.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="OutExample":::

<span data-ttu-id="5d7a6-171">*Pole parametrů* povoluje proměnný počet argumentů, které mají být předány metodě.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-171">A *parameter array* permits a variable number of arguments to be passed to a method.</span></span> <span data-ttu-id="5d7a6-172">Pole parametrů je deklarováno s `params` modifikátorem.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-172">A parameter array is declared with the `params` modifier.</span></span> <span data-ttu-id="5d7a6-173">Pouze poslední parametr metody může být pole parametrů a typ pole parametrů musí být jednorozměrné pole.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-173">Only the last parameter of a method can be a parameter array, and the type of a parameter array must be a single-dimensional array type.</span></span> <span data-ttu-id="5d7a6-174">`Write`Metody a `WriteLine` <xref:System.Console?displayProperty=nameWithType> třídy jsou osvědčenými příklady použití pole parametrů.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-174">The `Write` and `WriteLine` methods of the <xref:System.Console?displayProperty=nameWithType> class are good examples of parameter array usage.</span></span> <span data-ttu-id="5d7a6-175">Jsou deklarovány následujícím způsobem.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-175">They're declared as follows.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="ConsoleExtract":::

<span data-ttu-id="5d7a6-176">V rámci metody, která používá pole parametrů, se pole parametru chová stejně jako regulární parametr typu pole.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-176">Within a method that uses a parameter array, the parameter array behaves exactly like a regular parameter of an array type.</span></span> <span data-ttu-id="5d7a6-177">Při vyvolání metody s parametrem pole je však možné předat buď jeden argument typu pole parametru, nebo libovolný počet argumentů typu prvku pole parametrů.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-177">However, in an invocation of a method with a parameter array, it's possible to pass either a single argument of the parameter array type or any number of arguments of the element type of the parameter array.</span></span> <span data-ttu-id="5d7a6-178">V druhém případě je instance pole automaticky vytvořena a inicializována s danými argumenty.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-178">In the latter case, an array instance is automatically created and initialized with the given arguments.</span></span> <span data-ttu-id="5d7a6-179">Tento příklad</span><span class="sxs-lookup"><span data-stu-id="5d7a6-179">This example</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="UseParamsArgs":::

<span data-ttu-id="5d7a6-180">je ekvivalentem zápisu následujícího.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-180">is equivalent to writing the following.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="CompilerParams":::

### <a name="method-body-and-local-variables"></a><span data-ttu-id="5d7a6-181">Tělo metody a místní proměnné</span><span class="sxs-lookup"><span data-stu-id="5d7a6-181">Method body and local variables</span></span>

<span data-ttu-id="5d7a6-182">Tělo metody Určuje příkazy, které mají být provedeny při volání metody.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-182">A method’s body specifies the statements to execute when the method is invoked.</span></span>

<span data-ttu-id="5d7a6-183">Tělo metody může deklarovat proměnné, které jsou specifické pro vyvolání metody.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-183">A method body can declare variables that are specific to the invocation of the method.</span></span> <span data-ttu-id="5d7a6-184">Tyto proměnné se nazývají *místní proměnné*.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-184">Such variables are called *local variables*.</span></span> <span data-ttu-id="5d7a6-185">Místní deklarace proměnné Určuje název typu, název proměnné a pravděpodobně počáteční hodnotu.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-185">A local variable declaration specifies a type name, a variable name, and possibly an initial value.</span></span> <span data-ttu-id="5d7a6-186">Následující příklad deklaruje místní proměnnou `i` s počáteční hodnotou nula a místní proměnnou `j` bez počáteční hodnoty.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-186">The following example declares a local variable `i` with an initial value of zero and a local variable `j` with no initial value.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="SquaresClass":::

<span data-ttu-id="5d7a6-187">Jazyk C# vyžaduje, aby místní proměnná byla *jednoznačně přiřazena* , aby bylo možné získat její hodnotu.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-187">C# requires a local variable to be *definitely assigned* before its value can be obtained.</span></span> <span data-ttu-id="5d7a6-188">Například pokud deklarace předchozího `i` neobsahovala počáteční hodnotu, kompilátor by nahlásil chybu pro pozdější použití, protože by nemuseli `i` `i` být jednoznačně přiřazeni v těchto bodech v programu.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-188">For example, if the declaration of the previous `i` didn't include an initial value, the compiler would report an error for the later usages of `i` because `i` wouldn't be definitely assigned at those points in the program.</span></span>

<span data-ttu-id="5d7a6-189">Metoda může použít `return` příkazy pro vrácení řízení volajícímu.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-189">A method can use `return` statements to return control to its caller.</span></span> <span data-ttu-id="5d7a6-190">V metodách, které vracejí `void` , `return` příkazy nemůžou zadat výraz.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-190">In a method returning `void`, `return` statements can't specify an expression.</span></span> <span data-ttu-id="5d7a6-191">V metodě, která vrací typ non-void, `return` musí příkazy zahrnovat výraz, který vypočítá vrácenou hodnotu.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-191">In a method returning non-void, `return` statements must include an expression that computes the return value.</span></span>

### <a name="static-and-instance-methods"></a><span data-ttu-id="5d7a6-192">Statické a instanční metody</span><span class="sxs-lookup"><span data-stu-id="5d7a6-192">Static and instance methods</span></span>

<span data-ttu-id="5d7a6-193">Metoda deklarovaná s `static` modifikátorem je *statická metoda*.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-193">A method declared with a `static` modifier is a *static method*.</span></span> <span data-ttu-id="5d7a6-194">Statická metoda nefunguje na konkrétní instanci a může přímo přistupovat ke statickým členům.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-194">A static method doesn't operate on a specific instance and can only directly access static members.</span></span>

<span data-ttu-id="5d7a6-195">Metoda deklarovaná bez `static` modifikátoru je *Metoda instance*.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-195">A method declared without a `static` modifier is an *instance method*.</span></span> <span data-ttu-id="5d7a6-196">Metoda instance pracuje na konkrétní instanci a může přistupovat ke statickým i instancím členů.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-196">An instance method operates on a specific instance and can access both static and instance members.</span></span> <span data-ttu-id="5d7a6-197">Instance, na které byla vyvolána metoda instance, může být explicitně k dispozici jako `this` .</span><span class="sxs-lookup"><span data-stu-id="5d7a6-197">The instance on which an instance method was invoked can be explicitly accessed as `this`.</span></span> <span data-ttu-id="5d7a6-198">V případě, že se odkazuje na statickou metodu, se jedná o chybu `this` .</span><span class="sxs-lookup"><span data-stu-id="5d7a6-198">It's an error to refer to `this` in a static method.</span></span>

<span data-ttu-id="5d7a6-199">Následující `Entity` Třída má členy statických i instancí.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-199">The following `Entity` class has both static and instance members.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="EntityClass":::

<span data-ttu-id="5d7a6-200">Každá `Entity` instance obsahuje sériové číslo (a předpokládá se, že některé další informace nejsou zde uvedeny).</span><span class="sxs-lookup"><span data-stu-id="5d7a6-200">Each `Entity` instance contains a serial number (and presumably some other information that isn't shown here).</span></span> <span data-ttu-id="5d7a6-201">`Entity`Konstruktor (který je jako metoda instance) Inicializuje novou instanci s dalším dostupným sériovým číslem.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-201">The `Entity` constructor (which is like an instance method) initializes the new instance with the next available serial number.</span></span> <span data-ttu-id="5d7a6-202">Vzhledem k tomu, že je konstruktor členem instance, je povolen přístup k `_serialNo` poli instance i k `s_nextSerialNo` statickému poli.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-202">Because the constructor is an instance member, it's permitted to access both the `_serialNo` instance field and the `s_nextSerialNo` static field.</span></span>

<span data-ttu-id="5d7a6-203">`GetNextSerialNo` `SetNextSerialNo` Statické metody a můžou přistupovat ke `s_nextSerialNo` statickému poli, ale při přímém přístupu k poli instance by to byla chyba `_serialNo` .</span><span class="sxs-lookup"><span data-stu-id="5d7a6-203">The `GetNextSerialNo` and `SetNextSerialNo` static methods can access the `s_nextSerialNo` static field, but it would be an error for them to directly access the `_serialNo` instance field.</span></span>

<span data-ttu-id="5d7a6-204">Následující příklad ukazuje použití `Entity` třídy.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-204">The following example shows the use of the `Entity` class.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="UsingEntity":::

<span data-ttu-id="5d7a6-205">`SetNextSerialNo` `GetNextSerialNo` Statické metody a jsou vyvolány ve třídě, zatímco `GetSerialNo` Metoda instance je vyvolána na instancích třídy.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-205">The `SetNextSerialNo` and `GetNextSerialNo` static methods are invoked on the class whereas the `GetSerialNo` instance method is invoked on instances of the class.</span></span>

### <a name="virtual-override-and-abstract-methods"></a><span data-ttu-id="5d7a6-206">Virtuální, přepisování a abstraktní metody</span><span class="sxs-lookup"><span data-stu-id="5d7a6-206">Virtual, override, and abstract methods</span></span>

<span data-ttu-id="5d7a6-207">Pokud deklarace metody instance obsahuje `virtual` modifikátor, metoda je označována jako *virtuální metoda*.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-207">When an instance method declaration includes a `virtual` modifier, the method is said to be a *virtual method*.</span></span> <span data-ttu-id="5d7a6-208">Pokud není k dispozici žádný modifikátor Virtual, metoda je označována jako *nevirtuální metoda*.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-208">When no virtual modifier is present, the method is said to be a *nonvirtual method*.</span></span>

<span data-ttu-id="5d7a6-209">Když je vyvolána virtuální metoda, je *typ běhu* instance, pro kterou probíhá vyvolání, určuje vlastní implementaci metody, která má být vyvolána.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-209">When a virtual method is invoked, the *run-time type* of the instance for which that invocation takes place determines the actual method implementation to invoke.</span></span> <span data-ttu-id="5d7a6-210">V nevirtuálním volání metody je *Typ doby kompilace* instance určujícím faktorem.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-210">In a nonvirtual method invocation, the *compile-time type* of the instance is the determining factor.</span></span>

<span data-ttu-id="5d7a6-211">Virtuální metoda může být *přepsána* v odvozené třídě.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-211">A virtual method can be *overridden* in a derived class.</span></span> <span data-ttu-id="5d7a6-212">Pokud deklarace metody instance obsahuje modifikátor přepsání, metoda přepíše zděděnou virtuální metodu se stejnou signaturou.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-212">When an instance method declaration includes an override modifier, the method overrides an inherited virtual method with the same signature.</span></span> <span data-ttu-id="5d7a6-213">Deklarace virtuální metody zavádí novou metodu.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-213">A virtual method declaration introduces a new method.</span></span> <span data-ttu-id="5d7a6-214">Deklarace metody přepsání specializuje existující zděděnou virtuální metodu tím, že poskytuje novou implementaci této metody.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-214">An override method declaration specializes an existing inherited virtual method by providing a new implementation of that method.</span></span>

<span data-ttu-id="5d7a6-215">*Abstraktní metoda* je virtuální metoda bez implementace.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-215">An *abstract method* is a virtual method with no implementation.</span></span> <span data-ttu-id="5d7a6-216">Abstraktní metoda je deklarována s `abstract` modifikátorem a je povolena pouze v abstraktní třídě.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-216">An abstract method is declared with the `abstract` modifier and is permitted only in an abstract class.</span></span> <span data-ttu-id="5d7a6-217">Abstraktní metoda musí být přepsána v každé neabstraktní odvozené třídě.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-217">An abstract method must be overridden in every non-abstract derived class.</span></span>

<span data-ttu-id="5d7a6-218">Následující příklad deklaruje abstraktní třídu, `Expression` , která představuje uzel stromu výrazu, a tři odvozené třídy,, `Constant` `VariableReference` , a `Operation` , které implementují uzly stromu výrazu pro konstanty, odkazy na proměnné a aritmetické operace.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-218">The following example declares an abstract class, `Expression`, which represents an expression tree node, and three derived classes, `Constant`, `VariableReference`, and `Operation`, which implement expression tree nodes for constants, variable references, and arithmetic operations.</span></span> <span data-ttu-id="5d7a6-219">(Tento příklad je podobný jako, ale nesouvisí s typy stromu výrazů).</span><span class="sxs-lookup"><span data-stu-id="5d7a6-219">(This example is similar to, but not related to the expression tree types).</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="WorkingWithExpressions":::

<span data-ttu-id="5d7a6-220">K modelování aritmetických výrazů lze použít předchozí čtyři třídy.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-220">The previous four classes can be used to model arithmetic expressions.</span></span> <span data-ttu-id="5d7a6-221">Například pomocí instancí těchto tříd `x + 3` může být výraz reprezentován následujícím způsobem.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-221">For example, using instances of these classes, the expression `x + 3` can be represented as follows.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="UseExpressions":::

<span data-ttu-id="5d7a6-222">`Evaluate`Metoda `Expression` instance je vyvolána pro vyhodnocení daného výrazu a vytvoření `double` hodnoty.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-222">The `Evaluate` method of an `Expression` instance is invoked to evaluate the given expression and produce a `double` value.</span></span> <span data-ttu-id="5d7a6-223">Metoda přebírá `Dictionary` argument, který obsahuje názvy proměnných (jako klíče záznamů) a hodnoty (jako hodnoty položek).</span><span class="sxs-lookup"><span data-stu-id="5d7a6-223">The method takes a `Dictionary` argument that contains variable names (as keys of the entries) and values (as values of the entries).</span></span> <span data-ttu-id="5d7a6-224">Protože `Evaluate` je abstraktní metoda, neabstraktní třídy odvozené z musí být `Expression` přepsány `Evaluate` .</span><span class="sxs-lookup"><span data-stu-id="5d7a6-224">Because `Evaluate` is an abstract method, non-abstract classes derived from `Expression` must override `Evaluate`.</span></span>

<span data-ttu-id="5d7a6-225">`Constant`Implementace `Evaluate` jednoduše vrátí uloženou konstantu.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-225">A `Constant`'s implementation of `Evaluate` simply returns the stored constant.</span></span> <span data-ttu-id="5d7a6-226">`VariableReference`Implementace objektu vyhledá název proměnné ve slovníku a vrátí výslednou hodnotu.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-226">A `VariableReference`'s implementation looks up the variable name in the dictionary and returns the resulting value.</span></span> <span data-ttu-id="5d7a6-227">`Operation`Implementace nejprve vyhodnotí levý a pravý operand (rekurzivním voláním `Evaluate` metod) a poté provede danou aritmetickou operaci.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-227">An `Operation`'s implementation first evaluates the left and right operands (by recursively invoking their `Evaluate` methods) and then performs the given arithmetic operation.</span></span>

<span data-ttu-id="5d7a6-228">Následující program používá `Expression` třídy pro vyhodnocení výrazu `x * (y + 2)` pro různé hodnoty `x` a `y` .</span><span class="sxs-lookup"><span data-stu-id="5d7a6-228">The following program uses the `Expression` classes to evaluate the expression `x * (y + 2)` for different values of `x` and `y`.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="UsingExpressions":::

### <a name="method-overloading"></a><span data-ttu-id="5d7a6-229">Přetížení metody</span><span class="sxs-lookup"><span data-stu-id="5d7a6-229">Method overloading</span></span>

<span data-ttu-id="5d7a6-230">*Přetížení* metody umožňuje, aby více metod ve stejné třídě měl stejný název, pokud mají jedinečné podpisy.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-230">Method *overloading* permits multiple methods in the same class to have the same name as long as they have unique signatures.</span></span> <span data-ttu-id="5d7a6-231">Při kompilování volání přetížené metody kompilátor používá *řešení přetížení* k určení konkrétní metody, která má být vyvolána.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-231">When compiling an invocation of an overloaded method, the compiler uses *overload resolution* to determine the specific method to invoke.</span></span> <span data-ttu-id="5d7a6-232">Řešení přetížení najde jednu metodu, která nejlépe odpovídá argumentům.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-232">Overload resolution finds the one method that best matches the arguments.</span></span> <span data-ttu-id="5d7a6-233">Pokud nemůžete najít žádnou nejlepší shodu, nahlásí se chyba.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-233">If no single best match can be found, an error is reported.</span></span> <span data-ttu-id="5d7a6-234">Následující příklad ukazuje rozlišení přetížení v platnosti.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-234">The following example shows overload resolution in effect.</span></span> <span data-ttu-id="5d7a6-235">Komentář pro každé vyvolání v `UsageExample` metodě ukazuje, která metoda je vyvolána.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-235">The comment for each invocation in the `UsageExample` method shows which method is invoked.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="Overloading":::

<span data-ttu-id="5d7a6-236">Jak je znázorněno v příkladu, konkrétní metodu lze vždy vybrat explicitním přetypováním argumentů na přesné typy parametrů a argumenty typu.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-236">As shown by the example, a particular method can always be selected by explicitly casting the arguments to the exact parameter types and type arguments.</span></span>

## <a name="other-function-members"></a><span data-ttu-id="5d7a6-237">Další členové funkcí</span><span class="sxs-lookup"><span data-stu-id="5d7a6-237">Other function members</span></span>

<span data-ttu-id="5d7a6-238">Členy, které obsahují spustitelný kód, jsou souhrnně označovány jako *Členové funkce* třídy.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-238">Members that contain executable code are collectively known as the *function members* of a class.</span></span> <span data-ttu-id="5d7a6-239">Předchozí část popisuje metody, které jsou primárními typy členů funkce.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-239">The preceding section describes methods, which are the primary types of function members.</span></span> <span data-ttu-id="5d7a6-240">Tato část popisuje další druhy členů funkce podporované jazykem C#: konstruktory, vlastnosti, indexery, události, operátory a finalizační metody.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-240">This section describes the other kinds of function members supported by C#: constructors, properties, indexers, events, operators, and finalizers.</span></span>

<span data-ttu-id="5d7a6-241">Následující příklad ukazuje obecnou třídu s názvem `MyList<T>` , která implementuje zvětšený seznam objektů.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-241">The following example shows a generic class called `MyList<T>`, which implements a growable list of objects.</span></span> <span data-ttu-id="5d7a6-242">Třída obsahuje několik příkladů nejběžnějších druhů členů funkce.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-242">The class contains several examples of the most common kinds of function members.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="ListExample":::

### <a name="constructors"></a><span data-ttu-id="5d7a6-243">Konstruktory</span><span class="sxs-lookup"><span data-stu-id="5d7a6-243">Constructors</span></span>

<span data-ttu-id="5d7a6-244">Jazyk C# podporuje konstruktory instancí i statických konstruktorů.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-244">C# supports both instance and static constructors.</span></span> <span data-ttu-id="5d7a6-245">*Konstruktor instance* je člen, který implementuje akce vyžadované pro inicializaci instance třídy.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-245">An *instance constructor* is a member that implements the actions required to initialize an instance of a class.</span></span> <span data-ttu-id="5d7a6-246">*Statický konstruktor* je člen, který implementuje akce vyžadované k inicializaci samotné třídy při prvním načtení.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-246">A *static constructor* is a member that implements the actions required to initialize a class itself when it's first loaded.</span></span>

<span data-ttu-id="5d7a6-247">Konstruktor je deklarovaný jako metoda bez návratového typu a stejný název jako obsahující třída.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-247">A constructor is declared like a method with no return type and the same name as the containing class.</span></span> <span data-ttu-id="5d7a6-248">Pokud deklarace konstruktoru obsahuje `static` modifikátor, deklaruje statický konstruktor.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-248">If a constructor declaration includes a `static` modifier, it declares a static constructor.</span></span> <span data-ttu-id="5d7a6-249">V opačném případě deklaruje konstruktor instance.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-249">Otherwise, it declares an instance constructor.</span></span>

<span data-ttu-id="5d7a6-250">Konstruktory instancí můžou být přetížené a můžou mít volitelné parametry.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-250">Instance constructors can be overloaded and can have optional parameters.</span></span> <span data-ttu-id="5d7a6-251">Například `MyList<T>` Třída deklaruje jeden konstruktor instance s jedním volitelným `int` parametrem.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-251">For example, the `MyList<T>` class declares one instance constructor with a single optional `int` parameter.</span></span> <span data-ttu-id="5d7a6-252">Konstruktory instancí jsou vyvolány pomocí `new` operátoru.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-252">Instance constructors are invoked using the `new` operator.</span></span> <span data-ttu-id="5d7a6-253">Následující příkazy přidělují dvě `MyList<string>` instance pomocí konstruktoru `MyList` třídy s nepovinným argumentem a bez něj.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-253">The following statements allocate two `MyList<string>` instances using the constructor of the `MyList` class with and without the optional argument.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="CreateLists":::

<span data-ttu-id="5d7a6-254">Na rozdíl od jiných členů nejsou konstruktory instancí děděny.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-254">Unlike other members, instance constructors aren't inherited.</span></span> <span data-ttu-id="5d7a6-255">Třída nemá žádné konstruktory instancí jiné než konstruktory, které jsou ve skutečnosti deklarovány ve třídě.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-255">A class has no instance constructors other than those constructors actually declared in the class.</span></span> <span data-ttu-id="5d7a6-256">Pokud pro třídu není zadán konstruktor instance, bude automaticky zadáno prázdné číslo bez parametrů.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-256">If no instance constructor is supplied for a class, then an empty one with no parameters is automatically provided.</span></span>

### <a name="properties"></a><span data-ttu-id="5d7a6-257">Vlastnosti</span><span class="sxs-lookup"><span data-stu-id="5d7a6-257">Properties</span></span>

<span data-ttu-id="5d7a6-258">*Vlastnosti* jsou přirozené rozšíření polí.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-258">*Properties* are a natural extension of fields.</span></span> <span data-ttu-id="5d7a6-259">Oba se nazývají členové s přidruženými typy a syntaxe pro přístup k polím a vlastnostem je stejná.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-259">Both are named members with associated types, and the syntax for accessing fields and properties is the same.</span></span> <span data-ttu-id="5d7a6-260">Na rozdíl od polí ale vlastnosti neoznačují umístění úložiště.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-260">However, unlike fields, properties don't denote storage locations.</span></span> <span data-ttu-id="5d7a6-261">Místo toho mají vlastnosti *přistupující objekty* , které určují příkazy, které byly provedeny, když jsou jejich hodnoty čteny nebo zapsány.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-261">Instead, properties have *accessors* that specify the statements executed when their values are read or written.</span></span>

<span data-ttu-id="5d7a6-262">Vlastnost je deklarována jako pole s tím rozdílem, že deklarace končí pomocí přístupového objektu Get nebo pomocí přístupového objektu sady zapsaný mezi oddělovači `{` a `}` místo konci středníku.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-262">A property is declared like a field, except that the declaration ends with a get accessor or a set accessor written between the delimiters `{` and `}` instead of ending in a semicolon.</span></span> <span data-ttu-id="5d7a6-263">Vlastnost, která má přistupující objekt get i přístupový objekt set, je *vlastnost pro čtení i zápis*, vlastnost, která má pouze přistupující objekt get, je *vlastnost jen pro čtení*a vlastnost, která má pouze přístupový objekt set, je *vlastnost pouze pro zápis*.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-263">A property that has both a get accessor and a set accessor is a *read-write property*, a property that has only a get accessor is a *read-only property*, and a property that has only a set accessor is a *write-only property*.</span></span>

<span data-ttu-id="5d7a6-264">Přístupový objekt get odpovídá metodě bez parametrů s návratovou hodnotou typu vlastnosti.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-264">A get accessor corresponds to a parameterless method with a return value of the property type.</span></span> <span data-ttu-id="5d7a6-265">Přístupový objekt set odpovídá metodě s jedním parametrem s názvem Value a bez návratového typu.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-265">A set accessor corresponds to a method with a single parameter named value and no return type.</span></span> <span data-ttu-id="5d7a6-266">Přistupující objekt get vypočítá hodnotu vlastnosti.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-266">The get accessor computes the value of the property.</span></span> <span data-ttu-id="5d7a6-267">Přístupový objekt set poskytuje novou hodnotu pro vlastnost.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-267">The set accessor provides a new value for the property.</span></span> <span data-ttu-id="5d7a6-268">Když je vlastnost cílem přiřazení, nebo operandem `++` nebo `--` , je vyvolána přistupující objekt set.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-268">When the property is the target of an assignment, or the operand of `++` or `--`, the set accessor is invoked.</span></span> <span data-ttu-id="5d7a6-269">V jiných případech, kde je odkazováno na vlastnost, je vyvolána přistupující objekt get.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-269">In other cases where the property is referenced, the get accessor is invoked.</span></span>

<span data-ttu-id="5d7a6-270">`MyList<T>`Třída deklaruje dvě vlastnosti, `Count` `Capacity` které jsou jen pro čtení a pro čtení i zápis, v uvedeném pořadí.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-270">The `MyList<T>` class declares two properties, `Count` and `Capacity`, which are read-only and read-write, respectively.</span></span> <span data-ttu-id="5d7a6-271">Následující kód je příkladem použití těchto vlastností:</span><span class="sxs-lookup"><span data-stu-id="5d7a6-271">The following code is an example of use of these properties:</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="AccessProperties":::

<span data-ttu-id="5d7a6-272">Podobně jako pole a metody podporuje C# vlastnosti instance i statické vlastnosti.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-272">Similar to fields and methods, C# supports both instance properties and static properties.</span></span> <span data-ttu-id="5d7a6-273">Statické vlastnosti jsou deklarovány se statickým modifikátorem a vlastnosti instance jsou deklarovány bez ní.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-273">Static properties are declared with the static modifier, and instance properties are declared without it.</span></span>

<span data-ttu-id="5d7a6-274">Přístupové objekty vlastnosti mohou být virtuální.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-274">The accessor(s) of a property can be virtual.</span></span> <span data-ttu-id="5d7a6-275">Pokud deklarace vlastnosti obsahuje `virtual` `abstract` modifikátor, nebo, vztahuje se `override` na přístupový objekt (y) vlastnosti.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-275">When a property declaration includes a `virtual`, `abstract`, or `override` modifier, it applies to the accessor(s) of the property.</span></span>

### <a name="indexers"></a><span data-ttu-id="5d7a6-276">Indexery</span><span class="sxs-lookup"><span data-stu-id="5d7a6-276">Indexers</span></span>

<span data-ttu-id="5d7a6-277">*Indexer* je člen, který umožňuje, aby objekty byly indexovány stejným způsobem jako pole.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-277">An *indexer* is a member that enables objects to be indexed in the same way as an array.</span></span> <span data-ttu-id="5d7a6-278">Indexer je deklarován jako vlastnost s tím rozdílem, že název člena je `this` následován seznamem parametrů napsaným mezi oddělovači `[` a `]` .</span><span class="sxs-lookup"><span data-stu-id="5d7a6-278">An indexer is declared like a property except that the name of the member is `this` followed by a parameter list written between the delimiters `[` and `]`.</span></span> <span data-ttu-id="5d7a6-279">Parametry jsou k dispozici v přistupujícím objektu indexeru.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-279">The parameters are available in the accessor(s) of the indexer.</span></span> <span data-ttu-id="5d7a6-280">Podobně jako u vlastností mohou být indexery pro čtení i zápis, jen pro čtení a přístup k nástroji indexeru, které mohou být virtuální.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-280">Similar to properties, indexers can be read-write, read-only, and write-only, and the accessor(s) of an indexer can be virtual.</span></span>

<span data-ttu-id="5d7a6-281">`MyList<T>`Třída deklaruje jeden indexer pro čtení a zápis, který přebírá `int` parametr.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-281">The `MyList<T>` class declares a single read-write indexer that takes an `int` parameter.</span></span> <span data-ttu-id="5d7a6-282">Indexer umožňuje indexovat `MyList<T>` instance s `int` hodnotami.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-282">The indexer makes it possible to index `MyList<T>` instances with `int` values.</span></span> <span data-ttu-id="5d7a6-283">Příklad:</span><span class="sxs-lookup"><span data-stu-id="5d7a6-283">For example:</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="ListAccess":::

<span data-ttu-id="5d7a6-284">Indexery mohou být přetíženy.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-284">Indexers can be overloaded.</span></span> <span data-ttu-id="5d7a6-285">Třída může deklarovat více indexerů za předpokladu, že počet nebo typy jejich parametrů se liší.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-285">A class can declare multiple indexers as long as the number or types of their parameters differ.</span></span>

### <a name="events"></a><span data-ttu-id="5d7a6-286">Události</span><span class="sxs-lookup"><span data-stu-id="5d7a6-286">Events</span></span>

<span data-ttu-id="5d7a6-287">*Událost* je člen, který umožňuje třídě nebo objektu poskytovat oznámení.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-287">An *event* is a member that enables a class or object to provide notifications.</span></span> <span data-ttu-id="5d7a6-288">Událost je deklarována jako pole s tím rozdílem, že deklarace zahrnuje `event` klíčové slovo a typ musí být delegovaný typ.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-288">An event is declared like a field except that the declaration includes an `event` keyword and the type must be a delegate type.</span></span>

<span data-ttu-id="5d7a6-289">V rámci třídy, která deklaruje člena události, se událost chová stejně jako pole typu delegáta (za předpokladu, že událost není abstraktní a nedeklaruje přistupující objekty).</span><span class="sxs-lookup"><span data-stu-id="5d7a6-289">Within a class that declares an event member, the event behaves just like a field of a delegate type (provided the event isn't abstract and doesn't declare accessors).</span></span> <span data-ttu-id="5d7a6-290">Pole ukládá odkaz na delegáta, který představuje obslužné rutiny událostí, které byly přidány do události.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-290">The field stores a reference to a delegate that represents the event handlers that have been added to the event.</span></span> <span data-ttu-id="5d7a6-291">Pokud nejsou k dispozici žádné obslužné rutiny událostí, pole je `null` .</span><span class="sxs-lookup"><span data-stu-id="5d7a6-291">If no event handlers are present, the field is `null`.</span></span>

<span data-ttu-id="5d7a6-292">`MyList<T>`Třída deklaruje jeden člen události s názvem `Changed` , který indikuje, že do seznamu byla přidána nová položka.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-292">The `MyList<T>` class declares a single event member called `Changed`, which indicates that a new item has been added to the list.</span></span> <span data-ttu-id="5d7a6-293">Změněná událost je vyvolána `OnChanged` virtuální metodou, která nejprve kontroluje, zda je událost `null` (to znamená, že nejsou přítomny žádné obslužné rutiny).</span><span class="sxs-lookup"><span data-stu-id="5d7a6-293">The Changed event is raised by the `OnChanged` virtual method, which first checks whether the event is `null` (meaning that no handlers are present).</span></span> <span data-ttu-id="5d7a6-294">Pojem vyvolání události je přesně shodný s voláním delegáta, reprezentovaného událostí.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-294">The notion of raising an event is precisely equivalent to invoking the delegate represented by the event.</span></span> <span data-ttu-id="5d7a6-295">Pro vyvolání událostí nejsou k dispozici žádné speciální jazykové konstrukce.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-295">There are no special language constructs for raising events.</span></span>

<span data-ttu-id="5d7a6-296">Klienti reagují na události prostřednictvím *obslužných rutin událostí*.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-296">Clients react to events through *event handlers*.</span></span> <span data-ttu-id="5d7a6-297">Obslužné rutiny událostí jsou připojeny pomocí `+=` operátoru a odebrány pomocí `-=` operátoru.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-297">Event handlers are attached using the `+=` operator and removed using the `-=` operator.</span></span> <span data-ttu-id="5d7a6-298">Následující příklad připojí obslužnou rutinu události k `Changed` události `MyList<string>` .</span><span class="sxs-lookup"><span data-stu-id="5d7a6-298">The following example attaches an event handler to the `Changed` event of a `MyList<string>`.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="RespondToEvents":::

<span data-ttu-id="5d7a6-299">Pro pokročilé scénáře, kde je požadováno řízení základního úložiště události, může deklarace události explicitně poskytnout `add` a `remove` přistupující objekty, které jsou podobné `set` přístupovému objektu vlastnosti.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-299">For advanced scenarios where control of the underlying storage of an event is desired, an event declaration can explicitly provide `add` and `remove` accessors, which are similar to the `set` accessor of a property.</span></span>

### <a name="operators"></a><span data-ttu-id="5d7a6-300">Operátory</span><span class="sxs-lookup"><span data-stu-id="5d7a6-300">Operators</span></span>

<span data-ttu-id="5d7a6-301">*Operátor* je člen, který definuje význam použití konkrétního operátoru výrazu na instance třídy.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-301">An *operator* is a member that defines the meaning of applying a particular expression operator to instances of a class.</span></span> <span data-ttu-id="5d7a6-302">Lze definovat tři typy operátorů: unární operátory, binární operátory a operátory převodu.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-302">Three kinds of operators can be defined: unary operators, binary operators, and conversion operators.</span></span> <span data-ttu-id="5d7a6-303">Všechny operátory musí být deklarovány jako `public` a `static` .</span><span class="sxs-lookup"><span data-stu-id="5d7a6-303">All operators must be declared as `public` and `static`.</span></span>

<span data-ttu-id="5d7a6-304">`MyList<T>`Třída deklaruje dva operátory `operator ==` a `operator !=` .</span><span class="sxs-lookup"><span data-stu-id="5d7a6-304">The `MyList<T>` class declares two operators, `operator ==` and `operator !=`.</span></span> <span data-ttu-id="5d7a6-305">Tyto přepsané operátory poskytují nový význam pro výrazy, které tyto operátory aplikují na `MyList` instance.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-305">These overridden operators give new meaning to expressions that apply those operators to `MyList` instances.</span></span> <span data-ttu-id="5d7a6-306">Konkrétně operátory definují rovnost dvou `MyList<T>` instancí jako porovnávání každého z obsažených objektů pomocí jejich `Equals` metod.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-306">Specifically, the operators define equality of two `MyList<T>` instances as comparing each of the contained objects using their `Equals` methods.</span></span> <span data-ttu-id="5d7a6-307">Následující příklad používá `==` operátor k porovnání dvou `MyList<int>` instancí.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-307">The following example uses the `==` operator to compare two `MyList<int>` instances.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="ListAddition":::

<span data-ttu-id="5d7a6-308">První `Console.WriteLine` výstupy, `True` protože dva seznamy obsahují stejný počet objektů se stejnými hodnotami ve stejném pořadí.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-308">The first `Console.WriteLine` outputs `True` because the two lists contain the same number of objects with the same values in the same order.</span></span> <span data-ttu-id="5d7a6-309">`MyList<T>`Nebyl definován `operator ==` , první `Console.WriteLine` by měl výstup, `False` protože `a` a odkazují na `b` různé `MyList<int>` instance.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-309">Had `MyList<T>` not defined `operator ==`, the first `Console.WriteLine` would have output `False` because `a` and `b` reference different `MyList<int>` instances.</span></span>

### <a name="finalizers"></a><span data-ttu-id="5d7a6-310">Finalizační metody</span><span class="sxs-lookup"><span data-stu-id="5d7a6-310">Finalizers</span></span>

<span data-ttu-id="5d7a6-311">*Finalizační metoda* je člen, který implementuje akce vyžadované k finalizaci instance třídy.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-311">A *finalizer* is a member that implements the actions required to finalize an instance of a class.</span></span> <span data-ttu-id="5d7a6-312">Pro uvolnění nespravovaných prostředků je obvykle potřeba finalizační metoda.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-312">Typically, a finalizer is needed to release unmanaged resources.</span></span> <span data-ttu-id="5d7a6-313">Finalizační metody nemohou mít parametry, nemohou mít modifikátory dostupnosti a nelze je volat explicitně.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-313">Finalizers can't have parameters, they can't have accessibility modifiers, and they can't be invoked explicitly.</span></span> <span data-ttu-id="5d7a6-314">Finalizační metoda pro instanci je vyvolána automaticky během uvolňování paměti.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-314">The finalizer for an instance is invoked automatically during garbage collection.</span></span> <span data-ttu-id="5d7a6-315">Další podrobnosti najdete v článku o [finalizační metody](../programming-guide/classes-and-structs/destructors.md).</span><span class="sxs-lookup"><span data-stu-id="5d7a6-315">For more details, see the article on [finalizers](../programming-guide/classes-and-structs/destructors.md).</span></span>

<span data-ttu-id="5d7a6-316">Uvolňování paměti je povolená rozsáhlá Zeměpisná šířka při rozhodování o shromažďování objektů a spouštění finalizační metody.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-316">The garbage collector is allowed wide latitude in deciding when to collect objects and run finalizers.</span></span> <span data-ttu-id="5d7a6-317">Konkrétně časování volání finalizační metody není deterministické a finalizační metody mohou být provedeny v jakémkoli vlákně.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-317">Specifically, the timing of finalizer invocations isn't deterministic, and finalizers may be executed on any thread.</span></span> <span data-ttu-id="5d7a6-318">Z těchto a dalších důvodů by třídy měly implementovat finalizační metody pouze v případě, že žádná jiná řešení nejsou proveditelná.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-318">For these and other reasons, classes should implement finalizers only when no other solutions are feasible.</span></span>

<span data-ttu-id="5d7a6-319">`using`Příkaz poskytuje lepší přístup k zničení objektu.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-319">The `using` statement provides a better approach to object destruction.</span></span>

## <a name="expressions"></a><span data-ttu-id="5d7a6-320">Výrazy</span><span class="sxs-lookup"><span data-stu-id="5d7a6-320">Expressions</span></span>

<span data-ttu-id="5d7a6-321">*Výrazy* jsou vytvořené z *operandů* a *operátorů*.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-321">*Expressions* are constructed from *operands* and *operators*.</span></span> <span data-ttu-id="5d7a6-322">Operátory výrazu označují, které operace se mají použít u operandů.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-322">The operators of an expression indicate which operations to apply to the operands.</span></span> <span data-ttu-id="5d7a6-323">Příklady operátorů zahrnují `+` , `-` ,, a `*` `/` `new` .</span><span class="sxs-lookup"><span data-stu-id="5d7a6-323">Examples of operators include `+`, `-`, `*`, `/`, and `new`.</span></span> <span data-ttu-id="5d7a6-324">Příklady operandů zahrnují literály, pole, místní proměnné a výrazy.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-324">Examples of operands include literals, fields, local variables, and expressions.</span></span>

<span data-ttu-id="5d7a6-325">Pokud výraz obsahuje více operátorů, jejich *priorita* určuje pořadí, ve kterém jsou jednotlivé operátory vyhodnocovány.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-325">When an expression contains multiple operators, the *precedence* of the operators controls the order in which the individual operators are evaluated.</span></span> <span data-ttu-id="5d7a6-326">Například výraz `x + y * z` je vyhodnocen jako, `x + (y * z)` protože `*` operátor má vyšší prioritu než `+` operátor.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-326">For example, the expression `x + y * z` is evaluated as `x + (y * z)` because the `*` operator has higher precedence than the `+` operator.</span></span>

<span data-ttu-id="5d7a6-327">Když dojde k operandu mezi dvěma operátory se stejnou prioritou, *asociativita* operátor řídí pořadí, ve kterém jsou operace prováděny:</span><span class="sxs-lookup"><span data-stu-id="5d7a6-327">When an operand occurs between two operators with the same precedence, the *associativity* of the operators controls the order in which the operations are performed:</span></span>

* <span data-ttu-id="5d7a6-328">S výjimkou operátorů přiřazení a slučování s hodnotou null jsou všechny binární operátory *asociativní*, což znamená, že operace jsou prováděny zleva doprava.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-328">Except for the assignment and null-coalescing operators, all binary operators are *left-associative*, meaning that operations are performed from left to right.</span></span> <span data-ttu-id="5d7a6-329">Například `x + y + z` je vyhodnocen jako `(x + y) + z` .</span><span class="sxs-lookup"><span data-stu-id="5d7a6-329">For example, `x + y + z` is evaluated as `(x + y) + z`.</span></span>
* <span data-ttu-id="5d7a6-330">Operátory přiřazení, sloučení hodnoty null `??` a `??=` operátory a podmíněný operátor `?:` jsou *asociativní zprava*, což znamená, že operace jsou prováděny zprava doleva.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-330">The assignment operators, the null-coalescing `??` and `??=` operators, and the conditional operator `?:` are *right-associative*, meaning that operations are performed from right to left.</span></span> <span data-ttu-id="5d7a6-331">Například `x = y = z` je vyhodnocen jako `x = (y = z)` .</span><span class="sxs-lookup"><span data-stu-id="5d7a6-331">For example, `x = y = z` is evaluated as `x = (y = z)`.</span></span>

<span data-ttu-id="5d7a6-332">Priority a asociativita lze ovládat pomocí závorek.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-332">Precedence and associativity can be controlled using parentheses.</span></span> <span data-ttu-id="5d7a6-333">Například `x + y * z` první vynásobí `y` `z` a poté přidá výsledek do `x` , ale `(x + y) * z` nejprve přidá `x` a `y` a pak vynásobí výsledek hodnotou `z` .</span><span class="sxs-lookup"><span data-stu-id="5d7a6-333">For example, `x + y * z` first multiplies `y` by `z` and then adds the result to `x`, but `(x + y) * z` first adds `x` and `y` and then multiplies the result by `z`.</span></span>

<span data-ttu-id="5d7a6-334">Většina operátorů může být [*přetížená*](../language-reference/operators/operator-overloading.md).</span><span class="sxs-lookup"><span data-stu-id="5d7a6-334">Most operators can be [*overloaded*](../language-reference/operators/operator-overloading.md).</span></span> <span data-ttu-id="5d7a6-335">Přetížení operátoru umožňuje zadat uživatelsky definované implementace operátorů pro operace, u nichž jeden nebo oba operandy jsou uživatelsky definovaný typ třídy nebo struktury.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-335">Operator overloading permits user-defined operator implementations to be specified for operations where one or both of the operands are of a user-defined class or struct type.</span></span>

<span data-ttu-id="5d7a6-336">Jazyk C# poskytuje řadu operátorů pro provádění [aritmetických](../language-reference/operators/arithmetic-operators.md)operací, [logických](../language-reference/operators/boolean-logical-operators.md), [bitových a posunutí](../language-reference/operators/bitwise-and-shift-operators.md) a porovnávání [rovnosti](../language-reference/operators/equality-operators.md) a [pořadí](../language-reference/operators/comparison-operators.md) .</span><span class="sxs-lookup"><span data-stu-id="5d7a6-336">C# provides a number of operators to perform [arithmetic](../language-reference/operators/arithmetic-operators.md), [logical](../language-reference/operators/boolean-logical-operators.md), [bitwise and shift](../language-reference/operators/bitwise-and-shift-operators.md) operations and [equality](../language-reference/operators/equality-operators.md) and [order](../language-reference/operators/comparison-operators.md) comparisons.</span></span>

<span data-ttu-id="5d7a6-337">Úplný seznam operátorů jazyka C# seřazených podle priority úrovně naleznete v tématu [operátory jazyka c#](../language-reference/operators/index.md).</span><span class="sxs-lookup"><span data-stu-id="5d7a6-337">For the complete list of C# operators ordered by precedence level, see [C# operators](../language-reference/operators/index.md).</span></span>

## <a name="statements"></a><span data-ttu-id="5d7a6-338">Příkazy</span><span class="sxs-lookup"><span data-stu-id="5d7a6-338">Statements</span></span>

<span data-ttu-id="5d7a6-339">Akce programu jsou vyjádřeny pomocí *příkazů*.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-339">The actions of a program are expressed using *statements*.</span></span> <span data-ttu-id="5d7a6-340">Jazyk C# podporuje několik různých druhů příkazů, jejichž počet je definován z podmínek vložených příkazů.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-340">C# supports several different kinds of statements, a number of which are defined in terms of embedded statements.</span></span>

- <span data-ttu-id="5d7a6-341">*Blok* povoluje zápis více příkazů v kontextech, kde je povolen jediný příkaz.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-341">A *block* permits multiple statements to be written in contexts where a single statement is allowed.</span></span> <span data-ttu-id="5d7a6-342">Blok obsahuje seznam příkazů zapsaných mezi oddělovači `{` a `}` .</span><span class="sxs-lookup"><span data-stu-id="5d7a6-342">A block consists of a list of statements written between the delimiters `{` and `}`.</span></span>
- <span data-ttu-id="5d7a6-343">*Příkazy deklarace* slouží k deklaraci lokálních proměnných a konstant.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-343">*Declaration statements* are used to declare local variables and constants.</span></span>
- <span data-ttu-id="5d7a6-344">*Příkazy výrazů* se používají k vyhodnocení výrazů.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-344">*Expression statements* are used to evaluate expressions.</span></span> <span data-ttu-id="5d7a6-345">Výrazy, které lze použít jako příkazy, zahrnují vyvolání metod, přidělení objektů pomocí `new` operátoru, přiřazení pomocí `=` a operátory přiřazení, zvýšení a snížení pomocí operátorů a `++` `--` a `await` výrazů.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-345">Expressions that can be used as statements include method invocations, object allocations using the `new` operator, assignments using `=` and the compound assignment operators, increment and decrement operations using the `++` and `--` operators and `await` expressions.</span></span>
- <span data-ttu-id="5d7a6-346">*Příkazy výběru* se používají k výběru jednoho z několika možných příkazů pro spuštění na základě hodnoty nějakého výrazu.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-346">*Selection statements* are used to select one of a number of possible statements for execution based on the value of some expression.</span></span> <span data-ttu-id="5d7a6-347">Tato skupina obsahuje `if` příkazy a `switch` .</span><span class="sxs-lookup"><span data-stu-id="5d7a6-347">This group contains the `if` and `switch` statements.</span></span>
- <span data-ttu-id="5d7a6-348">*Příkazy iterace* se používají ke opakovanému provedení vloženého příkazu.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-348">*Iteration statements* are used to execute repeatedly an embedded statement.</span></span> <span data-ttu-id="5d7a6-349">Tato skupina obsahuje `while` příkazy, `do` , `for` a `foreach` .</span><span class="sxs-lookup"><span data-stu-id="5d7a6-349">This group contains the `while`, `do`, `for`, and `foreach` statements.</span></span>
- <span data-ttu-id="5d7a6-350">*Příkazy skoku* slouží k přenosu ovládacího prvku.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-350">*Jump statements* are used to transfer control.</span></span> <span data-ttu-id="5d7a6-351">Tato skupina obsahuje `break` příkazy, `continue` , `goto` , `throw` , `return` a `yield` .</span><span class="sxs-lookup"><span data-stu-id="5d7a6-351">This group contains the `break`, `continue`, `goto`, `throw`, `return`, and `yield` statements.</span></span>
- <span data-ttu-id="5d7a6-352">`try`Příkaz... slouží `catch` k zachycení výjimek, ke kterým dojde během provádění bloku, a `try` příkaz... `finally` slouží k určení konečného kódu, který je vždy spuštěn, bez ohledu na to, zda došlo k výjimce nebo nikoli.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-352">The `try`...`catch` statement is used to catch exceptions that occur during execution of a block, and the `try`...`finally` statement is used to specify finalization code that is always executed, whether an exception occurred or not.</span></span>
- <span data-ttu-id="5d7a6-353">`checked`Příkazy a `unchecked` slouží k řízení kontextu kontroly přetečení pro aritmetické operace a převody integrálního typu.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-353">The `checked` and `unchecked` statements are used to control the overflow-checking context for integral-type arithmetic operations and conversions.</span></span>
- <span data-ttu-id="5d7a6-354">`lock`Příkaz slouží k získání zámku vzájemného vyloučení pro daný objekt, spuštění příkazu a uvolnění zámku.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-354">The `lock` statement is used to obtain the mutual-exclusion lock for a given object, execute a statement, and then release the lock.</span></span>
- <span data-ttu-id="5d7a6-355">`using`Příkaz slouží k získání prostředku, spuštění příkazu a následnému uvolnění tohoto prostředku.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-355">The `using` statement is used to obtain a resource, execute a statement, and then dispose of that resource.</span></span>

<span data-ttu-id="5d7a6-356">Následující seznam uvádí typy příkazů, které lze použít:</span><span class="sxs-lookup"><span data-stu-id="5d7a6-356">The following lists the kinds of statements that can be used:</span></span>

* <span data-ttu-id="5d7a6-357">Místní deklarace proměnné</span><span class="sxs-lookup"><span data-stu-id="5d7a6-357">Local variable declaration.</span></span>
* <span data-ttu-id="5d7a6-358">Deklarace místní konstanty</span><span class="sxs-lookup"><span data-stu-id="5d7a6-358">Local constant declaration.</span></span>
* <span data-ttu-id="5d7a6-359">Příkaz výrazu.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-359">Expression statement.</span></span>
* <span data-ttu-id="5d7a6-360">`if` vydá.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-360">`if` statement.</span></span>
* <span data-ttu-id="5d7a6-361">`switch` vydá.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-361">`switch` statement.</span></span>
* <span data-ttu-id="5d7a6-362">`while` vydá.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-362">`while` statement.</span></span>
* <span data-ttu-id="5d7a6-363">`do` vydá.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-363">`do` statement.</span></span>
* <span data-ttu-id="5d7a6-364">`for` vydá.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-364">`for` statement.</span></span>
* <span data-ttu-id="5d7a6-365">`foreach` vydá.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-365">`foreach` statement.</span></span>
* <span data-ttu-id="5d7a6-366">`break` vydá.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-366">`break` statement.</span></span>
* <span data-ttu-id="5d7a6-367">`continue` vydá.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-367">`continue` statement.</span></span>
* <span data-ttu-id="5d7a6-368">`goto` vydá.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-368">`goto` statement.</span></span>
* <span data-ttu-id="5d7a6-369">`return` vydá.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-369">`return` statement.</span></span>
* <span data-ttu-id="5d7a6-370">`yield` vydá.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-370">`yield` statement.</span></span>
* <span data-ttu-id="5d7a6-371">`throw` příkazy a `try` příkazy.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-371">`throw` statements and `try` statements.</span></span>
* <span data-ttu-id="5d7a6-372">`checked``unchecked`příkazy a.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-372">`checked` and `unchecked` statements.</span></span>
* <span data-ttu-id="5d7a6-373">`lock` vydá.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-373">`lock` statement.</span></span>
* <span data-ttu-id="5d7a6-374">`using` vydá.</span><span class="sxs-lookup"><span data-stu-id="5d7a6-374">`using` statement.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="5d7a6-375">[Předchozí](types.md) 
> [Další](features.md)</span><span class="sxs-lookup"><span data-stu-id="5d7a6-375">[Previous](types.md)
[Next](features.md)</span></span>
