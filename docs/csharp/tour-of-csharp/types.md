---
title: 'Definování typů a jejich členů – prohlídka jazyka C #'
description: Stavební bloky programů jsou typy. Naučte se vytvářet třídy, struktury, rozhraní a další funkce v jazyce C#.
ms.date: 08/06/2020
ms.openlocfilehash: efd353fe8c1e6a57952bcb2586a05ad38ecd52b9
ms.sourcegitcommit: 8bfeb5930ca48b2ee6053f16082dcaf24d46d221
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 08/18/2020
ms.locfileid: "88559112"
---
# <a name="types-and-members"></a><span data-ttu-id="21efd-104">Typy a členové</span><span class="sxs-lookup"><span data-stu-id="21efd-104">Types and members</span></span>

## <a name="classes-and-objects"></a><span data-ttu-id="21efd-105">Třídy a objekty</span><span class="sxs-lookup"><span data-stu-id="21efd-105">Classes and objects</span></span>

<span data-ttu-id="21efd-106">*Třídy* jsou základem typů jazyka C#.</span><span class="sxs-lookup"><span data-stu-id="21efd-106">*Classes* are the most fundamental of C#’s types.</span></span> <span data-ttu-id="21efd-107">Třída je datová struktura, která kombinuje stav (pole) a akce (metody a další členy funkce) v jedné jednotce.</span><span class="sxs-lookup"><span data-stu-id="21efd-107">A class is a data structure that combines state (fields) and actions (methods and other function members) in a single unit.</span></span> <span data-ttu-id="21efd-108">Třída poskytuje definici pro *instance* třídy, označované také jako *objekty*.</span><span class="sxs-lookup"><span data-stu-id="21efd-108">A class provides a definition for *instances* of the class, also known as *objects*.</span></span> <span data-ttu-id="21efd-109">Třídy podporují *Dědičnost* a *polymorfismus*, mechanismy, kterými mohou *odvozené třídy* roztáhnout a specializovat *základní třídy*.</span><span class="sxs-lookup"><span data-stu-id="21efd-109">Classes support *inheritance* and *polymorphism*, mechanisms whereby *derived classes* can extend and specialize *base classes*.</span></span>

<span data-ttu-id="21efd-110">Nové třídy jsou vytvářeny pomocí deklarací třídy.</span><span class="sxs-lookup"><span data-stu-id="21efd-110">New classes are created using class declarations.</span></span> <span data-ttu-id="21efd-111">Deklarace třídy začíná hlavičkou.</span><span class="sxs-lookup"><span data-stu-id="21efd-111">A class declaration starts with a header.</span></span> <span data-ttu-id="21efd-112">Záhlaví určuje:</span><span class="sxs-lookup"><span data-stu-id="21efd-112">The header specifies:</span></span>

- <span data-ttu-id="21efd-113">Atributy a modifikátory třídy</span><span class="sxs-lookup"><span data-stu-id="21efd-113">The attributes and modifiers of the class</span></span>
- <span data-ttu-id="21efd-114">Název třídy</span><span class="sxs-lookup"><span data-stu-id="21efd-114">The name of the class</span></span>
- <span data-ttu-id="21efd-115">Základní třída (při dědění ze [základní třídy](#base-classes))</span><span class="sxs-lookup"><span data-stu-id="21efd-115">The base class (when inheriting from a [base class](#base-classes))</span></span>
- <span data-ttu-id="21efd-116">Rozhraní implementovaná třídou.</span><span class="sxs-lookup"><span data-stu-id="21efd-116">The interfaces implemented by the class.</span></span>

<span data-ttu-id="21efd-117">Pod hlavičkou následuje tělo třídy, které se skládá ze seznamu deklarací členů napsaných mezi oddělovači `{` a `}` .</span><span class="sxs-lookup"><span data-stu-id="21efd-117">The header is followed by the class body, which consists of a list of member declarations written between the delimiters `{` and `}`.</span></span>

<span data-ttu-id="21efd-118">Následující kód ukazuje deklaraci jednoduché třídy s názvem `Point` :</span><span class="sxs-lookup"><span data-stu-id="21efd-118">The following code shows a declaration of a simple class named `Point`:</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="PointClass":::

<span data-ttu-id="21efd-119">Instance tříd jsou vytvořeny pomocí `new` operátoru, který přiděluje paměť pro novou instanci, vyvolá konstruktor pro inicializaci instance a vrátí odkaz na instanci.</span><span class="sxs-lookup"><span data-stu-id="21efd-119">Instances of classes are created using the `new` operator, which allocates memory for a new instance, invokes a constructor to initialize the instance, and returns a reference to the instance.</span></span> <span data-ttu-id="21efd-120">Následující příkazy vytvoří dva `Point` objekty a ukládají odkazy na tyto objekty ve dvou proměnných:</span><span class="sxs-lookup"><span data-stu-id="21efd-120">The following statements create two `Point` objects and store references to those objects in two variables:</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="CreatePoints":::

<span data-ttu-id="21efd-121">Paměť obsazená objektem je automaticky uvolněna v případě, že objekt již není dostupný.</span><span class="sxs-lookup"><span data-stu-id="21efd-121">The memory occupied by an object is automatically reclaimed when the object is no longer reachable.</span></span> <span data-ttu-id="21efd-122">Není ani možné explicitně uvolnit objekty v jazyce C#.</span><span class="sxs-lookup"><span data-stu-id="21efd-122">It's neither necessary nor possible to explicitly deallocate objects in C#.</span></span>

### <a name="type-parameters"></a><span data-ttu-id="21efd-123">Parametry typu</span><span class="sxs-lookup"><span data-stu-id="21efd-123">Type parameters</span></span>

<span data-ttu-id="21efd-124">Obecné třídy definují [***parametry typu***](../programming-guide/generics/index.md).</span><span class="sxs-lookup"><span data-stu-id="21efd-124">Generic classes define [***type parameters***](../programming-guide/generics/index.md).</span></span> <span data-ttu-id="21efd-125">Parametry typu jsou seznam názvů parametrů typu uzavřených do lomených závorek.</span><span class="sxs-lookup"><span data-stu-id="21efd-125">Type parameters are a list of type parameter names enclosed in angle brackets.</span></span> <span data-ttu-id="21efd-126">Parametry typu následují za názvem třídy.</span><span class="sxs-lookup"><span data-stu-id="21efd-126">Type parameters follow the class name.</span></span> <span data-ttu-id="21efd-127">Parametry typu lze potom použít v těle deklarací třídy k definování členů třídy.</span><span class="sxs-lookup"><span data-stu-id="21efd-127">The type parameters can then be used in the body of the class declarations to define the members of the class.</span></span> <span data-ttu-id="21efd-128">V následujícím příkladu parametry typu `Pair` jsou `TFirst` a `TSecond` :</span><span class="sxs-lookup"><span data-stu-id="21efd-128">In the following example, the type parameters of `Pair` are `TFirst` and `TSecond`:</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="DefinePairClass":::

<span data-ttu-id="21efd-129">Typ třídy, která je deklarována pro přijetí parametrů typu, se nazývá *typ obecné třídy*.</span><span class="sxs-lookup"><span data-stu-id="21efd-129">A class type that is declared to take type parameters is called a *generic class type*.</span></span> <span data-ttu-id="21efd-130">Typy struktury, rozhraní a delegátů můžou být také obecné.</span><span class="sxs-lookup"><span data-stu-id="21efd-130">Struct, interface, and delegate types can also be generic.</span></span>
<span data-ttu-id="21efd-131">Při použití obecné třídy je nutné zadat argumenty typu pro každý z parametrů typu:</span><span class="sxs-lookup"><span data-stu-id="21efd-131">When the generic class is used, type arguments must be provided for each of the type parameters:</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="CreatePairObject":::

<span data-ttu-id="21efd-132">Obecný typ s poskytnutými argumenty typu, jako `Pair<int,string>` je například výše, se označuje jako *konstruovaný typ*.</span><span class="sxs-lookup"><span data-stu-id="21efd-132">A generic type with type arguments provided, like `Pair<int,string>` above, is called a *constructed type*.</span></span>

### <a name="base-classes"></a><span data-ttu-id="21efd-133">Základní třídy</span><span class="sxs-lookup"><span data-stu-id="21efd-133">Base classes</span></span>

<span data-ttu-id="21efd-134">Deklarace třídy může určovat základní třídu.</span><span class="sxs-lookup"><span data-stu-id="21efd-134">A class declaration may specify a base class.</span></span> <span data-ttu-id="21efd-135">Použijte název třídy a parametry typu s dvojtečkou a názvem základní třídy.</span><span class="sxs-lookup"><span data-stu-id="21efd-135">Follow the class name and type parameters with a colon and the name of the base class.</span></span> <span data-ttu-id="21efd-136">Vynechání specifikace základní třídy je stejné jako odvození z typu `object` .</span><span class="sxs-lookup"><span data-stu-id="21efd-136">Omitting a base class specification is the same as deriving from type `object`.</span></span> <span data-ttu-id="21efd-137">V následujícím příkladu je základní třída třídy `Point3D` `Point` .</span><span class="sxs-lookup"><span data-stu-id="21efd-137">In the following example, the base class of `Point3D` is `Point`.</span></span> <span data-ttu-id="21efd-138">V prvním příkladu je základní třída `Point` `object` :</span><span class="sxs-lookup"><span data-stu-id="21efd-138">From the first example, the base class of `Point` is `object`:</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="Create3DPoint":::

<span data-ttu-id="21efd-139">Třída dědí členy své základní třídy.</span><span class="sxs-lookup"><span data-stu-id="21efd-139">A class inherits the members of its base class.</span></span> <span data-ttu-id="21efd-140">Dědičnost znamená, že třída implicitně obsahuje skoro všechny členy své základní třídy.</span><span class="sxs-lookup"><span data-stu-id="21efd-140">Inheritance means that a class implicitly contains almost all members of its base class.</span></span> <span data-ttu-id="21efd-141">Třída nedědí instance a statické konstruktory a finalizační metodu.</span><span class="sxs-lookup"><span data-stu-id="21efd-141">A class doesn't inherit the instance and static constructors, and the finalizer.</span></span> <span data-ttu-id="21efd-142">Odvozená třída může přidat nové členy do těch členů, které dědí, ale nemůže odebrat definici zděděného člena.</span><span class="sxs-lookup"><span data-stu-id="21efd-142">A derived class can add new members to those members it inherits, but it can't remove the definition of an inherited member.</span></span> <span data-ttu-id="21efd-143">V předchozím příkladu `Point3D` dědí `X` `Y` Členové a z `Point` a každá `Point3D` instance obsahuje tři vlastnosti, `X` , `Y` a `Z` .</span><span class="sxs-lookup"><span data-stu-id="21efd-143">In the previous example, `Point3D` inherits the `X` and `Y` members from `Point`, and every `Point3D` instance contains three properties, `X`, `Y`, and `Z`.</span></span>

<span data-ttu-id="21efd-144">Implicitní převod existuje z typu třídy na libovolný z jeho základních typů třídy.</span><span class="sxs-lookup"><span data-stu-id="21efd-144">An implicit conversion exists from a class type to any of its base class types.</span></span> <span data-ttu-id="21efd-145">Proměnná typu třídy může odkazovat na instanci této třídy nebo instance jakékoli odvozené třídy.</span><span class="sxs-lookup"><span data-stu-id="21efd-145">A variable of a class type can reference an instance of that class or an instance of any derived class.</span></span> <span data-ttu-id="21efd-146">Například s ohledem na předchozí deklarace třídy může proměnná typu `Point` odkazovat buď na, `Point` nebo `Point3D` :</span><span class="sxs-lookup"><span data-stu-id="21efd-146">For example, given the previous class declarations, a variable of type `Point` can reference either a `Point` or a `Point3D`:</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="ImplicitCastToBase":::

## <a name="structs"></a><span data-ttu-id="21efd-147">Struktury</span><span class="sxs-lookup"><span data-stu-id="21efd-147">Structs</span></span>

<span data-ttu-id="21efd-148">Třídy definují typy, které podporují dědičnost a polymorfismuy.</span><span class="sxs-lookup"><span data-stu-id="21efd-148">Classes define types that support inheritance and polymorphism.</span></span> <span data-ttu-id="21efd-149">Umožňují vytvářet sofistikovaná chování založená na hierarchiích odvozených tříd.</span><span class="sxs-lookup"><span data-stu-id="21efd-149">They enable you to create sophisticated behaviors based on hierarchies of derived classes.</span></span> <span data-ttu-id="21efd-150">Naopak typy [***struktury***](../language-reference/builtin-types/struct.md) jsou jednodušší typy, jejichž primárním účelem je ukládání hodnot dat.</span><span class="sxs-lookup"><span data-stu-id="21efd-150">By contrast, [***struct***](../language-reference/builtin-types/struct.md) types are simpler types whose primary purpose is to store data values.</span></span> <span data-ttu-id="21efd-151">Struktury nemůžou deklarovat základní typ; implicitně se odvozují z <xref:System.ValueType?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="21efd-151">Structs can't declare a base type; they implicitly derive from <xref:System.ValueType?displayProperty=nameWithType>.</span></span> <span data-ttu-id="21efd-152">Z typu nelze odvodit jiné `struct` typy `struct` .</span><span class="sxs-lookup"><span data-stu-id="21efd-152">You can't derive other `struct` types from a `struct` type.</span></span> <span data-ttu-id="21efd-153">Jsou implicitně zapečetěné.</span><span class="sxs-lookup"><span data-stu-id="21efd-153">They're implicitly sealed.</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="PointStruct":::

## <a name="interfaces"></a><span data-ttu-id="21efd-154">Rozhraní</span><span class="sxs-lookup"><span data-stu-id="21efd-154">Interfaces</span></span>

<span data-ttu-id="21efd-155">[***Rozhraní***](../programming-guide/interfaces/index.md) definuje kontrakt, který může být implementován pomocí tříd a struktur.</span><span class="sxs-lookup"><span data-stu-id="21efd-155">An [***interface***](../programming-guide/interfaces/index.md) defines a contract that can be implemented by classes and structs.</span></span> <span data-ttu-id="21efd-156">Rozhraní může obsahovat metody, vlastnosti, události a indexery.</span><span class="sxs-lookup"><span data-stu-id="21efd-156">An interface can contain methods, properties, events, and indexers.</span></span> <span data-ttu-id="21efd-157">Rozhraní obvykle neposkytuje implementace členů, které definuje – určuje pouze členy, které musí být poskytnuty třídami nebo strukturami, které implementují rozhraní.</span><span class="sxs-lookup"><span data-stu-id="21efd-157">An interface typically doesn't provide implementations of the members it defines—it merely specifies the members that must be supplied by classes or structs that implement the interface.</span></span>

<span data-ttu-id="21efd-158">Rozhraní mohou využívat ***vícenásobnou dědičnost***.</span><span class="sxs-lookup"><span data-stu-id="21efd-158">Interfaces may employ ***multiple inheritance***.</span></span> <span data-ttu-id="21efd-159">V následujícím příkladu rozhraní `IComboBox` dědí z `ITextBox` a `IListBox` .</span><span class="sxs-lookup"><span data-stu-id="21efd-159">In the following example, the interface `IComboBox` inherits from both `ITextBox` and `IListBox`.</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="FirstInterfaces":::

<span data-ttu-id="21efd-160">Třídy a struktury mohou implementovat více rozhraní.</span><span class="sxs-lookup"><span data-stu-id="21efd-160">Classes and structs can implement multiple interfaces.</span></span> <span data-ttu-id="21efd-161">V následujícím příkladu třída `EditBox` implementuje i `IControl` `IDataBound` .</span><span class="sxs-lookup"><span data-stu-id="21efd-161">In the following example, the class `EditBox` implements both `IControl` and `IDataBound`.</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="ImplementInterfaces":::

<span data-ttu-id="21efd-162">Pokud třída nebo struktura implementuje konkrétní rozhraní, instance této třídy nebo struktury lze implicitně převést na tento typ rozhraní.</span><span class="sxs-lookup"><span data-stu-id="21efd-162">When a class or struct implements a particular interface, instances of that class or struct can be implicitly converted to that interface type.</span></span> <span data-ttu-id="21efd-163">Například</span><span class="sxs-lookup"><span data-stu-id="21efd-163">For example</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="UseInterfaces":::

## <a name="enums"></a><span data-ttu-id="21efd-164">Výčty</span><span class="sxs-lookup"><span data-stu-id="21efd-164">Enums</span></span>

<span data-ttu-id="21efd-165">Typ [***výčtu***](../language-reference/builtin-types/enum.md) definuje sadu konstantních hodnot.</span><span class="sxs-lookup"><span data-stu-id="21efd-165">An [***Enum***](../language-reference/builtin-types/enum.md) type defines a set of constant values.</span></span> <span data-ttu-id="21efd-166">Následující `enum` deklaruje konstanty, které definují jinou kořenovou zeleninu:</span><span class="sxs-lookup"><span data-stu-id="21efd-166">The following `enum` declares constants that define different root vegetables:</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="EnumDeclaration":::

<span data-ttu-id="21efd-167">Můžete také definovat `enum` , který má být použit v kombinaci jako příznaky.</span><span class="sxs-lookup"><span data-stu-id="21efd-167">You can also define an `enum` to be used in combination as flags.</span></span> <span data-ttu-id="21efd-168">Následující deklarace deklaruje sadu příznaků pro čtyři období.</span><span class="sxs-lookup"><span data-stu-id="21efd-168">The following declaration declares a set of flags for the four seasons.</span></span> <span data-ttu-id="21efd-169">Může se použít libovolná kombinace období, včetně `All` hodnoty, která zahrnuje všechny sezóny:</span><span class="sxs-lookup"><span data-stu-id="21efd-169">Any combination of the seasons may be applied, including an `All` value that includes all seasons:</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="FlagsEnumDeclaration":::

<span data-ttu-id="21efd-170">Následující příklad ukazuje deklarace obou předchozích výčtů:</span><span class="sxs-lookup"><span data-stu-id="21efd-170">The following example shows declarations of both the preceding enums:</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="UsingEnums":::

## <a name="nullable-types"></a><span data-ttu-id="21efd-171">Typy nullable</span><span class="sxs-lookup"><span data-stu-id="21efd-171">Nullable types</span></span>

<span data-ttu-id="21efd-172">Proměnné libovolného typu mohou být deklarovány jako ***nenulové nebo*** ***null***.</span><span class="sxs-lookup"><span data-stu-id="21efd-172">Variables of any type may be declared as ***non-nullable*** or ***nullable***.</span></span> <span data-ttu-id="21efd-173">Proměnná s možnou hodnotou null může obsahovat další `null` hodnotu, což značí, že žádná hodnota neexistuje.</span><span class="sxs-lookup"><span data-stu-id="21efd-173">A nullable variable can hold an additional `null` value, indicating no value.</span></span> <span data-ttu-id="21efd-174">Typy hodnot s možnou hodnotou null (struktury nebo výčty) jsou reprezentovány <xref:System.Nullable%601?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="21efd-174">Nullable Value types (structs or enums) are represented by <xref:System.Nullable%601?displayProperty=nameWithType>.</span></span> <span data-ttu-id="21efd-175">Typy odkazů, které nejsou null a povolující hodnotu null, jsou reprezentované podkladovým typem odkazu.</span><span class="sxs-lookup"><span data-stu-id="21efd-175">Non-nullable and Nullable Reference types are both represented by the underlying reference type.</span></span> <span data-ttu-id="21efd-176">Rozlišení je reprezentované metadaty, které načte kompilátor a některé knihovny.</span><span class="sxs-lookup"><span data-stu-id="21efd-176">The distinction is represented by metadata read by the compiler and some libraries.</span></span> <span data-ttu-id="21efd-177">Kompilátor poskytuje upozornění, když jsou odkazy na hodnotu null překážené bez prvotní kontroly jejich hodnoty `null` .</span><span class="sxs-lookup"><span data-stu-id="21efd-177">The compiler provides warnings when nullable references are dereferenced without first checking their value against `null`.</span></span> <span data-ttu-id="21efd-178">Kompilátor také poskytuje upozornění, pokud jsou odkazy, které nejsou null, přiřazeny hodnotě, která může být `null` .</span><span class="sxs-lookup"><span data-stu-id="21efd-178">The compiler also provides warnings when non-nullable references are assigned a value that may be `null`.</span></span> <span data-ttu-id="21efd-179">Následující příklad deklaruje ***hodnotu null int***a inicializuje ji na `null` .</span><span class="sxs-lookup"><span data-stu-id="21efd-179">The following example declares a ***nullable int***, initializing it to `null`.</span></span> <span data-ttu-id="21efd-180">Potom nastaví hodnotu na `5` .</span><span class="sxs-lookup"><span data-stu-id="21efd-180">Then, it sets the value to `5`.</span></span> <span data-ttu-id="21efd-181">Ukazuje stejný koncept s ***připouštějící řetězec s možnou hodnotou null***.</span><span class="sxs-lookup"><span data-stu-id="21efd-181">It demonstrates the same concept with a ***nullable string***.</span></span> <span data-ttu-id="21efd-182">Další informace naleznete v tématu [typy hodnot](../language-reference/builtin-types/nullable-value-types.md) s možnou hodnotou null a [odkazy s možnou hodnotou null](../nullable-references.md).</span><span class="sxs-lookup"><span data-stu-id="21efd-182">For more information, see [nullable value types](../language-reference/builtin-types/nullable-value-types.md) and [nullable reference types](../nullable-references.md).</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="DeclareNullable":::

## <a name="tuples"></a><span data-ttu-id="21efd-183">N-tice</span><span class="sxs-lookup"><span data-stu-id="21efd-183">Tuples</span></span>

<span data-ttu-id="21efd-184">Jazyk C# podporuje [***řazené kolekce členů***](../language-reference/builtin-types/value-tuples.md), které poskytují stručnou syntaxi pro seskupení více datových prvků ve zjednodušené datové struktuře.</span><span class="sxs-lookup"><span data-stu-id="21efd-184">C# supports [***tuples***](../language-reference/builtin-types/value-tuples.md), which provides concise syntax to group multiple data elements in a lightweight data structure.</span></span> <span data-ttu-id="21efd-185">Vytvořte instanci řazené kolekce členů deklarováním typů a názvů členů mezi `(` a `)` , jak je znázorněno v následujícím příkladu:</span><span class="sxs-lookup"><span data-stu-id="21efd-185">You instantiate a tuple by declaring the types and names of the members between `(` and `)`, as shown in the following example:</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="DeclareTuples":::

<span data-ttu-id="21efd-186">Řazené kolekce členů poskytují alternativu pro strukturu dat s více členy, bez použití stavebních bloků popsaných v dalším článku.</span><span class="sxs-lookup"><span data-stu-id="21efd-186">Tuples provide an alternative for data structure with multiple members, without using the building blocks described in the next article.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="21efd-187">[Předchozí](index.md) 
> [Další](program-building-blocks.md)</span><span class="sxs-lookup"><span data-stu-id="21efd-187">[Previous](index.md)
[Next](program-building-blocks.md)</span></span>
