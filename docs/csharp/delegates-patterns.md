---
title: Obecné vzory pro delegáty
description: Přečtěte si o běžných vzorech pro používání delegátů ve vašem kódu, abyste zabránili silnému propojení mezi vašimi komponentami.
ms.date: 06/20/2016
ms.assetid: 0ff8fdfd-6a11-4327-b061-0f2526f35b43
ms.openlocfilehash: 40e6ced7337e32d6e9b67b12a15ad7e03a77c4b6
ms.sourcegitcommit: 43d10ef65f0f1fd6c3b515e363bde11a3fcd8d6d
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 03/03/2020
ms.locfileid: "78239869"
---
# <a name="common-patterns-for-delegates"></a><span data-ttu-id="27897-103">Obecné vzory pro delegáty</span><span class="sxs-lookup"><span data-stu-id="27897-103">Common Patterns for Delegates</span></span>

[<span data-ttu-id="27897-104">Předchozí</span><span class="sxs-lookup"><span data-stu-id="27897-104">Previous</span></span>](delegates-strongly-typed.md)

<span data-ttu-id="27897-105">Delegáti poskytují mechanismus, který umožňuje vytvářet návrhy softwaru zahrnující minimální propojení mezi komponentami.</span><span class="sxs-lookup"><span data-stu-id="27897-105">Delegates provide a mechanism that enables software designs involving minimal coupling between components.</span></span>

<span data-ttu-id="27897-106">Jedním z skvělých příkladů tohoto druhu návrhu je LINQ.</span><span class="sxs-lookup"><span data-stu-id="27897-106">One excellent example for this kind of design is LINQ.</span></span> <span data-ttu-id="27897-107">Vzor výrazu dotazu LINQ spoléhá na delegáty všech jeho funkcí.</span><span class="sxs-lookup"><span data-stu-id="27897-107">The LINQ Query Expression Pattern relies on delegates for all of its features.</span></span> <span data-ttu-id="27897-108">Vezměte v úvahu tento jednoduchý příklad:</span><span class="sxs-lookup"><span data-stu-id="27897-108">Consider this simple example:</span></span>

```csharp
var smallNumbers = numbers.Where(n => n < 10);
```

<span data-ttu-id="27897-109">Tím se vyfiltruje posloupnost čísel jenom na hodnoty, které jsou menší než hodnota 10.</span><span class="sxs-lookup"><span data-stu-id="27897-109">This filters the sequence of numbers to only those less than the value 10.</span></span>
<span data-ttu-id="27897-110">Metoda `Where` používá delegáta, který určuje, které prvky sekvence předejte filtru.</span><span class="sxs-lookup"><span data-stu-id="27897-110">The `Where` method uses a delegate that determines which elements of a sequence pass the filter.</span></span> <span data-ttu-id="27897-111">Když vytvoříte dotaz LINQ, zadáváte implementaci delegáta pro tento konkrétní účel.</span><span class="sxs-lookup"><span data-stu-id="27897-111">When you create a LINQ query, you supply the implementation of the delegate for this specific purpose.</span></span>

<span data-ttu-id="27897-112">Prototyp pro metodu WHERE je:</span><span class="sxs-lookup"><span data-stu-id="27897-112">The prototype for the Where method is:</span></span>

```csharp
public static IEnumerable<TSource> Where<TSource> (this IEnumerable<TSource> source, Func<TSource, bool> predicate);
```

<span data-ttu-id="27897-113">Tento příklad se opakuje se všemi metodami, které jsou součástí LINQ.</span><span class="sxs-lookup"><span data-stu-id="27897-113">This example is repeated with all the methods that are part of LINQ.</span></span> <span data-ttu-id="27897-114">Všichni spoléhají na delegáty pro kód, který spravuje konkrétní dotaz.</span><span class="sxs-lookup"><span data-stu-id="27897-114">They all rely on delegates for the code that manages the specific query.</span></span> <span data-ttu-id="27897-115">Tento vzor návrhu rozhraní API je velmi výkonným, abyste se dozvěděli a pochopili.</span><span class="sxs-lookup"><span data-stu-id="27897-115">This API design pattern is a very powerful one to learn and understand.</span></span>

<span data-ttu-id="27897-116">Tento jednoduchý příklad ukazuje, jak Delegáti vyžadují velmi malé propojení mezi komponentami.</span><span class="sxs-lookup"><span data-stu-id="27897-116">This simple example illustrates how delegates require very little coupling between components.</span></span> <span data-ttu-id="27897-117">Nemusíte vytvářet třídu, která je odvozena z konkrétní základní třídy.</span><span class="sxs-lookup"><span data-stu-id="27897-117">You don't need to create a class that derives from a particular base class.</span></span> <span data-ttu-id="27897-118">Nemusíte implementovat konkrétní rozhraní.</span><span class="sxs-lookup"><span data-stu-id="27897-118">You don't need to implement a specific interface.</span></span>
<span data-ttu-id="27897-119">Jediným požadavkem je poskytnout implementaci jedné metody, která je pro úkol zásadní.</span><span class="sxs-lookup"><span data-stu-id="27897-119">The only requirement is to provide the implementation of one method that is fundamental to the task at hand.</span></span>

## <a name="building-your-own-components-with-delegates"></a><span data-ttu-id="27897-120">Vytváření vlastních komponent s delegáty</span><span class="sxs-lookup"><span data-stu-id="27897-120">Building Your Own Components with Delegates</span></span>

<span data-ttu-id="27897-121">Pojďme tento příklad sestavit vytvořením komponenty pomocí návrhu, který spoléhá na delegáty.</span><span class="sxs-lookup"><span data-stu-id="27897-121">Let's build on that example by creating a component using a design that relies on delegates.</span></span>

<span data-ttu-id="27897-122">Pojďme definovat komponentu, která se dá použít pro zprávy protokolu ve velkém systému.</span><span class="sxs-lookup"><span data-stu-id="27897-122">Let's define a component that could be used for log messages in a large system.</span></span> <span data-ttu-id="27897-123">Komponenty knihovny lze v mnoha různých prostředích použít na více různých platformách.</span><span class="sxs-lookup"><span data-stu-id="27897-123">The library components could be used in many different environments, on multiple different platforms.</span></span> <span data-ttu-id="27897-124">Komponenta, která spravuje protokoly, obsahuje spoustu běžných funkcí.</span><span class="sxs-lookup"><span data-stu-id="27897-124">There are a lot of common features in the component that manages the logs.</span></span> <span data-ttu-id="27897-125">Bude muset přijímat zprávy ze všech součástí systému.</span><span class="sxs-lookup"><span data-stu-id="27897-125">It will need to accept messages from any component in the system.</span></span> <span data-ttu-id="27897-126">Tyto zprávy budou mít různé priority, které může základní komponenta spravovat.</span><span class="sxs-lookup"><span data-stu-id="27897-126">Those messages will have different priorities, which the core component can manage.</span></span> <span data-ttu-id="27897-127">Zprávy by měly mít v konečném archivovaném formuláři časová razítka.</span><span class="sxs-lookup"><span data-stu-id="27897-127">The messages should have timestamps in their final archived form.</span></span> <span data-ttu-id="27897-128">V případě pokročilejších scénářů můžete zprávy filtrovat pomocí zdrojové součásti.</span><span class="sxs-lookup"><span data-stu-id="27897-128">For more advanced scenarios, you could filter messages by the source component.</span></span>

<span data-ttu-id="27897-129">K dispozici je jeden aspekt funkce, která se bude často měnit: kde se zapisují zprávy.</span><span class="sxs-lookup"><span data-stu-id="27897-129">There is one aspect of the feature that will change often: where messages are written.</span></span> <span data-ttu-id="27897-130">V některých prostředích se můžou zapisovat do chybové konzoly.</span><span class="sxs-lookup"><span data-stu-id="27897-130">In some environments, they may be written to the error console.</span></span> <span data-ttu-id="27897-131">V ostatních souborech soubor.</span><span class="sxs-lookup"><span data-stu-id="27897-131">In others, a file.</span></span> <span data-ttu-id="27897-132">Mezi další možnosti patří úložiště databáze, protokoly událostí operačního systému nebo jiné úložiště dokumentů.</span><span class="sxs-lookup"><span data-stu-id="27897-132">Other possibilities include database storage, OS event logs, or other document storage.</span></span>

<span data-ttu-id="27897-133">Existují také kombinace výstupů, které mohou být používány v různých scénářích.</span><span class="sxs-lookup"><span data-stu-id="27897-133">There are also combinations of output that might be used in different scenarios.</span></span> <span data-ttu-id="27897-134">Můžete chtít napsat zprávy do konzoly a do souboru.</span><span class="sxs-lookup"><span data-stu-id="27897-134">You may want to write messages to the console and to a file.</span></span>

<span data-ttu-id="27897-135">Návrh založený na delegátech poskytne značnou flexibilitu a usnadňuje podporu mechanismů úložiště, které mohou být přidány do budoucna.</span><span class="sxs-lookup"><span data-stu-id="27897-135">A design based on delegates will provide a great deal of flexibility, and make it easy to support storage mechanisms that may be added in the future.</span></span>

<span data-ttu-id="27897-136">V rámci tohoto návrhu může být primární součástí protokolu nevirtuální, sudá i zapečetěná třída.</span><span class="sxs-lookup"><span data-stu-id="27897-136">Under this design, the primary log component can be a non-virtual, even sealed class.</span></span> <span data-ttu-id="27897-137">Můžete připojit libovolnou sadu delegátů a zapsat zprávy na jiná úložná média.</span><span class="sxs-lookup"><span data-stu-id="27897-137">You can plug in any set of delegates to write the messages to different storage media.</span></span> <span data-ttu-id="27897-138">Integrovaná podpora pro delegáty vícesměrového vysílání usnadňuje podporu scénářů, ve kterých je nutné zapsat zprávy do více umístění (soubor a konzolu).</span><span class="sxs-lookup"><span data-stu-id="27897-138">The built in support for multicast delegates makes it easy to support scenarios where messages must be written to multiple locations (a file, and a console).</span></span>

## <a name="a-first-implementation"></a><span data-ttu-id="27897-139">První implementace</span><span class="sxs-lookup"><span data-stu-id="27897-139">A First Implementation</span></span>

<span data-ttu-id="27897-140">Pojďme začít malým: počáteční implementace přijme nové zprávy a zapíše je pomocí kteréhokoli připojeného delegáta.</span><span class="sxs-lookup"><span data-stu-id="27897-140">Let's start small: the initial implementation will accept new messages, and write them using any attached delegate.</span></span> <span data-ttu-id="27897-141">Můžete začít s jedním delegátem, který zapisuje zprávy do konzoly.</span><span class="sxs-lookup"><span data-stu-id="27897-141">You can start with one delegate that writes messages to the console.</span></span>

[!code-csharp[LoggerImplementation](../../samples/snippets/csharp/delegates-and-events/Logger.cs#FirstImplementation "A first Logger implementation.")]

<span data-ttu-id="27897-142">Výše uvedená statická třída je nejjednodušší věc, která může fungovat.</span><span class="sxs-lookup"><span data-stu-id="27897-142">The static class above is the simplest thing that can work.</span></span> <span data-ttu-id="27897-143">Musíme napsat jednu implementaci pro metodu, která zapisuje zprávy do konzoly:</span><span class="sxs-lookup"><span data-stu-id="27897-143">We need to write the single implementation for the method that writes messages to the console:</span></span> 

[!code-csharp[LogToConsole](../../samples/snippets/csharp/delegates-and-events/LoggingMethods.cs#LogToConsole "A Console logger.")]

<span data-ttu-id="27897-144">Nakonec musíte připojit delegáta tak, že ho připojíte k delegátovi WriteMessage deklarovanému v protokolovacím nástroji:</span><span class="sxs-lookup"><span data-stu-id="27897-144">Finally, you need to hook up the delegate by attaching it to the WriteMessage delegate declared in the logger:</span></span>

[!code-csharp[ConnectDelegate](../../samples/snippets/csharp/delegates-and-events/Program.cs#ConnectDelegate "Connect to the delegate")]

## <a name="practices"></a><span data-ttu-id="27897-145">Způsobů</span><span class="sxs-lookup"><span data-stu-id="27897-145">Practices</span></span>

<span data-ttu-id="27897-146">Naše ukázka je tak poměrně jednoduchá, ale stále předvádí některé důležité pokyny pro návrhy zahrnující delegáty.</span><span class="sxs-lookup"><span data-stu-id="27897-146">Our sample so far is fairly simple, but it still demonstrates some of the important guidelines for designs involving delegates.</span></span>

<span data-ttu-id="27897-147">Použití typů delegátů definovaných v rozhraní Core usnadňuje uživatelům práci s delegáty.</span><span class="sxs-lookup"><span data-stu-id="27897-147">Using the delegate types defined in the Core Framework makes it easier for users to work with the delegates.</span></span> <span data-ttu-id="27897-148">Nemusíte definovat nové typy a vývojáři, kteří používají vaši knihovnu, nemusejí učit nové, specializované typy delegátů.</span><span class="sxs-lookup"><span data-stu-id="27897-148">You don't need to define new types, and developers using your library do not need to learn new, specialized delegate types.</span></span>

<span data-ttu-id="27897-149">Použitá rozhraní jsou co nejmenší a co nejpružnější: pro vytvoření nového výstupního protokolovacího nástroje je nutné vytvořit jednu metodu.</span><span class="sxs-lookup"><span data-stu-id="27897-149">The interfaces used are as minimal and as flexible as possible: To create a new output logger, you must create one method.</span></span> <span data-ttu-id="27897-150">Tato metoda může být statickou metodou nebo metodou instance.</span><span class="sxs-lookup"><span data-stu-id="27897-150">That method may be a static method, or an instance method.</span></span> <span data-ttu-id="27897-151">Může mít jakýkoliv přístup.</span><span class="sxs-lookup"><span data-stu-id="27897-151">It may have any access.</span></span>

## <a name="formatting-output"></a><span data-ttu-id="27897-152">Formátování výstupu</span><span class="sxs-lookup"><span data-stu-id="27897-152">Formatting Output</span></span>

<span data-ttu-id="27897-153">Pojďme tuto první verzi udělat trochu robustnější a pak začít vytvářet další mechanismy protokolování.</span><span class="sxs-lookup"><span data-stu-id="27897-153">Let's make this first version a bit more robust, and then start creating other logging mechanisms.</span></span>

<span data-ttu-id="27897-154">Nyní přidáme do metody `LogMessage()` několik argumentů, aby vaše třída protokolu vytvořila více strukturovaných zpráv:</span><span class="sxs-lookup"><span data-stu-id="27897-154">Next, let's add a few arguments to the `LogMessage()` method so that your log class creates more structured messages:</span></span>

[!code-csharp[Severity](../../samples/snippets/csharp/delegates-and-events/Logger.cs#Severity "Define severities")]
[!code-csharp[NextLogger](../../samples/snippets/csharp/delegates-and-events/Logger.cs#LoggerTwo "Refine the Logger")]

<span data-ttu-id="27897-155">Teď využijeme tento argument `Severity` k filtrování zpráv, které se odesílají do výstupu protokolu.</span><span class="sxs-lookup"><span data-stu-id="27897-155">Next, let's make use of that `Severity` argument to filter the messages that are sent to the log's output.</span></span> 

[!code-csharp[FinalLogger](../../samples/snippets/csharp/delegates-and-events/Logger.cs#LoggerFinal "Finish the Logger")]

## <a name="practices"></a><span data-ttu-id="27897-156">Způsobů</span><span class="sxs-lookup"><span data-stu-id="27897-156">Practices</span></span>

<span data-ttu-id="27897-157">Do infrastruktury protokolování jste přidali nové funkce.</span><span class="sxs-lookup"><span data-stu-id="27897-157">You've added new features to the logging infrastructure.</span></span> <span data-ttu-id="27897-158">Vzhledem k tomu, že komponenta protokolovacího nástroje je velmi volně spojená s jakýmkoliv výstupním mechanismem, je možné tyto nové funkce přidat bez dopadu na žádný kód implementující delegáta protokolovacího nástroje.</span><span class="sxs-lookup"><span data-stu-id="27897-158">Because the logger component is very loosely coupled to any output mechanism, these new features can be added with no impact on any of the code implementing the logger delegate.</span></span>

<span data-ttu-id="27897-159">V takovém případě se zobrazí další příklady toho, jak toto volné spojení umožňuje větší flexibilitu při aktualizaci částí webu bez jakýchkoli změn v jiných umístěních.</span><span class="sxs-lookup"><span data-stu-id="27897-159">As you keep building this, you'll see more examples of how this loose coupling enables greater flexibility in updating parts of the site without any changes to other locations.</span></span> <span data-ttu-id="27897-160">Ve skutečnosti může být ve větší aplikaci výstupní třídy protokolovacího nástroje v jiném sestavení a ještě není nutné je znovu sestavit.</span><span class="sxs-lookup"><span data-stu-id="27897-160">In fact, in a larger application, the logger output classes might be in a different assembly, and not even need to be rebuilt.</span></span>

## <a name="building-a-second-output-engine"></a><span data-ttu-id="27897-161">Vytvoření druhého výstupního modulu</span><span class="sxs-lookup"><span data-stu-id="27897-161">Building a Second Output Engine</span></span>

<span data-ttu-id="27897-162">Komponenta log je také k disjetí.</span><span class="sxs-lookup"><span data-stu-id="27897-162">The Log component is coming along well.</span></span> <span data-ttu-id="27897-163">Pojďme přidat další výstupní modul, který bude protokolovat zprávy do souboru.</span><span class="sxs-lookup"><span data-stu-id="27897-163">Let's add one more output engine that logs messages to a file.</span></span> <span data-ttu-id="27897-164">To bude poněkud více součástí výstupního stroje.</span><span class="sxs-lookup"><span data-stu-id="27897-164">This will be a slightly more involved output engine.</span></span> <span data-ttu-id="27897-165">Bude to třída, která zapouzdřuje operace se soubory a zajistí, že se soubor vždy zavře po každém zápisu.</span><span class="sxs-lookup"><span data-stu-id="27897-165">It will be a class that encapsulates the file operations, and ensures that the file is always closed after each write.</span></span> <span data-ttu-id="27897-166">Tím zajistíte, že všechna data budou po vygenerování každé zprávy vyprázdněna na disk.</span><span class="sxs-lookup"><span data-stu-id="27897-166">That ensures that all the data is flushed to disk after each message is generated.</span></span>

<span data-ttu-id="27897-167">Tady je tento protokolovací nástroj založený na souboru:</span><span class="sxs-lookup"><span data-stu-id="27897-167">Here is that file based logger:</span></span>

[!code-csharp[FileLogger](../../samples/snippets/csharp/delegates-and-events/FileLogger.cs#FileLogger "Log to files")]

<span data-ttu-id="27897-168">Po vytvoření této třídy je možné ji vytvořit a připojit její metodu LogMessage – k součásti protokolovacího nástroje:</span><span class="sxs-lookup"><span data-stu-id="27897-168">Once you've created this class, you can instantiate it and it attaches its LogMessage method to the Logger component:</span></span>

[!code-csharp[FileLogger](../../samples/snippets/csharp/delegates-and-events/Program.cs#FileLogger "Log to files")]

<span data-ttu-id="27897-169">Tyto dvě se vzájemně nevylučují.</span><span class="sxs-lookup"><span data-stu-id="27897-169">These two are not mutually exclusive.</span></span> <span data-ttu-id="27897-170">Můžete připojit obě metody protokolu a generovat zprávy do konzoly a souboru:</span><span class="sxs-lookup"><span data-stu-id="27897-170">You could attach both log methods and generate messages to the console and a file:</span></span>

```csharp
var fileOutput = new FileLogger("log.txt");
Logger.WriteMessage += LoggingMethods.LogToConsole; // LoggingMethods is the static class we utilized earlier
```

<span data-ttu-id="27897-171">Později i ve stejné aplikaci můžete odebrat jednoho z delegátů bez jakýchkoli dalších problémů systému:</span><span class="sxs-lookup"><span data-stu-id="27897-171">Later, even in the same application, you can remove one of the delegates without any other issues to the system:</span></span>

```csharp
Logger.WriteMessage -= LoggingMethods.LogToConsole;
```

## <a name="practices"></a><span data-ttu-id="27897-172">Způsobů</span><span class="sxs-lookup"><span data-stu-id="27897-172">Practices</span></span>

<span data-ttu-id="27897-173">Nyní jste přidali druhou obslužnou rutinu výstupu pro dílčí systém protokolování.</span><span class="sxs-lookup"><span data-stu-id="27897-173">Now, you've added a second output handler for the logging sub-system.</span></span>
<span data-ttu-id="27897-174">Tato jedna z nich potřebuje trochu větší infrastrukturu, aby správně podporovala systém souborů.</span><span class="sxs-lookup"><span data-stu-id="27897-174">This one needs a bit more infrastructure to correctly support the file system.</span></span> <span data-ttu-id="27897-175">Delegát je metoda instance.</span><span class="sxs-lookup"><span data-stu-id="27897-175">The delegate is an instance method.</span></span> <span data-ttu-id="27897-176">Je to také soukromá metoda.</span><span class="sxs-lookup"><span data-stu-id="27897-176">It's also a private method.</span></span>
<span data-ttu-id="27897-177">Není potřeba mít větší přístupnost, protože delegát může připojit delegáty.</span><span class="sxs-lookup"><span data-stu-id="27897-177">There's no need for greater accessibility because the delegate infrastructure can connect the delegates.</span></span>

<span data-ttu-id="27897-178">Za druhé, návrh založený na delegátech umožňuje více metod výstupu bez dalšího kódu.</span><span class="sxs-lookup"><span data-stu-id="27897-178">Second, the delegate-based design enables multiple output methods without any extra code.</span></span> <span data-ttu-id="27897-179">Nemusíte vytvářet žádnou další infrastrukturu pro podporu více metod výstupu.</span><span class="sxs-lookup"><span data-stu-id="27897-179">You don't need to build any additional infrastructure to support multiple output methods.</span></span> <span data-ttu-id="27897-180">Jednoduše se v seznamu vyvolání stanou jinou metodou.</span><span class="sxs-lookup"><span data-stu-id="27897-180">They simply become another method on the invocation list.</span></span>

<span data-ttu-id="27897-181">Věnujte zvláštní pozornost kódu v metodě pro výstup protokolování souborů.</span><span class="sxs-lookup"><span data-stu-id="27897-181">Pay special attention to the code in the file logging output method.</span></span> <span data-ttu-id="27897-182">Je kódována, aby se zajistilo, že nevyvolá žádné výjimky.</span><span class="sxs-lookup"><span data-stu-id="27897-182">It is coded to ensure that it does not throw any exceptions.</span></span> <span data-ttu-id="27897-183">I když to není vždy naprosto nezbytné, často je to dobrý postup.</span><span class="sxs-lookup"><span data-stu-id="27897-183">While this isn't always strictly necessary, it's often a good practice.</span></span> <span data-ttu-id="27897-184">Pokud některá z metod delegáta vyvolá výjimku, zbývající delegáti, kteří jsou při vyvolání, nebudou vyvoláni.</span><span class="sxs-lookup"><span data-stu-id="27897-184">If either of the delegate methods throws an exception, the remaining delegates that are on the invocation won't be invoked.</span></span>

<span data-ttu-id="27897-185">Jako poslední Poznámka musí protokolovací nástroj souboru spravovat jeho prostředky otevřením a zavřením souboru v každé zprávě protokolu.</span><span class="sxs-lookup"><span data-stu-id="27897-185">As a last note, the file logger must manage its resources by opening and closing the file on each log message.</span></span> <span data-ttu-id="27897-186">Můžete zvolit, že soubor zůstane otevřený a implementuje IDisposable pro zavření souboru po dokončení.</span><span class="sxs-lookup"><span data-stu-id="27897-186">You could choose to keep the file open and implement IDisposable to close the file when you are completed.</span></span>
<span data-ttu-id="27897-187">Kterákoli z metod má své výhody a nevýhody.</span><span class="sxs-lookup"><span data-stu-id="27897-187">Either method has its advantages and disadvantages.</span></span> <span data-ttu-id="27897-188">Obě třídy vytvoří trochu větší propojení mezi třídami.</span><span class="sxs-lookup"><span data-stu-id="27897-188">Both do create a bit more coupling between the classes.</span></span>

<span data-ttu-id="27897-189">Žádný kód ve třídě protokolovacího nástroje by se neměl aktualizovat, aby podporoval buď scénář.</span><span class="sxs-lookup"><span data-stu-id="27897-189">None of the code in the Logger class would need to be updated in order to support either scenario.</span></span>

## <a name="handling-null-delegates"></a><span data-ttu-id="27897-190">Manipulace s delegáty s hodnotou null</span><span class="sxs-lookup"><span data-stu-id="27897-190">Handling Null Delegates</span></span>

<span data-ttu-id="27897-191">Nakonec aktualizujeme metodu LogMessage – tak, aby byla robustní pro případy, kdy není vybraný žádný výstupní mechanismus.</span><span class="sxs-lookup"><span data-stu-id="27897-191">Finally, let's update the LogMessage method so that it is robust for those cases when no output mechanism is selected.</span></span> <span data-ttu-id="27897-192">Aktuální implementace vyvolá `NullReferenceException`, když delegát `WriteMessage` nemá připojen seznam volání.</span><span class="sxs-lookup"><span data-stu-id="27897-192">The current implementation will throw a `NullReferenceException` when the `WriteMessage` delegate does not have an invocation list attached.</span></span>
<span data-ttu-id="27897-193">Můžete preferovat návrh, který Tichy pokračuje, i když nebyly připojeny žádné metody.</span><span class="sxs-lookup"><span data-stu-id="27897-193">You may prefer a design that silently continues when no methods have been attached.</span></span> <span data-ttu-id="27897-194">To je snadné pomocí podmíněného operátoru null kombinovaného s `Delegate.Invoke()` metodou:</span><span class="sxs-lookup"><span data-stu-id="27897-194">This is easy using the null conditional operator, combined with the `Delegate.Invoke()` method:</span></span>

```csharp
public static void LogMessage(string msg)
{
    WriteMessage?.Invoke(msg);
}
```

<span data-ttu-id="27897-195">Pokud levý operand (`WriteMessage` v tomto případě) má hodnotu null, znamená to, že se nepokusí o protokolování zprávy, což znamená, že došlo k nedostatku podmíněného operátoru (`?.`).</span><span class="sxs-lookup"><span data-stu-id="27897-195">The null conditional operator (`?.`) short-circuits when the left operand (`WriteMessage` in this case) is null, which means no attempt is made to log a message.</span></span>

<span data-ttu-id="27897-196">Nenajdete tu metodu `Invoke()` uvedenou v dokumentaci pro `System.Delegate` nebo `System.MulticastDelegate`.</span><span class="sxs-lookup"><span data-stu-id="27897-196">You won't find the `Invoke()` method listed in the documentation for `System.Delegate` or `System.MulticastDelegate`.</span></span> <span data-ttu-id="27897-197">Kompilátor generuje metodu bezpečného `Invoke` typu pro jakýkoli deklarovaný typ delegáta.</span><span class="sxs-lookup"><span data-stu-id="27897-197">The compiler generates a type safe `Invoke` method for any delegate type declared.</span></span> <span data-ttu-id="27897-198">V tomto příkladu to znamená, že `Invoke` přebírá jeden `string` argument a má návratový typ void.</span><span class="sxs-lookup"><span data-stu-id="27897-198">In this example, that means `Invoke` takes a single `string` argument, and has a void return type.</span></span>

## <a name="summary-of-practices"></a><span data-ttu-id="27897-199">Přehled postupů</span><span class="sxs-lookup"><span data-stu-id="27897-199">Summary of Practices</span></span>

<span data-ttu-id="27897-200">Viděli jste začátek komponenty protokolu, kterou je možné rozšířit o jiné moduly pro zápis a další funkce.</span><span class="sxs-lookup"><span data-stu-id="27897-200">You've seen the beginnings of a log component that could be expanded with other writers, and other features.</span></span> <span data-ttu-id="27897-201">Použití delegátů v návrhu těchto různých komponent je velmi volně připojeno.</span><span class="sxs-lookup"><span data-stu-id="27897-201">By using delegates in the design these different components are very loosely coupled.</span></span> <span data-ttu-id="27897-202">To přináší několik výhod.</span><span class="sxs-lookup"><span data-stu-id="27897-202">This provides several advantages.</span></span> <span data-ttu-id="27897-203">Je velmi snadné vytvořit nové výstupní mechanismy a připojit je k systému.</span><span class="sxs-lookup"><span data-stu-id="27897-203">It's very easy to create new output mechanisms and attach them to the system.</span></span> <span data-ttu-id="27897-204">Tyto další mechanismy potřebují jenom jednu metodu: metoda, která zapisuje zprávu protokolu.</span><span class="sxs-lookup"><span data-stu-id="27897-204">These other mechanisms only need one method: the method that writes the log message.</span></span> <span data-ttu-id="27897-205">Je to návrh, který je velmi odolný při přidávání nových funkcí.</span><span class="sxs-lookup"><span data-stu-id="27897-205">It's a design that is very resilient when new features are added.</span></span> <span data-ttu-id="27897-206">Kontraktem vyžadovaným pro jakýkoliv zapisovač je implementace jedné metody.</span><span class="sxs-lookup"><span data-stu-id="27897-206">The contract required for any writer is to implement one method.</span></span> <span data-ttu-id="27897-207">Tato metoda může být statickou metodou nebo metodou instance.</span><span class="sxs-lookup"><span data-stu-id="27897-207">That method could be a static or instance method.</span></span> <span data-ttu-id="27897-208">Může to být veřejné, privátní nebo jakýkoli jiný právní přístup.</span><span class="sxs-lookup"><span data-stu-id="27897-208">It could be public, private, or any other legal access.</span></span>

<span data-ttu-id="27897-209">Třída protokolovacího nástroje může provádět libovolný počet vylepšení nebo změn bez nutnosti zavádět zásadní změny.</span><span class="sxs-lookup"><span data-stu-id="27897-209">The Logger class can make any number of enhancements or changes without introducing breaking changes.</span></span> <span data-ttu-id="27897-210">Stejně jako u libovolné třídy nemůžete změnit veřejné rozhraní API bez rizika zásadních změn.</span><span class="sxs-lookup"><span data-stu-id="27897-210">Like any class, you cannot modify the public API without the risk of breaking changes.</span></span> <span data-ttu-id="27897-211">Vzhledem k tomu, že propojení mezi protokolovacím modulem a všemi výstupními moduly je pouze prostřednictvím delegáta, nejsou zapojeny žádné další typy (jako rozhraní nebo základní třídy).</span><span class="sxs-lookup"><span data-stu-id="27897-211">But, because the coupling between the logger and any output engines is only through the delegate, no other types (like interfaces or base classes) are involved.</span></span> <span data-ttu-id="27897-212">Spojení je co nejmenší.</span><span class="sxs-lookup"><span data-stu-id="27897-212">The coupling is as small as possible.</span></span>

[<span data-ttu-id="27897-213">Next</span><span class="sxs-lookup"><span data-stu-id="27897-213">Next</span></span>](events-overview.md)
