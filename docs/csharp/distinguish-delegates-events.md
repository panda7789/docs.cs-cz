---
title: Delegáti vs. události
description: Zjistěte rozdíl mezi delegáty a událostmi a kdy použít každou z těchto funkcí .NET Core.
ms.date: 06/20/2016
ms.technology: csharp-fundamentals
ms.assetid: 0fdc8629-2fdb-4a7c-a433-5b9d04eaf911
ms.openlocfilehash: 51d982c9b5b16a5fc28ede5f0318bc100bb33b68
ms.sourcegitcommit: f87ad41b8e62622da126aa928f7640108c4eff98
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 04/07/2020
ms.locfileid: "80805766"
---
# <a name="distinguishing-delegates-and-events"></a><span data-ttu-id="c2f4d-103">Rozlišování delegátů a událostí</span><span class="sxs-lookup"><span data-stu-id="c2f4d-103">Distinguishing Delegates and Events</span></span>

[<span data-ttu-id="c2f4d-104">Předchozí</span><span class="sxs-lookup"><span data-stu-id="c2f4d-104">Previous</span></span>](modern-events.md)

<span data-ttu-id="c2f4d-105">Vývojáři, kteří jsou na platformě .NET Core noví, `delegates` se často `events`potýkají s problémy při rozhodování mezi návrhem založeným na návrhu a návrhem založeným na .</span><span class="sxs-lookup"><span data-stu-id="c2f4d-105">Developers that are new to the .NET Core platform often struggle when deciding between a design based on `delegates` and a design based on `events`.</span></span> <span data-ttu-id="c2f4d-106">Výběr delegátů nebo událostí je často obtížné, protože dva funkce jazyka jsou podobné.</span><span class="sxs-lookup"><span data-stu-id="c2f4d-106">The choice of delegates or events is often difficult, because the two language features are similar.</span></span> <span data-ttu-id="c2f4d-107">Události jsou dokonce sestaveny pomocí jazykové podpory pro delegáty.</span><span class="sxs-lookup"><span data-stu-id="c2f4d-107">Events are even built using the language support for delegates.</span></span>

<span data-ttu-id="c2f4d-108">Oba nabízejí scénář pozdní vazby: umožňují scénáře, kde komponenta komunikuje voláním metody, která je známa pouze za běhu.</span><span class="sxs-lookup"><span data-stu-id="c2f4d-108">They both offer a late binding scenario: they enable scenarios where a component communicates by calling a method that is only known at runtime.</span></span> <span data-ttu-id="c2f4d-109">Oba podporují metody jednoho a více odběratelů.</span><span class="sxs-lookup"><span data-stu-id="c2f4d-109">They both support single and multiple subscriber methods.</span></span> <span data-ttu-id="c2f4d-110">Může se vám to líbit jako podpora jednoho vysílání a vícesměrového vysílání.</span><span class="sxs-lookup"><span data-stu-id="c2f4d-110">You may find this referred to as singlecast and multicast support.</span></span> <span data-ttu-id="c2f4d-111">Oba podporují podobnou syntaxi pro přidávání a odebírání obslužných rutin.</span><span class="sxs-lookup"><span data-stu-id="c2f4d-111">They both support similar syntax for adding and removing handlers.</span></span> <span data-ttu-id="c2f4d-112">Nakonec vyvolání události a volání delegáta použít přesně stejnou syntaxi volání metody.</span><span class="sxs-lookup"><span data-stu-id="c2f4d-112">Finally, raising an event and calling a delegate use exactly the same method call syntax.</span></span> <span data-ttu-id="c2f4d-113">I oba podporují `Invoke()` stejnou syntaxi metody `?.` pro použití s operátorem.</span><span class="sxs-lookup"><span data-stu-id="c2f4d-113">They even both support the same `Invoke()` method syntax for use with the `?.` operator.</span></span>

<span data-ttu-id="c2f4d-114">Se všemi těmito podobnostmi, je snadné mít potíže s určením, kdy použít, které.</span><span class="sxs-lookup"><span data-stu-id="c2f4d-114">With all those similarities, it is easy to have trouble determining when to use which.</span></span>

## <a name="listening-to-events-is-optional"></a><span data-ttu-id="c2f4d-115">Naslouchání událostem je volitelné</span><span class="sxs-lookup"><span data-stu-id="c2f4d-115">Listening to Events is Optional</span></span>

<span data-ttu-id="c2f4d-116">Nejdůležitější mne v úvahu při určování, který jazyk funkce použít, je zda musí být připojené odběratel.</span><span class="sxs-lookup"><span data-stu-id="c2f4d-116">The most important consideration in determining which language feature to use is whether or not there must be an attached subscriber.</span></span> <span data-ttu-id="c2f4d-117">Pokud váš kód musí volat kód dodaný předplatitelem, měli byste použít návrh založený na delegátech.</span><span class="sxs-lookup"><span data-stu-id="c2f4d-117">If your code must call the code supplied by the subscriber, you should use a design based on delegates.</span></span> <span data-ttu-id="c2f4d-118">Pokud váš kód může dokončit všechny své práce bez volání odběratele, měli byste použít návrh založený na událostech.</span><span class="sxs-lookup"><span data-stu-id="c2f4d-118">If your code can complete all its work without calling any subscribers, you should use a design based on events.</span></span>

<span data-ttu-id="c2f4d-119">Vezměme si příklady vytvořené během této části.</span><span class="sxs-lookup"><span data-stu-id="c2f4d-119">Consider the examples built during this section.</span></span> <span data-ttu-id="c2f4d-120">Kód, který `List.Sort()` jste vytvořili pomocí musí být poskytnuta funkce porovnávání, aby bylo možné správně třídit prvky.</span><span class="sxs-lookup"><span data-stu-id="c2f4d-120">The code you built using `List.Sort()` must be given a comparer function in order to properly sort the elements.</span></span> <span data-ttu-id="c2f4d-121">Linq dotazy musí být dodány s delegáty, aby bylo možné určit, jaké prvky vrátit.</span><span class="sxs-lookup"><span data-stu-id="c2f4d-121">LINQ queries must be supplied with delegates in order to determine what elements to return.</span></span> <span data-ttu-id="c2f4d-122">Oba používali návrh vytvořený s delegáty.</span><span class="sxs-lookup"><span data-stu-id="c2f4d-122">Both used a design built with delegates.</span></span>

<span data-ttu-id="c2f4d-123">Vezměme `Progress` si událost.</span><span class="sxs-lookup"><span data-stu-id="c2f4d-123">Consider the `Progress` event.</span></span> <span data-ttu-id="c2f4d-124">Hlásí průběh úkolu.</span><span class="sxs-lookup"><span data-stu-id="c2f4d-124">It reports progress on a task.</span></span>
<span data-ttu-id="c2f4d-125">Úloha pokračuje pokračovat bez ohledu na to, zda existují naslouchací procesy.</span><span class="sxs-lookup"><span data-stu-id="c2f4d-125">The task continues to proceed whether or not there are any listeners.</span></span>
<span data-ttu-id="c2f4d-126">Další `FileSearcher` příklad je.</span><span class="sxs-lookup"><span data-stu-id="c2f4d-126">The `FileSearcher` is another example.</span></span> <span data-ttu-id="c2f4d-127">To by ještě hledat a najít všechny soubory, které byly vyhledávány, a to i bez události účastníků připojen.</span><span class="sxs-lookup"><span data-stu-id="c2f4d-127">It would still search and find all the files that were sought, even with no event subscribers attached.</span></span>
<span data-ttu-id="c2f4d-128">Ovládací prvky uživatelského rozhraní stále fungují správně, i když neexistují žádní odběratelé, kteří poslouchají události.</span><span class="sxs-lookup"><span data-stu-id="c2f4d-128">UX controls still work correctly, even when there are no subscribers listening to the events.</span></span> <span data-ttu-id="c2f4d-129">Oba používají návrhy založené na událostech.</span><span class="sxs-lookup"><span data-stu-id="c2f4d-129">They both use designs based on events.</span></span>

## <a name="return-values-require-delegates"></a><span data-ttu-id="c2f4d-130">Návratové hodnoty vyžadují delegáty</span><span class="sxs-lookup"><span data-stu-id="c2f4d-130">Return Values Require Delegates</span></span>

<span data-ttu-id="c2f4d-131">Dalším aspektem je prototyp metody, který byste chtěli pro metodu delegáta.</span><span class="sxs-lookup"><span data-stu-id="c2f4d-131">Another consideration is the method prototype you would want for your delegate method.</span></span> <span data-ttu-id="c2f4d-132">Jak jste viděli, delegáti používané pro události všechny mají prázdný návratový typ.</span><span class="sxs-lookup"><span data-stu-id="c2f4d-132">As you've seen, the delegates used for events all have a void return type.</span></span> <span data-ttu-id="c2f4d-133">Také jste viděli, že existují idiomy k vytvoření obslužné rutiny událostí, které předávají informace zpět zdrojům událostí prostřednictvím úpravy vlastností objektu argumentu události.</span><span class="sxs-lookup"><span data-stu-id="c2f4d-133">You've also seen that there are idioms to create event handlers that do pass information back to event sources through modifying properties of the event argument object.</span></span> <span data-ttu-id="c2f4d-134">Zatímco tyto idiomy fungují, nejsou tak přirozené jako vrácení hodnoty z metody.</span><span class="sxs-lookup"><span data-stu-id="c2f4d-134">While these idioms do work, they are not as natural as returning a value from a method.</span></span>

<span data-ttu-id="c2f4d-135">Všimněte si, že tyto dvě heuristiky mohou být často oba přítomny: Pokud vaše metoda delegáta vrátí hodnotu, bude pravděpodobně nějakým způsobem ovlivnit algoritmus.</span><span class="sxs-lookup"><span data-stu-id="c2f4d-135">Notice that these two heuristics may often both be present: If your delegate method returns a value, it will likely impact the algorithm in some way.</span></span>

## <a name="events-have-private-invocation"></a><span data-ttu-id="c2f4d-136">Události mají soukromé vyvolání</span><span class="sxs-lookup"><span data-stu-id="c2f4d-136">Events Have Private Invocation</span></span>

<span data-ttu-id="c2f4d-137">Jiné třídy než ve kterém je událost obsažena můžete pouze přidat a odebrat posluchače událostí; pouze třída obsahující událost může vyvolat událost.</span><span class="sxs-lookup"><span data-stu-id="c2f4d-137">Classes other than the one in which an event is contained can only add and remove event listeners; only the class containing the event can invoke the event.</span></span> <span data-ttu-id="c2f4d-138">Události jsou obvykle členy veřejné třídy.</span><span class="sxs-lookup"><span data-stu-id="c2f4d-138">Events are typically public class members.</span></span>
<span data-ttu-id="c2f4d-139">Pro srovnání delegáti jsou často předávané jako parametry a uloženy jako soukromé členy třídy, pokud jsou uloženy vůbec.</span><span class="sxs-lookup"><span data-stu-id="c2f4d-139">By comparison, delegates are often passed as parameters and stored as private class members, if they are stored at all.</span></span>

## <a name="event-listeners-often-have-longer-lifetimes"></a><span data-ttu-id="c2f4d-140">Posluchači událostí mají často delší životnost</span><span class="sxs-lookup"><span data-stu-id="c2f4d-140">Event Listeners Often Have Longer Lifetimes</span></span>

<span data-ttu-id="c2f4d-141">Že posluchači událostí mají delší životnost, je o něco slabší odůvodnění.</span><span class="sxs-lookup"><span data-stu-id="c2f4d-141">That event listeners have longer lifetimes is a slightly weaker justification.</span></span> <span data-ttu-id="c2f4d-142">Můžete však zjistit, že návrhy založené na událostech jsou přirozenější, když zdroj události bude vyvolávat události po dlouhou dobu.</span><span class="sxs-lookup"><span data-stu-id="c2f4d-142">However, you may find that event-based designs are more natural when the event source will be raising events over a long period of time.</span></span> <span data-ttu-id="c2f4d-143">Můžete zobrazit příklady návrhu založeného na událostech pro ovládací prvky uživatelského rozhraní v mnoha systémech.</span><span class="sxs-lookup"><span data-stu-id="c2f4d-143">You can see examples of event-based design for UX controls on many systems.</span></span> <span data-ttu-id="c2f4d-144">Jakmile se přihlásíte k odběru události, zdroj události může vyvolat události po celou dobu životnosti programu.</span><span class="sxs-lookup"><span data-stu-id="c2f4d-144">Once you subscribe to an event, the event source may raise events throughout the lifetime of the program.</span></span>
<span data-ttu-id="c2f4d-145">(Z odběru se můžete odhlásit, když je již nepotřebujete.)</span><span class="sxs-lookup"><span data-stu-id="c2f4d-145">(You can unsubscribe from events when you no longer need them.)</span></span>

<span data-ttu-id="c2f4d-146">Kontrast, že s mnoha návrhy založené na delegáta, kde delegát se používá jako argument k metodě a delegát se nepoužívá po této metody vrátí.</span><span class="sxs-lookup"><span data-stu-id="c2f4d-146">Contrast that with many delegate-based designs, where a delegate is used as an argument to a method, and the delegate is not used after that method returns.</span></span>

## <a name="evaluate-carefully"></a><span data-ttu-id="c2f4d-147">Pečlivě vyhodnoťte</span><span class="sxs-lookup"><span data-stu-id="c2f4d-147">Evaluate Carefully</span></span>

<span data-ttu-id="c2f4d-148">Výše uvedené úvahy nejsou tvrdá a rychlá pravidla.</span><span class="sxs-lookup"><span data-stu-id="c2f4d-148">The above considerations are not hard and fast rules.</span></span> <span data-ttu-id="c2f4d-149">Místo toho představují pokyny, které vám pomohou rozhodnout, která volba je nejvhodnější pro konkrétní použití.</span><span class="sxs-lookup"><span data-stu-id="c2f4d-149">Instead, they represent guidance that can help you decide which choice is best for your particular usage.</span></span> <span data-ttu-id="c2f4d-150">Vzhledem k tomu, že jsou podobné, můžete dokonce prototyp oba, a zvážit, které by bylo přirozenější pracovat.</span><span class="sxs-lookup"><span data-stu-id="c2f4d-150">Because they are similar, you can even prototype both, and consider which would be more natural to work with.</span></span> <span data-ttu-id="c2f4d-151">Oba dobře zvládnou pozdní vazebné scénáře.</span><span class="sxs-lookup"><span data-stu-id="c2f4d-151">They both handle late binding scenarios well.</span></span> <span data-ttu-id="c2f4d-152">Použijte ten, který komunikuje váš návrh nejlepší.</span><span class="sxs-lookup"><span data-stu-id="c2f4d-152">Use the one that communicates your design the best.</span></span>
