---
title: Typy řazené kolekce členů – Průvodce C#
description: 'Seznamte se s nepojmenovanými a pojmenovanými typy řazené kolekce členů v jazyce C #'
ms.date: 05/15/2018
ms.technology: csharp-fundamentals
ms.assetid: ee8bf7c3-aa3e-4c9e-a5c6-e05cc6138baa
ms.openlocfilehash: 0fb6f043857a9932b7a86f773cce812e0fd49dcb
ms.sourcegitcommit: 0edbeb66d71b8df10fcb374cfca4d731b58ccdb2
ms.contentlocale: cs-CZ
ms.lasthandoff: 07/07/2020
ms.locfileid: "86051854"
---
# <a name="c-tuple-types"></a><span data-ttu-id="31fbf-103">Typy řazené kolekce členů jazyka C#</span><span class="sxs-lookup"><span data-stu-id="31fbf-103">C# tuple types</span></span>

<span data-ttu-id="31fbf-104">Řazené kolekce členů jazyka C# jsou typy, které definujete pomocí prosté syntaxe.</span><span class="sxs-lookup"><span data-stu-id="31fbf-104">C# tuples are types that you define using a lightweight syntax.</span></span> <span data-ttu-id="31fbf-105">Výhody zahrnují jednodušší syntaxi, pravidla pro převody na základě počtu (označovaného jako mohutnost) a typy prvků a konzistentní pravidla pro kopie, testy rovnosti a přiřazení.</span><span class="sxs-lookup"><span data-stu-id="31fbf-105">The advantages include a simpler syntax, rules for conversions based on number (referred to as cardinality) and types of elements, and consistent rules for copies, equality tests, and assignments.</span></span> <span data-ttu-id="31fbf-106">V rámci kompromisů nepodporují řazené kolekce členů některé objekty orientované na objekt idiomy přidružené k dědičnosti.</span><span class="sxs-lookup"><span data-stu-id="31fbf-106">As a tradeoff, tuples do not support some of the object-oriented idioms associated with inheritance.</span></span> <span data-ttu-id="31fbf-107">Přehled v části o [řazených kolekcích členů najdete v článku Co je nového v jazyce C# 7,0](whats-new/csharp-7.md#tuples) .</span><span class="sxs-lookup"><span data-stu-id="31fbf-107">You can get an overview in the section on [tuples in the What's new in C# 7.0](whats-new/csharp-7.md#tuples) article.</span></span>

<span data-ttu-id="31fbf-108">V tomto článku se naučíte jazykové pravidla upravující řazené kolekce členů v C# 7,0 a novějších verzích, různých způsobech jejich použití a úvodní doprovodné materiály k práci s řazenými kolekcemi členů.</span><span class="sxs-lookup"><span data-stu-id="31fbf-108">In this article, you'll learn the language rules governing tuples in C# 7.0 and later versions, different ways to use them, and initial guidance on working with tuples.</span></span>

> [!NOTE]
> <span data-ttu-id="31fbf-109">Nové funkce řazené kolekce členů vyžadují <xref:System.ValueTuple> typy.</span><span class="sxs-lookup"><span data-stu-id="31fbf-109">The new tuples features require the <xref:System.ValueTuple> types.</span></span>
> <span data-ttu-id="31fbf-110">Je nutné přidat balíček NuGet, [`System.ValueTuple`](https://www.nuget.org/packages/System.ValueTuple/) aby jej bylo možné použít na platformách, které neobsahují tyto typy.</span><span class="sxs-lookup"><span data-stu-id="31fbf-110">You must add the NuGet package [`System.ValueTuple`](https://www.nuget.org/packages/System.ValueTuple/) in order to use it on platforms that do not include the types.</span></span>
>
> <span data-ttu-id="31fbf-111">To je podobné jako u jiných funkcí jazyka, které závisí na typech dodaných v rámci rozhraní.</span><span class="sxs-lookup"><span data-stu-id="31fbf-111">This is similar to other language features that rely on types delivered in the framework.</span></span> <span data-ttu-id="31fbf-112">Příklady zahrnují `async` a `await` spoléhají na `INotifyCompletion` rozhraní a LINQ spoléhají na `IEnumerable<T>` .</span><span class="sxs-lookup"><span data-stu-id="31fbf-112">Examples include `async` and `await` relying on the `INotifyCompletion` interface, and LINQ relying on `IEnumerable<T>`.</span></span> <span data-ttu-id="31fbf-113">Mechanismus doručování se ale mění, protože .NET se stane nezávisle na platformě.</span><span class="sxs-lookup"><span data-stu-id="31fbf-113">However, the delivery mechanism is changing as .NET is becoming more platform independent.</span></span> <span data-ttu-id="31fbf-114">.NET Framework nemusí vždy dodávat do stejného tempo jako kompilátor jazyka.</span><span class="sxs-lookup"><span data-stu-id="31fbf-114">The .NET Framework may not always ship on the same cadence as the language compiler.</span></span> <span data-ttu-id="31fbf-115">Když nové funkce jazyka spoléhají na nové typy, budou tyto typy k dispozici jako balíčky NuGet, když se funkce jazyka dodávají.</span><span class="sxs-lookup"><span data-stu-id="31fbf-115">When new language features rely on new types, those types will be available as NuGet packages when the language features ship.</span></span> <span data-ttu-id="31fbf-116">Jelikož se tyto nové typy přidají do rozhraní .NET Standard API a doručují se jako součást architektury, požadavek na balíček NuGet se odebere.</span><span class="sxs-lookup"><span data-stu-id="31fbf-116">As these new types get added to the .NET Standard API and delivered as part of the framework, the NuGet package requirement will be removed.</span></span>

<span data-ttu-id="31fbf-117">Pojďme začít s důvody pro přidání nové podpory řazené kolekce členů.</span><span class="sxs-lookup"><span data-stu-id="31fbf-117">Let's start with the reasons for adding new tuple support.</span></span> <span data-ttu-id="31fbf-118">Metody vrací jeden objekt.</span><span class="sxs-lookup"><span data-stu-id="31fbf-118">Methods return a single object.</span></span> <span data-ttu-id="31fbf-119">Řazené kolekce členů umožňují snadněji zabalit více hodnot v jednom objektu.</span><span class="sxs-lookup"><span data-stu-id="31fbf-119">Tuples enable you to package multiple values in that single object more easily.</span></span>

<span data-ttu-id="31fbf-120">.NET Framework již obsahuje obecné `Tuple` třídy.</span><span class="sxs-lookup"><span data-stu-id="31fbf-120">The .NET Framework already has generic `Tuple` classes.</span></span> <span data-ttu-id="31fbf-121">Tyto třídy však měly dvě hlavní omezení.</span><span class="sxs-lookup"><span data-stu-id="31fbf-121">These classes, however, had two major limitations.</span></span> <span data-ttu-id="31fbf-122">Pro jednu `Tuple` třídu s názvem jejich vlastnosti `Item1` , `Item2` a tak dále.</span><span class="sxs-lookup"><span data-stu-id="31fbf-122">For one, the `Tuple` classes named their properties `Item1`, `Item2`, and so on.</span></span> <span data-ttu-id="31fbf-123">Tyto názvy nenesou žádné sémantické informace.</span><span class="sxs-lookup"><span data-stu-id="31fbf-123">Those names carry no semantic information.</span></span> <span data-ttu-id="31fbf-124">Použití těchto `Tuple` typů neumožňuje komunikaci významu jednotlivých vlastností.</span><span class="sxs-lookup"><span data-stu-id="31fbf-124">Using these `Tuple` types does not enable communicating the meaning of each of the properties.</span></span> <span data-ttu-id="31fbf-125">Nové funkce jazyka umožňují deklarovat a používat sémanticky smysluplné názvy pro prvky v řazené kolekci členů.</span><span class="sxs-lookup"><span data-stu-id="31fbf-125">The new language features enable you to declare and use semantically meaningful names for the elements in a tuple.</span></span>

<span data-ttu-id="31fbf-126">`Tuple`Třídy způsobují větší vliv na výkon, protože se jedná o odkazové typy.</span><span class="sxs-lookup"><span data-stu-id="31fbf-126">The `Tuple` classes cause more performance concerns because they are reference types.</span></span> <span data-ttu-id="31fbf-127">Použití jednoho z `Tuple` typů znamená přidělení objektů.</span><span class="sxs-lookup"><span data-stu-id="31fbf-127">Using one of the `Tuple` types means allocating objects.</span></span> <span data-ttu-id="31fbf-128">V případě aktivních cest může mít přidělení mnoha malých objektů měřitelný dopad na výkon aplikace.</span><span class="sxs-lookup"><span data-stu-id="31fbf-128">On hot paths, allocating many small objects can have a measurable impact on your application's performance.</span></span> <span data-ttu-id="31fbf-129">Proto jazyková podpora pro řazené kolekce členů využívá nové `ValueTuple` struktury.</span><span class="sxs-lookup"><span data-stu-id="31fbf-129">Therefore, the language support for tuples leverages the new `ValueTuple` structs.</span></span>

<span data-ttu-id="31fbf-130">Chcete-li se těmto nedostatkům vyhnout, můžete vytvořit `class` nebo a `struct` převést více prvků.</span><span class="sxs-lookup"><span data-stu-id="31fbf-130">To avoid those deficiencies, you could create a `class` or a `struct` to carry multiple elements.</span></span> <span data-ttu-id="31fbf-131">Bohužel to více funguje za vás a zakrývá váš záměr návrhu.</span><span class="sxs-lookup"><span data-stu-id="31fbf-131">Unfortunately, that's more work for you, and it obscures your design intent.</span></span> <span data-ttu-id="31fbf-132">Vytvoření `struct` nebo `class` znamená, že definujete typ s daty a chováním.</span><span class="sxs-lookup"><span data-stu-id="31fbf-132">Making a `struct` or `class` implies that you are defining a type with both data and behavior.</span></span> <span data-ttu-id="31fbf-133">Mnohokrát stačí uložit více hodnot do jednoho objektu.</span><span class="sxs-lookup"><span data-stu-id="31fbf-133">Many times, you simply want to store multiple values in a single object.</span></span>

<span data-ttu-id="31fbf-134">Jazykové funkce a `ValueTuple` obecné struktury vynutily pravidlo, že nemůžete přidat žádné chování (metody) k těmto typům řazené kolekce členů.</span><span class="sxs-lookup"><span data-stu-id="31fbf-134">The language features and the `ValueTuple` generic structs enforce the rule that you cannot add any behavior (methods) to these tuple types.</span></span>
<span data-ttu-id="31fbf-135">Všechny `ValueTuple` typy jsou *proměnlivé struktury*.</span><span class="sxs-lookup"><span data-stu-id="31fbf-135">All the `ValueTuple` types are *mutable structs*.</span></span> <span data-ttu-id="31fbf-136">Každé pole člena je veřejné pole.</span><span class="sxs-lookup"><span data-stu-id="31fbf-136">Each member field is a public field.</span></span> <span data-ttu-id="31fbf-137">Díky tomu jsou velmi odlehčené.</span><span class="sxs-lookup"><span data-stu-id="31fbf-137">That makes them very lightweight.</span></span> <span data-ttu-id="31fbf-138">To ale znamená, že by se neměly používat řazené kolekce členů tam, kde je neměnnosti důležité.</span><span class="sxs-lookup"><span data-stu-id="31fbf-138">However, that means tuples should not be used where immutability is important.</span></span>

<span data-ttu-id="31fbf-139">Řazené kolekce členů jsou jednodušší a pružnější datové kontejnery než `class` a `struct` typy.</span><span class="sxs-lookup"><span data-stu-id="31fbf-139">Tuples are both simpler and more flexible data containers than `class` and `struct` types.</span></span> <span data-ttu-id="31fbf-140">Pojďme tyto rozdíly prozkoumat.</span><span class="sxs-lookup"><span data-stu-id="31fbf-140">Let's explore those differences.</span></span>

## <a name="named-and-unnamed-tuples"></a><span data-ttu-id="31fbf-141">Pojmenované a nepojmenované řazené kolekce členů</span><span class="sxs-lookup"><span data-stu-id="31fbf-141">Named and unnamed tuples</span></span>

<span data-ttu-id="31fbf-142">`ValueTuple`Struktura obsahuje pole s názvy `Item1` , `Item2` , `Item3` a tak dále, podobně jako vlastnosti definované v existujících `Tuple` typech.</span><span class="sxs-lookup"><span data-stu-id="31fbf-142">The `ValueTuple` struct has fields named `Item1`, `Item2`, `Item3`, and so on, similar to the properties defined in the existing `Tuple` types.</span></span>
<span data-ttu-id="31fbf-143">Tyto názvy jsou jedinými názvy, které můžete použít pro *nepojmenované řazené kolekce členů*.</span><span class="sxs-lookup"><span data-stu-id="31fbf-143">These names are the only names you can use for *unnamed tuples*.</span></span> <span data-ttu-id="31fbf-144">Pokud neposkytnete žádné alternativní názvy polí do řazené kolekce členů, vytvořili jste nepojmenované řazené kolekce členů:</span><span class="sxs-lookup"><span data-stu-id="31fbf-144">When you do not provide any alternative field names to a tuple, you've created an unnamed tuple:</span></span>

[!code-csharp[UnnamedTuple](../../samples/snippets/csharp/tuples/program.cs#01_UnNamedTuple "Unnamed tuple")]

<span data-ttu-id="31fbf-145">Řazená kolekce členů v předchozím příkladu byla inicializována pomocí literálových konstant a v jazyce C# 7,1 nebudou vytvořeny názvy elementů pomocí *projekce názvů polí řazené kolekce členů* .</span><span class="sxs-lookup"><span data-stu-id="31fbf-145">The tuple in the previous example was initialized using literal constants and won't have element names created using *tuple field name projections* in C# 7.1.</span></span>

<span data-ttu-id="31fbf-146">Při inicializaci řazené kolekce členů ale můžete použít nové funkce jazyka, které každému poli přidávají lepší názvy.</span><span class="sxs-lookup"><span data-stu-id="31fbf-146">However, when you initialize a tuple, you can use new language features that give better names to each field.</span></span> <span data-ttu-id="31fbf-147">Tím dojde k vytvoření *pojmenované řazené kolekce členů*.</span><span class="sxs-lookup"><span data-stu-id="31fbf-147">Doing so creates a *named tuple*.</span></span>
<span data-ttu-id="31fbf-148">Pojmenované řazené kolekce členů mají stále prvky s názvem `Item1` ,, `Item2` `Item3` a tak dále.</span><span class="sxs-lookup"><span data-stu-id="31fbf-148">Named tuples still have elements named `Item1`, `Item2`, `Item3`, and so on.</span></span>
<span data-ttu-id="31fbf-149">Mají však také synonyma pro libovolný z těchto elementů, které máte pojmenovány.</span><span class="sxs-lookup"><span data-stu-id="31fbf-149">But they also have synonyms for any of those elements that you have named.</span></span>
<span data-ttu-id="31fbf-150">Pojmenovanou řazenou kolekci členů vytvoříte zadáním názvů pro každý prvek.</span><span class="sxs-lookup"><span data-stu-id="31fbf-150">You create a named tuple by specifying the names for each element.</span></span> <span data-ttu-id="31fbf-151">Jedním ze způsobů, jak zadat názvy v rámci inicializace řazené kolekce členů:</span><span class="sxs-lookup"><span data-stu-id="31fbf-151">One way is to specify the names as part of the tuple initialization:</span></span>

[!code-csharp[NamedTuple](../../samples/snippets/csharp/tuples/program.cs#02_NamedTuple "Named tuple")]

<span data-ttu-id="31fbf-152">Tato synonyma jsou zpracovávána kompilátorem a jazykem, aby bylo možné používat pojmenované řazené kolekce členů efektivně.</span><span class="sxs-lookup"><span data-stu-id="31fbf-152">These synonyms are handled by the compiler and the language so that you can use named tuples effectively.</span></span> <span data-ttu-id="31fbf-153">IDEs a editory můžou tyto sémantické názvy číst pomocí rozhraní Roslyn API.</span><span class="sxs-lookup"><span data-stu-id="31fbf-153">IDEs and editors can read these semantic names using the Roslyn APIs.</span></span> <span data-ttu-id="31fbf-154">Na prvky pojmenované řazené kolekce členů můžete odkazovat pomocí těchto sémantických názvů kdekoli ve stejném sestavení.</span><span class="sxs-lookup"><span data-stu-id="31fbf-154">You can reference the elements of a named tuple by those semantic names anywhere in the same assembly.</span></span> <span data-ttu-id="31fbf-155">Kompilátor nahradí názvy, které jste definovali, `Item*` ekvivalenty při generování zkompilovaného výstupu.</span><span class="sxs-lookup"><span data-stu-id="31fbf-155">The compiler replaces the names you've defined with `Item*` equivalents when generating the compiled output.</span></span> <span data-ttu-id="31fbf-156">Kompilovaný jazyk MSIL (Microsoft Intermediate Language) neobsahuje názvy, které jste těmto prvkům zadali.</span><span class="sxs-lookup"><span data-stu-id="31fbf-156">The compiled Microsoft Intermediate Language (MSIL) does not include the names you've given these elements.</span></span>

<span data-ttu-id="31fbf-157">Počínaje jazykem C# 7,1 mohou být názvy polí pro řazené kolekce členů poskytnuty z proměnných používaných k inicializaci řazené kolekce členů.</span><span class="sxs-lookup"><span data-stu-id="31fbf-157">Beginning with C# 7.1, the field names for a tuple may be provided from the variables used to initialize the tuple.</span></span> <span data-ttu-id="31fbf-158">Poskytování názvů polí pro řazené kolekce členů je označováno jako **[Inicializátory projekce řazené kolekce členů](#tuple-projection-initializers)**.</span><span class="sxs-lookup"><span data-stu-id="31fbf-158">Providing field names to tuples is referred to as **[tuple projection initializers](#tuple-projection-initializers)**.</span></span> <span data-ttu-id="31fbf-159">Následující kód vytvoří řazenou kolekci členů s názvem `accumulation` s prvky `count` (celé číslo) a `sum` (Double).</span><span class="sxs-lookup"><span data-stu-id="31fbf-159">The following code creates a tuple named `accumulation` with elements `count` (an integer), and `sum` (a double).</span></span>

[!code-csharp[ProjectedTuple](../../samples/snippets/csharp/tuples/program.cs#ProjectedTupleNames "Named tuple")]

<span data-ttu-id="31fbf-160">Kompilátor musí komunikovat s názvy, které jste vytvořili pro řazené kolekce členů, které jsou vráceny z veřejných metod nebo vlastností.</span><span class="sxs-lookup"><span data-stu-id="31fbf-160">The compiler must communicate those names you created for tuples that are returned from public methods or properties.</span></span> <span data-ttu-id="31fbf-161">V těchto případech kompilátor přidá <xref:System.Runtime.CompilerServices.TupleElementNamesAttribute> atribut metody.</span><span class="sxs-lookup"><span data-stu-id="31fbf-161">In those cases, the compiler adds a <xref:System.Runtime.CompilerServices.TupleElementNamesAttribute> attribute on the method.</span></span> <span data-ttu-id="31fbf-162">Tento atribut obsahuje <xref:System.Runtime.CompilerServices.TupleElementNamesAttribute.TransformNames> vlastnost seznamu, která obsahuje názvy zadané pro každý prvek v řazené kolekci členů.</span><span class="sxs-lookup"><span data-stu-id="31fbf-162">This attribute contains a <xref:System.Runtime.CompilerServices.TupleElementNamesAttribute.TransformNames> list property that contains the names given to each of the elements in the tuple.</span></span>

> [!NOTE]
> <span data-ttu-id="31fbf-163">Nástroje pro vývoj, jako je třeba Visual Studio, čtou tato metadata a poskytují IntelliSense a další funkce pomocí názvů polí metadat.</span><span class="sxs-lookup"><span data-stu-id="31fbf-163">Development Tools, such as Visual Studio, also read that metadata, and provide IntelliSense and other features using the metadata field names.</span></span>

<span data-ttu-id="31fbf-164">Je důležité pochopit tyto základní základy nových řazených kolekcí členů a typ, aby `ValueTuple` bylo možné pochopit pravidla pro přiřazování pojmenovaných řazených kolekcí členů.</span><span class="sxs-lookup"><span data-stu-id="31fbf-164">It is important to understand these underlying fundamentals of the new tuples and the `ValueTuple` type in order to understand the rules for assigning named tuples to each other.</span></span>

## <a name="tuple-projection-initializers"></a><span data-ttu-id="31fbf-165">Inicializátory řazené kolekce členů</span><span class="sxs-lookup"><span data-stu-id="31fbf-165">Tuple projection initializers</span></span>

<span data-ttu-id="31fbf-166">Obecně se Inicializátory řazené kolekce členů pracují pomocí názvů proměnných nebo polí z pravé strany příkazu inicializace řazené kolekce členů.</span><span class="sxs-lookup"><span data-stu-id="31fbf-166">In general, tuple projection initializers work by using the variable or field names from the right-hand side of a tuple initialization statement.</span></span>
<span data-ttu-id="31fbf-167">Pokud je zadán explicitní název, který má přednost před libovolným názvem projektu.</span><span class="sxs-lookup"><span data-stu-id="31fbf-167">If an explicit name is given, that takes precedence over any projected name.</span></span> <span data-ttu-id="31fbf-168">Například v následujícím inicializátoru jsou prvky `explicitFieldOne` a `explicitFieldTwo` , nikoli `localVariableOne` a `localVariableTwo` :</span><span class="sxs-lookup"><span data-stu-id="31fbf-168">For example, in the following initializer, the elements are `explicitFieldOne` and `explicitFieldTwo`, not `localVariableOne` and `localVariableTwo`:</span></span>

[!code-csharp[ExplicitNamedTuple](../../samples/snippets/csharp/tuples/program.cs#ProjectionExample_Explicit "Explicitly named tuple")]

<span data-ttu-id="31fbf-169">Pro jakékoli pole, kde není zadáno explicitní jméno, je projekt použit s implicitním názvem.</span><span class="sxs-lookup"><span data-stu-id="31fbf-169">For any field where an explicit name is not provided, an applicable implicit name is projected.</span></span> <span data-ttu-id="31fbf-170">Neexistuje žádný požadavek na poskytování sémantických názvů buď explicitně, nebo implicitně.</span><span class="sxs-lookup"><span data-stu-id="31fbf-170">There is no requirement to provide semantic names, either explicitly or implicitly.</span></span> <span data-ttu-id="31fbf-171">Následující inicializátor má názvy polí `Item1` , jejichž hodnota je `42` a `stringContent` , jejíž hodnota je "odpověď na vše":</span><span class="sxs-lookup"><span data-stu-id="31fbf-171">The following initializer has     field names `Item1`, whose value is `42` and `stringContent`, whose value is "The answer to everything":</span></span>

[!code-csharp[MixedTuple](../../samples/snippets/csharp/tuples/program.cs#MixedTuple "mixed tuple")]

<span data-ttu-id="31fbf-172">Existují dvě podmínky, kdy názvy polí kandidátů nejsou promítnuty do pole řazené kolekce členů:</span><span class="sxs-lookup"><span data-stu-id="31fbf-172">There are two conditions where candidate field names are not projected onto the tuple field:</span></span>

1. <span data-ttu-id="31fbf-173">Pokud je kandidátem název vyhrazený název řazené kolekce členů.</span><span class="sxs-lookup"><span data-stu-id="31fbf-173">When the candidate name is a reserved tuple name.</span></span> <span data-ttu-id="31fbf-174">Příklady zahrnují `Item3` , `ToString` nebo `Rest` .</span><span class="sxs-lookup"><span data-stu-id="31fbf-174">Examples include `Item3`, `ToString`, or `Rest`.</span></span>
1. <span data-ttu-id="31fbf-175">Pokud je název kandidáta duplicitní s jiným názvem pole řazené kolekce členů, buď explicitní, nebo implicitní.</span><span class="sxs-lookup"><span data-stu-id="31fbf-175">When the candidate name is a duplicate of another tuple field name, either explicit or implicit.</span></span>

<span data-ttu-id="31fbf-176">Tyto podmínky zabraňují nejednoznačnosti.</span><span class="sxs-lookup"><span data-stu-id="31fbf-176">These conditions avoid ambiguity.</span></span> <span data-ttu-id="31fbf-177">Tyto názvy by způsobily nejednoznačnost, pokud byly použity jako názvy polí v řazené kolekci členů.</span><span class="sxs-lookup"><span data-stu-id="31fbf-177">These names would cause an ambiguity if they were used as the field names for a field in a tuple.</span></span> <span data-ttu-id="31fbf-178">Ani jedna z těchto podmínek nezpůsobí chyby při kompilaci.</span><span class="sxs-lookup"><span data-stu-id="31fbf-178">Neither of these conditions cause compile-time errors.</span></span> <span data-ttu-id="31fbf-179">Místo toho pro prvky bez projektových názvů nejsou pro ně sémanticky pojmenovány.</span><span class="sxs-lookup"><span data-stu-id="31fbf-179">Instead, the elements without projected names do not have semantic names projected for them.</span></span>  <span data-ttu-id="31fbf-180">Následující příklady znázorňují tyto podmínky:</span><span class="sxs-lookup"><span data-stu-id="31fbf-180">The following examples demonstrate these conditions:</span></span>

[!code-csharp-interactive[Ambiguity](../../samples/snippets/csharp/tuples/program.cs#ProjectionAmbiguities "tuples where projections are not performed")]

<span data-ttu-id="31fbf-181">Tyto situace nezpůsobují chyby kompilátoru, protože by se jednalo o zásadní změnu kódu napsaného v jazyce C# 7,0, pokud nejsou k dispozici žádné projekce názvu pole řazené kolekce členů.</span><span class="sxs-lookup"><span data-stu-id="31fbf-181">These situations do not cause compiler errors because that would be a breaking change for code written with C# 7.0, when tuple field name projections were not available.</span></span>

## <a name="equality-and-tuples"></a><span data-ttu-id="31fbf-182">Rovnost a řazené kolekce členů</span><span class="sxs-lookup"><span data-stu-id="31fbf-182">Equality and tuples</span></span>

<span data-ttu-id="31fbf-183">Počínaje jazykem C# 7,3 typy řazené kolekce členů `==` podporují `!=` operátory a.</span><span class="sxs-lookup"><span data-stu-id="31fbf-183">Beginning with C# 7.3, tuple types support the `==` and `!=` operators.</span></span> <span data-ttu-id="31fbf-184">Tyto operátory pracují pomocí porovnání jednotlivých členů levého argumentu s každým členem pravého argumentu v daném pořadí.</span><span class="sxs-lookup"><span data-stu-id="31fbf-184">These operators work by comparing each member of the left argument to each member of the right argument in order.</span></span> <span data-ttu-id="31fbf-185">Tyto porovnávací krátkodobé okruhy.</span><span class="sxs-lookup"><span data-stu-id="31fbf-185">These comparisons short-circuit.</span></span> <span data-ttu-id="31fbf-186">Přestanou vyhodnocovat členy, jakmile se jeden pár nerovná.</span><span class="sxs-lookup"><span data-stu-id="31fbf-186">They will stop evaluating members as soon as one pair is not equal.</span></span> <span data-ttu-id="31fbf-187">Následující příklady kódu používají `==` , ale pravidla porovnání platí pro `!=` .</span><span class="sxs-lookup"><span data-stu-id="31fbf-187">The following code examples use `==`, but the comparison rules all apply to `!=`.</span></span> <span data-ttu-id="31fbf-188">Následující příklad kódu ukazuje porovnání rovnosti pro dvě páry celých čísel:</span><span class="sxs-lookup"><span data-stu-id="31fbf-188">The following code example shows an equality comparison for two pairs of integers:</span></span>

[!code-csharp-interactive[TupleEquality](../../samples/snippets/csharp/tuples/program.cs#Equality "Testing tuples for equality")]

<span data-ttu-id="31fbf-189">Existuje několik pravidel, která umožňují pohodlnější testy rovnosti řazené kolekce členů.</span><span class="sxs-lookup"><span data-stu-id="31fbf-189">There are several rules that make tuple equality tests more convenient.</span></span> <span data-ttu-id="31fbf-190">Rovnost řazené kolekce členů provádí převedené [převody](~/_csharplang/spec/conversions.md#lifted-conversion-operators) , pokud je jedna z řazených kolekcí členů s možnou hodnotou null, jak je znázorněno v následujícím kódu:</span><span class="sxs-lookup"><span data-stu-id="31fbf-190">Tuple equality performs [lifted conversions](~/_csharplang/spec/conversions.md#lifted-conversion-operators) if one of the tuples is a nullable tuple, as shown in the following code:</span></span>

[!code-csharp-interactive[NullableTupleEquality](../../samples/snippets/csharp/tuples/program.cs#NullableEquality "Comparing Tuples and nullable tuples")]

<span data-ttu-id="31fbf-191">Rovnost řazené kolekce členů také provádí implicitní převody na každého členu obou řazených kolekcí členů.</span><span class="sxs-lookup"><span data-stu-id="31fbf-191">Tuple equality also performs implicit conversions on each member of both tuples.</span></span> <span data-ttu-id="31fbf-192">Patří mezi ně zrušené převody, rozšiřující převody nebo jiné implicitní převody.</span><span class="sxs-lookup"><span data-stu-id="31fbf-192">These include lifted conversions, widening conversions, or other implicit conversions.</span></span> <span data-ttu-id="31fbf-193">Následující příklady ukazují, že celočíselná hodnota 2 – řazená kolekce členů může být porovnána s dlouhou meziřazenou kolekcí členů z důvodu implicitního převodu z celého čísla na Long:</span><span class="sxs-lookup"><span data-stu-id="31fbf-193">The following examples show that an integer 2-tuple can be compared to a long 2-tuple because of the implicit conversion from integer to long:</span></span>

[!code-csharp-interactive[SnippetMemberConversions](../../samples/snippets/csharp/tuples/program.cs#SnippetMemberConversions "converting tuples for equality tests")]

<span data-ttu-id="31fbf-194">Názvy členů řazené kolekce členů se neúčastní testů pro rovnost.</span><span class="sxs-lookup"><span data-stu-id="31fbf-194">The names of the tuple members do not participate in tests for equality.</span></span> <span data-ttu-id="31fbf-195">Pokud je však jeden z operandů literál řazené kolekce členů s explicitními názvy, kompilátor vygeneruje upozornění CS8383, pokud tyto názvy neodpovídají názvům jiného operandu.</span><span class="sxs-lookup"><span data-stu-id="31fbf-195">However, if one of the operands is a tuple literal with explicit names, the compiler generates warning CS8383 if those names do not match the names of the other operand.</span></span>
<span data-ttu-id="31fbf-196">V případě, kdy jsou oba operandy literály řazené kolekce členů, je upozornění na pravém operandu, jak je znázorněno v následujícím příkladu:</span><span class="sxs-lookup"><span data-stu-id="31fbf-196">In the case where both operands are tuple literals, the warning is on the right operand as shown in the following example:</span></span>

[!code-csharp-interactive[MemberNames](../../samples/snippets/csharp/tuples/program.cs#SnippetMemberNames "Tuple member names do not participate in equality tests")]

<span data-ttu-id="31fbf-197">A konečně, řazené kolekce členů můžou obsahovat vnořené řazené kolekce členů.</span><span class="sxs-lookup"><span data-stu-id="31fbf-197">Finally, tuples may contain nested tuples.</span></span> <span data-ttu-id="31fbf-198">Rovnost řazené kolekce členů porovnává "tvar" každého operandu prostřednictvím vnořených řazených kolekcí členů, jak je znázorněno v následujícím příkladu:</span><span class="sxs-lookup"><span data-stu-id="31fbf-198">Tuple equality compares the "shape" of each operand through nested tuples as shown in the following example:</span></span>

[!code-csharp-interactive[NestedTuples](../../samples/snippets/csharp/tuples/program.cs#SnippetNestedTuples "Tuples may contain nested tuples that participate in tuple equality.")]

<span data-ttu-id="31fbf-199">Jedná se o chybu při kompilaci pro porovnání dvou řazených kolekcí členů s rovností (nebo nerovnosti), pokud mají různé tvary.</span><span class="sxs-lookup"><span data-stu-id="31fbf-199">It's a compile-time error to compare two tuples for equality (or inequality) when they have different shapes.</span></span> <span data-ttu-id="31fbf-200">Kompilátor se nebude pokoušet o žádné dekonstrukci vnořených řazených kolekcí členů, aby je bylo možné porovnat.</span><span class="sxs-lookup"><span data-stu-id="31fbf-200">The compiler won't attempt any deconstruction of nested tuples in order to compare them.</span></span>

## <a name="assignment-and-tuples"></a><span data-ttu-id="31fbf-201">Přiřazení a řazené kolekce členů</span><span class="sxs-lookup"><span data-stu-id="31fbf-201">Assignment and tuples</span></span>

<span data-ttu-id="31fbf-202">Jazyk podporuje přiřazení mezi typy řazené kolekce členů, které mají stejný počet prvků, kde každý prvek na pravé straně lze implicitně převést na odpovídající element na levé straně.</span><span class="sxs-lookup"><span data-stu-id="31fbf-202">The language supports assignment between tuple types that have the same number of elements, where each right-hand side element can be implicitly converted to its corresponding left-hand side element.</span></span> <span data-ttu-id="31fbf-203">Jiné převody nejsou považovány za přiřazení.</span><span class="sxs-lookup"><span data-stu-id="31fbf-203">Other conversions aren't considered for assignments.</span></span> <span data-ttu-id="31fbf-204">Jedná se o chybu při kompilaci k přiřazení jedné řazené kolekce členů k druhému, pokud mají různé tvary.</span><span class="sxs-lookup"><span data-stu-id="31fbf-204">It's a compile-time error to assign one tuple to another when they have different shapes.</span></span> <span data-ttu-id="31fbf-205">Kompilátor se nebude pokoušet o žádné dekonstrukci vnořených řazených kolekcí členů, aby je bylo možné přiřadit.</span><span class="sxs-lookup"><span data-stu-id="31fbf-205">The compiler won't attempt any deconstruction of nested tuples in order to assign them.</span></span>
<span data-ttu-id="31fbf-206">Pojďme se podívat na typy přiřazení, která jsou povolená mezi typy řazené kolekce členů.</span><span class="sxs-lookup"><span data-stu-id="31fbf-206">Let's look at the kinds of assignments that are allowed between tuple types.</span></span>

<span data-ttu-id="31fbf-207">Vezměte v úvahu tyto proměnné, které se používají v následujících příkladech:</span><span class="sxs-lookup"><span data-stu-id="31fbf-207">Consider these variables used in the following examples:</span></span>

[!code-csharp[VariableCreation](../../samples/snippets/csharp/tuples/program.cs#03_VariableCreation "Variable creation")]

<span data-ttu-id="31fbf-208">První dvě proměnné a nemají `unnamed` `anonymous` pro prvky k dispozici sémantické názvy.</span><span class="sxs-lookup"><span data-stu-id="31fbf-208">The first two variables, `unnamed` and `anonymous` do not have semantic names provided for the elements.</span></span> <span data-ttu-id="31fbf-209">Názvy polí jsou `Item1` a `Item2` .</span><span class="sxs-lookup"><span data-stu-id="31fbf-209">The field names are `Item1` and `Item2`.</span></span>
<span data-ttu-id="31fbf-210">Poslední dvě proměnné `named` a `differentName` mají pro prvky zadány sémantické názvy.</span><span class="sxs-lookup"><span data-stu-id="31fbf-210">The last two variables, `named` and `differentName` have semantic names given for the elements.</span></span> <span data-ttu-id="31fbf-211">Tyto dvě řazené kolekce členů mají různé názvy pro prvky.</span><span class="sxs-lookup"><span data-stu-id="31fbf-211">These two tuples have different names for the elements.</span></span>

<span data-ttu-id="31fbf-212">Všechny čtyři tyto řazené kolekce členů mají stejný počet elementů (označovaných jako mohutnost) a typy těchto elementů jsou identické.</span><span class="sxs-lookup"><span data-stu-id="31fbf-212">All four of these tuples have the same number of elements (referred to as 'cardinality') and the types of those elements are identical.</span></span> <span data-ttu-id="31fbf-213">Proto všechna tato přiřazení fungují:</span><span class="sxs-lookup"><span data-stu-id="31fbf-213">Therefore, all of these assignments work:</span></span>

[!code-csharp[VariableAssignment](../../samples/snippets/csharp/tuples/program.cs#04_VariableAssignment "Variable assignment")]

<span data-ttu-id="31fbf-214">Všimněte si, že názvy řazených kolekcí členů nejsou přiřazeny.</span><span class="sxs-lookup"><span data-stu-id="31fbf-214">Notice that the names of the tuples are not assigned.</span></span> <span data-ttu-id="31fbf-215">Hodnoty prvků jsou přiřazeny podle pořadí prvků v řazené kolekci členů.</span><span class="sxs-lookup"><span data-stu-id="31fbf-215">The values of the elements are assigned following the order of the elements in the tuple.</span></span>

<span data-ttu-id="31fbf-216">Řazené kolekce členů různých typů nebo čísel prvků nelze přiřadit:</span><span class="sxs-lookup"><span data-stu-id="31fbf-216">Tuples of different types or numbers of elements are not assignable:</span></span>

```csharp
// Does not compile.
// CS0029: Cannot assign Tuple(int,int,int) to Tuple(int, string)
var differentShape = (1, 2, 3);
named = differentShape;
```

## <a name="tuples-as-method-return-values"></a><span data-ttu-id="31fbf-217">Řazené kolekce členů jako návratové hodnoty metody</span><span class="sxs-lookup"><span data-stu-id="31fbf-217">Tuples as method return values</span></span>

<span data-ttu-id="31fbf-218">Jedním z nejběžnějších použití pro řazené kolekce členů je jako návratová hodnota metody.</span><span class="sxs-lookup"><span data-stu-id="31fbf-218">One of the most common uses for tuples is as a method return value.</span></span> <span data-ttu-id="31fbf-219">Pojďme si projít jeden příklad.</span><span class="sxs-lookup"><span data-stu-id="31fbf-219">Let's walk through one example.</span></span> <span data-ttu-id="31fbf-220">Zvažte tuto metodu, která vypočítá směrodatnou odchylku pro posloupnost čísel:</span><span class="sxs-lookup"><span data-stu-id="31fbf-220">Consider this method that computes the standard deviation for a sequence of numbers:</span></span>

[!code-csharp[StandardDeviation](../../samples/snippets/csharp/tuples/statistics.cs#05_StandardDeviation "Compute Standard Deviation")]

> [!NOTE]
> <span data-ttu-id="31fbf-221">Tyto příklady vypočítají nesprávnou směrodatnou odchylku vzorků.</span><span class="sxs-lookup"><span data-stu-id="31fbf-221">These examples compute the uncorrected sample standard deviation.</span></span>
> <span data-ttu-id="31fbf-222">Opravený Vzorec směrodatné odchylky (standardní vzorek) rozdělí součet kvadratických rozdílů od střední hodnoty (N-1) namísto N, jako `Average` metoda rozšíření.</span><span class="sxs-lookup"><span data-stu-id="31fbf-222">The corrected sample standard deviation formula would divide the sum of the squared differences from the mean by (N-1) instead of N, as the `Average` extension method does.</span></span>

<span data-ttu-id="31fbf-223">Předchozí kód následuje vzorec Textbook pro směrodatnou odchylku.</span><span class="sxs-lookup"><span data-stu-id="31fbf-223">The preceding code follows the textbook formula for the standard deviation.</span></span> <span data-ttu-id="31fbf-224">Vytváří správnou odpověď, ale jedná se o neefektivní implementaci.</span><span class="sxs-lookup"><span data-stu-id="31fbf-224">It produces the correct answer, but it's an inefficient implementation.</span></span> <span data-ttu-id="31fbf-225">Tato metoda sestaví sekvenci dvakrát: jednou pro vytvoření průměru a jednou pro vytvoření průměru z čtverce rozdílu v průměru.</span><span class="sxs-lookup"><span data-stu-id="31fbf-225">This method enumerates the sequence twice: Once to produce the average, and once to produce the average of the square of the difference of the average.</span></span>
<span data-ttu-id="31fbf-226">(Nezapomeňte, že dotazy LINQ jsou vyhodnoceny jako laxně vytvářená, takže výpočet rozdílů od střední hodnoty a průměr těchto rozdílů činí pouze jeden výčet.)</span><span class="sxs-lookup"><span data-stu-id="31fbf-226">(Remember that LINQ queries are evaluated lazily, so the computation of the differences from the mean and the average of those differences makes only one enumeration.)</span></span>

<span data-ttu-id="31fbf-227">Existuje alternativní vzorec, který počítá směrodatnou odchylku pomocí pouze jednoho výčtu sekvence.</span><span class="sxs-lookup"><span data-stu-id="31fbf-227">There is an alternative formula that computes standard deviation using only one enumeration of the sequence.</span></span>  <span data-ttu-id="31fbf-228">Tento výpočet vytvoří dvě hodnoty, protože sestaví sekvenci: součet všech položek v sekvenci a součet každé hodnoty čtverce:</span><span class="sxs-lookup"><span data-stu-id="31fbf-228">This computation produces two values as it enumerates the sequence: the sum of all items in the sequence, and the sum of each value squared:</span></span>

[!code-csharp[SumOfSquaresFormula](../../samples/snippets/csharp/tuples/statistics.cs#06_SumOfSquaresFormula "Compute Standard Deviation using the sum of squares")]

<span data-ttu-id="31fbf-229">Tato verze sestaví sekvenci přesně jednou.</span><span class="sxs-lookup"><span data-stu-id="31fbf-229">This version enumerates the sequence exactly once.</span></span> <span data-ttu-id="31fbf-230">Nejedná se ale o opakovaně použitelný kód.</span><span class="sxs-lookup"><span data-stu-id="31fbf-230">But it's not reusable code.</span></span> <span data-ttu-id="31fbf-231">Jak budete pracovat, zjistíte, že mnoho různých statistických výpočtů používá počet položek v sekvenci, součet sekvence a součet čtverců sekvence.</span><span class="sxs-lookup"><span data-stu-id="31fbf-231">As you keep working, you'll find that many different statistical computations use the number of items in the sequence, the sum of the sequence, and the sum of the squares of the sequence.</span></span> <span data-ttu-id="31fbf-232">Pojďme tuto metodu Refaktorovat a napsat metodu nástroje, která vytvoří všechny tři tyto hodnoty.</span><span class="sxs-lookup"><span data-stu-id="31fbf-232">Let's refactor this method and write a utility method that produces all three of those values.</span></span> <span data-ttu-id="31fbf-233">Všechny tři hodnoty mohou být vráceny jako řazené kolekce členů.</span><span class="sxs-lookup"><span data-stu-id="31fbf-233">All three values can be returned as a tuple.</span></span>

<span data-ttu-id="31fbf-234">Pojďme tuto metodu aktualizovat tak, aby tři hodnoty vypočítané během výčtu byly uloženy v řazené kolekci členů.</span><span class="sxs-lookup"><span data-stu-id="31fbf-234">Let's update this method so the three values computed during the enumeration are stored in a tuple.</span></span> <span data-ttu-id="31fbf-235">Vytváří tuto verzi:</span><span class="sxs-lookup"><span data-stu-id="31fbf-235">That creates this version:</span></span>

[!code-csharp[TupleVersion](../../samples/snippets/csharp/tuples/statistics.cs#07_TupleVersion "Refactor to use tuples")]

<span data-ttu-id="31fbf-236">Podpora refaktoringu sady Visual Studio usnadňuje extrakci funkcí základních statistik do privátní metody.</span><span class="sxs-lookup"><span data-stu-id="31fbf-236">Visual Studio's Refactoring support makes it easy to extract the functionality for the core statistics into a private method.</span></span> <span data-ttu-id="31fbf-237">Poskytuje `private static` metodu, která vrací typ řazené kolekce členů se třemi hodnotami `Sum` , `SumOfSquares` a `Count` :</span><span class="sxs-lookup"><span data-stu-id="31fbf-237">That gives you a `private static` method that returns the tuple type with the three values of `Sum`, `SumOfSquares`, and `Count`:</span></span>

[!code-csharp[TupleMethodVersion](../../samples/snippets/csharp/tuples/statistics.cs#08_TupleMethodVersion "After extracting utility method")]

<span data-ttu-id="31fbf-238">Jazyk umožňuje několik dalších možností, které můžete použít, pokud chcete udělat několik rychlých úprav ručně.</span><span class="sxs-lookup"><span data-stu-id="31fbf-238">The language enables a couple more options that you can use, if you want to make a few quick edits by hand.</span></span> <span data-ttu-id="31fbf-239">Nejprve můžete použít `var` deklaraci k inicializaci výsledku řazené kolekce členů z `ComputeSumAndSumOfSquares` volání metody.</span><span class="sxs-lookup"><span data-stu-id="31fbf-239">First, you can use the `var` declaration to initialize the tuple result from the `ComputeSumAndSumOfSquares` method call.</span></span> <span data-ttu-id="31fbf-240">V rámci metody můžete také vytvořit tři diskrétní proměnné `ComputeSumAndSumOfSquares` .</span><span class="sxs-lookup"><span data-stu-id="31fbf-240">You can also create three discrete variables inside the `ComputeSumAndSumOfSquares` method.</span></span> <span data-ttu-id="31fbf-241">Finální verze je zobrazená v následujícím kódu:</span><span class="sxs-lookup"><span data-stu-id="31fbf-241">The final version is shown in the following code:</span></span>

[!code-csharp[CleanedTupleVersion](../../samples/snippets/csharp/tuples/statistics.cs#09_CleanedTupleVersion "After final cleanup")]

<span data-ttu-id="31fbf-242">Tato konečná verze se dá použít pro libovolnou metodu, která potřebuje tyto tři hodnoty, nebo jakoukoli její podmnožinu.</span><span class="sxs-lookup"><span data-stu-id="31fbf-242">This final version can be used for any method that needs those three values, or any subset of them.</span></span>

<span data-ttu-id="31fbf-243">Jazyk podporuje další možnosti správy názvů prvků v těchto metodách vracejících řazené kolekce členů.</span><span class="sxs-lookup"><span data-stu-id="31fbf-243">The language supports other options in managing the names of the elements in these tuple-returning methods.</span></span>

<span data-ttu-id="31fbf-244">Můžete odebrat názvy polí z deklarace návratové hodnoty a vrátit nepojmenované řazené kolekce členů:</span><span class="sxs-lookup"><span data-stu-id="31fbf-244">You can remove the field names from the return value declaration and return an unnamed tuple:</span></span>

```csharp
private static (double, double, int) ComputeSumAndSumOfSquares(IEnumerable<double> sequence)
{
    double sum = 0;
    double sumOfSquares = 0;
    int count = 0;

    foreach (var item in sequence)
    {
        count++;
        sum += item;
        sumOfSquares += item * item;
    }

    return (sum, sumOfSquares, count);
}
```

<span data-ttu-id="31fbf-245">Pole této řazené kolekce členů jsou pojmenovány `Item1` , `Item2` a `Item3` .</span><span class="sxs-lookup"><span data-stu-id="31fbf-245">The fields of this tuple are named `Item1`, `Item2`, and `Item3`.</span></span>
<span data-ttu-id="31fbf-246">Doporučuje se poskytnout sémantické názvy prvků řazených kolekcí členů vrácených z metod.</span><span class="sxs-lookup"><span data-stu-id="31fbf-246">It's recommended that you provide semantic names to the elements of tuples returned from methods.</span></span>

<span data-ttu-id="31fbf-247">Další idiom v případě, že řazené kolekce členů mohou být užitečné, je při vytváření dotazů LINQ.</span><span class="sxs-lookup"><span data-stu-id="31fbf-247">Another idiom where tuples can be useful is when you are authoring LINQ queries.</span></span> <span data-ttu-id="31fbf-248">Konečný plánovaný výsledek často obsahuje některé z vlastností objektů, které jsou vybrány, ale ne všechny.</span><span class="sxs-lookup"><span data-stu-id="31fbf-248">The final projected result often contains some, but not all, of the properties of the objects being selected.</span></span>

<span data-ttu-id="31fbf-249">Výsledky dotazu byste měli zamítnout do posloupnosti objektů, které byly anonymního typu.</span><span class="sxs-lookup"><span data-stu-id="31fbf-249">You would traditionally project the results of the query into a sequence of objects that were an anonymous type.</span></span> <span data-ttu-id="31fbf-250">, Který prezentuje mnoho omezení, hlavně proto, že anonymní typy nelze pohodlně pojmenovat v návratovém typu pro metodu.</span><span class="sxs-lookup"><span data-stu-id="31fbf-250">That presented many limitations, primarily because anonymous types could not conveniently be named in the return type for a method.</span></span> <span data-ttu-id="31fbf-251">Alternativy použití `object` nebo `dynamic` jako typ výsledku byly v důsledku značných nákladů na výkon.</span><span class="sxs-lookup"><span data-stu-id="31fbf-251">Alternatives using `object` or `dynamic` as the type of the result came with significant performance costs.</span></span>

<span data-ttu-id="31fbf-252">Vrácení sekvence typu řazené kolekce členů je jednoduché a názvy a typy prvků jsou k dispozici v době kompilace a prostřednictvím nástrojů IDE.</span><span class="sxs-lookup"><span data-stu-id="31fbf-252">Returning a sequence of a tuple type is easy, and the names and types of the elements are available at compile time and through IDE tools.</span></span>
<span data-ttu-id="31fbf-253">Zvažte například aplikaci ToDo.</span><span class="sxs-lookup"><span data-stu-id="31fbf-253">For example, consider a ToDo application.</span></span> <span data-ttu-id="31fbf-254">Můžete definovat třídu podobnou následující, aby představovala jedinou položku v seznamu ToDo:</span><span class="sxs-lookup"><span data-stu-id="31fbf-254">You might define a class similar to the following to represent a single entry in the ToDo list:</span></span>

[!code-csharp[ToDoItem](../../samples/snippets/csharp/tuples/projectionsample.cs#14_ToDoItem "To Do Item")]

<span data-ttu-id="31fbf-255">Vaše mobilní aplikace mohou podporovat kompaktní formu aktuálních položek ToDo, které zobrazují pouze nadpis.</span><span class="sxs-lookup"><span data-stu-id="31fbf-255">Your mobile applications may support a compact form of the current ToDo items that only displays the title.</span></span> <span data-ttu-id="31fbf-256">Tento dotaz LINQ by provedl projekci, která obsahuje pouze ID a název.</span><span class="sxs-lookup"><span data-stu-id="31fbf-256">That LINQ query would make a projection that includes only the ID and the title.</span></span> <span data-ttu-id="31fbf-257">Metoda, která vrací sekvenci řazených kolekcí členů vyjadřuje tento návrh dobře:</span><span class="sxs-lookup"><span data-stu-id="31fbf-257">A method that returns a sequence of tuples expresses that design well:</span></span>

[!code-csharp[QueryReturningTuple](../../samples/snippets/csharp/tuples/projectionsample.cs#15_QueryReturningTuple "Query returning a tuple")]

> [!NOTE]
> <span data-ttu-id="31fbf-258">V C# 7,1, projekce v rámci řazené kolekce členů umožňují vytvářet pojmenované řazené kolekce členů pomocí prvků podobně jako vlastnost pojmenování v anonymních typech.</span><span class="sxs-lookup"><span data-stu-id="31fbf-258">In C# 7.1, tuple projections enable you to create named tuples using elements, in a manner similar to the property naming in anonymous types.</span></span> <span data-ttu-id="31fbf-259">Ve výše uvedeném kódu `select` příkaz v projekci dotazu vytvoří řazenou kolekci členů, která obsahuje prvky `ID` a `Title` .</span><span class="sxs-lookup"><span data-stu-id="31fbf-259">In the above code, the `select` statement in the query projection creates a tuple that has elements `ID` and `Title`.</span></span>

<span data-ttu-id="31fbf-260">Pojmenovaná řazená kolekce členů může být součástí signatury.</span><span class="sxs-lookup"><span data-stu-id="31fbf-260">The named tuple can be part of the signature.</span></span> <span data-ttu-id="31fbf-261">Umožňuje kompilátoru a nástrojům IDE poskytovat statickou kontrolu, že výsledek používáte správně.</span><span class="sxs-lookup"><span data-stu-id="31fbf-261">It lets the compiler and IDE tools provide static checking that you are using the result correctly.</span></span> <span data-ttu-id="31fbf-262">Pojmenované řazené kolekce členů také přenáší informace o statickém typu, takže není nutné používat nákladné funkce běhu jako reflexe nebo dynamická vazba pro práci s výsledky.</span><span class="sxs-lookup"><span data-stu-id="31fbf-262">The named tuple also carries the static type information so there is no need to use expensive run time features like reflection or dynamic binding to work with the results.</span></span>

## <a name="deconstruction"></a><span data-ttu-id="31fbf-263">Dekonstrukce</span><span class="sxs-lookup"><span data-stu-id="31fbf-263">Deconstruction</span></span>

<span data-ttu-id="31fbf-264">Můžete odbalit všechny položky v řazené kolekci členů tím, že *dekonstruujete* řazenou kolekci členů vrácenou metodou.</span><span class="sxs-lookup"><span data-stu-id="31fbf-264">You can unpackage all the items in a tuple by *deconstructing* the tuple returned by a method.</span></span> <span data-ttu-id="31fbf-265">Existují tři různé přístupy k dekonstrukci řazených kolekcí členů.</span><span class="sxs-lookup"><span data-stu-id="31fbf-265">There are three different approaches to deconstructing tuples.</span></span>  <span data-ttu-id="31fbf-266">Nejprve můžete explicitně deklarovat typ každého pole uvnitř závorek a vytvořit tak diskrétní proměnné pro každý prvek řazené kolekce členů:</span><span class="sxs-lookup"><span data-stu-id="31fbf-266">First, you can explicitly declare the type of each field inside parentheses to create discrete variables for each of the elements in the tuple:</span></span>

[!code-csharp[Deconstruct](../../samples/snippets/csharp/tuples/statistics.cs#10_Deconstruct "Deconstruct")]

<span data-ttu-id="31fbf-267">Můžete také deklarovat implicitně typové proměnné pro každé pole v řazené kolekci členů pomocí `var` klíčového slova vně závorek:</span><span class="sxs-lookup"><span data-stu-id="31fbf-267">You can also declare implicitly typed variables for each field in a tuple by using the `var` keyword outside the parentheses:</span></span>

[!code-csharp[DeconstructToVar](../../samples/snippets/csharp/tuples/statistics.cs#11_DeconstructToVar "Deconstruct to Var")]

<span data-ttu-id="31fbf-268">Také je právní použití `var` klíčového slova s libovolnou nebo všemi deklaracemi proměnných uvnitř závorek.</span><span class="sxs-lookup"><span data-stu-id="31fbf-268">It is also legal to use the `var` keyword with any, or all of the variable declarations inside the parentheses.</span></span>

```csharp
(double sum, var sumOfSquares, var count) = ComputeSumAndSumOfSquares(sequence);
```

<span data-ttu-id="31fbf-269">Nemůžete použít konkrétní typ mimo závorky, a to ani v případě, že každé pole v řazené kolekci členů má stejný typ.</span><span class="sxs-lookup"><span data-stu-id="31fbf-269">You cannot use a specific type outside the parentheses, even if every field in the tuple has the same type.</span></span>

<span data-ttu-id="31fbf-270">Můžete dekonstruovat řazené kolekce členů i s existujícími deklaracemi:</span><span class="sxs-lookup"><span data-stu-id="31fbf-270">You can deconstruct tuples with existing declarations as well:</span></span>

```csharp
public class Point
{
    public int X { get; set; }
    public int Y { get; set; }

    public Point(int x, int y) => (X, Y) = (x, y);
}
```

> [!WARNING]
> <span data-ttu-id="31fbf-271">V závorkách nelze kombinovat existující deklarace s deklaracemi.</span><span class="sxs-lookup"><span data-stu-id="31fbf-271">You cannot mix existing declarations with declarations inside the parentheses.</span></span> <span data-ttu-id="31fbf-272">Následující není například povoleno: `(var x, y) = MyMethod();` .</span><span class="sxs-lookup"><span data-stu-id="31fbf-272">For instance, the following is not allowed: `(var x, y) = MyMethod();`.</span></span> <span data-ttu-id="31fbf-273">Tím se vytvoří chyba CS8184, protože *x* je deklarované uvnitř závorek a *y* je dřív deklarovaný jinde.</span><span class="sxs-lookup"><span data-stu-id="31fbf-273">This produces error CS8184 because *x* is declared inside the parentheses and *y* is previously declared elsewhere.</span></span>

### <a name="deconstructing-user-defined-types"></a><span data-ttu-id="31fbf-274">Dekonstrukce uživatelem definovaných typů</span><span class="sxs-lookup"><span data-stu-id="31fbf-274">Deconstructing user-defined types</span></span>

<span data-ttu-id="31fbf-275">Libovolný typ řazené kolekce členů lze dekonstruovat, jak je uvedeno výše.</span><span class="sxs-lookup"><span data-stu-id="31fbf-275">Any tuple type can be deconstructed as shown above.</span></span> <span data-ttu-id="31fbf-276">Je také snadné povolit dekonstrukci u libovolného uživatelsky definovaného typu (třídy, struktury nebo dokonce rozhraní).</span><span class="sxs-lookup"><span data-stu-id="31fbf-276">It's also easy to enable deconstruction on any user-defined type (classes, structs, or even interfaces).</span></span>

<span data-ttu-id="31fbf-277">Autor typu může definovat jednu nebo více `Deconstruct` metod, které přiřazují hodnoty k libovolnému počtu [ `out` proměnných](language-reference/keywords/out-parameter-modifier.md) reprezentujícím datové prvky, které tvoří typ.</span><span class="sxs-lookup"><span data-stu-id="31fbf-277">The type author can define one or more `Deconstruct` methods that assign values to any number of [`out` variables](language-reference/keywords/out-parameter-modifier.md) representing the data elements that make up the type.</span></span> <span data-ttu-id="31fbf-278">Například následující `Person` typ definuje `Deconstruct` metodu, která dekonstruuje objekt Person do prvků představujících křestní jméno a příjmení:</span><span class="sxs-lookup"><span data-stu-id="31fbf-278">For example, the following `Person` type defines a `Deconstruct` method that deconstructs a person object into the elements representing the first name and last name:</span></span>

[!code-csharp[TypeWithDeconstructMethod](../../samples/snippets/csharp/tuples/person.cs#12_TypeWithDeconstructMethod "Type with a deconstruct method")]

<span data-ttu-id="31fbf-279">Metoda dekonstrukce umožňuje přiřazení z a `Person` do dvou řetězců, které představují `FirstName` vlastnosti a `LastName` :</span><span class="sxs-lookup"><span data-stu-id="31fbf-279">The deconstruct method enables assignment from a `Person` to two strings, representing the `FirstName` and `LastName` properties:</span></span>

[!code-csharp[Deconstruct Type](../../samples/snippets/csharp/tuples/program.cs#12A_DeconstructType "Deconstruct a class type")]

<span data-ttu-id="31fbf-280">Můžete povolit dekonstrukci i pro typy, které jste nevytvořili.</span><span class="sxs-lookup"><span data-stu-id="31fbf-280">You can enable deconstruction even for types you did not author.</span></span>
<span data-ttu-id="31fbf-281">`Deconstruct`Metoda může být metoda rozšíření, která odbalí přístupné datové členy objektu.</span><span class="sxs-lookup"><span data-stu-id="31fbf-281">The `Deconstruct` method can be an extension method that unpackages the accessible data members of an object.</span></span> <span data-ttu-id="31fbf-282">Níže uvedený příklad ukazuje `Student` typ, odvozený z `Person` typu, a metodu rozšíření, která dekonstruujee `Student` do tří proměnných, reprezentující `FirstName` , `LastName` a `GPA` :</span><span class="sxs-lookup"><span data-stu-id="31fbf-282">The example below shows a `Student` type, derived from the `Person` type, and an extension method that deconstructs a `Student` into three variables, representing the `FirstName`, the `LastName`, and the `GPA`:</span></span>

[!code-csharp[ExtensionDeconstructMethod](../../samples/snippets/csharp/tuples/person.cs#13_ExtensionDeconstructMethod "Type with a deconstruct extension method")]

<span data-ttu-id="31fbf-283">`Student`Objekt má nyní dvě dostupné `Deconstruct` metody: metodu rozšíření deklarovanou pro `Student` typy a člena `Person` typu.</span><span class="sxs-lookup"><span data-stu-id="31fbf-283">A `Student` object now has two accessible `Deconstruct` methods: the extension method declared for `Student` types, and the member of the `Person` type.</span></span> <span data-ttu-id="31fbf-284">Obě jsou v oboru, což umožňuje, `Student` aby bylo možné ho rozdělit do dvou proměnných nebo tří.</span><span class="sxs-lookup"><span data-stu-id="31fbf-284">Both are in scope, and that enables a `Student` to be deconstructed into either two variables or three.</span></span>
<span data-ttu-id="31fbf-285">Pokud každému studentovi přiřadíte tři proměnné, vrátí se všechna jeho křestní jméno, příjmení a GPA.</span><span class="sxs-lookup"><span data-stu-id="31fbf-285">If you assign a student to three variables, the first name, last name, and GPA are all returned.</span></span> <span data-ttu-id="31fbf-286">Pokud do dvou proměnných přiřadíte studenta, vrátí se pouze jméno a příjmení.</span><span class="sxs-lookup"><span data-stu-id="31fbf-286">If you assign a student to two variables, only the first name and the last name are returned.</span></span>

[!code-csharp[Deconstruct extension method](../../samples/snippets/csharp/tuples/program.cs#13A_DeconstructExtension "Deconstruct a class type using an extension method")]

<span data-ttu-id="31fbf-287">Měli byste pečlivě definovat více `Deconstruct` metod ve třídě nebo hierarchii tříd.</span><span class="sxs-lookup"><span data-stu-id="31fbf-287">You should be careful defining multiple `Deconstruct` methods in a class or a class hierarchy.</span></span> <span data-ttu-id="31fbf-288">Více `Deconstruct` metod, které mají stejný počet `out` parametrů, může rychle způsobit nejednoznačnosti.</span><span class="sxs-lookup"><span data-stu-id="31fbf-288">Multiple `Deconstruct` methods that have the same number of `out` parameters can quickly cause ambiguities.</span></span> <span data-ttu-id="31fbf-289">Volající nemusí být schopni snadno volat požadovanou `Deconstruct` metodu.</span><span class="sxs-lookup"><span data-stu-id="31fbf-289">Callers may not be able to easily call the desired `Deconstruct` method.</span></span>

<span data-ttu-id="31fbf-290">V tomto příkladu je minimální pravděpodobnost pro dvojznačné volání `Deconstruct` , protože metoda pro `Person` má dva výstupní parametry a `Deconstruct` metoda pro `Student` má tři.</span><span class="sxs-lookup"><span data-stu-id="31fbf-290">In this example, there is minimal chance for an ambiguous call because the `Deconstruct` method for `Person` has two output parameters, and the `Deconstruct` method for `Student` has three.</span></span>

<span data-ttu-id="31fbf-291">Operátory dekonstrukce se nepodílejí na testování rovnosti.</span><span class="sxs-lookup"><span data-stu-id="31fbf-291">Deconstruction operators do not participate in testing equality.</span></span> <span data-ttu-id="31fbf-292">Následující příklad generuje chybu kompilátoru CS0019:</span><span class="sxs-lookup"><span data-stu-id="31fbf-292">The following example generates compiler error CS0019:</span></span>

```csharp
Person p = new Person("Althea", "Goodwin");
if (("Althea", "Goodwin") == p)
    Console.WriteLine(p);
```

<span data-ttu-id="31fbf-293">`Deconstruct`Metoda by mohla převést `Person` objekt `p` na řazenou kolekci členů, která obsahuje dva řetězce, ale není platná v kontextu testů rovnosti.</span><span class="sxs-lookup"><span data-stu-id="31fbf-293">The `Deconstruct` method could convert the `Person` object `p` to a tuple containing two strings, but it is not applicable in the context of equality tests.</span></span>

## <a name="tuples-as-out-parameters"></a><span data-ttu-id="31fbf-294">Řazené kolekce členů jako výstupní parametry</span><span class="sxs-lookup"><span data-stu-id="31fbf-294">Tuples as out parameters</span></span>

<span data-ttu-id="31fbf-295">Řazené kolekce členů lze použít jako *samotné* [ `out` parametry](language-reference/keywords/out-parameter-modifier.md) .</span><span class="sxs-lookup"><span data-stu-id="31fbf-295">Tuples can be used as [`out` parameters](language-reference/keywords/out-parameter-modifier.md) *themselves*.</span></span> <span data-ttu-id="31fbf-296">Nepleťte si se bez jakýchkoli nejednoznačnosti dříve zmíněných v části [dekonstrukce](#deconstruction) .</span><span class="sxs-lookup"><span data-stu-id="31fbf-296">Not to be confused with any ambiguity previously mentioned in the [Deconstruction](#deconstruction) section.</span></span> <span data-ttu-id="31fbf-297">Ve volání metody potřebujete pouze popsat tvar řazené kolekce členů:</span><span class="sxs-lookup"><span data-stu-id="31fbf-297">In a method call, you need only describe the tuple's shape:</span></span>

[!code-csharp[TuplesAsOutParameters](~/samples/snippets/csharp/tuples/program.cs#01_TupleAsOutVariable "Tuples as out parameters")]

<span data-ttu-id="31fbf-298">Alternativně můžete použít [_nepojmenované_](#named-and-unnamed-tuples) řazené kolekce členů a odkazovat na své pole `Item1` jako `Item2` a:</span><span class="sxs-lookup"><span data-stu-id="31fbf-298">Alternatively, you could use an [_unnamed_](#named-and-unnamed-tuples) tuple and refer to its fields as `Item1` and `Item2`:</span></span>

```csharp
dict.TryGetValue(2, out (int, string) pair);
// ...
Console.WriteLine($"{pair.Item1}: {pair.Item2}");
```

## <a name="conclusion"></a><span data-ttu-id="31fbf-299">Závěr</span><span class="sxs-lookup"><span data-stu-id="31fbf-299">Conclusion</span></span>

<span data-ttu-id="31fbf-300">Podpora nového jazyka a knihovny pro pojmenované řazené kolekce členů usnadňuje práci s návrhy, které používají datové struktury, které ukládají více elementů, ale nedefinují chování, jako třídy a struktury.</span><span class="sxs-lookup"><span data-stu-id="31fbf-300">The new language and library support for named tuples makes it much easier to work with designs that use data structures that store multiple elements but do not define behavior, as classes and structs do.</span></span> <span data-ttu-id="31fbf-301">Použití řazených kolekcí členů pro tyto typy je jednoduché a stručné.</span><span class="sxs-lookup"><span data-stu-id="31fbf-301">It's easy and concise to use tuples for those types.</span></span> <span data-ttu-id="31fbf-302">Získáte všechny výhody kontroly statického typu, aniž byste museli vytvářet typy pomocí podrobnějšího `class` `struct` příkazu nebo syntaxe.</span><span class="sxs-lookup"><span data-stu-id="31fbf-302">You get all the benefits of static type checking, without needing to author types using the more verbose `class` or `struct` syntax.</span></span> <span data-ttu-id="31fbf-303">I tak je nejužitečnější pro obslužné metody, které jsou `private` nebo `internal` .</span><span class="sxs-lookup"><span data-stu-id="31fbf-303">Even so, they are most useful for utility methods that are `private`, or `internal`.</span></span> <span data-ttu-id="31fbf-304">Vytvořte uživatelsky definované typy, buď `class` nebo `struct` typy, pokud vaše veřejné metody vrací hodnotu, která má více prvků.</span><span class="sxs-lookup"><span data-stu-id="31fbf-304">Create user-defined types, either `class` or `struct` types when your public methods return a value that has multiple elements.</span></span>
