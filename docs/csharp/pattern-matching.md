---
title: Porovnávání vzorů – průvodce C#
description: 'Informace o vzorodpovídající výrazy v C #'
ms.date: 04/10/2019
ms.technology: csharp-fundamentals
ms.assetid: 1e575c32-2e2b-4425-9dca-7d118f3ed15b
ms.openlocfilehash: bb6baf3771024d02b2027f81fd35b8be4872cf6e
ms.sourcegitcommit: 99b153b93bf94d0fecf7c7bcecb58ac424dfa47c
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 03/25/2020
ms.locfileid: "80249230"
---
# <a name="pattern-matching"></a><span data-ttu-id="0de1f-103">Porovnávání vzorů</span><span class="sxs-lookup"><span data-stu-id="0de1f-103">Pattern Matching</span></span>

<span data-ttu-id="0de1f-104">Vzorky testují, zda má hodnota určitý *tvar*, a mohou *extrahovat* informace z hodnoty, pokud má odpovídající tvar.</span><span class="sxs-lookup"><span data-stu-id="0de1f-104">Patterns test that a value has a certain *shape*, and can *extract* information from the value when it has the matching shape.</span></span> <span data-ttu-id="0de1f-105">Porovnávání vzorů poskytuje stručnější syntaxi pro algoritmy, které již používáte dnes.</span><span class="sxs-lookup"><span data-stu-id="0de1f-105">Pattern matching provides more concise syntax for algorithms you already use today.</span></span> <span data-ttu-id="0de1f-106">Již můžete vytvořit algoritmy porovnávání vzorů pomocí existující syntaxe.</span><span class="sxs-lookup"><span data-stu-id="0de1f-106">You already create pattern matching algorithms using existing syntax.</span></span> <span data-ttu-id="0de1f-107">`if` Napíšete `switch` nebo příkazy, které testují hodnoty.</span><span class="sxs-lookup"><span data-stu-id="0de1f-107">You write `if` or `switch` statements that test values.</span></span> <span data-ttu-id="0de1f-108">Potom, když tyto příkazy shodují, extrahovat a používat informace z této hodnoty.</span><span class="sxs-lookup"><span data-stu-id="0de1f-108">Then, when those statements match, you extract and use information from that value.</span></span> <span data-ttu-id="0de1f-109">Nové prvky syntaxe jsou rozšířením příkazů, `is` které `switch`již znáte: a .</span><span class="sxs-lookup"><span data-stu-id="0de1f-109">The new syntax elements are extensions to statements you're already familiar with: `is` and `switch`.</span></span> <span data-ttu-id="0de1f-110">Tato nová rozšíření kombinovat testování hodnoty a extrahování těchto informací.</span><span class="sxs-lookup"><span data-stu-id="0de1f-110">These new extensions combine testing a value and extracting that information.</span></span>

<span data-ttu-id="0de1f-111">V tomto článku se podíváme na novou syntaxi, která vám ukáže, jak umožňuje čitelný, výstižný kód.</span><span class="sxs-lookup"><span data-stu-id="0de1f-111">In this article, we'll look at the new syntax to show you how it enables readable, concise code.</span></span> <span data-ttu-id="0de1f-112">Porovnávání vzorů umožňuje idiomy, kde jsou odděleny data a kód, na rozdíl od objektově orientovaných návrhů, kde jsou data a metody, které s nimi manipulují, pevně spojeny.</span><span class="sxs-lookup"><span data-stu-id="0de1f-112">Pattern matching enables idioms where data and the code are separated, unlike object-oriented designs where data and the methods that manipulate them are tightly coupled.</span></span>

<span data-ttu-id="0de1f-113">Pro ilustraci těchto nových idiomů, pojďme pracovat s strukturami, které představují geometrické tvary pomocí příkazy odpovídající vzorky.</span><span class="sxs-lookup"><span data-stu-id="0de1f-113">To illustrate these new idioms, let's work with structures that represent geometric shapes using pattern matching statements.</span></span> <span data-ttu-id="0de1f-114">Pravděpodobně jste obeznámeni s vytvářením hierarchií tříd a vytvářením [virtuálních metod a přepsaných metod](methods.md#inherited) pro přizpůsobení chování objektů na základě typu runtime objektu.</span><span class="sxs-lookup"><span data-stu-id="0de1f-114">You're probably familiar with building class hierarchies and creating [virtual methods and overridden methods](methods.md#inherited) to customize object behavior based on the runtime type of the object.</span></span>

<span data-ttu-id="0de1f-115">Tyto techniky nejsou možné pro data, která není strukturována v hierarchii tříd.</span><span class="sxs-lookup"><span data-stu-id="0de1f-115">Those techniques aren't possible for data that isn't structured in a class hierarchy.</span></span> <span data-ttu-id="0de1f-116">Pokud jsou data a metody oddělené, potřebujete další nástroje.</span><span class="sxs-lookup"><span data-stu-id="0de1f-116">When data and methods are separate, you need other tools.</span></span> <span data-ttu-id="0de1f-117">Nové konstrukce *porovnávání vzorů* umožňují čistší syntaxi zkoumat data a manipulovat s tokem řízení na základě jakékoli podmínky těchto dat.</span><span class="sxs-lookup"><span data-stu-id="0de1f-117">The new *pattern matching* constructs enable cleaner syntax to examine data and manipulate control flow based on any condition of that data.</span></span> <span data-ttu-id="0de1f-118">Již `if` napíšete `switch` příkazy a že test hodnoty proměnné.</span><span class="sxs-lookup"><span data-stu-id="0de1f-118">You already write `if` statements and `switch` that test a variable's value.</span></span> <span data-ttu-id="0de1f-119">Napíšete `is` příkazy, které testují typ proměnné.</span><span class="sxs-lookup"><span data-stu-id="0de1f-119">You write `is` statements that test a variable's type.</span></span> <span data-ttu-id="0de1f-120">*Porovnávání vzorů* přidá nové možnosti těchto příkazů.</span><span class="sxs-lookup"><span data-stu-id="0de1f-120">*Pattern matching* adds new capabilities to those statements.</span></span>

<span data-ttu-id="0de1f-121">V tomto článku vytvoříte metodu, která vypočítá oblast různých geometrických tvarů.</span><span class="sxs-lookup"><span data-stu-id="0de1f-121">In this article, you'll build a method  that computes the area of different geometric shapes.</span></span> <span data-ttu-id="0de1f-122">Ale uděláte to bez použití objektově orientovaných technik a vytvoření hierarchie tříd pro různé tvary.</span><span class="sxs-lookup"><span data-stu-id="0de1f-122">But, you'll do it without resorting to object-oriented techniques and building a class hierarchy for the different shapes.</span></span>
<span data-ttu-id="0de1f-123">Místo toho použijete *porovnávání vzorů.*</span><span class="sxs-lookup"><span data-stu-id="0de1f-123">You'll use *pattern matching* instead.</span></span>
<span data-ttu-id="0de1f-124">Při procházení této ukázky porovnejte tento kód s tím, jak by byl strukturován jako hierarchie objektů.</span><span class="sxs-lookup"><span data-stu-id="0de1f-124">As you go through this sample, contrast this code with how it would be structured as an object hierarchy.</span></span> <span data-ttu-id="0de1f-125">Pokud data, která je nutné dotazovat a manipulovat s nimi, nejsou hierarchií tříd, porovnávání vzorů umožňuje elegantní návrhy.</span><span class="sxs-lookup"><span data-stu-id="0de1f-125">When the data you must query and manipulate isn't a class hierarchy, pattern matching enables elegant designs.</span></span>

<span data-ttu-id="0de1f-126">Místo toho, abypočínaje abstraktní definicí tvaru a přidáním různých specifických tříd tvarů, začněme místo toho s jednoduchými definicemi dat pouze pro každý z geometrických tvarů:</span><span class="sxs-lookup"><span data-stu-id="0de1f-126">Rather than starting with an abstract shape definition and adding different specific shape classes, let's start instead with simple data only definitions for each of the geometric shapes:</span></span>

[!code-csharp[ShapeDefinitions](../../samples/snippets/csharp/PatternMatching/Shapes.cs#01_ShapeDefinitions "Shape definitions")]

<span data-ttu-id="0de1f-127">Z těchto struktur napíšeme metodu, která vypočítá oblast nějakého tvaru.</span><span class="sxs-lookup"><span data-stu-id="0de1f-127">From these structures, let's write a method that computes the area of some shape.</span></span>

## <a name="the-is-type-pattern-expression"></a><span data-ttu-id="0de1f-128">Výraz `is` vzor textu</span><span class="sxs-lookup"><span data-stu-id="0de1f-128">The `is` type pattern expression</span></span>

<span data-ttu-id="0de1f-129">Před C# 7.0, budete muset otestovat každý `if` typ `is` v sérii a příkazy:</span><span class="sxs-lookup"><span data-stu-id="0de1f-129">Before C# 7.0, you'd need to test each type in a series of `if` and `is` statements:</span></span>

[!code-csharp[ClassicIsExpression](../../samples/snippets/csharp/PatternMatching/GeometricUtilities.cs#02_ClassicIsExpression "Classic type pattern using is")]

<span data-ttu-id="0de1f-130">Tento kód výše je klasický výraz *typu vzoru*: Testujete proměnnou k určení jeho typu a s jinou akci na základě tohoto typu.</span><span class="sxs-lookup"><span data-stu-id="0de1f-130">That code above is a classic expression of the *type pattern*: You're testing a variable to determine its type and taking a different action based on that type.</span></span>

<span data-ttu-id="0de1f-131">Tento kód se stává jednodušší `is` pomocí rozšíření výrazu přiřadit proměnnou, pokud test úspěšné:</span><span class="sxs-lookup"><span data-stu-id="0de1f-131">This code becomes simpler using extensions to the `is` expression to assign a variable if the test succeeds:</span></span>

[!code-csharp[IsPatternExpression](../../samples/snippets/csharp/PatternMatching/GeometricUtilities.cs#03_IsPatternExpression "is pattern expression")]

<span data-ttu-id="0de1f-132">V této aktualizované `is` verzi výraz testuje proměnnou a přiřazuje ji k nové proměnné správného typu.</span><span class="sxs-lookup"><span data-stu-id="0de1f-132">In this updated version, the `is` expression both tests the variable and assigns it to a new variable of the proper type.</span></span> <span data-ttu-id="0de1f-133">Všimněte si také, `Rectangle` že tato verze `struct`obsahuje typ, který je .</span><span class="sxs-lookup"><span data-stu-id="0de1f-133">Also, notice that this version includes the `Rectangle` type, which is a `struct`.</span></span> <span data-ttu-id="0de1f-134">Nový `is` výraz pracuje s typy hodnot i s typy odkazů.</span><span class="sxs-lookup"><span data-stu-id="0de1f-134">The new `is` expression works with value types as well as reference types.</span></span>

<span data-ttu-id="0de1f-135">Jazyková pravidla pro výrazy porovnávání vzorů vám pomohou vyhnout se zneužití výsledků výrazu shody.</span><span class="sxs-lookup"><span data-stu-id="0de1f-135">Language rules for pattern matching expressions help you avoid misusing the results of a match expression.</span></span> <span data-ttu-id="0de1f-136">Ve výše uvedeném příkladu `c`jsou `r` proměnné `s`, a jsou pouze v oboru `true` a jednoznačně přiřazeny, pokud mají výsledky příslušné výrazy shody vzoru.</span><span class="sxs-lookup"><span data-stu-id="0de1f-136">In the example above, the variables `s`, `c`, and `r` are only in scope and definitely assigned when the respective pattern match expressions have `true` results.</span></span> <span data-ttu-id="0de1f-137">Pokud se pokusíte použít jednu z proměnných v jiném umístění, váš kód generuje chyby kompilátoru.</span><span class="sxs-lookup"><span data-stu-id="0de1f-137">If you try to use either variable in another location, your code generates compiler errors.</span></span>

<span data-ttu-id="0de1f-138">Podívejme se na obě tato pravidla podrobně, počínaje rozsahem.</span><span class="sxs-lookup"><span data-stu-id="0de1f-138">Let's examine both of those rules in detail, beginning with scope.</span></span> <span data-ttu-id="0de1f-139">Proměnná `c` je v oboru `else` pouze v `if` pobočce prvního příkazu.</span><span class="sxs-lookup"><span data-stu-id="0de1f-139">The variable `c` is in scope only in the `else` branch of the first `if` statement.</span></span> <span data-ttu-id="0de1f-140">Proměnná `s` je v oboru `ComputeAreaModernIs`v metodě .</span><span class="sxs-lookup"><span data-stu-id="0de1f-140">The variable `s` is in scope in the method `ComputeAreaModernIs`.</span></span> <span data-ttu-id="0de1f-141">Je to proto, že `if` každá větev příkazu vytvoří samostatný obor pro proměnné.</span><span class="sxs-lookup"><span data-stu-id="0de1f-141">That's because each branch of an `if` statement establishes a separate scope for variables.</span></span> <span data-ttu-id="0de1f-142">Nicméně, `if` prohlášení samo o sobě není.</span><span class="sxs-lookup"><span data-stu-id="0de1f-142">However, the `if` statement itself doesn't.</span></span> <span data-ttu-id="0de1f-143">To znamená, že `if` proměnné deklarované v `if` příkazu jsou ve stejném oboru jako příkaz (metoda v tomto případě.) Toto chování není specifické pro porovnávání vzorů, ale je `if` `else` definované chování pro proměnné obory a příkazy.</span><span class="sxs-lookup"><span data-stu-id="0de1f-143">That means variables declared in the `if` statement are in the same scope as the `if` statement (the method in this case.) This behavior isn't specific to pattern matching, but is the defined behavior for variable scopes and `if` and `else` statements.</span></span>

<span data-ttu-id="0de1f-144">Proměnné a `c` `s` jsou přiřazeny, `if` pokud jsou příslušné příkazy true z důvodu definitivně přiřazena při true mechanismu.</span><span class="sxs-lookup"><span data-stu-id="0de1f-144">The variables `c` and `s` are assigned when the respective `if` statements are true because of the definitely assigned when true mechanism.</span></span>

> [!TIP]
> <span data-ttu-id="0de1f-145">Ukázky v tomto tématu použít doporučenou konstrukci, kde vzor odpovídající `is` výraz rozhodně přiřadí match proměnnou v `true` pobočce příkazu. `if`</span><span class="sxs-lookup"><span data-stu-id="0de1f-145">The samples in this topic use the recommended construct where a pattern match `is` expression definitely assigns the match variable in the `true` branch of the `if` statement.</span></span>
> <span data-ttu-id="0de1f-146">Můžete obrátit logiku `if (!(shape is Square s))` tím, `s` že říká a proměnná by určitě přiřazena pouze v oboru. `false`</span><span class="sxs-lookup"><span data-stu-id="0de1f-146">You could reverse the logic by saying `if (!(shape is Square s))` and the variable `s` would be definitely assigned only in the `false` branch.</span></span> <span data-ttu-id="0de1f-147">I když je platný C#, není doporučeno, protože je více matoucí sledovat logiku.</span><span class="sxs-lookup"><span data-stu-id="0de1f-147">While this is valid C#, it is not recommended because it is more confusing to follow the logic.</span></span>

<span data-ttu-id="0de1f-148">Tato pravidla znamenají, že je nepravděpodobné, že byste omylem přistupovali k výsledku výrazu shody vzoru, pokud tento vzor nebyl splněn.</span><span class="sxs-lookup"><span data-stu-id="0de1f-148">These rules mean that you're unlikely to accidentally access the result of a pattern match expression when that pattern wasn't met.</span></span>

## <a name="using-pattern-matching-switch-statements"></a><span data-ttu-id="0de1f-149">Použití příkazů `switch` porovnávání vzorů</span><span class="sxs-lookup"><span data-stu-id="0de1f-149">Using pattern matching `switch` statements</span></span>

<span data-ttu-id="0de1f-150">Jak plyne čas, možná budete muset podporovat jiné typy tvarů.</span><span class="sxs-lookup"><span data-stu-id="0de1f-150">As time goes on, you may need to support other shape types.</span></span> <span data-ttu-id="0de1f-151">S tím, jak se zvyšuje počet podmínek, které `is` testujete, zjistíte, že použití výrazů odpovídajících vzorů mů e být těžkopádné.</span><span class="sxs-lookup"><span data-stu-id="0de1f-151">As the number of conditions you're testing grows, you'll find that using the `is` pattern matching expressions can become cumbersome.</span></span> <span data-ttu-id="0de1f-152">Kromě vyžadování `if` příkazů pro každý typ, který `is` chcete zkontrolovat, jsou výrazy omezeny na testování, pokud vstup odpovídá jednomu typu.</span><span class="sxs-lookup"><span data-stu-id="0de1f-152">In addition to requiring `if` statements on each type you want to check, the `is` expressions are limited to testing if the input matches a single type.</span></span> <span data-ttu-id="0de1f-153">V takovém případě zjistíte, `switch` že výrazy porovnávání vzorů se stanou lepší volbou.</span><span class="sxs-lookup"><span data-stu-id="0de1f-153">In this case, you'll find that the `switch` pattern matching expressions becomes a better choice.</span></span>

<span data-ttu-id="0de1f-154">Tradiční `switch` příkaz byl vzor výraz: podporuje konstantní vzor.</span><span class="sxs-lookup"><span data-stu-id="0de1f-154">The traditional `switch` statement was a pattern expression: it supported the constant pattern.</span></span>
<span data-ttu-id="0de1f-155">Můžete porovnat proměnnou s libovolnou `case` konstantou použitou v příkazu:</span><span class="sxs-lookup"><span data-stu-id="0de1f-155">You could compare a variable to any constant used in a `case` statement:</span></span>

[!code-csharp[ClassicSwitch](../../samples/snippets/csharp/PatternMatching/GeometricUtilities.cs#04_ClassicSwitch "Classic switch statement")]

<span data-ttu-id="0de1f-156">Jediným vzorem podporovaným příkazem `switch` byl konstantní vzor.</span><span class="sxs-lookup"><span data-stu-id="0de1f-156">The only pattern supported by the `switch` statement was the constant pattern.</span></span> <span data-ttu-id="0de1f-157">Byl dále omezen na číselné typy a `string` typ.</span><span class="sxs-lookup"><span data-stu-id="0de1f-157">It was further limited to numeric types and the `string` type.</span></span>
<span data-ttu-id="0de1f-158">Tato omezení byla odebrána a nyní `switch` můžete napsat příkaz pomocí vzoru typu:</span><span class="sxs-lookup"><span data-stu-id="0de1f-158">Those restrictions have been removed, and you can now write a `switch` statement using the type pattern:</span></span>

[!code-csharp[Switch Type Pattern](../../samples/snippets/csharp/PatternMatching/GeometricUtilities.cs#05_SwitchTypePattern "Compute with `switch` expression")]

<span data-ttu-id="0de1f-159">Příkaz porovnávání `switch` vzorů používá známou syntaxi vývojářům, kteří použili tradiční příkaz stylu `switch` C.</span><span class="sxs-lookup"><span data-stu-id="0de1f-159">The pattern matching `switch` statement uses familiar syntax to developers who have used the traditional C-style `switch` statement.</span></span> <span data-ttu-id="0de1f-160">Každý `case` je vyhodnocen a kód pod podmínkou, která odpovídá vstupní proměnné je proveden.</span><span class="sxs-lookup"><span data-stu-id="0de1f-160">Each `case` is evaluated and the code beneath the condition that matches the input variable is executed.</span></span> <span data-ttu-id="0de1f-161">Spuštění kódu nemůže "propadnout" z jednoho výrazu případu na další; syntaxe `case` příkazu vyžaduje, `case` aby `break`každý `return`konec `goto`s , , nebo .</span><span class="sxs-lookup"><span data-stu-id="0de1f-161">Code execution can't "fall through" from one case expression to the next; the syntax of the `case` statement requires that each `case` end with a `break`, `return`, or `goto`.</span></span>

> [!NOTE]
> <span data-ttu-id="0de1f-162">Příkazy `goto` přejít na jiný popisek jsou platné pouze pro konstantní vzor (klasický příkaz switch).</span><span class="sxs-lookup"><span data-stu-id="0de1f-162">The `goto` statements to jump to another label are valid only for the constant pattern (the classic switch statement).</span></span>

<span data-ttu-id="0de1f-163">Existují důležitá nová pravidla, `switch` kterými se řídí prohlášení.</span><span class="sxs-lookup"><span data-stu-id="0de1f-163">There are important new rules governing the `switch` statement.</span></span> <span data-ttu-id="0de1f-164">Omezení typu proměnné ve výrazu `switch` byla odebrána.</span><span class="sxs-lookup"><span data-stu-id="0de1f-164">The restrictions on the type of the variable in the `switch` expression have been removed.</span></span>
<span data-ttu-id="0de1f-165">Lze použít libovolný `object` typ, například v tomto příkladu.</span><span class="sxs-lookup"><span data-stu-id="0de1f-165">Any type, such as `object` in this example, may be used.</span></span> <span data-ttu-id="0de1f-166">Výrazy případu již nejsou omezeny na konstantní hodnoty.</span><span class="sxs-lookup"><span data-stu-id="0de1f-166">The case expressions are no longer limited to constant values.</span></span> <span data-ttu-id="0de1f-167">Odebrání tohoto omezení znamená, že změna pořadí `switch` oddílů může změnit chování programu.</span><span class="sxs-lookup"><span data-stu-id="0de1f-167">Removing that limitation means that reordering `switch` sections may change a program's behavior.</span></span>

<span data-ttu-id="0de1f-168">Pokud jsou omezeny na konstantní `case` hodnoty, může hodnotu `switch` výrazu odpovídat více než jeden popisek.</span><span class="sxs-lookup"><span data-stu-id="0de1f-168">When limited to constant values, no more than one `case` label could match the value of the `switch` expression.</span></span> <span data-ttu-id="0de1f-169">Zkombinujte to s `switch` pravidlem, že každý oddíl nesmí propadnout `switch` do další části a z toho vyplývá, že oddíly mohou být uspořádány v libovolném pořadí bez ovlivnění chování.</span><span class="sxs-lookup"><span data-stu-id="0de1f-169">Combine that with the rule that every `switch` section must not fall through to the next section, and it followed that the `switch` sections could be rearranged in any order without affecting behavior.</span></span>
<span data-ttu-id="0de1f-170">Nyní, s více `switch` zobecněnými výrazy, záleží na pořadí každé sekce.</span><span class="sxs-lookup"><span data-stu-id="0de1f-170">Now, with more generalized `switch` expressions, the order of each section matters.</span></span> <span data-ttu-id="0de1f-171">Výrazy `switch` jsou vyhodnocovány v textovém pořadí.</span><span class="sxs-lookup"><span data-stu-id="0de1f-171">The `switch` expressions are evaluated in textual order.</span></span> <span data-ttu-id="0de1f-172">Spuštění se přenáší `switch` na první `switch` popisek, který odpovídá výrazu.</span><span class="sxs-lookup"><span data-stu-id="0de1f-172">Execution transfers to the first `switch` label that matches the `switch` expression.</span></span>  
<span data-ttu-id="0de1f-173">Případ `default` bude proveden pouze v případě, že se neshodují žádné jiné popisky případu.</span><span class="sxs-lookup"><span data-stu-id="0de1f-173">The `default` case will only be executed if no other case labels match.</span></span> <span data-ttu-id="0de1f-174">Případ `default` je hodnocen jako poslední, bez ohledu na jeho textové pořadí.</span><span class="sxs-lookup"><span data-stu-id="0de1f-174">The `default` case is evaluated last, regardless of its textual order.</span></span> <span data-ttu-id="0de1f-175">Pokud neexistuje žádný `default` případ a žádný `case` z ostatních příkazů odpovídat, `switch` provádění pokračuje na příkaz následující prohlášení.</span><span class="sxs-lookup"><span data-stu-id="0de1f-175">If there's no `default` case, and none of the other `case` statements match, execution continues at the statement following the `switch` statement.</span></span> <span data-ttu-id="0de1f-176">Žádný kód `case` popisků není spuštěn.</span><span class="sxs-lookup"><span data-stu-id="0de1f-176">None of the `case` labels code is executed.</span></span>

## <a name="when-clauses-in-case-expressions"></a><span data-ttu-id="0de1f-177">`when`klauzule `case` ve výrazech</span><span class="sxs-lookup"><span data-stu-id="0de1f-177">`when` clauses in `case` expressions</span></span>

<span data-ttu-id="0de1f-178">Pomocí klauzule na popisku `when` `case` můžete vytvořit speciální případy pro ty obrazce, které mají oblast 0.</span><span class="sxs-lookup"><span data-stu-id="0de1f-178">You can make special cases for those shapes that have 0 area by using a `when` clause on the `case` label.</span></span> <span data-ttu-id="0de1f-179">Čtverec s délkou strany 0 nebo kružnice s poloměrem 0 má oblast 0.</span><span class="sxs-lookup"><span data-stu-id="0de1f-179">A square with a side length of 0, or a circle with a radius of 0 has a 0 area.</span></span> <span data-ttu-id="0de1f-180">Tuto podmínku `when` určíte pomocí `case` klauzule na popisku:</span><span class="sxs-lookup"><span data-stu-id="0de1f-180">You specify that condition using a `when` clause on the `case` label:</span></span>  

[!code-csharp[ComputeDegenerateShapes](../../samples/snippets/csharp/PatternMatching/GeometricUtilities.cs#07_ComputeDegenerateShapes "Compute shapes with 0 area")]

<span data-ttu-id="0de1f-181">Tato změna ukazuje několik důležitých bodů o nové syntaxi.</span><span class="sxs-lookup"><span data-stu-id="0de1f-181">This change demonstrates a few important points about the new syntax.</span></span> <span data-ttu-id="0de1f-182">Nejprve `case` lze na jeden `switch` oddíl použít více popisků.</span><span class="sxs-lookup"><span data-stu-id="0de1f-182">First, multiple `case` labels can be applied to one `switch` section.</span></span> <span data-ttu-id="0de1f-183">Blok příkazu je proveden, pokud `true`je některý z těchto popisků .</span><span class="sxs-lookup"><span data-stu-id="0de1f-183">The statement block is executed when any of those labels is `true`.</span></span> <span data-ttu-id="0de1f-184">V tomto případě `switch` pokud je výraz kruh nebo čtverec s oblastí 0, metoda vrátí konstantu 0.</span><span class="sxs-lookup"><span data-stu-id="0de1f-184">In this instance, if the `switch` expression is either a circle or a square with 0 area, the method returns the constant 0.</span></span>

<span data-ttu-id="0de1f-185">Tento příklad zavádí dvě různé proměnné `case` ve dvou `switch` popiscích pro první blok.</span><span class="sxs-lookup"><span data-stu-id="0de1f-185">This example introduces two different variables in the two `case` labels for the first `switch` block.</span></span> <span data-ttu-id="0de1f-186">Všimněte si, `switch` že příkazy `c` v tomto bloku nepoužívají proměnné `s` (pro kruh) nebo (pro čtverec).</span><span class="sxs-lookup"><span data-stu-id="0de1f-186">Notice that the statements in this `switch` block don't use either the variables `c` (for the circle) or `s` (for the square).</span></span>
<span data-ttu-id="0de1f-187">Ani jedna z těchto proměnných `switch` je v tomto bloku určitě přiřazena.</span><span class="sxs-lookup"><span data-stu-id="0de1f-187">Neither of those variables is definitely assigned in this `switch` block.</span></span>
<span data-ttu-id="0de1f-188">Pokud se některý z těchto případů shoduje, je zřejmé, že byla přiřazena jedna z proměnných.</span><span class="sxs-lookup"><span data-stu-id="0de1f-188">If either of these cases match, clearly one of the variables has been assigned.</span></span>
<span data-ttu-id="0de1f-189">Je však nemožné zjistit, *který* byl přiřazen v době kompilace, protože oba případy mohou odpovídat za běhu.</span><span class="sxs-lookup"><span data-stu-id="0de1f-189">However, it's impossible to tell *which* has been assigned at compile time, because either case could match at runtime.</span></span> <span data-ttu-id="0de1f-190">Z tohoto důvodu většinou při `case` použití více popisků pro stejný blok, nezavedete novou proměnnou v příkazu, `case` nebo budete používat pouze proměnnou v klauzuli. `when`</span><span class="sxs-lookup"><span data-stu-id="0de1f-190">For that reason, most times when you use multiple `case` labels for the same block, you won't introduce a new variable in the `case` statement, or you'll only use the variable in the `when` clause.</span></span>

<span data-ttu-id="0de1f-191">Po přidání těchto obrazců s oblastí 0 přidáme několik dalších typů tvarů: obdélník a trojúhelník:</span><span class="sxs-lookup"><span data-stu-id="0de1f-191">Having added those shapes with 0 area, let's add a couple more shape types: a rectangle and a triangle:</span></span>

[!code-csharp[AddRectangleAndTriangle](../../samples/snippets/csharp/PatternMatching/GeometricUtilities.cs#09_AddRectangleAndTriangle "Add rectangle and triangle")]

 <span data-ttu-id="0de1f-192">Tato sada změn `case` přidá popisky pro degenerovaný případ a popisky a bloky pro každý z nových obrazců.</span><span class="sxs-lookup"><span data-stu-id="0de1f-192">This set of changes adds `case` labels for the degenerate case, and labels and blocks for each of the new shapes.</span></span>

<span data-ttu-id="0de1f-193">Nakonec můžete přidat `null` případ, abyste zajistili, `null`že argument není:</span><span class="sxs-lookup"><span data-stu-id="0de1f-193">Finally, you can add a `null` case to ensure the argument isn't `null`:</span></span>

[!code-csharp[NullCase](../../samples/snippets/csharp/PatternMatching/GeometricUtilities.cs#10_NullCase "Add null case")]

<span data-ttu-id="0de1f-194">Zvláštní chování pro `null` vzorek je zajímavé, protože konstanta `null` ve vzorku nemá typ, ale může být převedena na libovolný typ odkazu nebo typ hodnoty s hodnotou s možnou hodnotou, kterou lze hodnotit.</span><span class="sxs-lookup"><span data-stu-id="0de1f-194">The special behavior for the `null` pattern is interesting because the constant `null` in the pattern doesn't have a type but can be converted to any reference type or nullable value type.</span></span> <span data-ttu-id="0de1f-195">Spíše než `null` převést na libovolný typ, `null` jazyk definuje, že hodnota nebude odpovídat žádný typ vzor, bez ohledu na typ kompilace proměnné.</span><span class="sxs-lookup"><span data-stu-id="0de1f-195">Rather than convert a `null` to any type, the language defines that a `null` value won't match any type pattern, regardless of the compile-time type of the variable.</span></span> <span data-ttu-id="0de1f-196">Toto chování `switch` je nový vzorek `is` typu `is` na základě `false` konzistentní s příkazem: příkazy vždy vrátit, když je `null`zaškrtnutá hodnota .</span><span class="sxs-lookup"><span data-stu-id="0de1f-196">This behavior makes the new `switch` based type pattern consistent with the `is` statement: `is` statements always return `false` when the value being checked is `null`.</span></span> <span data-ttu-id="0de1f-197">Je to také jednodušší: jakmile zkontrolujete typ, nepotřebujete další kontrolu null.</span><span class="sxs-lookup"><span data-stu-id="0de1f-197">It's also simpler: once you've checked the type, you don't need an additional null check.</span></span> <span data-ttu-id="0de1f-198">Můžete vidět, že z toho, že neexistují žádné nulové kontroly v některém z bloků případu výše uvedených vzorků: nejsou nutné, protože odpovídající vzor typu zaručuje hodnotu bez nuly.</span><span class="sxs-lookup"><span data-stu-id="0de1f-198">You can see that from the fact that there are no null checks in any of the case blocks of the samples above: they aren't necessary, since matching the type pattern guarantees a non-null value.</span></span>

## <a name="var-declarations-in-case-expressions"></a><span data-ttu-id="0de1f-199">`var`deklarace `case` ve výrazech</span><span class="sxs-lookup"><span data-stu-id="0de1f-199">`var` declarations in `case` expressions</span></span>

<span data-ttu-id="0de1f-200">Zavedení `var` jako jeden z výrazů shody zavádí nová pravidla do shody vzoru.</span><span class="sxs-lookup"><span data-stu-id="0de1f-200">The introduction of `var` as one of the match expressions introduces new rules to the pattern match.</span></span>

<span data-ttu-id="0de1f-201">První pravidlo je, `var` že deklarace se řídí pravidly odvození normálního typu: Typ je odvozen za statický typ výrazu switch.</span><span class="sxs-lookup"><span data-stu-id="0de1f-201">The first rule is that the `var` declaration follows the normal type inference rules: The type is inferred to be the static type of the switch expression.</span></span> <span data-ttu-id="0de1f-202">Z tohoto pravidla se typ vždy shoduje.</span><span class="sxs-lookup"><span data-stu-id="0de1f-202">From that rule, the type always matches.</span></span>

<span data-ttu-id="0de1f-203">Druhým pravidlem `var` je, že deklarace nemá kontrolu null, které zahrnují jiné výrazy typu vzor.</span><span class="sxs-lookup"><span data-stu-id="0de1f-203">The second rule is that a `var` declaration doesn't have the null check that other type pattern expressions include.</span></span> <span data-ttu-id="0de1f-204">To znamená, že proměnná může být null a kontrola null je nezbytné v tomto případě.</span><span class="sxs-lookup"><span data-stu-id="0de1f-204">That means the variable may be null, and a null check is necessary in that case.</span></span>

<span data-ttu-id="0de1f-205">Tato dvě pravidla znamenají, že `var` v mnoha `case` případech deklarace ve `default` výrazu odpovídá stejným podmínkám jako výraz.</span><span class="sxs-lookup"><span data-stu-id="0de1f-205">Those two rules mean that in many instances, a `var` declaration in a `case` expression matches the same conditions as a `default` expression.</span></span>
<span data-ttu-id="0de1f-206">Vzhledem k tomu, že `default` jakýkoli případ, který není výchozí, je upřednostňován před případem, `default` případ se nikdy neprovede.</span><span class="sxs-lookup"><span data-stu-id="0de1f-206">Because any non-default case is preferred to the `default` case, the `default` case will never execute.</span></span>

> [!NOTE]
> <span data-ttu-id="0de1f-207">Kompilátor nevyzařuje upozornění v `default` těch případech, kdy byl případ zapsán, ale nikdy se nespustí.</span><span class="sxs-lookup"><span data-stu-id="0de1f-207">The compiler does not emit a warning in those cases where a `default` case has been written but will never execute.</span></span> <span data-ttu-id="0de1f-208">To je v `switch` souladu s aktuální chování příkazu, kde byly uvedeny všechny možné případy.</span><span class="sxs-lookup"><span data-stu-id="0de1f-208">This is consistent with current `switch` statement behavior where all possible cases have been listed.</span></span>

<span data-ttu-id="0de1f-209">Třetí pravidlo zavádí použití, `var` kde může být případ užitečný.</span><span class="sxs-lookup"><span data-stu-id="0de1f-209">The third rule introduces uses where a `var` case may be useful.</span></span> <span data-ttu-id="0de1f-210">Představte si, že provádíte porovnávání vzorů, kde je vstup em řetězec a hledáte známé hodnoty příkazů.</span><span class="sxs-lookup"><span data-stu-id="0de1f-210">Imagine that you're doing a pattern match where the input is a string and you're searching for known command values.</span></span> <span data-ttu-id="0de1f-211">Můžete napsat něco jako:</span><span class="sxs-lookup"><span data-stu-id="0de1f-211">You might write something like:</span></span>

[!code-csharp[VarCaseExpression](../../samples/snippets/csharp/PatternMatching/Program.cs#VarCaseExpression "use a var case expression to filter white space")]

<span data-ttu-id="0de1f-212">Případ `var` odpovídá `null`, prázdný řetězec nebo libovolný řetězec, který obsahuje pouze prázdné místo.</span><span class="sxs-lookup"><span data-stu-id="0de1f-212">The `var` case matches `null`, the empty string, or any string that contains only white space.</span></span> <span data-ttu-id="0de1f-213">Všimněte si, že `?.` předchozí kód používá operátor k zajištění, <xref:System.NullReferenceException>že není omylem hodit .</span><span class="sxs-lookup"><span data-stu-id="0de1f-213">Notice that the preceding code uses the `?.` operator to ensure that it doesn't accidentally throw a <xref:System.NullReferenceException>.</span></span> <span data-ttu-id="0de1f-214">Případ `default` zpracovává všechny ostatní řetězcové hodnoty, které nejsou chápány v tomto analyzátoru příkazů.</span><span class="sxs-lookup"><span data-stu-id="0de1f-214">The `default` case handles any other string values that aren't understood by this command parser.</span></span>

<span data-ttu-id="0de1f-215">Toto je jeden příklad, kde `var` můžete chtít zvážit `default` případ výraz, který je odlišný od výrazu.</span><span class="sxs-lookup"><span data-stu-id="0de1f-215">This is one example where you may want to consider a `var` case expression that is distinct from a `default` expression.</span></span>

## <a name="conclusions"></a><span data-ttu-id="0de1f-216">Závěry</span><span class="sxs-lookup"><span data-stu-id="0de1f-216">Conclusions</span></span>

<span data-ttu-id="0de1f-217">*Konstrukce porovnávání vzorů* umožňují snadno spravovat tok řízení mezi různými proměnnými a typy, které nejsou spojeny hierarchií dědičnosti.</span><span class="sxs-lookup"><span data-stu-id="0de1f-217">*Pattern Matching constructs* enable you to easily manage control flow among different variables and types that aren't related by an inheritance hierarchy.</span></span> <span data-ttu-id="0de1f-218">Můžete také řídit logiku použít všechny podmínky, které testujete na proměnné.</span><span class="sxs-lookup"><span data-stu-id="0de1f-218">You can also control logic to use any condition you test on the variable.</span></span> <span data-ttu-id="0de1f-219">Umožňuje vzory a idiomy, které budete potřebovat častěji při vytváření více distribuovaných aplikací, kde jsou data a metody, které pracují s daty, oddělené.</span><span class="sxs-lookup"><span data-stu-id="0de1f-219">It enables patterns and idioms that you'll need more often as you build more distributed applications, where data and the methods that manipulate that data are separate.</span></span> <span data-ttu-id="0de1f-220">Všimněte si, že struktury tvarů použité v této ukázce neobsahují žádné metody, pouze vlastnosti jen pro čtení.</span><span class="sxs-lookup"><span data-stu-id="0de1f-220">You'll notice that the shape structs used in this sample don't contain any methods, just read-only properties.</span></span>
<span data-ttu-id="0de1f-221">Porovnávání vzorů funguje s libovolným datovým typem.</span><span class="sxs-lookup"><span data-stu-id="0de1f-221">Pattern Matching works with any data type.</span></span> <span data-ttu-id="0de1f-222">Napíšete výrazy, které prozkoumat objekt a provádět rozhodnutí o toku řízení na základě těchto podmínek.</span><span class="sxs-lookup"><span data-stu-id="0de1f-222">You write expressions that examine the object, and make control flow decisions based on those conditions.</span></span>

<span data-ttu-id="0de1f-223">Porovnejte kód z této ukázky s návrhem, `Shape` který by vyplýval z vytvoření hierarchie tříd pro abstraktní a specifické odvozené tvary, z nichž každý s vlastní implementací virtuální metody pro výpočet oblasti.</span><span class="sxs-lookup"><span data-stu-id="0de1f-223">Compare the code from this sample with the design that would follow from creating a class hierarchy for an abstract `Shape` and specific derived shapes each with their own implementation of a virtual method to calculate the area.</span></span> <span data-ttu-id="0de1f-224">Často zjistíte, že výrazy porovnávání vzorů mohou být velmi užitečným nástrojem při práci s daty a chcete oddělit obavy o úložiště dat od obav o chování.</span><span class="sxs-lookup"><span data-stu-id="0de1f-224">You'll often find that pattern matching expressions can be a very useful tool when you're working with data and want to separate the data storage concerns from the behavior concerns.</span></span>

## <a name="see-also"></a><span data-ttu-id="0de1f-225">Viz také</span><span class="sxs-lookup"><span data-stu-id="0de1f-225">See also</span></span>

- [<span data-ttu-id="0de1f-226">Kurz: Použití funkcí porovnávání vzorů k rozšíření datových typů</span><span class="sxs-lookup"><span data-stu-id="0de1f-226">Tutorial: Using pattern matching features to extend data types</span></span>](tutorials/pattern-matching.md)
