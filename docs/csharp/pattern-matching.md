---
title: Porovnávání vzorů C# – Průvodce
description: Další informace o výrazech porovnávání vzorů vC#
ms.date: 04/10/2019
ms.technology: csharp-fundamentals
ms.assetid: 1e575c32-2e2b-4425-9dca-7d118f3ed15b
ms.openlocfilehash: ffa59d073ad891fd93e0f8d7ad8889de0499b106
ms.sourcegitcommit: 43d10ef65f0f1fd6c3b515e363bde11a3fcd8d6d
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 03/03/2020
ms.locfileid: "78241010"
---
# <a name="pattern-matching"></a><span data-ttu-id="6f540-103">Porovnávání vzorů</span><span class="sxs-lookup"><span data-stu-id="6f540-103">Pattern Matching</span></span>

<span data-ttu-id="6f540-104">Vzor testuje, že hodnota má určitý *tvar*a může *extrahovat* informace z hodnoty, když má odpovídající tvar.</span><span class="sxs-lookup"><span data-stu-id="6f540-104">Patterns test that a value has a certain *shape*, and can *extract* information from the value when it has the matching shape.</span></span> <span data-ttu-id="6f540-105">Porovnávání vzorů poskytuje stručnější syntaxi pro algoritmy, které už dnes používáte.</span><span class="sxs-lookup"><span data-stu-id="6f540-105">Pattern matching provides more concise syntax for algorithms you already use today.</span></span> <span data-ttu-id="6f540-106">Již jste vytvořili algoritmy porovnávání vzorů pomocí existující syntaxe.</span><span class="sxs-lookup"><span data-stu-id="6f540-106">You already create pattern matching algorithms using existing syntax.</span></span> <span data-ttu-id="6f540-107">Zapisujete `if` nebo `switch` příkazy, které testují hodnoty.</span><span class="sxs-lookup"><span data-stu-id="6f540-107">You write `if` or `switch` statements that test values.</span></span> <span data-ttu-id="6f540-108">Když se tyto příkazy shodují, extrahujete a použijete informace z této hodnoty.</span><span class="sxs-lookup"><span data-stu-id="6f540-108">Then, when those statements match, you extract and use information from that value.</span></span> <span data-ttu-id="6f540-109">Nové prvky syntaxe jsou rozšíření pro příkazy, které jste už obeznámeni s: `is` a `switch`.</span><span class="sxs-lookup"><span data-stu-id="6f540-109">The new syntax elements are extensions to statements you're already familiar with: `is` and `switch`.</span></span> <span data-ttu-id="6f540-110">Tato nová rozšíření kombinují testování hodnoty a extrahuje tyto informace.</span><span class="sxs-lookup"><span data-stu-id="6f540-110">These new extensions combine testing a value and extracting that information.</span></span>

<span data-ttu-id="6f540-111">V tomto článku se podíváme na novou syntaxi a ukážeme vám, jak to umožňuje čitelný a výstižný kód.</span><span class="sxs-lookup"><span data-stu-id="6f540-111">In this article, we'll look at the new syntax to show you how it enables readable, concise code.</span></span> <span data-ttu-id="6f540-112">Porovnávání vzorů umožňuje idiomy, kde jsou data a kód odděleny, na rozdíl od objektů orientovaných na objekty, kde data a metody, které jsou s nimi manipulovány, jsou úzce spojeny.</span><span class="sxs-lookup"><span data-stu-id="6f540-112">Pattern matching enables idioms where data and the code are separated, unlike object-oriented designs where data and the methods that manipulate them are tightly coupled.</span></span>

<span data-ttu-id="6f540-113">Pro ilustraci těchto nových idiomy je možné pracovat se strukturami, které představují geometrické obrazce pomocí příkazů pro porovnávání vzorů.</span><span class="sxs-lookup"><span data-stu-id="6f540-113">To illustrate these new idioms, let's work with structures that represent geometric shapes using pattern matching statements.</span></span> <span data-ttu-id="6f540-114">Pravděpodobně jste obeznámeni s vytvářením hierarchií tříd a vytvářením [virtuálních metod a přepsaných metod](methods.md#inherited) pro přizpůsobení chování objektu na základě typu modulu runtime objektu.</span><span class="sxs-lookup"><span data-stu-id="6f540-114">You're probably familiar with building class hierarchies and creating [virtual methods and overridden methods](methods.md#inherited) to customize object behavior based on the runtime type of the object.</span></span>

<span data-ttu-id="6f540-115">Tyto techniky nejsou možné pro data, která nejsou strukturovaná v hierarchii tříd.</span><span class="sxs-lookup"><span data-stu-id="6f540-115">Those techniques aren't possible for data that isn't structured in a class hierarchy.</span></span> <span data-ttu-id="6f540-116">Když jsou data a metody oddělené, potřebujete další nástroje.</span><span class="sxs-lookup"><span data-stu-id="6f540-116">When data and methods are separate, you need other tools.</span></span> <span data-ttu-id="6f540-117">Nové *vzory porovnávání* konstrukcí umožňují pomocí syntaxe čištění kontrolovat data a manipulovat tok řízení na základě jakékoli podmínky těchto dat.</span><span class="sxs-lookup"><span data-stu-id="6f540-117">The new *pattern matching* constructs enable cleaner syntax to examine data and manipulate control flow based on any condition of that data.</span></span> <span data-ttu-id="6f540-118">Již jste napsali příkazy `if` a `switch`, které testují hodnotu proměnné.</span><span class="sxs-lookup"><span data-stu-id="6f540-118">You already write `if` statements and `switch` that test a variable's value.</span></span> <span data-ttu-id="6f540-119">Píšete `is` příkazy, které testují typ proměnné.</span><span class="sxs-lookup"><span data-stu-id="6f540-119">You write `is` statements that test a variable's type.</span></span> <span data-ttu-id="6f540-120">*Porovnávání vzorů* přidává do těchto příkazů nové funkce.</span><span class="sxs-lookup"><span data-stu-id="6f540-120">*Pattern matching* adds new capabilities to those statements.</span></span>

<span data-ttu-id="6f540-121">V tomto článku vytvoříte metodu, která vypočítá oblast různých geometrických tvarů.</span><span class="sxs-lookup"><span data-stu-id="6f540-121">In this article, you'll build a method  that computes the area of different geometric shapes.</span></span> <span data-ttu-id="6f540-122">Ale provedete to bez nutnosti vytvářet objektově orientované techniky a sestavovat hierarchii tříd pro různé tvary.</span><span class="sxs-lookup"><span data-stu-id="6f540-122">But, you'll do it without resorting to object-oriented techniques and building a class hierarchy for the different shapes.</span></span>
<span data-ttu-id="6f540-123">Místo toho použijete *porovnávání se vzorem* .</span><span class="sxs-lookup"><span data-stu-id="6f540-123">You'll use *pattern matching* instead.</span></span>
<span data-ttu-id="6f540-124">Při procházení této ukázky je třeba na rozdíl od tohoto kódu tento kód rozčleněný jako na hierarchii objektů.</span><span class="sxs-lookup"><span data-stu-id="6f540-124">As you go through this sample, contrast this code with how it would be structured as an object hierarchy.</span></span> <span data-ttu-id="6f540-125">Pokud se data, která musíte dotazovat a manipulovat, není hierarchií tříd, porovnávání vzorů umožňuje elegantní návrhy.</span><span class="sxs-lookup"><span data-stu-id="6f540-125">When the data you must query and manipulate isn't a class hierarchy, pattern matching enables elegant designs.</span></span>

<span data-ttu-id="6f540-126">Místo toho, aby se spouštěla definice abstraktního obrazce a přidala se různé konkrétní třídy tvarů, začněte místo toho, aby se pro každý geometrický tvar spouštěly jenom jednoduché datové definice:</span><span class="sxs-lookup"><span data-stu-id="6f540-126">Rather than starting with an abstract shape definition and adding different specific shape classes, let's start instead with simple data only definitions for each of the geometric shapes:</span></span>

[!code-csharp[ShapeDefinitions](../../samples/snippets/csharp/PatternMatching/Shapes.cs#01_ShapeDefinitions "Shape definitions")]

<span data-ttu-id="6f540-127">Z těchto struktur napíšeme metodu, která vypočítá oblast nějakého tvaru.</span><span class="sxs-lookup"><span data-stu-id="6f540-127">From these structures, let's write a method that computes the area of some shape.</span></span>

## <a name="the-is-type-pattern-expression"></a><span data-ttu-id="6f540-128">Výraz vzoru typu `is`</span><span class="sxs-lookup"><span data-stu-id="6f540-128">The `is` type pattern expression</span></span>

<span data-ttu-id="6f540-129">Před C# 7,0 byste museli testovat každý typ v řadě `if` a `is` příkazy:</span><span class="sxs-lookup"><span data-stu-id="6f540-129">Before C# 7.0, you'd need to test each type in a series of `if` and `is` statements:</span></span>

[!code-csharp[ClassicIsExpression](../../samples/snippets/csharp/PatternMatching/GeometricUtilities.cs#02_ClassicIsExpression "Classic type pattern using is")]

<span data-ttu-id="6f540-130">Výše uvedený kód je klasický výraz *vzoru typu*: testujete proměnnou pro určení jejího typu a provedení jiné akce založené na tomto typu.</span><span class="sxs-lookup"><span data-stu-id="6f540-130">That code above is a classic expression of the *type pattern*: You're testing a variable to determine its type and taking a different action based on that type.</span></span>

<span data-ttu-id="6f540-131">Tento kód se bude jednodušší pomocí rozšíření pro výraz `is` pro přiřazení proměnné, pokud je test úspěšný:</span><span class="sxs-lookup"><span data-stu-id="6f540-131">This code becomes simpler using extensions to the `is` expression to assign a variable if the test succeeds:</span></span>

[!code-csharp[IsPatternExpression](../../samples/snippets/csharp/PatternMatching/GeometricUtilities.cs#03_IsPatternExpression "is pattern expression")]

<span data-ttu-id="6f540-132">V této aktualizované verzi výraz `is` testuje proměnnou a přiřadí ji k nové proměnné správného typu.</span><span class="sxs-lookup"><span data-stu-id="6f540-132">In this updated version, the `is` expression both tests the variable and assigns it to a new variable of the proper type.</span></span> <span data-ttu-id="6f540-133">Všimněte si také, že tato verze zahrnuje typ `Rectangle`, což je `struct`.</span><span class="sxs-lookup"><span data-stu-id="6f540-133">Also, notice that this version includes the `Rectangle` type, which is a `struct`.</span></span> <span data-ttu-id="6f540-134">Nový výraz `is` pracuje s typy hodnot a typy odkazů.</span><span class="sxs-lookup"><span data-stu-id="6f540-134">The new `is` expression works with value types as well as reference types.</span></span>

<span data-ttu-id="6f540-135">Pravidla jazyka pro výrazy porovnávání vzorů vám pomůžou vyhnout se nepříliš nepoužitým výsledkům výrazu shody.</span><span class="sxs-lookup"><span data-stu-id="6f540-135">Language rules for pattern matching expressions help you avoid misusing the results of a match expression.</span></span> <span data-ttu-id="6f540-136">V předchozím příkladu jsou proměnné `s`, `c`a `r` pouze v oboru a jednoznačně přiřazeny, pokud mají příslušné výrazy porovnávání vzorů `true` výsledky.</span><span class="sxs-lookup"><span data-stu-id="6f540-136">In the example above, the variables `s`, `c`, and `r` are only in scope and definitely assigned when the respective pattern match expressions have `true` results.</span></span> <span data-ttu-id="6f540-137">Pokud se pokusíte použít buď proměnnou v jiném umístění, kód vygeneruje chyby kompilátoru.</span><span class="sxs-lookup"><span data-stu-id="6f540-137">If you try to use either variable in another location, your code generates compiler errors.</span></span>

<span data-ttu-id="6f540-138">Pojďme si tato pravidla podrobněji prošetřit, počínaje oborem.</span><span class="sxs-lookup"><span data-stu-id="6f540-138">Let's examine both of those rules in detail, beginning with scope.</span></span> <span data-ttu-id="6f540-139">Proměnná `c` je v oboru pouze ve větvi `else` prvního příkazu `if`.</span><span class="sxs-lookup"><span data-stu-id="6f540-139">The variable `c` is in scope only in the `else` branch of the first `if` statement.</span></span> <span data-ttu-id="6f540-140">Proměnná `s` je v rozsahu `ComputeAreaModernIs`metody.</span><span class="sxs-lookup"><span data-stu-id="6f540-140">The variable `s` is in scope in the method `ComputeAreaModernIs`.</span></span> <span data-ttu-id="6f540-141">To je proto, že každá větev příkazu `if` vytvoří samostatný obor pro proměnné.</span><span class="sxs-lookup"><span data-stu-id="6f540-141">That's because each branch of an `if` statement establishes a separate scope for variables.</span></span> <span data-ttu-id="6f540-142">Nicméně samotný příkaz `if` ne.</span><span class="sxs-lookup"><span data-stu-id="6f540-142">However, the `if` statement itself doesn't.</span></span> <span data-ttu-id="6f540-143">To znamená, že proměnné deklarované v příkazu `if` jsou ve stejném oboru jako příkaz `if` (metoda v tomto případě). Toto chování není specifické pro porovnávání se vzorem, ale je definované chování pro proměnné obory a `if` a `else` příkazy.</span><span class="sxs-lookup"><span data-stu-id="6f540-143">That means variables declared in the `if` statement are in the same scope as the `if` statement (the method in this case.) This behavior isn't specific to pattern matching, but is the defined behavior for variable scopes and `if` and `else` statements.</span></span>

<span data-ttu-id="6f540-144">Proměnné `c` a `s` jsou přiřazeny, pokud jsou příslušné `if` příkazy pravdivé z důvodu omezení s omezením přiřazeným při hodnotě true.</span><span class="sxs-lookup"><span data-stu-id="6f540-144">The variables `c` and `s` are assigned when the respective `if` statements are true because of the definitely assigned when true mechanism.</span></span>

> [!TIP]
> <span data-ttu-id="6f540-145">V ukázkách v tomto tématu se používá doporučený konstrukce, kde porovnávání vzorů `is` výraz jednoznačně přiřadí proměnnou shody ve `true` větvi příkazu `if`.</span><span class="sxs-lookup"><span data-stu-id="6f540-145">The samples in this topic use the recommended construct where a pattern match `is` expression definitely assigns the match variable in the `true` branch of the `if` statement.</span></span>
> <span data-ttu-id="6f540-146">Můžete vrátit zpět logiku tím, že říkáte `if (!(shape is Square s))` a proměnná `s` by byla jednoznačně přiřazena pouze ve větvi `false`.</span><span class="sxs-lookup"><span data-stu-id="6f540-146">You could reverse the logic by saying `if (!(shape is Square s))` and the variable `s` would be definitely assigned only in the `false` branch.</span></span> <span data-ttu-id="6f540-147">I když je tento C#postup platný, nedoporučujeme, protože je lepší postupovat podle logiky.</span><span class="sxs-lookup"><span data-stu-id="6f540-147">While this is valid C#, it is not recommended because it is more confusing to follow the logic.</span></span>

<span data-ttu-id="6f540-148">Tato pravidla znamenají, že nebudete mít pravděpodobně náhodný přístup k výsledku výrazu porovnávání vzorů, když tento model nebyl splněn.</span><span class="sxs-lookup"><span data-stu-id="6f540-148">These rules mean that you're unlikely to accidentally access the result of a pattern match expression when that pattern wasn't met.</span></span>

## <a name="using-pattern-matching-switch-statements"></a><span data-ttu-id="6f540-149">Použití příkazů `switch` porovnávání vzorů</span><span class="sxs-lookup"><span data-stu-id="6f540-149">Using pattern matching `switch` statements</span></span>

<span data-ttu-id="6f540-150">V době, kdy bude trvat, možná budete muset podporovat jiné typy tvarů.</span><span class="sxs-lookup"><span data-stu-id="6f540-150">As time goes on, you may need to support other shape types.</span></span> <span data-ttu-id="6f540-151">Pokud se počet podmínek, které testujete, roste, zjistíte, že použití výrazů pro porovnávání vzorů `is` může být náročné.</span><span class="sxs-lookup"><span data-stu-id="6f540-151">As the number of conditions you're testing grows, you'll find that using the `is` pattern matching expressions can become cumbersome.</span></span> <span data-ttu-id="6f540-152">Kromě vyžadování `if`ch příkazů u každého typu, který chcete kontrolovat, jsou výrazy `is` omezeny na testování, pokud vstup odpovídá jedinému typu.</span><span class="sxs-lookup"><span data-stu-id="6f540-152">In addition to requiring `if` statements on each type you want to check, the `is` expressions are limited to testing if the input matches a single type.</span></span> <span data-ttu-id="6f540-153">V tomto případě zjistíte, že se výrazy `switch` porovnávání vzorů stávají lepší volbou.</span><span class="sxs-lookup"><span data-stu-id="6f540-153">In this case, you'll find that the `switch` pattern matching expressions becomes a better choice.</span></span> 

<span data-ttu-id="6f540-154">Tradiční příkaz `switch` byl výraz Pattern: podporuje se konstantní vzorek.</span><span class="sxs-lookup"><span data-stu-id="6f540-154">The traditional `switch` statement was a pattern expression: it supported the constant pattern.</span></span>
<span data-ttu-id="6f540-155">Můžete porovnat proměnnou s libovolnou konstantou použitou v příkazu `case`:</span><span class="sxs-lookup"><span data-stu-id="6f540-155">You could compare a variable to any constant used in a `case` statement:</span></span>

[!code-csharp[ClassicSwitch](../../samples/snippets/csharp/PatternMatching/GeometricUtilities.cs#04_ClassicSwitch "Classic switch statement")]

<span data-ttu-id="6f540-156">Jediný vzor podporovaný příkazem `switch` byl konstantním vzorem.</span><span class="sxs-lookup"><span data-stu-id="6f540-156">The only pattern supported by the `switch` statement was the constant pattern.</span></span> <span data-ttu-id="6f540-157">Bylo větší omezení na číselné typy a typ `string`.</span><span class="sxs-lookup"><span data-stu-id="6f540-157">It was further limited to numeric types and the `string` type.</span></span>
<span data-ttu-id="6f540-158">Tato omezení byla odebrána a nyní můžete napsat příkaz `switch` pomocí vzoru typu:</span><span class="sxs-lookup"><span data-stu-id="6f540-158">Those restrictions have been removed, and you can now write a `switch` statement using the type pattern:</span></span>

[!code-csharp[Switch Type Pattern](../../samples/snippets/csharp/PatternMatching/GeometricUtilities.cs#05_SwitchTypePattern "Compute with `switch` expression")]

<span data-ttu-id="6f540-159">Vzor odpovídající příkazu `switch` používá známou syntaxi pro vývojáře, kteří používali tradiční příkaz jazyka C-Style `switch`.</span><span class="sxs-lookup"><span data-stu-id="6f540-159">The pattern matching `switch` statement uses familiar syntax to developers who have used the traditional C-style `switch` statement.</span></span> <span data-ttu-id="6f540-160">Každý `case` je vyhodnocen a je proveden kód pod podmínkou, která odpovídá vstupní proměnné.</span><span class="sxs-lookup"><span data-stu-id="6f540-160">Each `case` is evaluated and the code beneath the condition that matches the input variable is executed.</span></span> <span data-ttu-id="6f540-161">Provádění kódu nemůže "klesnout do" z jednoho výrazu Case do dalšího. Syntaxe příkazu `case` vyžaduje, aby každý `case` končit `break`, `return`nebo `goto`.</span><span class="sxs-lookup"><span data-stu-id="6f540-161">Code execution can't "fall through" from one case expression to the next; the syntax of the `case` statement requires that each `case` end with a `break`, `return`, or `goto`.</span></span>

> [!NOTE]
> <span data-ttu-id="6f540-162">Příkazy `goto` pro skok na jiný popisek jsou platné pouze pro konstantní vzorek (příkaz klasického přepínače).</span><span class="sxs-lookup"><span data-stu-id="6f540-162">The `goto` statements to jump to another label are valid only for the constant pattern (the classic switch statement).</span></span>

<span data-ttu-id="6f540-163">Existují důležitá nová pravidla, kterými se řídí příkaz `switch`.</span><span class="sxs-lookup"><span data-stu-id="6f540-163">There are important new rules governing the `switch` statement.</span></span> <span data-ttu-id="6f540-164">Byla odebrána omezení pro typ proměnné ve výrazu `switch`.</span><span class="sxs-lookup"><span data-stu-id="6f540-164">The restrictions on the type of the variable in the `switch` expression have been removed.</span></span>
<span data-ttu-id="6f540-165">V tomto příkladu může být použit libovolný typ, například `object`.</span><span class="sxs-lookup"><span data-stu-id="6f540-165">Any type, such as `object` in this example, may be used.</span></span> <span data-ttu-id="6f540-166">Výrazy Case již nejsou omezeny na konstantní hodnoty.</span><span class="sxs-lookup"><span data-stu-id="6f540-166">The case expressions are no longer limited to constant values.</span></span> <span data-ttu-id="6f540-167">Odebrání tohoto omezení znamená, že změna pořadí `switch` oddíly může změnit chování programu.</span><span class="sxs-lookup"><span data-stu-id="6f540-167">Removing that limitation means that reordering `switch` sections may change a program's behavior.</span></span>

<span data-ttu-id="6f540-168">V případě omezení na konstantní hodnoty nesmí více než jeden `case` popisek odpovídat hodnotě výrazu `switch`.</span><span class="sxs-lookup"><span data-stu-id="6f540-168">When limited to constant values, no more than one `case` label could match the value of the `switch` expression.</span></span> <span data-ttu-id="6f540-169">Kombinaci s pravidlem, které každá `switch` oddíl nesmí projít do další části, a za tím, že `switch` oddíly lze změnit v libovolném pořadí, aniž by to mělo vliv na chování.</span><span class="sxs-lookup"><span data-stu-id="6f540-169">Combine that with the rule that every `switch` section must not fall through to the next section, and it followed that the `switch` sections could be rearranged in any order without affecting behavior.</span></span>
<span data-ttu-id="6f540-170">Nyní s obecnější `switch` výrazy je pořadí každé části věcí.</span><span class="sxs-lookup"><span data-stu-id="6f540-170">Now, with more generalized `switch` expressions, the order of each section matters.</span></span> <span data-ttu-id="6f540-171">Výrazy `switch` jsou vyhodnocovány v textovém pořadí.</span><span class="sxs-lookup"><span data-stu-id="6f540-171">The `switch` expressions are evaluated in textual order.</span></span> <span data-ttu-id="6f540-172">Provádění přenese do prvního `switch` popisku, který odpovídá výrazu `switch`.</span><span class="sxs-lookup"><span data-stu-id="6f540-172">Execution transfers to the first `switch` label that matches the `switch` expression.</span></span>  
<span data-ttu-id="6f540-173">`default` případ bude proveden pouze v případě, že se neshodují žádné popisky case.</span><span class="sxs-lookup"><span data-stu-id="6f540-173">The `default` case will only be executed if no other case labels match.</span></span> <span data-ttu-id="6f540-174">`default` případ se vyhodnocuje jako poslední bez ohledu na jeho textovou objednávku.</span><span class="sxs-lookup"><span data-stu-id="6f540-174">The `default` case is evaluated last, regardless of its textual order.</span></span> <span data-ttu-id="6f540-175">Pokud není k dispozici žádný `default` případ a žádný z ostatních příkazů `case` se neshoduje, provádění pokračuje na příkazu, který následuje po příkazu `switch`.</span><span class="sxs-lookup"><span data-stu-id="6f540-175">If there's no `default` case, and none of the other `case` statements match, execution continues at the statement following the `switch` statement.</span></span> <span data-ttu-id="6f540-176">Není spuštěn žádný kód popisku `case`.</span><span class="sxs-lookup"><span data-stu-id="6f540-176">None of the `case` labels code is executed.</span></span>

## <a name="when-clauses-in-case-expressions"></a><span data-ttu-id="6f540-177">klauzule `when` ve výrazech `case`</span><span class="sxs-lookup"><span data-stu-id="6f540-177">`when` clauses in `case` expressions</span></span>

<span data-ttu-id="6f540-178">Pro prvky, které mají 0 oblast s použitím klauzule `when` na `case` popisku, můžete vytvořit zvláštní případy.</span><span class="sxs-lookup"><span data-stu-id="6f540-178">You can make special cases for those shapes that have 0 area by using a `when` clause on the `case` label.</span></span> <span data-ttu-id="6f540-179">Čtverec s délkou druhé délky 0 nebo kroužek s poloměrem 0 má oblast 0.</span><span class="sxs-lookup"><span data-stu-id="6f540-179">A square with a side length of 0, or a circle with a radius of 0 has a 0 area.</span></span> <span data-ttu-id="6f540-180">Tuto podmínku určíte pomocí klauzule `when` na `case` popisku:</span><span class="sxs-lookup"><span data-stu-id="6f540-180">You specify that condition using a `when` clause on the `case` label:</span></span>  

[!code-csharp[ComputeDegenerateShapes](../../samples/snippets/csharp/PatternMatching/GeometricUtilities.cs#07_ComputeDegenerateShapes "Compute shapes with 0 area")]

<span data-ttu-id="6f540-181">Tato změna ukazuje několik důležitých bodů o nové syntaxi.</span><span class="sxs-lookup"><span data-stu-id="6f540-181">This change demonstrates a few important points about the new syntax.</span></span> <span data-ttu-id="6f540-182">Nejprve lze použít více `case`ch popisků na jeden oddíl `switch`.</span><span class="sxs-lookup"><span data-stu-id="6f540-182">First, multiple `case` labels can be applied to one `switch` section.</span></span> <span data-ttu-id="6f540-183">Blok příkazu se spustí, když některý z těchto popisků je `true`.</span><span class="sxs-lookup"><span data-stu-id="6f540-183">The statement block is executed when any of those labels is `true`.</span></span> <span data-ttu-id="6f540-184">Pokud je v tomto případě výraz `switch` buď kruhem, nebo čtvercem s 0 oblastí, vrátí metoda konstantu 0.</span><span class="sxs-lookup"><span data-stu-id="6f540-184">In this instance, if the `switch` expression is either a circle or a square with 0 area, the method returns the constant 0.</span></span>

<span data-ttu-id="6f540-185">Tento příklad zavádí dvě různé proměnné na dvou `case` jmenovky pro první blok `switch`.</span><span class="sxs-lookup"><span data-stu-id="6f540-185">This example introduces two different variables in the two `case` labels for the first `switch` block.</span></span> <span data-ttu-id="6f540-186">Všimněte si, že příkazy v tomto bloku `switch` nepoužívají buď proměnné `c` (pro kruh), nebo `s` (u čtverce).</span><span class="sxs-lookup"><span data-stu-id="6f540-186">Notice that the statements in this `switch` block don't use either the variables `c` (for the circle) or `s` (for the square).</span></span>
<span data-ttu-id="6f540-187">Ani jedna z těchto proměnných není jednoznačně přiřazena v tomto `switch`m bloku.</span><span class="sxs-lookup"><span data-stu-id="6f540-187">Neither of those variables is definitely assigned in this `switch` block.</span></span>
<span data-ttu-id="6f540-188">Pokud se některý z těchto případů shodují, je přiřazena jasně jedna z proměnných.</span><span class="sxs-lookup"><span data-stu-id="6f540-188">If either of these cases match, clearly one of the variables has been assigned.</span></span>
<span data-ttu-id="6f540-189">Není však možné sdělit, *které* bylo přiřazeno v době kompilace, protože případná shoda by mohla být v době běhu.</span><span class="sxs-lookup"><span data-stu-id="6f540-189">However, it's impossible to tell *which* has been assigned at compile time, because either case could match at runtime.</span></span> <span data-ttu-id="6f540-190">Z tohoto důvodu, když použijete více `case`ch popisků pro stejný blok, nebudete v příkazu `case` zavádět novou proměnnou, nebo použijete pouze proměnnou v klauzuli `when`.</span><span class="sxs-lookup"><span data-stu-id="6f540-190">For that reason, most times when you use multiple `case` labels for the same block, you won't introduce a new variable in the `case` statement, or you'll only use the variable in the `when` clause.</span></span>

<span data-ttu-id="6f540-191">Přidávají se tyto obrazce s 0 oblastí, takže přidáváme několik dalších typů tvarů: obdélník a trojúhelník:</span><span class="sxs-lookup"><span data-stu-id="6f540-191">Having added those shapes with 0 area, let's add a couple more shape types: a rectangle and a triangle:</span></span>

[!code-csharp[AddRectangleAndTriangle](../../samples/snippets/csharp/PatternMatching/GeometricUtilities.cs#09_AddRectangleAndTriangle "Add rectangle and triangle")]

 <span data-ttu-id="6f540-192">Tato sada změn přidává `case` popisky pro negenerovaný případ a popisky a bloky pro každý nový tvar.</span><span class="sxs-lookup"><span data-stu-id="6f540-192">This set of changes adds `case` labels for the degenerate case, and labels and blocks for each of the new shapes.</span></span> 

<span data-ttu-id="6f540-193">Nakonec můžete přidat `null` případ, abyste zajistili, že argument nebude `null`:</span><span class="sxs-lookup"><span data-stu-id="6f540-193">Finally, you can add a `null` case to ensure the argument isn't `null`:</span></span>

[!code-csharp[NullCase](../../samples/snippets/csharp/PatternMatching/GeometricUtilities.cs#10_NullCase "Add null case")]

<span data-ttu-id="6f540-194">Speciální chování pro vzor `null` je zajímavé, protože konstanta `null` ve vzorku nemá typ, ale lze ji převést na libovolný odkazový typ nebo na typ s možnou hodnotou null.</span><span class="sxs-lookup"><span data-stu-id="6f540-194">The special behavior for the `null` pattern is interesting because the constant `null` in the pattern doesn't have a type but can be converted to any reference type or nullable type.</span></span> <span data-ttu-id="6f540-195">Místo převedení `null` na libovolný typ jazyk definuje, že `null` hodnota nebude odpovídat žádnému vzoru typu bez ohledu na typ doby kompilace proměnné.</span><span class="sxs-lookup"><span data-stu-id="6f540-195">Rather than convert a `null` to any type, the language defines that a `null` value won't match any type pattern, regardless of the compile-time type of the variable.</span></span> <span data-ttu-id="6f540-196">Toto chování vytvoří nový vzor typu založený `switch`, který je konzistentní s příkazem `is`: `is` příkazy Always vrací `false`, pokud je hodnota zaškrtnuta `null`.</span><span class="sxs-lookup"><span data-stu-id="6f540-196">This behavior makes the new `switch` based type pattern consistent with the `is` statement: `is` statements always return `false` when the value being checked is `null`.</span></span> <span data-ttu-id="6f540-197">Je také jednodušší: po zkontrolování typu nebudete potřebovat další kontrolu null.</span><span class="sxs-lookup"><span data-stu-id="6f540-197">It's also simpler: once you've checked the type, you don't need an additional null check.</span></span> <span data-ttu-id="6f540-198">Můžete vidět, že neexistují žádné kontroly null v žádném z bloků Case výše uvedených vzorků: nejsou nezbytné, protože odpovídající vzorek typu garantuje hodnotu, která není null.</span><span class="sxs-lookup"><span data-stu-id="6f540-198">You can see that from the fact that there are no null checks in any of the case blocks of the samples above: they aren't necessary, since matching the type pattern guarantees a non-null value.</span></span>

## <a name="var-declarations-in-case-expressions"></a><span data-ttu-id="6f540-199">deklarace `var` ve výrazech `case`</span><span class="sxs-lookup"><span data-stu-id="6f540-199">`var` declarations in `case` expressions</span></span>

<span data-ttu-id="6f540-200">Zavedení `var` jako jednoho z výrazů shody zavádí nová pravidla pro porovnávání vzorů.</span><span class="sxs-lookup"><span data-stu-id="6f540-200">The introduction of `var` as one of the match expressions introduces new rules to the pattern match.</span></span>

<span data-ttu-id="6f540-201">Prvním pravidlem je, že deklarace `var` následuje po normálním odvození typu: typ je odvozen jako statický typ výrazu přepínače.</span><span class="sxs-lookup"><span data-stu-id="6f540-201">The first rule is that the `var` declaration follows the normal type inference rules: The type is inferred to be the static type of the switch expression.</span></span> <span data-ttu-id="6f540-202">V tomto pravidle typ vždy odpovídá.</span><span class="sxs-lookup"><span data-stu-id="6f540-202">From that rule, the type always matches.</span></span>

<span data-ttu-id="6f540-203">Druhým pravidlem je, že deklarace `var` nemá kontrolu hodnoty null, kterou obsahují jiné výrazy vzoru typu.</span><span class="sxs-lookup"><span data-stu-id="6f540-203">The second rule is that a `var` declaration doesn't have the null check that other type pattern expressions include.</span></span> <span data-ttu-id="6f540-204">To znamená, že proměnná může mít hodnotu null a v takovém případě je potřeba vrátit hodnotu null.</span><span class="sxs-lookup"><span data-stu-id="6f540-204">That means the variable may be null, and a null check is necessary in that case.</span></span>

<span data-ttu-id="6f540-205">Tato dvě pravidla znamenají, že v mnoha případech deklarace `var` ve výrazu `case` odpovídá stejným podmínkám jako výraz `default`.</span><span class="sxs-lookup"><span data-stu-id="6f540-205">Those two rules mean that in many instances, a `var` declaration in a `case` expression matches the same conditions as a `default` expression.</span></span>
<span data-ttu-id="6f540-206">Vzhledem k tomu, že všechny jiné než výchozí případy jsou upřednostňovány `default`m, nebude případ `default` nikdy spuštěn.</span><span class="sxs-lookup"><span data-stu-id="6f540-206">Because any non-default case is preferred to the `default` case, the `default` case will never execute.</span></span>

> [!NOTE]
> <span data-ttu-id="6f540-207">Kompilátor negeneruje upozornění v případech, kdy byl `default` případ napsaný, ale nikdy se nespustí.</span><span class="sxs-lookup"><span data-stu-id="6f540-207">The compiler does not emit a warning in those cases where a `default` case has been written but will never execute.</span></span> <span data-ttu-id="6f540-208">To je konzistentní s chováním aktuálního příkazu `switch`, kde jsou uvedeny všechny možné případy.</span><span class="sxs-lookup"><span data-stu-id="6f540-208">This is consistent with current `switch` statement behavior where all possible cases have been listed.</span></span>

<span data-ttu-id="6f540-209">Třetí pravidlo zavádí, kde může být užitečný případ `var`.</span><span class="sxs-lookup"><span data-stu-id="6f540-209">The third rule introduces uses where a `var` case may be useful.</span></span> <span data-ttu-id="6f540-210">Představte si, že provádíte porovnávání vzorů, kde vstup je řetězec a hledáte známé hodnoty příkazu.</span><span class="sxs-lookup"><span data-stu-id="6f540-210">Imagine that you're doing a pattern match where the input is a string and you're searching for known command values.</span></span> <span data-ttu-id="6f540-211">Můžete napsat něco jako:</span><span class="sxs-lookup"><span data-stu-id="6f540-211">You might write something like:</span></span>

[!code-csharp[VarCaseExpression](../../samples/snippets/csharp/PatternMatching/Program.cs#VarCaseExpression "use a var case expression to filter white space")]

<span data-ttu-id="6f540-212">`var` Case odpovídá `null`, prázdnému řetězci nebo jakémukoli řetězci, který obsahuje pouze prázdné znaky.</span><span class="sxs-lookup"><span data-stu-id="6f540-212">The `var` case matches `null`, the empty string, or any string that contains only white space.</span></span> <span data-ttu-id="6f540-213">Všimněte si, že předchozí kód používá operátor `?.`, aby se zajistilo, že nechtěně nevyvolá <xref:System.NullReferenceException>.</span><span class="sxs-lookup"><span data-stu-id="6f540-213">Notice that the preceding code uses the `?.` operator to ensure that it doesn't accidentally throw a <xref:System.NullReferenceException>.</span></span> <span data-ttu-id="6f540-214">`default` případ zpracovává všechny další řetězcové hodnoty, které nejsou pochopeny tímto analyzátorem příkazů.</span><span class="sxs-lookup"><span data-stu-id="6f540-214">The `default` case handles any other string values that aren't understood by this command parser.</span></span>

<span data-ttu-id="6f540-215">Toto je jeden z příkladů, kde můžete chtít zvážit výraz případu `var`, který se liší od výrazu `default`.</span><span class="sxs-lookup"><span data-stu-id="6f540-215">This is one example where you may want to consider a `var` case expression that is distinct from a `default` expression.</span></span>

## <a name="conclusions"></a><span data-ttu-id="6f540-216">Závěry</span><span class="sxs-lookup"><span data-stu-id="6f540-216">Conclusions</span></span>

<span data-ttu-id="6f540-217">*Konstrukce porovnávání vzorů* vám umožňují snadno spravovat tok řízení mezi různými proměnnými a typy, které nesouvisí s hierarchií dědičnosti.</span><span class="sxs-lookup"><span data-stu-id="6f540-217">*Pattern Matching constructs* enable you to easily manage control flow among different variables and types that aren't related by an inheritance hierarchy.</span></span> <span data-ttu-id="6f540-218">Můžete také řídit logiku pro použití libovolné podmínky, kterou testujete u proměnné.</span><span class="sxs-lookup"><span data-stu-id="6f540-218">You can also control logic to use any condition you test on the variable.</span></span> <span data-ttu-id="6f540-219">Umožňuje vzory a idiomy, které budete potřebovat častěji při sestavování více distribuovaných aplikací, kde data a metody, které pracují s těmito daty, jsou oddělené.</span><span class="sxs-lookup"><span data-stu-id="6f540-219">It enables patterns and idioms that you'll need more often as you build more distributed applications, where data and the methods that manipulate that data are separate.</span></span> <span data-ttu-id="6f540-220">Všimněte si, že struktury tvarů použité v této ukázce neobsahují žádné metody, pouze vlastnosti jen pro čtení.</span><span class="sxs-lookup"><span data-stu-id="6f540-220">You'll notice that the shape structs used in this sample don't contain any methods, just read-only properties.</span></span>
<span data-ttu-id="6f540-221">Porovnávání vzorů funguje s jakýmkoli datovým typem.</span><span class="sxs-lookup"><span data-stu-id="6f540-221">Pattern Matching works with any data type.</span></span> <span data-ttu-id="6f540-222">Zapisujete výrazy, které prozkoumají objekt, a na základě těchto podmínek proveďte rozhodnutí toku řízení.</span><span class="sxs-lookup"><span data-stu-id="6f540-222">You write expressions that examine the object, and make control flow decisions based on those conditions.</span></span>

<span data-ttu-id="6f540-223">Porovnejte kód z této ukázky s návrhem, který by následoval z vytváření hierarchie tříd pro abstraktní `Shape` a specifické odvozené tvary z každého s vlastní implementací virtuální metody pro výpočet oblasti.</span><span class="sxs-lookup"><span data-stu-id="6f540-223">Compare the code from this sample with the design that would follow from creating a class hierarchy for an abstract `Shape` and specific derived shapes each with their own implementation of a virtual method to calculate the area.</span></span> <span data-ttu-id="6f540-224">Často zjistíte, že výrazy porovnávání vzorů můžou být velmi užitečným nástrojem při práci s daty a chcete oddělit informace týkající se úložiště dat, která se týkají chování.</span><span class="sxs-lookup"><span data-stu-id="6f540-224">You'll often find that pattern matching expressions can be a very useful tool when you're working with data and want to separate the data storage concerns from the behavior concerns.</span></span>

## <a name="see-also"></a><span data-ttu-id="6f540-225">Viz také</span><span class="sxs-lookup"><span data-stu-id="6f540-225">See also</span></span>

- [<span data-ttu-id="6f540-226">Kurz: použití funkcí pro porovnávání vzorů k rozšiřování datových typů</span><span class="sxs-lookup"><span data-stu-id="6f540-226">Tutorial: Using pattern matching features to extend data types</span></span>](tutorials/pattern-matching.md)
