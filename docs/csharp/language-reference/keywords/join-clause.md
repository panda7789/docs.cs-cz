---
description: klauzule JOIN – reference jazyka C#
title: klauzule JOIN – reference jazyka C#
ms.date: 07/20/2015
f1_keywords:
- join
- join_CSharpKeyword
helpviewer_keywords:
- join clause [C#]
- join keyword [C#]
ms.assetid: 76e9df84-092c-41a6-9537-c3f1cbd7f0fb
ms.openlocfilehash: 44b35bd1243e4715f81513eef9968f30a8f315a3
ms.sourcegitcommit: d579fb5e4b46745fd0f1f8874c94c6469ce58604
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 08/30/2020
ms.locfileid: "89139746"
---
# <a name="join-clause-c-reference"></a><span data-ttu-id="9db01-103">join – klauzule (Referenční dokumentace jazyka C#)</span><span class="sxs-lookup"><span data-stu-id="9db01-103">join clause (C# Reference)</span></span>

<span data-ttu-id="9db01-104">`join`Klauzule je užitečná pro přidružení prvků z různých zdrojových sekvencí, které nemají přímý vztah v objektovém modelu.</span><span class="sxs-lookup"><span data-stu-id="9db01-104">The `join` clause is useful for associating elements from different source sequences that have no direct relationship in the object model.</span></span> <span data-ttu-id="9db01-105">Jediným požadavkem je, aby elementy v jednotlivých zdrojích sdílely určitou hodnotu, která může být porovnána s rovností.</span><span class="sxs-lookup"><span data-stu-id="9db01-105">The only requirement is that the elements in each source share some value that can be compared for equality.</span></span> <span data-ttu-id="9db01-106">Například distributor potravinářského prostředí může mít seznam dodavatelů určitého produktu a seznam nákupčích.</span><span class="sxs-lookup"><span data-stu-id="9db01-106">For example, a food distributor might have a list of suppliers of a certain product, and a list of buyers.</span></span> <span data-ttu-id="9db01-107">`join`Klauzuli lze použít například k vytvoření seznamu dodavatelů a nákupčích tohoto produktu, kteří jsou ve stejné konkrétní oblasti.</span><span class="sxs-lookup"><span data-stu-id="9db01-107">A `join` clause can be used, for example, to create a list of the suppliers and buyers of that product who are all in the same specified region.</span></span>

<span data-ttu-id="9db01-108">`join`Klauzule přijímá jako vstup dvě zdrojové sekvence.</span><span class="sxs-lookup"><span data-stu-id="9db01-108">A `join` clause takes two source sequences as input.</span></span> <span data-ttu-id="9db01-109">Prvky v každé sekvenci musí být buď nebo obsahují vlastnost, která může být porovnána s odpovídající vlastností v druhé sekvenci.</span><span class="sxs-lookup"><span data-stu-id="9db01-109">The elements in each sequence must either be or contain a property that can be compared to a corresponding property in the other sequence.</span></span> <span data-ttu-id="9db01-110">`join`Klauzule porovnává zadané klíče k rovnosti pomocí `equals` klíčového slova Special.</span><span class="sxs-lookup"><span data-stu-id="9db01-110">The `join` clause compares the specified keys for equality by using the special `equals` keyword.</span></span> <span data-ttu-id="9db01-111">Všechna spojení prováděná `join` klauzulí jsou equijoins.</span><span class="sxs-lookup"><span data-stu-id="9db01-111">All joins performed by the `join` clause are equijoins.</span></span> <span data-ttu-id="9db01-112">Tvar výstupu `join` klauzule závisí na konkrétním typu spojení, které provádíte.</span><span class="sxs-lookup"><span data-stu-id="9db01-112">The shape of the output of a `join` clause depends on the specific type of join you are performing.</span></span> <span data-ttu-id="9db01-113">Níže jsou tři nejběžnější typy spojení:</span><span class="sxs-lookup"><span data-stu-id="9db01-113">The following are three most common join types:</span></span>

- <span data-ttu-id="9db01-114">Vnitřní spojení</span><span class="sxs-lookup"><span data-stu-id="9db01-114">Inner join</span></span>

- <span data-ttu-id="9db01-115">Spojení skupin</span><span class="sxs-lookup"><span data-stu-id="9db01-115">Group join</span></span>

- <span data-ttu-id="9db01-116">Levé vnější spojení</span><span class="sxs-lookup"><span data-stu-id="9db01-116">Left outer join</span></span>

## <a name="inner-join"></a><span data-ttu-id="9db01-117">Vnitřní spojení</span><span class="sxs-lookup"><span data-stu-id="9db01-117">Inner join</span></span>

<span data-ttu-id="9db01-118">Následující příklad ukazuje jednoduchý vnitřní equijoin.</span><span class="sxs-lookup"><span data-stu-id="9db01-118">The following example shows a simple inner equijoin.</span></span> <span data-ttu-id="9db01-119">Tento dotaz vytvoří nestrukturovanou posloupnost párů "název produktu/kategorie".</span><span class="sxs-lookup"><span data-stu-id="9db01-119">This query produces a flat sequence of "product name / category" pairs.</span></span> <span data-ttu-id="9db01-120">Stejný řetězec kategorie se zobrazí ve více prvcích.</span><span class="sxs-lookup"><span data-stu-id="9db01-120">The same category string will appear in multiple elements.</span></span> <span data-ttu-id="9db01-121">Pokud prvek z `categories` nemá žádnou shodu `products` , tato kategorie se ve výsledcích nezobrazí.</span><span class="sxs-lookup"><span data-stu-id="9db01-121">If an element from `categories` has no matching `products`, that category will not appear in the results.</span></span>

[!code-csharp[cscsrefQueryKeywords#24](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsCsrefQueryKeywords/CS/Join.cs#24)]

<span data-ttu-id="9db01-122">Další informace najdete v tématu [provádění vnitřních spojení](../../linq/perform-inner-joins.md).</span><span class="sxs-lookup"><span data-stu-id="9db01-122">For more information, see [Perform inner joins](../../linq/perform-inner-joins.md).</span></span>

## <a name="group-join"></a><span data-ttu-id="9db01-123">Spojení skupin</span><span class="sxs-lookup"><span data-stu-id="9db01-123">Group join</span></span>

<span data-ttu-id="9db01-124">`join`Klauzule s `into` výrazem se nazývá spojení se skupinou.</span><span class="sxs-lookup"><span data-stu-id="9db01-124">A `join` clause with an `into` expression is called a group join.</span></span>

[!code-csharp[cscsrefQueryKeywords#25](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsCsrefQueryKeywords/CS/Join.cs#25)]

<span data-ttu-id="9db01-125">Spojení se skupinou vytvoří hierarchickou sekvenci výsledků, která přidruží prvky v levé zdrojové sekvenci k jednomu nebo více shodným prvkům zdrojové sekvence na pravé straně.</span><span class="sxs-lookup"><span data-stu-id="9db01-125">A group join produces a hierarchical result sequence, which associates elements in the left source sequence with one or more matching elements in the right side source sequence.</span></span> <span data-ttu-id="9db01-126">Spojení se skupinami nemá v relačních výrazech žádný ekvivalent. v podstatě je to sekvence polí objektů.</span><span class="sxs-lookup"><span data-stu-id="9db01-126">A group join has no equivalent in relational terms; it is essentially a sequence of object arrays.</span></span>

<span data-ttu-id="9db01-127">Pokud se nenajde žádné elementy z pravé zdrojové sekvence, aby odpovídaly elementu v levém zdroji, klauzule vytvoří `join` pro tuto položku prázdné pole.</span><span class="sxs-lookup"><span data-stu-id="9db01-127">If no elements from the right source sequence are found to match an element in the left source, the `join` clause will produce an empty array for that item.</span></span> <span data-ttu-id="9db01-128">Proto je spojení se skupinou stále v podstatě vnitřní equijoin s tím rozdílem, že je sekvence výsledků uspořádána do skupin.</span><span class="sxs-lookup"><span data-stu-id="9db01-128">Therefore, the group join is still basically an inner-equijoin except that the result sequence is organized into groups.</span></span>

<span data-ttu-id="9db01-129">Pokud jste vybrali jenom výsledky spojení se skupinami, můžete k položkám přistupovat, ale nemůžete identifikovat klíč, na kterém se shodují.</span><span class="sxs-lookup"><span data-stu-id="9db01-129">If you just select the results of a group join, you can access the items, but you cannot identify the key that they match on.</span></span> <span data-ttu-id="9db01-130">Proto je obecně vhodnější vybrat výsledky připojení skupiny do nového typu, který má také název klíče, jak je znázorněno v předchozím příkladu.</span><span class="sxs-lookup"><span data-stu-id="9db01-130">Therefore, it is generally more useful to select the results of the group join into a new type that also has the key name, as shown in the previous example.</span></span>

<span data-ttu-id="9db01-131">Můžete samozřejmě také použít výsledek spojení skupiny jako generátor jiného poddotazu:</span><span class="sxs-lookup"><span data-stu-id="9db01-131">You can also, of course, use the result of a group join as the generator of another subquery:</span></span>

[!code-csharp[cscsrefQueryKeywords#26](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsCsrefQueryKeywords/CS/Join.cs#26)]

<span data-ttu-id="9db01-132">Další informace najdete v tématu [provedení seskupených spojení](../../linq/perform-grouped-joins.md).</span><span class="sxs-lookup"><span data-stu-id="9db01-132">For more information, see [Perform grouped joins](../../linq/perform-grouped-joins.md).</span></span>

## <a name="left-outer-join"></a><span data-ttu-id="9db01-133">Levé vnější spojení</span><span class="sxs-lookup"><span data-stu-id="9db01-133">Left outer join</span></span>

<span data-ttu-id="9db01-134">V levém vnějším spojení jsou vráceny všechny prvky v levé zdrojové sekvenci, a to i v případě, že v pravé sekvenci nejsou žádné vyhovující prvky.</span><span class="sxs-lookup"><span data-stu-id="9db01-134">In a left outer join, all the elements in the left source sequence are returned, even if no matching elements are in the right sequence.</span></span> <span data-ttu-id="9db01-135">K provedení levého vnějšího spojení v LINQ použijte `DefaultIfEmpty` metodu v kombinaci s připojením skupiny k určení výchozího prvku na pravé straně, který se vytvoří, pokud element na levé straně nemá žádné shody.</span><span class="sxs-lookup"><span data-stu-id="9db01-135">To perform a left outer join in LINQ, use the `DefaultIfEmpty` method in combination with a group join to specify a default right-side element to produce if a left-side element has no matches.</span></span> <span data-ttu-id="9db01-136">Můžete použít `null` jako výchozí hodnotu libovolného typu odkazu nebo můžete zadat uživatelsky definovaný výchozí typ.</span><span class="sxs-lookup"><span data-stu-id="9db01-136">You can use `null` as the default value for any reference type, or you can specify a user-defined default type.</span></span> <span data-ttu-id="9db01-137">V následujícím příkladu je zobrazen uživatelsky definovaný výchozí typ:</span><span class="sxs-lookup"><span data-stu-id="9db01-137">In the following example, a user-defined default type is shown:</span></span>

[!code-csharp[cscsrefQueryKeywords#27](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsCsrefQueryKeywords/CS/Join.cs#27)]

<span data-ttu-id="9db01-138">Další informace najdete v tématu [provedení levých vnějších spojení](../../linq/perform-left-outer-joins.md).</span><span class="sxs-lookup"><span data-stu-id="9db01-138">For more information, see [Perform left outer joins](../../linq/perform-left-outer-joins.md).</span></span>

## <a name="the-equals-operator"></a><span data-ttu-id="9db01-139">Operátor Equals</span><span class="sxs-lookup"><span data-stu-id="9db01-139">The equals operator</span></span>

<span data-ttu-id="9db01-140">`join`Klauzule provede výjimku equijoin.</span><span class="sxs-lookup"><span data-stu-id="9db01-140">A `join` clause performs an equijoin.</span></span> <span data-ttu-id="9db01-141">Jinými slovy, můžete pouze základní shody s rovností dvou klíčů.</span><span class="sxs-lookup"><span data-stu-id="9db01-141">In other words, you can only base matches on the equality of two keys.</span></span> <span data-ttu-id="9db01-142">Jiné typy porovnání, jako je "větší než" nebo "nerovnost", nejsou podporovány.</span><span class="sxs-lookup"><span data-stu-id="9db01-142">Other types of comparisons such as "greater than" or "not equals" are not supported.</span></span> <span data-ttu-id="9db01-143">Aby bylo jasné, že se všechna spojení equijoins, `join` použije klauzule `equals` místo operátoru klíčové slovo `==` .</span><span class="sxs-lookup"><span data-stu-id="9db01-143">To make clear that all joins are equijoins, the `join` clause uses the `equals` keyword instead of the `==` operator.</span></span> <span data-ttu-id="9db01-144">`equals`Klíčové slovo lze použít pouze v `join` klauzuli a liší se od `==` operátora v jednom důležitém způsobu.</span><span class="sxs-lookup"><span data-stu-id="9db01-144">The `equals` keyword can only be used in a `join` clause and it differs from the `==` operator in one important way.</span></span> <span data-ttu-id="9db01-145">Pomocí `equals` , levý klíč spotřebovává vnější zdrojovou sekvenci a pravý klíč spotřebovává vnitřní zdroj.</span><span class="sxs-lookup"><span data-stu-id="9db01-145">With `equals`, the left key consumes the outer source sequence, and the right key consumes the inner source.</span></span> <span data-ttu-id="9db01-146">Vnější zdroj je pouze v rozsahu na levé straně `equals` a vnitřní zdrojová sekvence je pouze v rozsahu na pravé straně.</span><span class="sxs-lookup"><span data-stu-id="9db01-146">The outer source is only in scope on the left side of `equals` and the inner source sequence is only in scope on the right side.</span></span>

## <a name="non-equijoins"></a><span data-ttu-id="9db01-147">Bez equijoins</span><span class="sxs-lookup"><span data-stu-id="9db01-147">Non-equijoins</span></span>

<span data-ttu-id="9db01-148">`from`K zavedení nových sekvencí nezávisle na dotaz můžete použít více klauzulí, a to pomocí více klauzulí.</span><span class="sxs-lookup"><span data-stu-id="9db01-148">You can perform non-equijoins, cross joins, and other custom join operations by using multiple `from` clauses to introduce new sequences independently into a query.</span></span> <span data-ttu-id="9db01-149">Další informace najdete v tématu [provádění vlastních operací spojení](../../linq/perform-custom-join-operations.md).</span><span class="sxs-lookup"><span data-stu-id="9db01-149">For more information, see [Perform custom join operations](../../linq/perform-custom-join-operations.md).</span></span>

## <a name="joins-on-object-collections-vs-relational-tables"></a><span data-ttu-id="9db01-150">Spojení s kolekcemi objektů vs. relačními tabulkami</span><span class="sxs-lookup"><span data-stu-id="9db01-150">Joins on object collections vs. relational tables</span></span>

<span data-ttu-id="9db01-151">Ve výrazu dotazu LINQ se operace join provádí na kolekcích objektů.</span><span class="sxs-lookup"><span data-stu-id="9db01-151">In a LINQ query expression, join operations are performed on object collections.</span></span> <span data-ttu-id="9db01-152">Kolekce objektů nemohou být "připojené" stejným způsobem jako dvě relační tabulky.</span><span class="sxs-lookup"><span data-stu-id="9db01-152">Object collections cannot be "joined" in exactly the same way as two relational tables.</span></span> <span data-ttu-id="9db01-153">V LINQ jsou explicitní `join` klauzule požadovány pouze v případě, že dvě zdrojové sekvence nejsou svázány s žádnou relací.</span><span class="sxs-lookup"><span data-stu-id="9db01-153">In LINQ, explicit `join` clauses are only required when two source sequences are not tied by any relationship.</span></span> <span data-ttu-id="9db01-154">Při práci s se [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] tabulky cizích klíčů v objektovém modelu reprezentují jako vlastnosti primární tabulky.</span><span class="sxs-lookup"><span data-stu-id="9db01-154">When working with [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)], foreign key tables are represented in the object model as properties of the primary table.</span></span> <span data-ttu-id="9db01-155">Například v databázi Northwind má tabulka Customer relaci cizího klíče s tabulkou Orders.</span><span class="sxs-lookup"><span data-stu-id="9db01-155">For example, in the Northwind database, the Customer table has a foreign key relationship with the Orders table.</span></span> <span data-ttu-id="9db01-156">Při mapování tabulek na objektový model má třída Customer vlastnost Orders, která obsahuje kolekci objednávek přidružených k danému zákazníkovi.</span><span class="sxs-lookup"><span data-stu-id="9db01-156">When you map the tables to the object model, the Customer class has an Orders property that contains the collection of Orders associated with that Customer.</span></span> <span data-ttu-id="9db01-157">V důsledku toho se připojení už pro vás udělalo.</span><span class="sxs-lookup"><span data-stu-id="9db01-157">In effect, the join has already been done for you.</span></span>

<span data-ttu-id="9db01-158">Další informace o dotazování napříč souvisejícími tabulkami v kontextu [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] naleznete v tématu [How to: map Database Relationships](../../../framework/data/adonet/sql/linq/how-to-map-database-relationships.md).</span><span class="sxs-lookup"><span data-stu-id="9db01-158">For more information about querying across related tables in the context of [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)], see [How to: Map Database Relationships](../../../framework/data/adonet/sql/linq/how-to-map-database-relationships.md).</span></span>

## <a name="composite-keys"></a><span data-ttu-id="9db01-159">Složené klíče</span><span class="sxs-lookup"><span data-stu-id="9db01-159">Composite keys</span></span>

<span data-ttu-id="9db01-160">K otestování rovnosti více hodnot můžete použít složený klíč.</span><span class="sxs-lookup"><span data-stu-id="9db01-160">You can test for equality of multiple values by using a composite key.</span></span> <span data-ttu-id="9db01-161">Další informace najdete v tématu [připojení pomocí složených klíčů](../../linq/join-by-using-composite-keys.md).</span><span class="sxs-lookup"><span data-stu-id="9db01-161">For more information, see [Join by using composite keys](../../linq/join-by-using-composite-keys.md).</span></span> <span data-ttu-id="9db01-162">V klauzuli lze použít také složené klíče `group` .</span><span class="sxs-lookup"><span data-stu-id="9db01-162">Composite keys can be also used in a `group` clause.</span></span>

## <a name="example"></a><span data-ttu-id="9db01-163">Příklad</span><span class="sxs-lookup"><span data-stu-id="9db01-163">Example</span></span>

<span data-ttu-id="9db01-164">Následující příklad porovnává výsledky vnitřního spojení, spojení skupin a levé vnější spojení se stejnými zdroji dat pomocí stejných shodných klíčů.</span><span class="sxs-lookup"><span data-stu-id="9db01-164">The following example compares the results of an inner join, a group join, and a left outer join on the same data sources by using the same matching keys.</span></span> <span data-ttu-id="9db01-165">Do těchto příkladů se přidá nějaký další kód, který vyjasní výsledky v zobrazení konzoly.</span><span class="sxs-lookup"><span data-stu-id="9db01-165">Some extra code is added to these examples to clarify the results in the console display.</span></span>

[!code-csharp[cscsrefQueryKeywords#23](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsCsrefQueryKeywords/CS/Join.cs#23)]

## <a name="remarks"></a><span data-ttu-id="9db01-166">Poznámky</span><span class="sxs-lookup"><span data-stu-id="9db01-166">Remarks</span></span>

<span data-ttu-id="9db01-167">`join`Klauzule, která není následována, `into` je přeložena do <xref:System.Linq.Enumerable.Join%2A> volání metody.</span><span class="sxs-lookup"><span data-stu-id="9db01-167">A `join` clause that is not followed by `into` is translated into a <xref:System.Linq.Enumerable.Join%2A> method call.</span></span> <span data-ttu-id="9db01-168">`join`Klauzule, která je následována, `into` je přeložena na <xref:System.Linq.Enumerable.GroupJoin%2A> volání metody.</span><span class="sxs-lookup"><span data-stu-id="9db01-168">A `join` clause that is followed by `into` is translated to a <xref:System.Linq.Enumerable.GroupJoin%2A> method call.</span></span>

## <a name="see-also"></a><span data-ttu-id="9db01-169">Viz také</span><span class="sxs-lookup"><span data-stu-id="9db01-169">See also</span></span>

- [<span data-ttu-id="9db01-170">Klíčová slova dotazu (LINQ)</span><span class="sxs-lookup"><span data-stu-id="9db01-170">Query Keywords (LINQ)</span></span>](query-keywords.md)
- [<span data-ttu-id="9db01-171">LINQ (Language Integrated Query)</span><span class="sxs-lookup"><span data-stu-id="9db01-171">Language Integrated Query (LINQ)</span></span>](../../linq/index.md)
- [<span data-ttu-id="9db01-172">Operace sjednocení</span><span class="sxs-lookup"><span data-stu-id="9db01-172">Join Operations</span></span>](../../programming-guide/concepts/linq/join-operations.md)
- [<span data-ttu-id="9db01-173">group – klauzule</span><span class="sxs-lookup"><span data-stu-id="9db01-173">group clause</span></span>](group-clause.md)
- [<span data-ttu-id="9db01-174">Provedení levých vnějších spojení</span><span class="sxs-lookup"><span data-stu-id="9db01-174">Perform left outer joins</span></span>](../../linq/perform-left-outer-joins.md)
- [<span data-ttu-id="9db01-175">Provádění vnitřních spojení</span><span class="sxs-lookup"><span data-stu-id="9db01-175">Perform inner joins</span></span>](../../linq/perform-inner-joins.md)
- [<span data-ttu-id="9db01-176">Provádění seskupených spojení</span><span class="sxs-lookup"><span data-stu-id="9db01-176">Perform grouped joins</span></span>](../../linq/perform-grouped-joins.md)
- [<span data-ttu-id="9db01-177">Řazení výsledků klauzule join</span><span class="sxs-lookup"><span data-stu-id="9db01-177">Order the results of a join clause</span></span>](../../linq/order-the-results-of-a-join-clause.md)
- [<span data-ttu-id="9db01-178">Spojení pomocí složených klíčů</span><span class="sxs-lookup"><span data-stu-id="9db01-178">Join by using composite keys</span></span>](../../linq/join-by-using-composite-keys.md)
- [<span data-ttu-id="9db01-179">Kompatibilní databázové systémy pro Visual Studio</span><span class="sxs-lookup"><span data-stu-id="9db01-179">Compatible database systems for Visual Studio</span></span>](/visualstudio/data-tools/installing-database-systems-tools-and-samples)
