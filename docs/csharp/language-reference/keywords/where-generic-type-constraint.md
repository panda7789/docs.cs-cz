---
description: WHERE (omezení obecného typu) – Reference jazyka C#
title: WHERE (omezení obecného typu) – Reference jazyka C#
ms.date: 04/15/2020
f1_keywords:
- whereconstraint
- whereconstraint_CSharpKeyword
helpviewer_keywords:
- where (generic type constraint) [C#]
ms.openlocfilehash: 78f784135c6bf01ea9724fcf92be234e6b86ff07
ms.sourcegitcommit: d579fb5e4b46745fd0f1f8874c94c6469ce58604
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 08/30/2020
ms.locfileid: "89141904"
---
# <a name="where-generic-type-constraint-c-reference"></a><span data-ttu-id="1f22c-103">where (omezení obecného typu) (Referenční dokumentace jazyka C#)</span><span class="sxs-lookup"><span data-stu-id="1f22c-103">where (generic type constraint) (C# Reference)</span></span>

<span data-ttu-id="1f22c-104">`where`Klauzule v obecné definici určuje omezení pro typy, které se používají jako argumenty pro parametry typu v obecném typu, metodě, delegátu nebo místní funkci.</span><span class="sxs-lookup"><span data-stu-id="1f22c-104">The `where` clause in a generic definition specifies constraints on the types that are used as arguments for type parameters in a generic type, method, delegate, or local function.</span></span> <span data-ttu-id="1f22c-105">Omezení mohou určovat rozhraní, základní třídy nebo vyžadovat, aby byl obecný typ odkaz, hodnota nebo nespravovaný typ.</span><span class="sxs-lookup"><span data-stu-id="1f22c-105">Constraints can specify interfaces, base classes, or require a generic type to be a reference, value, or unmanaged type.</span></span> <span data-ttu-id="1f22c-106">Deklaruje možnosti, které musí mít argument typu.</span><span class="sxs-lookup"><span data-stu-id="1f22c-106">They declare capabilities that the type argument must have.</span></span>

<span data-ttu-id="1f22c-107">Můžete například deklarovat obecnou třídu, například `MyGenericClass` parametr typu `T` implementuje <xref:System.IComparable%601> rozhraní:</span><span class="sxs-lookup"><span data-stu-id="1f22c-107">For example, you can declare a generic class, `MyGenericClass`, such that the type parameter `T` implements the <xref:System.IComparable%601> interface:</span></span>

[!code-csharp[using an interface constraint](snippets/GenericWhereConstraints.cs#1)]

> [!NOTE]
> <span data-ttu-id="1f22c-108">Další informace o klauzuli WHERE ve výrazu dotazu naleznete v tématu [Where klauzule](where-clause.md).</span><span class="sxs-lookup"><span data-stu-id="1f22c-108">For more information on the where clause in a query expression, see [where clause](where-clause.md).</span></span>

<span data-ttu-id="1f22c-109">`where`Klauzule může také zahrnovat omezení základní třídy.</span><span class="sxs-lookup"><span data-stu-id="1f22c-109">The `where` clause can also include a base class constraint.</span></span> <span data-ttu-id="1f22c-110">Omezení základní třídy uvádí, že typ, který má být použit jako argument typu pro tento obecný typ, má zadanou třídu jako základní třídu nebo je základní třída.</span><span class="sxs-lookup"><span data-stu-id="1f22c-110">The base class constraint states that a type to be used as a type argument for that generic type has the specified class as a base class, or is that base class.</span></span> <span data-ttu-id="1f22c-111">Pokud je použito omezení základní třídy, musí být uvedena před všemi ostatními omezeními pro tento parametr typu.</span><span class="sxs-lookup"><span data-stu-id="1f22c-111">If the base class constraint is used, it must appear before any other constraints on that type parameter.</span></span> <span data-ttu-id="1f22c-112">Některé typy nejsou povoleny jako omezení základní třídy: <xref:System.Object> , <xref:System.Array> a <xref:System.ValueType> .</span><span class="sxs-lookup"><span data-stu-id="1f22c-112">Some types are disallowed as a base class constraint: <xref:System.Object>, <xref:System.Array>, and <xref:System.ValueType>.</span></span> <span data-ttu-id="1f22c-113">Před C# 7,3, <xref:System.Enum> , a <xref:System.Delegate> <xref:System.MulticastDelegate> byly také zakázány jako omezení základní třídy.</span><span class="sxs-lookup"><span data-stu-id="1f22c-113">Before C# 7.3, <xref:System.Enum>, <xref:System.Delegate>, and <xref:System.MulticastDelegate> were also disallowed as base class constraints.</span></span> <span data-ttu-id="1f22c-114">Následující příklad ukazuje typy, které lze nyní zadat jako základní třídu:</span><span class="sxs-lookup"><span data-stu-id="1f22c-114">The following example shows the types that can now be specified as a base class:</span></span>

[!code-csharp[using an interface constraint](snippets/GenericWhereConstraints.cs#2)]

<span data-ttu-id="1f22c-115">V kontextu s možnou hodnotou null v jazyce C# 8,0 a novějším je vynutila hodnota null typu základní třídy.</span><span class="sxs-lookup"><span data-stu-id="1f22c-115">In a nullable context in C# 8.0 and later, the nullability of the base class type is enforced.</span></span> <span data-ttu-id="1f22c-116">Pokud základní třída nemůže mít hodnotu null (například `Base` ), argument typu nesmí mít hodnotu null.</span><span class="sxs-lookup"><span data-stu-id="1f22c-116">If the base class is non-nullable (for example `Base`), the type argument must be non-nullable.</span></span> <span data-ttu-id="1f22c-117">Pokud je základní třídou Nullable (například `Base?` ), může být argumentem typu buď typ odkazu s možnou hodnotou null, nebo odkaz, který nepovoluje hodnotu null.</span><span class="sxs-lookup"><span data-stu-id="1f22c-117">If the base class is nullable (for example `Base?`), the type argument may be either a nullable or non-nullable reference type.</span></span> <span data-ttu-id="1f22c-118">Kompilátor vydá upozornění, pokud je argumentem typu typ odkazu s možnou hodnotou null, pokud základní třída nemůže mít hodnotu null.</span><span class="sxs-lookup"><span data-stu-id="1f22c-118">The compiler issues a warning if the type argument is a nullable reference type when the base class is non-nullable.</span></span>

<span data-ttu-id="1f22c-119">`where`Klauzule může určit, že typ je `class` nebo `struct` .</span><span class="sxs-lookup"><span data-stu-id="1f22c-119">The `where` clause can specify that the type is a `class` or a `struct`.</span></span> <span data-ttu-id="1f22c-120">`struct`Omezení eliminuje nutnost zadat omezení základní třídy `System.ValueType` .</span><span class="sxs-lookup"><span data-stu-id="1f22c-120">The `struct` constraint removes the need to specify a base class constraint of `System.ValueType`.</span></span> <span data-ttu-id="1f22c-121">`System.ValueType`Typ nelze použít jako omezení základní třídy.</span><span class="sxs-lookup"><span data-stu-id="1f22c-121">The `System.ValueType` type may not be used as a base class constraint.</span></span> <span data-ttu-id="1f22c-122">Následující příklad ukazuje obě `class` `struct` omezení a:</span><span class="sxs-lookup"><span data-stu-id="1f22c-122">The following example shows both the `class` and `struct` constraints:</span></span>

[!code-csharp[using the class and struct constraints](snippets/GenericWhereConstraints.cs#3)]

<span data-ttu-id="1f22c-123">V kontextu s možnou hodnotou null v jazyce C# 8,0 a vyšší `class` omezení vyžaduje, aby typ byl odkazový typ, který nemůže být null.</span><span class="sxs-lookup"><span data-stu-id="1f22c-123">In a nullable context in C# 8.0 and later, the `class` constraint requires a type to be a non-nullable reference type.</span></span> <span data-ttu-id="1f22c-124">Chcete-li povolit typy odkazů s možnou hodnotou null, použijte `class?` omezení, které umožňuje přístup s možnou hodnotou null i odkaz na jiný typ.</span><span class="sxs-lookup"><span data-stu-id="1f22c-124">To allow nullable reference types, use the `class?` constraint, which allows both nullable and non-nullable reference types.</span></span>

<span data-ttu-id="1f22c-125">`where`Klauzule může zahrnovat `notnull` omezení.</span><span class="sxs-lookup"><span data-stu-id="1f22c-125">The `where` clause may include the `notnull` constraint.</span></span> <span data-ttu-id="1f22c-126">`notnull`Omezení omezuje parametr typu na typy, které nejsou null.</span><span class="sxs-lookup"><span data-stu-id="1f22c-126">The `notnull` constraint limits the type parameter to non-nullable types.</span></span> <span data-ttu-id="1f22c-127">Tento typ může být [typ hodnoty](../builtin-types/value-types.md) nebo typ odkazu, který neumožňuje hodnotu null.</span><span class="sxs-lookup"><span data-stu-id="1f22c-127">That type may be a [value type](../builtin-types/value-types.md) or a non-nullable reference type.</span></span> <span data-ttu-id="1f22c-128">`notnull`Omezení je k dispozici počínaje jazykem C# 8,0 pro kód zkompilovaný v [ `nullable enable` kontextu](../../nullable-references.md#nullable-contexts).</span><span class="sxs-lookup"><span data-stu-id="1f22c-128">The `notnull` constraint is available starting in C# 8.0 for code compiled in a [`nullable enable` context](../../nullable-references.md#nullable-contexts).</span></span> <span data-ttu-id="1f22c-129">Na rozdíl od jiných omezení, pokud argument typu v rozporu s `notnull` omezením, kompilátor vygeneruje upozornění namísto chyby.</span><span class="sxs-lookup"><span data-stu-id="1f22c-129">Unlike other constraints, if a type argument violates the `notnull` constraint, the compiler generates a warning instead of an error.</span></span> <span data-ttu-id="1f22c-130">Upozornění se generují jenom v `nullable enable` kontextu.</span><span class="sxs-lookup"><span data-stu-id="1f22c-130">Warnings are only generated in a `nullable enable` context.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="1f22c-131">Obecné deklarace, které obsahují `notnull` omezení, mohou být použity v oblivious kontextu s možnou hodnotou null, ale kompilátor neuplatňuje omezení.</span><span class="sxs-lookup"><span data-stu-id="1f22c-131">Generic declarations that include the `notnull` constraint can be used in a nullable oblivious context, but compiler does not enforce the constraint.</span></span>

[!code-csharp[using the nonnull constraint](snippets/GenericWhereConstraints.cs#NotNull)]

<span data-ttu-id="1f22c-132">`where`Klauzule může také obsahovat `unmanaged` omezení.</span><span class="sxs-lookup"><span data-stu-id="1f22c-132">The `where` clause may also include an `unmanaged` constraint.</span></span> <span data-ttu-id="1f22c-133">`unmanaged`Omezení omezuje parametr typu na typy známé jako [nespravované typy](../builtin-types/unmanaged-types.md).</span><span class="sxs-lookup"><span data-stu-id="1f22c-133">The `unmanaged` constraint limits the type parameter to types known as [unmanaged types](../builtin-types/unmanaged-types.md).</span></span> <span data-ttu-id="1f22c-134">`unmanaged`Omezení usnadňuje psaní kódu spolupráce na nízké úrovni v jazyce C#.</span><span class="sxs-lookup"><span data-stu-id="1f22c-134">The `unmanaged` constraint makes it easier to write low-level interop code in C#.</span></span> <span data-ttu-id="1f22c-135">Toto omezení povoluje opakovaně použitelné rutiny ve všech nespravovaných typech.</span><span class="sxs-lookup"><span data-stu-id="1f22c-135">This constraint enables reusable routines across all unmanaged types.</span></span> <span data-ttu-id="1f22c-136">`unmanaged`Omezení nelze kombinovat s `class` `struct` omezením or.</span><span class="sxs-lookup"><span data-stu-id="1f22c-136">The `unmanaged` constraint can't be combined with the `class` or `struct` constraint.</span></span> <span data-ttu-id="1f22c-137">`unmanaged`Omezení vynutilo, že typ musí být `struct` :</span><span class="sxs-lookup"><span data-stu-id="1f22c-137">The `unmanaged` constraint enforces that the type must be a `struct`:</span></span>

[!code-csharp[using the unmanaged constraint](snippets/GenericWhereConstraints.cs#4)]

<span data-ttu-id="1f22c-138">`where`Klauzule může také zahrnovat omezení konstruktoru `new()` .</span><span class="sxs-lookup"><span data-stu-id="1f22c-138">The `where` clause may also include a constructor constraint, `new()`.</span></span> <span data-ttu-id="1f22c-139">Toto omezení umožňuje vytvořit instanci parametru typu pomocí `new` operátoru.</span><span class="sxs-lookup"><span data-stu-id="1f22c-139">That constraint makes it possible to create an instance of a type parameter using the `new` operator.</span></span> <span data-ttu-id="1f22c-140">[Omezení New ()](new-constraint.md) umožňuje kompilátoru zjistit, že libovolný zadaný argument typu musí mít přístupný konstruktor bez parametrů.</span><span class="sxs-lookup"><span data-stu-id="1f22c-140">The [new() Constraint](new-constraint.md) lets the compiler know that any type argument supplied must have an accessible parameterless constructor.</span></span> <span data-ttu-id="1f22c-141">Příklad:</span><span class="sxs-lookup"><span data-stu-id="1f22c-141">For example:</span></span>

[!code-csharp[using the new constraint](snippets/GenericWhereConstraints.cs#5)]

<span data-ttu-id="1f22c-142">`new()`Omezení se v klauzuli zobrazí jako poslední `where` .</span><span class="sxs-lookup"><span data-stu-id="1f22c-142">The `new()` constraint appears last in the `where` clause.</span></span> <span data-ttu-id="1f22c-143">`new()`Omezení nelze kombinovat s `struct` `unmanaged` omezeními nebo.</span><span class="sxs-lookup"><span data-stu-id="1f22c-143">The `new()` constraint can't be combined with the `struct` or `unmanaged` constraints.</span></span> <span data-ttu-id="1f22c-144">Všechny typy vyhovující těmto omezením musí mít přístupný konstruktor bez parametrů, což omezení je `new()` redundantní.</span><span class="sxs-lookup"><span data-stu-id="1f22c-144">All types satisfying those constraints must have an accessible parameterless constructor, making the `new()` constraint redundant.</span></span>

<span data-ttu-id="1f22c-145">S více parametry typu použijte jednu `where` klauzuli pro každý parametr typu, například:</span><span class="sxs-lookup"><span data-stu-id="1f22c-145">With multiple type parameters, use one `where` clause for each type parameter, for example:</span></span>

[!code-csharp[using multiple where constraints](snippets/GenericWhereConstraints.cs#6)]

<span data-ttu-id="1f22c-146">Omezení můžete také připojit k parametrům typu obecných metod, jak je znázorněno v následujícím příkladu:</span><span class="sxs-lookup"><span data-stu-id="1f22c-146">You can also attach constraints to type parameters of generic methods, as shown in the following example:</span></span>

[!code-csharp[where constraints with generic methods](snippets/GenericWhereConstraints.cs#7)]

<span data-ttu-id="1f22c-147">Všimněte si, že syntaxe pro popis omezení parametrů typu na delegátech je stejná jako u metod:</span><span class="sxs-lookup"><span data-stu-id="1f22c-147">Notice that the syntax to describe type parameter constraints on delegates is the same as that of methods:</span></span>

[!code-csharp[where constraints with generic methods](snippets/GenericWhereConstraints.cs#8)]

<span data-ttu-id="1f22c-148">Informace o obecných delegátech najdete v tématu [Obecné delegáty](../../programming-guide/generics/generic-delegates.md).</span><span class="sxs-lookup"><span data-stu-id="1f22c-148">For information on generic delegates, see [Generic Delegates](../../programming-guide/generics/generic-delegates.md).</span></span>

<span data-ttu-id="1f22c-149">Podrobnosti o syntaxi a použití omezení naleznete v tématu [omezení u parametrů typu](../../programming-guide/generics/constraints-on-type-parameters.md).</span><span class="sxs-lookup"><span data-stu-id="1f22c-149">For details on the syntax and use of constraints, see [Constraints on Type Parameters](../../programming-guide/generics/constraints-on-type-parameters.md).</span></span>

## <a name="c-language-specification"></a><span data-ttu-id="1f22c-150">specifikace jazyka C#</span><span class="sxs-lookup"><span data-stu-id="1f22c-150">C# language specification</span></span>

 [!INCLUDE[CSharplangspec](~/includes/csharplangspec-md.md)]

## <a name="see-also"></a><span data-ttu-id="1f22c-151">Viz také</span><span class="sxs-lookup"><span data-stu-id="1f22c-151">See also</span></span>

- [<span data-ttu-id="1f22c-152">Reference jazyka C#</span><span class="sxs-lookup"><span data-stu-id="1f22c-152">C# Reference</span></span>](../index.md)
- [<span data-ttu-id="1f22c-153">Průvodce programováním v C#</span><span class="sxs-lookup"><span data-stu-id="1f22c-153">C# Programming Guide</span></span>](../../programming-guide/index.md)
- [<span data-ttu-id="1f22c-154">Úvod do obecných typů</span><span class="sxs-lookup"><span data-stu-id="1f22c-154">Introduction to Generics</span></span>](../../programming-guide/generics/index.md)
- [<span data-ttu-id="1f22c-155">nové omezení</span><span class="sxs-lookup"><span data-stu-id="1f22c-155">new Constraint</span></span>](./new-constraint.md)
- [<span data-ttu-id="1f22c-156">Omezení parametrů typů</span><span class="sxs-lookup"><span data-stu-id="1f22c-156">Constraints on Type Parameters</span></span>](../../programming-guide/generics/constraints-on-type-parameters.md)
