---
title: Zápis bezpečného a C# efektivního kódu
description: Nedávná vylepšení C# jazyka umožňují psát ověřitelný bezpečný kód, který byl dříve přidružen k nezabezpečenému kódu.
ms.date: 10/23/2018
ms.technology: csharp-advanced-concepts
ms.custom: mvc
ms.openlocfilehash: f590a338d35966e2cd3a507164057a49b8a5f6f8
ms.sourcegitcommit: 30a558d23e3ac5a52071121a52c305c85fe15726
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 12/25/2019
ms.locfileid: "75346705"
---
# <a name="write-safe-and-efficient-c-code"></a><span data-ttu-id="29b4b-103">Zápis bezpečného a C# efektivního kódu</span><span class="sxs-lookup"><span data-stu-id="29b4b-103">Write safe and efficient C# code</span></span>

<span data-ttu-id="29b4b-104">Nové funkce v C# umožňují psát ověřitelný bezpečný kód s lepším výkonem.</span><span class="sxs-lookup"><span data-stu-id="29b4b-104">New features in C# enable you to write verifiable safe code with better performance.</span></span> <span data-ttu-id="29b4b-105">Pokud tyto techniky pečlivě použijete, bude méně scénářů vyžadovat nezabezpečený kód.</span><span class="sxs-lookup"><span data-stu-id="29b4b-105">If you carefully apply these techniques, fewer scenarios require unsafe code.</span></span> <span data-ttu-id="29b4b-106">Tyto funkce usnadňují použití odkazů na typy hodnot jako argumenty metody a návratové metody.</span><span class="sxs-lookup"><span data-stu-id="29b4b-106">These features make it easier to use references to value types as method arguments and method returns.</span></span> <span data-ttu-id="29b4b-107">Po bezpečném provedení tyto techniky minimalizují kopírování hodnotových typů.</span><span class="sxs-lookup"><span data-stu-id="29b4b-107">When done safely, these techniques minimize copying value types.</span></span> <span data-ttu-id="29b4b-108">Pomocí typů hodnot můžete minimalizovat počet přidělení a průchodů uvolňování paměti.</span><span class="sxs-lookup"><span data-stu-id="29b4b-108">By using value types, you can minimize the number of allocations and garbage collection passes.</span></span>

<span data-ttu-id="29b4b-109">Většina vzorového kódu v tomto článku používá funkce přidané v C# 7,2.</span><span class="sxs-lookup"><span data-stu-id="29b4b-109">Much of the sample code in this article uses features added in C# 7.2.</span></span> <span data-ttu-id="29b4b-110">Chcete-li tyto funkce používat, je nutné nakonfigurovat projekt tak C# , aby používal 7,2 nebo novější.</span><span class="sxs-lookup"><span data-stu-id="29b4b-110">To use those features, you must configure your project to use C# 7.2 or later.</span></span> <span data-ttu-id="29b4b-111">Další informace o nastavení jazykové verze najdete v tématu [Konfigurace jazykové verze](language-reference/configure-language-version.md).</span><span class="sxs-lookup"><span data-stu-id="29b4b-111">For more information on setting the language version, see [configure the language version](language-reference/configure-language-version.md).</span></span>

<span data-ttu-id="29b4b-112">Tento článek se zaměřuje na techniky pro efektivní správu prostředků.</span><span class="sxs-lookup"><span data-stu-id="29b4b-112">This article focuses on techniques for efficient resource management.</span></span> <span data-ttu-id="29b4b-113">Jednou z výhod použití hodnotových typů je, že často brání přidělení haldy.</span><span class="sxs-lookup"><span data-stu-id="29b4b-113">One advantage to using value types is that they often avoid heap allocations.</span></span> <span data-ttu-id="29b4b-114">Nevýhodou je, že se zkopírují podle hodnoty.</span><span class="sxs-lookup"><span data-stu-id="29b4b-114">The disadvantage is that they're copied by value.</span></span> <span data-ttu-id="29b4b-115">Tyto kompromisy usnadňují optimalizaci algoritmů, které pracují s velkými objemy dat.</span><span class="sxs-lookup"><span data-stu-id="29b4b-115">This tradeoff makes it harder to optimize algorithms that operate on large amounts of data.</span></span> <span data-ttu-id="29b4b-116">Nové funkce jazyka v C# 7,2 poskytují mechanismy, které umožňují bezpečný efektivní kód pomocí odkazů na typy hodnot.</span><span class="sxs-lookup"><span data-stu-id="29b4b-116">New language features in C# 7.2 provide mechanisms that enable safe efficient code using references to value types.</span></span> <span data-ttu-id="29b4b-117">Pomocí těchto funkcí můžete minimalizovat operace přidělování i kopírování.</span><span class="sxs-lookup"><span data-stu-id="29b4b-117">Use these features wisely to minimize both allocations and copy operations.</span></span> <span data-ttu-id="29b4b-118">Tento článek popisuje tyto nové funkce.</span><span class="sxs-lookup"><span data-stu-id="29b4b-118">This article explores those new features.</span></span>

<span data-ttu-id="29b4b-119">Tento článek se zaměřuje na následující techniky správy prostředků:</span><span class="sxs-lookup"><span data-stu-id="29b4b-119">This article focuses on the following resource management techniques:</span></span>

- <span data-ttu-id="29b4b-120">Deklarovat [`readonly struct`](language-reference/keywords/readonly.md#readonly-struct-example) pro vyjádření, že typ je **neměnný** a umožňuje kompilátoru ukládat kopie při použití parametrů [`in`](language-reference/keywords/in-parameter-modifier.md) .</span><span class="sxs-lookup"><span data-stu-id="29b4b-120">Declare a [`readonly struct`](language-reference/keywords/readonly.md#readonly-struct-example) to express that a type is **immutable** and enables the compiler to save copies when using [`in`](language-reference/keywords/in-parameter-modifier.md) parameters.</span></span>
- <span data-ttu-id="29b4b-121">Pokud typ nemůže být neměnný, deklarujte `struct` členů `readonly` k označení toho, že člen nemění stav.</span><span class="sxs-lookup"><span data-stu-id="29b4b-121">If a type can't be immutable, declare `struct` members `readonly` to indicate that the member doesn't modify state.</span></span>
- <span data-ttu-id="29b4b-122">Použijte [`ref readonly`](language-reference/keywords/ref.md#reference-return-values) vrátit, pokud je návratová hodnota `struct` větší než <xref:System.IntPtr.Size?displayProperty=nameWithType> a životnost úložiště je větší než metoda, která vrací hodnotu.</span><span class="sxs-lookup"><span data-stu-id="29b4b-122">Use a [`ref readonly`](language-reference/keywords/ref.md#reference-return-values) return when the return value is a `struct` larger than <xref:System.IntPtr.Size?displayProperty=nameWithType> and the storage lifetime is greater than the method returning the value.</span></span>
- <span data-ttu-id="29b4b-123">Pokud je velikost `readonly struct` větší než <xref:System.IntPtr.Size?displayProperty=nameWithType>, měli byste ji předat jako parametr `in` z důvodů výkonu.</span><span class="sxs-lookup"><span data-stu-id="29b4b-123">When the size of a `readonly struct` is bigger than <xref:System.IntPtr.Size?displayProperty=nameWithType>, you should pass it as an `in` parameter for performance reasons.</span></span>
- <span data-ttu-id="29b4b-124">Nikdy nepředávejte `struct` jako parametr `in`, pokud není deklarován s modifikátorem `readonly` nebo metoda volá pouze `readonly` členů struktury.</span><span class="sxs-lookup"><span data-stu-id="29b4b-124">Never pass a `struct` as an `in` parameter unless it's declared with the `readonly` modifier or the method calls only `readonly` members of the struct.</span></span> <span data-ttu-id="29b4b-125">Porušení těchto pokynů může negativně ovlivnit výkon a může vést k zakrytí chování.</span><span class="sxs-lookup"><span data-stu-id="29b4b-125">Violating this guidance may negatively affect performance and could lead to an obscure behavior.</span></span>
- <span data-ttu-id="29b4b-126">Pro práci s pamětí jako posloupnosti bajtů použijte [`ref struct`](language-reference/keywords/ref.md#ref-struct-types)nebo `readonly ref struct`, jako je například <xref:System.Span%601> nebo <xref:System.ReadOnlySpan%601>.</span><span class="sxs-lookup"><span data-stu-id="29b4b-126">Use a [`ref struct`](language-reference/keywords/ref.md#ref-struct-types), or a `readonly ref struct` such as <xref:System.Span%601> or <xref:System.ReadOnlySpan%601> to work with memory as a sequence of bytes.</span></span>

<span data-ttu-id="29b4b-127">Tyto techniky vynutí vyrovnávání dvou konkurenčních cílů s ohledem na **reference** a **hodnoty**.</span><span class="sxs-lookup"><span data-stu-id="29b4b-127">These techniques force you to balance two competing goals with regard to **references** and **values**.</span></span> <span data-ttu-id="29b4b-128">Proměnné, které jsou [odkazové typy](programming-guide/types/index.md#reference-types) , uchovávají odkaz na umístění v paměti.</span><span class="sxs-lookup"><span data-stu-id="29b4b-128">Variables that are [reference types](programming-guide/types/index.md#reference-types) hold a reference to the location in memory.</span></span> <span data-ttu-id="29b4b-129">Proměnné, které jsou [typy hodnot](programming-guide/types/index.md#value-types) přímo obsahují jejich hodnotu.</span><span class="sxs-lookup"><span data-stu-id="29b4b-129">Variables that are [value types](programming-guide/types/index.md#value-types) directly contain their value.</span></span> <span data-ttu-id="29b4b-130">Tyto rozdíly zvýrazňují klíčové rozdíly, které jsou důležité pro správu paměťových prostředků.</span><span class="sxs-lookup"><span data-stu-id="29b4b-130">These differences highlight the key differences that are important for managing memory resources.</span></span> <span data-ttu-id="29b4b-131">**Typy hodnot** jsou obvykle zkopírovány, když jsou předány metodě nebo vráceny z metody.</span><span class="sxs-lookup"><span data-stu-id="29b4b-131">**Value types** are typically copied when passed to a method or returned from a method.</span></span> <span data-ttu-id="29b4b-132">Toto chování zahrnuje kopírování hodnoty `this` při volání členů typu hodnoty.</span><span class="sxs-lookup"><span data-stu-id="29b4b-132">This behavior includes copying the value of `this` when calling members of a value type.</span></span> <span data-ttu-id="29b4b-133">Náklady na kopii se týkají velikosti typu.</span><span class="sxs-lookup"><span data-stu-id="29b4b-133">The cost of the copy is related to the size of the type.</span></span> <span data-ttu-id="29b4b-134">**Typy odkazů** jsou přiděleny na spravovanou haldu.</span><span class="sxs-lookup"><span data-stu-id="29b4b-134">**Reference types** are allocated on the managed heap.</span></span> <span data-ttu-id="29b4b-135">Každý nový objekt vyžaduje nové přidělení a následně musí být uvolněn.</span><span class="sxs-lookup"><span data-stu-id="29b4b-135">Each new object requires a new allocation, and subsequently must be reclaimed.</span></span> <span data-ttu-id="29b4b-136">Obě tyto operace probírají čas.</span><span class="sxs-lookup"><span data-stu-id="29b4b-136">Both these operations take time.</span></span> <span data-ttu-id="29b4b-137">Odkaz je zkopírován, pokud je typ odkazu předán jako argument metodě nebo vrácen z metody.</span><span class="sxs-lookup"><span data-stu-id="29b4b-137">The reference is copied when a reference type is passed as an argument to a method or returned from a method.</span></span>

<span data-ttu-id="29b4b-138">Tento článek používá následující vzorový koncept struktury 3D bodů pro vysvětlení těchto doporučení:</span><span class="sxs-lookup"><span data-stu-id="29b4b-138">This article uses the following example concept of the 3D-point structure to explain these recommendations:</span></span>

```csharp
public struct Point3D
{
    public double X;
    public double Y;
    public double Z;
}
```

<span data-ttu-id="29b4b-139">Různé příklady používají různé implementace tohoto konceptu.</span><span class="sxs-lookup"><span data-stu-id="29b4b-139">Different examples use different implementations of this concept.</span></span>

## <a name="declare-readonly-structs-for-immutable-value-types"></a><span data-ttu-id="29b4b-140">Deklarovat struktury ReadOnly pro neměnné hodnoty typů</span><span class="sxs-lookup"><span data-stu-id="29b4b-140">Declare readonly structs for immutable value types</span></span>

<span data-ttu-id="29b4b-141">Deklarace `struct` pomocí modifikátoru `readonly` informuje kompilátor, že váš záměr je vytvořit neměnný typ.</span><span class="sxs-lookup"><span data-stu-id="29b4b-141">Declaring a `struct` using the `readonly` modifier informs the compiler that your intent is to create an immutable type.</span></span> <span data-ttu-id="29b4b-142">Kompilátor vynutil toto rozhodnutí o návrhu pomocí následujících pravidel:</span><span class="sxs-lookup"><span data-stu-id="29b4b-142">The compiler enforces that design decision with the following rules:</span></span>

- <span data-ttu-id="29b4b-143">Všechny členy polí musí být `readonly`</span><span class="sxs-lookup"><span data-stu-id="29b4b-143">All field members must be `readonly`</span></span>
- <span data-ttu-id="29b4b-144">Všechny vlastnosti musí být jen pro čtení, včetně automaticky implementovaných vlastností.</span><span class="sxs-lookup"><span data-stu-id="29b4b-144">All properties must be read-only, including auto-implemented properties.</span></span>

<span data-ttu-id="29b4b-145">Tato dvě pravidla jsou dostačující, aby se zajistilo, že žádný člen `readonly struct` nemění stav této struktury.</span><span class="sxs-lookup"><span data-stu-id="29b4b-145">These two rules are sufficient to ensure that no member of a `readonly struct` modifies the state of that struct.</span></span> <span data-ttu-id="29b4b-146">`struct` je neměnný.</span><span class="sxs-lookup"><span data-stu-id="29b4b-146">The `struct` is immutable.</span></span> <span data-ttu-id="29b4b-147">`Point3D` struktura může být definována jako neproměnlivá struktura, jak je znázorněno v následujícím příkladu:</span><span class="sxs-lookup"><span data-stu-id="29b4b-147">The `Point3D` structure could be defined as an immutable struct as shown in the following example:</span></span>

```csharp
readonly public struct ReadonlyPoint3D
{
    public ReadonlyPoint3D(double x, double y, double z)
    {
        this.X = x;
        this.Y = y;
        this.Z = z;
    }

    public double X { get; }
    public double Y { get; }
    public double Z { get; }
}
```

<span data-ttu-id="29b4b-148">Toto doporučení použijte vždy, když je záměrem návrhu vytvořit neměnný typ hodnoty.</span><span class="sxs-lookup"><span data-stu-id="29b4b-148">Follow this recommendation whenever your design intent is to create an immutable value type.</span></span> <span data-ttu-id="29b4b-149">Další výhodou je zvýšení výkonu.</span><span class="sxs-lookup"><span data-stu-id="29b4b-149">Any performance improvements are an added benefit.</span></span> <span data-ttu-id="29b4b-150">`readonly struct` jasně vyjadřuje záměr návrhu.</span><span class="sxs-lookup"><span data-stu-id="29b4b-150">The `readonly struct` clearly expresses your design intent.</span></span>

## <a name="declare-readonly-members-when-a-struct-cant-be-immutable"></a><span data-ttu-id="29b4b-151">Deklarovat členy jen pro čtení, pokud struktura nemůže být neměnná</span><span class="sxs-lookup"><span data-stu-id="29b4b-151">Declare readonly members when a struct can't be immutable</span></span>

<span data-ttu-id="29b4b-152">V C# 8,0 a novějších platí, že pokud je typ struktury proměnlivý, měli byste deklarovat členy, které nezpůsobí, že by mutace byly `readonly`.</span><span class="sxs-lookup"><span data-stu-id="29b4b-152">In C# 8.0 and later, when a struct type is mutable, you should declare members that don't cause mutation to be `readonly`.</span></span> <span data-ttu-id="29b4b-153">Například následující je proměnlivá varianta struktury 3D bodů:</span><span class="sxs-lookup"><span data-stu-id="29b4b-153">For example, the following is a mutable variation of the 3D point structure:</span></span>

```csharp
public struct Point3D
{
    public Point3D(double x, double y, double z)
    {
        _x = x;
        _y = y;
        _z = z;
    }

    private double _x;
    public double X
    {
        readonly get => _x;
        set => _x = value;
    }

    private double _y;
    public double Y
    {
        readonly get => _y;
        set => _y = value;
    }

    private double _z;
    public double Z
    {
        readonly get => _z;
        set => _z = value;
    }

    public readonly double Distance => Math.Sqrt(X * X + Y * Y + Z * Z);

    public readonly override string ToString() => $"{X}, {Y}, {Z}";
}
```

<span data-ttu-id="29b4b-154">Předchozí příklad ukazuje mnoho umístění, kde lze použít modifikátor `readonly`: metody, vlastnosti a přistupující objekty vlastností.</span><span class="sxs-lookup"><span data-stu-id="29b4b-154">The preceding sample shows many of the locations where you can apply the `readonly` modifier: methods, properties, and property accessors.</span></span> <span data-ttu-id="29b4b-155">Použijete-li automaticky implementované vlastnosti, kompilátor přidá modifikátor `readonly` k přístupovému objektu `get` pro čtení a zápis vlastností.</span><span class="sxs-lookup"><span data-stu-id="29b4b-155">If you use auto-implemented properties, the compiler adds the `readonly` modifier to the `get` accessor for read-write properties.</span></span> <span data-ttu-id="29b4b-156">Kompilátor přidá modifikátor `readonly` pro automaticky implementované deklarace vlastností pro vlastnosti, které mají pouze přistupující objekt `get`.</span><span class="sxs-lookup"><span data-stu-id="29b4b-156">The compiler adds the `readonly` modifier to the auto-implemented property declarations for properties with only a `get` accessor.</span></span>

<span data-ttu-id="29b4b-157">Přidání modifikátoru `readonly` do členů, kteří nepoužívají stav, poskytuje dvě související výhody.</span><span class="sxs-lookup"><span data-stu-id="29b4b-157">Adding the `readonly` modifier to members that don't mutate state provides two related benefits.</span></span> <span data-ttu-id="29b4b-158">Za prvé vynutil kompilátor váš záměr.</span><span class="sxs-lookup"><span data-stu-id="29b4b-158">First, the compiler enforces your intent.</span></span> <span data-ttu-id="29b4b-159">Tento člen nemůže být součástí stavu struktury, ani nemůže přistupovat ke členu, který není označen také jako `readonly`.</span><span class="sxs-lookup"><span data-stu-id="29b4b-159">That member can't mutate the struct's state, nor can it access a member that isn't also marked `readonly`.</span></span> <span data-ttu-id="29b4b-160">Za druhé kompilátor při přístupu ke členu `readonly` nevytvoří obrannou linií kopie parametrů `in`.</span><span class="sxs-lookup"><span data-stu-id="29b4b-160">Second, the compiler won't create defensive copies of `in` parameters when accessing a `readonly` member.</span></span> <span data-ttu-id="29b4b-161">Kompilátor může tuto optimalizaci bezpečně provést, protože zaručuje, že `readonly` člen nemění `struct`.</span><span class="sxs-lookup"><span data-stu-id="29b4b-161">The compiler can make this optimization safely because it guarantees that the `struct` is not modified by a `readonly` member.</span></span>

## <a name="use-ref-readonly-return-statements-for-large-structures-when-possible"></a><span data-ttu-id="29b4b-162">Pokud je to možné, používejte příkazy `ref readonly return` pro velké struktury.</span><span class="sxs-lookup"><span data-stu-id="29b4b-162">Use `ref readonly return` statements for large structures when possible</span></span>

<span data-ttu-id="29b4b-163">Hodnoty můžete vrátit odkazem, pokud hodnota vracená není lokální vůči návratové metodě.</span><span class="sxs-lookup"><span data-stu-id="29b4b-163">You can return values by reference when the value being returned isn't local to the returning method.</span></span> <span data-ttu-id="29b4b-164">Vrácení odkazem znamená, že je zkopírován pouze odkaz, nikoli struktura.</span><span class="sxs-lookup"><span data-stu-id="29b4b-164">Returning by reference means that only the reference is copied, not the structure.</span></span> <span data-ttu-id="29b4b-165">V následujícím příkladu vlastnost `Origin` nemůže použít `ref` vrácení, protože vrácená hodnota je místní proměnná:</span><span class="sxs-lookup"><span data-stu-id="29b4b-165">In the following example, the `Origin` property can't use a `ref` return because the value being returned is a local variable:</span></span>

```csharp
public Point3D Origin => new Point3D(0,0,0);
```

<span data-ttu-id="29b4b-166">Následující definici vlastnosti však lze vrátit odkazem, protože vrácená hodnota je statický člen:</span><span class="sxs-lookup"><span data-stu-id="29b4b-166">However, the following property definition can be returned by reference because the returned value is a static member:</span></span>

```csharp
public struct Point3D
{
    private static Point3D origin = new Point3D(0,0,0);

    // Dangerous! returning a mutable reference to internal storage
    public ref Point3D Origin => ref origin;

    // other members removed for space
}
```

<span data-ttu-id="29b4b-167">Nechcete, aby volající měnili počátek, takže byste měli vrátit hodnotu `ref readonly`:</span><span class="sxs-lookup"><span data-stu-id="29b4b-167">You don't want callers modifying the origin, so you should return the value by `ref readonly`:</span></span>

```csharp
public struct Point3D
{
    private static Point3D origin = new Point3D(0,0,0);

    public static ref readonly Point3D Origin => ref origin;

    // other members removed for space
}
```

<span data-ttu-id="29b4b-168">Vrácení `ref readonly` umožňuje uložit kopírování větších struktur a zachovat neměnnosti vašich interních datových členů.</span><span class="sxs-lookup"><span data-stu-id="29b4b-168">Returning `ref readonly` enables you to save copying larger structures and preserve the immutability of your internal data members.</span></span>

<span data-ttu-id="29b4b-169">Na webu volání využije volající možnost použít vlastnost `Origin` jako `ref readonly` nebo jako hodnotu:</span><span class="sxs-lookup"><span data-stu-id="29b4b-169">At the call site, callers make the choice to use the `Origin` property as a `ref readonly` or as a value:</span></span>

[!code-csharp[AssignRefReadonly](../../samples/csharp/safe-efficient-code/ref-readonly-struct/Program.cs#AssignRefReadonly "Assigning a ref readonly")]

<span data-ttu-id="29b4b-170">První přiřazení v předchozím kódu vytvoří kopii `Origin` konstanty a přiřadí tuto kopii.</span><span class="sxs-lookup"><span data-stu-id="29b4b-170">The first assignment in the preceding code makes a copy of the `Origin` constant and assigns that copy.</span></span> <span data-ttu-id="29b4b-171">Druhý přiřadí odkaz.</span><span class="sxs-lookup"><span data-stu-id="29b4b-171">The second assigns a reference.</span></span> <span data-ttu-id="29b4b-172">Všimněte si, že modifikátor `readonly` musí být součástí deklarace proměnné.</span><span class="sxs-lookup"><span data-stu-id="29b4b-172">Notice that the `readonly` modifier must be part of the declaration of the variable.</span></span> <span data-ttu-id="29b4b-173">Odkaz, na který se odkazuje, se nedá změnit.</span><span class="sxs-lookup"><span data-stu-id="29b4b-173">The reference to which it refers can't be modified.</span></span> <span data-ttu-id="29b4b-174">Pokusí se to provést za účelem chyby při kompilaci.</span><span class="sxs-lookup"><span data-stu-id="29b4b-174">Attempts to do so result in a compile-time error.</span></span>

<span data-ttu-id="29b4b-175">V deklaraci `originReference`je vyžadován modifikátor `readonly`.</span><span class="sxs-lookup"><span data-stu-id="29b4b-175">The `readonly` modifier is required on the declaration of `originReference`.</span></span>

<span data-ttu-id="29b4b-176">Kompilátor vynutil, že volající nemůže upravit odkaz.</span><span class="sxs-lookup"><span data-stu-id="29b4b-176">The compiler enforces that the caller can't modify the reference.</span></span> <span data-ttu-id="29b4b-177">Pokusí se přiřadit hodnotu přímo generovat chybu při kompilaci.</span><span class="sxs-lookup"><span data-stu-id="29b4b-177">Attempts to assign the value directly generate a compile-time error.</span></span> <span data-ttu-id="29b4b-178">Kompilátor však nemůže zjistit, zda jakákoli metoda člena mění stav struktury.</span><span class="sxs-lookup"><span data-stu-id="29b4b-178">However, the compiler can't know if any member method modifies the state of the struct.</span></span>
<span data-ttu-id="29b4b-179">Aby se zajistilo, že se objekt nezměnil, kompilátor vytvoří kopii a zavolá odkazy členů pomocí této kopie.</span><span class="sxs-lookup"><span data-stu-id="29b4b-179">To ensure that the object isn't modified, the compiler creates a copy and calls member references using that copy.</span></span> <span data-ttu-id="29b4b-180">Jakékoli úpravy této obrannou linií kopie.</span><span class="sxs-lookup"><span data-stu-id="29b4b-180">Any modifications are to that defensive copy.</span></span>

## <a name="apply-the-in-modifier-to-readonly-struct-parameters-larger-than-systemintptrsize"></a><span data-ttu-id="29b4b-181">Použijte modifikátor `in` pro `readonly struct` parametrů větších než `System.IntPtr.Size`</span><span class="sxs-lookup"><span data-stu-id="29b4b-181">Apply the `in` modifier to `readonly struct` parameters larger than `System.IntPtr.Size`</span></span>

<span data-ttu-id="29b4b-182">Klíčové slovo `in` doplňuje existující `ref` a `out` klíčová slova, aby předávala argumenty odkazem.</span><span class="sxs-lookup"><span data-stu-id="29b4b-182">The `in` keyword complements the existing `ref` and `out` keywords to pass arguments by reference.</span></span> <span data-ttu-id="29b4b-183">Klíčové slovo `in` určuje předání argumentu odkazem, ale volaná metoda neupravuje hodnotu.</span><span class="sxs-lookup"><span data-stu-id="29b4b-183">The `in` keyword specifies passing the argument by reference, but the called method doesn't modify the value.</span></span>

<span data-ttu-id="29b4b-184">Tento doplněk poskytuje úplný slovník pro vyjádření záměru návrhu.</span><span class="sxs-lookup"><span data-stu-id="29b4b-184">This addition provides a full vocabulary to express your design intent.</span></span>
<span data-ttu-id="29b4b-185">Typy hodnot jsou zkopírovány při předání do volané metody, pokud nezadáte žádné z následujících modifikátorů v signatuře metody.</span><span class="sxs-lookup"><span data-stu-id="29b4b-185">Value types are copied when passed to a called method when you don't specify any of the following modifiers in the method signature.</span></span> <span data-ttu-id="29b4b-186">Každý z těchto modifikátorů určuje, že proměnná je předána odkazem, který vyloučí kopii.</span><span class="sxs-lookup"><span data-stu-id="29b4b-186">Each of these modifiers specifies that a variable is passed by reference, avoiding the copy.</span></span> <span data-ttu-id="29b4b-187">Každý modifikátor vyjadřuje jiný záměr:</span><span class="sxs-lookup"><span data-stu-id="29b4b-187">Each modifier expresses a different intent:</span></span>

- <span data-ttu-id="29b4b-188">`out`: Tato metoda nastaví hodnotu argumentu použitého jako tento parametr.</span><span class="sxs-lookup"><span data-stu-id="29b4b-188">`out`: This method sets the value of the argument used as this parameter.</span></span>
- <span data-ttu-id="29b4b-189">`ref`: Tato metoda může nastavit hodnotu argumentu použitého jako tento parametr.</span><span class="sxs-lookup"><span data-stu-id="29b4b-189">`ref`: This method may set the value of the argument used as this parameter.</span></span>
- <span data-ttu-id="29b4b-190">`in`: Tato metoda neupravuje hodnotu argumentu použitého jako tento parametr.</span><span class="sxs-lookup"><span data-stu-id="29b4b-190">`in`: This method doesn't modify the value of the argument used as this parameter.</span></span>

<span data-ttu-id="29b4b-191">Přidejte modifikátor `in`, který předává argument odkazem a deklaruje záměr návrhu k předání argumentů odkazem, aby nedocházelo k zbytečnému kopírování.</span><span class="sxs-lookup"><span data-stu-id="29b4b-191">Add the `in` modifier to pass an argument by reference and declare your design intent to pass arguments by reference to avoid unnecessary copying.</span></span> <span data-ttu-id="29b4b-192">Nebudete mít v úmyslu upravovat objekt použitý jako argument.</span><span class="sxs-lookup"><span data-stu-id="29b4b-192">You don't intend to modify the object used as that argument.</span></span>

<span data-ttu-id="29b4b-193">Tento postup často vylepšuje výkon pro typy hodnot ReadOnly, které jsou větší než <xref:System.IntPtr.Size?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="29b4b-193">This practice often improves performance for readonly value types that are larger than <xref:System.IntPtr.Size?displayProperty=nameWithType>.</span></span> <span data-ttu-id="29b4b-194">U jednoduchých typů (`sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, `double`, `decimal` a `bool`a `enum`ch typů) jsou všechny potenciální nárůsty výkonu minimální.</span><span class="sxs-lookup"><span data-stu-id="29b4b-194">For simple types (`sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, `double`, `decimal` and `bool`, and `enum` types), any potential performance gains are minimal.</span></span> <span data-ttu-id="29b4b-195">Ve skutečnosti se výkon může snížit pomocí předávacího odkazu pro typy menší než <xref:System.IntPtr.Size?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="29b4b-195">In fact, performance may degrade by using pass-by-reference for types smaller than <xref:System.IntPtr.Size?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="29b4b-196">Následující kód ukazuje příklad metody, která vypočítá vzdálenost mezi dvěma body v 3D prostoru.</span><span class="sxs-lookup"><span data-stu-id="29b4b-196">The following code shows an example of a method that calculates the distance between two points in 3D space.</span></span>

[!code-csharp[InArgument](../../samples/csharp/safe-efficient-code/ref-readonly-struct/Program.cs#InArgument "Specifying an in argument")]

<span data-ttu-id="29b4b-197">Argumenty jsou dvě struktury, které obsahují tři dvojité.</span><span class="sxs-lookup"><span data-stu-id="29b4b-197">The arguments are two structures that each contain three doubles.</span></span> <span data-ttu-id="29b4b-198">Dvojitá přesnost je 8 bajtů, takže každý argument je 24 bajtů.</span><span class="sxs-lookup"><span data-stu-id="29b4b-198">A double is 8 bytes, so each argument is 24 bytes.</span></span> <span data-ttu-id="29b4b-199">Zadáním modifikátoru `in` předáte do těchto argumentů odkaz na 4 bajty nebo 8 bajtů v závislosti na architektuře počítače.</span><span class="sxs-lookup"><span data-stu-id="29b4b-199">By specifying the `in` modifier, you pass a 4 byte or 8-byte reference to those arguments, depending on the architecture of the machine.</span></span> <span data-ttu-id="29b4b-200">Rozdíl velikosti je malý, ale přidává se, když vaše aplikace volá tuto metodu v těsné smyčce pomocí řady různých hodnot.</span><span class="sxs-lookup"><span data-stu-id="29b4b-200">The difference in size is small, but it adds up when your application calls this method in a tight loop using many different values.</span></span>

<span data-ttu-id="29b4b-201">Modifikátor `in` doplňuje `out` a `ref` jiným způsobem.</span><span class="sxs-lookup"><span data-stu-id="29b4b-201">The `in` modifier complements `out` and `ref` in other ways as well.</span></span> <span data-ttu-id="29b4b-202">Nelze vytvořit přetížení metody, která se liší pouze v přítomnosti `in`, `out`nebo `ref`.</span><span class="sxs-lookup"><span data-stu-id="29b4b-202">You can't create overloads of a method that differ only in the presence of `in`, `out`, or `ref`.</span></span> <span data-ttu-id="29b4b-203">Tato nová pravidla rozšíří stejné chování, které bylo vždy definováno pro parametry `out` a `ref`.</span><span class="sxs-lookup"><span data-stu-id="29b4b-203">These new rules extend the same behavior that had always been defined for `out` and `ref` parameters.</span></span> <span data-ttu-id="29b4b-204">Podobně jako modifikátory `out` a `ref` nejsou typy hodnot zabalené, protože je použit modifikátor `in`.</span><span class="sxs-lookup"><span data-stu-id="29b4b-204">Like the `out` and `ref` modifiers, value types aren't boxed because the `in` modifier is applied.</span></span>

<span data-ttu-id="29b4b-205">Modifikátor `in` lze použít pro libovolného člena, který přebírá parametry: metody, delegáty, výrazy lambda, místní funkce, indexery, operátory.</span><span class="sxs-lookup"><span data-stu-id="29b4b-205">The `in` modifier may be applied to any member that takes parameters: methods, delegates, lambdas, local functions, indexers, operators.</span></span>

<span data-ttu-id="29b4b-206">Další funkcí `in` parametrů je, že pro argument `in` parametr můžete použít literálové hodnoty nebo konstanty.</span><span class="sxs-lookup"><span data-stu-id="29b4b-206">Another feature of `in` parameters is that you may use literal values or constants for the argument to an `in` parameter.</span></span> <span data-ttu-id="29b4b-207">Navíc na rozdíl od `ref` nebo `out` parametr není nutné použít modifikátor `in` na webu volání.</span><span class="sxs-lookup"><span data-stu-id="29b4b-207">Also, unlike a `ref` or `out` parameter, you don't need to apply the `in` modifier at the call site.</span></span> <span data-ttu-id="29b4b-208">Následující kód ukazuje dva příklady volání metody `CalculateDistance`.</span><span class="sxs-lookup"><span data-stu-id="29b4b-208">The following code shows you two examples of calling the `CalculateDistance` method.</span></span> <span data-ttu-id="29b4b-209">První používá dvě místní proměnné předané odkazem.</span><span class="sxs-lookup"><span data-stu-id="29b4b-209">The first uses two local variables passed by reference.</span></span> <span data-ttu-id="29b4b-210">Druhý zahrnuje dočasnou proměnnou vytvořenou jako součást volání metody.</span><span class="sxs-lookup"><span data-stu-id="29b4b-210">The second includes a temporary variable created as part of the method call.</span></span>

[!code-csharp[UseInArgument](../../samples/csharp/safe-efficient-code/ref-readonly-struct/Program.cs#UseInArgument "Specifying an In argument")]

<span data-ttu-id="29b4b-211">Existuje několik způsobů, jak kompilátor vynutil charakter `in` argument jen pro čtení.</span><span class="sxs-lookup"><span data-stu-id="29b4b-211">There are several ways in which the compiler enforces the read-only nature of an `in` argument.</span></span>  <span data-ttu-id="29b4b-212">První z nich volaná metoda se nemůže přímo přiřadit k parametru `in`.</span><span class="sxs-lookup"><span data-stu-id="29b4b-212">First of all, the called method can't directly assign to an `in` parameter.</span></span> <span data-ttu-id="29b4b-213">Nelze ji přímo přiřadit k žádnému poli `in` parametr, pokud je tato hodnota typu `struct`.</span><span class="sxs-lookup"><span data-stu-id="29b4b-213">It can't directly assign to any field of an `in` parameter when that value is a `struct` type.</span></span> <span data-ttu-id="29b4b-214">Kromě toho nemůžete předat parametr `in` žádné metodě pomocí modifikátoru `ref` nebo `out`.</span><span class="sxs-lookup"><span data-stu-id="29b4b-214">In addition, you can't pass an `in` parameter to any method using the `ref` or `out` modifier.</span></span>
<span data-ttu-id="29b4b-215">Tato pravidla platí pro každé pole parametru `in`, pokud je pole typem `struct` a parametr je také `struct` typ.</span><span class="sxs-lookup"><span data-stu-id="29b4b-215">These rules apply to any field of an `in` parameter, provided the field is a `struct` type and the parameter is also a `struct` type.</span></span> <span data-ttu-id="29b4b-216">Ve skutečnosti platí, že tato pravidla se použijí pro přístup k více vrstvám členů, přičemž typy na všech úrovních přístupu členů jsou `structs`.</span><span class="sxs-lookup"><span data-stu-id="29b4b-216">In fact, these rules apply for multiple layers of member access provided the types at all levels of member access are `structs`.</span></span>
<span data-ttu-id="29b4b-217">Kompilátor vynutil, že `struct` typy předávané jako `in` argumenty a jejich `struct` členové jsou proměnné jen pro čtení, pokud se používají jako argumenty pro jiné metody.</span><span class="sxs-lookup"><span data-stu-id="29b4b-217">The compiler enforces that `struct` types passed as  `in` arguments and their `struct` members are read-only variables when used as arguments to other methods.</span></span>

<span data-ttu-id="29b4b-218">Použití parametrů `in` se může vyhnout potenciálním nákladům na výkon při vytváření kopií.</span><span class="sxs-lookup"><span data-stu-id="29b4b-218">The use of `in` parameters can avoid the potential performance costs of making copies.</span></span> <span data-ttu-id="29b4b-219">Nemění sémantiku žádného volání metody.</span><span class="sxs-lookup"><span data-stu-id="29b4b-219">It doesn't change the semantics of any method call.</span></span> <span data-ttu-id="29b4b-220">Proto není nutné zadávat modifikátor `in` na webu volání.</span><span class="sxs-lookup"><span data-stu-id="29b4b-220">Therefore, you don't need to specify the `in` modifier at the call site.</span></span> <span data-ttu-id="29b4b-221">Vynechání modifikátoru `in` na webu volání informuje kompilátor, že je povoleno vytvořit kopii argumentu z následujících důvodů:</span><span class="sxs-lookup"><span data-stu-id="29b4b-221">Omitting the `in` modifier at the call site informs the compiler that it's allowed to make a copy of the argument for the following reasons:</span></span>

- <span data-ttu-id="29b4b-222">Existuje implicitní převod, ale nikoli převod identity z typu argumentu na typ parametru.</span><span class="sxs-lookup"><span data-stu-id="29b4b-222">There exists an implicit conversion but not an identity conversion from the argument type to the parameter type.</span></span>
- <span data-ttu-id="29b4b-223">Argument je výraz, ale nemá známou proměnnou úložiště.</span><span class="sxs-lookup"><span data-stu-id="29b4b-223">The argument is an expression but doesn't have a known storage variable.</span></span>
- <span data-ttu-id="29b4b-224">Existuje přetížení, které se liší podle přítomnosti nebo nepřítomnosti `in`.</span><span class="sxs-lookup"><span data-stu-id="29b4b-224">An overload exists that differs by the presence or absence of `in`.</span></span> <span data-ttu-id="29b4b-225">V takovém případě je přetížení podle hodnot lepší shodu.</span><span class="sxs-lookup"><span data-stu-id="29b4b-225">In that case, the by value overload is a better match.</span></span>

<span data-ttu-id="29b4b-226">Tato pravidla jsou užitečná, když aktualizujete existující kód tak, aby používal argumenty odkazu jen pro čtení.</span><span class="sxs-lookup"><span data-stu-id="29b4b-226">These rules are useful as you update existing code to use read-only reference arguments.</span></span> <span data-ttu-id="29b4b-227">Uvnitř volané metody můžete zavolat libovolnou metodu instance, která používá parametry hodnot.</span><span class="sxs-lookup"><span data-stu-id="29b4b-227">Inside the called method, you can call any instance method that uses by value parameters.</span></span> <span data-ttu-id="29b4b-228">V těchto případech je vytvořena kopie parametru `in`.</span><span class="sxs-lookup"><span data-stu-id="29b4b-228">In those instances, a copy of the `in` parameter is created.</span></span> <span data-ttu-id="29b4b-229">Vzhledem k tomu, že kompilátor může vytvořit dočasnou proměnnou pro libovolný parametr `in`, můžete také zadat výchozí hodnoty pro libovolný parametr `in`.</span><span class="sxs-lookup"><span data-stu-id="29b4b-229">Because the compiler may create a temporary variable for any `in` parameter, you can also specify default values for any `in` parameter.</span></span> <span data-ttu-id="29b4b-230">Následující kód určuje počátek (bod 0, 0) jako výchozí hodnotu pro druhý bod:</span><span class="sxs-lookup"><span data-stu-id="29b4b-230">The following code specifies the origin (point 0,0) as the default value for the second point:</span></span>

[!code-csharp[InArgumentDefault](../../samples/csharp/safe-efficient-code/ref-readonly-struct/Program.cs#InArgumentDefault "Specifying defaults for an in parameter")]

<span data-ttu-id="29b4b-231">Chcete-li vynutit, aby kompilátor předal argumenty jen pro čtení odkazem, určete `in` modifikátor u argumentů na webu volání, jak je znázorněno v následujícím kódu:</span><span class="sxs-lookup"><span data-stu-id="29b4b-231">To force the compiler to pass read-only arguments by reference, specify the `in` modifier on the arguments at the call site, as shown in the following code:</span></span>

[!code-csharp[UseInArgument](../../samples/csharp/safe-efficient-code/ref-readonly-struct/Program.cs#ExplicitInArgument "Specifying an In argument")]

<span data-ttu-id="29b4b-232">Toto chování usnadňuje přijímání parametrů `in` v průběhu času v rozsáhlých základech kódu, kde je možné nárůst výkonu.</span><span class="sxs-lookup"><span data-stu-id="29b4b-232">This behavior makes it easier to adopt `in` parameters over time in large codebases where performance gains are possible.</span></span> <span data-ttu-id="29b4b-233">Nejprve přidáte modifikátor `in` k podpisům metod.</span><span class="sxs-lookup"><span data-stu-id="29b4b-233">You add the `in` modifier to method signatures first.</span></span> <span data-ttu-id="29b4b-234">Pak můžete přidat modifikátor `in` na webech volání a vytvořit `readonly struct` typy a povolit tak kompilátoru, aby se zabránilo vytváření obrannou linií kopií parametrů `in` ve více umístěních.</span><span class="sxs-lookup"><span data-stu-id="29b4b-234">Then, you can add the `in` modifier at call sites and create `readonly struct` types to enable the compiler to avoid creating defensive copies of `in` parameters in more locations.</span></span>

<span data-ttu-id="29b4b-235">Označení parametru `in` lze také použít s odkazovým typem nebo číselnými hodnotami.</span><span class="sxs-lookup"><span data-stu-id="29b4b-235">The `in` parameter designation can also be used with reference types or numeric values.</span></span> <span data-ttu-id="29b4b-236">Výhody v obou případech jsou však minimální, pokud existují.</span><span class="sxs-lookup"><span data-stu-id="29b4b-236">However, the benefits in both cases are minimal, if any.</span></span>

## <a name="never-use-mutable-structs-as-in-in-argument"></a><span data-ttu-id="29b4b-237">Nikdy nepoužívejte proměnlivé struktury jako v argumentu `in`</span><span class="sxs-lookup"><span data-stu-id="29b4b-237">Never use mutable structs as in `in` argument</span></span>

<span data-ttu-id="29b4b-238">Výše popsané techniky vysvětlují, jak se vyhnout kopiím vrácením odkazů a předáním hodnot odkazem.</span><span class="sxs-lookup"><span data-stu-id="29b4b-238">The techniques described above explain how to avoid copies by returning references and passing values by reference.</span></span> <span data-ttu-id="29b4b-239">Tyto techniky fungují nejlépe, pokud jsou typy argumentů deklarovány jako `readonly struct` typy.</span><span class="sxs-lookup"><span data-stu-id="29b4b-239">These techniques work best when the argument types are declared as `readonly struct` types.</span></span> <span data-ttu-id="29b4b-240">V opačném případě kompilátor musí vytvořit **obrannou linií kopie** v mnoha situacích, aby se vynutila vlastnost ReadOnly-Ness všech argumentů.</span><span class="sxs-lookup"><span data-stu-id="29b4b-240">Otherwise, the compiler must create **defensive copies** in many situations to enforce the readonly-ness of any arguments.</span></span> <span data-ttu-id="29b4b-241">Vezměte v úvahu následující příklad, který vypočítá vzdálenost prostorového bodu od počátku:</span><span class="sxs-lookup"><span data-stu-id="29b4b-241">Consider the following example that calculates the distance of a 3D point from the origin:</span></span>

[!code-csharp[InArgument](../../samples/csharp/safe-efficient-code/ref-readonly-struct/Program.cs#InArgument "Specifying an in argument")]

<span data-ttu-id="29b4b-242">Struktura *`Point3D` není struktura* jen pro čtení.</span><span class="sxs-lookup"><span data-stu-id="29b4b-242">The `Point3D` structure is *not* a readonly struct.</span></span> <span data-ttu-id="29b4b-243">V těle této metody je k dispozici šest různých volání přístupu k vlastnostem.</span><span class="sxs-lookup"><span data-stu-id="29b4b-243">There are six different property access calls in the body of this method.</span></span> <span data-ttu-id="29b4b-244">Při prvním zkoumání jste si možná mysleli, že tyto přístupy byly bezpečné.</span><span class="sxs-lookup"><span data-stu-id="29b4b-244">On first examination, you may have thought these accesses were safe.</span></span> <span data-ttu-id="29b4b-245">Po všech případech přistupující objekt `get` by neměl upravovat stav objektu.</span><span class="sxs-lookup"><span data-stu-id="29b4b-245">After all, a `get` accessor shouldn't modify the state of the object.</span></span> <span data-ttu-id="29b4b-246">Nejedná se ale o žádné jazykové pravidlo, které to vynutilo.</span><span class="sxs-lookup"><span data-stu-id="29b4b-246">But there's no language rule that enforces that.</span></span> <span data-ttu-id="29b4b-247">Je to jenom běžná konvence.</span><span class="sxs-lookup"><span data-stu-id="29b4b-247">It's only a common convention.</span></span> <span data-ttu-id="29b4b-248">Libovolný typ může implementovat přistupující objekt `get`, který změnil vnitřní stav.</span><span class="sxs-lookup"><span data-stu-id="29b4b-248">Any type could implement a `get` accessor that modified the internal state.</span></span> <span data-ttu-id="29b4b-249">Bez záruky jazyka musí kompilátor vytvořit dočasnou kopii argumentu před voláním libovolného člena.</span><span class="sxs-lookup"><span data-stu-id="29b4b-249">Without some language guarantee, the compiler must create a temporary copy of the argument before calling any member.</span></span> <span data-ttu-id="29b4b-250">Dočasné úložiště je vytvořeno v zásobníku, hodnoty argumentu jsou zkopírovány do dočasného úložiště a hodnota je zkopírována do zásobníku pro každý přístup člena jako argument `this`.</span><span class="sxs-lookup"><span data-stu-id="29b4b-250">The temporary storage is created on the stack, the values of the argument are copied to the temporary storage, and the value is copied to the stack for each member access as the `this` argument.</span></span> <span data-ttu-id="29b4b-251">V mnoha situacích tyto kopie poškozují výkon, takže pokud typ argumentu není `readonly struct`, je průchozí hodnota rychlejší než odkaz Pass-by-ReadOnly.</span><span class="sxs-lookup"><span data-stu-id="29b4b-251">In many situations, these copies harm performance enough that pass-by-value is faster than pass-by-readonly-reference when the argument type isn't a `readonly struct`.</span></span>

<span data-ttu-id="29b4b-252">Místo toho, pokud výpočet vzdálenosti používá neproměnlivou strukturu `ReadonlyPoint3D`, dočasné objekty nejsou potřeba:</span><span class="sxs-lookup"><span data-stu-id="29b4b-252">Instead, if the distance calculation uses the immutable struct, `ReadonlyPoint3D`, temporary objects aren't needed:</span></span>

[!code-csharp[readonlyInArgument](../../samples/csharp/safe-efficient-code/ref-readonly-struct/Program.cs#ReadOnlyInArgument "Specifying a readonly in argument")]

<span data-ttu-id="29b4b-253">Kompilátor generuje efektivnější kód při volání členů `readonly struct`: `this` odkaz namísto kopie příjemce je vždy parametr `in` předaný odkazem na metodu člena.</span><span class="sxs-lookup"><span data-stu-id="29b4b-253">The compiler generates more efficient code when you call members of a `readonly struct`: The `this` reference, instead of a copy of the receiver, is always an `in` parameter passed by reference to the member method.</span></span> <span data-ttu-id="29b4b-254">Tato optimalizace ukládá kopírování při použití `readonly struct` jako argumentu `in`.</span><span class="sxs-lookup"><span data-stu-id="29b4b-254">This optimization saves copying when you use a `readonly struct` as an `in` argument.</span></span>

<span data-ttu-id="29b4b-255">Nemůžete předat typ hodnoty s možnou hodnotou null jako argument `in`.</span><span class="sxs-lookup"><span data-stu-id="29b4b-255">You shouldn't pass a nullable value type as an `in` argument.</span></span> <span data-ttu-id="29b4b-256">Typ <xref:System.Nullable%601> není deklarován jako struktura jen pro čtení.</span><span class="sxs-lookup"><span data-stu-id="29b4b-256">The <xref:System.Nullable%601> type isn't declared as a read-only struct.</span></span> <span data-ttu-id="29b4b-257">To znamená, že kompilátor musí generovat obrannou linií kopie pro libovolný argument typu hodnoty s možnou hodnotou null předaný metodě pomocí modifikátoru `in` v deklaraci parametru.</span><span class="sxs-lookup"><span data-stu-id="29b4b-257">That means the compiler must generate defensive copies for any nullable value type argument passed to a method using the `in` modifier on the parameter declaration.</span></span>

<span data-ttu-id="29b4b-258">Můžete si prohlédnout ukázkový program, který ukazuje rozdíly v výkonu pomocí [BenchmarkDotNet](https://www.nuget.org/packages/BenchmarkDotNet/) v našem [úložišti ukázek](https://github.com/dotnet/samples/tree/master/csharp/safe-efficient-code/benchmark) na GitHubu.</span><span class="sxs-lookup"><span data-stu-id="29b4b-258">You can see an example program that demonstrates the performance differences using [BenchmarkDotNet](https://www.nuget.org/packages/BenchmarkDotNet/) in our [samples repository](https://github.com/dotnet/samples/tree/master/csharp/safe-efficient-code/benchmark) on GitHub.</span></span> <span data-ttu-id="29b4b-259">Porovná předání proměnlivé struktury podle hodnoty a odkazu s předáním neměnné struktury podle hodnoty a odkazu.</span><span class="sxs-lookup"><span data-stu-id="29b4b-259">It compares passing a mutable struct by value and by reference with passing an immutable struct by value and by reference.</span></span> <span data-ttu-id="29b4b-260">Použití neproměnlivé struktury a předávání odkazem je nejrychlejší.</span><span class="sxs-lookup"><span data-stu-id="29b4b-260">The use of the immutable struct and pass by reference is fastest.</span></span>

## <a name="use-ref-struct-types-to-work-with-blocks-or-memory-on-a-single-stack-frame"></a><span data-ttu-id="29b4b-261">Použití typů `ref struct` pro práci s bloky nebo pamětí v jednom bloku zásobníku</span><span class="sxs-lookup"><span data-stu-id="29b4b-261">Use `ref struct` types to work with blocks or memory on a single stack frame</span></span>

<span data-ttu-id="29b4b-262">Související funkce jazyka je schopnost deklarovat typ hodnoty, který musí být omezen na jeden rámec zásobníku.</span><span class="sxs-lookup"><span data-stu-id="29b4b-262">A related language feature is the ability to declare a value type that must be constrained to a single stack frame.</span></span> <span data-ttu-id="29b4b-263">Toto omezení umožňuje kompilátoru provést několik optimalizací.</span><span class="sxs-lookup"><span data-stu-id="29b4b-263">This restriction enables the compiler to make several optimizations.</span></span> <span data-ttu-id="29b4b-264">Primární motivace pro tuto funkci byla <xref:System.Span%601> a související struktury.</span><span class="sxs-lookup"><span data-stu-id="29b4b-264">The primary motivation for this feature was <xref:System.Span%601> and related structures.</span></span> <span data-ttu-id="29b4b-265">Zvýšení výkonu z těchto vylepšení dosáhnete pomocí nových a aktualizovaných rozhraní API .NET, která využívají <xref:System.Span%601>ho typu.</span><span class="sxs-lookup"><span data-stu-id="29b4b-265">You'll achieve performance improvements from these enhancements by using new and updated .NET APIs that make use of the <xref:System.Span%601> type.</span></span>

<span data-ttu-id="29b4b-266">Můžete mít podobné požadavky na práci s pamětí vytvořenou pomocí [`stackalloc`](language-reference/operators/stackalloc.md) nebo při použití paměti z rozhraní API pro interoperabilitu.</span><span class="sxs-lookup"><span data-stu-id="29b4b-266">You may have similar requirements working with memory created using [`stackalloc`](language-reference/operators/stackalloc.md) or when using memory from interop APIs.</span></span> <span data-ttu-id="29b4b-267">Pro tyto potřeby můžete definovat vlastní typy `ref struct`.</span><span class="sxs-lookup"><span data-stu-id="29b4b-267">You can define your own `ref struct` types for those needs.</span></span>

## <a name="readonly-ref-struct-type"></a><span data-ttu-id="29b4b-268">Typ `readonly ref struct`</span><span class="sxs-lookup"><span data-stu-id="29b4b-268">`readonly ref struct` type</span></span>

<span data-ttu-id="29b4b-269">Deklarace struktury jako `readonly ref` kombinuje výhody a omezení deklarace `ref struct` a `readonly struct`.</span><span class="sxs-lookup"><span data-stu-id="29b4b-269">Declaring a struct as `readonly ref` combines the benefits and restrictions of `ref struct` and `readonly struct` declarations.</span></span> <span data-ttu-id="29b4b-270">Paměť využitá rozsahem jen pro čtení je omezená na jeden rámec zásobníku a paměť, kterou používá rozsah jen pro čtení, se nedá změnit.</span><span class="sxs-lookup"><span data-stu-id="29b4b-270">The memory used by the readonly span is restricted to a single stack frame, and the memory used by the readonly span can't be modified.</span></span>

## <a name="conclusions"></a><span data-ttu-id="29b4b-271">Závěry</span><span class="sxs-lookup"><span data-stu-id="29b4b-271">Conclusions</span></span>

<span data-ttu-id="29b4b-272">Použití typů hodnot minimalizuje počet operací přidělení:</span><span class="sxs-lookup"><span data-stu-id="29b4b-272">Using value types minimizes the number of allocation operations:</span></span>

- <span data-ttu-id="29b4b-273">Úložiště pro typy hodnot je zásobník přidělený pro lokální proměnné a argumenty metody.</span><span class="sxs-lookup"><span data-stu-id="29b4b-273">Storage for value types is stack allocated for local variables and method arguments.</span></span>
- <span data-ttu-id="29b4b-274">Úložiště pro typy hodnot, které jsou členy jiných objektů, je přiděleno jako součást tohoto objektu, nikoli jako samostatné přidělení.</span><span class="sxs-lookup"><span data-stu-id="29b4b-274">Storage for value types that are members of other objects is allocated as part of that object, not as a separate allocation.</span></span>
- <span data-ttu-id="29b4b-275">Úložiště pro návratové hodnoty typu hodnoty je přiděleno zásobníku.</span><span class="sxs-lookup"><span data-stu-id="29b4b-275">Storage for value type return values is stack allocated.</span></span>

<span data-ttu-id="29b4b-276">Rozdíl mezi typy odkazů v těchto situacích:</span><span class="sxs-lookup"><span data-stu-id="29b4b-276">Contrast that with reference types in those same situations:</span></span>

- <span data-ttu-id="29b4b-277">Úložiště pro typy odkazů je halda přidělená pro lokální proměnné a argumenty metody.</span><span class="sxs-lookup"><span data-stu-id="29b4b-277">Storage for reference types are heap allocated for local variables and method arguments.</span></span> <span data-ttu-id="29b4b-278">Odkaz je uložený v zásobníku.</span><span class="sxs-lookup"><span data-stu-id="29b4b-278">The reference is stored on the stack.</span></span>
- <span data-ttu-id="29b4b-279">Úložiště pro typy odkazů, které jsou členy jiných objektů, je samostatně přiděleno na haldu.</span><span class="sxs-lookup"><span data-stu-id="29b4b-279">Storage for reference types that are members of other objects are separately allocated on the heap.</span></span> <span data-ttu-id="29b4b-280">Obsahující objekt ukládá odkaz.</span><span class="sxs-lookup"><span data-stu-id="29b4b-280">The containing object stores the reference.</span></span>
- <span data-ttu-id="29b4b-281">Úložiště pro návratové hodnoty typu odkazu je přidělena halda.</span><span class="sxs-lookup"><span data-stu-id="29b4b-281">Storage for reference type return values is heap allocated.</span></span> <span data-ttu-id="29b4b-282">Odkaz na toto úložiště je uložený v zásobníku.</span><span class="sxs-lookup"><span data-stu-id="29b4b-282">The reference to that storage is stored on the stack.</span></span>

<span data-ttu-id="29b4b-283">Minimalizace přidělení přináší s kompromisy.</span><span class="sxs-lookup"><span data-stu-id="29b4b-283">Minimizing allocations comes with tradeoffs.</span></span> <span data-ttu-id="29b4b-284">Pokud je velikost `struct` větší než velikost odkazu, zkopírujete více paměti.</span><span class="sxs-lookup"><span data-stu-id="29b4b-284">You copy more memory when the size of the `struct` is larger than the size of a reference.</span></span> <span data-ttu-id="29b4b-285">Odkaz obvykle je 64 bitů nebo 32 bitů a závisí na procesoru cílového počítače.</span><span class="sxs-lookup"><span data-stu-id="29b4b-285">A reference is typically 64 bits or 32 bits, and depends on the target machine CPU.</span></span>

<span data-ttu-id="29b4b-286">Tyto kompromisy mají obvykle minimální dopad na výkon.</span><span class="sxs-lookup"><span data-stu-id="29b4b-286">These tradeoffs generally have minimal performance impact.</span></span> <span data-ttu-id="29b4b-287">U rozsáhlých struktur nebo větších kolekcí se ale zvyšuje dopad na výkon.</span><span class="sxs-lookup"><span data-stu-id="29b4b-287">However, for large structs or larger collections, the performance impact increases.</span></span> <span data-ttu-id="29b4b-288">Dopad může být velký v těsných smyčkách a horké cesty pro programy.</span><span class="sxs-lookup"><span data-stu-id="29b4b-288">The impact can be large in tight loops and hot paths for programs.</span></span>

<span data-ttu-id="29b4b-289">Tato vylepšení C# jazyka jsou navržena pro kritické algoritmy výkonu, kde minimalizace přidělení paměti je významným faktorem při dosahování potřebného výkonu.</span><span class="sxs-lookup"><span data-stu-id="29b4b-289">These enhancements to the C# language are designed for performance critical algorithms where minimizing memory allocations is a major factor in achieving the necessary performance.</span></span> <span data-ttu-id="29b4b-290">Možná zjistíte, že tyto funkce nepoužíváte často v kódu, který píšete.</span><span class="sxs-lookup"><span data-stu-id="29b4b-290">You may find that you don't often use these features in the code you write.</span></span> <span data-ttu-id="29b4b-291">Tato vylepšení se ale přijala v rámci .NET.</span><span class="sxs-lookup"><span data-stu-id="29b4b-291">However, these enhancements have been adopted throughout .NET.</span></span> <span data-ttu-id="29b4b-292">Díky většímu množství rozhraní API využívají tyto funkce, ale můžete zlepšit výkon aplikací.</span><span class="sxs-lookup"><span data-stu-id="29b4b-292">As more and more APIs make use of these features, you'll see the performance of your applications improve.</span></span>

## <a name="see-also"></a><span data-ttu-id="29b4b-293">Viz také:</span><span class="sxs-lookup"><span data-stu-id="29b4b-293">See also</span></span>

- [<span data-ttu-id="29b4b-294">ref – klíčové slovo</span><span class="sxs-lookup"><span data-stu-id="29b4b-294">ref keyword</span></span>](language-reference/keywords/ref.md)
- [<span data-ttu-id="29b4b-295">Návratové a místní referenční hodnoty</span><span class="sxs-lookup"><span data-stu-id="29b4b-295">Ref returns and ref locals</span></span>](programming-guide/classes-and-structs/ref-returns.md)
