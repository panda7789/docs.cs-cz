---
title: Napište bezpečný a efektivní kód Jazyka C#
description: Nedávná vylepšení jazyka C# umožňují psát ověřitelný bezpečný kód, který výkon dříve spojen s nebezpečným kódem.
ms.date: 10/23/2018
ms.technology: csharp-advanced-concepts
ms.custom: mvc
ms.openlocfilehash: 365320fef5a2f9cd123086c1baed9a786ede9f05
ms.sourcegitcommit: 59e36e65ac81cdd094a5a84617625b2a0ff3506e
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 03/27/2020
ms.locfileid: "80345085"
---
# <a name="write-safe-and-efficient-c-code"></a><span data-ttu-id="4cb60-103">Napište bezpečný a efektivní kód Jazyka C#</span><span class="sxs-lookup"><span data-stu-id="4cb60-103">Write safe and efficient C# code</span></span>

<span data-ttu-id="4cb60-104">Nové funkce v C# umožňují psát ověřitelný bezpečný kód s lepším výkonem.</span><span class="sxs-lookup"><span data-stu-id="4cb60-104">New features in C# enable you to write verifiable safe code with better performance.</span></span> <span data-ttu-id="4cb60-105">Pokud pečlivě použijete tyto techniky, méně scénářů vyžaduje nebezpečný kód.</span><span class="sxs-lookup"><span data-stu-id="4cb60-105">If you carefully apply these techniques, fewer scenarios require unsafe code.</span></span> <span data-ttu-id="4cb60-106">Tyto funkce usnadňují použití odkazů na typy hodnot jako argumenty metody a vrácené metody.</span><span class="sxs-lookup"><span data-stu-id="4cb60-106">These features make it easier to use references to value types as method arguments and method returns.</span></span> <span data-ttu-id="4cb60-107">Při bezpečném provedení tyto techniky minimalizují kopírování typů hodnot.</span><span class="sxs-lookup"><span data-stu-id="4cb60-107">When done safely, these techniques minimize copying value types.</span></span> <span data-ttu-id="4cb60-108">Pomocí typů hodnot můžete minimalizovat počet přidělení a průchodů uvolňování paměti.</span><span class="sxs-lookup"><span data-stu-id="4cb60-108">By using value types, you can minimize the number of allocations and garbage collection passes.</span></span>

<span data-ttu-id="4cb60-109">Velká část ukázkového kódu v tomto článku používá funkce přidané v c# 7.2.</span><span class="sxs-lookup"><span data-stu-id="4cb60-109">Much of the sample code in this article uses features added in C# 7.2.</span></span> <span data-ttu-id="4cb60-110">Chcete-li tyto funkce používat, je nutné nakonfigurovat projekt tak, aby používal c# 7.2 nebo novější.</span><span class="sxs-lookup"><span data-stu-id="4cb60-110">To use those features, you must configure your project to use C# 7.2 or later.</span></span> <span data-ttu-id="4cb60-111">Další informace o nastavení jazykové verze naleznete [v tématu konfigurace jazykové verze](language-reference/configure-language-version.md).</span><span class="sxs-lookup"><span data-stu-id="4cb60-111">For more information on setting the language version, see [configure the language version](language-reference/configure-language-version.md).</span></span>

<span data-ttu-id="4cb60-112">Tento článek se zaměřuje na techniky pro efektivní správu zdrojů.</span><span class="sxs-lookup"><span data-stu-id="4cb60-112">This article focuses on techniques for efficient resource management.</span></span> <span data-ttu-id="4cb60-113">Jednou z výhod použití typů hodnot je, že se často vyhýbají přidělení haldy.</span><span class="sxs-lookup"><span data-stu-id="4cb60-113">One advantage to using value types is that they often avoid heap allocations.</span></span> <span data-ttu-id="4cb60-114">Nevýhodou je, že jsou kopírovány podle hodnoty.</span><span class="sxs-lookup"><span data-stu-id="4cb60-114">The disadvantage is that they're copied by value.</span></span> <span data-ttu-id="4cb60-115">Tento kompromis ztěžuje optimalizaci algoritmů, které pracují s velkým množstvím dat.</span><span class="sxs-lookup"><span data-stu-id="4cb60-115">This trade-off makes it harder to optimize algorithms that operate on large amounts of data.</span></span> <span data-ttu-id="4cb60-116">Nové jazykové funkce v jazyce C# 7.2 poskytují mechanismy, které umožňují bezpečný efektivní kód pomocí odkazů na typy hodnot.</span><span class="sxs-lookup"><span data-stu-id="4cb60-116">New language features in C# 7.2 provide mechanisms that enable safe efficient code using references to value types.</span></span> <span data-ttu-id="4cb60-117">Tyto funkce můžete používat moudře, abyste minimalizovali přidělení i operace kopírování.</span><span class="sxs-lookup"><span data-stu-id="4cb60-117">Use these features wisely to minimize both allocations and copy operations.</span></span> <span data-ttu-id="4cb60-118">Tento článek zkoumá tyto nové funkce.</span><span class="sxs-lookup"><span data-stu-id="4cb60-118">This article explores those new features.</span></span>

<span data-ttu-id="4cb60-119">Tento článek se zaměřuje na následující techniky správy zdrojů:</span><span class="sxs-lookup"><span data-stu-id="4cb60-119">This article focuses on the following resource management techniques:</span></span>

- <span data-ttu-id="4cb60-120">Deklarovat a [`readonly struct`](language-reference/builtin-types/struct.md#readonly-struct) vyjádřit, že typ je **neměnný**.</span><span class="sxs-lookup"><span data-stu-id="4cb60-120">Declare a [`readonly struct`](language-reference/builtin-types/struct.md#readonly-struct) to express that a type is **immutable**.</span></span> <span data-ttu-id="4cb60-121">To umožňuje kompilátoru uložit [`in`](language-reference/keywords/in-parameter-modifier.md) obranné kopie při použití parametrů.</span><span class="sxs-lookup"><span data-stu-id="4cb60-121">That enables the compiler to save defensive copies when using [`in`](language-reference/keywords/in-parameter-modifier.md) parameters.</span></span>
- <span data-ttu-id="4cb60-122">Pokud typ nemůže být neměnný, `struct` `readonly` deklarujte členy, kteří označují, že člen nemění stav.</span><span class="sxs-lookup"><span data-stu-id="4cb60-122">If a type can't be immutable, declare `struct` members `readonly` to indicate that the member doesn't modify state.</span></span>
- <span data-ttu-id="4cb60-123">Použijte [`ref readonly`](language-reference/keywords/ref.md#reference-return-values) return, pokud je `struct` vrácená <xref:System.IntPtr.Size?displayProperty=nameWithType> hodnota větší než a doba trvání úložiště je větší než metoda vracející hodnotu.</span><span class="sxs-lookup"><span data-stu-id="4cb60-123">Use a [`ref readonly`](language-reference/keywords/ref.md#reference-return-values) return when the return value is a `struct` larger than <xref:System.IntPtr.Size?displayProperty=nameWithType> and the storage lifetime is greater than the method returning the value.</span></span>
- <span data-ttu-id="4cb60-124">Pokud je velikost `readonly struct` a <xref:System.IntPtr.Size?displayProperty=nameWithType>větší než , měli `in` byste ji předat jako parametr z důvodů výkonu.</span><span class="sxs-lookup"><span data-stu-id="4cb60-124">When the size of a `readonly struct` is bigger than <xref:System.IntPtr.Size?displayProperty=nameWithType>, you should pass it as an `in` parameter for performance reasons.</span></span>
- <span data-ttu-id="4cb60-125">Nikdy předat `struct` jako `in` parametr, pokud je `readonly` deklarován s `readonly` modifikátornebo metoda volá pouze členy struktury.</span><span class="sxs-lookup"><span data-stu-id="4cb60-125">Never pass a `struct` as an `in` parameter unless it's declared with the `readonly` modifier or the method calls only `readonly` members of the struct.</span></span> <span data-ttu-id="4cb60-126">Porušení tohoto pokynu může negativně ovlivnit výkon a může vést k obskurní chování.</span><span class="sxs-lookup"><span data-stu-id="4cb60-126">Violating this guidance may negatively affect performance and could lead to an obscure behavior.</span></span>
- <span data-ttu-id="4cb60-127">Použijte [`ref struct`](language-reference/keywords/ref.md#ref-struct-types), nebo `readonly ref struct` jako <xref:System.Span%601> <xref:System.ReadOnlySpan%601> nebo pracovat s pamětí jako posloupnost bajtů.</span><span class="sxs-lookup"><span data-stu-id="4cb60-127">Use a [`ref struct`](language-reference/keywords/ref.md#ref-struct-types), or a `readonly ref struct` such as <xref:System.Span%601> or <xref:System.ReadOnlySpan%601> to work with memory as a sequence of bytes.</span></span>

<span data-ttu-id="4cb60-128">Tyto techniky vás nutí vyvážit dva konkurenční cíle s ohledem na **odkazy** a **hodnoty**.</span><span class="sxs-lookup"><span data-stu-id="4cb60-128">These techniques force you to balance two competing goals with regard to **references** and **values**.</span></span> <span data-ttu-id="4cb60-129">Proměnné, které jsou [typy odkazů](programming-guide/types/index.md#reference-types) obsahovat odkaz na umístění v paměti.</span><span class="sxs-lookup"><span data-stu-id="4cb60-129">Variables that are [reference types](programming-guide/types/index.md#reference-types) hold a reference to the location in memory.</span></span> <span data-ttu-id="4cb60-130">Proměnné, které jsou [typy hodnot](programming-guide/types/index.md#value-types) přímo obsahují jejich hodnotu.</span><span class="sxs-lookup"><span data-stu-id="4cb60-130">Variables that are [value types](programming-guide/types/index.md#value-types) directly contain their value.</span></span> <span data-ttu-id="4cb60-131">Tyto rozdíly zdůrazňují klíčové rozdíly, které jsou důležité pro správu prostředků paměti.</span><span class="sxs-lookup"><span data-stu-id="4cb60-131">These differences highlight the key differences that are important for managing memory resources.</span></span> <span data-ttu-id="4cb60-132">**Typy hodnot** jsou obvykle zkopírovány při předání do metody nebo vráceny z metody.</span><span class="sxs-lookup"><span data-stu-id="4cb60-132">**Value types** are typically copied when passed to a method or returned from a method.</span></span> <span data-ttu-id="4cb60-133">Toto chování zahrnuje kopírování `this` hodnoty při volání členů typu hodnoty.</span><span class="sxs-lookup"><span data-stu-id="4cb60-133">This behavior includes copying the value of `this` when calling members of a value type.</span></span> <span data-ttu-id="4cb60-134">Náklady na kopii se vztahují k velikosti typu.</span><span class="sxs-lookup"><span data-stu-id="4cb60-134">The cost of the copy is related to the size of the type.</span></span> <span data-ttu-id="4cb60-135">**Referenční typy** jsou přiděleny na spravované haldy.</span><span class="sxs-lookup"><span data-stu-id="4cb60-135">**Reference types** are allocated on the managed heap.</span></span> <span data-ttu-id="4cb60-136">Každý nový objekt vyžaduje nové přidělení a následně musí být rekultivovány.</span><span class="sxs-lookup"><span data-stu-id="4cb60-136">Each new object requires a new allocation, and subsequently must be reclaimed.</span></span> <span data-ttu-id="4cb60-137">Obě tyto operace nějakou dobu trvat.</span><span class="sxs-lookup"><span data-stu-id="4cb60-137">Both these operations take time.</span></span> <span data-ttu-id="4cb60-138">Odkaz je zkopírován, když je typ odkazu předán jako argument metodě nebo vrácen z metody.</span><span class="sxs-lookup"><span data-stu-id="4cb60-138">The reference is copied when a reference type is passed as an argument to a method or returned from a method.</span></span>

<span data-ttu-id="4cb60-139">Tento článek používá následující příklad koncept struktury 3D bodů vysvětlit tato doporučení:</span><span class="sxs-lookup"><span data-stu-id="4cb60-139">This article uses the following example concept of the 3D-point structure to explain these recommendations:</span></span>

```csharp
public struct Point3D
{
    public double X;
    public double Y;
    public double Z;
}
```

<span data-ttu-id="4cb60-140">Různé příklady používají různé implementace tohoto konceptu.</span><span class="sxs-lookup"><span data-stu-id="4cb60-140">Different examples use different implementations of this concept.</span></span>

## <a name="declare-readonly-structs-for-immutable-value-types"></a><span data-ttu-id="4cb60-141">Deklarovat struktury jen pro čtení pro neměnné typy hodnot</span><span class="sxs-lookup"><span data-stu-id="4cb60-141">Declare readonly structs for immutable value types</span></span>

<span data-ttu-id="4cb60-142">Deklarování `struct` `readonly` pomocí modifikátorinformuje kompilátoru, že vaším záměrem je vytvořit neměnný typ.</span><span class="sxs-lookup"><span data-stu-id="4cb60-142">Declaring a `struct` using the `readonly` modifier informs the compiler that your intent is to create an immutable type.</span></span> <span data-ttu-id="4cb60-143">Kompilátor vynucuje toto rozhodnutí o návrhu pomocí následujících pravidel:</span><span class="sxs-lookup"><span data-stu-id="4cb60-143">The compiler enforces that design decision with the following rules:</span></span>

- <span data-ttu-id="4cb60-144">Všichni členové pole musí být`readonly`</span><span class="sxs-lookup"><span data-stu-id="4cb60-144">All field members must be `readonly`</span></span>
- <span data-ttu-id="4cb60-145">Všechny vlastnosti musí být jen pro čtení, včetně automaticky implementovaných vlastností.</span><span class="sxs-lookup"><span data-stu-id="4cb60-145">All properties must be read-only, including auto-implemented properties.</span></span>

<span data-ttu-id="4cb60-146">Tato dvě pravidla postačují `readonly struct` k zajištění toho, aby žádný člen této struktury neuměvoval stav této struktury.</span><span class="sxs-lookup"><span data-stu-id="4cb60-146">These two rules are sufficient to ensure that no member of a `readonly struct` modifies the state of that struct.</span></span> <span data-ttu-id="4cb60-147">Je `struct` neměnný.</span><span class="sxs-lookup"><span data-stu-id="4cb60-147">The `struct` is immutable.</span></span> <span data-ttu-id="4cb60-148">Struktura `Point3D` může být definována jako neměnná struktura, jak je znázorněno v následujícím příkladu:</span><span class="sxs-lookup"><span data-stu-id="4cb60-148">The `Point3D` structure could be defined as an immutable struct as shown in the following example:</span></span>

```csharp
readonly public struct ReadonlyPoint3D
{
    public ReadonlyPoint3D(double x, double y, double z)
    {
        this.X = x;
        this.Y = y;
        this.Z = z;
    }

    public double X { get; }
    public double Y { get; }
    public double Z { get; }
}
```

<span data-ttu-id="4cb60-149">Postupujte podle tohoto doporučení vždy, když záměr návrhu je vytvořit neměnný typ hodnoty.</span><span class="sxs-lookup"><span data-stu-id="4cb60-149">Follow this recommendation whenever your design intent is to create an immutable value type.</span></span> <span data-ttu-id="4cb60-150">Všechna vylepšení výkonu jsou další výhodou.</span><span class="sxs-lookup"><span data-stu-id="4cb60-150">Any performance improvements are an added benefit.</span></span> <span data-ttu-id="4cb60-151">Jasně `readonly struct` vyjadřuje váš záměr návrhu.</span><span class="sxs-lookup"><span data-stu-id="4cb60-151">The `readonly struct` clearly expresses your design intent.</span></span>

## <a name="declare-readonly-members-when-a-struct-cant-be-immutable"></a><span data-ttu-id="4cb60-152">Deklarovat členy pouze pro čtení, když struktura nemůže být neměnná</span><span class="sxs-lookup"><span data-stu-id="4cb60-152">Declare readonly members when a struct can't be immutable</span></span>

<span data-ttu-id="4cb60-153">V C# 8.0 a novější, když struct typ je proměnlivý, měli byste `readonly`deklarovat členy, které nezpůsobují mutace být .</span><span class="sxs-lookup"><span data-stu-id="4cb60-153">In C# 8.0 and later, when a struct type is mutable, you should declare members that don't cause mutation to be `readonly`.</span></span> <span data-ttu-id="4cb60-154">Zvažte jinou aplikaci, která potřebuje strukturu 3D bodů, ale musí podporovat proměnlivost.</span><span class="sxs-lookup"><span data-stu-id="4cb60-154">Consider a different application that needs a 3D point structure, but must support mutability.</span></span> <span data-ttu-id="4cb60-155">Následující verze struktury 3D bodů `readonly` přidá modifikátor pouze těm členům, kteří strukturu nemění.</span><span class="sxs-lookup"><span data-stu-id="4cb60-155">The following version of the 3D point structure adds the `readonly` modifier only to those members that don't modify the structure.</span></span> <span data-ttu-id="4cb60-156">Postupujte podle tohoto příkladu, když váš návrh musí podporovat změny struktury některými členy, ale stále chcete výhody vynucení pouze pro čtení u některých členů:</span><span class="sxs-lookup"><span data-stu-id="4cb60-156">Follow this example when your design must support modifications to the struct by some members, but you still want the benefits of enforcing readonly on some members:</span></span>

```csharp
public struct Point3D
{
    public Point3D(double x, double y, double z)
    {
        _x = x;
        _y = y;
        _z = z;
    }

    private double _x;
    public double X
    {
        readonly get => _x;
        set => _x = value;
    }

    private double _y;
    public double Y
    {
        readonly get => _y;
        set => _y = value;
    }

    private double _z;
    public double Z
    {
        readonly get => _z;
        set => _z = value;
    }

    public readonly double Distance => Math.Sqrt(X * X + Y * Y + Z * Z);

    public readonly override string ToString() => $"{X}, {Y}, {Z}";
}
```

<span data-ttu-id="4cb60-157">Předchozí ukázka zobrazuje mnoho umístění, kde `readonly` můžete použít modifikátor: metody, vlastnosti a přístupové objekty vlastností.</span><span class="sxs-lookup"><span data-stu-id="4cb60-157">The preceding sample shows many of the locations where you can apply the `readonly` modifier: methods, properties, and property accessors.</span></span> <span data-ttu-id="4cb60-158">Pokud používáte automaticky implementované vlastnosti, `readonly` kompilátor `get` přidá modifikátor do přistupujícího objektu pro vlastnosti čtení a zápisu.</span><span class="sxs-lookup"><span data-stu-id="4cb60-158">If you use auto-implemented properties, the compiler adds the `readonly` modifier to the `get` accessor for read-write properties.</span></span> <span data-ttu-id="4cb60-159">Kompilátor přidá `readonly` modifikátor automaticky implementované deklarace vlastností pro vlastnosti s pouze přistupujícím objektem. `get`</span><span class="sxs-lookup"><span data-stu-id="4cb60-159">The compiler adds the `readonly` modifier to the auto-implemented property declarations for properties with only a `get` accessor.</span></span>

<span data-ttu-id="4cb60-160">Přidání `readonly` modifikátor u členů, které nemutují stav poskytuje dvě související výhody.</span><span class="sxs-lookup"><span data-stu-id="4cb60-160">Adding the `readonly` modifier to members that don't mutate state provides two related benefits.</span></span> <span data-ttu-id="4cb60-161">Nejprve kompilátor vynucuje váš záměr.</span><span class="sxs-lookup"><span data-stu-id="4cb60-161">First, the compiler enforces your intent.</span></span> <span data-ttu-id="4cb60-162">Tento člen nemůže mutovat stav struktury, ani nemůže získat přístup k členu, který není také označen `readonly`.</span><span class="sxs-lookup"><span data-stu-id="4cb60-162">That member can't mutate the struct's state, nor can it access a member that isn't also marked `readonly`.</span></span> <span data-ttu-id="4cb60-163">Za druhé kompilátor nevytvoří obranné `in` kopie parametrů při `readonly` přístupu k členu.</span><span class="sxs-lookup"><span data-stu-id="4cb60-163">Second, the compiler won't create defensive copies of `in` parameters when accessing a `readonly` member.</span></span> <span data-ttu-id="4cb60-164">Kompilátor může tuto optimalizaci bezpečně provést, protože zaručuje, že `struct` člen není změněn. `readonly`</span><span class="sxs-lookup"><span data-stu-id="4cb60-164">The compiler can make this optimization safely because it guarantees that the `struct` is not modified by a `readonly` member.</span></span>

## <a name="use-ref-readonly-return-statements-for-large-structures-when-possible"></a><span data-ttu-id="4cb60-165">Použít `ref readonly return` příkazy pro velké struktury, pokud je to možné</span><span class="sxs-lookup"><span data-stu-id="4cb60-165">Use `ref readonly return` statements for large structures when possible</span></span>

<span data-ttu-id="4cb60-166">Můžete vrátit hodnoty odkazem, pokud vrácená hodnota není místní pro metodu vrácení.</span><span class="sxs-lookup"><span data-stu-id="4cb60-166">You can return values by reference when the value being returned isn't local to the returning method.</span></span> <span data-ttu-id="4cb60-167">Vrácení odkazem znamená, že je zkopírován pouze odkaz, nikoli struktura.</span><span class="sxs-lookup"><span data-stu-id="4cb60-167">Returning by reference means that only the reference is copied, not the structure.</span></span> <span data-ttu-id="4cb60-168">V následujícím příkladu `Origin` vlastnost nemůže použít `ref` return, protože vrácená hodnota je místní proměnná:</span><span class="sxs-lookup"><span data-stu-id="4cb60-168">In the following example, the `Origin` property can't use a `ref` return because the value being returned is a local variable:</span></span>

```csharp
public Point3D Origin => new Point3D(0,0,0);
```

<span data-ttu-id="4cb60-169">Následující definice vlastnosti však může být vrácena odkazem, protože vrácená hodnota je statický člen:</span><span class="sxs-lookup"><span data-stu-id="4cb60-169">However, the following property definition can be returned by reference because the returned value is a static member:</span></span>

```csharp
public struct Point3D
{
    private static Point3D origin = new Point3D(0,0,0);

    // Dangerous! returning a mutable reference to internal storage
    public ref Point3D Origin => ref origin;

    // other members removed for space
}
```

<span data-ttu-id="4cb60-170">Nechcete, aby volající upravovali původ, takže byste měli `ref readonly`vrátit hodnotu pomocí :</span><span class="sxs-lookup"><span data-stu-id="4cb60-170">You don't want callers modifying the origin, so you should return the value by `ref readonly`:</span></span>

```csharp
public struct Point3D
{
    private static Point3D origin = new Point3D(0,0,0);

    public static ref readonly Point3D Origin => ref origin;

    // other members removed for space
}
```

<span data-ttu-id="4cb60-171">Vrácení `ref readonly` umožňuje uložit kopírování větší struktury a zachovat neměnnost interních datových členů.</span><span class="sxs-lookup"><span data-stu-id="4cb60-171">Returning `ref readonly` enables you to save copying larger structures and preserve the immutability of your internal data members.</span></span>

<span data-ttu-id="4cb60-172">Na webu volání volající provést volbu `Origin` použít vlastnost `ref readonly` jako nebo jako hodnotu:</span><span class="sxs-lookup"><span data-stu-id="4cb60-172">At the call site, callers make the choice to use the `Origin` property as a `ref readonly` or as a value:</span></span>

[!code-csharp[AssignRefReadonly](../../samples/snippets/csharp/safe-efficient-code/ref-readonly-struct/Program.cs#AssignRefReadonly "Assigning a ref readonly")]

<span data-ttu-id="4cb60-173">První přiřazení v předchozím kódu vytvoří kopii konstanty `Origin` a přiřadí tuto kopii.</span><span class="sxs-lookup"><span data-stu-id="4cb60-173">The first assignment in the preceding code makes a copy of the `Origin` constant and assigns that copy.</span></span> <span data-ttu-id="4cb60-174">Druhý přiřadí odkaz.</span><span class="sxs-lookup"><span data-stu-id="4cb60-174">The second assigns a reference.</span></span> <span data-ttu-id="4cb60-175">Všimněte `readonly` si, že modifikátor musí být součástí deklarace proměnné.</span><span class="sxs-lookup"><span data-stu-id="4cb60-175">Notice that the `readonly` modifier must be part of the declaration of the variable.</span></span> <span data-ttu-id="4cb60-176">Odkaz, na který odkazuje nelze změnit.</span><span class="sxs-lookup"><span data-stu-id="4cb60-176">The reference to which it refers can't be modified.</span></span> <span data-ttu-id="4cb60-177">Pokusy o to mít za následek chybu v době kompilace.</span><span class="sxs-lookup"><span data-stu-id="4cb60-177">Attempts to do so result in a compile-time error.</span></span>

<span data-ttu-id="4cb60-178">Modifikátor `readonly` je vyžadován `originReference`na prohlášení .</span><span class="sxs-lookup"><span data-stu-id="4cb60-178">The `readonly` modifier is required on the declaration of `originReference`.</span></span>

<span data-ttu-id="4cb60-179">Kompilátor vynucuje, že volající nemůže změnit odkaz.</span><span class="sxs-lookup"><span data-stu-id="4cb60-179">The compiler enforces that the caller can't modify the reference.</span></span> <span data-ttu-id="4cb60-180">Pokusy o přiřazení hodnoty přímo generují chybu v době kompilace.</span><span class="sxs-lookup"><span data-stu-id="4cb60-180">Attempts to assign the value directly generate a compile-time error.</span></span> <span data-ttu-id="4cb60-181">Kompilátor však nemůže vědět, pokud libovolná metoda člena upravuje stav struktury.</span><span class="sxs-lookup"><span data-stu-id="4cb60-181">However, the compiler can't know if any member method modifies the state of the struct.</span></span>
<span data-ttu-id="4cb60-182">Chcete-li zajistit, že objekt není změněn, kompilátor vytvoří kopii a volá členské odkazy pomocí této kopie.</span><span class="sxs-lookup"><span data-stu-id="4cb60-182">To ensure that the object isn't modified, the compiler creates a copy and calls member references using that copy.</span></span> <span data-ttu-id="4cb60-183">Jakékoliv změny jsou na této obranné kopii.</span><span class="sxs-lookup"><span data-stu-id="4cb60-183">Any modifications are to that defensive copy.</span></span>

## <a name="apply-the-in-modifier-to-readonly-struct-parameters-larger-than-systemintptrsize"></a><span data-ttu-id="4cb60-184">Použijte `in` modifikátor na `readonly struct` parametry větší než`System.IntPtr.Size`</span><span class="sxs-lookup"><span data-stu-id="4cb60-184">Apply the `in` modifier to `readonly struct` parameters larger than `System.IntPtr.Size`</span></span>

<span data-ttu-id="4cb60-185">Klíčové `in` slovo doplňuje `ref` existující `out` a klíčová slova předat argumenty odkazem.</span><span class="sxs-lookup"><span data-stu-id="4cb60-185">The `in` keyword complements the existing `ref` and `out` keywords to pass arguments by reference.</span></span> <span data-ttu-id="4cb60-186">Klíčové `in` slovo určuje předání argumentu odkazem, ale volaná metoda hodnotu nezmění.</span><span class="sxs-lookup"><span data-stu-id="4cb60-186">The `in` keyword specifies passing the argument by reference, but the called method doesn't modify the value.</span></span>

<span data-ttu-id="4cb60-187">Tento dodatek poskytuje úplnou slovní zásobu vyjádřit svůj záměr návrhu.</span><span class="sxs-lookup"><span data-stu-id="4cb60-187">This addition provides a full vocabulary to express your design intent.</span></span>
<span data-ttu-id="4cb60-188">Typy hodnot jsou zkopírovány při předání do volané metody, pokud v podpisu metody nezadáte žádný z následujících modifikátorů.</span><span class="sxs-lookup"><span data-stu-id="4cb60-188">Value types are copied when passed to a called method when you don't specify any of the following modifiers in the method signature.</span></span> <span data-ttu-id="4cb60-189">Každý z těchto modifikátorů určuje, že proměnná je předána odkazem, čímž se zabrání kopii.</span><span class="sxs-lookup"><span data-stu-id="4cb60-189">Each of these modifiers specifies that a variable is passed by reference, avoiding the copy.</span></span> <span data-ttu-id="4cb60-190">Každý modifikátor vyjadřuje jiný záměr:</span><span class="sxs-lookup"><span data-stu-id="4cb60-190">Each modifier expresses a different intent:</span></span>

- <span data-ttu-id="4cb60-191">`out`: Tato metoda nastaví hodnotu argumentu použitého jako tento parametr.</span><span class="sxs-lookup"><span data-stu-id="4cb60-191">`out`: This method sets the value of the argument used as this parameter.</span></span>
- <span data-ttu-id="4cb60-192">`ref`: Tato metoda může nastavit hodnotu argumentu použitého jako tento parametr.</span><span class="sxs-lookup"><span data-stu-id="4cb60-192">`ref`: This method may set the value of the argument used as this parameter.</span></span>
- <span data-ttu-id="4cb60-193">`in`: Tato metoda nemění hodnotu argumentu použitého jako tento parametr.</span><span class="sxs-lookup"><span data-stu-id="4cb60-193">`in`: This method doesn't modify the value of the argument used as this parameter.</span></span>

<span data-ttu-id="4cb60-194">Přidejte `in` modifikátor předat argument odkazem a deklarovat záměr návrhu předat argumenty odkazem, aby se zabránilo zbytečné kopírování.</span><span class="sxs-lookup"><span data-stu-id="4cb60-194">Add the `in` modifier to pass an argument by reference and declare your design intent to pass arguments by reference to avoid unnecessary copying.</span></span> <span data-ttu-id="4cb60-195">Nemáte v úmyslu změnit objekt použitý jako tento argument.</span><span class="sxs-lookup"><span data-stu-id="4cb60-195">You don't intend to modify the object used as that argument.</span></span>

<span data-ttu-id="4cb60-196">Tento postup často zlepšuje výkon pro typy hodnot <xref:System.IntPtr.Size?displayProperty=nameWithType>jen pro čtení, které jsou větší než .</span><span class="sxs-lookup"><span data-stu-id="4cb60-196">This practice often improves performance for readonly value types that are larger than <xref:System.IntPtr.Size?displayProperty=nameWithType>.</span></span> <span data-ttu-id="4cb60-197">U jednoduchých`sbyte` `byte`typů `short` `ushort`( `int` `uint`, `long` `ulong`, `char` `float`, `double` `decimal` , `bool`, `enum` , , , , , a , a typy) jsou potenciální zvýšení výkonu minimální.</span><span class="sxs-lookup"><span data-stu-id="4cb60-197">For simple types (`sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, `double`, `decimal` and `bool`, and `enum` types), any potential performance gains are minimal.</span></span> <span data-ttu-id="4cb60-198">Ve skutečnosti může snížit výkon pomocí pass-by-reference <xref:System.IntPtr.Size?displayProperty=nameWithType>pro typy menší než .</span><span class="sxs-lookup"><span data-stu-id="4cb60-198">In fact, performance may degrade by using pass-by-reference for types smaller than <xref:System.IntPtr.Size?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="4cb60-199">Následující kód ukazuje příklad metody, která vypočítá vzdálenost mezi dvěma body v 3D prostoru.</span><span class="sxs-lookup"><span data-stu-id="4cb60-199">The following code shows an example of a method that calculates the distance between two points in 3D space.</span></span>

[!code-csharp[InArgument](../../samples/snippets/csharp/safe-efficient-code/ref-readonly-struct/Program.cs#InArgument "Specifying an in argument")]

<span data-ttu-id="4cb60-200">Argumenty jsou dvě struktury, z nichž každá obsahuje tři doubles.</span><span class="sxs-lookup"><span data-stu-id="4cb60-200">The arguments are two structures that each contain three doubles.</span></span> <span data-ttu-id="4cb60-201">Double je 8 bajtů, takže každý argument je 24 bajtů.</span><span class="sxs-lookup"><span data-stu-id="4cb60-201">A double is 8 bytes, so each argument is 24 bytes.</span></span> <span data-ttu-id="4cb60-202">Zadáním `in` modifikátoru předáte 4 bajtový nebo osmibajtový odkaz na tyto argumenty v závislosti na architektuře počítače.</span><span class="sxs-lookup"><span data-stu-id="4cb60-202">By specifying the `in` modifier, you pass a 4 byte or 8-byte reference to those arguments, depending on the architecture of the machine.</span></span> <span data-ttu-id="4cb60-203">Rozdíl ve velikosti je malý, ale sečte se při volání této metody aplikace v těsné smyčce pomocí mnoha různých hodnot.</span><span class="sxs-lookup"><span data-stu-id="4cb60-203">The difference in size is small, but it adds up when your application calls this method in a tight loop using many different values.</span></span>

<span data-ttu-id="4cb60-204">Modifikátor `in` `out` doplňuje `ref` a i jinými způsoby.</span><span class="sxs-lookup"><span data-stu-id="4cb60-204">The `in` modifier complements `out` and `ref` in other ways as well.</span></span> <span data-ttu-id="4cb60-205">Nelze vytvořit přetížení metody, které se liší pouze `in`v `out`přítomnosti `ref`, , nebo .</span><span class="sxs-lookup"><span data-stu-id="4cb60-205">You can't create overloads of a method that differ only in the presence of `in`, `out`, or `ref`.</span></span> <span data-ttu-id="4cb60-206">Tato nová pravidla rozšířit stejné chování, `out` které `ref` bylo vždy definováno pro a parametry.</span><span class="sxs-lookup"><span data-stu-id="4cb60-206">These new rules extend the same behavior that had always been defined for `out` and `ref` parameters.</span></span> <span data-ttu-id="4cb60-207">Stejně `out` `ref` jako modifikátory a typy hodnot `in` nejsou zabaleny, protože je použit modifikátor.</span><span class="sxs-lookup"><span data-stu-id="4cb60-207">Like the `out` and `ref` modifiers, value types aren't boxed because the `in` modifier is applied.</span></span>

<span data-ttu-id="4cb60-208">Modifikátor `in` lze použít na libovolný člen, který přebírá parametry: metody, delegáti, lambdy, místní funkce, indexery, operátory.</span><span class="sxs-lookup"><span data-stu-id="4cb60-208">The `in` modifier may be applied to any member that takes parameters: methods, delegates, lambdas, local functions, indexers, operators.</span></span>

<span data-ttu-id="4cb60-209">Další vlastností `in` parametrů je, že můžete použít literálové `in` hodnoty nebo konstanty pro argument parametru.</span><span class="sxs-lookup"><span data-stu-id="4cb60-209">Another feature of `in` parameters is that you may use literal values or constants for the argument to an `in` parameter.</span></span> <span data-ttu-id="4cb60-210">Také na `ref` rozdíl `out` od parametru nebo není `in` nutné použít modifikátor na webu volání.</span><span class="sxs-lookup"><span data-stu-id="4cb60-210">Also, unlike a `ref` or `out` parameter, you don't need to apply the `in` modifier at the call site.</span></span> <span data-ttu-id="4cb60-211">Následující kód ukazuje dva příklady `CalculateDistance` volání metody.</span><span class="sxs-lookup"><span data-stu-id="4cb60-211">The following code shows you two examples of calling the `CalculateDistance` method.</span></span> <span data-ttu-id="4cb60-212">První používá dvě místní proměnné předané odkazem.</span><span class="sxs-lookup"><span data-stu-id="4cb60-212">The first uses two local variables passed by reference.</span></span> <span data-ttu-id="4cb60-213">Druhý obsahuje dočasnou proměnnou vytvořenou jako součást volání metody.</span><span class="sxs-lookup"><span data-stu-id="4cb60-213">The second includes a temporary variable created as part of the method call.</span></span>

[!code-csharp[UseInArgument](../../samples/snippets/csharp/safe-efficient-code/ref-readonly-struct/Program.cs#UseInArgument "Specifying an In argument")]

<span data-ttu-id="4cb60-214">Existuje několik způsobů, ve kterém kompilátor vynucuje povahu `in` argumentu jen pro čtení.</span><span class="sxs-lookup"><span data-stu-id="4cb60-214">There are several ways in which the compiler enforces the read-only nature of an `in` argument.</span></span>  <span data-ttu-id="4cb60-215">Za prvé, volaná metoda nemůže přímo `in` přiřadit parametru.</span><span class="sxs-lookup"><span data-stu-id="4cb60-215">First of all, the called method can't directly assign to an `in` parameter.</span></span> <span data-ttu-id="4cb60-216">Nemůže přímo přiřadit žádné pole parametru, `in` pokud je `struct` tato hodnota typu.</span><span class="sxs-lookup"><span data-stu-id="4cb60-216">It can't directly assign to any field of an `in` parameter when that value is a `struct` type.</span></span> <span data-ttu-id="4cb60-217">Kromě toho nelze předat `in` parametr žádné metodě `ref` pomocí `out` modifikátoru nebo.</span><span class="sxs-lookup"><span data-stu-id="4cb60-217">In addition, you can't pass an `in` parameter to any method using the `ref` or `out` modifier.</span></span>
<span data-ttu-id="4cb60-218">Tato pravidla platí pro `in` libovolné pole parametru za `struct` předpokladu, že `struct` pole je typ a parametr je také typ.</span><span class="sxs-lookup"><span data-stu-id="4cb60-218">These rules apply to any field of an `in` parameter, provided the field is a `struct` type and the parameter is also a `struct` type.</span></span> <span data-ttu-id="4cb60-219">Ve skutečnosti tato pravidla platí pro více vrstev přístupu členů za `structs`předpokladu, že typy na všech úrovních přístupu členů jsou .</span><span class="sxs-lookup"><span data-stu-id="4cb60-219">In fact, these rules apply for multiple layers of member access provided the types at all levels of member access are `structs`.</span></span>
<span data-ttu-id="4cb60-220">Kompilátor vynucuje, že `struct` typy předané jako `in` argumenty a jejich `struct` členové jsou proměnné jen pro čtení při použití jako argumenty pro jiné metody.</span><span class="sxs-lookup"><span data-stu-id="4cb60-220">The compiler enforces that `struct` types passed as  `in` arguments and their `struct` members are read-only variables when used as arguments to other methods.</span></span>

<span data-ttu-id="4cb60-221">Použití `in` parametrů může zabránit potenciálním nákladům na výkon vytváření kopií.</span><span class="sxs-lookup"><span data-stu-id="4cb60-221">The use of `in` parameters can avoid the potential performance costs of making copies.</span></span> <span data-ttu-id="4cb60-222">Nezmění sémantiku žádné volání metody.</span><span class="sxs-lookup"><span data-stu-id="4cb60-222">It doesn't change the semantics of any method call.</span></span> <span data-ttu-id="4cb60-223">Proto není nutné zadat `in` modifikátor na webu volání.</span><span class="sxs-lookup"><span data-stu-id="4cb60-223">Therefore, you don't need to specify the `in` modifier at the call site.</span></span> <span data-ttu-id="4cb60-224">Vynechání `in` modifikátoru na webu volání informuje kompilátor, že je povoleno vytvořit kopii argumentu z následujících důvodů:</span><span class="sxs-lookup"><span data-stu-id="4cb60-224">Omitting the `in` modifier at the call site informs the compiler that it's allowed to make a copy of the argument for the following reasons:</span></span>

- <span data-ttu-id="4cb60-225">Existuje implicitní převod, ale ne převod identity z typu argumentu na typ parametru.</span><span class="sxs-lookup"><span data-stu-id="4cb60-225">There exists an implicit conversion but not an identity conversion from the argument type to the parameter type.</span></span>
- <span data-ttu-id="4cb60-226">Argument je výraz, ale nemá známou proměnnou úložiště.</span><span class="sxs-lookup"><span data-stu-id="4cb60-226">The argument is an expression but doesn't have a known storage variable.</span></span>
- <span data-ttu-id="4cb60-227">Existuje přetížení, které se liší přítomností `in`nebo nepřítomností .</span><span class="sxs-lookup"><span data-stu-id="4cb60-227">An overload exists that differs by the presence or absence of `in`.</span></span> <span data-ttu-id="4cb60-228">V takovém případě je přetížení podle hodnoty lepší shodu.</span><span class="sxs-lookup"><span data-stu-id="4cb60-228">In that case, the by value overload is a better match.</span></span>

<span data-ttu-id="4cb60-229">Tato pravidla jsou užitečné při aktualizaci existujícího kódu pro použití argumentů odkazů jen pro čtení.</span><span class="sxs-lookup"><span data-stu-id="4cb60-229">These rules are useful as you update existing code to use read-only reference arguments.</span></span> <span data-ttu-id="4cb60-230">Uvnitř volané metody můžete volat libovolnou metodu instance, která používá parametry hodnoty.</span><span class="sxs-lookup"><span data-stu-id="4cb60-230">Inside the called method, you can call any instance method that uses by value parameters.</span></span> <span data-ttu-id="4cb60-231">V těchto případech je vytvořena `in` kopie parametru.</span><span class="sxs-lookup"><span data-stu-id="4cb60-231">In those instances, a copy of the `in` parameter is created.</span></span> <span data-ttu-id="4cb60-232">Vzhledem k tomu, že kompilátor může vytvořit dočasnou proměnnou pro libovolný `in` parametr, můžete také zadat výchozí hodnoty pro libovolný `in` parametr.</span><span class="sxs-lookup"><span data-stu-id="4cb60-232">Because the compiler may create a temporary variable for any `in` parameter, you can also specify default values for any `in` parameter.</span></span> <span data-ttu-id="4cb60-233">Následující kód určuje počátek (bod 0,0) jako výchozí hodnotu pro druhý bod:</span><span class="sxs-lookup"><span data-stu-id="4cb60-233">The following code specifies the origin (point 0,0) as the default value for the second point:</span></span>

[!code-csharp[InArgumentDefault](../../samples/snippets/csharp/safe-efficient-code/ref-readonly-struct/Program.cs#InArgumentDefault "Specifying defaults for an in parameter")]

<span data-ttu-id="4cb60-234">Chcete-li vynutit, aby kompilátor předával `in` argumenty jen pro čtení odkazem, zadejte modifikátor argumentů na webu volání, jak je znázorněno v následujícím kódu:</span><span class="sxs-lookup"><span data-stu-id="4cb60-234">To force the compiler to pass read-only arguments by reference, specify the `in` modifier on the arguments at the call site, as shown in the following code:</span></span>

[!code-csharp[UseInArgument](../../samples/snippets/csharp/safe-efficient-code/ref-readonly-struct/Program.cs#ExplicitInArgument "Specifying an In argument")]

<span data-ttu-id="4cb60-235">Toto chování usnadňuje `in` přijmout parametry v průběhu času ve velkých základy kódu, kde je možné zvýšení výkonu.</span><span class="sxs-lookup"><span data-stu-id="4cb60-235">This behavior makes it easier to adopt `in` parameters over time in large codebases where performance gains are possible.</span></span> <span data-ttu-id="4cb60-236">`in` Modifikátor nejprve přidáte k podpisům metody.</span><span class="sxs-lookup"><span data-stu-id="4cb60-236">You add the `in` modifier to method signatures first.</span></span> <span data-ttu-id="4cb60-237">Potom můžete přidat `in` modifikátor na `readonly struct` weby volání a vytvořit typy povolit kompilátoru, aby se zabránilo vytváření obranných `in` kopií parametrů ve více umístěních.</span><span class="sxs-lookup"><span data-stu-id="4cb60-237">Then, you can add the `in` modifier at call sites and create `readonly struct` types to enable the compiler to avoid creating defensive copies of `in` parameters in more locations.</span></span>

<span data-ttu-id="4cb60-238">Označení `in` parametru lze také použít s typy odkazů nebo číselnými hodnotami.</span><span class="sxs-lookup"><span data-stu-id="4cb60-238">The `in` parameter designation can also be used with reference types or numeric values.</span></span> <span data-ttu-id="4cb60-239">Nicméně, výhody v obou případech jsou minimální, pokud existují.</span><span class="sxs-lookup"><span data-stu-id="4cb60-239">However, the benefits in both cases are minimal, if any.</span></span>

## <a name="avoid-mutable-structs-as-an-in-argument"></a><span data-ttu-id="4cb60-240">Vyhněte se proměnlivým `in` strukturám jako argumentu</span><span class="sxs-lookup"><span data-stu-id="4cb60-240">Avoid mutable structs as an `in` argument</span></span>

<span data-ttu-id="4cb60-241">Výše popsané techniky vysvětlují, jak se vyhnout kopiím vrácením odkazů a předávání mů e-li odkazovat.</span><span class="sxs-lookup"><span data-stu-id="4cb60-241">The techniques described above explain how to avoid copies by returning references and passing values by reference.</span></span> <span data-ttu-id="4cb60-242">Tyto techniky fungují nejlépe, když `readonly struct` jsou typy argumentů deklarovány jako typy.</span><span class="sxs-lookup"><span data-stu-id="4cb60-242">These techniques work best when the argument types are declared as `readonly struct` types.</span></span> <span data-ttu-id="4cb60-243">V opačném případě musí kompilátor vytvořit **obranné kopie** v mnoha situacích k vynucení pouze pro čtení všech argumentů.</span><span class="sxs-lookup"><span data-stu-id="4cb60-243">Otherwise, the compiler must create **defensive copies** in many situations to enforce the readonly-ness of any arguments.</span></span> <span data-ttu-id="4cb60-244">Vezměme si následující příklad, který vypočítá vzdálenost 3D bodu od počátku:</span><span class="sxs-lookup"><span data-stu-id="4cb60-244">Consider the following example that calculates the distance of a 3D point from the origin:</span></span>

[!code-csharp[InArgument](../../samples/snippets/csharp/safe-efficient-code/ref-readonly-struct/Program.cs#InArgument "Specifying an in argument")]

<span data-ttu-id="4cb60-245">Struktura `Point3D` *není* jen pro čtení struktury.</span><span class="sxs-lookup"><span data-stu-id="4cb60-245">The `Point3D` structure is *not* a readonly struct.</span></span> <span data-ttu-id="4cb60-246">Existuje šest různých volání přístupu vlastností v těle této metody.</span><span class="sxs-lookup"><span data-stu-id="4cb60-246">There are six different property access calls in the body of this method.</span></span> <span data-ttu-id="4cb60-247">Při prvním vyšetření jste si možná mysleli, že tyto přístupy jsou bezpečné.</span><span class="sxs-lookup"><span data-stu-id="4cb60-247">On first examination, you may have thought these accesses were safe.</span></span> <span data-ttu-id="4cb60-248">Koneckonců, `get` přistupující objekt by neměl měnit stav objektu.</span><span class="sxs-lookup"><span data-stu-id="4cb60-248">After all, a `get` accessor shouldn't modify the state of the object.</span></span> <span data-ttu-id="4cb60-249">Ale neexistuje žádné jazykové pravidlo, které by to vynucova.</span><span class="sxs-lookup"><span data-stu-id="4cb60-249">But there's no language rule that enforces that.</span></span> <span data-ttu-id="4cb60-250">Je to jen běžná konvence.</span><span class="sxs-lookup"><span data-stu-id="4cb60-250">It's only a common convention.</span></span> <span data-ttu-id="4cb60-251">Libovolný typ může `get` implementovat přistupujícího pole, které upravilo vnitřní stav.</span><span class="sxs-lookup"><span data-stu-id="4cb60-251">Any type could implement a `get` accessor that modified the internal state.</span></span> <span data-ttu-id="4cb60-252">Bez záruky některých jazyků musí kompilátor vytvořit dočasnou kopii argumentu před voláním libovolného člena, který není označen modifikátorem. `readonly`</span><span class="sxs-lookup"><span data-stu-id="4cb60-252">Without some language guarantee, the compiler must create a temporary copy of the argument before calling any member not marked with the `readonly` modifier.</span></span> <span data-ttu-id="4cb60-253">Dočasné úložiště je vytvořeno v zásobníku, hodnoty argumentu jsou zkopírovány do dočasného úložiště a hodnota `this` je zkopírována do zásobníku pro každý přístup člena jako argument.</span><span class="sxs-lookup"><span data-stu-id="4cb60-253">The temporary storage is created on the stack, the values of the argument are copied to the temporary storage, and the value is copied to the stack for each member access as the `this` argument.</span></span> <span data-ttu-id="4cb60-254">V mnoha situacích tyto kopie poškodit výkon natolik, že pass-by-value je rychlejší než pass-by-readonly-reference, pokud typ argumentu `readonly struct` není a a metoda volá členy, které nejsou označeny `readonly`.</span><span class="sxs-lookup"><span data-stu-id="4cb60-254">In many situations, these copies harm performance enough that pass-by-value is faster than pass-by-readonly-reference when the argument type isn't a `readonly struct` and the method calls members that aren't marked `readonly`.</span></span> <span data-ttu-id="4cb60-255">Pokud označíte všechny metody, které nemění `readonly`stav struktury jako , kompilátor může bezpečně určit, že stav struktury není změněn a obranná kopie není potřeba.</span><span class="sxs-lookup"><span data-stu-id="4cb60-255">If you mark all methods that don't modify the struct state as `readonly`, the compiler can safely determine that the struct state isn't modified, and a defensive copy is not needed.</span></span>

<span data-ttu-id="4cb60-256">Místo toho, pokud výpočet vzdálenosti používá neměnnou strukturu, `ReadonlyPoint3D`, dočasné objekty nejsou potřeba:</span><span class="sxs-lookup"><span data-stu-id="4cb60-256">Instead, if the distance calculation uses the immutable struct, `ReadonlyPoint3D`, temporary objects aren't needed:</span></span>

[!code-csharp[readonlyInArgument](../../samples/snippets/csharp/safe-efficient-code/ref-readonly-struct/Program.cs#ReadOnlyInArgument "Specifying a readonly in argument")]

<span data-ttu-id="4cb60-257">Kompilátor generuje efektivnější kód při volání `readonly struct`členů `this` : Odkaz namísto kopie příjemce je `in` vždy parametr předaný odkazem na metodu člena.</span><span class="sxs-lookup"><span data-stu-id="4cb60-257">The compiler generates more efficient code when you call members of a `readonly struct`: The `this` reference, instead of a copy of the receiver, is always an `in` parameter passed by reference to the member method.</span></span> <span data-ttu-id="4cb60-258">Tato optimalizace uloží kopírování při `readonly struct` použití `in` jako argument.</span><span class="sxs-lookup"><span data-stu-id="4cb60-258">This optimization saves copying when you use a `readonly struct` as an `in` argument.</span></span>

<span data-ttu-id="4cb60-259">Jako argument byste neměli předávat `in` typ hodnoty s možnou hodnotou s možnou hodnotou.</span><span class="sxs-lookup"><span data-stu-id="4cb60-259">You shouldn't pass a nullable value type as an `in` argument.</span></span> <span data-ttu-id="4cb60-260">Typ <xref:System.Nullable%601> není deklarován jako struktura jen pro čtení.</span><span class="sxs-lookup"><span data-stu-id="4cb60-260">The <xref:System.Nullable%601> type isn't declared as a read-only struct.</span></span> <span data-ttu-id="4cb60-261">To znamená, že kompilátor musí generovat obranné kopie pro všechny `in` argumenty typu hodnoty s možnou hodnotou null předané metodě pomocí modifikátoru v deklaraci parametru.</span><span class="sxs-lookup"><span data-stu-id="4cb60-261">That means the compiler must generate defensive copies for any nullable value type argument passed to a method using the `in` modifier on the parameter declaration.</span></span>

<span data-ttu-id="4cb60-262">Můžete vidět ukázkový program, který demonstruje rozdíly ve výkonu pomocí [BenchmarkDotNet](https://www.nuget.org/packages/BenchmarkDotNet/) v našem [úložišti ukázek](https://github.com/dotnet/samples/tree/master/csharp/safe-efficient-code/benchmark) na GitHubu.</span><span class="sxs-lookup"><span data-stu-id="4cb60-262">You can see an example program that demonstrates the performance differences using [BenchmarkDotNet](https://www.nuget.org/packages/BenchmarkDotNet/) in our [samples repository](https://github.com/dotnet/samples/tree/master/csharp/safe-efficient-code/benchmark) on GitHub.</span></span> <span data-ttu-id="4cb60-263">Porovnává předání proměnlivé struktury podle hodnoty a odkazem s předáním neměnné struktury podle hodnoty a odkazem.</span><span class="sxs-lookup"><span data-stu-id="4cb60-263">It compares passing a mutable struct by value and by reference with passing an immutable struct by value and by reference.</span></span> <span data-ttu-id="4cb60-264">Použití neměnné struktury a předat odkazem je nejrychlejší.</span><span class="sxs-lookup"><span data-stu-id="4cb60-264">The use of the immutable struct and pass by reference is fastest.</span></span>

## <a name="use-ref-struct-types-to-work-with-blocks-or-memory-on-a-single-stack-frame"></a><span data-ttu-id="4cb60-265">Použití `ref struct` typů pro práci s bloky nebo pamětí v jednom rámci zásobníku</span><span class="sxs-lookup"><span data-stu-id="4cb60-265">Use `ref struct` types to work with blocks or memory on a single stack frame</span></span>

<span data-ttu-id="4cb60-266">Související funkce jazyka je schopnost deklarovat typ hodnoty, který musí být omezen na jeden rámec zásobníku.</span><span class="sxs-lookup"><span data-stu-id="4cb60-266">A related language feature is the ability to declare a value type that must be constrained to a single stack frame.</span></span> <span data-ttu-id="4cb60-267">Toto omezení umožňuje kompilátoru provést několik optimalizací.</span><span class="sxs-lookup"><span data-stu-id="4cb60-267">This restriction enables the compiler to make several optimizations.</span></span> <span data-ttu-id="4cb60-268">Primární motivací pro <xref:System.Span%601> tuto funkci byla a související struktury.</span><span class="sxs-lookup"><span data-stu-id="4cb60-268">The primary motivation for this feature was <xref:System.Span%601> and related structures.</span></span> <span data-ttu-id="4cb60-269">Z těchto vylepšení dosáhnete zlepšení min. pomocí nových a aktualizovaných <xref:System.Span%601> rozhraní API rozhraní .NET, která používají daný typ.</span><span class="sxs-lookup"><span data-stu-id="4cb60-269">You'll achieve performance improvements from these enhancements by using new and updated .NET APIs that make use of the <xref:System.Span%601> type.</span></span>

<span data-ttu-id="4cb60-270">Můžete mít podobné požadavky práce [`stackalloc`](language-reference/operators/stackalloc.md) s pamětí vytvořené pomocí nebo při použití paměti z interop API.</span><span class="sxs-lookup"><span data-stu-id="4cb60-270">You may have similar requirements working with memory created using [`stackalloc`](language-reference/operators/stackalloc.md) or when using memory from interop APIs.</span></span> <span data-ttu-id="4cb60-271">Pro tyto potřeby `ref struct` můžete definovat vlastní typy.</span><span class="sxs-lookup"><span data-stu-id="4cb60-271">You can define your own `ref struct` types for those needs.</span></span>

## <a name="readonly-ref-struct-type"></a><span data-ttu-id="4cb60-272">`readonly ref struct`Typ</span><span class="sxs-lookup"><span data-stu-id="4cb60-272">`readonly ref struct` type</span></span>

<span data-ttu-id="4cb60-273">Deklarování struktury `readonly ref` jako kombinuje výhody `ref struct` a `readonly struct` omezení a prohlášení.</span><span class="sxs-lookup"><span data-stu-id="4cb60-273">Declaring a struct as `readonly ref` combines the benefits and restrictions of `ref struct` and `readonly struct` declarations.</span></span> <span data-ttu-id="4cb60-274">Paměť používaná rozsahem jen pro čtení je omezena na jeden rámec zásobníku a paměť používanou pouze pro čtení nelze změnit.</span><span class="sxs-lookup"><span data-stu-id="4cb60-274">The memory used by the readonly span is restricted to a single stack frame, and the memory used by the readonly span can't be modified.</span></span>

## <a name="conclusions"></a><span data-ttu-id="4cb60-275">Závěry</span><span class="sxs-lookup"><span data-stu-id="4cb60-275">Conclusions</span></span>

<span data-ttu-id="4cb60-276">Použití typů hodnot minimalizuje počet operací přidělení:</span><span class="sxs-lookup"><span data-stu-id="4cb60-276">Using value types minimizes the number of allocation operations:</span></span>

- <span data-ttu-id="4cb60-277">Úložiště pro typy hodnot je zásobník přidělen pro místní proměnné a argumenty metody.</span><span class="sxs-lookup"><span data-stu-id="4cb60-277">Storage for value types is stack allocated for local variables and method arguments.</span></span>
- <span data-ttu-id="4cb60-278">Úložiště pro typy hodnot, které jsou členy jiných objektů je přidělena jako součást tohoto objektu, nikoli jako samostatné přidělení.</span><span class="sxs-lookup"><span data-stu-id="4cb60-278">Storage for value types that are members of other objects is allocated as part of that object, not as a separate allocation.</span></span>
- <span data-ttu-id="4cb60-279">Úložiště pro vrácené hodnoty typu hodnoty je přiděleno zásobníku.</span><span class="sxs-lookup"><span data-stu-id="4cb60-279">Storage for value type return values is stack allocated.</span></span>

<span data-ttu-id="4cb60-280">Kontrast, že s typy odkazů v těchto stejných situacích:</span><span class="sxs-lookup"><span data-stu-id="4cb60-280">Contrast that with reference types in those same situations:</span></span>

- <span data-ttu-id="4cb60-281">Úložiště pro typy odkazů jsou haldy přiděleny pro místní proměnné a argumenty metody.</span><span class="sxs-lookup"><span data-stu-id="4cb60-281">Storage for reference types are heap allocated for local variables and method arguments.</span></span> <span data-ttu-id="4cb60-282">Odkaz je uložen v zásobníku.</span><span class="sxs-lookup"><span data-stu-id="4cb60-282">The reference is stored on the stack.</span></span>
- <span data-ttu-id="4cb60-283">Úložiště pro referenční typy, které jsou členy jiných objektů jsou samostatně přiděleny na haldě.</span><span class="sxs-lookup"><span data-stu-id="4cb60-283">Storage for reference types that are members of other objects are separately allocated on the heap.</span></span> <span data-ttu-id="4cb60-284">Obsahující objekt ukládá odkaz.</span><span class="sxs-lookup"><span data-stu-id="4cb60-284">The containing object stores the reference.</span></span>
- <span data-ttu-id="4cb60-285">Úložiště pro návratové hodnoty referenčního typu je přiděleno haldy.</span><span class="sxs-lookup"><span data-stu-id="4cb60-285">Storage for reference type return values is heap allocated.</span></span> <span data-ttu-id="4cb60-286">Odkaz na toto úložiště je uložen v zásobníku.</span><span class="sxs-lookup"><span data-stu-id="4cb60-286">The reference to that storage is stored on the stack.</span></span>

<span data-ttu-id="4cb60-287">Minimalizace přidělení přichází s kompromisy.</span><span class="sxs-lookup"><span data-stu-id="4cb60-287">Minimizing allocations comes with tradeoffs.</span></span> <span data-ttu-id="4cb60-288">Zkopírujete více paměti, `struct` pokud je velikost větší než velikost odkazu.</span><span class="sxs-lookup"><span data-stu-id="4cb60-288">You copy more memory when the size of the `struct` is larger than the size of a reference.</span></span> <span data-ttu-id="4cb60-289">Odkaz je obvykle 64 bitů nebo 32 bitů a závisí na procesoru cílového počítače.</span><span class="sxs-lookup"><span data-stu-id="4cb60-289">A reference is typically 64 bits or 32 bits, and depends on the target machine CPU.</span></span>

<span data-ttu-id="4cb60-290">Tyto kompromisy mají obecně minimální dopad na výkon.</span><span class="sxs-lookup"><span data-stu-id="4cb60-290">These tradeoffs generally have minimal performance impact.</span></span> <span data-ttu-id="4cb60-291">Však pro velké struktury nebo větší kolekce, zvýšení dopadu na výkon.</span><span class="sxs-lookup"><span data-stu-id="4cb60-291">However, for large structs or larger collections, the performance impact increases.</span></span> <span data-ttu-id="4cb60-292">Dopad může být velký v těsných smyčkách a horkých cestách pro programy.</span><span class="sxs-lookup"><span data-stu-id="4cb60-292">The impact can be large in tight loops and hot paths for programs.</span></span>

<span data-ttu-id="4cb60-293">Tato vylepšení jazyka C# jsou určeny pro algoritmy kritické pro výkon, kde minimalizace přidělení paměti je hlavním faktorem při dosahování potřebného výkonu.</span><span class="sxs-lookup"><span data-stu-id="4cb60-293">These enhancements to the C# language are designed for performance critical algorithms where minimizing memory allocations is a major factor in achieving the necessary performance.</span></span> <span data-ttu-id="4cb60-294">Možná zjistíte, že tyto funkce často nepoužíváte v kódu, který píšete.</span><span class="sxs-lookup"><span data-stu-id="4cb60-294">You may find that you don't often use these features in the code you write.</span></span> <span data-ttu-id="4cb60-295">Tato vylepšení však byla přijata v celém rozhraní .NET.</span><span class="sxs-lookup"><span data-stu-id="4cb60-295">However, these enhancements have been adopted throughout .NET.</span></span> <span data-ttu-id="4cb60-296">Vzhledem k tomu, že stále více a více api využívají tyto funkce, uvidíte, že výkon vašich aplikací se zlepší.</span><span class="sxs-lookup"><span data-stu-id="4cb60-296">As more and more APIs make use of these features, you'll see the performance of your applications improve.</span></span>

## <a name="see-also"></a><span data-ttu-id="4cb60-297">Viz také</span><span class="sxs-lookup"><span data-stu-id="4cb60-297">See also</span></span>

- [<span data-ttu-id="4cb60-298">klíčové slovo ref</span><span class="sxs-lookup"><span data-stu-id="4cb60-298">ref keyword</span></span>](language-reference/keywords/ref.md)
- [<span data-ttu-id="4cb60-299">Návratové hodnoty podle odkazu a lokální proměnné podle odkazu</span><span class="sxs-lookup"><span data-stu-id="4cb60-299">Ref returns and ref locals</span></span>](programming-guide/classes-and-structs/ref-returns.md)
