---
title: Sekvence
description: Naučte se používat F# sekvence, když máte rozsáhlou uspořádanou kolekci dat, ale nemusí nutně očekávat použití všech prvků.
ms.date: 11/04/2019
ms.openlocfilehash: 34e03f1cead0a9f678f637afcb6c8397ef7572bc
ms.sourcegitcommit: f348c84443380a1959294cdf12babcb804cfa987
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 11/12/2019
ms.locfileid: "73971449"
---
# <a name="sequences"></a><span data-ttu-id="cd371-103">Sekvence</span><span class="sxs-lookup"><span data-stu-id="cd371-103">Sequences</span></span>

> [!NOTE]
> <span data-ttu-id="cd371-104">Odkazy na reference k rozhraní API v tomto článku vás převezmou na MSDN.</span><span class="sxs-lookup"><span data-stu-id="cd371-104">The API reference links in this article will take you to MSDN.</span></span>  <span data-ttu-id="cd371-105">Reference k rozhraní docs.microsoft.com API není dokončená.</span><span class="sxs-lookup"><span data-stu-id="cd371-105">The docs.microsoft.com API reference is not complete.</span></span>

<span data-ttu-id="cd371-106">*Sekvence* je logická řada prvků všech jednoho typu.</span><span class="sxs-lookup"><span data-stu-id="cd371-106">A *sequence* is a logical series of elements all of one type.</span></span> <span data-ttu-id="cd371-107">Sekvence jsou zvláště užitečné v případě, že máte rozsáhlou uspořádanou kolekci dat, ale nemusí nutně očekávat použití všech prvků.</span><span class="sxs-lookup"><span data-stu-id="cd371-107">Sequences are particularly useful when you have a large, ordered collection of data but do not necessarily expect to use all of the elements.</span></span> <span data-ttu-id="cd371-108">Jednotlivé prvky sekvence jsou vypočítány pouze jako povinné, takže sekvence může poskytovat lepší výkon než seznam v situacích, kdy nejsou použity všechny prvky.</span><span class="sxs-lookup"><span data-stu-id="cd371-108">Individual sequence elements are computed only as required, so a sequence can provide better performance than a list in situations in which not all the elements are used.</span></span> <span data-ttu-id="cd371-109">Sekvence jsou reprezentovány typem `seq<'T>`, který je aliasem pro <xref:System.Collections.Generic.IEnumerable%601>.</span><span class="sxs-lookup"><span data-stu-id="cd371-109">Sequences are represented by the `seq<'T>` type, which is an alias for <xref:System.Collections.Generic.IEnumerable%601>.</span></span> <span data-ttu-id="cd371-110">Proto může být jakýkoli typ rozhraní .NET, který implementuje rozhraní <xref:System.Collections.Generic.IEnumerable%601>, použit jako sekvence.</span><span class="sxs-lookup"><span data-stu-id="cd371-110">Therefore, any .NET type that implements <xref:System.Collections.Generic.IEnumerable%601> interface can be used as a sequence.</span></span> <span data-ttu-id="cd371-111">[Modul SEQ](https://msdn.microsoft.com/library/54e8f059-ca52-4632-9ae9-49685ee9b684) poskytuje podporu pro manipulace zahrnující sekvence.</span><span class="sxs-lookup"><span data-stu-id="cd371-111">The [Seq module](https://msdn.microsoft.com/library/54e8f059-ca52-4632-9ae9-49685ee9b684) provides support for manipulations involving sequences.</span></span>

## <a name="sequence-expressions"></a><span data-ttu-id="cd371-112">Výrazy sekvence</span><span class="sxs-lookup"><span data-stu-id="cd371-112">Sequence Expressions</span></span>

<span data-ttu-id="cd371-113">*Výraz sekvence* je výraz, který je vyhodnocen jako sekvence.</span><span class="sxs-lookup"><span data-stu-id="cd371-113">A *sequence expression* is an expression that evaluates to a sequence.</span></span> <span data-ttu-id="cd371-114">Výrazy sekvence mohou mít několik forem.</span><span class="sxs-lookup"><span data-stu-id="cd371-114">Sequence expressions can take a number of forms.</span></span> <span data-ttu-id="cd371-115">Nejjednodušší formulář určuje rozsah.</span><span class="sxs-lookup"><span data-stu-id="cd371-115">The simplest form specifies a range.</span></span> <span data-ttu-id="cd371-116">Například `seq { 1 .. 5 }` vytvoří sekvenci, která obsahuje pět prvků, včetně koncových bodů 1 a 5.</span><span class="sxs-lookup"><span data-stu-id="cd371-116">For example, `seq { 1 .. 5 }` creates a sequence that contains five elements, including the endpoints 1 and 5.</span></span> <span data-ttu-id="cd371-117">Můžete také určit přírůstek (nebo snížení) mezi dvěma dvojitými tečkami.</span><span class="sxs-lookup"><span data-stu-id="cd371-117">You can also specify an increment (or decrement) between two double periods.</span></span> <span data-ttu-id="cd371-118">Například následující kód vytvoří sekvenci násobek 10.</span><span class="sxs-lookup"><span data-stu-id="cd371-118">For example, the following code creates the sequence of multiples of 10.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet1502.fs)]

<span data-ttu-id="cd371-119">Výrazy sekvence jsou tvořeny F# výrazy, které vytvářejí hodnoty sekvence.</span><span class="sxs-lookup"><span data-stu-id="cd371-119">Sequence expressions are made up of F# expressions that produce values of the sequence.</span></span> <span data-ttu-id="cd371-120">Hodnoty můžete také generovat programově:</span><span class="sxs-lookup"><span data-stu-id="cd371-120">You can also generate values programmatically:</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet1503.fs)]

<span data-ttu-id="cd371-121">Předchozí příklad používá operátor `->`, který umožňuje určit výraz, jehož hodnota se stane součástí sekvence.</span><span class="sxs-lookup"><span data-stu-id="cd371-121">The previous sample uses the `->` operator, which allows you to specify an expression whose value will become a part of the sequence.</span></span> <span data-ttu-id="cd371-122">`->` lze použít pouze v případě, že každá část kódu, která následuje, vrací hodnotu.</span><span class="sxs-lookup"><span data-stu-id="cd371-122">You can only use `->` if every part of the code that follows it returns a value.</span></span>

<span data-ttu-id="cd371-123">Alternativně můžete zadat klíčové slovo `do` s volitelným `yield`, které následuje:</span><span class="sxs-lookup"><span data-stu-id="cd371-123">Alternatively, you can specify the `do` keyword, with an optional `yield` that follows:</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet1504.fs)]

<span data-ttu-id="cd371-124">Následující kód vygeneruje seznam dvojic souřadnic spolu s indexem do pole, které představuje mřížku.</span><span class="sxs-lookup"><span data-stu-id="cd371-124">The following code generates a list of coordinate pairs along with an index into an array that represents the grid.</span></span> <span data-ttu-id="cd371-125">Všimněte si, že první výraz `for` vyžaduje, aby byl zadán `do`.</span><span class="sxs-lookup"><span data-stu-id="cd371-125">Note that the first `for` expression requires a `do` to be specified.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet1505.fs)]

<span data-ttu-id="cd371-126">Výraz `if` použitý v sekvenci je filtr.</span><span class="sxs-lookup"><span data-stu-id="cd371-126">An `if` expression used in a sequence is a filter.</span></span> <span data-ttu-id="cd371-127">Chcete-li například vygenerovat sekvenci pouze apostrofů, za předpokladu, že máte funkci `isprime` typu `int -> bool`, sestavte sekvenci následujícím způsobem.</span><span class="sxs-lookup"><span data-stu-id="cd371-127">For example, to generate a sequence of only prime numbers, assuming that you have a function `isprime` of type `int -> bool`, construct the sequence as follows.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet1506.fs)]

<span data-ttu-id="cd371-128">Jak bylo zmíněno dříve, `do` je zde požadováno, protože neexistuje žádná `else` větev, která přechází do `if`.</span><span class="sxs-lookup"><span data-stu-id="cd371-128">As mentioned previously, `do` is required here because there is no `else` branch that goes with the `if`.</span></span> <span data-ttu-id="cd371-129">Pokud se pokusíte použít `->`, zobrazí se chyba oznamující, že ne všechny větve vrací hodnotu.</span><span class="sxs-lookup"><span data-stu-id="cd371-129">If you try to use `->`, you'll get an error saying that not all branches return a value.</span></span>

## <a name="the-yield-keyword"></a><span data-ttu-id="cd371-130">Klíčové slovo `yield!`</span><span class="sxs-lookup"><span data-stu-id="cd371-130">The `yield!` keyword</span></span>

<span data-ttu-id="cd371-131">V některých případech můžete chtít zahrnout sekvenci prvků do jiné sekvence.</span><span class="sxs-lookup"><span data-stu-id="cd371-131">Sometimes, you may wish to include a sequence of elements into another sequence.</span></span> <span data-ttu-id="cd371-132">Chcete-li zahrnout sekvenci v rámci jiné sekvence, je nutné použít klíčové slovo `yield!`:</span><span class="sxs-lookup"><span data-stu-id="cd371-132">To include a sequence within another sequence, you'll need to use the `yield!` keyword:</span></span>

```fsharp
// Repeats '1 2 3 4 5' ten times
seq {
    for _ in 1..10 do
        yield! seq { 1; 2; 3; 4; 5}
}
```

<span data-ttu-id="cd371-133">Dalším způsobem, jak se `yield!`, je, že se sloučí vnitřní sekvence a pak se do ní vloží v obsaženém pořadí.</span><span class="sxs-lookup"><span data-stu-id="cd371-133">Another way of thinking of `yield!` is that it flattens an inner sequence and then includes that in the containing sequence.</span></span>

<span data-ttu-id="cd371-134">Pokud se ve výrazu používá `yield!`, všechny ostatní jednotlivé hodnoty musí používat klíčové slovo `yield`:</span><span class="sxs-lookup"><span data-stu-id="cd371-134">When `yield!` is used in an expression, all other single values must use the `yield` keyword:</span></span>

```fsharp
// Combine repeated values with their values
seq {
    for x in 1..10 do
        yield x
        yield! seq { for i in 1..x -> i}
}
```

<span data-ttu-id="cd371-135">Výsledkem určení pouze `x` v předchozím příkladu bude sekvence nevygenerovala žádné hodnoty.</span><span class="sxs-lookup"><span data-stu-id="cd371-135">Specifying only `x` in the previous example will result in the sequence generating no values.</span></span>

## <a name="examples"></a><span data-ttu-id="cd371-136">Příklady</span><span class="sxs-lookup"><span data-stu-id="cd371-136">Examples</span></span>

<span data-ttu-id="cd371-137">První příklad používá výraz sekvence, který obsahuje iteraci, filtr a výtěžnost pro vygenerování pole.</span><span class="sxs-lookup"><span data-stu-id="cd371-137">The first example uses a sequence expression that contains an iteration, a filter, and a yield to generate an array.</span></span> <span data-ttu-id="cd371-138">Tento kód vytiskne sekvenci prvočísla mezi 1 a 100 do konzoly.</span><span class="sxs-lookup"><span data-stu-id="cd371-138">This code prints a sequence of prime numbers between 1 and 100 to the console.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet1507.fs)]

<span data-ttu-id="cd371-139">Následující příklad vytvoří tabulku násobení, která se skládá z řazených kolekcí členů tří prvků, z nichž každý obsahuje dva faktory a produkt:</span><span class="sxs-lookup"><span data-stu-id="cd371-139">The following example creates a multiplication table that consists of tuples of three elements, each consisting of two factors and the product:</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet1508.fs)]

<span data-ttu-id="cd371-140">Následující příklad ukazuje použití `yield!` ke kombinování jednotlivých sekvencí do jediné konečné sekvence.</span><span class="sxs-lookup"><span data-stu-id="cd371-140">The following example demonstrates the use of `yield!` to combine individual sequences into a single final sequence.</span></span> <span data-ttu-id="cd371-141">V tomto případě jsou sekvence pro každý podstrom v binárním stromu zřetězeny rekurzivní funkcí a vytvoří finální sekvenci.</span><span class="sxs-lookup"><span data-stu-id="cd371-141">In this case, the sequences for each subtree in a binary tree are concatenated in a recursive function to produce the final sequence.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet1509.fs)]

## <a name="using-sequences"></a><span data-ttu-id="cd371-142">Používání sekvencí</span><span class="sxs-lookup"><span data-stu-id="cd371-142">Using Sequences</span></span>

<span data-ttu-id="cd371-143">Sekvence podporují mnoho stejných funkcí jako [seznamy](lists.md).</span><span class="sxs-lookup"><span data-stu-id="cd371-143">Sequences support many of the same functions as [lists](lists.md).</span></span> <span data-ttu-id="cd371-144">Sekvence také podporují operace, jako je seskupování a počítání, pomocí funkcí pro generování klíčů.</span><span class="sxs-lookup"><span data-stu-id="cd371-144">Sequences also support operations such as grouping and counting by using key-generating functions.</span></span> <span data-ttu-id="cd371-145">Sekvence také podporují více různorodých funkcí pro extrakci dílčích sekvencí.</span><span class="sxs-lookup"><span data-stu-id="cd371-145">Sequences also support more diverse functions for extracting subsequences.</span></span>

<span data-ttu-id="cd371-146">Mnoho datových typů, například seznamy, pole, sady a mapy, jsou implicitně sekvencované, protože se jedná o vyčíslitelné kolekce.</span><span class="sxs-lookup"><span data-stu-id="cd371-146">Many data types, such as lists, arrays, sets, and maps are implicitly sequences because they are enumerable collections.</span></span> <span data-ttu-id="cd371-147">Funkce, která přebírá sekvenci jako argument funguje s libovolnými běžnými F# datovými typy, kromě libovolného datového typu .NET, který implementuje `System.Collections.Generic.IEnumerable<'T>`.</span><span class="sxs-lookup"><span data-stu-id="cd371-147">A function that takes a sequence as an argument works with any of the common F# data types, in addition to any .NET data type that implements `System.Collections.Generic.IEnumerable<'T>`.</span></span> <span data-ttu-id="cd371-148">Naproti tomu funkci, která přebírá seznam jako argument, který může přijímat jenom seznamy.</span><span class="sxs-lookup"><span data-stu-id="cd371-148">Contrast this to a function that takes a list as an argument, which can only take lists.</span></span> <span data-ttu-id="cd371-149">Typ `seq<'T>` je zkratka typu pro `IEnumerable<'T>`.</span><span class="sxs-lookup"><span data-stu-id="cd371-149">The type `seq<'T>` is a type abbreviation for `IEnumerable<'T>`.</span></span> <span data-ttu-id="cd371-150">To znamená, že každý typ, který implementuje obecné `System.Collections.Generic.IEnumerable<'T>`, včetně polí, seznamů, sad a map v F#a také většiny typů kolekcí .NET, je kompatibilní s typem `seq` a lze jej použít všude, kde je očekávána sekvence.</span><span class="sxs-lookup"><span data-stu-id="cd371-150">This means that any type that implements the generic `System.Collections.Generic.IEnumerable<'T>`, which includes arrays, lists, sets, and maps in F#, and also most .NET collection types, is compatible with the `seq` type and can be used wherever a sequence is expected.</span></span>

## <a name="module-functions"></a><span data-ttu-id="cd371-151">Funkce modulu</span><span class="sxs-lookup"><span data-stu-id="cd371-151">Module Functions</span></span>

<span data-ttu-id="cd371-152">[Modul SEQ](https://msdn.microsoft.com/library/54e8f059-ca52-4632-9ae9-49685ee9b684) v [oboru názvů Microsoft. FSharp. Collections](https://msdn.microsoft.com/library/24f64e5f-5030-47d0-9759-8d3e398ed13f) obsahuje funkce pro práci s sekvencemi.</span><span class="sxs-lookup"><span data-stu-id="cd371-152">The [Seq module](https://msdn.microsoft.com/library/54e8f059-ca52-4632-9ae9-49685ee9b684) in the [Microsoft.FSharp.Collections namespace](https://msdn.microsoft.com/library/24f64e5f-5030-47d0-9759-8d3e398ed13f) contains functions for working with sequences.</span></span> <span data-ttu-id="cd371-153">Tyto funkce fungují společně se seznamy, poli, mapami a sadami, protože všechny tyto typy jsou vyčíslitelné, a proto je lze považovat za sekvence.</span><span class="sxs-lookup"><span data-stu-id="cd371-153">These functions work with lists, arrays, maps, and sets as well, because all of those types are enumerable, and therefore can be treated as sequences.</span></span>

## <a name="creating-sequences"></a><span data-ttu-id="cd371-154">Vytváření sekvencí</span><span class="sxs-lookup"><span data-stu-id="cd371-154">Creating Sequences</span></span>

<span data-ttu-id="cd371-155">Můžete vytvářet sekvence pomocí výrazů pořadí, jak je popsáno výše, nebo pomocí určitých funkcí.</span><span class="sxs-lookup"><span data-stu-id="cd371-155">You can create sequences by using sequence expressions, as described previously, or by using certain functions.</span></span>

<span data-ttu-id="cd371-156">Prázdnou sekvenci lze vytvořit pomocí [Seq. Empty](https://msdn.microsoft.com/library/3c7f1c69-6117-4782-b2da-0e04d6854f59)nebo můžete vytvořit sekvenci pouze jednoho zadaného elementu pomocí [Seq. singleton](https://msdn.microsoft.com/library/9b8cc460-a282-4ec5-b29a-630ab17e9de7).</span><span class="sxs-lookup"><span data-stu-id="cd371-156">You can create an empty sequence by using [Seq.empty](https://msdn.microsoft.com/library/3c7f1c69-6117-4782-b2da-0e04d6854f59), or you can create a sequence of just one specified element by using [Seq.singleton](https://msdn.microsoft.com/library/9b8cc460-a282-4ec5-b29a-630ab17e9de7).</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/fssequences/snippet9.fs)]

<span data-ttu-id="cd371-157">Můžete použít [Seq. init](https://msdn.microsoft.com/library/059de69d-812c-4f8e-be86-88aa72101576) k vytvoření sekvence, pro kterou jsou vytvořeny prvky pomocí funkce, kterou zadáte.</span><span class="sxs-lookup"><span data-stu-id="cd371-157">You can use [Seq.init](https://msdn.microsoft.com/library/059de69d-812c-4f8e-be86-88aa72101576) to create a sequence for which the elements are created by using a function that you provide.</span></span> <span data-ttu-id="cd371-158">Můžete také zadat velikost sekvence.</span><span class="sxs-lookup"><span data-stu-id="cd371-158">You also provide a size for the sequence.</span></span> <span data-ttu-id="cd371-159">Tato funkce je stejná jako [list. init](https://msdn.microsoft.com/library/dd38c096-0ea8-4858-be6b-794b90418b83)s tím rozdílem, že elementy nejsou vytvořeny, dokud neprovedete iteraci v sekvenci.</span><span class="sxs-lookup"><span data-stu-id="cd371-159">This function is just like [List.init](https://msdn.microsoft.com/library/dd38c096-0ea8-4858-be6b-794b90418b83), except that the elements are not created until you iterate through the sequence.</span></span> <span data-ttu-id="cd371-160">Následující kód ilustruje použití funkce `Seq.init`.</span><span class="sxs-lookup"><span data-stu-id="cd371-160">The following code illustrates the use of `Seq.init`.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/fssequences/snippet10.fs)]

<span data-ttu-id="cd371-161">Výstup je</span><span class="sxs-lookup"><span data-stu-id="cd371-161">The output is</span></span>

```console
0 10 20 30 40
```

<span data-ttu-id="cd371-162">Pomocí funkcí [Seq. ofArray –](https://msdn.microsoft.com/library/299cd4d9-be72-4511-aac8-089e1ddaac99) a [Seq. ofList –&#60;t&#62; ](https://msdn.microsoft.com/visualfsharpdocs/conceptual/seq.oflist%5b%27t%5d-function-%5bfsharp%5d)můžete vytvářet sekvence z polí a seznamů.</span><span class="sxs-lookup"><span data-stu-id="cd371-162">By using [Seq.ofArray](https://msdn.microsoft.com/library/299cd4d9-be72-4511-aac8-089e1ddaac99) and [Seq.ofList&#60;'T&#62; Function](https://msdn.microsoft.com/visualfsharpdocs/conceptual/seq.oflist%5b%27t%5d-function-%5bfsharp%5d), you can create sequences from arrays and lists.</span></span> <span data-ttu-id="cd371-163">Pole a seznamy však můžete také převést na sekvence pomocí operátoru přetypování.</span><span class="sxs-lookup"><span data-stu-id="cd371-163">However, you can also convert arrays and lists to sequences by using a cast operator.</span></span> <span data-ttu-id="cd371-164">Obě metody jsou uvedeny v následujícím kódu.</span><span class="sxs-lookup"><span data-stu-id="cd371-164">Both techniques are shown in the following code.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/fssequences/snippet11.fs)]

<span data-ttu-id="cd371-165">Pomocí [Seq. cast](https://msdn.microsoft.com/library/1d087db3-a8b2-41dd-8ddc-227544529334)můžete vytvořit sekvenci ze slabě typované kolekce, jako jsou například definované v `System.Collections`.</span><span class="sxs-lookup"><span data-stu-id="cd371-165">By using [Seq.cast](https://msdn.microsoft.com/library/1d087db3-a8b2-41dd-8ddc-227544529334), you can create a sequence from a weakly typed collection, such as those defined in `System.Collections`.</span></span> <span data-ttu-id="cd371-166">Tyto slabě typové kolekce mají typ elementu `System.Object` a jsou vyčísleny pomocí neobecného `System.Collections.Generic.IEnumerable&#96;1`ho typu.</span><span class="sxs-lookup"><span data-stu-id="cd371-166">Such weakly typed collections have the element type `System.Object` and are enumerated by using the non-generic `System.Collections.Generic.IEnumerable&#96;1` type.</span></span> <span data-ttu-id="cd371-167">Následující kód ilustruje použití `Seq.cast` k převedení `System.Collections.ArrayList` do sekvence.</span><span class="sxs-lookup"><span data-stu-id="cd371-167">The following code illustrates the use of `Seq.cast` to convert an `System.Collections.ArrayList` into a sequence.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/fssequences/snippet12.fs)]

<span data-ttu-id="cd371-168">Můžete definovat nekonečné sekvence pomocí funkce [Seq. initInfinite –](https://msdn.microsoft.com/library/d1804e53-da92-48ec-8d6e-57eaf4c62bef) .</span><span class="sxs-lookup"><span data-stu-id="cd371-168">You can define infinite sequences by using the [Seq.initInfinite](https://msdn.microsoft.com/library/d1804e53-da92-48ec-8d6e-57eaf4c62bef) function.</span></span> <span data-ttu-id="cd371-169">Pro takové sekvence zadáte funkci, která generuje každý prvek z indexu elementu.</span><span class="sxs-lookup"><span data-stu-id="cd371-169">For such a sequence, you provide a function that generates each element from the index of the element.</span></span> <span data-ttu-id="cd371-170">Nekonečné sekvence jsou možné z důvodu opožděného vyhodnocení; prvky jsou vytvořeny podle potřeby voláním funkce, kterou zadáte.</span><span class="sxs-lookup"><span data-stu-id="cd371-170">Infinite sequences are possible because of lazy evaluation; elements are created as needed by calling the function that you specify.</span></span> <span data-ttu-id="cd371-171">Následující příklad kódu vytvoří nekonečnou sekvenci čísel s plovoucí desetinnou čárkou, v tomto případě alternující řady reciprocals čtverců po sobě jdoucích celých čísel.</span><span class="sxs-lookup"><span data-stu-id="cd371-171">The following code example produces an infinite sequence of floating point numbers, in this case the alternating series of reciprocals of squares of successive integers.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/fssequences/snippet13.fs)]

<span data-ttu-id="cd371-172">[Seq. unskládání](https://msdn.microsoft.com/library/7d9232fc-742e-42bc-bdf7-6f130f0eff21) generuje sekvenci z funkce výpočtu, která přebírá stav a transformuje ho za účelem vytvoření každého následného prvku v sekvenci.</span><span class="sxs-lookup"><span data-stu-id="cd371-172">[Seq.unfold](https://msdn.microsoft.com/library/7d9232fc-742e-42bc-bdf7-6f130f0eff21) generates a sequence from a computation function that takes a state and transforms it to produce each subsequent element in the sequence.</span></span> <span data-ttu-id="cd371-173">Stav je pouze hodnota, která se používá k výpočtu každého prvku a může se změnit při výpočtu každého prvku.</span><span class="sxs-lookup"><span data-stu-id="cd371-173">The state is just a value that is used to compute each element, and can change as each element is computed.</span></span> <span data-ttu-id="cd371-174">Druhý argument pro `Seq.unfold` je počáteční hodnota, která se používá ke spuštění sekvence.</span><span class="sxs-lookup"><span data-stu-id="cd371-174">The second argument to `Seq.unfold` is the initial value that is used to start the sequence.</span></span> <span data-ttu-id="cd371-175">`Seq.unfold` používá typ možnosti pro stav, který umožňuje ukončit sekvenci vrácením `None` hodnoty.</span><span class="sxs-lookup"><span data-stu-id="cd371-175">`Seq.unfold` uses an option type for the state, which enables you to terminate the sequence by returning the `None` value.</span></span> <span data-ttu-id="cd371-176">Následující kód ukazuje dva příklady sekvencí, `seq1` a `fib`, které jsou generovány operací `unfold`.</span><span class="sxs-lookup"><span data-stu-id="cd371-176">The following code shows two examples of sequences, `seq1` and `fib`, that are generated by an `unfold` operation.</span></span> <span data-ttu-id="cd371-177">První, `seq1`, je pouze jednoduchá sekvence s čísly až 20.</span><span class="sxs-lookup"><span data-stu-id="cd371-177">The first, `seq1`, is just a simple sequence with numbers up to 20.</span></span> <span data-ttu-id="cd371-178">Druhý `fib`používá `unfold` k výpočtu sekvence Fibonacci.</span><span class="sxs-lookup"><span data-stu-id="cd371-178">The second, `fib`, uses `unfold` to compute the Fibonacci sequence.</span></span> <span data-ttu-id="cd371-179">Vzhledem k tomu, že každý prvek v sekvenci Fibonacci je součtem předchozích dvou čísel Fibonacci, hodnota stavu je řazená kolekce členů, která se skládá z předchozích dvou čísel v sekvenci.</span><span class="sxs-lookup"><span data-stu-id="cd371-179">Because each element in the Fibonacci sequence is the sum of the previous two Fibonacci numbers, the state value is a tuple that consists of the previous two numbers in the sequence.</span></span> <span data-ttu-id="cd371-180">Počáteční hodnota je `(1,1)`, první dvě čísla v sekvenci.</span><span class="sxs-lookup"><span data-stu-id="cd371-180">The initial value is `(1,1)`, the first two numbers in the sequence.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/fssequences/snippet14.fs)]

<span data-ttu-id="cd371-181">Výstup je následující:</span><span class="sxs-lookup"><span data-stu-id="cd371-181">The output is as follows:</span></span>

```console
The sequence seq1 contains numbers from 0 to 20.

0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20

The sequence fib contains Fibonacci numbers.

2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597
```

<span data-ttu-id="cd371-182">Následující kód je příklad, který používá mnoho funkcí modulu Sequence popsaných tady pro generování a výpočet hodnot nekonečné sekvence.</span><span class="sxs-lookup"><span data-stu-id="cd371-182">The following code is an example that uses many of the sequence module functions described here to generate and compute the values of infinite sequences.</span></span> <span data-ttu-id="cd371-183">Spuštění kódu může trvat několik minut.</span><span class="sxs-lookup"><span data-stu-id="cd371-183">The code might take a few minutes to run.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/fssequences/snippet15.fs)]

## <a name="searching-and-finding-elements"></a><span data-ttu-id="cd371-184">Hledání a hledání elementů</span><span class="sxs-lookup"><span data-stu-id="cd371-184">Searching and Finding Elements</span></span>

<span data-ttu-id="cd371-185">Sekvence podporují funkce, které jsou k dispozici v seznamech: [Seq. Exists](https://msdn.microsoft.com/library/428c97bf-599d-4c39-a5b9-f8717c198ad1), [Seq. exists2 –](https://msdn.microsoft.com/library/efdf14a4-27f7-4dc1-9281-52639e66d565), [Seq. Find](https://msdn.microsoft.com/library/02c21ecd-97e5-4e99-a4c1-b4d0b730b7d8), [Seq. findIndex –](https://msdn.microsoft.com/library/96dfe86b-df15-4d92-8316-7cd6055e09f3), [Seq. vyskl](https://msdn.microsoft.com/library/a87bc771-55f7-43f9-94f9-33d8f9bf325d), [Seq. tryFind –](https://msdn.microsoft.com/library/ac43c6f5-4dc7-4e9a-a222-00b5736aee47)a [Seq. tryFindIndex –](https://msdn.microsoft.com/library/c357b221-edf6-4f68-bf40-82a3156d945a).</span><span class="sxs-lookup"><span data-stu-id="cd371-185">Sequences support functionality available with lists: [Seq.exists](https://msdn.microsoft.com/library/428c97bf-599d-4c39-a5b9-f8717c198ad1), [Seq.exists2](https://msdn.microsoft.com/library/efdf14a4-27f7-4dc1-9281-52639e66d565), [Seq.find](https://msdn.microsoft.com/library/02c21ecd-97e5-4e99-a4c1-b4d0b730b7d8), [Seq.findIndex](https://msdn.microsoft.com/library/96dfe86b-df15-4d92-8316-7cd6055e09f3), [Seq.pick](https://msdn.microsoft.com/library/a87bc771-55f7-43f9-94f9-33d8f9bf325d), [Seq.tryFind](https://msdn.microsoft.com/library/ac43c6f5-4dc7-4e9a-a222-00b5736aee47), and [Seq.tryFindIndex](https://msdn.microsoft.com/library/c357b221-edf6-4f68-bf40-82a3156d945a).</span></span> <span data-ttu-id="cd371-186">Verze těchto funkcí, které jsou k dispozici pro sekvence, vyhodnocují sekvenci pouze do hledaného prvku.</span><span class="sxs-lookup"><span data-stu-id="cd371-186">The versions of these functions that are available for sequences evaluate the sequence only up to the element that is being searched for.</span></span> <span data-ttu-id="cd371-187">Příklady najdete v tématu [seznam](https://msdn.microsoft.com/library/83102799-f251-42e1-93ef-64232e8c5b1d).</span><span class="sxs-lookup"><span data-stu-id="cd371-187">For examples, see [Lists](https://msdn.microsoft.com/library/83102799-f251-42e1-93ef-64232e8c5b1d).</span></span>

## <a name="obtaining-subsequences"></a><span data-ttu-id="cd371-188">Získání dílčích sekvencí</span><span class="sxs-lookup"><span data-stu-id="cd371-188">Obtaining Subsequences</span></span>

<span data-ttu-id="cd371-189">Příkazy [Seq. Filter](https://msdn.microsoft.com/library/7f2e9850-a660-460c-9831-3bbff5613770) a [Seq. Choose](https://msdn.microsoft.com/library/63b83b06-4b24-4239-bf69-a2c12d891395) se podobají odpovídajícím funkcím, které jsou k dispozici pro seznamy, s výjimkou toho, že filtrování a výběr se neprojeví, dokud se prvky sekvence nevyhodnotí.</span><span class="sxs-lookup"><span data-stu-id="cd371-189">[Seq.filter](https://msdn.microsoft.com/library/7f2e9850-a660-460c-9831-3bbff5613770) and [Seq.choose](https://msdn.microsoft.com/library/63b83b06-4b24-4239-bf69-a2c12d891395) are like the corresponding functions that are available for lists, except that the filtering and choosing does not occur until the sequence elements are evaluated.</span></span>

<span data-ttu-id="cd371-190">[Seq. oříznutí](https://msdn.microsoft.com/library/1892dfeb-308e-45e2-857a-3c3405d02244) vytvoří sekvenci z jiné sekvence, ale omezí sekvenci na zadaný počet prvků.</span><span class="sxs-lookup"><span data-stu-id="cd371-190">[Seq.truncate](https://msdn.microsoft.com/library/1892dfeb-308e-45e2-857a-3c3405d02244) creates a sequence from another sequence, but limits the sequence to a specified number of elements.</span></span> <span data-ttu-id="cd371-191">[Seq. pořídit](https://msdn.microsoft.com/library/6e75f701-640b-4c4a-9d63-4313fc090596) vytvoří novou sekvenci, která bude obsahovat pouze zadaný počet prvků od začátku sekvence.</span><span class="sxs-lookup"><span data-stu-id="cd371-191">[Seq.take](https://msdn.microsoft.com/library/6e75f701-640b-4c4a-9d63-4313fc090596) creates a new sequence that contains only a specified number of elements from the start of a sequence.</span></span> <span data-ttu-id="cd371-192">Pokud je v sekvenci méně prvků, než je určeno pro provedení, `Seq.take` vyvolá `System.InvalidOperationException`.</span><span class="sxs-lookup"><span data-stu-id="cd371-192">If there are fewer elements in the sequence than you specify to take, `Seq.take` throws a `System.InvalidOperationException`.</span></span> <span data-ttu-id="cd371-193">Rozdíl mezi `Seq.take` a `Seq.truncate` je, že `Seq.truncate` nevytvoří chybu, pokud je počet prvků menší než zadané číslo.</span><span class="sxs-lookup"><span data-stu-id="cd371-193">The difference between `Seq.take` and `Seq.truncate` is that `Seq.truncate` does not produce an error if the number of elements is fewer than the number you specify.</span></span>

<span data-ttu-id="cd371-194">Následující kód ukazuje chování a rozdíly mezi `Seq.truncate` a `Seq.take`.</span><span class="sxs-lookup"><span data-stu-id="cd371-194">The following code shows the behavior of and differences between `Seq.truncate` and `Seq.take`.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/fssequences/snippet16.fs)]

<span data-ttu-id="cd371-195">Výstup, před výskytem chyby, je následující.</span><span class="sxs-lookup"><span data-stu-id="cd371-195">The output, before the error occurs, is as follows.</span></span>

```console
1 4 9 16 25
1 4 9 16 25 36 49 64 81 100
1 4 9 16 25
1 4 9 16 25 36 49 64 81 100
```

<span data-ttu-id="cd371-196">Pomocí [Seq. TakeWhile –](https://msdn.microsoft.com/library/19eea4ce-66e0-4353-b015-72eb03421d92)lze zadat funkci predikátu (logická funkce) a vytvořit sekvenci z jiné sekvence, která je tvořena těmito prvky původní sekvence, pro kterou je predikát `true`, ale zastavit před prvním prvkem pro který predikát vrací `false`.</span><span class="sxs-lookup"><span data-stu-id="cd371-196">By using [Seq.takeWhile](https://msdn.microsoft.com/library/19eea4ce-66e0-4353-b015-72eb03421d92), you can specify a predicate function (a Boolean function) and create a sequence from another sequence made up of those elements of the original sequence for which the predicate is `true`, but stop before the first element for which the predicate returns `false`.</span></span> <span data-ttu-id="cd371-197">[Seq. Skip](https://msdn.microsoft.com/library/b4eb3f08-8594-4d17-8180-852c6c688bf1) vrátí sekvenci, která přeskočí zadaný počet prvních prvků v jiné sekvenci a vrátí zbývající prvky.</span><span class="sxs-lookup"><span data-stu-id="cd371-197">[Seq.skip](https://msdn.microsoft.com/library/b4eb3f08-8594-4d17-8180-852c6c688bf1) returns a sequence that skips a specified number of the first elements of another sequence and returns the remaining elements.</span></span> <span data-ttu-id="cd371-198">[Seq. SkipWhile –](https://msdn.microsoft.com/library/fb729021-2a3c-430f-83c3-0b37526f1a16) vrací sekvenci, která přeskočí první prvky jiné sekvence, pokud predikát vrátí `true`a vrátí zbývající prvky počínaje prvním prvkem, pro který predikát vrátí `false`.</span><span class="sxs-lookup"><span data-stu-id="cd371-198">[Seq.skipWhile](https://msdn.microsoft.com/library/fb729021-2a3c-430f-83c3-0b37526f1a16) returns a sequence that skips the first elements of another sequence as long as the predicate returns `true`, and then returns the remaining elements, starting with the first element for which the predicate returns `false`.</span></span>

<span data-ttu-id="cd371-199">Následující příklad kódu ilustruje chování a rozdíly mezi `Seq.takeWhile`, `Seq.skip`a `Seq.skipWhile`.</span><span class="sxs-lookup"><span data-stu-id="cd371-199">The following code example illustrates the behavior of and differences between `Seq.takeWhile`, `Seq.skip`, and `Seq.skipWhile`.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/fssequences/snippet17.fs)]

<span data-ttu-id="cd371-200">Výstup je následující.</span><span class="sxs-lookup"><span data-stu-id="cd371-200">The output is as follows.</span></span>

```console
1 4 9
36 49 64 81 100
16 25 36 49 64 81 100
```

## <a name="transforming-sequences"></a><span data-ttu-id="cd371-201">Transformace sekvencí</span><span class="sxs-lookup"><span data-stu-id="cd371-201">Transforming Sequences</span></span>

<span data-ttu-id="cd371-202">[Seq.](https://msdn.microsoft.com/library/210dcf26-4e24-4d83-af6d-a8288b2ae4b1) Pairwise vytvoří nové pořadí, ve kterém jsou po sobě následující prvky vstupní sekvence seskupeny do řazených kolekcí členů.</span><span class="sxs-lookup"><span data-stu-id="cd371-202">[Seq.pairwise](https://msdn.microsoft.com/library/210dcf26-4e24-4d83-af6d-a8288b2ae4b1) creates a new sequence in which successive elements of the input sequence are grouped into tuples.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/fssequences/snippet18.fs)]

<span data-ttu-id="cd371-203">[Seq. windowed](https://msdn.microsoft.com/library/8b565b8f-d645-4dba-be22-099075fe4744) je like `Seq.pairwise`, s výjimkou, že namísto vytváření posloupnosti řazených kolekcí členů vytvoří sekvenci polí, které obsahují kopie sousedících prvků ( *okno*) z sekvence.</span><span class="sxs-lookup"><span data-stu-id="cd371-203">[Seq.windowed](https://msdn.microsoft.com/library/8b565b8f-d645-4dba-be22-099075fe4744) is like `Seq.pairwise`, except that instead of producing a sequence of tuples, it produces a sequence of arrays that contain copies of adjacent elements (a *window*) from the sequence.</span></span> <span data-ttu-id="cd371-204">Zadejte počet sousedících prvků, které mají být v každém poli.</span><span class="sxs-lookup"><span data-stu-id="cd371-204">You specify the number of adjacent elements you want in each array.</span></span>

<span data-ttu-id="cd371-205">Následující příklad kódu ukazuje použití `Seq.windowed`.</span><span class="sxs-lookup"><span data-stu-id="cd371-205">The following code example demonstrates the use of `Seq.windowed`.</span></span> <span data-ttu-id="cd371-206">V tomto případě počet prvků v okně je 3.</span><span class="sxs-lookup"><span data-stu-id="cd371-206">In this case the number of elements in the window is 3.</span></span> <span data-ttu-id="cd371-207">V příkladu se používá `printSeq`, který je definován v předchozím příkladu kódu.</span><span class="sxs-lookup"><span data-stu-id="cd371-207">The example uses `printSeq`, which is defined in the previous code example.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/fssequences/snippet180.fs)]

<span data-ttu-id="cd371-208">Výstup je následující.</span><span class="sxs-lookup"><span data-stu-id="cd371-208">The output is as follows.</span></span>

<span data-ttu-id="cd371-209">Počáteční sekvence:</span><span class="sxs-lookup"><span data-stu-id="cd371-209">Initial sequence:</span></span>

```console
1.0 1.5 2.0 1.5 1.0 1.5

Windows of length 3:
[|1.0; 1.5; 2.0|] [|1.5; 2.0; 1.5|] [|2.0; 1.5; 1.0|] [|1.5; 1.0; 1.5|]

Moving average:
1.5 1.666666667 1.5 1.333333333
```

## <a name="operations-with-multiple-sequences"></a><span data-ttu-id="cd371-210">Operace s více sekvencemi</span><span class="sxs-lookup"><span data-stu-id="cd371-210">Operations with Multiple Sequences</span></span>

<span data-ttu-id="cd371-211">[Seq. zip](https://msdn.microsoft.com/library/0a5df8bf-0d48-44ce-bff4-e8ef1df5bca4) a [Seq. zip3 –](https://msdn.microsoft.com/library/ef13bebb-22ae-4eb9-873b-87dd29154d16) přebírají dvě nebo tři sekvence a vytvoří sekvenci řazených kolekcí členů.</span><span class="sxs-lookup"><span data-stu-id="cd371-211">[Seq.zip](https://msdn.microsoft.com/library/0a5df8bf-0d48-44ce-bff4-e8ef1df5bca4) and [Seq.zip3](https://msdn.microsoft.com/library/ef13bebb-22ae-4eb9-873b-87dd29154d16) take two or three sequences and produce a sequence of tuples.</span></span> <span data-ttu-id="cd371-212">Tyto funkce jsou podobné odpovídajícím funkcím, které jsou k dispozici pro [seznamy](https://msdn.microsoft.com/library/83102799-f251-42e1-93ef-64232e8c5b1d).</span><span class="sxs-lookup"><span data-stu-id="cd371-212">These functions are like the corresponding functions available for [lists](https://msdn.microsoft.com/library/83102799-f251-42e1-93ef-64232e8c5b1d).</span></span> <span data-ttu-id="cd371-213">Neexistuje žádná odpovídající funkce pro oddělení jedné sekvence do dvou nebo více sekvencí.</span><span class="sxs-lookup"><span data-stu-id="cd371-213">There is no corresponding functionality to separate one sequence into two or more sequences.</span></span> <span data-ttu-id="cd371-214">Pokud tuto funkci pro sekvenci potřebujete, převeďte ji na seznam a použijte [seznam. dekomprimovat](https://msdn.microsoft.com/library/639db80c-41b5-45bb-a6b4-1eaa04d61d21).</span><span class="sxs-lookup"><span data-stu-id="cd371-214">If you need this functionality for a sequence, convert the sequence to a list and use [List.unzip](https://msdn.microsoft.com/library/639db80c-41b5-45bb-a6b4-1eaa04d61d21).</span></span>

## <a name="sorting-comparing-and-grouping"></a><span data-ttu-id="cd371-215">Řazení, porovnávání a seskupování</span><span class="sxs-lookup"><span data-stu-id="cd371-215">Sorting, Comparing, and Grouping</span></span>

<span data-ttu-id="cd371-216">Funkce řazení podporované pro seznamy také fungují s sekvencemi.</span><span class="sxs-lookup"><span data-stu-id="cd371-216">The sorting functions supported for lists also work with sequences.</span></span> <span data-ttu-id="cd371-217">To zahrnuje [Seq. Sort](https://msdn.microsoft.com/library/327ea595-e77c-4529-b61e-8c6cbf5ec92e) a [Seq. sortBy](https://msdn.microsoft.com/library/4f8b4fb9-bf20-49d9-b4ee-dcc906c8208f).</span><span class="sxs-lookup"><span data-stu-id="cd371-217">This includes [Seq.sort](https://msdn.microsoft.com/library/327ea595-e77c-4529-b61e-8c6cbf5ec92e) and [Seq.sortBy](https://msdn.microsoft.com/library/4f8b4fb9-bf20-49d9-b4ee-dcc906c8208f).</span></span> <span data-ttu-id="cd371-218">Tyto funkce iterují celou sekvenci.</span><span class="sxs-lookup"><span data-stu-id="cd371-218">These functions iterate through the whole sequence.</span></span>

<span data-ttu-id="cd371-219">Porovnáte dvě sekvence pomocí funkce [Seq. compareWith –](https://msdn.microsoft.com/library/5a740135-0b3a-4545-816f-8f91cc31290f) .</span><span class="sxs-lookup"><span data-stu-id="cd371-219">You compare two sequences by using the [Seq.compareWith](https://msdn.microsoft.com/library/5a740135-0b3a-4545-816f-8f91cc31290f) function.</span></span> <span data-ttu-id="cd371-220">Funkce porovná úspěšné prvky a zastaví, když nalezne první neshodnou dvojici.</span><span class="sxs-lookup"><span data-stu-id="cd371-220">The function compares successive elements in turn, and stops when it encounters the first unequal pair.</span></span> <span data-ttu-id="cd371-221">Žádné další prvky nepřispívají k porovnání.</span><span class="sxs-lookup"><span data-stu-id="cd371-221">Any additional elements do not contribute to the comparison.</span></span>

<span data-ttu-id="cd371-222">Následující kód ukazuje použití `Seq.compareWith`.</span><span class="sxs-lookup"><span data-stu-id="cd371-222">The following code shows the use of `Seq.compareWith`.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/fssequences/snippet19.fs)]

<span data-ttu-id="cd371-223">V předchozím kódu je vypočítán a zkontrolován pouze první prvek a výsledkem je-1.</span><span class="sxs-lookup"><span data-stu-id="cd371-223">In the previous code, only the first element is computed and examined, and the result is -1.</span></span>

<span data-ttu-id="cd371-224">[Seq. CountBy –](https://msdn.microsoft.com/library/721702a5-150e-4fe8-81cd-ffbf8476cc1f) přebírá funkci, která generuje hodnotu nazvanou *klíč* pro každý prvek.</span><span class="sxs-lookup"><span data-stu-id="cd371-224">[Seq.countBy](https://msdn.microsoft.com/library/721702a5-150e-4fe8-81cd-ffbf8476cc1f) takes a function that generates a value called a *key* for each element.</span></span> <span data-ttu-id="cd371-225">Klíč je vygenerován pro každý prvek voláním této funkce na každý prvek.</span><span class="sxs-lookup"><span data-stu-id="cd371-225">A key is generated for each element by calling this function on each element.</span></span> <span data-ttu-id="cd371-226">`Seq.countBy` pak vrátí sekvenci, která obsahuje hodnoty klíče, a počet prvků, které vygenerovaly jednotlivé hodnoty klíče.</span><span class="sxs-lookup"><span data-stu-id="cd371-226">`Seq.countBy` then returns a sequence that contains the key values, and a count of the number of elements that generated each value of the key.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/fssequences/snippet201.fs)]

<span data-ttu-id="cd371-227">Výstup je následující.</span><span class="sxs-lookup"><span data-stu-id="cd371-227">The output is as follows.</span></span>

```console
(1, 34) (2, 33) (0, 33)
```

<span data-ttu-id="cd371-228">Předchozí výstup ukazuje, že byly 34 prvky původní sekvence, které vytvořily hodnoty klíče 1, 33 hodnoty, které vytvořily klíč 2, a 33 hodnoty, které vytvořily klíč 0.</span><span class="sxs-lookup"><span data-stu-id="cd371-228">The previous output shows that there were 34 elements of the original sequence that produced the key 1, 33 values that produced the key 2, and 33 values that produced the key 0.</span></span>

<span data-ttu-id="cd371-229">Prvky sekvence lze seskupit voláním [Seq. GroupBy](https://msdn.microsoft.com/library/d46a04df-1a42-40cc-a368-058c9c5806fd).</span><span class="sxs-lookup"><span data-stu-id="cd371-229">You can group elements of a sequence by calling [Seq.groupBy](https://msdn.microsoft.com/library/d46a04df-1a42-40cc-a368-058c9c5806fd).</span></span> <span data-ttu-id="cd371-230">`Seq.groupBy` přebírá sekvenci a funkci, která generuje klíč z prvku.</span><span class="sxs-lookup"><span data-stu-id="cd371-230">`Seq.groupBy` takes a sequence and a function that generates a key from an element.</span></span> <span data-ttu-id="cd371-231">Funkce je spuštěna u každého prvku sekvence.</span><span class="sxs-lookup"><span data-stu-id="cd371-231">The function is executed on each element of the sequence.</span></span> <span data-ttu-id="cd371-232">`Seq.groupBy` vrací sekvenci řazených kolekcí členů, kde první prvek každé řazené kolekce členů je klíč a druhá je sekvence prvků, které tvoří tento klíč.</span><span class="sxs-lookup"><span data-stu-id="cd371-232">`Seq.groupBy` returns a sequence of tuples, where the first element of each tuple is the key and the second is a sequence of elements that produce that key.</span></span>

<span data-ttu-id="cd371-233">Následující příklad kódu ukazuje použití `Seq.groupBy` pro rozdělení posloupnosti čísel od 1 do 100 do tří skupin, které mají jedinečné hodnoty klíče 0, 1 a 2.</span><span class="sxs-lookup"><span data-stu-id="cd371-233">The following code example shows the use of `Seq.groupBy` to partition the sequence of numbers from 1 to 100 into three groups that have the distinct key values 0, 1, and 2.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/fssequences/snippet202.fs)]

<span data-ttu-id="cd371-234">Výstup je následující.</span><span class="sxs-lookup"><span data-stu-id="cd371-234">The output is as follows.</span></span>

```console
(1, seq [1; 4; 7; 10; ...]) (2, seq [2; 5; 8; 11; ...]) (0, seq [3; 6; 9; 12; ...])
```

<span data-ttu-id="cd371-235">Můžete vytvořit sekvenci, která eliminuje duplicitní prvky voláním [Seq. DISTINCT](https://msdn.microsoft.com/library/99d01014-7e0e-4e7b-9d0a-41a61d93f401).</span><span class="sxs-lookup"><span data-stu-id="cd371-235">You can create a sequence that eliminates duplicate elements by calling [Seq.distinct](https://msdn.microsoft.com/library/99d01014-7e0e-4e7b-9d0a-41a61d93f401).</span></span> <span data-ttu-id="cd371-236">Případně můžete použít [Seq. distinctBy –](https://msdn.microsoft.com/library/9293293b-9420-49c8-848f-401a9cd49b75), který převezme funkci generování klíčů, která má být volána u každého prvku.</span><span class="sxs-lookup"><span data-stu-id="cd371-236">Or you can use [Seq.distinctBy](https://msdn.microsoft.com/library/9293293b-9420-49c8-848f-401a9cd49b75), which takes a key-generating function to be called on each element.</span></span> <span data-ttu-id="cd371-237">Výsledná sekvence obsahuje prvky původní sekvence, které mají jedinečné klíče; později prvky, které vytvoří duplicitní klíč k dřívějšímu prvku, jsou zahozeny.</span><span class="sxs-lookup"><span data-stu-id="cd371-237">The resulting sequence contains elements of the original sequence that have unique keys; later elements that produce a duplicate key to an earlier element are discarded.</span></span>

<span data-ttu-id="cd371-238">Následující příklad kódu ukazuje použití `Seq.distinct`.</span><span class="sxs-lookup"><span data-stu-id="cd371-238">The following code example illustrates the use of `Seq.distinct`.</span></span> <span data-ttu-id="cd371-239">`Seq.distinct` je znázorněno vygenerováním sekvencí, které představují binární čísla, a následným zobrazením, že jediné samostatné prvky jsou 0 a 1.</span><span class="sxs-lookup"><span data-stu-id="cd371-239">`Seq.distinct` is demonstrated by generating sequences that represent binary numbers, and then showing that the only distinct elements are 0 and 1.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/fssequences/snippet22.fs)]

<span data-ttu-id="cd371-240">Následující kód demonstruje `Seq.distinctBy` pomocí sekvence, která obsahuje záporné a kladné číslo a pomocí funkce absolutní hodnoty jako funkce pro generování klíčů.</span><span class="sxs-lookup"><span data-stu-id="cd371-240">The following code demonstrates `Seq.distinctBy` by starting with a sequence that contains negative and positive numbers and using the absolute value function as the key-generating function.</span></span> <span data-ttu-id="cd371-241">V výsledné sekvenci chybí všechna kladná čísla, která odpovídají záporným číslům v sekvenci, protože záporná čísla se objeví dříve v sekvenci, a proto jsou vybrána místo kladného čísla, která mají stejnou absolutní hodnotu. hodnota nebo klíč.</span><span class="sxs-lookup"><span data-stu-id="cd371-241">The resulting sequence is missing all the positive numbers that correspond to the negative numbers in the sequence, because the negative numbers appear earlier in the sequence and therefore are selected instead of the positive numbers that have the same absolute value, or key.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/fssequences/snippet23.fs)]

## <a name="readonly-and-cached-sequences"></a><span data-ttu-id="cd371-242">Jen pro čtení a posloupnosti v mezipaměti</span><span class="sxs-lookup"><span data-stu-id="cd371-242">Readonly and Cached Sequences</span></span>

<span data-ttu-id="cd371-243">[Seq. ReadOnly](https://msdn.microsoft.com/library/88059cb4-3bb0-4126-9448-fbcd48fe13a7) vytvoří kopii sekvence jen pro čtení.</span><span class="sxs-lookup"><span data-stu-id="cd371-243">[Seq.readonly](https://msdn.microsoft.com/library/88059cb4-3bb0-4126-9448-fbcd48fe13a7) creates a read-only copy of a sequence.</span></span> <span data-ttu-id="cd371-244">`Seq.readonly` je užitečné v případě, že máte kolekci pro čtení i zápis, jako je například pole, a nechcete změnit původní kolekci.</span><span class="sxs-lookup"><span data-stu-id="cd371-244">`Seq.readonly` is useful when you have a read-write collection, such as an array, and you do not want to modify the original collection.</span></span> <span data-ttu-id="cd371-245">Tato funkce se dá použít k zachování zapouzdření dat.</span><span class="sxs-lookup"><span data-stu-id="cd371-245">This function can be used to preserve data encapsulation.</span></span> <span data-ttu-id="cd371-246">V následujícím příkladu kódu je vytvořen typ, který obsahuje pole.</span><span class="sxs-lookup"><span data-stu-id="cd371-246">In the following code example, a type that contains an array is created.</span></span> <span data-ttu-id="cd371-247">Vlastnost zpřístupňuje pole, ale místo vrácení pole vrátí sekvenci, která je vytvořena z pole pomocí `Seq.readonly`.</span><span class="sxs-lookup"><span data-stu-id="cd371-247">A property exposes the array, but instead of returning an array, it returns a sequence that is created from the array by using `Seq.readonly`.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/fssequences/snippet24.fs)]

<span data-ttu-id="cd371-248">[Seq. cache](https://msdn.microsoft.com/library/d197f9cc-08bf-4986-9869-246e72ca73f0) vytvoří uloženou verzi sekvence.</span><span class="sxs-lookup"><span data-stu-id="cd371-248">[Seq.cache](https://msdn.microsoft.com/library/d197f9cc-08bf-4986-9869-246e72ca73f0) creates a stored version of a sequence.</span></span> <span data-ttu-id="cd371-249">Použijte `Seq.cache`, abyste zabránili opakovanému vyhodnocení sekvence nebo pokud máte více vláken, která používají sekvenci, ale je nutné se ujistit, že každý prvek bude pracovat pouze v jednom okamžiku.</span><span class="sxs-lookup"><span data-stu-id="cd371-249">Use `Seq.cache` to avoid reevaluation of a sequence, or when you have multiple threads that use a sequence, but you must make sure that each element is acted upon only one time.</span></span> <span data-ttu-id="cd371-250">Máte-li sekvenci, která je používána více vlákny, můžete mít jedno vlákno, které vytvoří výčet a vypočítá hodnoty pro původní sekvenci a zbývající vlákna mohou použít sekvenci uloženou v mezipaměti.</span><span class="sxs-lookup"><span data-stu-id="cd371-250">When you have a sequence that is being used by multiple threads, you can have one thread that enumerates and computes the values for the original sequence, and remaining threads can use the cached sequence.</span></span>

## <a name="performing-computations-on-sequences"></a><span data-ttu-id="cd371-251">Provádění výpočtů na sekvencích</span><span class="sxs-lookup"><span data-stu-id="cd371-251">Performing Computations on Sequences</span></span>

<span data-ttu-id="cd371-252">Jednoduché aritmetické operace jsou podobné jako u seznamů, například [Seq. Average](https://msdn.microsoft.com/library/609d793b-c70f-4e36-9ab4-d928056d65b8), [Seq. Sum](https://msdn.microsoft.com/library/01208515-4880-4358-91f5-af34f66dc77a), [Seq. averageBy –](https://msdn.microsoft.com/library/47c855c1-2dbd-415a-885e-b909d9d3e4f8), [Seq. sumBy –](https://msdn.microsoft.com/library/68cca78c-94ed-4a45-9b8d-34d2c5f2b1b1)a tak dále.</span><span class="sxs-lookup"><span data-stu-id="cd371-252">Simple arithmetic operations are like those of lists, such as [Seq.average](https://msdn.microsoft.com/library/609d793b-c70f-4e36-9ab4-d928056d65b8), [Seq.sum](https://msdn.microsoft.com/library/01208515-4880-4358-91f5-af34f66dc77a), [Seq.averageBy](https://msdn.microsoft.com/library/47c855c1-2dbd-415a-885e-b909d9d3e4f8), [Seq.sumBy](https://msdn.microsoft.com/library/68cca78c-94ed-4a45-9b8d-34d2c5f2b1b1), and so on.</span></span>

<span data-ttu-id="cd371-253">[Seq. reskládání](https://msdn.microsoft.com/library/30c4c95a-9563-4c96-bbe1-f7aacfd026e3), [Seq. zmenšení](https://msdn.microsoft.com/library/a2ad4f64-ac69-47d2-92f0-7173d9dfeae9)a [Seq. Scan](https://msdn.microsoft.com/library/7e2d23e9-f153-4411-a884-b6d415ff627e) jsou podobné odpovídající funkce, které jsou k dispozici pro seznamy.</span><span class="sxs-lookup"><span data-stu-id="cd371-253">[Seq.fold](https://msdn.microsoft.com/library/30c4c95a-9563-4c96-bbe1-f7aacfd026e3), [Seq.reduce](https://msdn.microsoft.com/library/a2ad4f64-ac69-47d2-92f0-7173d9dfeae9), and [Seq.scan](https://msdn.microsoft.com/library/7e2d23e9-f153-4411-a884-b6d415ff627e) are like the corresponding functions that are available for lists.</span></span> <span data-ttu-id="cd371-254">Sekvence podporují podmnožinu úplných variací těchto funkcí, které seznam podporují.</span><span class="sxs-lookup"><span data-stu-id="cd371-254">Sequences support a subset of the full variations of these functions that lists support.</span></span> <span data-ttu-id="cd371-255">Další informace a příklady najdete v tématu [seznam](lists.md).</span><span class="sxs-lookup"><span data-stu-id="cd371-255">For more information and examples, see [Lists](lists.md).</span></span>

## <a name="see-also"></a><span data-ttu-id="cd371-256">Viz také:</span><span class="sxs-lookup"><span data-stu-id="cd371-256">See also</span></span>

- [<span data-ttu-id="cd371-257">Referenční dokumentace jazyka F#</span><span class="sxs-lookup"><span data-stu-id="cd371-257">F# Language Reference</span></span>](index.md)
- [<span data-ttu-id="cd371-258">Typy F#</span><span class="sxs-lookup"><span data-stu-id="cd371-258">F# Types</span></span>](fsharp-types.md)
