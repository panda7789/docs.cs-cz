---
title: Hodnoty (F#)
description: 'Zjistěte, jak jsou množství, které mají konkrétní typ hodnoty v jazyce F #.'
ms.date: 05/16/2016
ms.openlocfilehash: f645481ce8395c11ae920aee06cbf07955aeb684
ms.sourcegitcommit: 64f4baed249341e5bf64d1385bf48e3f2e1a0211
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 09/07/2018
ms.locfileid: "44078831"
---
# <a name="values"></a><span data-ttu-id="9b038-103">Hodnoty</span><span class="sxs-lookup"><span data-stu-id="9b038-103">Values</span></span>

<span data-ttu-id="9b038-104">Hodnoty v jazyce F # jsou množství, které mají konkrétní typ; hodnoty může být integrálního typu nebo plovoucí desetinnou čárkou, znaky nebo hodnoty text, seznamy, pořadí, pole, řazených kolekcí členů, rozlišovaná sjednocení, záznamy, typy tříd nebo funkce.</span><span class="sxs-lookup"><span data-stu-id="9b038-104">Values in F# are quantities that have a specific type; values can be integral or floating point numbers, characters or text, lists, sequences, arrays, tuples, discriminated unions, records, class types, or function values.</span></span>

## <a name="binding-a-value"></a><span data-ttu-id="9b038-105">Po navázání hodnoty</span><span class="sxs-lookup"><span data-stu-id="9b038-105">Binding a Value</span></span>

<span data-ttu-id="9b038-106">Termín *vazby* znamená, že název přidružení definici.</span><span class="sxs-lookup"><span data-stu-id="9b038-106">The term *binding* means associating a name with a definition.</span></span> <span data-ttu-id="9b038-107">`let` – Klíčové slovo sváže hodnotu, stejně jako v následujících příkladech:</span><span class="sxs-lookup"><span data-stu-id="9b038-107">The `let` keyword binds a value, as in the following examples:</span></span>

[!code-fsharp[Main](../../../../samples/snippets/fsharp/lang-ref-1/snippet601.fs)]

<span data-ttu-id="9b038-108">Typ hodnoty je odvozen z definice.</span><span class="sxs-lookup"><span data-stu-id="9b038-108">The type of a value is inferred from the definition.</span></span> <span data-ttu-id="9b038-109">Pro primitivní typ, jako je číslo s plovoucí desetinnou čárkou nebo celočíselné bod je určen typ z typu literál.</span><span class="sxs-lookup"><span data-stu-id="9b038-109">For a primitive type, such as an integral or floating point number, the type is determined from the type of the literal.</span></span> <span data-ttu-id="9b038-110">Proto v předchozím příkladu, kompilátor odvodí typ `b` bude `unsigned int`, že kompilátor odvodí typ `a` bude `int`.</span><span class="sxs-lookup"><span data-stu-id="9b038-110">Therefore, in the previous example, the compiler infers the type of `b` to be `unsigned int`, whereas the compiler infers the type of `a` to be `int`.</span></span> <span data-ttu-id="9b038-111">Typ hodnoty funkci je určen z návratové hodnoty v těle funkce.</span><span class="sxs-lookup"><span data-stu-id="9b038-111">The type of a function value is determined from the return value in the function body.</span></span> <span data-ttu-id="9b038-112">Další informace o typech hodnot funkce, najdete v části [funkce](../functions/index.md).</span><span class="sxs-lookup"><span data-stu-id="9b038-112">For more information about function value types, see [Functions](../functions/index.md).</span></span> <span data-ttu-id="9b038-113">Další informace o typy literálu, naleznete v tématu [literály](../literals.md).</span><span class="sxs-lookup"><span data-stu-id="9b038-113">For more information about literal types, see [Literals](../literals.md).</span></span>

<span data-ttu-id="9b038-114">Kompilátor nevyvolá diagnostiky o nevyužitých vazby ve výchozím nastavení.</span><span class="sxs-lookup"><span data-stu-id="9b038-114">The compiler does not issue diagnostics about unused bindings by default.</span></span> <span data-ttu-id="9b038-115">Pro příjem těchto zpráv, povolte upozornění 1182 v souboru projektu nebo při vyvolání kompilátoru (viz `--warnon` v části [– možnosti kompilátoru](../compiler-options.md)).</span><span class="sxs-lookup"><span data-stu-id="9b038-115">To receive these messages, enable warning 1182 in your project file or when invoking the compiler (see `--warnon` under [Compiler Options](../compiler-options.md)).</span></span>

## <a name="why-immutable"></a><span data-ttu-id="9b038-116">Důvod, proč neměnné?</span><span class="sxs-lookup"><span data-stu-id="9b038-116">Why Immutable?</span></span>

<span data-ttu-id="9b038-117">Neměnné hodnoty jsou hodnoty, které nelze změnit během provádění programu.</span><span class="sxs-lookup"><span data-stu-id="9b038-117">Immutable values are values that cannot be changed throughout the course of a program's execution.</span></span> <span data-ttu-id="9b038-118">Pokud se používají pro jazyky, jako je například C++, Visual Basic nebo C#, je možné překvapivé, že F # umístí nadřazenost přes neměnné hodnoty a nikoli proměnné, které je možné přiřadit nové hodnoty během provádění programu.</span><span class="sxs-lookup"><span data-stu-id="9b038-118">If you are used to languages such as C++, Visual Basic, or C#, you might find it surprising that F# puts primacy over immutable values rather than variables that can be assigned new values during the execution of a program.</span></span> <span data-ttu-id="9b038-119">Neměnnými daty je důležitý prvek, funkční programování.</span><span class="sxs-lookup"><span data-stu-id="9b038-119">Immutable data is an important element of functional programming.</span></span> <span data-ttu-id="9b038-120">V prostředí s více vlákny jsou těžko spravuje sdílené proměnlivé proměnné, které lze změnit tím, že mnoho různých vlákna.</span><span class="sxs-lookup"><span data-stu-id="9b038-120">In a multithreaded environment, shared mutable variables that can be changed by many different threads are difficult to manage.</span></span> <span data-ttu-id="9b038-121">Kromě toho s proměnlivými proměnnými, může být někdy obtížné zjistit, pokud proměnné může být změněn, pokud je předána do jiné funkce.</span><span class="sxs-lookup"><span data-stu-id="9b038-121">Also, with mutable variables, it can sometimes be hard to tell if a variable might be changed when it is passed to another function.</span></span>

<span data-ttu-id="9b038-122">V čistě funkčních jazyků nejsou žádné proměnné a funkce se chovají výhradně jako matematických funkcí.</span><span class="sxs-lookup"><span data-stu-id="9b038-122">In pure functional languages, there are no variables, and functions behave strictly as mathematical functions.</span></span> <span data-ttu-id="9b038-123">Pokud kód v procedurální jazyk používá přiřazení proměnné změnit hodnotu, má ekvivalentní kód v jazyce funkční neměnné hodnotu, která je vstup, neměnné funkce a různé hodnoty neměnné jako výstup.</span><span class="sxs-lookup"><span data-stu-id="9b038-123">Where code in a procedural language uses a variable assignment to alter a value, the equivalent code in a functional language has an immutable value that is the input, an immutable function, and different immutable values as the output.</span></span> <span data-ttu-id="9b038-124">Tato matematické přísnosti umožňuje užší důvody týkající se chování programu.</span><span class="sxs-lookup"><span data-stu-id="9b038-124">This mathematical strictness allows for tighter reasoning about the behavior of the program.</span></span> <span data-ttu-id="9b038-125">Tato užší reasoning je díky kompilátory přísněji kontrolovat kód a optimalizovat efektivněji a pomáhá zjednodušit vývojářům pochopit a psát správný kód.</span><span class="sxs-lookup"><span data-stu-id="9b038-125">This tighter reasoning is what enables compilers to check code more stringently and to optimize more effectively, and helps make it easier for developers to understand and write correct code.</span></span> <span data-ttu-id="9b038-126">Funkční kód je proto pravděpodobně budou snadněji ladit než běžné kódu procedury.</span><span class="sxs-lookup"><span data-stu-id="9b038-126">Functional code is therefore likely to be easier to debug than ordinary procedural code.</span></span>

<span data-ttu-id="9b038-127">F # čistě funkční jazyk, ještě není plně podporuje funkční programování.</span><span class="sxs-lookup"><span data-stu-id="9b038-127">F# is not a pure functional language, yet it fully supports functional programming.</span></span> <span data-ttu-id="9b038-128">Použití neměnné hodnot je vhodné, protože díky tomu se váš kód, abyste využili výhod důležitou součástí funkčního programování.</span><span class="sxs-lookup"><span data-stu-id="9b038-128">Using immutable values is a good practice because doing this allows your code to benefit from an important aspect of functional programming.</span></span>

## <a name="mutable-variables"></a><span data-ttu-id="9b038-129">Proměnlivé proměnné</span><span class="sxs-lookup"><span data-stu-id="9b038-129">Mutable Variables</span></span>

<span data-ttu-id="9b038-130">Můžete použít klíčové slovo `mutable` k určení proměnné, které se můžou změnit.</span><span class="sxs-lookup"><span data-stu-id="9b038-130">You can use the keyword `mutable` to specify a variable that can be changed.</span></span> <span data-ttu-id="9b038-131">Proměnlivé proměnné v jazyce F # obecně měli mít omezený rozsah, jako typ pole nebo jako místní hodnoty.</span><span class="sxs-lookup"><span data-stu-id="9b038-131">Mutable variables in F# should generally have a limited scope, either as a field of a type or as a local value.</span></span> <span data-ttu-id="9b038-132">Proměnlivé proměnné s omezeným oborem usnadňuje řízení a jsou méně pravděpodobné, že má být upraven nesprávné způsoby.</span><span class="sxs-lookup"><span data-stu-id="9b038-132">Mutable variables with a limited scope are easier to control and are less likely to be modified in incorrect ways.</span></span>

<span data-ttu-id="9b038-133">Počáteční hodnota proměnlivé proměnné můžete přiřadit pomocí `let` – klíčové slovo v stejným způsobem, jak můžete definovat hodnotu.</span><span class="sxs-lookup"><span data-stu-id="9b038-133">You can assign an initial value to a mutable variable by using the `let` keyword in the same way as you would define a value.</span></span> <span data-ttu-id="9b038-134">Rozdíl je ale, že je lze následně přiřadit nové hodnoty proměnlivé proměnné pomocí `<-` operátor jako v následujícím příkladu.</span><span class="sxs-lookup"><span data-stu-id="9b038-134">However, the difference is that you can subsequently assign new values to mutable variables by using the `<-` operator, as in the following example.</span></span>

[!code-fsharp[Main](../../../../samples/snippets/fsharp/lang-ref-1/snippet602.fs)]

<span data-ttu-id="9b038-135">Hodnoty, které jsou označeny `mutable` může automaticky povýšen na `'a ref` Pokud zachycená výrazem uzávěru, včetně formuláře, které vytvářejí uzávěry, jako například `seq` tvůrci.</span><span class="sxs-lookup"><span data-stu-id="9b038-135">Values marked `mutable` may be automatically promoted to `'a ref` if captured by a closure, including forms that create closures, such as `seq` builders.</span></span> <span data-ttu-id="9b038-136">Pokud chcete být upozorněni na k tomu dojde, varování při povolení 3180 v souboru projektu nebo při vyvolání kompilátoru.</span><span class="sxs-lookup"><span data-stu-id="9b038-136">If you wish to be notified when this occurs, enable warning 3180 in your project file or when invoking the compiler.</span></span>

## <a name="related-topics"></a><span data-ttu-id="9b038-137">Související témata</span><span class="sxs-lookup"><span data-stu-id="9b038-137">Related Topics</span></span>

|<span data-ttu-id="9b038-138">Název</span><span class="sxs-lookup"><span data-stu-id="9b038-138">Title</span></span>|<span data-ttu-id="9b038-139">Popis</span><span class="sxs-lookup"><span data-stu-id="9b038-139">Description</span></span>|
|-----|-----------|
|[<span data-ttu-id="9b038-140">Vazby let</span><span class="sxs-lookup"><span data-stu-id="9b038-140">let Bindings</span></span>](../functions/let-bindings.md)|<span data-ttu-id="9b038-141">Obsahuje informace o použití `let` – klíčové slovo pro vázání názvů a hodnot a funkcí.</span><span class="sxs-lookup"><span data-stu-id="9b038-141">Provides information about using the `let` keyword to bind names to values and functions.</span></span>|
|[<span data-ttu-id="9b038-142">Funkce</span><span class="sxs-lookup"><span data-stu-id="9b038-142">Functions</span></span>](../functions/index.md)|<span data-ttu-id="9b038-143">Obsahuje přehled funkce v jazyce F #.</span><span class="sxs-lookup"><span data-stu-id="9b038-143">Provides an overview of functions in F#.</span></span>|

## <a name="see-also"></a><span data-ttu-id="9b038-144">Viz také:</span><span class="sxs-lookup"><span data-stu-id="9b038-144">See also</span></span>

- [<span data-ttu-id="9b038-145">Hodnoty Null</span><span class="sxs-lookup"><span data-stu-id="9b038-145">Null Values</span></span>](null-Values.md)
- [<span data-ttu-id="9b038-146">Referenční dokumentace jazyka F#</span><span class="sxs-lookup"><span data-stu-id="9b038-146">F# Language Reference</span></span>](../index.md)
