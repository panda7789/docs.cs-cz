---
title: EventCounters v .NET Core
description: V tomto článku se dozvíte, co EventCounters, jak je implementovat a jak se mají využívat.
ms.date: 08/07/2020
ms.openlocfilehash: 68868ff8b4e1393fc3b23af2bc8eef239ac56975
ms.sourcegitcommit: 1e6439ec4d5889fc08cf3bfb4dac2b91931eb827
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 08/08/2020
ms.locfileid: "88024998"
---
# <a name="eventcounters-in-net-core"></a><span data-ttu-id="95653-103">EventCounters v .NET Core</span><span class="sxs-lookup"><span data-stu-id="95653-103">EventCounters in .NET Core</span></span>

<span data-ttu-id="95653-104">**Tento článek se týká: ✔️** .net Core 3,0 SDK a novějších verzí</span><span class="sxs-lookup"><span data-stu-id="95653-104">**This article applies to: ✔️** .NET Core 3.0 SDK and later versions</span></span>

<span data-ttu-id="95653-105">EventCounters jsou rozhraní API .NET Core používaná pro shromažďování metrik výkonu pro odlehčenou, více platforem a téměř v reálném čase.</span><span class="sxs-lookup"><span data-stu-id="95653-105">EventCounters are .NET Core APIs used for lightweight, cross-platform, and near real-time performance metric collection.</span></span> <span data-ttu-id="95653-106">EventCounters byly přidány jako alternativa mezi různými platformami a "čítači výkonu" .NET Framework ve Windows.</span><span class="sxs-lookup"><span data-stu-id="95653-106">EventCounters were added as a cross-platform alternative to the "performance counters" of the .NET Framework on Windows.</span></span> <span data-ttu-id="95653-107">V tomto článku se dozvíte, co EventCounters, jak je implementovat a jak se mají využívat.</span><span class="sxs-lookup"><span data-stu-id="95653-107">In this article you'll learn what EventCounters are, how to implement them, and how to consume them.</span></span>

<span data-ttu-id="95653-108">Modul runtime .NET Core a několik knihoven .NET publikují základní diagnostické informace pomocí EventCounters počínaje platformou .NET Core 3,0.</span><span class="sxs-lookup"><span data-stu-id="95653-108">The .NET Core runtime and a few .NET libraries publish basic diagnostics information using EventCounters starting in .NET Core 3.0.</span></span> <span data-ttu-id="95653-109">Kromě EventCounters, které poskytuje modul runtime .NET, se můžete rozhodnout implementovat vlastní EventCounters.</span><span class="sxs-lookup"><span data-stu-id="95653-109">Apart from the EventCounters that are provided by the .NET runtime, you may choose to implement your own EventCounters.</span></span> <span data-ttu-id="95653-110">EventCounters lze použít ke sledování různých metrik.</span><span class="sxs-lookup"><span data-stu-id="95653-110">EventCounters can be used to track various metrics.</span></span>

<span data-ttu-id="95653-111">EventCounters živě jako součást <xref:System.Diagnostics.Tracing.EventSource> a automaticky se do nástrojů pro naslouchací procesy přihlásí.</span><span class="sxs-lookup"><span data-stu-id="95653-111">EventCounters live as a part of an <xref:System.Diagnostics.Tracing.EventSource>, and are automatically pushed to listener tools on a regular basis.</span></span> <span data-ttu-id="95653-112">Stejně jako všechny ostatní události v <xref:System.Diagnostics.Tracing.EventSource> , mohou být spotřebovány v rámci proc a out-of-proc přes <xref:System.Diagnostics.Tracing.EventListener> a EventPipe.</span><span class="sxs-lookup"><span data-stu-id="95653-112">Like all other events on an <xref:System.Diagnostics.Tracing.EventSource>, they can be consumed both in-proc and out-of-proc via <xref:System.Diagnostics.Tracing.EventListener> and EventPipe.</span></span> <span data-ttu-id="95653-113">Tento článek se zaměřuje na možnosti více platforem EventCounters a záměrně vylučuje PerfView a ETW (trasování událostí pro Windows), i když je možné oba použít s EventCounters.</span><span class="sxs-lookup"><span data-stu-id="95653-113">This article focuses on the cross-platform capabilities of EventCounters, and intentionally excludes PerfView and ETW (Event Tracing for Windows) - although both can be used with EventCounters.</span></span>

![Obrázek diagramu EventCounters in-proc a out-of-proc](media/event-counters.svg)

[!INCLUDE [available-counters](includes/available-counters.md)]

## <a name="eventcounter-api-overview"></a><span data-ttu-id="95653-115">Přehled rozhraní EventCounter API</span><span class="sxs-lookup"><span data-stu-id="95653-115">EventCounter API overview</span></span>

<span data-ttu-id="95653-116">Existují dvě primární kategorie čítačů.</span><span class="sxs-lookup"><span data-stu-id="95653-116">There are two primary categories of counters.</span></span> <span data-ttu-id="95653-117">Některé čítače jsou pro hodnoty "úroková_míra", jako je například celkový počet výjimek, celkový počet GC a celkový počet požadavků.</span><span class="sxs-lookup"><span data-stu-id="95653-117">Some counters are for "rate" values, such as total number of exceptions, total number of GCs, and total number of requests.</span></span> <span data-ttu-id="95653-118">Další čítače jsou hodnoty "snapshot", jako je například využití haldy, využití procesoru a velikost pracovní sady.</span><span class="sxs-lookup"><span data-stu-id="95653-118">Other counters are "snapshot" values, such as heap usage, CPU usage, and working set size.</span></span> <span data-ttu-id="95653-119">V každé z těchto kategorií čítačů existují dva typy čítačů, které se liší podle toho, jak získají jejich hodnoty.</span><span class="sxs-lookup"><span data-stu-id="95653-119">Within each of these categories of counters, there are two types of counters that vary by how they get their value.</span></span> <span data-ttu-id="95653-120">Čítače cyklického dotazování získávají hodnoty pomocí zpětného volání a čítače bez cyklického dotazování mají své hodnoty přímo nastaveny na instanci čítače.</span><span class="sxs-lookup"><span data-stu-id="95653-120">Polling counters retrieve their value via a callback, and non-polling counters have their values directly set on the counter instance.</span></span>

<span data-ttu-id="95653-121">Čítače jsou reprezentovány následujícími implementacemi:</span><span class="sxs-lookup"><span data-stu-id="95653-121">The counters are represented by the following implementations:</span></span>

* <xref:System.Diagnostics.Tracing.EventCounter>
* <xref:System.Diagnostics.Tracing.IncrementingEventCounter>
* <xref:System.Diagnostics.Tracing.IncrementingPollingCounter>
* <xref:System.Diagnostics.Tracing.PollingCounter>

<span data-ttu-id="95653-122">Naslouchací proces události Určuje, jak dlouhé mají být intervaly měření.</span><span class="sxs-lookup"><span data-stu-id="95653-122">An event listener specifies how long measurement intervals are.</span></span> <span data-ttu-id="95653-123">Na konci každého intervalu se hodnota přenáší do naslouchacího procesu pro každý čítač.</span><span class="sxs-lookup"><span data-stu-id="95653-123">At the end of each interval a value is transmitted to the listener for each counter.</span></span> <span data-ttu-id="95653-124">Implementace čítače určují, která rozhraní API a výpočty se používají k vytvoření hodnoty v každém intervalu.</span><span class="sxs-lookup"><span data-stu-id="95653-124">The implementations of a counter determine what APIs and calculations are used to produce the value each interval.</span></span>

1. <span data-ttu-id="95653-125"><xref:System.Diagnostics.Tracing.EventCounter>Zaznamenává sadu hodnot.</span><span class="sxs-lookup"><span data-stu-id="95653-125">The <xref:System.Diagnostics.Tracing.EventCounter> records a set of values.</span></span> <span data-ttu-id="95653-126"><xref:System.Diagnostics.Tracing.EventCounter.WriteMetric%2A?displayProperty=nameWithType>Metoda přidá novou hodnotu do sady.</span><span class="sxs-lookup"><span data-stu-id="95653-126">The <xref:System.Diagnostics.Tracing.EventCounter.WriteMetric%2A?displayProperty=nameWithType> method adds a new value to the set.</span></span> <span data-ttu-id="95653-127">U každého intervalu se počítá statistická souhrn pro sadu, jako třeba minimum, maximum a střední hodnota.</span><span class="sxs-lookup"><span data-stu-id="95653-127">With each interval, a statistical summary for the set is computed, such as the min, max, and mean.</span></span> <span data-ttu-id="95653-128">V nástroji [dotnet-Counters](dotnet-counters.md) se vždy zobrazí střední hodnota.</span><span class="sxs-lookup"><span data-stu-id="95653-128">The [dotnet-counters](dotnet-counters.md) tool will always display the mean value.</span></span> <span data-ttu-id="95653-129"><xref:System.Diagnostics.Tracing.EventCounter>Je užitečné pro popis diskrétní sady operací.</span><span class="sxs-lookup"><span data-stu-id="95653-129">The <xref:System.Diagnostics.Tracing.EventCounter> is useful to describe a discrete set of operations.</span></span> <span data-ttu-id="95653-130">Běžné použití může zahrnovat monitorování průměrné velikosti v bajtech nedávných vstupně-výstupních operací nebo průměrné peněžní hodnoty sady finančních transakcí.</span><span class="sxs-lookup"><span data-stu-id="95653-130">Common usage may include monitoring the average size in bytes of recent IO operations, or the average monetary value of a set of financial transactions.</span></span>

1. <span data-ttu-id="95653-131"><xref:System.Diagnostics.Tracing.IncrementingEventCounter>Zaznamenává průběžný součet pro každý časový interval.</span><span class="sxs-lookup"><span data-stu-id="95653-131">The <xref:System.Diagnostics.Tracing.IncrementingEventCounter> records a running total for each time interval.</span></span> <span data-ttu-id="95653-132"><xref:System.Diagnostics.Tracing.IncrementingEventCounter.Increment%2A?displayProperty=nameWithType>Metoda přičítá k celku.</span><span class="sxs-lookup"><span data-stu-id="95653-132">The <xref:System.Diagnostics.Tracing.IncrementingEventCounter.Increment%2A?displayProperty=nameWithType> method adds to the total.</span></span> <span data-ttu-id="95653-133">Například pokud `Increment()` je zavolána třikrát během jednoho intervalu s hodnotami `1` , a, `2` `5` pak Mezisoučet `8` bude hlášen jako hodnota čítače pro tento interval.</span><span class="sxs-lookup"><span data-stu-id="95653-133">For example, if `Increment()` is called three times during one interval with values `1`, `2`, and `5`, then the running total of `8` will be reported as the counter value for this interval.</span></span> <span data-ttu-id="95653-134">Nástroj [dotnet-Counters](dotnet-counters.md) zobrazí sazbu jako zaznamenaný součet/čas.</span><span class="sxs-lookup"><span data-stu-id="95653-134">The [dotnet-counters](dotnet-counters.md) tool will display the rate as the recorded total / time.</span></span> <span data-ttu-id="95653-135"><xref:System.Diagnostics.Tracing.IncrementingEventCounter>Je vhodný k měření, jak často se akce vyskytují, například počet požadavků zpracovaných za sekundu.</span><span class="sxs-lookup"><span data-stu-id="95653-135">The <xref:System.Diagnostics.Tracing.IncrementingEventCounter> is useful to measure how frequently an action is occurring, such as the number of requests processed per second.</span></span>

1. <span data-ttu-id="95653-136"><xref:System.Diagnostics.Tracing.PollingCounter>Používá zpětné volání k určení hodnoty, která je hlášena.</span><span class="sxs-lookup"><span data-stu-id="95653-136">The <xref:System.Diagnostics.Tracing.PollingCounter> uses a callback to determine the value that is reported.</span></span> <span data-ttu-id="95653-137">V každém časovém intervalu je vyvolána funkce zpětného volání poskytnuté uživatelem a jako hodnota čítače se použije návratová hodnota.</span><span class="sxs-lookup"><span data-stu-id="95653-137">With each time interval, the user provided callback function is invoked and the return value is used as the counter value.</span></span> <span data-ttu-id="95653-138"><xref:System.Diagnostics.Tracing.PollingCounter>Lze použít k dotazování metriky z externího zdroje, například získání aktuálních volných bajtů na disku.</span><span class="sxs-lookup"><span data-stu-id="95653-138">A <xref:System.Diagnostics.Tracing.PollingCounter> can be used to query a metric from an external source, for example getting the current free bytes on a disk.</span></span> <span data-ttu-id="95653-139">Dá se použít i k hlášení vlastních statistik, které se dají vypočítávají na vyžádání aplikací.</span><span class="sxs-lookup"><span data-stu-id="95653-139">It can also be used to report custom statistics that can be computed on demand by an application.</span></span> <span data-ttu-id="95653-140">Mezi příklady patří vytváření sestav o 95. percentilu nedávných latencí žádostí nebo aktuální poměr přístupů do mezipaměti.</span><span class="sxs-lookup"><span data-stu-id="95653-140">Examples include reporting the 95th percentile of recent request latencies, or the current hit or miss ratio of a cache.</span></span>

1. <span data-ttu-id="95653-141">K <xref:System.Diagnostics.Tracing.IncrementingPollingCounter> určení hlášené hodnoty přírůstku používá zpětné volání.</span><span class="sxs-lookup"><span data-stu-id="95653-141">The <xref:System.Diagnostics.Tracing.IncrementingPollingCounter> uses a callback to determine the reported increment value.</span></span> <span data-ttu-id="95653-142">V každém časovém intervalu je vyvoláno zpětné volání a potom rozdíl mezi aktuálním voláním a posledním voláním je Hlášená hodnota.</span><span class="sxs-lookup"><span data-stu-id="95653-142">With each time interval, the callback is invoked, and then the difference between the current invocation, and the last invocation is the reported value.</span></span> <span data-ttu-id="95653-143">Nástroj [dotnet-Counters](dotnet-counters.md) vždy zobrazí rozdíl jako sazbu, hlášené hodnoty a časy.</span><span class="sxs-lookup"><span data-stu-id="95653-143">The [dotnet-counters](dotnet-counters.md) tool will always display the difference as a rate, the reported value / time.</span></span> <span data-ttu-id="95653-144">Tento čítač je užitečný, pokud není možné volat rozhraní API u každého výskytu, ale je možné zadat dotaz na celkový počet výskytů.</span><span class="sxs-lookup"><span data-stu-id="95653-144">This counter is useful when it isn't feasible to call an API on each occurrence, but it's possible to query the total number of occurrences.</span></span> <span data-ttu-id="95653-145">Můžete například ohlásit počet bajtů zapsaných do souboru za sekundu, dokonce i bez oznámení pokaždé, když je bajt napsán.</span><span class="sxs-lookup"><span data-stu-id="95653-145">For example, you could report the number of bytes written to a file per second, even without a notification each time a byte is written.</span></span>

## <a name="implement-an-eventsource"></a><span data-ttu-id="95653-146">Implementace EventSource</span><span class="sxs-lookup"><span data-stu-id="95653-146">Implement an EventSource</span></span>

<span data-ttu-id="95653-147">Následující kód implementuje ukázku <xref:System.Diagnostics.Tracing.EventSource> vystavenou jako pojmenovaný `"Sample.EventCounter.Minimal"` poskytovatel.</span><span class="sxs-lookup"><span data-stu-id="95653-147">The following code implements a sample <xref:System.Diagnostics.Tracing.EventSource> exposed as the named `"Sample.EventCounter.Minimal"` provider.</span></span> <span data-ttu-id="95653-148">Tento zdroj obsahuje <xref:System.Diagnostics.Tracing.EventCounter> reprezentaci doby zpracování požadavku.</span><span class="sxs-lookup"><span data-stu-id="95653-148">This source contains an <xref:System.Diagnostics.Tracing.EventCounter> representing request processing time.</span></span> <span data-ttu-id="95653-149">Takový čítač má název (to znamená jeho jedinečné ID ve zdroji) a zobrazované jméno, které používají nástroje pro naslouchací proces, jako je například [dotnet-Counter](dotnet-counters.md).</span><span class="sxs-lookup"><span data-stu-id="95653-149">Such a counter has a name (that is, its unique ID in the source) and a display name, both used by listener tools such as [dotnet-counter](dotnet-counters.md).</span></span>

:::code language="csharp" source="snippets/EventCounters/MinimalEventCounterSource.cs":::

<span data-ttu-id="95653-150">Slouží `dotnet-counters ps` k zobrazení seznamu procesů rozhraní .NET, které lze monitorovat:</span><span class="sxs-lookup"><span data-stu-id="95653-150">You use `dotnet-counters ps` to display a list of .NET processes that can be monitored:</span></span>

```console
dotnet-counters ps
   1398652 dotnet     C:\Program Files\dotnet\dotnet.exe
   1399072 dotnet     C:\Program Files\dotnet\dotnet.exe
   1399112 dotnet     C:\Program Files\dotnet\dotnet.exe
   1401880 dotnet     C:\Program Files\dotnet\dotnet.exe
   1400180 sample-counters C:\sample-counters\bin\Debug\netcoreapp3.1\sample-counters.exe
```

<span data-ttu-id="95653-151">Předáním <xref:System.Diagnostics.Tracing.EventSource> názvu `counter_list` přepínači můžete začít monitorovat Čítač:</span><span class="sxs-lookup"><span data-stu-id="95653-151">Pass the <xref:System.Diagnostics.Tracing.EventSource> name to the `counter_list` switch to start monitoring your counter:</span></span>

```console
dotnet-counters monitor --process-id 1400180 Sample.EventCounter.Minimal
```

<span data-ttu-id="95653-152">Následující příklad ukazuje výstup monitorování:</span><span class="sxs-lookup"><span data-stu-id="95653-152">The following example shows monitor output:</span></span>

```console
Press p to pause, r to resume, q to quit.
    Status: Running

[Samples-EventCounterDemos-Minimal]
    Request Processing Time (ms)                            0.445
```

<span data-ttu-id="95653-153">Stisknutím tlačítka <kbd>q</kbd> zastavte příkaz monitorování.</span><span class="sxs-lookup"><span data-stu-id="95653-153">Press <kbd>q</kbd> to stop the monitoring command.</span></span>

#### <a name="conditional-counters"></a><span data-ttu-id="95653-154">Podmíněné čítače</span><span class="sxs-lookup"><span data-stu-id="95653-154">Conditional counters</span></span>

<span data-ttu-id="95653-155">Při implementaci <xref:System.Diagnostics.Tracing.EventSource> může být obsahující čítače podmíněně vytvořena při <xref:System.Diagnostics.Tracing.EventSource.OnEventCommand%2A?displayProperty=nameWithType> volání metody s <xref:System.Diagnostics.Tracing.EventCommandEventArgs.Command> hodnotou `EventCommand.Enable` .</span><span class="sxs-lookup"><span data-stu-id="95653-155">When implementing an <xref:System.Diagnostics.Tracing.EventSource>, the containing counters can be conditionally instantiated when the <xref:System.Diagnostics.Tracing.EventSource.OnEventCommand%2A?displayProperty=nameWithType> method is called with a <xref:System.Diagnostics.Tracing.EventCommandEventArgs.Command> value of `EventCommand.Enable`.</span></span> <span data-ttu-id="95653-156">Chcete-li instanci čítače bezpečně vytvořit pouze v případě, že je `null` použita, použijte [operátor přiřazení s hodnotou null](../../csharp/language-reference/operators/null-coalescing-operator.md).</span><span class="sxs-lookup"><span data-stu-id="95653-156">To safely instantiate a counter instance only if it is `null`, use the [null-coalescing assignment operator](../../csharp/language-reference/operators/null-coalescing-operator.md).</span></span> <span data-ttu-id="95653-157">Kromě toho vlastní metody mohou vyhodnotit <xref:System.Diagnostics.DiagnosticSource.IsEnabled%2A> metodu pro zjištění, zda je povolen aktuální zdroj události.</span><span class="sxs-lookup"><span data-stu-id="95653-157">Additionally, custom methods can evaluate the <xref:System.Diagnostics.DiagnosticSource.IsEnabled%2A> method to determine whether or not the current event source is enabled.</span></span>

:::code language="csharp" source="snippets/EventCounters/ConditionalEventCounterSource.cs":::

> [!TIP]
> <span data-ttu-id="95653-158">Podmíněné čítače jsou čítače, které jsou podmínečně vytvořeny pomocí architektury, což je mikrooptimalizace.</span><span class="sxs-lookup"><span data-stu-id="95653-158">Conditional counters are counters that are conditionally instantiated, a micro-optimization.</span></span> <span data-ttu-id="95653-159">Modul runtime tento model přijme pro scénáře, ve kterých se obvykle nepoužívají čítače, k uložení zlomku milisekund.</span><span class="sxs-lookup"><span data-stu-id="95653-159">The runtime adopts this pattern for scenarios where counters are normally not used, to save a fraction of a millisecond.</span></span>

### <a name="net-core-runtime-example-counters"></a><span data-ttu-id="95653-160">Ukázkové čítače .NET Core Runtime</span><span class="sxs-lookup"><span data-stu-id="95653-160">.NET Core runtime example counters</span></span>

<span data-ttu-id="95653-161">Modul runtime .NET Core obsahuje mnoho skvělých ukázkových implementací.</span><span class="sxs-lookup"><span data-stu-id="95653-161">There are many great example implementations in the .NET Core runtime.</span></span> <span data-ttu-id="95653-162">Zde je implementace modulu runtime pro čítač, který sleduje velikost pracovní sady aplikace.</span><span class="sxs-lookup"><span data-stu-id="95653-162">Here is the runtime implementation for the counter that tracks the working set size of the application.</span></span>

```csharp
var workingSetCounter = new PollingCounter(
    "working-set",
    this,
    () => (double)(Environment.WorkingSet / 1_000_000))
{
    DisplayName = "Working Set",
    DisplayUnits = "MB"
};
```

<span data-ttu-id="95653-163"><xref:System.Diagnostics.Tracing.PollingCounter>Oznamuje aktuální velikost fyzické paměti namapované na proces (pracovní sadu) aplikace, protože zachycuje metriku v okamžiku.</span><span class="sxs-lookup"><span data-stu-id="95653-163">The <xref:System.Diagnostics.Tracing.PollingCounter> reports the current amount of physical memory mapped to the process (working set) of the app, since it captures a metric at a moment in time.</span></span> <span data-ttu-id="95653-164">Zpětné volání pro cyklické dotazování hodnoty je poskytnutý výraz lambda, který je pouze voláním <xref:System.Environment.WorkingSet?displayProperty=fullName> rozhraní API.</span><span class="sxs-lookup"><span data-stu-id="95653-164">The callback for polling a value is the provided lambda expression, which is just a call to the <xref:System.Environment.WorkingSet?displayProperty=fullName> API.</span></span> <span data-ttu-id="95653-165"><xref:System.Diagnostics.Tracing.DiagnosticCounter.DisplayName>a <xref:System.Diagnostics.Tracing.DiagnosticCounter.DisplayUnits> jsou volitelné vlastnosti, které lze nastavit tak, aby pomohly na straně spotřebitele čítače, aby bylo možné přesnější zobrazení hodnoty.</span><span class="sxs-lookup"><span data-stu-id="95653-165"><xref:System.Diagnostics.Tracing.DiagnosticCounter.DisplayName> and <xref:System.Diagnostics.Tracing.DiagnosticCounter.DisplayUnits> are optional properties that can be set to help the consumer side of the counter to display the value more clearly.</span></span> <span data-ttu-id="95653-166">Například [dotnet – čítače](dotnet-counters.md) využívají tyto vlastnosti k zobrazení lépe přívětivých verzí názvů čítačů.</span><span class="sxs-lookup"><span data-stu-id="95653-166">For example, [dotnet-counters](dotnet-counters.md) uses these properties to display the more display-friendly version of the counter names.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="95653-167">`DisplayName`Vlastnosti nejsou lokalizovány.</span><span class="sxs-lookup"><span data-stu-id="95653-167">The `DisplayName` properties are not localized.</span></span>

<span data-ttu-id="95653-168">Pro <xref:System.Diagnostics.Tracing.PollingCounter> a <xref:System.Diagnostics.Tracing.IncrementingPollingCounter> není třeba provádět nic jiného.</span><span class="sxs-lookup"><span data-stu-id="95653-168">For the <xref:System.Diagnostics.Tracing.PollingCounter>, and the <xref:System.Diagnostics.Tracing.IncrementingPollingCounter>, nothing else needs to be done.</span></span> <span data-ttu-id="95653-169">Oba sami dotazují hodnoty v intervalu požadovaném příjemcem.</span><span class="sxs-lookup"><span data-stu-id="95653-169">They both poll the values themselves at an interval requested by the consumer.</span></span>

<span data-ttu-id="95653-170">Tady je příklad čítače modulu runtime implementovaného pomocí <xref:System.Diagnostics.Tracing.IncrementingPollingCounter> .</span><span class="sxs-lookup"><span data-stu-id="95653-170">Here is an example of a runtime counter implemented using <xref:System.Diagnostics.Tracing.IncrementingPollingCounter>.</span></span>

```csharp
var monitorContentionCounter = new IncrementingPollingCounter(
    "monitor-lock-contention-count",
    this,
    () => Monitor.LockContentionCount
)
{
    DisplayName = "Monitor Lock Contention Count",
    DisplayRateTimeScale = TimeSpan.FromSeconds(1)
};
```

<span data-ttu-id="95653-171"><xref:System.Diagnostics.Tracing.IncrementingPollingCounter> <xref:System.Threading.Monitor.LockContentionCount?displayProperty=nameWithType> Rozhraní API používá k nahlášení zvýšení celkového počtu kolizí zámků.</span><span class="sxs-lookup"><span data-stu-id="95653-171">The <xref:System.Diagnostics.Tracing.IncrementingPollingCounter> uses the <xref:System.Threading.Monitor.LockContentionCount?displayProperty=nameWithType> API to report the increment of the total lock contention count.</span></span> <span data-ttu-id="95653-172"><xref:System.Diagnostics.Tracing.IncrementingPollingCounter.DisplayRateTimeScale>Vlastnost je volitelná, ale když ji použijete, může poskytnout nápovědu pro časový interval, ve kterém se čítač nejlépe zobrazuje.</span><span class="sxs-lookup"><span data-stu-id="95653-172">The <xref:System.Diagnostics.Tracing.IncrementingPollingCounter.DisplayRateTimeScale> property is optional, but when used it can provide a hint for what time interval the counter is best displayed at.</span></span> <span data-ttu-id="95653-173">Například počet kolizí zámků se nejlépe zobrazuje jako _počet za sekundu_, takže jeho <xref:System.Diagnostics.Tracing.IncrementingPollingCounter.DisplayRateTimeScale> hodnota je jedna sekunda.</span><span class="sxs-lookup"><span data-stu-id="95653-173">For example, the lock contention count is best displayed as _count per second_, so its <xref:System.Diagnostics.Tracing.IncrementingPollingCounter.DisplayRateTimeScale> is set to one second.</span></span> <span data-ttu-id="95653-174">Rychlost zobrazení se dá upravit pro různé typy čítačů sazeb.</span><span class="sxs-lookup"><span data-stu-id="95653-174">The display rate can be adjusted for different types of rate counters.</span></span>

> [!NOTE]
> <span data-ttu-id="95653-175">Rozhraní <xref:System.Diagnostics.Tracing.IncrementingPollingCounter.DisplayRateTimeScale> nepoužívá modul [dotnet-Counters](dotnet-counters.md)a naslouchací procesy událostí _nejsou_ pro jeho použití požadovány.</span><span class="sxs-lookup"><span data-stu-id="95653-175">The <xref:System.Diagnostics.Tracing.IncrementingPollingCounter.DisplayRateTimeScale> is _not_ used by [dotnet-counters](dotnet-counters.md), and event listeners are not required to use it.</span></span>

<span data-ttu-id="95653-176">Existuje více implementací čítačů pro použití jako reference v úložišti [.NET runtime](https://github.com/dotnet/runtime/blob/master/src/libraries/System.Private.CoreLib/src/System/Diagnostics/Tracing/RuntimeEventSource.cs) .</span><span class="sxs-lookup"><span data-stu-id="95653-176">There are more counter implementations to use as a reference in the [.NET runtime](https://github.com/dotnet/runtime/blob/master/src/libraries/System.Private.CoreLib/src/System/Diagnostics/Tracing/RuntimeEventSource.cs) repo.</span></span>

## <a name="concurrency"></a><span data-ttu-id="95653-177">Souběžnost</span><span class="sxs-lookup"><span data-stu-id="95653-177">Concurrency</span></span>

> [!TIP]
> <span data-ttu-id="95653-178">Rozhraní EventCounters API nezaručuje bezpečnost vlákna.</span><span class="sxs-lookup"><span data-stu-id="95653-178">The EventCounters API does not guarantee thread safety.</span></span> <span data-ttu-id="95653-179">Pokud jsou delegáty předané <xref:System.Diagnostics.Tracing.PollingCounter> nebo <xref:System.Diagnostics.Tracing.IncrementingPollingCounter> instance volány více vlákny, je vaše zodpovědnost za zajištění bezpečnosti vláken delegátů.</span><span class="sxs-lookup"><span data-stu-id="95653-179">When the delegates passed to <xref:System.Diagnostics.Tracing.PollingCounter> or <xref:System.Diagnostics.Tracing.IncrementingPollingCounter> instances are called by multiple threads, it's your responsibility to guarantee the delegates' thread-safety.</span></span>

<span data-ttu-id="95653-180">Zvažte například následující <xref:System.Diagnostics.Tracing.EventSource> postup, který bude sledovat požadavky.</span><span class="sxs-lookup"><span data-stu-id="95653-180">For example, consider the following <xref:System.Diagnostics.Tracing.EventSource> to keep track of requests.</span></span>

:::code language="csharp" source="snippets/EventCounters/RequestEventSource.cs":::

<span data-ttu-id="95653-181">`AddRequest()`Metodu lze volat z obslužné rutiny žádosti a `RequestRateCounter` dotazuje hodnotu v intervalu určeném spotřebitelem čítače.</span><span class="sxs-lookup"><span data-stu-id="95653-181">The `AddRequest()` method can be called from a request handler, and the `RequestRateCounter` polls the value at the interval specified by the consumer of the counter.</span></span> <span data-ttu-id="95653-182">Nicméně tuto `AddRequest()` metodu lze volat více vlákny najednou, a to tak, že zadáte podmínku časování `_requestCount` .</span><span class="sxs-lookup"><span data-stu-id="95653-182">However, the `AddRequest()` method can be called by multiple threads at once, putting a race condition on `_requestCount`.</span></span> <span data-ttu-id="95653-183">Alternativní způsob, jak zvýšit `_requestCount` hodnotu k použití, je bezpečný pro přístup z více vláken <xref:System.Threading.Interlocked.Increment%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="95653-183">A thread-safe alternative way to increment the `_requestCount` is to use <xref:System.Threading.Interlocked.Increment%2A?displayProperty=nameWithType>.</span></span>

```csharp
public void AddRequest() => Interlocked.Increment(ref _requestCount);
```

## <a name="consume-eventcounters"></a><span data-ttu-id="95653-184">Využití EventCounters</span><span class="sxs-lookup"><span data-stu-id="95653-184">Consume EventCounters</span></span>

<span data-ttu-id="95653-185">Existují dva hlavní způsoby využití EventCounters, a to buď v proc, nebo mimo proc.</span><span class="sxs-lookup"><span data-stu-id="95653-185">There are two primary ways of consuming EventCounters, either in-proc, or out-of-proc.</span></span> <span data-ttu-id="95653-186">Spotřeba EventCounters se dá odlišit do tří vrstev různých spotřebních technologií.</span><span class="sxs-lookup"><span data-stu-id="95653-186">The consumption of EventCounters can be distinguished into three layers of various consuming technologies.</span></span>

- <span data-ttu-id="95653-187">Přenos událostí v nezpracovaném datovém proudu prostřednictvím ETW nebo EventPipe:</span><span class="sxs-lookup"><span data-stu-id="95653-187">Transporting events in a raw stream via ETW or EventPipe:</span></span>
  - <span data-ttu-id="95653-188">Rozhraní API ETW přicházejí v operačním systému Windows a EventPipe je přístupné jako rozhraní [.NET API](https://github.com/dotnet/diagnostics/blob/master/documentation/design-docs/diagnostics-client-library.md#1-attaching-to-a-process-and-dumping-out-all-the-runtime-gc-events-in-real-time-to-the-console)nebo diagnostický [protokol IPC](https://github.com/dotnet/diagnostics/blob/master/documentation/design-docs/ipc-protocol.md).</span><span class="sxs-lookup"><span data-stu-id="95653-188">ETW APIs come with the Windows OS, and EventPipe is accessible as a [.NET API](https://github.com/dotnet/diagnostics/blob/master/documentation/design-docs/diagnostics-client-library.md#1-attaching-to-a-process-and-dumping-out-all-the-runtime-gc-events-in-real-time-to-the-console), or the diagnostic [IPC protocol](https://github.com/dotnet/diagnostics/blob/master/documentation/design-docs/ipc-protocol.md).</span></span>
- <span data-ttu-id="95653-189">Dekódování binárního datového proudu událostí do událostí:</span><span class="sxs-lookup"><span data-stu-id="95653-189">Decoding the binary event stream into events:</span></span>
  - <span data-ttu-id="95653-190">[Knihovna TraceEvent](https://www.nuget.org/packages/Microsoft.Diagnostics.Tracing.TraceEvent) zpracovává formáty ETW i EventPipe streamování.</span><span class="sxs-lookup"><span data-stu-id="95653-190">The [TraceEvent library](https://www.nuget.org/packages/Microsoft.Diagnostics.Tracing.TraceEvent) handles both ETW and EventPipe stream formats.</span></span>
- <span data-ttu-id="95653-191">Nástroje příkazového řádku a grafického uživatelského rozhraní:</span><span class="sxs-lookup"><span data-stu-id="95653-191">Command-line and GUI tools:</span></span>
  - <span data-ttu-id="95653-192">Nástroje jako PerfView (ETW nebo EventPipe), dotnet-Counters (pouze EventPipe) a dotnet-monitor (pouze EventPipe).</span><span class="sxs-lookup"><span data-stu-id="95653-192">Tools like PerfView (ETW or EventPipe), dotnet-counters (EventPipe only), and dotnet-monitor (EventPipe only).</span></span>

### <a name="consume-out-of-proc"></a><span data-ttu-id="95653-193">Využití mimo proc</span><span class="sxs-lookup"><span data-stu-id="95653-193">Consume out-of-proc</span></span>

<span data-ttu-id="95653-194">Využití EventCounters mimo proc je velice běžný přístup.</span><span class="sxs-lookup"><span data-stu-id="95653-194">Consuming EventCounters out-of-proc is a very common approach.</span></span> <span data-ttu-id="95653-195">Pomocí EventPipe můžete použít [čítače dotnet-Counters](dotnet-counters.md) k jejich využití v různých platformách.</span><span class="sxs-lookup"><span data-stu-id="95653-195">You can use [dotnet-counters](dotnet-counters.md) to consume them in a cross-platform manner via an EventPipe.</span></span> <span data-ttu-id="95653-196">`dotnet-counters`Nástroj je globálním nástrojem dotnet pro různé platformy, který se dá použít k monitorování hodnot čítače.</span><span class="sxs-lookup"><span data-stu-id="95653-196">The `dotnet-counters` tool is a cross-platform dotnet CLI global tool that can be used to monitor the counter values.</span></span> <span data-ttu-id="95653-197">Pokud chcete zjistit, jak používat `dotnet-counters` Nástroj k monitorování čítačů, přečtěte si kurz [dotnet-Counters](dotnet-counters.md)nebo pracujte s [měřením výkonu pomocí EventCounters](event-counter-perf.md) .</span><span class="sxs-lookup"><span data-stu-id="95653-197">To find out how to use `dotnet-counters` to monitor your counters, see [dotnet-counters](dotnet-counters.md), or work through the [Measure performance using EventCounters](event-counter-perf.md) tutorial.</span></span>

#### <a name="dotnet-trace"></a><span data-ttu-id="95653-198">dotnet-trace</span><span class="sxs-lookup"><span data-stu-id="95653-198">dotnet-trace</span></span>

<span data-ttu-id="95653-199">`dotnet-trace`Nástroj lze použít ke spotřebě dat čítače prostřednictvím EventPipe.</span><span class="sxs-lookup"><span data-stu-id="95653-199">The `dotnet-trace` tool can be used to consume the counter data through an EventPipe.</span></span> <span data-ttu-id="95653-200">Tady je příklad použití `dotnet-trace` ke shromáždění dat čítače.</span><span class="sxs-lookup"><span data-stu-id="95653-200">Here is an example using `dotnet-trace` to collect counter data.</span></span>

```console
dotnet-trace collect --process-id <pid> Sample.EventCounter.Minimal:0:0:EventCounterIntervalSec=1
```

<span data-ttu-id="95653-201">Další informace o shromažďování hodnot čítačů v průběhu času naleznete v dokumentaci [dotnet-Trace](dotnet-trace.md#use-dotnet-trace-to-collect-counter-values-over-time) .</span><span class="sxs-lookup"><span data-stu-id="95653-201">For more information on how to collect counter values over time, see the [dotnet-trace](dotnet-trace.md#use-dotnet-trace-to-collect-counter-values-over-time) documentation.</span></span>

#### <a name="azure-application-insights"></a><span data-ttu-id="95653-202">Azure Application Insights</span><span class="sxs-lookup"><span data-stu-id="95653-202">Azure Application Insights</span></span>

<span data-ttu-id="95653-203">EventCounters je možné spotřebovat pomocí Azure Monitor, konkrétně Application Insights Azure.</span><span class="sxs-lookup"><span data-stu-id="95653-203">EventCounters can be consumed by Azure Monitor, specifically Azure Application Insights.</span></span> <span data-ttu-id="95653-204">Čítače je možné přidávat a odebírat a vy můžete zadat vlastní čítače nebo známé čítače.</span><span class="sxs-lookup"><span data-stu-id="95653-204">Counters can be added and removed, and you're free to specify custom counters, or well-known counters.</span></span> <span data-ttu-id="95653-205">Další informace najdete v tématu [přizpůsobení čítačů, které se mají shromažďovat](/azure/azure-monitor/app/eventcounters#customizing-counters-to-be-collected).</span><span class="sxs-lookup"><span data-stu-id="95653-205">For more information, see [Customizing counters to be collected](/azure/azure-monitor/app/eventcounters#customizing-counters-to-be-collected).</span></span>

#### <a name="dotnet-monitor"></a><span data-ttu-id="95653-206">dotnet – monitorování</span><span class="sxs-lookup"><span data-stu-id="95653-206">dotnet-monitor</span></span>

<span data-ttu-id="95653-207">`dotnet-monitor`Je experimentální nástroj, který usnadňuje získání přístupu k diagnostickým informacím v procesu .NET.</span><span class="sxs-lookup"><span data-stu-id="95653-207">The `dotnet-monitor` is an experimental tool that makes it easier to get access to diagnostics information in a .NET process.</span></span> <span data-ttu-id="95653-208">Další informace najdete v tématu [Úvod do příkazu dotnet-monitor, experimentální nástroj](https://devblogs.microsoft.com/dotnet/introducing-dotnet-monitor).</span><span class="sxs-lookup"><span data-stu-id="95653-208">For more information, see [Introducing dotnet-monitor, an experimental tool](https://devblogs.microsoft.com/dotnet/introducing-dotnet-monitor).</span></span>

### <a name="consume-in-proc"></a><span data-ttu-id="95653-209">Využití v proc</span><span class="sxs-lookup"><span data-stu-id="95653-209">Consume in-proc</span></span>

<span data-ttu-id="95653-210">Hodnoty čítače můžete využívat prostřednictvím <xref:System.Diagnostics.Tracing.EventListener> rozhraní API.</span><span class="sxs-lookup"><span data-stu-id="95653-210">You can consume the counter values via the <xref:System.Diagnostics.Tracing.EventListener> API.</span></span> <span data-ttu-id="95653-211"><xref:System.Diagnostics.Tracing.EventListener>Slouží jako procedura pro zpracování jakýchkoli událostí zapsaných všemi instancemi <xref:System.Diagnostics.Tracing.EventSource> ve vaší aplikaci.</span><span class="sxs-lookup"><span data-stu-id="95653-211">An <xref:System.Diagnostics.Tracing.EventListener> is an in-proc way of consuming any events written by all instances of an <xref:System.Diagnostics.Tracing.EventSource> in your application.</span></span> <span data-ttu-id="95653-212">Další informace o tom, jak používat `EventListener` rozhraní API, najdete v tématu <xref:System.Diagnostics.Tracing.EventListener> .</span><span class="sxs-lookup"><span data-stu-id="95653-212">For more information on how to use the `EventListener` API, see <xref:System.Diagnostics.Tracing.EventListener>.</span></span>

<span data-ttu-id="95653-213">Nejprve je <xref:System.Diagnostics.Tracing.EventSource> třeba povolit hodnotu čítače, která vytváří hodnotu čítače.</span><span class="sxs-lookup"><span data-stu-id="95653-213">First, the <xref:System.Diagnostics.Tracing.EventSource> that produces the counter value needs to be enabled.</span></span> <span data-ttu-id="95653-214">Přepsat <xref:System.Diagnostics.Tracing.EventListener.OnEventSourceCreated%2A?displayProperty=nameWithType> metodu pro získání oznámení při <xref:System.Diagnostics.Tracing.EventSource> Vytvoření a, pokud je to u <xref:System.Diagnostics.Tracing.EventSource> vašeho EventCounters správné, můžete <xref:System.Diagnostics.Tracing.EventListener.EnableEvents%2A?displayProperty=nameWithType> na něj zavolat.</span><span class="sxs-lookup"><span data-stu-id="95653-214">Override the <xref:System.Diagnostics.Tracing.EventListener.OnEventSourceCreated%2A?displayProperty=nameWithType> method to get a notification when an <xref:System.Diagnostics.Tracing.EventSource> is created, and if this is the correct <xref:System.Diagnostics.Tracing.EventSource> with your EventCounters, then you can call <xref:System.Diagnostics.Tracing.EventListener.EnableEvents%2A?displayProperty=nameWithType> on it.</span></span> <span data-ttu-id="95653-215">Tady je příklad přepsání:</span><span class="sxs-lookup"><span data-stu-id="95653-215">Here is an example override:</span></span>

:::code language="csharp" source="snippets/EventCounters/SimpleEventListener.cs" range="16-27":::

#### <a name="sample-code"></a><span data-ttu-id="95653-216">Ukázka kódu</span><span class="sxs-lookup"><span data-stu-id="95653-216">Sample code</span></span>

<span data-ttu-id="95653-217">Tady je ukázková <xref:System.Diagnostics.Tracing.EventListener> třída, která vytiskne všechny názvy čítačů a hodnoty z modulu runtime .NET <xref:System.Diagnostics.Tracing.EventSource> pro publikování vnitřních čítačů ( `System.Runtime` ) v určitém intervalu.</span><span class="sxs-lookup"><span data-stu-id="95653-217">Here is a sample <xref:System.Diagnostics.Tracing.EventListener> class that prints out all the counter names and values from the .NET runtime's <xref:System.Diagnostics.Tracing.EventSource>, for publishing its internal counters (`System.Runtime`) at some interval.</span></span>

:::code language="csharp" source="snippets/EventCounters/SimpleEventListener.cs":::

<span data-ttu-id="95653-218">Jak je uvedeno výše, _musíte_ se ujistit, že `"EventCounterIntervalSec"` argument je nastaven v `filterPayload` argumentu při volání <xref:System.Diagnostics.Tracing.EventListener.EnableEvents%2A> .</span><span class="sxs-lookup"><span data-stu-id="95653-218">As shown above, you _must_ make sure the `"EventCounterIntervalSec"` argument is set in the `filterPayload` argument when calling <xref:System.Diagnostics.Tracing.EventListener.EnableEvents%2A>.</span></span> <span data-ttu-id="95653-219">V opačném případě čítače nebudou moci vyprázdnit hodnoty, protože nevědí, jak by měl být vyprázdněn.</span><span class="sxs-lookup"><span data-stu-id="95653-219">Otherwise the counters will not be able to flush out values since it doesn't know at which interval it should be getting flushed out.</span></span>

## <a name="see-also"></a><span data-ttu-id="95653-220">Viz také</span><span class="sxs-lookup"><span data-stu-id="95653-220">See also</span></span>

- [<span data-ttu-id="95653-221">dotnet-counters</span><span class="sxs-lookup"><span data-stu-id="95653-221">dotnet-counters</span></span>](dotnet-counters.md)
- [<span data-ttu-id="95653-222">dotnet-trace</span><span class="sxs-lookup"><span data-stu-id="95653-222">dotnet-trace</span></span>](dotnet-trace.md)
- <xref:System.Diagnostics.Tracing.EventCounter>
- <xref:System.Diagnostics.Tracing.EventListener>
- <xref:System.Diagnostics.Tracing.EventSource>
