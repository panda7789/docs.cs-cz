---
title: Kovariance a kontravariance v obecných typech
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- generics, covariance and contravariance
- generics, variance
- covariance and contravariance in generics
- generic type parameters
ms.assetid: 2678dc63-c7f9-4590-9ddc-0a4df684d42e
author: mairaw
ms.author: mairaw
ms.openlocfilehash: 80c3a772ae4dfba53982ed28c0bd54f500c50b08
ms.sourcegitcommit: e614e0f3b031293e4107f37f752be43652f3f253
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 08/26/2018
ms.locfileid: "42932945"
---
# <a name="covariance-and-contravariance-in-generics"></a><span data-ttu-id="16fb3-102">Kovariance a kontravariance v obecných typech</span><span class="sxs-lookup"><span data-stu-id="16fb3-102">Covariance and Contravariance in Generics</span></span>
<a name="top"></a> <span data-ttu-id="16fb3-103">Kovariance a kontravariance jsou pojmy, které označují schopnost používat více odvozeného typu (konkrétnější) nebo méně odvozeného typu (specifické pro less) než byl původně zadán.</span><span class="sxs-lookup"><span data-stu-id="16fb3-103">Covariance and contravariance are terms that refer to the ability to use a more derived type (more specific) or a less derived type (less specific) than originally specified.</span></span> <span data-ttu-id="16fb3-104">Parametry obecného typu podporují kovarianci a kontravarianci za účelem zvýšení flexibility při přiřazování a používání obecných typů.</span><span class="sxs-lookup"><span data-stu-id="16fb3-104">Generic type parameters support covariance and contravariance to provide greater flexibility in assigning and using generic types.</span></span> <span data-ttu-id="16fb3-105">Pokud hovoříme o typu systému, pak jsou pojmy kovariance, kontravariance a invariance definovány následovně:</span><span class="sxs-lookup"><span data-stu-id="16fb3-105">When you are referring to a type system, covariance, contravariance, and invariance have the following definitions.</span></span> <span data-ttu-id="16fb3-106">V příkladech se předpokládá základní třídu s názvem `Base` a odvozenou třídu s názvem `Derived`.</span><span class="sxs-lookup"><span data-stu-id="16fb3-106">The examples assume a base class named `Base` and a derived class named `Derived`.</span></span>  
  
-   `Covariance`  
  
     <span data-ttu-id="16fb3-107">Umožňuje použít více odvozený typ, než byl původně zadán.</span><span class="sxs-lookup"><span data-stu-id="16fb3-107">Enables you to use a more derived type than originally specified.</span></span>  
  
     <span data-ttu-id="16fb3-108">Můžete přiřadit instanci `IEnumerable<Derived>` (`IEnumerable(Of Derived)` v jazyce Visual Basic) na proměnnou typu `IEnumerable<Base>`.</span><span class="sxs-lookup"><span data-stu-id="16fb3-108">You can assign an instance of `IEnumerable<Derived>` (`IEnumerable(Of Derived)` in Visual Basic) to a variable of type `IEnumerable<Base>`.</span></span>  
  
-   `Contravariance`  
  
     <span data-ttu-id="16fb3-109">Umožňuje používat obecnější (méně odvozený) typ, než byl původně zadán.</span><span class="sxs-lookup"><span data-stu-id="16fb3-109">Enables you to use a more generic (less derived) type than originally specified.</span></span>  
  
     <span data-ttu-id="16fb3-110">Můžete přiřadit instanci `Action<Base>` (`Action(Of Base)` v jazyce Visual Basic) na proměnnou typu `Action<Derived>`.</span><span class="sxs-lookup"><span data-stu-id="16fb3-110">You can assign an instance of `Action<Base>` (`Action(Of Base)` in Visual Basic) to a variable of type `Action<Derived>`.</span></span>  
  
-   `Invariance`  
  
     <span data-ttu-id="16fb3-111">To znamená, že můžete použít pouze původně zadaný typ; parametr invariantního obecného typu není ani kovariantní, ani kontravariantní.</span><span class="sxs-lookup"><span data-stu-id="16fb3-111">Means that you can use only the type originally specified; so an invariant generic type parameter is neither covariant nor contravariant.</span></span>  
  
     <span data-ttu-id="16fb3-112">Nelze přiřadit instanci `List<Base>` (`List(Of Base)` v jazyce Visual Basic) na proměnnou typu `List<Derived>` nebo naopak.</span><span class="sxs-lookup"><span data-stu-id="16fb3-112">You cannot assign an instance of `List<Base>` (`List(Of Base)` in Visual Basic) to a variable of type `List<Derived>` or vice versa.</span></span>  
  
 <span data-ttu-id="16fb3-113">Parametry kovariantního typu umožňují vytvářet přiřazení, které vypadají podobně jako běžný [polymorfismus](~/docs/csharp/programming-guide/classes-and-structs/polymorphism.md), jak je znázorněno v následujícím kódu.</span><span class="sxs-lookup"><span data-stu-id="16fb3-113">Covariant type parameters enable you to make assignments that look much like ordinary [Polymorphism](~/docs/csharp/programming-guide/classes-and-structs/polymorphism.md), as shown in the following code.</span></span>  
  
 [!code-csharp[CoContraSimpleIEnum#1](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontrasimpleienum/cs/example.cs#1)]
 [!code-vb[CoContraSimpleIEnum#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontrasimpleienum/vb/example.vb#1)]  
  
 <span data-ttu-id="16fb3-114"><xref:System.Collections.Generic.List%601> Implementuje třída <xref:System.Collections.Generic.IEnumerable%601> rozhraní, takže `List<Derived>` (`List(Of Derived)` v jazyce Visual Basic) implementuje `IEnumerable<Derived>`.</span><span class="sxs-lookup"><span data-stu-id="16fb3-114">The <xref:System.Collections.Generic.List%601> class implements the <xref:System.Collections.Generic.IEnumerable%601> interface, so `List<Derived>` (`List(Of Derived)` in Visual Basic) implements `IEnumerable<Derived>`.</span></span> <span data-ttu-id="16fb3-115">Parametr kovariantního typu dokončí zbývající úkoly.</span><span class="sxs-lookup"><span data-stu-id="16fb3-115">The covariant type parameter does the rest.</span></span>  
  
 <span data-ttu-id="16fb3-116">Kontravariance se naopak zdá být neintuitivní.</span><span class="sxs-lookup"><span data-stu-id="16fb3-116">Contravariance, on the other hand, seems counterintuitive.</span></span> <span data-ttu-id="16fb3-117">Následující příklad vytvoří delegát typu `Action<Base>` (`Action(Of Base)` v jazyce Visual Basic) a poté tento delegát přiřadí k proměnné typu `Action<Derived>`.</span><span class="sxs-lookup"><span data-stu-id="16fb3-117">The following example creates a delegate of type `Action<Base>` (`Action(Of Base)` in Visual Basic), and then assigns that delegate to a variable of type `Action<Derived>`.</span></span>  
  
 [!code-csharp[CoContraSimpleAction#1](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontrasimpleaction/cs/example.cs#1)]
 [!code-vb[CoContraSimpleAction#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontrasimpleaction/vb/example.vb#1)]  
  
 <span data-ttu-id="16fb3-118">Zdá se, že se jedná o zpětnou akci, jde však o typově bezpečný kód, který se zkompiluje a spustí.</span><span class="sxs-lookup"><span data-stu-id="16fb3-118">This seems backward, but it is type-safe code that compiles and runs.</span></span> <span data-ttu-id="16fb3-119">Výraz lambda se shoduje s delegátem je přiřazen, takže definuje metodu, která přijímá jeden parametr typu `Base` a, který nemá žádnou návratovou hodnotu.</span><span class="sxs-lookup"><span data-stu-id="16fb3-119">The lambda expression matches the delegate it is assigned to, so it defines a method that takes one parameter of type `Base` and that has no return value.</span></span> <span data-ttu-id="16fb3-120">Výsledný delegát může být přiřazen proměnné typu `Action<Derived>` protože parametr typu `T` z <xref:System.Action%601> delegát je kontravariantní.</span><span class="sxs-lookup"><span data-stu-id="16fb3-120">The resulting delegate can be assigned to a variable of type `Action<Derived>` because the type parameter `T` of the <xref:System.Action%601> delegate is contravariant.</span></span> <span data-ttu-id="16fb3-121">Kód je typově bezpečné protože `T` Určuje typ parametru.</span><span class="sxs-lookup"><span data-stu-id="16fb3-121">The code is type-safe because `T` specifies a parameter type.</span></span> <span data-ttu-id="16fb3-122">Pokud delegát typu `Action<Base>` je vyvolána, jako kdyby se jednalo o delegát typu `Action<Derived>`, její argument musí být typu `Derived`.</span><span class="sxs-lookup"><span data-stu-id="16fb3-122">When the delegate of type `Action<Base>` is invoked as if it were a delegate of type `Action<Derived>`, its argument must be of type `Derived`.</span></span> <span data-ttu-id="16fb3-123">Tento argument lze vždy předat bezpečně základní metodě, protože parametr metody je typu `Base`.</span><span class="sxs-lookup"><span data-stu-id="16fb3-123">This argument can always be passed safely to the underlying method, because the method's parameter is of type `Base`.</span></span>  
  
 <span data-ttu-id="16fb3-124">Obecně lze parametr konvariantního typu použít jako návratový typ delegátu a parametry kontravariantního typu mohou být použity jako typy parametrů.</span><span class="sxs-lookup"><span data-stu-id="16fb3-124">In general, a covariant type parameter can be used as the return type of a delegate, and contravariant type parameters can be used as parameter types.</span></span> <span data-ttu-id="16fb3-125">V případě konkrétního rozhraní mohou být parametry kovariantního typu použity jako návratové typy metod rozhraní a parametry kontravariantního typu mohou být použity jako typy parametrů metod rozhraní.</span><span class="sxs-lookup"><span data-stu-id="16fb3-125">For an interface, covariant type parameters can be used as the return types of the interface's methods, and contravariant type parameters can be used as the parameter types of the interface's methods.</span></span>  
  
 <span data-ttu-id="16fb3-126">Kovariance a kontravariance se souhrnně označují jako *variance*.</span><span class="sxs-lookup"><span data-stu-id="16fb3-126">Covariance and contravariance are collectively referred to as *variance*.</span></span> <span data-ttu-id="16fb3-127">Parametr obecného typu, který není označen jako kovariantní nebo kontravariantní se označuje jako *invariantní*.</span><span class="sxs-lookup"><span data-stu-id="16fb3-127">A generic type parameter that is not marked covariant or contravariant is referred to as *invariant*.</span></span> <span data-ttu-id="16fb3-128">Stručný souhrn faktů o varianci v modulu CLR (Common Language Runtime):</span><span class="sxs-lookup"><span data-stu-id="16fb3-128">A brief summary of facts about variance in the common language runtime:</span></span>  
  
-   <span data-ttu-id="16fb3-129">V [!INCLUDE[net_v40_long](../../../includes/net-v40-long-md.md)], parametry variantního typu omezeny na obecná rozhraní a obecné typy delegátů.</span><span class="sxs-lookup"><span data-stu-id="16fb3-129">In the [!INCLUDE[net_v40_long](../../../includes/net-v40-long-md.md)], variant type parameters are restricted to generic interface and generic delegate types.</span></span>  
  
-   <span data-ttu-id="16fb3-130">Obecná rozhraní nebo obecné typy delegátů mohou mít parametry kovariantního i kontravariantního typu.</span><span class="sxs-lookup"><span data-stu-id="16fb3-130">A generic interface or generic delegate type can have both covariant and contravariant type parameters.</span></span>  
  
-   <span data-ttu-id="16fb3-131">Variance platí pouze pro odkazované typy. Pokud zadáte typ hodnoty pro parametr variantního typu, je tento parametr typu pro výsledný konstruovaný typ invariantní.</span><span class="sxs-lookup"><span data-stu-id="16fb3-131">Variance applies only to reference types; if you specify a value type for a variant type parameter, that type parameter is invariant for the resulting constructed type.</span></span>  
  
-   <span data-ttu-id="16fb3-132">Variance se nevztahuje na kombinaci delegátů.</span><span class="sxs-lookup"><span data-stu-id="16fb3-132">Variance does not apply to delegate combination.</span></span> <span data-ttu-id="16fb3-133">To znamená, že u daných dvou delegátů typů `Action<Derived>` a `Action<Base>` (`Action(Of Derived)` a `Action(Of Base)` v jazyce Visual Basic), nelze kombinovat druhý delegát s prvním Ačkoli výsledek by byl typově bezpečný.</span><span class="sxs-lookup"><span data-stu-id="16fb3-133">That is, given two delegates of types `Action<Derived>` and `Action<Base>` (`Action(Of Derived)` and `Action(Of Base)` in Visual Basic), you cannot combine the second delegate with the first although the result would be type safe.</span></span> <span data-ttu-id="16fb3-134">Variance umožňuje druhého delegátu má být přiřazena k proměnné typu `Action<Derived>`, delegáty lze však kombinovat pouze v případě přesné shody typů.</span><span class="sxs-lookup"><span data-stu-id="16fb3-134">Variance allows the second delegate to be assigned to a variable of type `Action<Derived>`, but delegates can combine only if their types match exactly.</span></span>  
  
 <span data-ttu-id="16fb3-135">Následující pododdíly obsahují podrobný popis parametrů kovariantního a kontravariantního typu:</span><span class="sxs-lookup"><span data-stu-id="16fb3-135">The following subsections describe covariant and contravariant type parameters in detail:</span></span>  
  
-   [<span data-ttu-id="16fb3-136">Obecná rozhraní s parametry kovariantního typu</span><span class="sxs-lookup"><span data-stu-id="16fb3-136">Generic Interfaces with Covariant Type Parameters</span></span>](#InterfaceCovariantTypeParameters)  
  
-   [<span data-ttu-id="16fb3-137">Obecná rozhraní s parametry obecného kontravariantního typu</span><span class="sxs-lookup"><span data-stu-id="16fb3-137">Generic Interfaces with Contravariant Generic Type Parameters</span></span>](#InterfaceCovariantTypeParameters)  
  
-   [<span data-ttu-id="16fb3-138">Parametry typu obecné delegáty s typ Variant</span><span class="sxs-lookup"><span data-stu-id="16fb3-138">Generic Delegates with Variant Type Parameters</span></span>](#DelegateVariantTypeParameters)  
  
-   [<span data-ttu-id="16fb3-139">Definování variantních obecných rozhraní a delegátů</span><span class="sxs-lookup"><span data-stu-id="16fb3-139">Defining Variant Generic Interfaces and Delegates</span></span>](#DefiningVariantTypeParameters)  
  
-   [<span data-ttu-id="16fb3-140">Seznam variantních obecných rozhraní a typy delegátů</span><span class="sxs-lookup"><span data-stu-id="16fb3-140">List of Variant Generic Interface and Delegate Types</span></span>](#VariantList)  
  
<a name="InterfaceCovariantTypeParameters"></a>   
## <a name="generic-interfaces-with-covariant-type-parameters"></a><span data-ttu-id="16fb3-141">Obecná rozhraní s parametry kovariantního typu</span><span class="sxs-lookup"><span data-stu-id="16fb3-141">Generic Interfaces with Covariant Type Parameters</span></span>  
 <span data-ttu-id="16fb3-142">Počínaje [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)], mají několik obecných rozhraní parametry kovariantního typu, třeba: <xref:System.Collections.Generic.IEnumerable%601>, <xref:System.Collections.Generic.IEnumerator%601>, <xref:System.Linq.IQueryable%601>, a <xref:System.Linq.IGrouping%602>.</span><span class="sxs-lookup"><span data-stu-id="16fb3-142">Starting with the [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)], several generic interfaces have covariant type parameters; for example: <xref:System.Collections.Generic.IEnumerable%601>, <xref:System.Collections.Generic.IEnumerator%601>, <xref:System.Linq.IQueryable%601>, and <xref:System.Linq.IGrouping%602>.</span></span> <span data-ttu-id="16fb3-143">Všechny parametry typu těchto rozhraní jsou kovariantní. Parametry typu se tedy používají pouze pro návratové typy členů.</span><span class="sxs-lookup"><span data-stu-id="16fb3-143">All the type parameters of these interfaces are covariant, so the type parameters are used only for the return types of the members.</span></span>  
  
 <span data-ttu-id="16fb3-144">Následující příklad znázorňuje parametry kovariantního typu.</span><span class="sxs-lookup"><span data-stu-id="16fb3-144">The following example illustrates covariant type parameters.</span></span> <span data-ttu-id="16fb3-145">Příklad definuje dva typy: `Base` má statickou metodu s názvem `PrintBases` , která má `IEnumerable<Base>` (`IEnumerable(Of Base)` v jazyce Visual Basic) a tisk prvků.</span><span class="sxs-lookup"><span data-stu-id="16fb3-145">The example defines two types: `Base` has a static method named `PrintBases` that takes an `IEnumerable<Base>` (`IEnumerable(Of Base)` in Visual Basic) and prints the elements.</span></span> <span data-ttu-id="16fb3-146">`Derived` dědí z `Base`.</span><span class="sxs-lookup"><span data-stu-id="16fb3-146">`Derived` inherits from `Base`.</span></span> <span data-ttu-id="16fb3-147">Tento příklad vytvoří prázdnou `List<Derived>` (`List(Of Derived)` v jazyce Visual Basic) a ukazuje, že tento typ může být předán `PrintBases` a přiřadit proměnné typu `IEnumerable<Base>` bez přetypování.</span><span class="sxs-lookup"><span data-stu-id="16fb3-147">The example creates an empty `List<Derived>` (`List(Of Derived)` in Visual Basic) and demonstrates that this type can be passed to `PrintBases` and assigned to a variable of type `IEnumerable<Base>` without casting.</span></span> <span data-ttu-id="16fb3-148"><xref:System.Collections.Generic.List%601> implementuje <xref:System.Collections.Generic.IEnumerable%601>, který má jediný parametr kovariantního typu.</span><span class="sxs-lookup"><span data-stu-id="16fb3-148"><xref:System.Collections.Generic.List%601> implements <xref:System.Collections.Generic.IEnumerable%601>, which has a single covariant type parameter.</span></span> <span data-ttu-id="16fb3-149">Typ kovariantního parametru je důvod, proč instance `IEnumerable<Derived>` lze použít místo `IEnumerable<Base>`.</span><span class="sxs-lookup"><span data-stu-id="16fb3-149">The covariant type parameter is the reason why an instance of `IEnumerable<Derived>` can be used instead of `IEnumerable<Base>`.</span></span>  
  
 [!code-csharp[CoContravarianceInClrGenericI#1](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontravarianceinclrgenerici/cs/example.cs#1)]
 [!code-vb[CoContravarianceInClrGenericI#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontravarianceinclrgenerici/vb/example.vb#1)]  
  
 [<span data-ttu-id="16fb3-150">Zpět na začátek</span><span class="sxs-lookup"><span data-stu-id="16fb3-150">Back to top</span></span>](#top)  
  
<a name="InterfaceContravariantTypeParameters"></a>   
## <a name="generic-interfaces-with-contravariant-generic-type-parameters"></a><span data-ttu-id="16fb3-151">Obecná rozhraní s parametry obecného kontravariantního typu</span><span class="sxs-lookup"><span data-stu-id="16fb3-151">Generic Interfaces with Contravariant Generic Type Parameters</span></span>  
 <span data-ttu-id="16fb3-152">Počínaje [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)], mají několik obecných rozhraní parametry kontravariantního typu; například: <xref:System.Collections.Generic.IComparer%601>, <xref:System.IComparable%601>, a <xref:System.Collections.Generic.IEqualityComparer%601>.</span><span class="sxs-lookup"><span data-stu-id="16fb3-152">Starting with the [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)], several generic interfaces have contravariant type parameters; for example: <xref:System.Collections.Generic.IComparer%601>, <xref:System.IComparable%601>, and <xref:System.Collections.Generic.IEqualityComparer%601>.</span></span> <span data-ttu-id="16fb3-153">Tato rozhraní mají pouze parametry kontravariantního typu, takže parametry typu slouží pouze jako typy parametrů u členů rozhraní.</span><span class="sxs-lookup"><span data-stu-id="16fb3-153">These interfaces have only contravariant type parameters, so the type parameters are used only as parameter types in the members of the interfaces.</span></span>  
  
 <span data-ttu-id="16fb3-154">Následující příklad znázorňuje parametry kontravariantního typu.</span><span class="sxs-lookup"><span data-stu-id="16fb3-154">The following example illustrates contravariant type parameters.</span></span> <span data-ttu-id="16fb3-155">Tento příklad definuje abstraktní (`MustInherit` v jazyce Visual Basic) `Shape` třídy s `Area` vlastnost.</span><span class="sxs-lookup"><span data-stu-id="16fb3-155">The example defines an abstract (`MustInherit` in Visual Basic) `Shape` class with an `Area` property.</span></span> <span data-ttu-id="16fb3-156">Příklad také definuje `ShapeAreaComparer` třídu, která implementuje `IComparer<Shape>` (`IComparer(Of Shape)` v jazyce Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="16fb3-156">The example also defines a `ShapeAreaComparer` class that implements `IComparer<Shape>` (`IComparer(Of Shape)` in Visual Basic).</span></span> <span data-ttu-id="16fb3-157">Provádění <xref:System.Collections.Generic.IComparer%601.Compare%2A?displayProperty=nameWithType> metoda je založena na hodnotě `Area` vlastnosti, takže `ShapeAreaComparer` slouží k seřazení `Shape` objekty podle oblasti.</span><span class="sxs-lookup"><span data-stu-id="16fb3-157">The implementation of the <xref:System.Collections.Generic.IComparer%601.Compare%2A?displayProperty=nameWithType> method is based on the value of the `Area` property, so `ShapeAreaComparer` can be used to sort `Shape` objects by area.</span></span>  
  
 <span data-ttu-id="16fb3-158">`Circle` Třída dědí `Shape` a přepíše `Area`.</span><span class="sxs-lookup"><span data-stu-id="16fb3-158">The `Circle` class inherits `Shape` and overrides `Area`.</span></span> <span data-ttu-id="16fb3-159">V příkladu se vytvoří <xref:System.Collections.Generic.SortedSet%601> z `Circle` pomocí konstruktoru, který přebírá `IComparer<Circle>` (`IComparer(Of Circle)` v jazyce Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="16fb3-159">The example creates a <xref:System.Collections.Generic.SortedSet%601> of `Circle` objects, using a constructor that takes an `IComparer<Circle>` (`IComparer(Of Circle)` in Visual Basic).</span></span> <span data-ttu-id="16fb3-160">Namísto předání `IComparer<Circle>`, příklad předá `ShapeAreaComparer` objektu, který implementuje `IComparer<Shape>`.</span><span class="sxs-lookup"><span data-stu-id="16fb3-160">However, instead of passing an `IComparer<Circle>`, the example passes a `ShapeAreaComparer` object, which implements `IComparer<Shape>`.</span></span> <span data-ttu-id="16fb3-161">Příklad může předat porovnávací metodu méně odvozeného typu (`Shape`) když kód volá porovnávací metodu více odvozeného typu (`Circle`), protože parametr typu <xref:System.Collections.Generic.IComparer%601> obecného rozhraní je kontravariantní.</span><span class="sxs-lookup"><span data-stu-id="16fb3-161">The example can pass a comparer of a less derived type (`Shape`) when the code calls for a comparer of a more derived type (`Circle`), because the type parameter of the <xref:System.Collections.Generic.IComparer%601> generic interface is contravariant.</span></span>  
  
 <span data-ttu-id="16fb3-162">Když je nový `Circle` objekt přidán do `SortedSet<Circle>`, `IComparer<Shape>.Compare` – metoda (`IComparer(Of Shape).Compare` metody v jazyce Visual Basic) z `ShapeAreaComparer` objektu je volána pokaždé, když má nový element je ve srovnání s existujícího prvku.</span><span class="sxs-lookup"><span data-stu-id="16fb3-162">When a new `Circle` object is added to the `SortedSet<Circle>`, the `IComparer<Shape>.Compare` method (`IComparer(Of Shape).Compare` method in Visual Basic) of the `ShapeAreaComparer` object is called each time the new element is compared to an existing element.</span></span> <span data-ttu-id="16fb3-163">Typ parametru metody (`Shape`) je méně odvozený než předávaný typ (`Circle`), takže volání je typově bezpečný.</span><span class="sxs-lookup"><span data-stu-id="16fb3-163">The parameter type of the method (`Shape`) is less derived than the type that is being passed (`Circle`), so the call is type safe.</span></span> <span data-ttu-id="16fb3-164">Kontravariance umožní `ShapeAreaComparer` řazení kolekcí jakéhokoli jednotlivého typu a také kombinaci kolekcí typů odvozených z `Shape`.</span><span class="sxs-lookup"><span data-stu-id="16fb3-164">Contravariance enables `ShapeAreaComparer` to sort a collection of any single type, as well as a mixed collection of types, that derive from `Shape`.</span></span>  
  
 [!code-csharp[CoContravarianceInClrGenericI2#1](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontravarianceinclrgenerici2/cs/example.cs#1)]
 [!code-vb[CoContravarianceInClrGenericI2#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontravarianceinclrgenerici2/vb/example.vb#1)]  
  
 [<span data-ttu-id="16fb3-165">Zpět na začátek</span><span class="sxs-lookup"><span data-stu-id="16fb3-165">Back to top</span></span>](#top)  
  
<a name="DelegateVariantTypeParameters"></a>   
## <a name="generic-delegates-with-variant-type-parameters"></a><span data-ttu-id="16fb3-166">Obecné delegáty s parametry variantního typu</span><span class="sxs-lookup"><span data-stu-id="16fb3-166">Generic Delegates with Variant Type Parameters</span></span>  
 <span data-ttu-id="16fb3-167">V [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)], `Func` obecné delegáty, jako například <xref:System.Func%602>, kovariantní návratové typy a kontravariantní typy parametru.</span><span class="sxs-lookup"><span data-stu-id="16fb3-167">In the [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)], the `Func` generic delegates, such as <xref:System.Func%602>, have covariant return types and contravariant parameter types.</span></span> <span data-ttu-id="16fb3-168">`Action` Obecné delegáty, jako například <xref:System.Action%602>, mají kontravariantní typy parametru.</span><span class="sxs-lookup"><span data-stu-id="16fb3-168">The `Action` generic delegates, such as <xref:System.Action%602>, have contravariant parameter types.</span></span> <span data-ttu-id="16fb3-169">To znamená, že delegáty lze přiřadit k proměnné, které mají více odvozené typy parametrů a (v případě třídy `Func` obecných delegátů) méně odvozené návratové typy.</span><span class="sxs-lookup"><span data-stu-id="16fb3-169">This means that the delegates can be assigned to variables that have more derived parameter types and (in the case of the `Func` generic delegates) less derived return types.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="16fb3-170">Poslední parametr obecného typu `Func` obecné delegáty Určuje typ návratové hodnoty v signatuře delegátu.</span><span class="sxs-lookup"><span data-stu-id="16fb3-170">The last generic type parameter of the `Func` generic delegates specifies the type of the return value in the delegate signature.</span></span> <span data-ttu-id="16fb3-171">Jedná se o kovariantní (`out` – klíčové slovo), zatímco jiné parametry obecného typu jsou kontravariantní (`in` – klíčové slovo).</span><span class="sxs-lookup"><span data-stu-id="16fb3-171">It is covariant (`out` keyword), whereas the other generic type parameters are contravariant (`in` keyword).</span></span>  
  
 <span data-ttu-id="16fb3-172">Následující kód to znázorňuje.</span><span class="sxs-lookup"><span data-stu-id="16fb3-172">The following code illustrates this.</span></span> <span data-ttu-id="16fb3-173">První část kódu definuje třídu s názvem `Base`, třídu s názvem `Derived` , která dědí `Base`a další třídu s `static` – metoda (`Shared` v jazyce Visual Basic) s názvem `MyMethod`.</span><span class="sxs-lookup"><span data-stu-id="16fb3-173">The first piece of code defines a class named `Base`, a class named `Derived` that inherits `Base`, and another class with a `static` method (`Shared` in Visual Basic) named `MyMethod`.</span></span> <span data-ttu-id="16fb3-174">Metoda použije instanci `Base` a vrátí instanci `Derived`.</span><span class="sxs-lookup"><span data-stu-id="16fb3-174">The method takes an instance of `Base` and returns an instance of `Derived`.</span></span> <span data-ttu-id="16fb3-175">(Pokud je argument instancí `Derived`, `MyMethod` jej vrátí; pokud je argument instancí `Base`, `MyMethod` vrátí novou instanci třídy `Derived`.) V `Main()`, tento příklad vytvoří instanci `Func<Base, Derived>` (`Func(Of Base, Derived)` v jazyce Visual Basic), která představuje `MyMethod`a uloží jej do proměnné `f1`.</span><span class="sxs-lookup"><span data-stu-id="16fb3-175">(If the argument is an instance of `Derived`, `MyMethod` returns it; if the argument is an instance of `Base`, `MyMethod` returns a new instance of `Derived`.) In `Main()`, the example creates an instance of `Func<Base, Derived>` (`Func(Of Base, Derived)` in Visual Basic) that represents `MyMethod`, and stores it in the variable `f1`.</span></span>  
  
 [!code-csharp[CoContravarianceDelegates#2](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontravariancedelegates/cs/example.cs#2)]
 [!code-vb[CoContravarianceDelegates#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontravariancedelegates/vb/example.vb#2)]  
  
 <span data-ttu-id="16fb3-176">Druhá část kódu znázorňuje, delegát může být přiřazen proměnné typu `Func<Base, Base>` (`Func(Of Base, Base)` v jazyce Visual Basic), protože návratový typ je kovariantní.</span><span class="sxs-lookup"><span data-stu-id="16fb3-176">The second piece of code shows that the delegate can be assigned to a variable of type `Func<Base, Base>` (`Func(Of Base, Base)` in Visual Basic), because the return type is covariant.</span></span>  
  
 [!code-csharp[CoContravarianceDelegates#3](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontravariancedelegates/cs/example.cs#3)]
 [!code-vb[CoContravarianceDelegates#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontravariancedelegates/vb/example.vb#3)]  
  
 <span data-ttu-id="16fb3-177">Třetí část kódu znázorňuje, delegát může být přiřazen proměnné typu `Func<Derived, Derived>` (`Func(Of Derived, Derived)` v jazyce Visual Basic), protože typ parametru je kontravariantní.</span><span class="sxs-lookup"><span data-stu-id="16fb3-177">The third piece of code shows that the delegate can be assigned to a variable of type `Func<Derived, Derived>` (`Func(Of Derived, Derived)` in Visual Basic), because the parameter type is contravariant.</span></span>  
  
 [!code-csharp[CoContravarianceDelegates#4](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontravariancedelegates/cs/example.cs#4)]
 [!code-vb[CoContravarianceDelegates#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontravariancedelegates/vb/example.vb#4)]  
  
 <span data-ttu-id="16fb3-178">Poslední část kódu znázorňuje, delegát může být přiřazen proměnné typu `Func<Derived, Base>` (`Func(Of Derived, Base)` v jazyce Visual Basic), kombinací vlivu kontravariantního typu parametru a kovariantního návratového typu.</span><span class="sxs-lookup"><span data-stu-id="16fb3-178">The final piece of code shows that the delegate can be assigned to a variable of type `Func<Derived, Base>` (`Func(Of Derived, Base)` in Visual Basic), combining the effects of the contravariant parameter type and the covariant return type.</span></span>  
  
 [!code-csharp[CoContravarianceDelegates#5](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontravariancedelegates/cs/example.cs#5)]
 [!code-vb[CoContravarianceDelegates#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontravariancedelegates/vb/example.vb#5)]  
  
### <a name="variance-in-generic-and-non-generic-delegates"></a><span data-ttu-id="16fb3-179">Variance obecných a neobecných delegátů</span><span class="sxs-lookup"><span data-stu-id="16fb3-179">Variance in Generic and Non-Generic Delegates</span></span>  
 <span data-ttu-id="16fb3-180">V předchozím kódu podpis `MyMethod` přesně shoduje se signaturou konstruovaného obecného delegátu: `Func<Base, Derived>` (`Func(Of Base, Derived)` v jazyce Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="16fb3-180">In the preceding code, the signature of `MyMethod` exactly matches the signature of the constructed generic delegate: `Func<Base, Derived>` (`Func(Of Base, Derived)` in Visual Basic).</span></span> <span data-ttu-id="16fb3-181">Příklad ukazuje, že tento obecný delegát může být uložen v proměnných nebo parametrech metod, které mají více odvozené typy parametrů a méně odvozené návratové typy tak dlouho, dokud všechny typy delegátů jsou konstruovány ze typu obecného delegátu <xref:System.Func%602>.</span><span class="sxs-lookup"><span data-stu-id="16fb3-181">The example shows that this generic delegate can be stored in variables or method parameters that have more derived parameter types and less derived return types, as long as all the delegate types are constructed from the generic delegate type <xref:System.Func%602>.</span></span>  
  
 <span data-ttu-id="16fb3-182">Jedná se o důležitý fakt.</span><span class="sxs-lookup"><span data-stu-id="16fb3-182">This is an important point.</span></span> <span data-ttu-id="16fb3-183">Účinky kovariance a kontravariance v parametrech typu obecných delegátů jsou podobné účinkům kovariance a kontravariance v běžných vazbách delegátů (viz [odchylky v delegátech](https://msdn.microsoft.com/library/e3b98197-6c5b-4e55-9c6e-9739b60645ca)).</span><span class="sxs-lookup"><span data-stu-id="16fb3-183">The effects of covariance and contravariance in the type parameters of generic delegates are similar to the effects of covariance and contravariance in ordinary delegate binding (see [Variance in Delegates](https://msdn.microsoft.com/library/e3b98197-6c5b-4e55-9c6e-9739b60645ca)).</span></span> <span data-ttu-id="16fb3-184">Variance ve vazbě delegátu však funguje se všemi typy delegátů, nejen s obecnými typy delegátu, které mají parametry variantního typu.</span><span class="sxs-lookup"><span data-stu-id="16fb3-184">However, variance in delegate binding works with all delegate types, not just with generic delegate types that have variant type parameters.</span></span> <span data-ttu-id="16fb3-185">Variance ve vazbách delegátů navíc umožňuje metodě vázat se na jakýkoli delegát, který má více omezující parametry typu a méně omezující návratový typ, zatímco přiřazení obecných delegátů funguje pouze v případě, že oba typy delegátů jsou konstruovány ze stejné definice obecného typu.</span><span class="sxs-lookup"><span data-stu-id="16fb3-185">Furthermore, variance in delegate binding enables a method to be bound to any delegate that has more restrictive parameter types and a less restrictive return type, whereas the assignment of generic delegates works only if both delegate types are constructed from the same generic type definition.</span></span>  
  
 <span data-ttu-id="16fb3-186">Následující příklad znázorňuje kombinované účinky variance ve vazbě delegátu a variance u parametrů obecného typu.</span><span class="sxs-lookup"><span data-stu-id="16fb3-186">The following example shows the combined effects of variance in delegate binding and variance in generic type parameters.</span></span> <span data-ttu-id="16fb3-187">Příklad definuje hierarchie typů, která zahrnuje tři typy od nejméně odvozené (`Type1`) k nejvíce odvozenému (`Type3`).</span><span class="sxs-lookup"><span data-stu-id="16fb3-187">The example defines a type hierarchy that includes three types, from least derived (`Type1`) to most derived (`Type3`).</span></span> <span data-ttu-id="16fb3-188">Odchylky v běžných vazbách delegátů se používá k navázání metody s parametrem typu `Type1` a návratový typ `Type3` k obecnému delegátu s parametrem typu `Type2` a návratový typ `Type2`.</span><span class="sxs-lookup"><span data-stu-id="16fb3-188">Variance in ordinary delegate binding is used to bind a method with a parameter type of `Type1` and a return type of `Type3` to a generic delegate with a parameter type of `Type2` and a return type of `Type2`.</span></span> <span data-ttu-id="16fb3-189">Výsledný obecný delegát je poté přiřazen jiné proměnné, jejíž typ obecného delegátu má parametr typu `Type3` a návratový typ `Type1`, použitím kovariance a kontravariance parametrů obecného typu.</span><span class="sxs-lookup"><span data-stu-id="16fb3-189">The resulting generic delegate is then assigned to another variable whose generic delegate type has a parameter of type `Type3` and a return type of `Type1`, using the covariance and contravariance of generic type parameters.</span></span> <span data-ttu-id="16fb3-190">Druhé přiřazení vyžaduje typ proměnné i typ delegátu byly konstruovány ze stejné obecné definice typu, v tomto případě <xref:System.Func%602>.</span><span class="sxs-lookup"><span data-stu-id="16fb3-190">The second assignment requires both the variable type and the delegate type to be constructed from the same generic type definition, in this case, <xref:System.Func%602>.</span></span>  
  
 [!code-csharp[CoContravarianceDelegatesGenRelaxed#1](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontravariancedelegatesgenrelaxed/cs/example.cs#1)]
 [!code-vb[CoContravarianceDelegatesGenRelaxed#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontravariancedelegatesgenrelaxed/vb/example.vb#1)]  
  
 [<span data-ttu-id="16fb3-191">Zpět na začátek</span><span class="sxs-lookup"><span data-stu-id="16fb3-191">Back to top</span></span>](#top)  
  
<a name="DefiningVariantTypeParameters"></a>   
## <a name="defining-variant-generic-interfaces-and-delegates"></a><span data-ttu-id="16fb3-192">Definování variantních obecných rozhraní a delegátů</span><span class="sxs-lookup"><span data-stu-id="16fb3-192">Defining Variant Generic Interfaces and Delegates</span></span>  
 <span data-ttu-id="16fb3-193">Počínaje [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)], Visual Basic a C# mít klíčová slova, která umožňují označit parametry obecného typu rozhraní a delegátů jako kovariantní nebo kontravariantní.</span><span class="sxs-lookup"><span data-stu-id="16fb3-193">Starting with the [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)], Visual Basic and C# have keywords that enable you to mark the generic type parameters of interfaces and delegates as covariant or contravariant.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="16fb3-194">Počínaje verzí 2.0 rozhraní .NET Framework podporuje modul CLR (Common Language Runtime) anotace variance v parametrech obecného typu.</span><span class="sxs-lookup"><span data-stu-id="16fb3-194">Starting with the .NET Framework version 2.0, the common language runtime supports variance annotations on generic type parameters.</span></span> <span data-ttu-id="16fb3-195">Před verzí [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)], je jediný způsob, jak definovat obecné třídy, která má tyto anotace použít jazyk Microsoft intermediate language (MSIL) buď kompilováním třídy pomocí [Ilasm.exe (IL Assembler)](../../../docs/framework/tools/ilasm-exe-il-assembler.md) anebo jejím v dynamické sestavení.</span><span class="sxs-lookup"><span data-stu-id="16fb3-195">Prior to the [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)], the only way to define a generic class that has these annotations is to use Microsoft intermediate language (MSIL), either by compiling the class with [Ilasm.exe (IL Assembler)](../../../docs/framework/tools/ilasm-exe-il-assembler.md) or by emitting it in a dynamic assembly.</span></span>  
  
 <span data-ttu-id="16fb3-196">Typ kovariantního parametru je označen klíčovým `out` – klíčové slovo (`Out` – klíčové slovo v jazyce Visual Basic `+` pro [jazyk MSIL Assembler](../../../docs/framework/tools/ilasm-exe-il-assembler.md)).</span><span class="sxs-lookup"><span data-stu-id="16fb3-196">A covariant type parameter is marked with the `out` keyword (`Out` keyword in Visual Basic, `+` for the [MSIL Assembler](../../../docs/framework/tools/ilasm-exe-il-assembler.md)).</span></span> <span data-ttu-id="16fb3-197">Parametr kovariantního typu můžete použít jako návratovou hodnotu metody, která patří do rozhraní, nebo jako návratový typ delegátu.</span><span class="sxs-lookup"><span data-stu-id="16fb3-197">You can use a covariant type parameter as the return value of a method that belongs to an interface, or as the return type of a delegate.</span></span> <span data-ttu-id="16fb3-198">Typ kovariantního parametru nelze použít jako omezení obecného typu pro metody rozhraní.</span><span class="sxs-lookup"><span data-stu-id="16fb3-198">You cannot use a covariant type parameter as a generic type constraint for interface methods.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="16fb3-199">Pokud má metoda rozhraní parametr, který je typem obecného delegátu, může parametr kovariantního typu pro typ rozhraní být použit pro zadání parametru kontravariantního typu pro typ delegátu.</span><span class="sxs-lookup"><span data-stu-id="16fb3-199">If a method of an interface has a parameter that is a generic delegate type, a covariant type parameter of the interface type can be used to specify a contravariant type parameter of the delegate type.</span></span>  
  
 <span data-ttu-id="16fb3-200">Parametr kontravariantního typu je označené `in` – klíčové slovo (`In` – klíčové slovo v jazyce Visual Basic `-` pro [jazyk MSIL Assembler](../../../docs/framework/tools/ilasm-exe-il-assembler.md)).</span><span class="sxs-lookup"><span data-stu-id="16fb3-200">A contravariant type parameter is marked with the `in` keyword (`In` keyword in Visual Basic, `-` for the [MSIL Assembler](../../../docs/framework/tools/ilasm-exe-il-assembler.md)).</span></span> <span data-ttu-id="16fb3-201">Parametr kontravariantního typu můžete použít jako typ parametru metody, která patří do rozhraní, nebo jako typ parametru delegátu.</span><span class="sxs-lookup"><span data-stu-id="16fb3-201">You can use a contravariant type parameter as the type of a parameter of a method that belongs to an interface, or as the type of a parameter of a delegate.</span></span> <span data-ttu-id="16fb3-202">Parametr kontravariantního typu lze použít jako omezení obecného typu pro metodu rozhraní.</span><span class="sxs-lookup"><span data-stu-id="16fb3-202">You can use a contravariant type parameter as a generic type constraint for an interface method.</span></span>  
  
 <span data-ttu-id="16fb3-203">Pouze typy rozhraní a typy delegátů mohou mít parametry variantního typu.</span><span class="sxs-lookup"><span data-stu-id="16fb3-203">Only interface types and delegate types can have variant type parameters.</span></span> <span data-ttu-id="16fb3-204">Typy rozhraní nebo delegátů mohou mít parametry kovariantního i kontravariantního typu.</span><span class="sxs-lookup"><span data-stu-id="16fb3-204">An interface or delegate type can have both covariant and contravariant type parameters.</span></span>  
  
 <span data-ttu-id="16fb3-205">Jazyky Visual Basic a C# neumožňují porušení pravidel pro použití parametrů kovariantního a kontravariantního typu nebo přidání anotací kovariance a kontravariance parametrům typu pro jiné typy, než jsou typy rozhraní a delegátů.</span><span class="sxs-lookup"><span data-stu-id="16fb3-205">Visual Basic and C# do not allow you to violate the rules for using covariant and contravariant type parameters, or to add covariance and contravariance annotations to the type parameters of types other than interfaces and delegates.</span></span> <span data-ttu-id="16fb3-206">[Jazyk MSIL Assembler](../../../docs/framework/tools/ilasm-exe-il-assembler.md) neprovádí tyto kontroly, ale <xref:System.TypeLoadException> je vyvolána, pokud se pokusíte načíst typ, který porušuje pravidla.</span><span class="sxs-lookup"><span data-stu-id="16fb3-206">The [MSIL Assembler](../../../docs/framework/tools/ilasm-exe-il-assembler.md) does not perform such checks, but a <xref:System.TypeLoadException> is thrown if you try to load a type that violates the rules.</span></span>  
  
 <span data-ttu-id="16fb3-207">Informace a příklady kódu naleznete v tématu [odchylky obecných rozhraní](https://msdn.microsoft.com/library/e14322da-1db3-42f2-9a67-397daddd6b6a).</span><span class="sxs-lookup"><span data-stu-id="16fb3-207">For information and example code, see [Variance in Generic Interfaces](https://msdn.microsoft.com/library/e14322da-1db3-42f2-9a67-397daddd6b6a).</span></span>  
  
 [<span data-ttu-id="16fb3-208">Zpět na začátek</span><span class="sxs-lookup"><span data-stu-id="16fb3-208">Back to top</span></span>](#top)  
  
<a name="VariantList"></a>   
## <a name="list-of-variant-generic-interface-and-delegate-types"></a><span data-ttu-id="16fb3-209">Seznam variantních obecných typů rozhraní a delegátů</span><span class="sxs-lookup"><span data-stu-id="16fb3-209">List of Variant Generic Interface and Delegate Types</span></span>  
 <span data-ttu-id="16fb3-210">V [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)], následující typy rozhraní a delegátů kovariantního a/nebo parametry kontravariantního typu.</span><span class="sxs-lookup"><span data-stu-id="16fb3-210">In the [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)], the following interface and delegate types have covariant and/or contravariant type parameters.</span></span>  
  
|<span data-ttu-id="16fb3-211">Typ</span><span class="sxs-lookup"><span data-stu-id="16fb3-211">Type</span></span>|<span data-ttu-id="16fb3-212">Parametry kovariantního typu</span><span class="sxs-lookup"><span data-stu-id="16fb3-212">Covariant type parameters</span></span>|<span data-ttu-id="16fb3-213">Parametry kontravariantního typu</span><span class="sxs-lookup"><span data-stu-id="16fb3-213">Contravariant type parameters</span></span>|  
|----------|-------------------------------|-----------------------------------|  
|<span data-ttu-id="16fb3-214"><xref:System.Action%601> k <xref:System.Action%6016></span><span class="sxs-lookup"><span data-stu-id="16fb3-214"><xref:System.Action%601> to <xref:System.Action%6016></span></span>||<span data-ttu-id="16fb3-215">Ano</span><span class="sxs-lookup"><span data-stu-id="16fb3-215">Yes</span></span>|  
|<xref:System.Comparison%601>||<span data-ttu-id="16fb3-216">Ano</span><span class="sxs-lookup"><span data-stu-id="16fb3-216">Yes</span></span>|  
|<xref:System.Converter%602>|<span data-ttu-id="16fb3-217">Ano</span><span class="sxs-lookup"><span data-stu-id="16fb3-217">Yes</span></span>|<span data-ttu-id="16fb3-218">Ano</span><span class="sxs-lookup"><span data-stu-id="16fb3-218">Yes</span></span>|  
|<xref:System.Func%601>|<span data-ttu-id="16fb3-219">Ano</span><span class="sxs-lookup"><span data-stu-id="16fb3-219">Yes</span></span>||  
|<span data-ttu-id="16fb3-220"><xref:System.Func%602> k <xref:System.Func%6017></span><span class="sxs-lookup"><span data-stu-id="16fb3-220"><xref:System.Func%602> to <xref:System.Func%6017></span></span>|<span data-ttu-id="16fb3-221">Ano</span><span class="sxs-lookup"><span data-stu-id="16fb3-221">Yes</span></span>|<span data-ttu-id="16fb3-222">Ano</span><span class="sxs-lookup"><span data-stu-id="16fb3-222">Yes</span></span>|  
|<xref:System.IComparable%601>||<span data-ttu-id="16fb3-223">Ano</span><span class="sxs-lookup"><span data-stu-id="16fb3-223">Yes</span></span>|  
|<xref:System.Predicate%601>||<span data-ttu-id="16fb3-224">Ano</span><span class="sxs-lookup"><span data-stu-id="16fb3-224">Yes</span></span>|  
|<xref:System.Collections.Generic.IComparer%601>||<span data-ttu-id="16fb3-225">Ano</span><span class="sxs-lookup"><span data-stu-id="16fb3-225">Yes</span></span>|  
|<xref:System.Collections.Generic.IEnumerable%601>|<span data-ttu-id="16fb3-226">Ano</span><span class="sxs-lookup"><span data-stu-id="16fb3-226">Yes</span></span>||  
|<xref:System.Collections.Generic.IEnumerator%601>|<span data-ttu-id="16fb3-227">Ano</span><span class="sxs-lookup"><span data-stu-id="16fb3-227">Yes</span></span>||  
|<xref:System.Collections.Generic.IEqualityComparer%601>||<span data-ttu-id="16fb3-228">Ano</span><span class="sxs-lookup"><span data-stu-id="16fb3-228">Yes</span></span>|  
|<xref:System.Linq.IGrouping%602>|<span data-ttu-id="16fb3-229">Ano</span><span class="sxs-lookup"><span data-stu-id="16fb3-229">Yes</span></span>||  
|<xref:System.Linq.IOrderedEnumerable%601>|<span data-ttu-id="16fb3-230">Ano</span><span class="sxs-lookup"><span data-stu-id="16fb3-230">Yes</span></span>||  
|<xref:System.Linq.IOrderedQueryable%601>|<span data-ttu-id="16fb3-231">Ano</span><span class="sxs-lookup"><span data-stu-id="16fb3-231">Yes</span></span>||  
|<xref:System.Linq.IQueryable%601>|<span data-ttu-id="16fb3-232">Ano</span><span class="sxs-lookup"><span data-stu-id="16fb3-232">Yes</span></span>||  
  
## <a name="see-also"></a><span data-ttu-id="16fb3-233">Viz také</span><span class="sxs-lookup"><span data-stu-id="16fb3-233">See Also</span></span>  
 [<span data-ttu-id="16fb3-234">Kovariance a kontravariance (C#)</span><span class="sxs-lookup"><span data-stu-id="16fb3-234">Covariance and Contravariance (C#)</span></span>](../../csharp/programming-guide/concepts/covariance-contravariance/index.md)  
 <span data-ttu-id="16fb3-235">[Kovariance a kontravariance (Visual Basic)](../../visual-basic/programming-guide/concepts/covariance-contravariance/index.md)  </span><span class="sxs-lookup"><span data-stu-id="16fb3-235">[Covariance and Contravariance (Visual Basic)](../../visual-basic/programming-guide/concepts/covariance-contravariance/index.md)  </span></span>  
 [<span data-ttu-id="16fb3-236">Odchylky v delegátech</span><span class="sxs-lookup"><span data-stu-id="16fb3-236">Variance in Delegates</span></span>](https://msdn.microsoft.com/library/e3b98197-6c5b-4e55-9c6e-9739b60645ca)
