---
title: Pokyny pro kolekce
ms.date: 10/22/2008
ms.technology: dotnet-standard
ms.assetid: 297b8f1d-b11f-4dc6-960a-8e990817304e
ms.openlocfilehash: cc853be2310cf72c4eb559f625c6a37a44ed7db8
ms.sourcegitcommit: 33deec3e814238fb18a49b2a7e89278e27888291
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 06/02/2020
ms.locfileid: "84276046"
---
# <a name="guidelines-for-collections"></a><span data-ttu-id="1e130-102">Pokyny pro kolekce</span><span class="sxs-lookup"><span data-stu-id="1e130-102">Guidelines for Collections</span></span>
<span data-ttu-id="1e130-103">Jakýkoli typ navržený specificky pro manipulaci se skupinou objektů s některými běžnými charakteristikami lze považovat za kolekci.</span><span class="sxs-lookup"><span data-stu-id="1e130-103">Any type designed specifically to manipulate a group of objects having some common characteristic can be considered a collection.</span></span> <span data-ttu-id="1e130-104">Je téměř vždy vhodný pro tyto typy, které mají <xref:System.Collections.IEnumerable> být implementovány nebo <xref:System.Collections.Generic.IEnumerable%601> , takže v této části považujeme pouze typy implementující jedno nebo obě tato rozhraní na kolekce.</span><span class="sxs-lookup"><span data-stu-id="1e130-104">It is almost always appropriate for such types to implement <xref:System.Collections.IEnumerable> or <xref:System.Collections.Generic.IEnumerable%601>, so in this section we only consider types implementing one or both of those interfaces to be collections.</span></span>

 <span data-ttu-id="1e130-105">❌Ve veřejných rozhraních API nepoužívejte slabě typované kolekce.</span><span class="sxs-lookup"><span data-stu-id="1e130-105">❌ DO NOT use weakly typed collections in public APIs.</span></span>

 <span data-ttu-id="1e130-106">Typ všech vrácených hodnot a parametrů představujících položky kolekce by měl být přesný typ položky, nikoli žádný z jeho základních typů (platí pouze pro veřejné členy kolekce).</span><span class="sxs-lookup"><span data-stu-id="1e130-106">The type of all return values and parameters representing collection items should be the exact item type, not any of its base types (this applies only to public members of the collection).</span></span>

 <span data-ttu-id="1e130-107">❌Nepoužívejte <xref:System.Collections.ArrayList> ani <xref:System.Collections.Generic.List%601> ve veřejných rozhraních API.</span><span class="sxs-lookup"><span data-stu-id="1e130-107">❌ DO NOT use <xref:System.Collections.ArrayList> or <xref:System.Collections.Generic.List%601> in public APIs.</span></span>

 <span data-ttu-id="1e130-108">Tyto typy jsou datové struktury navržené pro použití v interní implementaci, nikoli ve veřejných rozhraních API.</span><span class="sxs-lookup"><span data-stu-id="1e130-108">These types are data structures designed to be used in internal implementation, not in public APIs.</span></span> <span data-ttu-id="1e130-109">`List<T>`je optimalizováno pro výkon a zvýšení nákladů na vyčištění rozhraní API a flexibility.</span><span class="sxs-lookup"><span data-stu-id="1e130-109">`List<T>` is optimized for performance and power at the cost of cleanness of the APIs and flexibility.</span></span> <span data-ttu-id="1e130-110">Pokud například vrátíte, nebudete `List<T>` někdy moci dostávat oznámení, když kód klienta upraví kolekci.</span><span class="sxs-lookup"><span data-stu-id="1e130-110">For example, if you return `List<T>`, you will not ever be able to receive notifications when client code modifies the collection.</span></span> <span data-ttu-id="1e130-111">Také `List<T>` zpřístupňuje mnoho členů, například <xref:System.Collections.Generic.List%601.BinarySearch%2A> , které nejsou užitečné nebo použitelné v mnoha scénářích.</span><span class="sxs-lookup"><span data-stu-id="1e130-111">Also, `List<T>` exposes many members, such as <xref:System.Collections.Generic.List%601.BinarySearch%2A>, that are not useful or applicable in many scenarios.</span></span> <span data-ttu-id="1e130-112">Následující dvě části popisují typy (abstrakce) navržené speciálně pro použití ve veřejných rozhraních API.</span><span class="sxs-lookup"><span data-stu-id="1e130-112">The following two sections describe types (abstractions) designed specifically for use in public APIs.</span></span>

 <span data-ttu-id="1e130-113">❌Nepoužívejte `Hashtable` ani `Dictionary<TKey,TValue>` ve veřejných rozhraních API.</span><span class="sxs-lookup"><span data-stu-id="1e130-113">❌ DO NOT use `Hashtable` or `Dictionary<TKey,TValue>` in public APIs.</span></span>

 <span data-ttu-id="1e130-114">Tyto typy jsou datové struktury navržené pro použití při interní implementaci.</span><span class="sxs-lookup"><span data-stu-id="1e130-114">These types are data structures designed to be used in internal implementation.</span></span> <span data-ttu-id="1e130-115">Veřejná rozhraní API by měla používat <xref:System.Collections.IDictionary> , `IDictionary <TKey, TValue>` nebo vlastní typ implementující jedno nebo obě rozhraní.</span><span class="sxs-lookup"><span data-stu-id="1e130-115">Public APIs should use <xref:System.Collections.IDictionary>, `IDictionary <TKey, TValue>`, or a custom type implementing one or both of the interfaces.</span></span>

 <span data-ttu-id="1e130-116">❌Nepoužívejte <xref:System.Collections.Generic.IEnumerator%601> , <xref:System.Collections.IEnumerator> nebo jakýkoli jiný typ, který implementuje jedno z těchto rozhraní, s výjimkou návratového typu `GetEnumerator` metody.</span><span class="sxs-lookup"><span data-stu-id="1e130-116">❌ DO NOT use <xref:System.Collections.Generic.IEnumerator%601>, <xref:System.Collections.IEnumerator>, or any other type that implements either of these interfaces, except as the return type of a `GetEnumerator` method.</span></span>

 <span data-ttu-id="1e130-117">Typy vracející enumerátory z jiných metod než `GetEnumerator` nelze použít spolu s `foreach` příkazem.</span><span class="sxs-lookup"><span data-stu-id="1e130-117">Types returning enumerators from methods other than `GetEnumerator` cannot be used with the `foreach` statement.</span></span>

 <span data-ttu-id="1e130-118">❌Neimplementujte i `IEnumerator<T>` `IEnumerable<T>` na stejný typ.</span><span class="sxs-lookup"><span data-stu-id="1e130-118">❌ DO NOT implement both `IEnumerator<T>` and `IEnumerable<T>` on the same type.</span></span> <span data-ttu-id="1e130-119">Totéž platí pro neobecná rozhraní `IEnumerator` a `IEnumerable` .</span><span class="sxs-lookup"><span data-stu-id="1e130-119">The same applies to the nongeneric interfaces `IEnumerator` and `IEnumerable`.</span></span>

## <a name="collection-parameters"></a><span data-ttu-id="1e130-120">Parametry kolekce</span><span class="sxs-lookup"><span data-stu-id="1e130-120">Collection Parameters</span></span>
 <span data-ttu-id="1e130-121">✔️ použít jako typ parametru možnost minimálního specializovaného typu.</span><span class="sxs-lookup"><span data-stu-id="1e130-121">✔️ DO use the least-specialized type possible as a parameter type.</span></span> <span data-ttu-id="1e130-122">Většina členů přibírajících kolekce jako parametry používají `IEnumerable<T>` rozhraní.</span><span class="sxs-lookup"><span data-stu-id="1e130-122">Most members taking collections as parameters use the `IEnumerable<T>` interface.</span></span>

 <span data-ttu-id="1e130-123">❌Nepoužívejte <xref:System.Collections.Generic.ICollection%601> <xref:System.Collections.ICollection> parametr nebo jako parametr pouze pro přístup k `Count` Vlastnosti.</span><span class="sxs-lookup"><span data-stu-id="1e130-123">❌ AVOID using <xref:System.Collections.Generic.ICollection%601> or <xref:System.Collections.ICollection> as a parameter just to access the `Count` property.</span></span>

 <span data-ttu-id="1e130-124">Místo toho zvažte použití `IEnumerable<T>` nebo `IEnumerable` a dynamicky se kontroluje, zda objekt implementuje `ICollection<T>` nebo `ICollection` .</span><span class="sxs-lookup"><span data-stu-id="1e130-124">Instead, consider using `IEnumerable<T>` or `IEnumerable` and dynamically checking whether the object implements `ICollection<T>` or `ICollection`.</span></span>

## <a name="collection-properties-and-return-values"></a><span data-ttu-id="1e130-125">Vlastnosti kolekce a návratové hodnoty</span><span class="sxs-lookup"><span data-stu-id="1e130-125">Collection Properties and Return Values</span></span>
 <span data-ttu-id="1e130-126">❌Nevytvářejte vlastnosti nastavitelné kolekce.</span><span class="sxs-lookup"><span data-stu-id="1e130-126">❌ DO NOT provide settable collection properties.</span></span>

 <span data-ttu-id="1e130-127">Uživatelé mohou obsah kolekce nahradit tak, že nejprve vymaže kolekci a následně přidají nový obsah.</span><span class="sxs-lookup"><span data-stu-id="1e130-127">Users can replace the contents of the collection by clearing the collection first and then adding the new contents.</span></span> <span data-ttu-id="1e130-128">Pokud je nahrazení celé kolekce běžným scénářem, zvažte poskytnutí `AddRange` metody v kolekci.</span><span class="sxs-lookup"><span data-stu-id="1e130-128">If replacing the whole collection is a common scenario, consider providing the `AddRange` method on the collection.</span></span>

 <span data-ttu-id="1e130-129">✔️ použít `Collection<T>` nebo podtřídu `Collection<T>` pro vlastnosti nebo návratové hodnoty reprezentující kolekce pro čtení i zápis.</span><span class="sxs-lookup"><span data-stu-id="1e130-129">✔️ DO use `Collection<T>` or a subclass of `Collection<T>` for properties or return values representing read/write collections.</span></span>

 <span data-ttu-id="1e130-130">Pokud `Collection<T>` nesplňuje určitý požadavek (například kolekce nesmí implementovat <xref:System.Collections.IList> ), použijte vlastní kolekci implementací `IEnumerable<T>` , `ICollection<T>` nebo <xref:System.Collections.Generic.IList%601> .</span><span class="sxs-lookup"><span data-stu-id="1e130-130">If `Collection<T>` does not meet some requirement (e.g., the collection must not implement <xref:System.Collections.IList>), use a custom collection by implementing `IEnumerable<T>`, `ICollection<T>`, or <xref:System.Collections.Generic.IList%601>.</span></span>

 <span data-ttu-id="1e130-131">✔️ použít <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> , podtřídu `ReadOnlyCollection<T>` nebo ve výjimečných případech `IEnumerable<T>` pro vlastnosti nebo návratové hodnoty, které představují kolekce jen pro čtení.</span><span class="sxs-lookup"><span data-stu-id="1e130-131">✔️ DO use <xref:System.Collections.ObjectModel.ReadOnlyCollection%601>, a subclass of `ReadOnlyCollection<T>`, or in rare cases `IEnumerable<T>` for properties or return values representing read-only collections.</span></span>

 <span data-ttu-id="1e130-132">Obecně je vhodnější `ReadOnlyCollection<T>` .</span><span class="sxs-lookup"><span data-stu-id="1e130-132">In general, prefer `ReadOnlyCollection<T>`.</span></span> <span data-ttu-id="1e130-133">Pokud nesplňuje určitý požadavek (například kolekce nesmí implementovat `IList` ), použijte vlastní kolekci implementací `IEnumerable<T>` , `ICollection<T>` nebo `IList<T>` .</span><span class="sxs-lookup"><span data-stu-id="1e130-133">If it does not meet some requirement (e.g., the collection must not implement `IList`), use a custom collection by implementing `IEnumerable<T>`, `ICollection<T>`, or `IList<T>`.</span></span> <span data-ttu-id="1e130-134">Pokud implementujete vlastní kolekci jen pro čtení, implementujte `ICollection<T>.IsReadOnly` pro návrat `true` .</span><span class="sxs-lookup"><span data-stu-id="1e130-134">If you do implement a custom read-only collection, implement `ICollection<T>.IsReadOnly` to return `true`.</span></span>

 <span data-ttu-id="1e130-135">V případech, kdy jste si jisti, že jediný scénář, který budete chtít někdy podporovat, je pouze iterace jenom pro přeposílání, můžete jednoduše použít `IEnumerable<T>` .</span><span class="sxs-lookup"><span data-stu-id="1e130-135">In cases where you are sure that the only scenario you will ever want to support is forward-only iteration, you can simply use `IEnumerable<T>`.</span></span>

 <span data-ttu-id="1e130-136">✔️ Zvažte použití podtříd obecných základních kolekcí namísto přímého použití kolekcí.</span><span class="sxs-lookup"><span data-stu-id="1e130-136">✔️ CONSIDER using subclasses of generic base collections instead of using the collections directly.</span></span>

 <span data-ttu-id="1e130-137">To umožňuje lepší název a přidání pomocných členů, kteří nejsou přítomni v základních typech kolekce.</span><span class="sxs-lookup"><span data-stu-id="1e130-137">This allows for a better name and for adding helper members that are not present on the base collection types.</span></span> <span data-ttu-id="1e130-138">To se hodí hlavně pro rozhraní API vysoké úrovně.</span><span class="sxs-lookup"><span data-stu-id="1e130-138">This is especially applicable to high-level APIs.</span></span>

 <span data-ttu-id="1e130-139">✔️ Zvažte vrácení podtřídy `Collection<T>` nebo `ReadOnlyCollection<T>` z velmi běžně používaných metod a vlastností.</span><span class="sxs-lookup"><span data-stu-id="1e130-139">✔️ CONSIDER returning a subclass of `Collection<T>` or `ReadOnlyCollection<T>` from very commonly used methods and properties.</span></span>

 <span data-ttu-id="1e130-140">To umožní přidat pomocné metody nebo změnit implementaci kolekce v budoucnu.</span><span class="sxs-lookup"><span data-stu-id="1e130-140">This will make it possible for you to add helper methods or change the collection implementation in the future.</span></span>

 <span data-ttu-id="1e130-141">✔️ Zvažte použití kolekce s klíčem, pokud položky uložené v kolekci mají jedinečné klíče (jména, ID atd.).</span><span class="sxs-lookup"><span data-stu-id="1e130-141">✔️ CONSIDER using a keyed collection if the items stored in the collection have unique keys (names, IDs, etc.).</span></span> <span data-ttu-id="1e130-142">Kolekce s klíčem jsou kolekce, které mohou být indexovány pomocí celého čísla i klíče a jsou obvykle implementovány děděním z `KeyedCollection<TKey,TItem>` .</span><span class="sxs-lookup"><span data-stu-id="1e130-142">Keyed collections are collections that can be indexed by both an integer and a key and are usually implemented by inheriting from `KeyedCollection<TKey,TItem>`.</span></span>

 <span data-ttu-id="1e130-143">Kolekce s klíčem mají obvykle větší nároky na paměť a neměly by se používat v případě, že režie paměti převyšuje výhody použití klíčů.</span><span class="sxs-lookup"><span data-stu-id="1e130-143">Keyed collections usually have larger memory footprints and should not be used if the memory overhead outweighs the benefits of having the keys.</span></span>

 <span data-ttu-id="1e130-144">❌Nevracet hodnoty null z vlastností kolekce ani z metod vracejících kolekce.</span><span class="sxs-lookup"><span data-stu-id="1e130-144">❌ DO NOT return null values from collection properties or from methods returning collections.</span></span> <span data-ttu-id="1e130-145">Místo toho se vrátí prázdná kolekce nebo prázdné pole.</span><span class="sxs-lookup"><span data-stu-id="1e130-145">Return an empty collection or an empty array instead.</span></span>

 <span data-ttu-id="1e130-146">Obecným pravidlem je, že kolekce a pole s hodnotou null a prázdné (0 položka) by měly být ošetřeny stejným způsobem.</span><span class="sxs-lookup"><span data-stu-id="1e130-146">The general rule is that null and empty (0 item) collections or arrays should be treated the same.</span></span>

### <a name="snapshots-versus-live-collections"></a><span data-ttu-id="1e130-147">Snímky versus živé kolekce</span><span class="sxs-lookup"><span data-stu-id="1e130-147">Snapshots Versus Live Collections</span></span>
 <span data-ttu-id="1e130-148">Kolekce představující stav v určitém okamžiku se nazývají kolekce snímků.</span><span class="sxs-lookup"><span data-stu-id="1e130-148">Collections representing a state at some point in time are called snapshot collections.</span></span> <span data-ttu-id="1e130-149">Například kolekce obsahující řádky vrácené z databázového dotazu by byla snímkem.</span><span class="sxs-lookup"><span data-stu-id="1e130-149">For example, a collection containing rows returned from a database query would be a snapshot.</span></span> <span data-ttu-id="1e130-150">Kolekce, které vždy představují aktuální stav, se nazývají živé kolekce.</span><span class="sxs-lookup"><span data-stu-id="1e130-150">Collections that always represent the current state are called live collections.</span></span> <span data-ttu-id="1e130-151">Například kolekce `ComboBox` položek je živá kolekce.</span><span class="sxs-lookup"><span data-stu-id="1e130-151">For example, a collection of `ComboBox` items is a live collection.</span></span>

 <span data-ttu-id="1e130-152">❌Nevracet kolekce snímků z vlastností.</span><span class="sxs-lookup"><span data-stu-id="1e130-152">❌ DO NOT return snapshot collections from properties.</span></span> <span data-ttu-id="1e130-153">Vlastnosti by měly vracet živé kolekce.</span><span class="sxs-lookup"><span data-stu-id="1e130-153">Properties should return live collections.</span></span>

 <span data-ttu-id="1e130-154">Metody getter vlastnosti by měly být velmi prosté operace.</span><span class="sxs-lookup"><span data-stu-id="1e130-154">Property getters should be very lightweight operations.</span></span> <span data-ttu-id="1e130-155">Vrácení snímku vyžaduje vytvoření kopie interní kolekce v operaci O (n).</span><span class="sxs-lookup"><span data-stu-id="1e130-155">Returning a snapshot requires creating a copy of an internal collection in an O(n) operation.</span></span>

 <span data-ttu-id="1e130-156">✔️ použít buď kolekci snímků, nebo živý `IEnumerable<T>` (nebo její podtyp) k vyjádření kolekcí, které jsou nestálé (tj., které se mohou změnit bez explicitní úpravy kolekce).</span><span class="sxs-lookup"><span data-stu-id="1e130-156">✔️ DO use either a snapshot collection or a live `IEnumerable<T>` (or its subtype) to represent collections that are volatile (i.e., that can change without explicitly modifying the collection).</span></span>

 <span data-ttu-id="1e130-157">Obecně platí, že všechny kolekce, které představují sdílený prostředek (například soubory v adresáři), jsou nestálé.</span><span class="sxs-lookup"><span data-stu-id="1e130-157">In general, all collections representing a shared resource (e.g., files in a directory) are volatile.</span></span> <span data-ttu-id="1e130-158">Tyto kolekce jsou velmi obtížné nebo nemožné implementovat jako živé kolekce, pokud implementace nestačí jenom pro dopředné enumerátory.</span><span class="sxs-lookup"><span data-stu-id="1e130-158">Such collections are very difficult or impossible to implement as live collections unless the implementation is simply a forward-only enumerator.</span></span>

## <a name="choosing-between-arrays-and-collections"></a><span data-ttu-id="1e130-159">Výběr mezi poli a kolekcemi</span><span class="sxs-lookup"><span data-stu-id="1e130-159">Choosing Between Arrays and Collections</span></span>
 <span data-ttu-id="1e130-160">✔️ preferovat kolekce před poli.</span><span class="sxs-lookup"><span data-stu-id="1e130-160">✔️ DO prefer collections over arrays.</span></span>

 <span data-ttu-id="1e130-161">Kolekce poskytují větší kontrolu nad obsahem, můžou se v průběhu času vyvíjet a jsou užitečnější.</span><span class="sxs-lookup"><span data-stu-id="1e130-161">Collections provide more control over contents, can evolve over time, and are more usable.</span></span> <span data-ttu-id="1e130-162">Kromě toho se nedoporučuje používat pole pro scénáře jen pro čtení, protože náklady na klonování pole jsou zakazují.</span><span class="sxs-lookup"><span data-stu-id="1e130-162">In addition, using arrays for read-only scenarios is discouraged because the cost of cloning the array is prohibitive.</span></span> <span data-ttu-id="1e130-163">Studie použitelnosti ukázaly, že někteří vývojáři se lépe cítí pomocí rozhraní API založených na kolekcích.</span><span class="sxs-lookup"><span data-stu-id="1e130-163">Usability studies have shown that some developers feel more comfortable using collection-based APIs.</span></span>

 <span data-ttu-id="1e130-164">Pokud ale vyvíjíte rozhraní API nízké úrovně, může být lepší použít pole pro scénáře pro čtení i zápis.</span><span class="sxs-lookup"><span data-stu-id="1e130-164">However, if you are developing low-level APIs, it might be better to use arrays for read-write scenarios.</span></span> <span data-ttu-id="1e130-165">Pole mají menší nároky na paměť, což pomáhá snižovat pracovní sadu a přístup k prvkům v poli je rychlejší, protože je optimalizován modulem runtime.</span><span class="sxs-lookup"><span data-stu-id="1e130-165">Arrays have a smaller memory footprint, which helps reduce the working set, and access to elements in an array is faster because it is optimized by the runtime.</span></span>

 <span data-ttu-id="1e130-166">✔️ Zvažte použití polí v rozhraních API nízké úrovně k minimalizaci spotřeby paměti a maximalizaci výkonu.</span><span class="sxs-lookup"><span data-stu-id="1e130-166">✔️ CONSIDER using arrays in low-level APIs to minimize memory consumption and maximize performance.</span></span>

 <span data-ttu-id="1e130-167">✔️ místo kolekcí bajtů použít pole bajtů.</span><span class="sxs-lookup"><span data-stu-id="1e130-167">✔️ DO use byte arrays instead of collections of bytes.</span></span>

 <span data-ttu-id="1e130-168">❌Nepoužívejte pole pro vlastnosti, pokud by vlastnost musela vracet nové pole (například kopie interního pole) pokaždé, když je volána vlastnost getter.</span><span class="sxs-lookup"><span data-stu-id="1e130-168">❌ DO NOT use arrays for properties if the property would have to return a new array (e.g., a copy of an internal array) every time the property getter is called.</span></span>

## <a name="implementing-custom-collections"></a><span data-ttu-id="1e130-169">Implementace vlastních kolekcí</span><span class="sxs-lookup"><span data-stu-id="1e130-169">Implementing Custom Collections</span></span>
 <span data-ttu-id="1e130-170">✔️ Zvažte dědění z `Collection<T>` , `ReadOnlyCollection<T>` nebo `KeyedCollection<TKey,TItem>` při navrhování nových kolekcí.</span><span class="sxs-lookup"><span data-stu-id="1e130-170">✔️ CONSIDER inheriting from `Collection<T>`, `ReadOnlyCollection<T>`, or `KeyedCollection<TKey,TItem>` when designing new collections.</span></span>

 <span data-ttu-id="1e130-171">✔️ PROVÉST implementaci `IEnumerable<T>` při navrhování nových kolekcí.</span><span class="sxs-lookup"><span data-stu-id="1e130-171">✔️ DO implement `IEnumerable<T>` when designing new collections.</span></span> <span data-ttu-id="1e130-172">Zvažte implementaci `ICollection<T>` nebo i `IList<T>` tam, kde to dává smysl.</span><span class="sxs-lookup"><span data-stu-id="1e130-172">Consider implementing `ICollection<T>` or even `IList<T>` where it makes sense.</span></span>

 <span data-ttu-id="1e130-173">Při implementaci takové vlastní kolekce postupujte podle vzoru rozhraní API vytvořeného `Collection<T>` a `ReadOnlyCollection<T>` co nejpřesněji.</span><span class="sxs-lookup"><span data-stu-id="1e130-173">When implementing such custom collection, follow the API pattern established by `Collection<T>` and `ReadOnlyCollection<T>` as closely as possible.</span></span> <span data-ttu-id="1e130-174">To znamená, že je třeba implementovat stejné členy explicitně, pojmenovat parametry jako tyto dvě kolekce a tak dále.</span><span class="sxs-lookup"><span data-stu-id="1e130-174">That is, implement the same members explicitly, name the parameters like these two collections name them, and so on.</span></span>

 <span data-ttu-id="1e130-175">✔️ Zvažte implementaci neobecných rozhraní kolekcí ( `IList` a `ICollection` ), pokud se kolekce často předává rozhraním API, která přebírají tato rozhraní jako vstup.</span><span class="sxs-lookup"><span data-stu-id="1e130-175">✔️ CONSIDER implementing nongeneric collection interfaces (`IList` and `ICollection`) if the collection will often be passed to APIs taking these interfaces as input.</span></span>

 <span data-ttu-id="1e130-176">❌Vyhněte se implementaci rozhraní kolekce u typů se složitými rozhraními API, která nesouvisí s konceptem kolekce.</span><span class="sxs-lookup"><span data-stu-id="1e130-176">❌ AVOID implementing collection interfaces on types with complex APIs unrelated to the concept of a collection.</span></span>

 <span data-ttu-id="1e130-177">❌Nedědit z neobecných základních kolekcí, jako je `CollectionBase` .</span><span class="sxs-lookup"><span data-stu-id="1e130-177">❌ DO NOT inherit from nongeneric base collections such as `CollectionBase`.</span></span> <span data-ttu-id="1e130-178">Použijte `Collection<T>` `ReadOnlyCollection<T>` `KeyedCollection<TKey,TItem>` místo toho, a.</span><span class="sxs-lookup"><span data-stu-id="1e130-178">Use `Collection<T>`, `ReadOnlyCollection<T>`, and `KeyedCollection<TKey,TItem>` instead.</span></span>

### <a name="naming-custom-collections"></a><span data-ttu-id="1e130-179">Pojmenovávání vlastních kolekcí</span><span class="sxs-lookup"><span data-stu-id="1e130-179">Naming Custom Collections</span></span>
 <span data-ttu-id="1e130-180">Kolekce (typy, které implementují `IEnumerable` ) se vytvářejí hlavně ze dvou důvodů: (1) pro vytvoření nové struktury dat s operacemi specifickými pro strukturu a často různé charakteristiky výkonu než stávající datové struktury (např.,, <xref:System.Collections.Generic.List%601> <xref:System.Collections.Generic.LinkedList%601> <xref:System.Collections.Generic.Stack%601> ) a (2) pro vytvoření specializované kolekce pro uchovávání konkrétní sady položek (např. <xref:System.Collections.Specialized.StringCollection> ).</span><span class="sxs-lookup"><span data-stu-id="1e130-180">Collections (types that implement `IEnumerable`) are created mainly for two reasons: (1) to create a new data structure with structure-specific operations and often different performance characteristics than existing data structures (e.g.,  <xref:System.Collections.Generic.List%601>, <xref:System.Collections.Generic.LinkedList%601>, <xref:System.Collections.Generic.Stack%601>), and (2) to create a specialized collection for holding a specific set of items (e.g.,  <xref:System.Collections.Specialized.StringCollection>).</span></span> <span data-ttu-id="1e130-181">V interní implementaci aplikací a knihoven se často používají datové struktury.</span><span class="sxs-lookup"><span data-stu-id="1e130-181">Data structures are most often used in the internal implementation of applications and libraries.</span></span> <span data-ttu-id="1e130-182">Specializované kolekce jsou převážně vystaveny v rozhraních API (jako typy vlastností a parametrů).</span><span class="sxs-lookup"><span data-stu-id="1e130-182">Specialized collections are mainly to be exposed in APIs (as property and parameter types).</span></span>

 <span data-ttu-id="1e130-183">✔️ použít příponu "Dictionary" v názvech implementací abstrakcí `IDictionary` nebo `IDictionary<TKey,TValue>` .</span><span class="sxs-lookup"><span data-stu-id="1e130-183">✔️ DO use the "Dictionary" suffix in names of abstractions implementing `IDictionary` or `IDictionary<TKey,TValue>`.</span></span>

 <span data-ttu-id="1e130-184">✔️ použít příponu "Collection" v názvech typů implementující `IEnumerable` (nebo kterékoli z jeho následníků) a reprezentující seznam položek.</span><span class="sxs-lookup"><span data-stu-id="1e130-184">✔️ DO use the "Collection" suffix in names of types implementing `IEnumerable` (or any of its descendants) and representing a list of items.</span></span>

 <span data-ttu-id="1e130-185">✔️ použijte název příslušné struktury dat pro vlastní datové struktury.</span><span class="sxs-lookup"><span data-stu-id="1e130-185">✔️ DO use the appropriate data structure name for custom data structures.</span></span>

 <span data-ttu-id="1e130-186">❌Nepoužívejte žádné přípony, které by znamenaly konkrétní implementaci, jako je "LinkedList" nebo "zatřiďovací tabulka", v názvech abstrakcí kolekce.</span><span class="sxs-lookup"><span data-stu-id="1e130-186">❌ AVOID using any suffixes implying particular implementation, such as "LinkedList" or "Hashtable," in names of collection abstractions.</span></span>

 <span data-ttu-id="1e130-187">✔️ Zvažte názvy kolekcí s názvem typu položky.</span><span class="sxs-lookup"><span data-stu-id="1e130-187">✔️ CONSIDER prefixing collection names with the name of the item type.</span></span> <span data-ttu-id="1e130-188">Například kolekce, která ukládá položky typu `Address` (implementující `IEnumerable<Address>` ), by měla být pojmenována `AddressCollection` .</span><span class="sxs-lookup"><span data-stu-id="1e130-188">For example, a collection storing items of type `Address` (implementing `IEnumerable<Address>`) should be named `AddressCollection`.</span></span> <span data-ttu-id="1e130-189">Pokud je typ položky rozhraní, může být předpona "I" typu položky vynechána.</span><span class="sxs-lookup"><span data-stu-id="1e130-189">If the item type is an interface, the "I" prefix of the item type can be omitted.</span></span> <span data-ttu-id="1e130-190">Proto <xref:System.IDisposable> lze volat kolekci položek `DisposableCollection` .</span><span class="sxs-lookup"><span data-stu-id="1e130-190">Thus, a collection of <xref:System.IDisposable> items can be called `DisposableCollection`.</span></span>

 <span data-ttu-id="1e130-191">✔️ Zvažte použití předpony "ReadOnly" v názvech kolekcí jen pro čtení, pokud může být do rozhraní přidána odpovídající zapisovatelná kolekce nebo již existuje.</span><span class="sxs-lookup"><span data-stu-id="1e130-191">✔️ CONSIDER using the "ReadOnly" prefix in names of read-only collections if a corresponding writeable collection might be added or already exists in the framework.</span></span>

 <span data-ttu-id="1e130-192">Například by měla být volána kolekce řetězců jen pro čtení `ReadOnlyStringCollection` .</span><span class="sxs-lookup"><span data-stu-id="1e130-192">For example, a read-only collection of strings should be called `ReadOnlyStringCollection`.</span></span>

 <span data-ttu-id="1e130-193">*Části © 2005, 2009 Microsoft Corporation. Všechna práva vyhrazena.*</span><span class="sxs-lookup"><span data-stu-id="1e130-193">*Portions © 2005, 2009 Microsoft Corporation. All rights reserved.*</span></span>

 <span data-ttu-id="1e130-194">*Přetištěno oprávněním Pearsonova vzdělávání, Inc. z [pokynů pro návrh rozhraní: konvence, idiomy a vzory pro opakovaně použitelné knihovny .NET, druhá edice](https://www.informit.com/store/framework-design-guidelines-conventions-idioms-and-9780321545619) od Krzysztof Cwalina a Brad Abrams, publikovaly 22. října 2008 Addison-Wesley Professional jako součást sady Microsoft Windows Development Series.*</span><span class="sxs-lookup"><span data-stu-id="1e130-194">*Reprinted by permission of Pearson Education, Inc. from [Framework Design Guidelines: Conventions, Idioms, and Patterns for Reusable .NET Libraries, 2nd Edition](https://www.informit.com/store/framework-design-guidelines-conventions-idioms-and-9780321545619) by Krzysztof Cwalina and Brad Abrams, published Oct 22, 2008 by Addison-Wesley Professional as part of the Microsoft Windows Development Series.*</span></span>

## <a name="see-also"></a><span data-ttu-id="1e130-195">Viz také</span><span class="sxs-lookup"><span data-stu-id="1e130-195">See also</span></span>

- [<span data-ttu-id="1e130-196">Pokyny k návrhu architektury</span><span class="sxs-lookup"><span data-stu-id="1e130-196">Framework Design Guidelines</span></span>](index.md)
- [<span data-ttu-id="1e130-197">Pokyny k použití</span><span class="sxs-lookup"><span data-stu-id="1e130-197">Usage Guidelines</span></span>](usage-guidelines.md)
