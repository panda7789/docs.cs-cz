---
title: Volba mezi třídou a strukturou
description: Naučte se, jak rozhodnout, zda navrhnout typ jako třídu nebo navrhnout typ jako strukturu. Pochopení způsobu, jakým se v rozhraní .NET liší typy odkazů a typy hodnot
ms.date: 10/22/2008
ms.technology: dotnet-standard
helpviewer_keywords:
- class library design guidelines [.NET Framework], structures
- class library design guidelines [.NET Framework], classes
- structures [.NET Framework], vs. classes
- classes [.NET Framework], design guidelines
- type design guidelines, structures
- structures [.NET Framework], design guidelines
- classes [.NET Framework], vs. structures
- type design guidelines, classes
ms.assetid: f8b8ec9b-0ba7-4dea-aadf-a93395cd804f
ms.openlocfilehash: 9d757e77292c1226fbe2328cce082033ae8f7003
ms.sourcegitcommit: 7137e12f54c4e83a94ae43ec320f8cf59c1772ea
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 06/10/2020
ms.locfileid: "84662599"
---
# <a name="choosing-between-class-and-struct"></a><span data-ttu-id="641cb-104">Volba mezi třídou a strukturou</span><span class="sxs-lookup"><span data-stu-id="641cb-104">Choosing Between Class and Struct</span></span>
<span data-ttu-id="641cb-105">Jedno ze základních rozhodnutí o návrhu každé plošky návrháře architektury je bez ohledu na to, zda je možné navrhnout typ jako třídu (odkazový typ) nebo jako strukturu (typ hodnoty).</span><span class="sxs-lookup"><span data-stu-id="641cb-105">One of the basic design decisions every framework designer faces is whether to design a type as a class (a reference type) or as a struct (a value type).</span></span> <span data-ttu-id="641cb-106">Dobrým porozumění rozdílům v chování typů odkazu a hodnot je rozhodující při této volbě.</span><span class="sxs-lookup"><span data-stu-id="641cb-106">Good understanding of the differences in the behavior of reference types and value types is crucial in making this choice.</span></span>

 <span data-ttu-id="641cb-107">První rozdíl mezi typy odkazů a typy hodnot, které budeme brát v úvahu, je, že typy odkazů jsou přiděleny na haldu a uvolňování paměti, zatímco typy hodnot jsou přiděleny buď v zásobníku, nebo vložené v rámci obsahující typy a navráceny, když se jejich nadřazený typ zruší.</span><span class="sxs-lookup"><span data-stu-id="641cb-107">The first difference between reference types and value types we will consider is that reference types are allocated on the heap and garbage-collected, whereas value types are allocated either on the stack or inline in containing types and deallocated when the stack unwinds or when their containing type gets deallocated.</span></span> <span data-ttu-id="641cb-108">Proto jsou alokace a navracení hodnotových typů všeobecně levnější než přidělení a zrušení přidělení typů odkazů.</span><span class="sxs-lookup"><span data-stu-id="641cb-108">Therefore, allocations and deallocations of value types are in general cheaper than allocations and deallocations of reference types.</span></span>

 <span data-ttu-id="641cb-109">Dále jsou pole typů odkazů rozdělena mimo řádek, což znamená, že prvky pole jsou pouze odkazy na instance typu odkazu, který je umístěn na haldě.</span><span class="sxs-lookup"><span data-stu-id="641cb-109">Next, arrays of reference types are allocated out-of-line, meaning the array elements are just references to instances of the reference type residing on the heap.</span></span> <span data-ttu-id="641cb-110">Pole hodnot typu jsou přidělena jako vložená, což znamená, že prvky pole jsou skutečnými instancemi typu hodnoty.</span><span class="sxs-lookup"><span data-stu-id="641cb-110">Value type arrays are allocated inline, meaning that the array elements are the actual instances of the value type.</span></span> <span data-ttu-id="641cb-111">Proto jsou přidělení a dealokace polí hodnotových typů mnohem levnější než přidělení a zrušení přidělení polí typu odkazu.</span><span class="sxs-lookup"><span data-stu-id="641cb-111">Therefore, allocations and deallocations of value type arrays are much cheaper than allocations and deallocations of reference type arrays.</span></span> <span data-ttu-id="641cb-112">Kromě toho ve většině případů typ hodnoty pole představuje mnohem lepší rozsah odkazů.</span><span class="sxs-lookup"><span data-stu-id="641cb-112">In addition, in a majority of cases value type arrays exhibit much better locality of reference.</span></span>

 <span data-ttu-id="641cb-113">Další rozdíl se týká využití paměti.</span><span class="sxs-lookup"><span data-stu-id="641cb-113">The next difference is related to memory usage.</span></span> <span data-ttu-id="641cb-114">Typy hodnot se při přetypování na typ odkazu nebo na jedno z rozhraní, které implementují, vrátí do pole.</span><span class="sxs-lookup"><span data-stu-id="641cb-114">Value types get boxed when cast to a reference type or one of the interfaces they implement.</span></span> <span data-ttu-id="641cb-115">Po přetypování zpátky na typ hodnoty se rozstanou.</span><span class="sxs-lookup"><span data-stu-id="641cb-115">They get unboxed when cast back to the value type.</span></span> <span data-ttu-id="641cb-116">Vzhledem k tomu, že pole jsou objekty, které jsou přiděleny haldě a jsou uvolněny do paměti, příliš mnoho zabalení a rozbalení může mít negativní vliv na haldu, uvolňování paměti a nakonec výkon aplikace.</span><span class="sxs-lookup"><span data-stu-id="641cb-116">Because boxes are objects that are allocated on the heap and are garbage-collected, too much boxing and unboxing can have a negative impact on the heap, the garbage collector, and ultimately the performance of the application.</span></span>  <span data-ttu-id="641cb-117">Naopak žádné takové zabalení nevzniká jako přetypování typů odkazů.</span><span class="sxs-lookup"><span data-stu-id="641cb-117">In contrast, no such boxing occurs as reference types are cast.</span></span> <span data-ttu-id="641cb-118">(Další informace naleznete v tématu [zabalení a rozbalení](../../csharp/programming-guide/types/boxing-and-unboxing.md)).</span><span class="sxs-lookup"><span data-stu-id="641cb-118">(For more information, see [Boxing and Unboxing](../../csharp/programming-guide/types/boxing-and-unboxing.md)).</span></span>

 <span data-ttu-id="641cb-119">V dalším kroku přiřazení typu odkazu kopírují odkaz, zatímco přiřazení typu hodnoty kopírují celou hodnotu.</span><span class="sxs-lookup"><span data-stu-id="641cb-119">Next, reference type assignments copy the reference, whereas value type assignments copy the entire value.</span></span> <span data-ttu-id="641cb-120">Proto přiřazení velkých typů odkazů jsou levnější než přiřazení typů velkých hodnot.</span><span class="sxs-lookup"><span data-stu-id="641cb-120">Therefore, assignments of large reference types are cheaper than assignments of large value types.</span></span>

 <span data-ttu-id="641cb-121">Nakonec odkazové typy jsou předány odkazem, zatímco typy hodnot jsou předány hodnotou.</span><span class="sxs-lookup"><span data-stu-id="641cb-121">Finally, reference types are passed by reference, whereas value types are passed by value.</span></span> <span data-ttu-id="641cb-122">Změny instance typu odkazu ovlivňují všechny odkazy odkazující na instanci.</span><span class="sxs-lookup"><span data-stu-id="641cb-122">Changes to an instance of a reference type affect all references pointing to the instance.</span></span> <span data-ttu-id="641cb-123">Instance typu hodnoty jsou zkopírovány, když jsou předány hodnotou.</span><span class="sxs-lookup"><span data-stu-id="641cb-123">Value type instances are copied when they are passed by value.</span></span> <span data-ttu-id="641cb-124">Když dojde ke změně instance hodnotového typu, samozřejmě nemá vliv na žádnou z jeho kopií.</span><span class="sxs-lookup"><span data-stu-id="641cb-124">When an instance of a value type is changed, it of course does not affect any of its copies.</span></span> <span data-ttu-id="641cb-125">Vzhledem k tomu, že kopie nejsou vytvořeny explicitně uživatelem, ale jsou implicitně vytvořeny, když jsou předány argumenty nebo vrátí návratové hodnoty, mohou být typy hodnot, které lze změnit, matoucí pro mnoho uživatelů.</span><span class="sxs-lookup"><span data-stu-id="641cb-125">Because the copies are not created explicitly by the user but are implicitly created when arguments are passed or return values are returned, value types that can be changed can be confusing to many users.</span></span> <span data-ttu-id="641cb-126">Proto by měly být typy hodnot neměnné.</span><span class="sxs-lookup"><span data-stu-id="641cb-126">Therefore, value types should be immutable.</span></span>

 <span data-ttu-id="641cb-127">Jako pravidlo pro palec by většina typů v rozhraní měla být třídy.</span><span class="sxs-lookup"><span data-stu-id="641cb-127">As a rule of thumb, the majority of types in a framework should be classes.</span></span> <span data-ttu-id="641cb-128">Existují však některé situace, ve kterých charakteristiky typu hodnoty usnadňují používání struktur.</span><span class="sxs-lookup"><span data-stu-id="641cb-128">There are, however, some situations in which the characteristics of a value type make it more appropriate to use structs.</span></span>

 <span data-ttu-id="641cb-129">✔️ Zvažte definování struktury namísto třídy, pokud jsou instance daného typu malé a běžně krátkodobé nebo jsou běžně vloženy do jiných objektů.</span><span class="sxs-lookup"><span data-stu-id="641cb-129">✔️ CONSIDER defining a struct instead of a class if instances of the type are small and commonly short-lived or are commonly embedded in other objects.</span></span>

 <span data-ttu-id="641cb-130">❌Vyhněte se definování struktury, pokud typ neobsahuje všechny následující charakteristiky:</span><span class="sxs-lookup"><span data-stu-id="641cb-130">❌ AVOID defining a struct unless the type has all of the following characteristics:</span></span>

- <span data-ttu-id="641cb-131">Logicky představuje jedinou hodnotu, podobně jako primitivní typy ( `int` , `double` atd.).</span><span class="sxs-lookup"><span data-stu-id="641cb-131">It logically represents a single value, similar to primitive types (`int`, `double`, etc.).</span></span>

- <span data-ttu-id="641cb-132">Má velikost instance 16 bajtů.</span><span class="sxs-lookup"><span data-stu-id="641cb-132">It has an instance size under 16 bytes.</span></span>

- <span data-ttu-id="641cb-133">Je neměnný.</span><span class="sxs-lookup"><span data-stu-id="641cb-133">It is immutable.</span></span>

- <span data-ttu-id="641cb-134">Nemusí být často ohraničená.</span><span class="sxs-lookup"><span data-stu-id="641cb-134">It will not have to be boxed frequently.</span></span>

 <span data-ttu-id="641cb-135">Ve všech ostatních případech byste měli definovat typy jako třídy.</span><span class="sxs-lookup"><span data-stu-id="641cb-135">In all other cases, you should define your types as classes.</span></span>

 <span data-ttu-id="641cb-136">*Části © 2005, 2009 Microsoft Corporation. Všechna práva vyhrazena.*</span><span class="sxs-lookup"><span data-stu-id="641cb-136">*Portions © 2005, 2009 Microsoft Corporation. All rights reserved.*</span></span>

 <span data-ttu-id="641cb-137">*Přetištěno oprávněním Pearsonova vzdělávání, Inc. z [pokynů pro návrh rozhraní: konvence, idiomy a vzory pro opakovaně použitelné knihovny .NET, druhá edice](https://www.informit.com/store/framework-design-guidelines-conventions-idioms-and-9780321545619) od Krzysztof Cwalina a Brad Abrams, publikovaly 22. října 2008 Addison-Wesley Professional jako součást sady Microsoft Windows Development Series.*</span><span class="sxs-lookup"><span data-stu-id="641cb-137">*Reprinted by permission of Pearson Education, Inc. from [Framework Design Guidelines: Conventions, Idioms, and Patterns for Reusable .NET Libraries, 2nd Edition](https://www.informit.com/store/framework-design-guidelines-conventions-idioms-and-9780321545619) by Krzysztof Cwalina and Brad Abrams, published Oct 22, 2008 by Addison-Wesley Professional as part of the Microsoft Windows Development Series.*</span></span>

## <a name="see-also"></a><span data-ttu-id="641cb-138">Viz také</span><span class="sxs-lookup"><span data-stu-id="641cb-138">See also</span></span>

- [<span data-ttu-id="641cb-139">Pokyny pro návrh typů</span><span class="sxs-lookup"><span data-stu-id="641cb-139">Type Design Guidelines</span></span>](type.md)
- [<span data-ttu-id="641cb-140">Pokyny k návrhu architektury</span><span class="sxs-lookup"><span data-stu-id="641cb-140">Framework Design Guidelines</span></span>](index.md)
