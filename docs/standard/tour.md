---
title: Prohlídka technologie .NET
description: Prohlídka s průvodcem některými z prominentních rysů rozhraní .NET.
author: cartermp
ms.author: wiwagn
ms.date: 05/22/2017
ms.technology: dotnet-standard
ms.assetid: bbfe6465-329d-4982-869d-472e7ef85d93
ms.openlocfilehash: 61d4792b1f1b92dd59442ee38810da96c6cf63bd
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 03/15/2020
ms.locfileid: "78241140"
---
# <a name="tour-of-net"></a><span data-ttu-id="51f1d-103">Prohlídka technologie .NET</span><span class="sxs-lookup"><span data-stu-id="51f1d-103">Tour of .NET</span></span>

<span data-ttu-id="51f1d-104">.NET je univerzální vývojová platforma.</span><span class="sxs-lookup"><span data-stu-id="51f1d-104">.NET is a general purpose development platform.</span></span> <span data-ttu-id="51f1d-105">Má několik klíčových funkcí, jako je například podpora pro více programovacích jazyků, asynchronní a souběžné programovací modely a nativní interoperabilita, které umožňují širokou škálu scénářů na různých platformách.</span><span class="sxs-lookup"><span data-stu-id="51f1d-105">It has several key features, such as support for multiple programming languages, asynchronous and concurrent programming models, and native interoperability, which enable a wide range of scenarios across multiple platforms.</span></span>

<span data-ttu-id="51f1d-106">Tento článek nabízí prohlídku s průvodcem některé klíčové funkce rozhraní .NET.</span><span class="sxs-lookup"><span data-stu-id="51f1d-106">This article offers a guided tour through some of the key features of the .NET.</span></span> <span data-ttu-id="51f1d-107">Informace o architektonických dílech rozhraní .NET a o tom, k čemu se používají, najdete v tématu [.NET Architectural Components.](components.md)</span><span class="sxs-lookup"><span data-stu-id="51f1d-107">See the [.NET Architectural Components](components.md) topic to learn about the architectural pieces of .NET and what they're used for.</span></span>

## <a name="how-to-run-the-code-samples"></a><span data-ttu-id="51f1d-108">Jak spustit ukázky kódu</span><span class="sxs-lookup"><span data-stu-id="51f1d-108">How to run the code samples</span></span>

<span data-ttu-id="51f1d-109">Informace o tom, jak nastavit vývojové prostředí pro spuštění ukázek kódu, najdete v tématu [Začínáme.](get-started.md)</span><span class="sxs-lookup"><span data-stu-id="51f1d-109">To learn how to set up a development environment to run the code samples, see the [Getting Started](get-started.md) topic.</span></span> <span data-ttu-id="51f1d-110">Zkopírujte a vložte ukázky kódu z této stránky do vašeho prostředí, abyste je provedli.</span><span class="sxs-lookup"><span data-stu-id="51f1d-110">Copy and paste code samples from this page into your environment to execute them.</span></span>

## <a name="programming-languages"></a><span data-ttu-id="51f1d-111">Programovací jazyky</span><span class="sxs-lookup"><span data-stu-id="51f1d-111">Programming languages</span></span>

<span data-ttu-id="51f1d-112">Rozhraní .NET podporuje více programovacích jazyků.</span><span class="sxs-lookup"><span data-stu-id="51f1d-112">.NET supports multiple programming languages.</span></span> <span data-ttu-id="51f1d-113">Implementace .NET [implementují common language infrastructure (CLI),](https://visualstudio.microsoft.com/license-terms/ecma-c-common-language-infrastructure-standards/)která mimo jiné určuje jazykově nezávislou dobu runtime a jazykovou interoperabilitu.</span><span class="sxs-lookup"><span data-stu-id="51f1d-113">The .NET implementations implement the [Common Language Infrastructure (CLI)](https://visualstudio.microsoft.com/license-terms/ecma-c-common-language-infrastructure-standards/), which among other things specifies a language-independent runtime and language interoperability.</span></span> <span data-ttu-id="51f1d-114">To znamená, že můžete zvolit libovolný jazyk .NET pro vytváření aplikací a služeb v rozhraní .NET.</span><span class="sxs-lookup"><span data-stu-id="51f1d-114">This means that you choose any .NET language to build apps and services on .NET.</span></span>

<span data-ttu-id="51f1d-115">Společnost Microsoft aktivně vyvíjí a podporuje tři jazyky .NET: C#, F# a Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="51f1d-115">Microsoft actively develops and supports three .NET languages: C#, F#, and Visual Basic.</span></span>

* <span data-ttu-id="51f1d-116">C# je jednoduchý, výkonný, typově bezpečný a objektově orientovaný, při zachování expresivity a elegance jazyků ve stylu C.</span><span class="sxs-lookup"><span data-stu-id="51f1d-116">C# is simple, powerful, type-safe, and object-oriented, while retaining the expressiveness and elegance of C-style languages.</span></span> <span data-ttu-id="51f1d-117">Každý, kdo zná Jazyk C a podobné jazyky najde několik problémů při přizpůsobování c#.</span><span class="sxs-lookup"><span data-stu-id="51f1d-117">Anyone familiar with C and similar languages finds few problems in adapting to C#.</span></span> <span data-ttu-id="51f1d-118">Další informace o c# najdete v [příručce C#.](../csharp/index.yml)</span><span class="sxs-lookup"><span data-stu-id="51f1d-118">Check out the [C# Guide](../csharp/index.yml) to learn more about C#.</span></span>

* <span data-ttu-id="51f1d-119">F# je multiplatformní, funkční první programovací jazyk, který také podporuje tradiční objektově orientované a imperativní programování.</span><span class="sxs-lookup"><span data-stu-id="51f1d-119">F# is a cross-platform, functional-first programming language that also supports traditional object-oriented and imperative programming.</span></span> <span data-ttu-id="51f1d-120">Další informace o [f#.](../fsharp/index.yml)</span><span class="sxs-lookup"><span data-stu-id="51f1d-120">Check out the [F# Guide](../fsharp/index.yml) to learn more about F#.</span></span>

* <span data-ttu-id="51f1d-121">Visual Basic je snadný jazyk se dozvíte, že používáte k vytvoření různých aplikací, které běží na rozhraní .NET.</span><span class="sxs-lookup"><span data-stu-id="51f1d-121">Visual Basic is an easy language to learn that you use to build a variety of apps that run on .NET.</span></span> <span data-ttu-id="51f1d-122">Mezi jazyky .NET je syntaxe jazyka Visual Basic nejblíže běžnému lidskému jazyku, což často usnadňuje lidem, kteří jsou pro vývoj softwaru noví.</span><span class="sxs-lookup"><span data-stu-id="51f1d-122">Among the .NET languages, the syntax of Visual Basic is the closest to ordinary human language, often making it easier for people new to software development.</span></span>

## <a name="automatic-memory-management"></a><span data-ttu-id="51f1d-123">Automatická správa paměti</span><span class="sxs-lookup"><span data-stu-id="51f1d-123">Automatic memory management</span></span>

<span data-ttu-id="51f1d-124">Rozhraní .NET používá [uvolňování paměti (GC)](garbage-collection/index.md) k zajištění automatické správy paměti pro programy.</span><span class="sxs-lookup"><span data-stu-id="51f1d-124">.NET uses [garbage collection (GC)](garbage-collection/index.md) to provide automatic memory management for programs.</span></span> <span data-ttu-id="51f1d-125">Gc pracuje na opožděný přístup ke správě paměti, upřednostňuje propustnost aplikace na okamžité shromažďování paměti.</span><span class="sxs-lookup"><span data-stu-id="51f1d-125">The GC operates on a lazy approach to memory management, preferring app throughput to the immediate collection of memory.</span></span> <span data-ttu-id="51f1d-126">Další informace o .NET GC, podívejte se na [základy uvolňování paměti (GC)](garbage-collection/fundamentals.md).</span><span class="sxs-lookup"><span data-stu-id="51f1d-126">To learn more about the .NET GC, check out [Fundamentals of garbage collection (GC)](garbage-collection/fundamentals.md).</span></span>

<span data-ttu-id="51f1d-127">Následující dva řádky přidělují paměť:</span><span class="sxs-lookup"><span data-stu-id="51f1d-127">The following two lines both allocate memory:</span></span>

[!code-csharp[MemoryManagement](../../samples/snippets/csharp/snippets/tour/MemoryManagement.csx#L1-L2)]

<span data-ttu-id="51f1d-128">Neexistuje žádné analogové klíčové slovo pro de-allocate paměti, jako de-allocation se stane automaticky, když systém uvolňování paměti uvolní paměti prostřednictvím jeho naplánované spuštění.</span><span class="sxs-lookup"><span data-stu-id="51f1d-128">There's no analogous keyword to de-allocate memory, as de-allocation happens automatically when the garbage collector reclaims the memory through its scheduled run.</span></span>

<span data-ttu-id="51f1d-129">Systém uvolňování paměti je jednou ze služeb, které pomáhají zajistit *bezpečnost paměti*.</span><span class="sxs-lookup"><span data-stu-id="51f1d-129">The garbage collector is one of the services that help ensure *memory safety*.</span></span> <span data-ttu-id="51f1d-130">Program je bezpečný v paměti, pokud přistupuje pouze k přidělené paměti.</span><span class="sxs-lookup"><span data-stu-id="51f1d-130">A program is memory safe if it accesses only allocated memory.</span></span> <span data-ttu-id="51f1d-131">Například za běhu zajišťuje, že aplikace nemá přístup k nepřidělené paměti mimo hranice pole.</span><span class="sxs-lookup"><span data-stu-id="51f1d-131">For instance, the runtime ensures that an app doesn't access unallocated memory beyond the bounds of an array.</span></span>

<span data-ttu-id="51f1d-132">V následujícím příkladu runtime vyvolá <xref:System.IndexOutOfRangeException> výjimku k vynucení bezpečnosti paměti:</span><span class="sxs-lookup"><span data-stu-id="51f1d-132">In the following example, the runtime throws an <xref:System.IndexOutOfRangeException> exception to enforce memory safety:</span></span>

[!code-csharp[MemoryManagement](../../samples/snippets/csharp/snippets/tour/MemoryManagement.csx#L4-L5)]

## <a name="working-with-unmanaged-resources"></a><span data-ttu-id="51f1d-133">Práce s nespravovanými zdroji</span><span class="sxs-lookup"><span data-stu-id="51f1d-133">Working with unmanaged resources</span></span>

<span data-ttu-id="51f1d-134">Některé objekty odkazují na *nespravované prostředky*.</span><span class="sxs-lookup"><span data-stu-id="51f1d-134">Some objects reference *unmanaged resources*.</span></span> <span data-ttu-id="51f1d-135">Nespravované prostředky jsou prostředky, které nejsou automaticky udržovány za běhu .NET.</span><span class="sxs-lookup"><span data-stu-id="51f1d-135">Unmanaged resources are resources that aren't automatically maintained by the .NET runtime.</span></span> <span data-ttu-id="51f1d-136">Popisovač souboru je například nespravovaný prostředek.</span><span class="sxs-lookup"><span data-stu-id="51f1d-136">For example, a file handle is an unmanaged resource.</span></span> <span data-ttu-id="51f1d-137">Objekt <xref:System.IO.FileStream> je spravovaný objekt, ale odkazuje na popisovač souboru, který není spravován.</span><span class="sxs-lookup"><span data-stu-id="51f1d-137">A <xref:System.IO.FileStream> object is a managed object, but it references a file handle, which is unmanaged.</span></span> <span data-ttu-id="51f1d-138">Po dokončení používání aplikace <xref:System.IO.FileStream>je třeba uvolnit popisovač souboru.</span><span class="sxs-lookup"><span data-stu-id="51f1d-138">When you're done using the <xref:System.IO.FileStream>, you need to release the file handle.</span></span>

<span data-ttu-id="51f1d-139">V rozhraní .NET implementují rozhraní <xref:System.IDisposable> objekty, které odkazují na nespravované prostředky.</span><span class="sxs-lookup"><span data-stu-id="51f1d-139">In .NET, objects that reference unmanaged resources implement the <xref:System.IDisposable> interface.</span></span> <span data-ttu-id="51f1d-140">Po dokončení používání objektu zavoláte <xref:System.IDisposable.Dispose> metodu objektu, která je zodpovědná za uvolnění všech nespravovaných prostředků.</span><span class="sxs-lookup"><span data-stu-id="51f1d-140">When you're done using the object, you call the object's <xref:System.IDisposable.Dispose> method, which is responsible for releasing any unmanaged resources.</span></span> <span data-ttu-id="51f1d-141">Jazyky .NET poskytují pro tyto objekty vhodný [ `using` příkaz,](../csharp/language-reference/keywords/using.md) jak je znázorněno v následujícím příkladu:</span><span class="sxs-lookup"><span data-stu-id="51f1d-141">.NET languages provide a convenient [`using` statement](../csharp/language-reference/keywords/using.md) for such objects, as shown in the following example:</span></span>

[!code-csharp[UnmanagedResources](../../samples/snippets/csharp/snippets/tour/UnmanagedResources.csx#L1-L6)]

<span data-ttu-id="51f1d-142">Po `using` dokončení bloku, .NET runtime automaticky `stream` volá <xref:System.IDisposable.Dispose> metodu objektu, který uvolní popisovač souboru.</span><span class="sxs-lookup"><span data-stu-id="51f1d-142">Once the `using` block completes, the .NET runtime automatically calls the `stream` object's <xref:System.IDisposable.Dispose> method, which releases the file handle.</span></span> <span data-ttu-id="51f1d-143">Runtime také to, pokud výjimka způsobí, že ovládací prvek opustit blok.</span><span class="sxs-lookup"><span data-stu-id="51f1d-143">The runtime also does this if an exception causes control to leave the block.</span></span>

<span data-ttu-id="51f1d-144">Další podrobnosti naleznete v následujících tématech:</span><span class="sxs-lookup"><span data-stu-id="51f1d-144">For more details, see the following topics:</span></span>

* <span data-ttu-id="51f1d-145">Pro C# naleznete [pomocí prohlášení (C# Reference)](../csharp/language-reference/keywords/using-statement.md) téma.</span><span class="sxs-lookup"><span data-stu-id="51f1d-145">For C#, see the [using Statement (C# Reference)](../csharp/language-reference/keywords/using-statement.md) topic.</span></span>
* <span data-ttu-id="51f1d-146">Informace o použití jazyka F# naleznete v tématu [Správa zdrojů: Klíčové slovo použití](../fsharp/language-reference/resource-management-the-use-keyword.md).</span><span class="sxs-lookup"><span data-stu-id="51f1d-146">For F#, see [Resource Management: The use Keyword](../fsharp/language-reference/resource-management-the-use-keyword.md).</span></span>
* <span data-ttu-id="51f1d-147">V jazyce Visual Basic najdete [téma Using Statement (Visual Basic).](../visual-basic/language-reference/statements/using-statement.md)</span><span class="sxs-lookup"><span data-stu-id="51f1d-147">For Visual Basic, see the [Using Statement (Visual Basic)](../visual-basic/language-reference/statements/using-statement.md) topic.</span></span>

## <a name="type-safety"></a><span data-ttu-id="51f1d-148">Bezpečnost typů</span><span class="sxs-lookup"><span data-stu-id="51f1d-148">Type safety</span></span>

<span data-ttu-id="51f1d-149">Objekt je instance určitého typu.</span><span class="sxs-lookup"><span data-stu-id="51f1d-149">An object is an instance of a specific type.</span></span> <span data-ttu-id="51f1d-150">Pouze operace povolené pro daný objekt jsou operace jeho typu.</span><span class="sxs-lookup"><span data-stu-id="51f1d-150">The only operations allowed for a given object are those of its type.</span></span> <span data-ttu-id="51f1d-151">Typ `Dog` může `Jump` mít `WagTail` a metody, ale ne metodu. `SumTotal`</span><span class="sxs-lookup"><span data-stu-id="51f1d-151">A `Dog` type may have `Jump` and `WagTail` methods but not a `SumTotal` method.</span></span> <span data-ttu-id="51f1d-152">Program volá pouze metody, které patří k danému typu.</span><span class="sxs-lookup"><span data-stu-id="51f1d-152">A program only calls the methods belonging to a given type.</span></span> <span data-ttu-id="51f1d-153">Všechna ostatní volání mají za následek chybu v době kompilace nebo výjimku `object`za běhu (v případě použití dynamických funkcí nebo ).</span><span class="sxs-lookup"><span data-stu-id="51f1d-153">All other calls result in either a compile-time error or a run-time exception (in case of using dynamic features or `object`).</span></span>

<span data-ttu-id="51f1d-154">Jazyky .NET jsou objektově orientované s hierarchiemi základních a odvozených tříd.</span><span class="sxs-lookup"><span data-stu-id="51f1d-154">.NET languages are object-oriented with hierarchies of base and derived classes.</span></span> <span data-ttu-id="51f1d-155">Runtime .NET umožňuje pouze přetypování objektů a volání, které jsou zarovnány s hierarchií objektů.</span><span class="sxs-lookup"><span data-stu-id="51f1d-155">The .NET runtime only allows object casts and calls that align with the object hierarchy.</span></span> <span data-ttu-id="51f1d-156">Nezapomeňte, že každý typ definovaný v libovolném <xref:System.Object> jazyce .NET je odvozen od základního typu.</span><span class="sxs-lookup"><span data-stu-id="51f1d-156">Remember that every type defined in any .NET language derives from the base <xref:System.Object> type.</span></span>

[!code-csharp[TypeSafety](../../samples/snippets/csharp/snippets/tour/TypeSafety.csx#L19-L23)]

<span data-ttu-id="51f1d-157">Bezpečnost typů se také používá k vynucení zapouzdření tím, že zaručuje věrnost klíčových slov přistupujícího pole.</span><span class="sxs-lookup"><span data-stu-id="51f1d-157">Type safety is also used to help enforce encapsulation by guaranteeing the fidelity of the accessor keywords.</span></span> <span data-ttu-id="51f1d-158">Přistupující klíčová slova jsou artefakty, které řídí přístup k členům daného typu jiným kódem.</span><span class="sxs-lookup"><span data-stu-id="51f1d-158">Accessor keywords are artifacts which control access to members of a given type by other code.</span></span> <span data-ttu-id="51f1d-159">Ty se obvykle používají pro různé druhy dat v rámci typu, které se používají ke správě jeho chování.</span><span class="sxs-lookup"><span data-stu-id="51f1d-159">These are usually used for various kinds of data within a type that are used to manage its behavior.</span></span>

[!code-csharp[TypeSafety](../../samples/snippets/csharp/snippets/tour/TypeSafety.csx#L3-L3)]

<span data-ttu-id="51f1d-160">C#, Visual Basic a F# podporují *odvození místního typu*.</span><span class="sxs-lookup"><span data-stu-id="51f1d-160">C#, Visual Basic, and F# support local *type inference*.</span></span> <span data-ttu-id="51f1d-161">Odvození typu znamená, že kompilátor odvodí typ výrazu na levé straně z výrazu na pravé straně.</span><span class="sxs-lookup"><span data-stu-id="51f1d-161">Type inference means that the compiler deduces the type of the expression on the left-hand side from the expression on the right-hand side.</span></span> <span data-ttu-id="51f1d-162">To neznamená, že bezpečnost typů je přerušena nebo se mu vyhnout.</span><span class="sxs-lookup"><span data-stu-id="51f1d-162">This doesn't mean that the type safety is broken or avoided.</span></span> <span data-ttu-id="51f1d-163">Výsledný typ má silný typ se vším, co znamená.</span><span class="sxs-lookup"><span data-stu-id="51f1d-163">The resulting type does have a strong type with everything that implies.</span></span> <span data-ttu-id="51f1d-164">Z předchozího `dog` příkladu je přepsána zavést odvození typu a zbytek příkladu je beze změny:</span><span class="sxs-lookup"><span data-stu-id="51f1d-164">From the previous example, `dog` is rewritten to introduce type inference, and the remainder of the example is unchanged:</span></span>

[!code-csharp[TypeSafety](../../samples/snippets/csharp/snippets/tour/TypeSafety.csx#L28-L34)]

<span data-ttu-id="51f1d-165">F# má ještě další možnosti odvození typu než odvození typu metody místní nalezené v jazyce C# a Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="51f1d-165">F# has even further type inference capabilities than the method-local type inference found in C# and Visual Basic.</span></span> <span data-ttu-id="51f1d-166">Další informace najdete [v tématu Typ odvození](../fsharp/language-reference/type-inference.md).</span><span class="sxs-lookup"><span data-stu-id="51f1d-166">To learn more, see [Type Inference](../fsharp/language-reference/type-inference.md).</span></span>

## <a name="delegates-and-lambdas"></a><span data-ttu-id="51f1d-167">Delegáty a výrazy lambda</span><span class="sxs-lookup"><span data-stu-id="51f1d-167">Delegates and lambdas</span></span>

<span data-ttu-id="51f1d-168">Delegát je reprezentován podpisem metody.</span><span class="sxs-lookup"><span data-stu-id="51f1d-168">A delegate is represented by a method signature.</span></span> <span data-ttu-id="51f1d-169">Všechny metody s tímto podpisem lze přiřadit delegáta a je proveden při vyvolání delegáta.</span><span class="sxs-lookup"><span data-stu-id="51f1d-169">Any method with that signature can be assigned to the delegate and is executed when the delegate is invoked.</span></span>

<span data-ttu-id="51f1d-170">Delegáti jsou jako ukazatele funkce Jazyka C++ s tím rozdílem, že jsou bezpečné pro daný typ.</span><span class="sxs-lookup"><span data-stu-id="51f1d-170">Delegates are like C++ function pointers except that they're type safe.</span></span> <span data-ttu-id="51f1d-171">Jsou to druh odpojené metody v rámci clr typ systému.</span><span class="sxs-lookup"><span data-stu-id="51f1d-171">They're a kind of disconnected method within the CLR type system.</span></span> <span data-ttu-id="51f1d-172">Pravidelné metody jsou připojeny ke třídě a jsou přímo volatelné pouze prostřednictvím statické nebo instance volání konvence.</span><span class="sxs-lookup"><span data-stu-id="51f1d-172">Regular methods are attached to a class and are only directly callable through static or instance calling conventions.</span></span>

<span data-ttu-id="51f1d-173">V rozhraní .NET se delegáti běžně používají v obslužných rutinách událostí, při definování asynchronních operací a ve výrazech lambda, které jsou základním kamenem LINQ.</span><span class="sxs-lookup"><span data-stu-id="51f1d-173">In .NET, delegates are commonly used in event handlers, in defining asynchronous operations, and in lambda expressions, which are a cornerstone of LINQ.</span></span> <span data-ttu-id="51f1d-174">Další informace najdete v tématu [Delegáti a lambdas.](delegates-lambdas.md)</span><span class="sxs-lookup"><span data-stu-id="51f1d-174">Learn more in the [Delegates and lambdas](delegates-lambdas.md) topic.</span></span>

## <a name="generics"></a><span data-ttu-id="51f1d-175">Obecné typy</span><span class="sxs-lookup"><span data-stu-id="51f1d-175">Generics</span></span>

<span data-ttu-id="51f1d-176">Obecné typy umožňují programátorovi zavést *parametr typu* při navrhování jejich tříd, které umožňují kódu klienta (uživatelům typu) určit přesný typ, který má být používán místo parametru typu.</span><span class="sxs-lookup"><span data-stu-id="51f1d-176">Generics allow the programmer to introduce a *type parameter* when designing their classes that allows the client code (the users of the type) to specify the exact type to use in place of the type parameter.</span></span>

<span data-ttu-id="51f1d-177">Generika byla přidána, aby programátorům pomohla implementovat obecné datové struktury.</span><span class="sxs-lookup"><span data-stu-id="51f1d-177">Generics were added to help programmers implement generic data structures.</span></span> <span data-ttu-id="51f1d-178">Před jejich příchodem, aby typ, `List` jako je typ, který má být obecný, `object`by musel pracovat s prvky, které byly typu .</span><span class="sxs-lookup"><span data-stu-id="51f1d-178">Before their arrival, in order for a type such as the `List` type to be generic, it would have to work with elements that were of type `object`.</span></span> <span data-ttu-id="51f1d-179">To mělo různé problémy s výkonem a sémantickým i s možnými jemnými chybami za běhu.</span><span class="sxs-lookup"><span data-stu-id="51f1d-179">This had various performance and semantic problems, along with possible subtle run-time errors.</span></span> <span data-ttu-id="51f1d-180">Běžná chyba za běhu je, když datová struktura obsahuje například celá čísla <xref:System.InvalidCastException> a řetězce a je vyvolána při zpracování členů seznamu.</span><span class="sxs-lookup"><span data-stu-id="51f1d-180">A common run-time error is when a data structure contains, for example, both integers and strings, and an <xref:System.InvalidCastException> is thrown while processing the list's members.</span></span>

<span data-ttu-id="51f1d-181">Následující ukázka ukazuje základní program spuštěný pomocí instance <xref:System.Collections.Generic.List%601> typů:</span><span class="sxs-lookup"><span data-stu-id="51f1d-181">The following sample shows a basic program running using an instance of <xref:System.Collections.Generic.List%601> types:</span></span>

[!code-csharp[GenericsShort](../../samples/snippets/csharp/snippets/tour/GenericsShort.csx)]

<span data-ttu-id="51f1d-182">Další informace naleznete v tématu [přehledu obecných typů (Generics).](generics.md)</span><span class="sxs-lookup"><span data-stu-id="51f1d-182">For more information, see the [Generic types (Generics) overview](generics.md) topic.</span></span>

## <a name="async-programming"></a><span data-ttu-id="51f1d-183">Asynchronní programování</span><span class="sxs-lookup"><span data-stu-id="51f1d-183">Async programming</span></span>

<span data-ttu-id="51f1d-184">Asynchronní programování je koncept první třídy v rámci rozhraní .NET s asynchronní podporou v modulu runtime, knihovnách architektury a konstrukcích jazyků .NET.</span><span class="sxs-lookup"><span data-stu-id="51f1d-184">Async programming is a first-class concept within .NET with async support in the runtime, framework libraries, and .NET language constructs.</span></span> <span data-ttu-id="51f1d-185">Interně jsou založeny na objektech `Task`(například), které využívají výhod operačního systému k co nejefektivnějšímu provádění úloh vázaných na vstupně-výstupní služby.</span><span class="sxs-lookup"><span data-stu-id="51f1d-185">Internally, they're based on objects (such as `Task`), which take advantage of the operating system to perform I/O-bound jobs as efficiently as possible.</span></span>

<span data-ttu-id="51f1d-186">Další informace o asynchronním programování v rozhraní .NET, začněte s tématem [Přehled asynchronní.](async.md)</span><span class="sxs-lookup"><span data-stu-id="51f1d-186">To learn more about async programming in .NET, start with the [Async overview](async.md) topic.</span></span>

## <a name="language-integrated-query-linq"></a><span data-ttu-id="51f1d-187">LINQ (Language Integrated Query)</span><span class="sxs-lookup"><span data-stu-id="51f1d-187">Language Integrated Query (LINQ)</span></span>

<span data-ttu-id="51f1d-188">LINQ je výkonná sada funkcí pro C# a Visual Basic, které umožňují psát jednoduchý, deklarativní kód pro práci s daty.</span><span class="sxs-lookup"><span data-stu-id="51f1d-188">LINQ is a powerful set of features for C# and Visual Basic that allow you to write simple, declarative code for operating on data.</span></span> <span data-ttu-id="51f1d-189">Data mohou být v mnoha formách (například objekty v paměti, databáze SQL nebo dokument XML), ale kód LINQ, který píšete, se obvykle neliší podle zdroje dat.</span><span class="sxs-lookup"><span data-stu-id="51f1d-189">The data can be in many forms (such as in-memory objects, a SQL database, or an XML document), but the LINQ code you write typically doesn't differ by data source.</span></span>

<span data-ttu-id="51f1d-190">Další informace a některé ukázky najdete v tématu [LINQ (Language Integrated Query).](using-linq.md)</span><span class="sxs-lookup"><span data-stu-id="51f1d-190">To learn more and see some samples, see the [LINQ (Language Integrated Query)](using-linq.md) topic.</span></span>

## <a name="native-interoperability"></a><span data-ttu-id="51f1d-191">Nativní interoperabilita</span><span class="sxs-lookup"><span data-stu-id="51f1d-191">Native interoperability</span></span>

<span data-ttu-id="51f1d-192">Každý operační systém obsahuje rozhraní API (Application Programming Interface), které poskytuje systémové služby.</span><span class="sxs-lookup"><span data-stu-id="51f1d-192">Every operating system includes an application programming interface (API) that provides system services.</span></span> <span data-ttu-id="51f1d-193">Rozhraní .NET poskytuje několik způsobů volání těchto rozhraní API.</span><span class="sxs-lookup"><span data-stu-id="51f1d-193">.NET provides several ways to call those APIs.</span></span>

<span data-ttu-id="51f1d-194">Hlavní způsob, jak udělat nativní interoperabilitu, je prostřednictvím "platforminvoke" nebo P / Invoke pro short, který je podporován na platformách Linux a Windows.</span><span class="sxs-lookup"><span data-stu-id="51f1d-194">The main way to do native interoperability is via "platform invoke" or P/Invoke for short, which is supported across Linux and Windows platforms.</span></span> <span data-ttu-id="51f1d-195">Způsob nativní interoperability pouze pro systém Windows se označuje jako "interop modelu COM", který se používá pro práci s [komponentami modelu COM](/cpp/atl/introduction-to-com) ve spravovaném kódu.</span><span class="sxs-lookup"><span data-stu-id="51f1d-195">A Windows-only way of doing native interoperability is known as "COM interop," which is used to work with [COM components](/cpp/atl/introduction-to-com) in managed code.</span></span> <span data-ttu-id="51f1d-196">Je postaven na infrastruktuře P/Invoke, ale funguje nenápadně různými způsoby.</span><span class="sxs-lookup"><span data-stu-id="51f1d-196">It's built on top of the P/Invoke infrastructure, but it works in subtly different ways.</span></span>

<span data-ttu-id="51f1d-197">Většina mono (a tedy Xamarin) podpora interoperability pro Java a Objective-C jsou postaveny podobně, to znamená, že používají stejné principy.</span><span class="sxs-lookup"><span data-stu-id="51f1d-197">Most of Mono's (and thus Xamarin's) interoperability support for Java and Objective-C are built similarly, that is, they use the same principles.</span></span>

<span data-ttu-id="51f1d-198">Další informace o nativní interoperabilitě naleznete v článku [Nativní interoperabilita.](native-interop/index.md)</span><span class="sxs-lookup"><span data-stu-id="51f1d-198">For more information about native interoperability, see the [Native interoperability](native-interop/index.md) article.</span></span>

## <a name="unsafe-code"></a><span data-ttu-id="51f1d-199">Nebezpečný kód</span><span class="sxs-lookup"><span data-stu-id="51f1d-199">Unsafe code</span></span>

<span data-ttu-id="51f1d-200">V závislosti na jazykové podpoře umožňuje CLR přístup k nativní `unsafe` paměti a aritmetické ukazatele prostřednictvím kódu.</span><span class="sxs-lookup"><span data-stu-id="51f1d-200">Depending on language support, the CLR lets you access native memory and do pointer arithmetic via `unsafe` code.</span></span> <span data-ttu-id="51f1d-201">Tyto operace jsou potřebné pro určité algoritmy a interoperabilitu systému.</span><span class="sxs-lookup"><span data-stu-id="51f1d-201">These operations are needed for certain algorithms and system interoperability.</span></span> <span data-ttu-id="51f1d-202">Přestože je použití nebezpečného kódu výkonné, nedoporučuje se, pokud není nutné interop s systémovými api nebo implementovat nejúčinnější algoritmus.</span><span class="sxs-lookup"><span data-stu-id="51f1d-202">Although powerful, use of unsafe code is discouraged unless it's necessary to interop with system APIs or implement the most efficient algorithm.</span></span> <span data-ttu-id="51f1d-203">Nebezpečný kód nemusí spustit stejným způsobem v různých prostředích a také ztrácí výhody systému uvolňování paměti a bezpečnost typů.</span><span class="sxs-lookup"><span data-stu-id="51f1d-203">Unsafe code may not execute the same way in different environments and also loses the benefits of a garbage collector and type safety.</span></span> <span data-ttu-id="51f1d-204">Doporučujeme omezit a centralizovat nebezpečný kód co nejvíce a důkladně otestovat tento kód.</span><span class="sxs-lookup"><span data-stu-id="51f1d-204">It's recommended to confine and centralize unsafe code as much as possible and test that code thoroughly.</span></span>

<span data-ttu-id="51f1d-205">Následující příklad je upravená `ToString()` verze metody `StringBuilder` z třídy.</span><span class="sxs-lookup"><span data-stu-id="51f1d-205">The following example is a modified version of the `ToString()` method from the `StringBuilder` class.</span></span> <span data-ttu-id="51f1d-206">Ukazuje, jak `unsafe` pomocí kódu můžete efektivně implementovat algoritmus přesunutím bloky paměti přímo:</span><span class="sxs-lookup"><span data-stu-id="51f1d-206">It illustrates how using `unsafe` code can efficiently implement an algorithm by moving around chunks of memory directly:</span></span>

[!code-csharp[Unsafe](../../samples/snippets/csharp/snippets/tour/Unsafe.csx)]

## <a name="next-steps"></a><span data-ttu-id="51f1d-207">Další kroky</span><span class="sxs-lookup"><span data-stu-id="51f1d-207">Next steps</span></span>

<span data-ttu-id="51f1d-208">Máte-li zájem o prohlídku funkcí jazyka C#, podívejte se na [prohlídku jazyka C#](../csharp/tour-of-csharp/index.md).</span><span class="sxs-lookup"><span data-stu-id="51f1d-208">If you're interested in a tour of C# features, check out [Tour of C#](../csharp/tour-of-csharp/index.md).</span></span>

<span data-ttu-id="51f1d-209">Pokud máte zájem o prohlídku funkcí F#, podívejte se [na prohlídku F#](../fsharp/tour.md).</span><span class="sxs-lookup"><span data-stu-id="51f1d-209">If you're interested in a tour of F# features, see [Tour of F#](../fsharp/tour.md).</span></span>

<span data-ttu-id="51f1d-210">Pokud chcete začít psát vlastní kód, navštivte [stránku Začínáme](get-started.md).</span><span class="sxs-lookup"><span data-stu-id="51f1d-210">If you want to get started with writing code of your own, visit [Getting Started](get-started.md).</span></span>

<span data-ttu-id="51f1d-211">Další informace o důležitých součástech rozhraní .NET naleznete v části [.NET Architectural Components](components.md).</span><span class="sxs-lookup"><span data-stu-id="51f1d-211">To learn about important components of .NET, check out [.NET Architectural Components](components.md).</span></span>
