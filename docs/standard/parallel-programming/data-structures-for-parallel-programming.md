---
title: Datové struktury pro paralelní programování
ms.date: 03/30/2017
ms.technology: dotnet-standard
helpviewer_keywords:
- data structures, multi-threading
ms.assetid: bdc82f2f-4754-45a1-a81e-fe2e9c30cef9
ms.openlocfilehash: f9c130b73044440f24b7b8bbebe9527490a165c1
ms.sourcegitcommit: 33deec3e814238fb18a49b2a7e89278e27888291
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 06/02/2020
ms.locfileid: "84288521"
---
# <a name="data-structures-for-parallel-programming"></a><span data-ttu-id="4098b-102">Datové struktury pro paralelní programování</span><span class="sxs-lookup"><span data-stu-id="4098b-102">Data Structures for Parallel Programming</span></span>
<span data-ttu-id="4098b-103">.NET Framework verze 4 zavádí několik nových typů, které jsou užitečné v paralelním programování, včetně sady souběžných tříd kolekcí, zjednodušené synchronizace primitiv a typů pro opožděnou inicializaci.</span><span class="sxs-lookup"><span data-stu-id="4098b-103">The .NET Framework version 4 introduces several new types that are useful in parallel programming, including a set of concurrent collection classes, lightweight synchronization primitives, and types for lazy initialization.</span></span> <span data-ttu-id="4098b-104">Tyto typy můžete použít s libovolným kódem aplikace s více vlákny, včetně Task Parallel Library a PLINQ.</span><span class="sxs-lookup"><span data-stu-id="4098b-104">You can use these types with any multithreaded application code, including the Task Parallel Library and PLINQ.</span></span>  
  
## <a name="concurrent-collection-classes"></a><span data-ttu-id="4098b-105">Třídy souběžných kolekcí</span><span class="sxs-lookup"><span data-stu-id="4098b-105">Concurrent Collection Classes</span></span>  
 <span data-ttu-id="4098b-106">Třídy kolekce v <xref:System.Collections.Concurrent?displayProperty=nameWithType> oboru názvů poskytují operace přidání a odebrání bezpečné pro přístup z více vláken, které zabraňují uzamčení bez ohledu na to, kde je to možné, a použití jemně odstupňovaného zamykání, kde jsou nutná zámky</span><span class="sxs-lookup"><span data-stu-id="4098b-106">The collection classes in the <xref:System.Collections.Concurrent?displayProperty=nameWithType> namespace provide thread-safe add and remove operations that avoid locks wherever possible and use fine-grained locking where locks are necessary.</span></span> <span data-ttu-id="4098b-107">Na rozdíl od kolekcí, které byly představeny v .NET Framework verzích 1,0 a 2,0, třída souběžného shromažďování nevyžaduje, aby při přístupu k položkám převzala kód uživatele.</span><span class="sxs-lookup"><span data-stu-id="4098b-107">Unlike collections that were introduced in the .NET Framework versions 1.0 and 2.0, a concurrent collection class does not require user code to take any locks when it accesses items.</span></span> <span data-ttu-id="4098b-108">Třídy souběžných kolekcí můžou významně zlepšit výkon nad typy, jako jsou <xref:System.Collections.ArrayList?displayProperty=nameWithType> a <xref:System.Collections.Generic.List%601?displayProperty=nameWithType> (s uživatelem implementovaným zámkem) ve scénářích, kdy více vláken přidává a odebírá položky z kolekce.</span><span class="sxs-lookup"><span data-stu-id="4098b-108">The concurrent collection classes can significantly improve performance over types such as <xref:System.Collections.ArrayList?displayProperty=nameWithType> and <xref:System.Collections.Generic.List%601?displayProperty=nameWithType> (with user-implemented locking) in scenarios where multiple threads add and remove items from a collection.</span></span>  
  
 <span data-ttu-id="4098b-109">Následující tabulka uvádí nové třídy souběžných kolekcí:</span><span class="sxs-lookup"><span data-stu-id="4098b-109">The following table lists the new concurrent collection classes:</span></span>  
  
|<span data-ttu-id="4098b-110">Typ</span><span class="sxs-lookup"><span data-stu-id="4098b-110">Type</span></span>|<span data-ttu-id="4098b-111">Popis</span><span class="sxs-lookup"><span data-stu-id="4098b-111">Description</span></span>|  
|----------|-----------------|  
|<xref:System.Collections.Concurrent.BlockingCollection%601?displayProperty=nameWithType>|<span data-ttu-id="4098b-112">Poskytuje blokující a ohraničování možností pro kolekce bezpečné pro přístup z více vláken, které implementují <xref:System.Collections.Concurrent.IProducerConsumerCollection%601?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="4098b-112">Provides blocking and bounding capabilities for thread-safe collections that implement <xref:System.Collections.Concurrent.IProducerConsumerCollection%601?displayProperty=nameWithType>.</span></span> <span data-ttu-id="4098b-113">Vlákna producenta zablokují, pokud nejsou k dispozici žádné sloty nebo pokud je kolekce plná.</span><span class="sxs-lookup"><span data-stu-id="4098b-113">Producer threads block if no slots are available or if the collection is full.</span></span> <span data-ttu-id="4098b-114">Vlákna příjemce jsou blokována, pokud je kolekce prázdná.</span><span class="sxs-lookup"><span data-stu-id="4098b-114">Consumer threads block if the collection is empty.</span></span> <span data-ttu-id="4098b-115">Tento typ také podporuje neblokující přístup uživatelů a výrobců.</span><span class="sxs-lookup"><span data-stu-id="4098b-115">This type also supports non-blocking access by consumers and producers.</span></span> <span data-ttu-id="4098b-116"><xref:System.Collections.Concurrent.BlockingCollection%601>dá se použít jako základní třída nebo záložní úložiště k poskytnutí blokování a vázání pro libovolnou třídu kolekce, která podporuje <xref:System.Collections.Generic.IEnumerable%601> .</span><span class="sxs-lookup"><span data-stu-id="4098b-116"><xref:System.Collections.Concurrent.BlockingCollection%601> can be used as a base class or backing store to provide blocking and bounding for any collection class that supports <xref:System.Collections.Generic.IEnumerable%601>.</span></span>|  
|<xref:System.Collections.Concurrent.ConcurrentBag%601?displayProperty=nameWithType>|<span data-ttu-id="4098b-117">Implementace kontejneru bezpečná pro přístup z více vláken, která poskytuje škálovatelné operace přidání a získání.</span><span class="sxs-lookup"><span data-stu-id="4098b-117">A thread-safe bag implementation that provides scalable add and get operations.</span></span>|  
|<xref:System.Collections.Concurrent.ConcurrentDictionary%602?displayProperty=nameWithType>|<span data-ttu-id="4098b-118">Souběžný a škálovatelný typ slovníku.</span><span class="sxs-lookup"><span data-stu-id="4098b-118">A concurrent and scalable dictionary type.</span></span>|  
|<xref:System.Collections.Concurrent.ConcurrentQueue%601?displayProperty=nameWithType>|<span data-ttu-id="4098b-119">Souběžná a škálovatelná fronta FIFO.</span><span class="sxs-lookup"><span data-stu-id="4098b-119">A concurrent and scalable FIFO queue.</span></span>|  
|<xref:System.Collections.Concurrent.ConcurrentStack%601?displayProperty=nameWithType>|<span data-ttu-id="4098b-120">Souběžný a škálovatelný zásobník LIFO.</span><span class="sxs-lookup"><span data-stu-id="4098b-120">A concurrent and scalable LIFO stack.</span></span>|  
  
 <span data-ttu-id="4098b-121">Další informace najdete v tématu [kolekce bezpečné](../collections/thread-safe/index.md)pro přístup z více vláken.</span><span class="sxs-lookup"><span data-stu-id="4098b-121">For more information, see [Thread-Safe Collections](../collections/thread-safe/index.md).</span></span>  
  
## <a name="synchronization-primitives"></a><span data-ttu-id="4098b-122">Synchronizace primitiv</span><span class="sxs-lookup"><span data-stu-id="4098b-122">Synchronization Primitives</span></span>  
 <span data-ttu-id="4098b-123">Nové synchronizační primitiva v <xref:System.Threading?displayProperty=nameWithType> oboru názvů umožňují jemně odstupňovaný a rychlejší výkon tím, že v kódu s více vlákny vyloučí nákladný mechanizmy zámků.</span><span class="sxs-lookup"><span data-stu-id="4098b-123">The new synchronization primitives in the <xref:System.Threading?displayProperty=nameWithType> namespace enable fine-grained concurrency and faster performance by avoiding expensive locking mechanisms found in legacy multithreading code.</span></span> <span data-ttu-id="4098b-124">Některé nové typy, například <xref:System.Threading.Barrier?displayProperty=nameWithType> a <xref:System.Threading.CountdownEvent?displayProperty=nameWithType> nemají žádné protějšky v dřívějších verzích .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="4098b-124">Some of the new types, such as <xref:System.Threading.Barrier?displayProperty=nameWithType> and <xref:System.Threading.CountdownEvent?displayProperty=nameWithType> have no counterparts in earlier releases of the .NET Framework.</span></span>  
  
 <span data-ttu-id="4098b-125">Následující tabulka uvádí nové typy synchronizace:</span><span class="sxs-lookup"><span data-stu-id="4098b-125">The following table lists the new synchronization types:</span></span>  
  
|<span data-ttu-id="4098b-126">Typ</span><span class="sxs-lookup"><span data-stu-id="4098b-126">Type</span></span>|<span data-ttu-id="4098b-127">Popis</span><span class="sxs-lookup"><span data-stu-id="4098b-127">Description</span></span>|  
|----------|-----------------|  
|<xref:System.Threading.Barrier?displayProperty=nameWithType>|<span data-ttu-id="4098b-128">Umožňuje více vláknům souběžně pracovat s algoritmem tím, že poskytuje bod, ve kterém každý úkol může signalizovat doručení a pak zablokovat, dokud nebudou přijaty některé nebo všechny úlohy.</span><span class="sxs-lookup"><span data-stu-id="4098b-128">Enables multiple threads to work on an algorithm in parallel by providing a point at which each task can signal its arrival and then block until some or all tasks have arrived.</span></span> <span data-ttu-id="4098b-129">Další informace najdete v tématu [bariéra](../threading/barrier.md).</span><span class="sxs-lookup"><span data-stu-id="4098b-129">For more information, see [Barrier](../threading/barrier.md).</span></span>|  
|<xref:System.Threading.CountdownEvent?displayProperty=nameWithType>|<span data-ttu-id="4098b-130">Zjednodušuje rozvětvení a spojování scénářů poskytnutím jednoduchého mechanizmu Rendezvous.</span><span class="sxs-lookup"><span data-stu-id="4098b-130">Simplifies fork and join scenarios by providing an easy rendezvous mechanism.</span></span> <span data-ttu-id="4098b-131">Další informace najdete v tématu [CountdownEvent](../threading/countdownevent.md).</span><span class="sxs-lookup"><span data-stu-id="4098b-131">For more information, see [CountdownEvent](../threading/countdownevent.md).</span></span>|  
|<xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType>|<span data-ttu-id="4098b-132">Primitiva synchronizace podobná <xref:System.Threading.ManualResetEvent?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="4098b-132">A synchronization primitive similar to <xref:System.Threading.ManualResetEvent?displayProperty=nameWithType>.</span></span> <span data-ttu-id="4098b-133"><xref:System.Threading.ManualResetEventSlim>je světlejší-váha, ale dá se použít jenom pro komunikaci uvnitř procesu.</span><span class="sxs-lookup"><span data-stu-id="4098b-133"><xref:System.Threading.ManualResetEventSlim> is lighter-weight but can only be used for intra-process communication.</span></span>|  
|<xref:System.Threading.SemaphoreSlim?displayProperty=nameWithType>|<span data-ttu-id="4098b-134">Primitiva synchronizace, která omezuje počet vláken, která můžou souběžně přistupovat k prostředku nebo k fondu prostředků.</span><span class="sxs-lookup"><span data-stu-id="4098b-134">A synchronization primitive that limits the number of threads that can concurrently access a resource or a pool of resources.</span></span> <span data-ttu-id="4098b-135">Další informace najdete v tématu [semafor a SemaphoreSlim](../threading/semaphore-and-semaphoreslim.md).</span><span class="sxs-lookup"><span data-stu-id="4098b-135">For more information, see [Semaphore and SemaphoreSlim](../threading/semaphore-and-semaphoreslim.md).</span></span>|  
|<xref:System.Threading.SpinLock?displayProperty=nameWithType>|<span data-ttu-id="4098b-136">Primitiva vzájemného zámku pro vyloučení, která způsobí, že vlákno, které se pokouší získat zámek, čeká ve smyčce nebo *číselníku*po určitou dobu před vyřazením jeho nestavů.</span><span class="sxs-lookup"><span data-stu-id="4098b-136">A mutual exclusion lock primitive that causes the thread that is trying to acquire the lock to wait in a loop, or *spin*, for a period of time before yielding its quantum.</span></span> <span data-ttu-id="4098b-137">Ve scénářích, kdy se očekává, že je čekání na zámek krátké, <xref:System.Threading.SpinLock> nabízí lepší výkon než jiné formy zamykání.</span><span class="sxs-lookup"><span data-stu-id="4098b-137">In scenarios where the wait for the lock is expected to be short, <xref:System.Threading.SpinLock> offers better performance than other forms of locking.</span></span> <span data-ttu-id="4098b-138">Další informace najdete v tématu [struktuře SpinLock](../threading/spinlock.md).</span><span class="sxs-lookup"><span data-stu-id="4098b-138">For more information, see [SpinLock](../threading/spinlock.md).</span></span>|  
|<xref:System.Threading.SpinWait?displayProperty=nameWithType>|<span data-ttu-id="4098b-139">Malý, lehký typ, který se po určitou dobu vytočí a nakonec vloží vlákno do čekacího stavu, pokud je překročený počet číselníku.</span><span class="sxs-lookup"><span data-stu-id="4098b-139">A small, lightweight type that will spin for a specified time and eventually put the thread into a wait state if the spin count is exceeded.</span></span>  <span data-ttu-id="4098b-140">Další informace najdete v tématu [objektu SpinWait](../threading/spinwait.md).</span><span class="sxs-lookup"><span data-stu-id="4098b-140">For more information, see [SpinWait](../threading/spinwait.md).</span></span>|  
  
 <span data-ttu-id="4098b-141">Další informace naleznete v tématu:</span><span class="sxs-lookup"><span data-stu-id="4098b-141">For more information, see:</span></span>  
  
- [<span data-ttu-id="4098b-142">Postupy: Použití struktury SpinLock pro synchronizaci nízké úrovně</span><span class="sxs-lookup"><span data-stu-id="4098b-142">How to: Use SpinLock for Low-Level Synchronization</span></span>](../threading/how-to-use-spinlock-for-low-level-synchronization.md)  
  
- <span data-ttu-id="4098b-143">[Postupy: synchronizace souběžných operací s bariérou](../threading/how-to-synchronize-concurrent-operations-with-a-barrier.md).</span><span class="sxs-lookup"><span data-stu-id="4098b-143">[How to: Synchronize Concurrent Operations with a Barrier](../threading/how-to-synchronize-concurrent-operations-with-a-barrier.md).</span></span>  
  
## <a name="lazy-initialization-classes"></a><span data-ttu-id="4098b-144">Třídy opožděné inicializace</span><span class="sxs-lookup"><span data-stu-id="4098b-144">Lazy Initialization Classes</span></span>  
 <span data-ttu-id="4098b-145">V případě opožděné inicializace není paměť pro objekt přidělena, dokud není nutné.</span><span class="sxs-lookup"><span data-stu-id="4098b-145">With lazy initialization, the memory for an object is not allocated until it is needed.</span></span> <span data-ttu-id="4098b-146">Opožděná inicializace může zvýšit výkon rozšířením přidělení objektů rovnoměrně po celou dobu životnosti programu.</span><span class="sxs-lookup"><span data-stu-id="4098b-146">Lazy initialization can improve performance by spreading object allocations evenly across the lifetime of a program.</span></span> <span data-ttu-id="4098b-147">Můžete povolit opožděnou inicializaci pro libovolný vlastní typ vybalením typu <xref:System.Lazy%601> .</span><span class="sxs-lookup"><span data-stu-id="4098b-147">You can enable lazy initialization for any custom type by wrapping the type <xref:System.Lazy%601>.</span></span>  
  
 <span data-ttu-id="4098b-148">V následující tabulce jsou uvedeny typy opožděné inicializace:</span><span class="sxs-lookup"><span data-stu-id="4098b-148">The following table lists the lazy initialization types:</span></span>  
  
|<span data-ttu-id="4098b-149">Typ</span><span class="sxs-lookup"><span data-stu-id="4098b-149">Type</span></span>|<span data-ttu-id="4098b-150">Popis</span><span class="sxs-lookup"><span data-stu-id="4098b-150">Description</span></span>|  
|----------|-----------------|  
|<xref:System.Lazy%601?displayProperty=nameWithType>|<span data-ttu-id="4098b-151">Poskytuje odlehčenou inicializaci bezpečnou pro přístup z více vláken.</span><span class="sxs-lookup"><span data-stu-id="4098b-151">Provides lightweight, thread-safe lazy-initialization.</span></span>|  
|<xref:System.Threading.ThreadLocal%601?displayProperty=nameWithType>|<span data-ttu-id="4098b-152">Poskytuje laxně vytvářená inicializovaných hodnot pro každé vlákno, přičemž každé vlákno laxně vytvářená vyvolá inicializační funkci.</span><span class="sxs-lookup"><span data-stu-id="4098b-152">Provides a lazily-initialized value on a per-thread basis, with each thread lazily-invoking the initialization function.</span></span>|  
|<xref:System.Threading.LazyInitializer?displayProperty=nameWithType>|<span data-ttu-id="4098b-153">Poskytuje statické metody, které zabraňují nutnosti přidělit vyhrazenou instanci opožděné inicializace.</span><span class="sxs-lookup"><span data-stu-id="4098b-153">Provides static methods that avoid the need to allocate a dedicated, lazy-initialization instance.</span></span> <span data-ttu-id="4098b-154">Místo toho používají odkazy, aby bylo zajištěno, že cíle byly inicializovány při jejich použití.</span><span class="sxs-lookup"><span data-stu-id="4098b-154">Instead, they use references to ensure targets have been initialized as they are accessed.</span></span>|  
  
 <span data-ttu-id="4098b-155">Další informace naleznete v tématu [opožděná inicializace](../../framework/performance/lazy-initialization.md).</span><span class="sxs-lookup"><span data-stu-id="4098b-155">For more information, see [Lazy Initialization](../../framework/performance/lazy-initialization.md).</span></span>  
  
## <a name="aggregate-exceptions"></a><span data-ttu-id="4098b-156">Agregované výjimky</span><span class="sxs-lookup"><span data-stu-id="4098b-156">Aggregate Exceptions</span></span>  
 <span data-ttu-id="4098b-157"><xref:System.AggregateException?displayProperty=nameWithType>Typ lze použít k zachycení více výjimek, které jsou vyvolány souběžně v samostatných vláknech a vrátí je do spojovacího vlákna jako jediná výjimka.</span><span class="sxs-lookup"><span data-stu-id="4098b-157">The <xref:System.AggregateException?displayProperty=nameWithType> type can be used to capture multiple exceptions that are thrown concurrently on separate threads, and return them to the joining thread as a single exception.</span></span> <span data-ttu-id="4098b-158"><xref:System.Threading.Tasks.Task?displayProperty=nameWithType>Typy a <xref:System.Threading.Tasks.Parallel?displayProperty=nameWithType> a PLINQ používají <xref:System.AggregateException> pro tento účel rozsáhlou práci.</span><span class="sxs-lookup"><span data-stu-id="4098b-158">The <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> and <xref:System.Threading.Tasks.Parallel?displayProperty=nameWithType> types and PLINQ use <xref:System.AggregateException> extensively for this purpose.</span></span> <span data-ttu-id="4098b-159">Další informace naleznete v tématu [zpracování výjimek](exception-handling-task-parallel-library.md) a [Postupy: zpracování výjimek v dotazu PLINQ](how-to-handle-exceptions-in-a-plinq-query.md).</span><span class="sxs-lookup"><span data-stu-id="4098b-159">For more information, see [Exception Handling](exception-handling-task-parallel-library.md) and [How to: Handle Exceptions in a PLINQ Query](how-to-handle-exceptions-in-a-plinq-query.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="4098b-160">Viz také</span><span class="sxs-lookup"><span data-stu-id="4098b-160">See also</span></span>

- <xref:System.Collections.Concurrent?displayProperty=nameWithType>
- <xref:System.Threading?displayProperty=nameWithType>
- [<span data-ttu-id="4098b-161">Paralelní programování</span><span class="sxs-lookup"><span data-stu-id="4098b-161">Parallel Programming</span></span>](index.md)
