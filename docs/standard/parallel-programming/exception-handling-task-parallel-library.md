---
title: Zpracování výjimek (paralelní knihovna úloh)
ms.date: 04/20/2020
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- tasks, exceptions
ms.assetid: beb51e50-9061-4d3d-908c-56a4f7c2e8c1
ms.openlocfilehash: aa6d4b706eb11921ffd419402bcf4cf059a29b11
ms.sourcegitcommit: 348bb052d5cef109a61a3d5253faa5d7167d55ac
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 04/22/2020
ms.locfileid: "82021508"
---
# <a name="exception-handling-task-parallel-library"></a><span data-ttu-id="9ec1b-102">Zpracování výjimek (paralelní knihovna úloh)</span><span class="sxs-lookup"><span data-stu-id="9ec1b-102">Exception handling (Task Parallel Library)</span></span>

<span data-ttu-id="9ec1b-103">Neošetřené výjimky, které jsou vyvolány uživatelským kódem, který je spuštěn uvnitř úlohy, jsou šířeny zpět do volajícího vlákna, s výjimkou určitých scénářů, které jsou popsány dále v tomto tématu.</span><span class="sxs-lookup"><span data-stu-id="9ec1b-103">Unhandled exceptions that are thrown by user code that is running inside a task are propagated back to the calling thread, except in certain scenarios that are described later in this topic.</span></span> <span data-ttu-id="9ec1b-104">Výjimky jsou šířeny při použití jedné ze <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> statických metod nebo metod instance a `try` / `catch` zpracováváte je ohraničujícím volání v příkazu.</span><span class="sxs-lookup"><span data-stu-id="9ec1b-104">Exceptions are propagated when you use one of the static or instance <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> methods, and you handle them by enclosing the call in a `try`/`catch` statement.</span></span> <span data-ttu-id="9ec1b-105">Pokud je úkol nadřazenou podřízenou úlohou připojených podřízených úloh nebo pokud čekáte na více úkolů, může být vyvoláno více výjimek.</span><span class="sxs-lookup"><span data-stu-id="9ec1b-105">If a task is the parent of attached child tasks, or if you are waiting on multiple tasks, multiple exceptions could be thrown.</span></span>

<span data-ttu-id="9ec1b-106">Aby bylo možné šířit všechny výjimky zpět do hlavního vlákna, infrastruktura úkolů je zabaluje do instance <xref:System.AggregateException>.</span><span class="sxs-lookup"><span data-stu-id="9ec1b-106">To propagate all the exceptions back to the calling thread, the Task infrastructure wraps them in an <xref:System.AggregateException> instance.</span></span> <span data-ttu-id="9ec1b-107">Výjimka <xref:System.AggregateException> má <xref:System.AggregateException.InnerExceptions%2A> vlastnost, která může být výčtu zkoumat všechny původní výjimky, které byly vyvolány a zpracování (nebo nezpracování) každý z nich jednotlivě.</span><span class="sxs-lookup"><span data-stu-id="9ec1b-107">The <xref:System.AggregateException> exception has an <xref:System.AggregateException.InnerExceptions%2A> property that can be enumerated to examine all the original exceptions that were thrown, and handle (or not handle) each one individually.</span></span> <span data-ttu-id="9ec1b-108">Můžete také zpracovat původní výjimky <xref:System.AggregateException.Handle%2A?displayProperty=nameWithType> pomocí metody.</span><span class="sxs-lookup"><span data-stu-id="9ec1b-108">You can also handle the original exceptions by using the <xref:System.AggregateException.Handle%2A?displayProperty=nameWithType> method.</span></span>

<span data-ttu-id="9ec1b-109">I v případě, že je vyvolána pouze <xref:System.AggregateException> jedna výjimka, je stále zabalena do výjimky, jak ukazuje následující příklad.</span><span class="sxs-lookup"><span data-stu-id="9ec1b-109">Even if only one exception is thrown, it is still wrapped in an <xref:System.AggregateException> exception, as the following example shows.</span></span>

[!code-csharp[TPL_Exceptions#21](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_exceptions/cs/handling21.cs#21)]
[!code-vb[TPL_Exceptions#21](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_exceptions/vb/handling21.vb#21)]

<span data-ttu-id="9ec1b-110">Nezpracované výjimce se můžete vyhnout zachycením instance <xref:System.AggregateException> a ignorováním jakýchkoli vnitřních výjimek.</span><span class="sxs-lookup"><span data-stu-id="9ec1b-110">You could avoid an unhandled exception by just catching the <xref:System.AggregateException> and not observing any of the inner exceptions.</span></span> <span data-ttu-id="9ec1b-111">Doporučujeme však nedělat to, protože je obdobou zachycení <xref:System.Exception> základní typ v neparalelní scénáře.</span><span class="sxs-lookup"><span data-stu-id="9ec1b-111">However, we recommend that you do not do this because it is analogous to catching the base <xref:System.Exception> type in non-parallel scenarios.</span></span> <span data-ttu-id="9ec1b-112">Pokud zachytíte výjimku, a potom neprovedete žádnou konkrétní akci zotavení, bude program ponechán v neurčitém stavu.</span><span class="sxs-lookup"><span data-stu-id="9ec1b-112">To catch an exception without taking specific actions to recover from it can leave your program in an indeterminate state.</span></span>

<span data-ttu-id="9ec1b-113">Pokud nechcete volat metodu <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> čekat na dokončení úkolu, můžete také <xref:System.AggregateException> načíst výjimku <xref:System.Threading.Tasks.Task.Exception%2A> z vlastnosti úkolu, jak ukazuje následující příklad.</span><span class="sxs-lookup"><span data-stu-id="9ec1b-113">If you do not want to call the <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> method to wait for a task's completion, you can also retrieve the <xref:System.AggregateException> exception from the task's <xref:System.Threading.Tasks.Task.Exception%2A> property, as the following example shows.</span></span> <span data-ttu-id="9ec1b-114">Další informace naleznete [v části Sledování výjimek pomocí části Vlastnost Task.Exception](#observing-exceptions-by-using-the-taskexception-property) v tomto tématu.</span><span class="sxs-lookup"><span data-stu-id="9ec1b-114">For more information, see the [Observing exceptions by using the Task.Exception property](#observing-exceptions-by-using-the-taskexception-property) section in this topic.</span></span>

[!code-csharp[TPL_Exceptions#29](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_exceptions/cs/handling22.cs#29)]
[!code-vb[TPL_Exceptions#29](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_exceptions/vb/handling22.vb#29)]

<span data-ttu-id="9ec1b-115">Pokud nečekáte na úlohu, která šíří výjimku, nebo přístup k jeho <xref:System.Threading.Tasks.Task.Exception%2A> vlastnosti, výjimka je eskalována podle zásady výjimky .NET při uvolňování úlohy.</span><span class="sxs-lookup"><span data-stu-id="9ec1b-115">If you do not wait on a task that propagates an exception, or access its <xref:System.Threading.Tasks.Task.Exception%2A> property, the exception is escalated according to the .NET exception policy when the task is garbage-collected.</span></span>

<span data-ttu-id="9ec1b-116">Pokud jsou povoleny výjimky bubliny zpět do spojovacího vlákna, je možné, že úkol může pokračovat ve zpracování některých položek po vyvolání výjimky.</span><span class="sxs-lookup"><span data-stu-id="9ec1b-116">When exceptions are allowed to bubble up back to the joining thread, it is possible that a task may continue to process some items after the exception is raised.</span></span>

> [!NOTE]
> <span data-ttu-id="9ec1b-117">Pokud je povolena vlastnost „Pouze vlastní kód“, zastaví se sada Visual Studio v některých případech na řádce, která výjimku vyvolá, a zobrazí chybovou zprávu s upozorněním, že „výjimka není zpracována uživatelským kódem“.</span><span class="sxs-lookup"><span data-stu-id="9ec1b-117">When "Just My Code" is enabled, Visual Studio in some cases will break on the line that throws the exception and display an error message that says "exception not handled by user code."</span></span> <span data-ttu-id="9ec1b-118">Tato chyba je neškodná.</span><span class="sxs-lookup"><span data-stu-id="9ec1b-118">This error is benign.</span></span> <span data-ttu-id="9ec1b-119">Můžete pokračovat stisknutím klávesy F5 a zjistit, jakým způsobem jsou zpracovaný výjimky, což je znázorněno v těchto příkladech.</span><span class="sxs-lookup"><span data-stu-id="9ec1b-119">You can press F5 to continue and see the exception-handling behavior that is demonstrated in these examples.</span></span> <span data-ttu-id="9ec1b-120">Chcete-li zabránit visual studio z rozdělení na první chybu, stačí zrušit zaškrtnutí políčka **Povolit pouze můj kód** v části **Nástroje, možnosti, ladění, obecné**.</span><span class="sxs-lookup"><span data-stu-id="9ec1b-120">To prevent Visual Studio from breaking on the first error, just uncheck the **Enable Just My Code** checkbox under **Tools, Options, Debugging, General**.</span></span>

## <a name="attached-child-tasks-and-nested-aggregateexceptions"></a><span data-ttu-id="9ec1b-121">Připojené podřízené úkoly a vnořené aggregateExceptions</span><span class="sxs-lookup"><span data-stu-id="9ec1b-121">Attached child tasks and nested AggregateExceptions</span></span>

<span data-ttu-id="9ec1b-122">Pokud úloha obsahuje připojené podřízené úlohy, které způsobí výjimku, je tato výjimka zabalená do instance <xref:System.AggregateException> předtím, než je postoupena do nadřazené úlohy, která zabalí tuto výjimku do vlastní instance <xref:System.AggregateException> dříve, než ji postoupí zpět do volajícího vlákna.</span><span class="sxs-lookup"><span data-stu-id="9ec1b-122">If a task has an attached child task that throws an exception, that exception is wrapped in an <xref:System.AggregateException> before it is propagated to the parent task, which wraps that exception in its own <xref:System.AggregateException> before it propagates it back to the calling thread.</span></span> <span data-ttu-id="9ec1b-123">V takových případech <xref:System.AggregateException.InnerExceptions%2A> vlastnost <xref:System.AggregateException> výjimky, která <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType>je <xref:System.Threading.Tasks.Task.WaitAny%2A>zachycena v , nebo <xref:System.Threading.Tasks.Task.WaitAll%2A> metoda obsahuje jednu nebo více <xref:System.AggregateException> instancí, nikoli původní výjimky, které způsobily chybu.</span><span class="sxs-lookup"><span data-stu-id="9ec1b-123">In such cases, the <xref:System.AggregateException.InnerExceptions%2A> property of the <xref:System.AggregateException> exception that is caught at the <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType>, <xref:System.Threading.Tasks.Task.WaitAny%2A>, or <xref:System.Threading.Tasks.Task.WaitAll%2A> method contains one or more <xref:System.AggregateException> instances, not the original exceptions that caused the fault.</span></span> <span data-ttu-id="9ec1b-124">Chcete-li se vyhnout nutnosti <xref:System.AggregateException> iterát přes <xref:System.AggregateException.Flatten%2A> vnořené výjimky, můžete použít metodu k odebrání všech vnořených <xref:System.AggregateException> výjimek tak, aby <xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType> vlastnost obsahuje původní výjimky.</span><span class="sxs-lookup"><span data-stu-id="9ec1b-124">To avoid having to iterate over nested <xref:System.AggregateException> exceptions, you can use the <xref:System.AggregateException.Flatten%2A> method to remove all the nested <xref:System.AggregateException> exceptions, so that the <xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType> property contains the original exceptions.</span></span> <span data-ttu-id="9ec1b-125">V následujícím příkladu jsou vnořené instance <xref:System.AggregateException> zploštěny a zpracovávány pouze v jednom průchodu.</span><span class="sxs-lookup"><span data-stu-id="9ec1b-125">In the following example, nested <xref:System.AggregateException> instances are flattened and handled in just one loop.</span></span>

[!code-csharp[TPL_Exceptions#22](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_exceptions/cs/flatten2.cs#22)]
[!code-vb[TPL_Exceptions#22](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_exceptions/vb/flatten2.vb#22)]

<span data-ttu-id="9ec1b-126">Můžete také použít <xref:System.AggregateException.Flatten%2A?displayProperty=nameWithType> metodu znovu vyvolat vnitřní <xref:System.AggregateException> výjimky z více instancí <xref:System.AggregateException> vyvolána více úkolů v jedné instanci, jak ukazuje následující příklad.</span><span class="sxs-lookup"><span data-stu-id="9ec1b-126">You can also use the <xref:System.AggregateException.Flatten%2A?displayProperty=nameWithType> method to rethrow the inner exceptions from multiple <xref:System.AggregateException> instances thrown by multiple tasks in a single <xref:System.AggregateException> instance, as the following example shows.</span></span>

[!code-csharp[TPL_Exceptions#13](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_exceptions/cs/taskexceptions2.cs#13)]
[!code-vb[TPL_Exceptions#13](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_exceptions/vb/taskexceptions2.vb#13)]

## <a name="exceptions-from-detached-child-tasks"></a><span data-ttu-id="9ec1b-127">Výjimky z odpojených podřízených úkolů</span><span class="sxs-lookup"><span data-stu-id="9ec1b-127">Exceptions from detached child tasks</span></span>

<span data-ttu-id="9ec1b-128">Ve výchozím nastavení jsou podřízené úkoly vytvořeny jako odpojené.</span><span class="sxs-lookup"><span data-stu-id="9ec1b-128">By default, child tasks are created as detached.</span></span> <span data-ttu-id="9ec1b-129">Výjimky vyvolané z odpojených úkolů musí být zpracovány nebo znovu vyvolány ihned v nadřazeném úkolu. Tyto výjimky nejsou šířeny zpět do volajícího vlákna stejným způsobem jako připojené úkoly.</span><span class="sxs-lookup"><span data-stu-id="9ec1b-129">Exceptions thrown from detached tasks must be handled or rethrown in the immediate parent task; they are not propagated back to the calling thread in the same way as attached child tasks propagated back.</span></span> <span data-ttu-id="9ec1b-130">Nejvyšší nadřazený může ručně znovu vyvolat výjimku z odpojené <xref:System.AggregateException> podřízené způsobit, že má být zabalen a šířen zpět do volajícího vlákna.</span><span class="sxs-lookup"><span data-stu-id="9ec1b-130">The topmost parent can manually rethrow an exception from a detached child to cause it to be wrapped in an <xref:System.AggregateException> and propagated back to the calling thread.</span></span>

[!code-csharp[TPL_Exceptions#23](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_exceptions/cs/detached21.cs#23)]
[!code-vb[TPL_Exceptions#23](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_exceptions/vb/detached21.vb#23)]

<span data-ttu-id="9ec1b-131">I pokud používáte pokračování pro sledování výjimky v podřízeném úkolu, musí být výjimka stále sledována nadřazeným úkolem.</span><span class="sxs-lookup"><span data-stu-id="9ec1b-131">Even if you use a continuation to observe an exception in a child task, the exception still must be observed by the parent task.</span></span>

## <a name="exceptions-that-indicate-cooperative-cancellation"></a><span data-ttu-id="9ec1b-132">Výjimky, které označují zrušení spolupráce</span><span class="sxs-lookup"><span data-stu-id="9ec1b-132">Exceptions that indicate cooperative cancellation</span></span>

<span data-ttu-id="9ec1b-133">Pokud uživatelský kód v rámci úkolu odpoví na požadavek zrušení, mělo by správně dojít k vyvolání výjimky <xref:System.OperationCanceledException> a předání v tokenu zrušení, na kterém byl požadavek sdělen.</span><span class="sxs-lookup"><span data-stu-id="9ec1b-133">When user code in a task responds to a cancellation request, the correct procedure is to throw an <xref:System.OperationCanceledException> passing in the cancellation token on which the request was communicated.</span></span> <span data-ttu-id="9ec1b-134">Dříve než se pokusí o postoupení výjimky, porovná úkol token ve výjimce s tokenem, který byl předán při vytváření.</span><span class="sxs-lookup"><span data-stu-id="9ec1b-134">Before it attempts to propagate the exception, the task instance compares the token in the exception to the one that was passed to it when it was created.</span></span> <span data-ttu-id="9ec1b-135">Pokud se shodují, daný úkol postoupí výjimku <xref:System.Threading.Tasks.TaskCanceledException> zabalenou v instanci <xref:System.AggregateException> a lze ji zobrazit při ověřování vnořené výjimky.</span><span class="sxs-lookup"><span data-stu-id="9ec1b-135">If they are the same, the task propagates a <xref:System.Threading.Tasks.TaskCanceledException> wrapped in the <xref:System.AggregateException>, and it can be seen when the inner exceptions are examined.</span></span> <span data-ttu-id="9ec1b-136">Pokud však volající vlákno na úlohu nečeká, nebude tato konkrétní výjimka rozšířena.</span><span class="sxs-lookup"><span data-stu-id="9ec1b-136">However, if the calling thread is not waiting on the task, this specific exception will not be propagated.</span></span> <span data-ttu-id="9ec1b-137">Další informace naleznete v [tématu Zrušení úkolu](../../../docs/standard/parallel-programming/task-cancellation.md).</span><span class="sxs-lookup"><span data-stu-id="9ec1b-137">For more information, see [Task Cancellation](../../../docs/standard/parallel-programming/task-cancellation.md).</span></span>

[!code-csharp[TPL_Exceptions#4](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_exceptions/cs/exceptions.cs#4)]
[!code-vb[TPL_Exceptions#4](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_exceptions/vb/tpl_exceptions.vb#4)]

## <a name="using-the-handle-method-to-filter-inner-exceptions"></a><span data-ttu-id="9ec1b-138">Použití metody popisovače k filtrování vnitřních výjimek</span><span class="sxs-lookup"><span data-stu-id="9ec1b-138">Using the handle method to filter inner exceptions</span></span>

<span data-ttu-id="9ec1b-139">Metodu <xref:System.AggregateException.Handle%2A?displayProperty=nameWithType> můžete použít k filtrování výjimek, které lze považovat jako „zpracované“ bez použití jakékoli další logiky.</span><span class="sxs-lookup"><span data-stu-id="9ec1b-139">You can use the <xref:System.AggregateException.Handle%2A?displayProperty=nameWithType> method to filter out exceptions that you can treat as "handled" without using any further logic.</span></span> <span data-ttu-id="9ec1b-140">V delegáta uživatele, který <xref:System.AggregateException.Handle%28System.Func%7BSystem.Exception%2CSystem.Boolean%7D%29?displayProperty=nameWithType> je dodáván k metodě, <xref:System.Exception.Message%2A> můžete zkontrolovat typ výjimky, jeho vlastnost nebo jakékoli jiné informace o něm, které vám umožní určit, zda je neškodný.</span><span class="sxs-lookup"><span data-stu-id="9ec1b-140">In the user delegate that is supplied to the <xref:System.AggregateException.Handle%28System.Func%7BSystem.Exception%2CSystem.Boolean%7D%29?displayProperty=nameWithType> method, you can examine the exception type, its <xref:System.Exception.Message%2A> property, or any other information about it that will let you determine whether it is benign.</span></span> <span data-ttu-id="9ec1b-141">Všechny výjimky, pro `false` které delegát vrátí jsou <xref:System.AggregateException> znovu vyvolány v nové instanci ihned po <xref:System.AggregateException.Handle%2A?displayProperty=nameWithType> vrátí metoda.</span><span class="sxs-lookup"><span data-stu-id="9ec1b-141">Any exceptions for which the delegate returns `false` are rethrown in a new <xref:System.AggregateException> instance immediately after the <xref:System.AggregateException.Handle%2A?displayProperty=nameWithType> method returns.</span></span>

<span data-ttu-id="9ec1b-142">Následující příklad je funkčně ekvivalentní prvnímu příkladu v tomto <xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType> tématu, který zkoumá každou výjimku v kolekci.</span><span class="sxs-lookup"><span data-stu-id="9ec1b-142">The following example is functionally equivalent to the first example in this topic, which examines each exception in the <xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType> collection.</span></span>  <span data-ttu-id="9ec1b-143">Místo toho tato obslužná rutina výjimky volá objekt <xref:System.AggregateException.Handle%2A?displayProperty=nameWithType> metody `CustomException` pro každou výjimku a pouze znovu vyvolá výjimky, které nejsou instancemi.</span><span class="sxs-lookup"><span data-stu-id="9ec1b-143">Instead, this exception handler calls the <xref:System.AggregateException.Handle%2A?displayProperty=nameWithType> method object for each exception, and only rethrows exceptions that are not `CustomException` instances.</span></span>

[!code-csharp[TPL_Exceptions#26](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_exceptions/cs/handlemethod21.cs#26)]
[!code-vb[TPL_Exceptions#26](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_exceptions/vb/handlemethod21.vb#26)]

<span data-ttu-id="9ec1b-144">Následuje úplnější příklad, který <xref:System.AggregateException.Handle%2A?displayProperty=nameWithType> používá metodu k <xref:System.UnauthorizedAccessException> poskytnutí zvláštního zpracování výjimky při výčtu souborů.</span><span class="sxs-lookup"><span data-stu-id="9ec1b-144">The following is a more complete example that uses the <xref:System.AggregateException.Handle%2A?displayProperty=nameWithType> method to provide special handling for an <xref:System.UnauthorizedAccessException> exception when enumerating files.</span></span>

[!code-csharp[TPL_Exceptions#12](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_exceptions/cs/taskexceptions.cs#12)]
[!code-vb[TPL_Exceptions#12](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_exceptions/vb/taskexceptions.vb#12)]

## <a name="observing-exceptions-by-using-the-taskexception-property"></a><span data-ttu-id="9ec1b-145">Pozorování výjimek pomocí vlastnosti Task.Exception</span><span class="sxs-lookup"><span data-stu-id="9ec1b-145">Observing exceptions by using the Task.Exception property</span></span>

<span data-ttu-id="9ec1b-146">Pokud úkol skončí ve stavu <xref:System.Threading.Tasks.TaskStatus.Faulted?displayProperty=nameWithType>, může být její vlastnost <xref:System.Threading.Tasks.Task.Exception%2A> přezkoumána a zjištěna výjimka, která chybu způsobila.</span><span class="sxs-lookup"><span data-stu-id="9ec1b-146">If a task completes in the <xref:System.Threading.Tasks.TaskStatus.Faulted?displayProperty=nameWithType> state, its <xref:System.Threading.Tasks.Task.Exception%2A> property can be examined to discover which specific exception caused the fault.</span></span> <span data-ttu-id="9ec1b-147">Vhodným způsobem sledování vlastnosti <xref:System.Threading.Tasks.Task.Exception%2A> je použití pokračování, které se spouští pouze v případě selhání předchozího úkolu, jak je znázorněno v následujícím příkladu.</span><span class="sxs-lookup"><span data-stu-id="9ec1b-147">A good way to observe the <xref:System.Threading.Tasks.Task.Exception%2A> property is to use a continuation that runs only if the antecedent task faults, as shown in the following example.</span></span>

[!code-csharp[TPL_Exceptions#27](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_exceptions/cs/exceptionprop21.cs#27)]
[!code-vb[TPL_Exceptions#27](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_exceptions/vb/exceptionprop21.vb#27)]

<span data-ttu-id="9ec1b-148">Ve smysluplné aplikaci může delegát pokračování protokolovat podrobné informace o výjimce a případně vytvořit nové úkoly, které se z výjimky zotaví.</span><span class="sxs-lookup"><span data-stu-id="9ec1b-148">In a meaningful application, the continuation delegate could log detailed information about the exception and possibly spawn new tasks to recover from the exception.</span></span> <span data-ttu-id="9ec1b-149">Pokud úloha chyby, následující výrazy vyvolat výjimku:</span><span class="sxs-lookup"><span data-stu-id="9ec1b-149">If a task faults, the following expressions throw the exception:</span></span>

- `await task`
- `task.Wait()`
- `task.Result`
- `task.GetAwaiter().GetResult()`

<span data-ttu-id="9ec1b-150">Použijte [`try-catch`](../../csharp/language-reference/keywords/try-catch.md) příkaz pro zpracování a sledování vyzdvižené výjimky.</span><span class="sxs-lookup"><span data-stu-id="9ec1b-150">Use a [`try-catch`](../../csharp/language-reference/keywords/try-catch.md) statement to handle and observe thrown exceptions.</span></span> <span data-ttu-id="9ec1b-151">Případně dodržujte výjimku přístupem <xref:System.Threading.Tasks.Task.Exception%2A?displayProperty=nameWithType> k vlastnosti.</span><span class="sxs-lookup"><span data-stu-id="9ec1b-151">Alternatively, observe the exception by accessing the <xref:System.Threading.Tasks.Task.Exception%2A?displayProperty=nameWithType> property.</span></span>

## <a name="unobservedtaskexception-event"></a><span data-ttu-id="9ec1b-152">Událost UnobservedTaskException</span><span class="sxs-lookup"><span data-stu-id="9ec1b-152">UnobservedTaskException event</span></span>

<span data-ttu-id="9ec1b-153">V některých situacích, jako je například hostování nedůvěryhodných zásuvných modulů, mohou být neškodné výjimky běžné a může být příliš obtížné je všechny sledovat ručně.</span><span class="sxs-lookup"><span data-stu-id="9ec1b-153">In some scenarios, such as when hosting untrusted plug-ins, benign exceptions might be common, and it might be too difficult to manually observe them all.</span></span> <span data-ttu-id="9ec1b-154">V těchto případech je možné zpracovat událost <xref:System.Threading.Tasks.TaskScheduler.UnobservedTaskException?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="9ec1b-154">In these cases, you can handle the <xref:System.Threading.Tasks.TaskScheduler.UnobservedTaskException?displayProperty=nameWithType> event.</span></span> <span data-ttu-id="9ec1b-155">Instance <xref:System.Threading.Tasks.UnobservedTaskExceptionEventArgs?displayProperty=nameWithType>, která je předána obslužné rutině, může být použita k zamezení šíření nesledovaných výjimek zpět do spojovacího vlákna.</span><span class="sxs-lookup"><span data-stu-id="9ec1b-155">The <xref:System.Threading.Tasks.UnobservedTaskExceptionEventArgs?displayProperty=nameWithType> instance that is passed to your handler can be used to prevent the unobserved exception from being propagated back to the joining thread.</span></span>

## <a name="see-also"></a><span data-ttu-id="9ec1b-156">Viz také</span><span class="sxs-lookup"><span data-stu-id="9ec1b-156">See also</span></span>

- [<span data-ttu-id="9ec1b-157">Task Parallel Library (TPL)</span><span class="sxs-lookup"><span data-stu-id="9ec1b-157">Task Parallel Library (TPL)</span></span>](../../../docs/standard/parallel-programming/task-parallel-library-tpl.md)
