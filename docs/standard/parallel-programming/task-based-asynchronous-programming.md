---
title: Asynchronní programování založené na úlohách
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- parallelism, task
ms.assetid: 458b5e69-5210-45e5-bc44-3888f86abd6f
author: rpetrusha
ms.author: ronpet
ms.openlocfilehash: e3dad3e33968b72d199b412c65f04a4079020f78
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 05/04/2018
ms.locfileid: "33592586"
---
# <a name="task-based-asynchronous-programming"></a><span data-ttu-id="627df-102">Asynchronní programování založené na úlohách</span><span class="sxs-lookup"><span data-stu-id="627df-102">Task-based Asynchronous Programming</span></span>
<span data-ttu-id="627df-103">Task Parallel Library (TPL) je založena na konceptu *úloh*, která představuje asynchronní operaci.</span><span class="sxs-lookup"><span data-stu-id="627df-103">The Task Parallel Library (TPL) is based on the concept of a *task*, which represents an asynchronous operation.</span></span> <span data-ttu-id="627df-104">V některých způsobech úlohu podobá vlákna nebo <xref:System.Threading.ThreadPool> pracovních položek, ale na vyšší úrovni abstrakce.</span><span class="sxs-lookup"><span data-stu-id="627df-104">In some ways, a task resembles a thread or <xref:System.Threading.ThreadPool> work item, but at a higher level of abstraction.</span></span> <span data-ttu-id="627df-105">Termín *úkolů paralelismus* odkazuje na jeden nebo více nezávislých úkoly, které jsou spuštěné současně.</span><span class="sxs-lookup"><span data-stu-id="627df-105">The term *task parallelism* refers to one or more independent tasks running concurrently.</span></span> <span data-ttu-id="627df-106">Úlohy poskytují dvě hlavní výhody:</span><span class="sxs-lookup"><span data-stu-id="627df-106">Tasks provide two primary benefits:</span></span>  
  
-   <span data-ttu-id="627df-107">Větší škálovatelnost a efektivnější využívání systémových prostředků.</span><span class="sxs-lookup"><span data-stu-id="627df-107">More efficient and more scalable use of system resources.</span></span>  
  
     <span data-ttu-id="627df-108">Na pozadí jsou úlohy zařazené do <xref:System.Threading.ThreadPool>, které se rozšířily o algoritmy, zjistit a upravte počet vláken, a které poskytují, Maximalizovat propustnost Vyrovnávání zatížení.</span><span class="sxs-lookup"><span data-stu-id="627df-108">Behind the scenes, tasks are queued to the <xref:System.Threading.ThreadPool>, which has been enhanced with algorithms  that determine and adjust to the number of threads and that provide load balancing to maximize throughput.</span></span> <span data-ttu-id="627df-109">Díky tomu jsou úlohy relativně lehké a lze jich vytvořit mnoho, takže lze dosáhnout jemně odstupňovaného paralelismu.</span><span class="sxs-lookup"><span data-stu-id="627df-109">This makes tasks relatively lightweight, and you can create many of them to enable fine-grained parallelism.</span></span>  
  
-   <span data-ttu-id="627df-110">Více programového ovládání než je k dispozici s vláknem nebo pracovní položkou.</span><span class="sxs-lookup"><span data-stu-id="627df-110">More programmatic control than is possible with a thread or work item.</span></span>  
  
     <span data-ttu-id="627df-111">Úlohy a architektura kolem nich vytvořená poskytují bohatou sadu rozhraní (API), která podporují čekání, zrušení, pokračování, robustní zpracování výjimek, podrobný stav, vlastní plánování a další.</span><span class="sxs-lookup"><span data-stu-id="627df-111">Tasks and the framework built around them provide a rich set of APIs that support waiting, cancellation, continuations, robust exception handling, detailed status, custom scheduling, and more.</span></span>  
  
 <span data-ttu-id="627df-112">Pro oba z těchto důvodů je v rozhraní .NET Framework TPL upřednostňovaným rozhraním API pro psaní vícevláknového, asynchronního a paralelního kódu.</span><span class="sxs-lookup"><span data-stu-id="627df-112">For both of these reasons, in the .NET Framework, TPL is the preferred API for writing multi-threaded, asynchronous, and parallel code.</span></span>  
  
## <a name="creating-and-running-tasks-implicitly"></a><span data-ttu-id="627df-113">Vytvoření a spuštění úloh implicitně</span><span class="sxs-lookup"><span data-stu-id="627df-113">Creating and running tasks implicitly</span></span>  
 <span data-ttu-id="627df-114"><xref:System.Threading.Tasks.Parallel.Invoke%2A?displayProperty=nameWithType> Metoda představuje pohodlný způsob pro souběžnou libovolný počet různých příkazů.</span><span class="sxs-lookup"><span data-stu-id="627df-114">The <xref:System.Threading.Tasks.Parallel.Invoke%2A?displayProperty=nameWithType> method provides a convenient way to run any number of arbitrary statements concurrently.</span></span> <span data-ttu-id="627df-115">Stačí pouze předat <xref:System.Action> delegáta pro každou položku práce.</span><span class="sxs-lookup"><span data-stu-id="627df-115">Just pass in an <xref:System.Action> delegate for each item of work.</span></span> <span data-ttu-id="627df-116">Nejsnadnější způsob, jak vytvořit tyto delegáty, je použití lambda výrazů.</span><span class="sxs-lookup"><span data-stu-id="627df-116">The easiest way to create these delegates is to use lambda expressions.</span></span> <span data-ttu-id="627df-117">Lambda výraz může buďto volat pojmenovanou metodu, nebo poskytnout vložený kód.</span><span class="sxs-lookup"><span data-stu-id="627df-117">The lambda expression can either call a named method or provide the code inline.</span></span> <span data-ttu-id="627df-118">Následující příklad ukazuje základní <xref:System.Threading.Tasks.Parallel.Invoke%2A> volání, které se vytvoří a spustí dvě úlohy, které běží souběžně.</span><span class="sxs-lookup"><span data-stu-id="627df-118">The following example shows a basic <xref:System.Threading.Tasks.Parallel.Invoke%2A> call that creates and starts two tasks that run concurrently.</span></span> <span data-ttu-id="627df-119">První úlohou je reprezentována výrazu lambda, která volá metodu s názvem `DoSomeWork`, a v druhé úloze je reprezentována výrazem lambda, která volá metodu s názvem `DoSomeOtherWork`.</span><span class="sxs-lookup"><span data-stu-id="627df-119">The first task is represented by a lambda expression that calls a method named `DoSomeWork`, and the second task is represented by a lambda expression that calls a method named `DoSomeOtherWork`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="627df-120">Tato dokumentace používá k definování delegátů v TPL lambda výrazy.</span><span class="sxs-lookup"><span data-stu-id="627df-120">This documentation uses lambda expressions to define delegates in TPL.</span></span> <span data-ttu-id="627df-121">Pokud nejste obeznámeni s výrazy lambda v jazyce C# nebo Visual Basic, přečtěte si téma [výrazy Lambda v PLINQ a TPL](../../../docs/standard/parallel-programming/lambda-expressions-in-plinq-and-tpl.md).</span><span class="sxs-lookup"><span data-stu-id="627df-121">If you are not familiar with lambda expressions in C# or Visual Basic, see [Lambda Expressions in PLINQ and TPL](../../../docs/standard/parallel-programming/lambda-expressions-in-plinq-and-tpl.md).</span></span>  
  
 [!code-csharp[TPL#21](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl/cs/tpl.cs#21)]
 [!code-vb[TPL#21](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl/vb/tpl_vb.vb#21)]  
  
> [!NOTE]
>  <span data-ttu-id="627df-122">Počet <xref:System.Threading.Tasks.Task> instancí, které jsou vytvořeny na pozadí pomocí <xref:System.Threading.Tasks.Parallel.Invoke%2A> není nutně roven počtu zadaných delegátů, které jsou k dispozici.</span><span class="sxs-lookup"><span data-stu-id="627df-122">The number of <xref:System.Threading.Tasks.Task> instances that are created behind the scenes by <xref:System.Threading.Tasks.Parallel.Invoke%2A> is not necessarily equal to the number of delegates that are provided.</span></span> <span data-ttu-id="627df-123">Knihovna TPL může využít různé optimalizace, zejména s velkým počtem delegátů.</span><span class="sxs-lookup"><span data-stu-id="627df-123">The TPL may employ various optimizations, especially with large numbers of delegates.</span></span>  
  
 <span data-ttu-id="627df-124">Další informace najdete v tématu [postupy: použití Parallel.Invoke k provádění paralelních operací](../../../docs/standard/parallel-programming/how-to-use-parallel-invoke-to-execute-parallel-operations.md).</span><span class="sxs-lookup"><span data-stu-id="627df-124">For more information, see [How to: Use Parallel.Invoke to Execute Parallel Operations](../../../docs/standard/parallel-programming/how-to-use-parallel-invoke-to-execute-parallel-operations.md).</span></span>  
  
 <span data-ttu-id="627df-125">Pro větší kontrolu nad spuštění úkolu nebo na vrácení hodnoty z úlohy, budete muset pracovat s <xref:System.Threading.Tasks.Task> více explicitně objekty.</span><span class="sxs-lookup"><span data-stu-id="627df-125">For greater control over task execution or to return a value from the task, you have to work with <xref:System.Threading.Tasks.Task> objects more explicitly.</span></span>  
  
## <a name="creating-and-running-tasks-explicitly"></a><span data-ttu-id="627df-126">Vytvoření a spuštění úloh explicitně</span><span class="sxs-lookup"><span data-stu-id="627df-126">Creating and running tasks explicitly</span></span>  
 <span data-ttu-id="627df-127">Úloha, která nevrátí hodnotu je reprezentována <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> třídy.</span><span class="sxs-lookup"><span data-stu-id="627df-127">A task that does not return a value is represented by the <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> class.</span></span> <span data-ttu-id="627df-128">Úloha, která vrátí hodnotu, je reprezentována <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> třídy, která dědí z <xref:System.Threading.Tasks.Task>.</span><span class="sxs-lookup"><span data-stu-id="627df-128">A task that returns a value is represented by the <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> class, which inherits from <xref:System.Threading.Tasks.Task>.</span></span> <span data-ttu-id="627df-129">Objekt úlohy zpracovává podrobnosti infrastruktury a poskytuje metody a vlastnosti, které jsou přístupné z volajícího vlákna po celou dobu trvání úlohy.</span><span class="sxs-lookup"><span data-stu-id="627df-129">The task object handles the infrastructure details and provides methods and properties that are accessible from the calling thread throughout the lifetime of the task.</span></span> <span data-ttu-id="627df-130">Například můžete získat přístup <xref:System.Threading.Tasks.Task.Status%2A> vlastnosti úlohy kdykoli k určení, zda byla spuštěna, byl dokončen, byla zrušena nebo došlo k výjimce.</span><span class="sxs-lookup"><span data-stu-id="627df-130">For example, you can access the <xref:System.Threading.Tasks.Task.Status%2A> property of a task at any time to determine whether it has started running, ran to completion, was canceled, or has thrown an exception.</span></span> <span data-ttu-id="627df-131">Stav je reprezentována <xref:System.Threading.Tasks.TaskStatus> výčtu.</span><span class="sxs-lookup"><span data-stu-id="627df-131">The status is represented by a <xref:System.Threading.Tasks.TaskStatus> enumeration.</span></span>  
  
 <span data-ttu-id="627df-132">Když je vytvořena úloha, je jí zadán uživatelský delegát, jenž provádí zapouzdření kódu, který úloha provede.</span><span class="sxs-lookup"><span data-stu-id="627df-132">When you create a task, you give it a user delegate that encapsulates the code that the task will execute.</span></span> <span data-ttu-id="627df-133">Tento delegát může být vyjádřen jako pojmenovaný delegát, anonymní metoda nebo lambda výraz.</span><span class="sxs-lookup"><span data-stu-id="627df-133">The delegate can be expressed as a named delegate, an anonymous method, or a lambda expression.</span></span> <span data-ttu-id="627df-134">Lambda výrazy mohou obsahovat volání pojmenované metody, jak ukazuje následující příklad.</span><span class="sxs-lookup"><span data-stu-id="627df-134">Lambda expressions can contain a call to a named method, as shown in the following example.</span></span> <span data-ttu-id="627df-135">Všimněte si, že v příkladu obsahuje volání <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> metodou, jak zajistit, že úloha dokončí provádění před ukončením aplikace režimu konzoly.</span><span class="sxs-lookup"><span data-stu-id="627df-135">Note that the example includes a call to the <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> method to ensure that the task completes execution before the console mode application ends.</span></span>  
  
 [!code-csharp[TPL_TaskIntro#1](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_taskintro/cs/lambda1.cs#1)]
 [!code-vb[TPL_TaskIntro#1](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_taskintro/vb/lambda1.vb#1)]  
  
 <span data-ttu-id="627df-136">Můžete také <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> metody pro vytvoření a spuštění úlohy v rámci jedné operace.</span><span class="sxs-lookup"><span data-stu-id="627df-136">You can also use the <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> methods to create and start a task in one operation.</span></span> <span data-ttu-id="627df-137">Ke správě úlohy, <xref:System.Threading.Tasks.Task.Run%2A> metody použití výchozího plánovače úloh, bez ohledu na to, jaké úlohu plánovače souvisí s aktuální vlákno.</span><span class="sxs-lookup"><span data-stu-id="627df-137">To manage the task, the <xref:System.Threading.Tasks.Task.Run%2A> methods use the default  task scheduler, regardless of which task scheduler is associated with the current thread.</span></span> <span data-ttu-id="627df-138"><xref:System.Threading.Tasks.Task.Run%2A> Metody jsou upřednostňovaný způsob, jak vytvořit a spustit úlohy v případě, že není potřeba větší kontrolu nad vytvoření a plánování úloh.</span><span class="sxs-lookup"><span data-stu-id="627df-138">The <xref:System.Threading.Tasks.Task.Run%2A> methods are the preferred way to create and start tasks when more control over the creation and scheduling of the task is not needed.</span></span>  
  
 [!code-csharp[TPL_TaskIntro#2](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_taskintro/cs/run1.cs#2)]
 [!code-vb[TPL_TaskIntro#2](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_taskintro/vb/run1.vb#2)]  
  
 <span data-ttu-id="627df-139">Můžete také <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> metodu pro vytvoření a spuštění úlohy v rámci jedné operace.</span><span class="sxs-lookup"><span data-stu-id="627df-139">You can also use the <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> method to create and start a task in one operation.</span></span> <span data-ttu-id="627df-140">Tuto metodu použijte, když vytvoření a plánování nemusí být oddělené a chcete, aby možnosti vytvoření další úlohy nebo použijte konkrétní scheduleru, nebo když potřebujete předat další stav do úlohy prostřednictvím jeho <xref:System.Threading.Tasks.Task.AsyncState%2A> vlastnost, jak je znázorněno Následující příklad.</span><span class="sxs-lookup"><span data-stu-id="627df-140">Use this method when creation and scheduling do not have to be separated and you require additional task creation options or the use of a specific scheduler, or when you need to pass additional state into the task through its <xref:System.Threading.Tasks.Task.AsyncState%2A> property, as shown in the following example.</span></span>  
  
 [!code-csharp[TPL_TaskIntro#3](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_taskintro/cs/startnew1.cs#3)]
 [!code-vb[TPL_TaskIntro#3](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_taskintro/vb/startnew1.vb#3)]  
  
 <span data-ttu-id="627df-141"><xref:System.Threading.Tasks.Task> a <xref:System.Threading.Tasks.Task%601> každý vystavit statického <xref:System.Threading.Tasks.Task.Factory%2A> vlastnost, která vrací výchozí instanci <xref:System.Threading.Tasks.TaskFactory>, takže můžete volat metodu jako `Task.Factory.StartNew()`.</span><span class="sxs-lookup"><span data-stu-id="627df-141"><xref:System.Threading.Tasks.Task> and <xref:System.Threading.Tasks.Task%601> each expose a static <xref:System.Threading.Tasks.Task.Factory%2A> property that returns a default instance of <xref:System.Threading.Tasks.TaskFactory>, so that you can call the method as `Task.Factory.StartNew()`.</span></span> <span data-ttu-id="627df-142">Také v následujícím příkladu protože úlohy jsou typu <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType>, každá má veřejné <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> vlastnost, která obsahuje výsledek výpočet.</span><span class="sxs-lookup"><span data-stu-id="627df-142">Also, in the following example, because the tasks are of type <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType>, they each have a public <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> property that contains the result of the computation.</span></span> <span data-ttu-id="627df-143">Úlohy běží asynchronně a mohou být dokončeny v libovolném pořadí.</span><span class="sxs-lookup"><span data-stu-id="627df-143">The tasks run asynchronously and may complete in any order.</span></span> <span data-ttu-id="627df-144">Pokud <xref:System.Threading.Tasks.Task%601.Result%2A> vlastnost přistupuje předtím, než se dokončí výpočet, vlastnost blokuje volající vlákno, dokud nebude k dispozici hodnota.</span><span class="sxs-lookup"><span data-stu-id="627df-144">If the <xref:System.Threading.Tasks.Task%601.Result%2A> property is accessed before the computation finishes, the property blocks the calling thread until the value is available.</span></span>  
  
 [!code-csharp[TPL_TaskIntro#4](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_taskintro/cs/result1.cs#4)]
 [!code-vb[TPL_TaskIntro#4](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_taskintro/vb/result1.vb#4)]  
  
 <span data-ttu-id="627df-145">Další informace najdete v tématu [postupy: vrácení hodnoty z úlohy](../../../docs/standard/parallel-programming/how-to-return-a-value-from-a-task.md).</span><span class="sxs-lookup"><span data-stu-id="627df-145">For more information, see [How to: Return a Value from a Task](../../../docs/standard/parallel-programming/how-to-return-a-value-from-a-task.md).</span></span>  
  
 <span data-ttu-id="627df-146">Při použití lambda výrazu k vytvoření delegáta máte přístup ke všem proměnným, které jsou v daném okamžiku viditelné ve zdrojovém kódu.</span><span class="sxs-lookup"><span data-stu-id="627df-146">When you use a lambda expression to create a delegate, you have access to all the variables that are visible at that point in your source code.</span></span> <span data-ttu-id="627df-147">V některých případech, zejména v rámci smyčky, však lambda nezachytí proměnnou podle očekávání.</span><span class="sxs-lookup"><span data-stu-id="627df-147">However, in some cases, most notably within loops, a lambda doesn't capture the variable as expected.</span></span> <span data-ttu-id="627df-148">Pouze zachycuje konečnou hodnotu, nikoli mutaci hodnoty po každé iteraci.</span><span class="sxs-lookup"><span data-stu-id="627df-148">It only captures the final value, not the value as it mutates after each iteration.</span></span> <span data-ttu-id="627df-149">Následující příklad ukazuje tento problém.</span><span class="sxs-lookup"><span data-stu-id="627df-149">The following example illustrates the problem.</span></span> <span data-ttu-id="627df-150">Pak předá smyčku čítač výrazu lambda, která vytvoří `CustomData` objektu a používá čítač smyčky jako identifikátor objektu.</span><span class="sxs-lookup"><span data-stu-id="627df-150">It passes a loop counter to a lambda expression that instantiates a `CustomData` object and uses the loop counter as the object's identifier.</span></span> <span data-ttu-id="627df-151">Jako výstup z příkladu znázorňuje všechny `CustomData` objekt má stejné identifikátor.</span><span class="sxs-lookup"><span data-stu-id="627df-151">As the output from the example shows, each `CustomData` object has an identical identifier.</span></span>  
  
 [!code-csharp[TPL_TaskIntro#22](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_taskintro/cs/iteration1b.cs#22)]
 [!code-vb[TPL_TaskIntro#22](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_taskintro/vb/iteration1b.vb#22)]  
  
 <span data-ttu-id="627df-152">K hodnotě v každé iteraci můžete přistupovat zadáním objektu stavu úlohy pomocí jeho konstruktoru.</span><span class="sxs-lookup"><span data-stu-id="627df-152">You can access the value on each iteration by providing a state object to a task through its constructor.</span></span> <span data-ttu-id="627df-153">Následující příklad změní předchozí příklad pomocí čítač smyčky při vytváření `CustomData` objekt, který je pak předaný výrazu lambda.</span><span class="sxs-lookup"><span data-stu-id="627df-153">The following example modifies the previous example by using the loop counter when creating the `CustomData` object, which, in turn, is passed to the lambda expression.</span></span>  <span data-ttu-id="627df-154">Jako výstup z příkladu znázorňuje všechny `CustomData` objekt teď má jedinečný identifikátor na základě hodnoty čítače smyčky v době byla vytvořena instance objektu.</span><span class="sxs-lookup"><span data-stu-id="627df-154">As the output from the example shows, each `CustomData` object now has a unique identifier based on the value of the loop counter at the time the object was instantiated.</span></span>  
  
 [!code-csharp[TPL_TaskIntro#21](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_taskintro/cs/iteration1a.cs#21)]
 [!code-vb[TPL_TaskIntro#21](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_taskintro/vb/iteration1a.vb#21)]  
  
 <span data-ttu-id="627df-155">Tento stav je předán jako argument delegáta úlohy a byla přístupná z objektu úlohy pomocí <xref:System.Threading.Tasks.Task.AsyncState%2A?displayProperty=nameWithType> vlastnost.</span><span class="sxs-lookup"><span data-stu-id="627df-155">This state is passed as an argument to the task delegate, and it can be accessed from the task object by using the <xref:System.Threading.Tasks.Task.AsyncState%2A?displayProperty=nameWithType> property.</span></span>  <span data-ttu-id="627df-156">Následující příklad je podobný předchozímu příkladu.</span><span class="sxs-lookup"><span data-stu-id="627df-156">The following example is a variation on the previous example.</span></span> <span data-ttu-id="627df-157">Použije <xref:System.Threading.Tasks.Task.AsyncState%2A> vlastnost pro zobrazení informací o `CustomData` objekty předaný výrazu lambda.</span><span class="sxs-lookup"><span data-stu-id="627df-157">It uses the <xref:System.Threading.Tasks.Task.AsyncState%2A> property to display information about the `CustomData` objects passed to the lambda expression.</span></span>  
  
 [!code-csharp[TPL_TaskIntro#23](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_taskintro/cs/asyncstate.cs#23)]
 [!code-vb[TPL_TaskIntro#23](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_taskintro/vb/asyncstate.vb#23)]  
  
## <a name="task-id"></a><span data-ttu-id="627df-158">ID úlohy</span><span class="sxs-lookup"><span data-stu-id="627df-158">Task ID</span></span>  
 <span data-ttu-id="627df-159">Každá úloha obdrží ID celé číslo, které jednoznačně identifikuje v doméně aplikace a je přístupný pomocí <xref:System.Threading.Tasks.Task.Id%2A?displayProperty=nameWithType> vlastnost.</span><span class="sxs-lookup"><span data-stu-id="627df-159">Every task receives an integer ID that uniquely identifies it in an application domain and can be accessed by using the <xref:System.Threading.Tasks.Task.Id%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="627df-160">ID je užitečné pro zobrazení informací o úkolu v ladicím programu sady Visual Studio **paralelní zásobníky** a **úlohy** systému windows.</span><span class="sxs-lookup"><span data-stu-id="627df-160">The ID is useful for viewing task information in the Visual Studio debugger **Parallel Stacks** and **Tasks** windows.</span></span> <span data-ttu-id="627df-161">ID využívá líné vytváření, což znamená, že není vytvořeno, dokud se o něj nepožádá, proto může mít úloha při každém spuštění programu jiné ID.</span><span class="sxs-lookup"><span data-stu-id="627df-161">The ID is lazily created, which means that it isn't created until it is requested; therefore, a task may have a different ID every time the program is run.</span></span> <span data-ttu-id="627df-162">Další informace o tom, jak zobrazit ID úkolu v ladicím programu najdete v tématu [používání okna úloh](/visualstudio/debugger/using-the-tasks-window) a [použití okna paralelní zásobníky](/visualstudio/debugger/using-the-parallel-stacks-window).</span><span class="sxs-lookup"><span data-stu-id="627df-162">For more information about how to view task IDs in the debugger, see [Using the Tasks Window](/visualstudio/debugger/using-the-tasks-window) and [Using the Parallel Stacks Window](/visualstudio/debugger/using-the-parallel-stacks-window).</span></span>  
  
## <a name="task-creation-options"></a><span data-ttu-id="627df-163">Možnosti vytvoření úlohy</span><span class="sxs-lookup"><span data-stu-id="627df-163">Task Creation Options</span></span>  
 <span data-ttu-id="627df-164">Většina rozhraní API, které vytvářejí úlohy poskytují přetížení, které přijímají <xref:System.Threading.Tasks.TaskCreationOptions> parametr.</span><span class="sxs-lookup"><span data-stu-id="627df-164">Most APIs that create tasks provide overloads that accept a <xref:System.Threading.Tasks.TaskCreationOptions> parameter.</span></span> <span data-ttu-id="627df-165">Zadáním jedné z těchto možností lze dát pokyn plánovači úloh, jak naplánovat úlohy ve fondu vláken.</span><span class="sxs-lookup"><span data-stu-id="627df-165">By specifying one of these options, you tell the task scheduler how to schedule the task on the thread pool.</span></span> <span data-ttu-id="627df-166">V následující tabulce jsou uvedeny různé možnosti pro vytváření úloh.</span><span class="sxs-lookup"><span data-stu-id="627df-166">The following table lists the various task creation options.</span></span>  
  
|<span data-ttu-id="627df-167"><xref:System.Threading.Tasks.TaskCreationOptions> Hodnota parametru</span><span class="sxs-lookup"><span data-stu-id="627df-167"><xref:System.Threading.Tasks.TaskCreationOptions> parameter value</span></span>|<span data-ttu-id="627df-168">Popis</span><span class="sxs-lookup"><span data-stu-id="627df-168">Description</span></span>|  
|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-----------------|  
|<xref:System.Threading.Tasks.TaskCreationOptions.None>|<span data-ttu-id="627df-169">Výchozí hodnota, pokud není zadána jiná.</span><span class="sxs-lookup"><span data-stu-id="627df-169">The default when no option is specified.</span></span> <span data-ttu-id="627df-170">Plánovač používá k plánování úlohy své výchozí heuristické metody.</span><span class="sxs-lookup"><span data-stu-id="627df-170">The scheduler uses its default heuristics to schedule the task.</span></span>|  
|<xref:System.Threading.Tasks.TaskCreationOptions.PreferFairness>|<span data-ttu-id="627df-171">Určuje, že úlohy by měly být naplánovány tak, aby se úlohy vytvořené dříve pravděpodobně prováděly dříve a později vytvořené úlohy aby se s větší pravděpodobností prováděly později.</span><span class="sxs-lookup"><span data-stu-id="627df-171">Specifies that the task should be scheduled so that tasks created sooner will be more likely to be executed sooner, and tasks created later will be more likely to execute later.</span></span>|  
|<xref:System.Threading.Tasks.TaskCreationOptions.LongRunning>|<span data-ttu-id="627df-172">Určuje, že úloha představuje dlouhotrvající operaci.</span><span class="sxs-lookup"><span data-stu-id="627df-172">Specifies that the task represents a long-running operation.</span></span>|  
|<xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent>|<span data-ttu-id="627df-173">Určuje, že úloha by měla být vytvořena jako připojená podřízená úloha aktuální úlohy, pokud existuje.</span><span class="sxs-lookup"><span data-stu-id="627df-173">Specifies that a task should be created as an attached child of the current task, if one exists.</span></span> <span data-ttu-id="627df-174">Další informace najdete v tématu [připojené a odpojené podřízené úlohy](../../../docs/standard/parallel-programming/attached-and-detached-child-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="627df-174">For more information, see [Attached and Detached Child Tasks](../../../docs/standard/parallel-programming/attached-and-detached-child-tasks.md).</span></span>|  
|<xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach>|<span data-ttu-id="627df-175">Určuje, že pokud určuje vnitřní úloh `AttachedToParent` možnost této úlohy se stává připojené podřízené úlohy.</span><span class="sxs-lookup"><span data-stu-id="627df-175">Specifies that if an inner task specifies the `AttachedToParent` option, that task will not become an attached child task.</span></span>|  
|<xref:System.Threading.Tasks.TaskCreationOptions.HideScheduler>|<span data-ttu-id="627df-176">Určuje, že Plánovač úloh pro úlohy vytvořen při volání metody, třeba <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> nebo <xref:System.Threading.Tasks.Task%601.ContinueWith%2A?displayProperty=nameWithType> uvnitř určitý úkol je scheduler výchozí místo scheduler, na kterém je tato úloha spuštěna.</span><span class="sxs-lookup"><span data-stu-id="627df-176">Specifies that the task scheduler for tasks created by calling methods like <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> or <xref:System.Threading.Tasks.Task%601.ContinueWith%2A?displayProperty=nameWithType> from within a particular task is the default scheduler instead of the scheduler on which this task is running.</span></span>|  
  
 <span data-ttu-id="627df-177">Možnosti mohou být kombinovány s použitím bitové **nebo** operaci.</span><span class="sxs-lookup"><span data-stu-id="627df-177">The options may be combined by using a bitwise **OR** operation.</span></span> <span data-ttu-id="627df-178">Následující příklad ukazuje úkol, který má <xref:System.Threading.Tasks.TaskCreationOptions.LongRunning> a <xref:System.Threading.Tasks.TaskContinuationOptions.PreferFairness> možnost.</span><span class="sxs-lookup"><span data-stu-id="627df-178">The following example shows a task that has the <xref:System.Threading.Tasks.TaskCreationOptions.LongRunning> and <xref:System.Threading.Tasks.TaskContinuationOptions.PreferFairness> option.</span></span>  
  
 [!code-csharp[TPL_TaskIntro#03](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_taskintro/cs/taskintro.cs#03)]
 [!code-vb[TPL_TaskIntro#03](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_taskintro/vb/tpl_intro.vb#03)]  
  
## <a name="tasks-threads-and-culture"></a><span data-ttu-id="627df-179">Úlohy, vláken a kultury</span><span class="sxs-lookup"><span data-stu-id="627df-179">Tasks, threads, and culture</span></span>  
 <span data-ttu-id="627df-180">Každé vlákno má přidružené jazykovou verzi a jazyková verze uživatelského rozhraní, který je definovaný <xref:System.Threading.Thread.CurrentCulture%2A?displayProperty=nameWithType> a <xref:System.Threading.Thread.CurrentUICulture%2A?displayProperty=nameWithType> vlastnosti, v uvedeném pořadí.</span><span class="sxs-lookup"><span data-stu-id="627df-180">Each thread has an associated culture and UI culture, which is defined by the <xref:System.Threading.Thread.CurrentCulture%2A?displayProperty=nameWithType> and <xref:System.Threading.Thread.CurrentUICulture%2A?displayProperty=nameWithType> properties, respectively.</span></span> <span data-ttu-id="627df-181">Jazykovou verzi vlákna se používá v těchto operací jako formátování, analýza, řazení a porovnání řetězců.</span><span class="sxs-lookup"><span data-stu-id="627df-181">A thread's culture is used in such operations as formatting, parsing, sorting, and string comparison.</span></span> <span data-ttu-id="627df-182">Jazyková verze uživatelského rozhraní vlákno se používá v vyhledávání prostředků.</span><span class="sxs-lookup"><span data-stu-id="627df-182">A thread's UI culture is used in resource lookup.</span></span> <span data-ttu-id="627df-183">Normálně Pokud nezadáte výchozí jazykovou verzi pro všechna vlákna v doméně aplikace pomocí <xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A?displayProperty=nameWithType> a <xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A?displayProperty=nameWithType> vlastnosti, výchozí jazykovou verzi a jazyková verze uživatelského rozhraní vlákna je definována systémovou kulturu.</span><span class="sxs-lookup"><span data-stu-id="627df-183">Ordinarily, unless you specify a default culture for all the threads in an application domain by using the <xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A?displayProperty=nameWithType> and <xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A?displayProperty=nameWithType> properties, the default culture and UI culture of a thread is defined by the system culture.</span></span> <span data-ttu-id="627df-184">Pokud explicitně nastavit jazykovou verzi vlákna a spustit nové vlákno, nové vlákno nedědí jazykovou verzi volající vlákno; Místo toho jeho jazyková verze je výchozí jazykovou verzi systému.</span><span class="sxs-lookup"><span data-stu-id="627df-184">If you explicitly set a thread's culture and launch a new thread, the new thread does not inherit the culture of the calling thread; instead, its culture is the default system culture.</span></span> <span data-ttu-id="627df-185">Programovací model pro aplikace, které cílové verze rozhraní .NET Framework před založený na úlohách [!INCLUDE[net_v46](../../../includes/net-v46-md.md)] řídit tento postup.</span><span class="sxs-lookup"><span data-stu-id="627df-185">The task-based programming model for apps that target versions of the .NET Framework prior to [!INCLUDE[net_v46](../../../includes/net-v46-md.md)] adhere to this practice.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="627df-186">Všimněte si, že volající vlákno jazykové verzi v rámci úkolu kontextu se vztahují na aplikace, *cíl* [!INCLUDE[net_v46](../../../includes/net-v46-md.md)], není aplikace, *běh* [!INCLUDE[net_v46](../../../includes/net-v46-md.md)].</span><span class="sxs-lookup"><span data-stu-id="627df-186">Note that the calling thread's culture as part of a task's context applies to apps that *target* the [!INCLUDE[net_v46](../../../includes/net-v46-md.md)], not apps that *run under* the [!INCLUDE[net_v46](../../../includes/net-v46-md.md)].</span></span> <span data-ttu-id="627df-187">Při vytváření projektu v sadě Visual Studio vyberte z rozevíracího seznamu v horní části této verze, můžete vybrat konkrétní verzi rozhraní .NET Framework **nový projekt** dialogové okno, nebo mimo ni Visual Studio můžete použít <xref:System.Runtime.Versioning.TargetFrameworkAttribute> atribut.</span><span class="sxs-lookup"><span data-stu-id="627df-187">You can target a particular version of the .NET Framework when you create your project in Visual Studio by selecting that version from the dropdown list at the top of the **New Project** dialog box, or outside of Visual Studio you can use the <xref:System.Runtime.Versioning.TargetFrameworkAttribute> attribute.</span></span> <span data-ttu-id="627df-188">Pro aplikace, které cílové verze rozhraní .NET Framework před verzí [!INCLUDE[net_v46](../../../includes/net-v46-md.md)], nebo který cílit na konkrétní verzi rozhraní .NET Framework, bude určen jazykovou verzi vlákna, ve kterém běží pokračuje úkolu jazykovou verzi.</span><span class="sxs-lookup"><span data-stu-id="627df-188">For apps that target versions of the .NET Framework prior to the [!INCLUDE[net_v46](../../../includes/net-v46-md.md)], or that do not target a specific version of the .NET Framework, a task's culture continues to be determined by the culture of the thread on which it runs.</span></span>  
  
 <span data-ttu-id="627df-189">Počínaje aplikací cílených [!INCLUDE[net_v46](../../../includes/net-v46-md.md)], zdědí jazykovou verzi volající vlákno každý úkol, i když tato úloha se spustí asynchronně na vlákno fondu vláken.</span><span class="sxs-lookup"><span data-stu-id="627df-189">Starting with apps that target the [!INCLUDE[net_v46](../../../includes/net-v46-md.md)], the calling thread's culture is inherited by each task, even if the task runs asynchronously on a thread pool thread.</span></span>  
  
 <span data-ttu-id="627df-190">Následující příklad uvádí jednoduchý obrázek.</span><span class="sxs-lookup"><span data-stu-id="627df-190">The following example provides a simple illustration.</span></span> <span data-ttu-id="627df-191">Použije <xref:System.Runtime.Versioning.TargetFrameworkAttribute> atribut target [!INCLUDE[net_v46](../../../includes/net-v46-md.md)] a mění aktuální jazykovou verzi aplikace buď francouzština (Francie), nebo pokud francouzština (Francie) je již aktuální jazykové verze Angličtina (Spojené státy).</span><span class="sxs-lookup"><span data-stu-id="627df-191">It uses the <xref:System.Runtime.Versioning.TargetFrameworkAttribute> attribute to target the [!INCLUDE[net_v46](../../../includes/net-v46-md.md)] and changes the app's current culture to either French (France) or, if French (France) is already the current culture, English (United States).</span></span> <span data-ttu-id="627df-192">Poté vyvolá delegáta s názvem `formatDelegate` , který vrací čísla formátovaná jako hodnoty měny v nové jazykové verze.</span><span class="sxs-lookup"><span data-stu-id="627df-192">It then invokes a delegate named `formatDelegate` that returns some numbers formatted as currency values in the new culture.</span></span> <span data-ttu-id="627df-193">Všimněte si, že zda delegát jako úlohu synchronně nebo asynchronně, vrátí očekávaný výsledek protože jazykovou verzi volající vlákno je zdědí asynchronní úlohu.</span><span class="sxs-lookup"><span data-stu-id="627df-193">Note that whether the delegate as a task either synchronously or asynchronously, it returns the expected result because the culture of the calling thread is inherited by the asynchronous task.</span></span>  
  
 [!code-csharp[System.Globalization.CultureInfo.Class.Async#5](../../../samples/snippets/csharp/VS_Snippets_CLR_System/system.globalization.cultureinfo.class.async/cs/asyncculture1.cs#5)]
 [!code-vb[System.Globalization.CultureInfo.Class.Async#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR_System/system.globalization.cultureinfo.class.async/vb/asyncculture1.vb#5)]  
  
 <span data-ttu-id="627df-194">Pokud používáte Visual Studio, můžete vynechat <xref:System.Runtime.Versioning.TargetFrameworkAttribute> atribut a místo toho vyberte rozhraní .NET Framework 4.6 jako cíl, když vytvoříte projekt v **nový projekt** dialogové okno.</span><span class="sxs-lookup"><span data-stu-id="627df-194">If you are using Visual Studio, you can omit the <xref:System.Runtime.Versioning.TargetFrameworkAttribute> attribute and instead select the .NET Framework 4.6 as the target when you create the project in the **New Project** dialog.</span></span>  
  
 <span data-ttu-id="627df-195">Pro výstup, která odráží chování aplikací cílové verze rozhraní .NET Framework před [!INCLUDE[net_v46](../../../includes/net-v46-md.md)], odeberte <xref:System.Runtime.Versioning.TargetFrameworkAttribute> atribut ze zdrojového kódu.</span><span class="sxs-lookup"><span data-stu-id="627df-195">For output that reflects the behavior of apps the target versions of the .NET Framework prior to [!INCLUDE[net_v46](../../../includes/net-v46-md.md)], remove the <xref:System.Runtime.Versioning.TargetFrameworkAttribute> attribute from the source code.</span></span> <span data-ttu-id="627df-196">Výstup bude odrážet konvencí formátování výchozí systémovou kulturu, není jazyková verze volající vlákno.</span><span class="sxs-lookup"><span data-stu-id="627df-196">The output will reflect the formatting conventions of the default system culture, not the culture of the calling thread.</span></span>  
  
 <span data-ttu-id="627df-197">Další informace o asynchronních úloh a jazykovou verzi, najdete v části "Jazyková verze a asynchronní operace založené na úlohách" v <xref:System.Globalization.CultureInfo> tématu.</span><span class="sxs-lookup"><span data-stu-id="627df-197">For more information on asynchronous tasks and culture, see the "Culture and asynchronous task-based operations" section in the <xref:System.Globalization.CultureInfo> topic.</span></span>  
  
## <a name="creating-task-continuations"></a><span data-ttu-id="627df-198">Vytváření pokračování úlohy</span><span class="sxs-lookup"><span data-stu-id="627df-198">Creating task continuations</span></span>  
 <span data-ttu-id="627df-199"><xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType> a <xref:System.Threading.Tasks.Task%601.ContinueWith%2A?displayProperty=nameWithType> metody umožňují zadat při spuštění úlohy *předchozí úlohou* dokončí.</span><span class="sxs-lookup"><span data-stu-id="627df-199">The <xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType> and <xref:System.Threading.Tasks.Task%601.ContinueWith%2A?displayProperty=nameWithType> methods let you specify a task to start when the *antecedent task* finishes.</span></span> <span data-ttu-id="627df-200">Delegát úkolů pokračování je předán odkaz na předchozí úlohou tak, aby mohl zkontrolovat stav předchozí úlohou a při získávání hodnoty <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> vlastnost, můžete použít výstup předchůdce jako vstup pro pokračování.</span><span class="sxs-lookup"><span data-stu-id="627df-200">The delegate of the continuation task is passed a reference to the antecedent task so that it can examine the antecedent task's status and, by retrieving the value of the <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> property, can use the output of the antecedent as input for the continuation.</span></span>  
  
 <span data-ttu-id="627df-201">V následujícím příkladu `getData` úloha je spuštěna voláním <xref:System.Threading.Tasks.TaskFactory.StartNew%60%601%28System.Func%7B%60%600%7D%29?displayProperty=nameWithType> metoda.</span><span class="sxs-lookup"><span data-stu-id="627df-201">In the following example, the `getData` task is started by a call to the <xref:System.Threading.Tasks.TaskFactory.StartNew%60%601%28System.Func%7B%60%600%7D%29?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="627df-202">`processData` Úloha je spuštěna automaticky při `getData` dokončí, a `displayData` při spuštění `processData` dokončí.</span><span class="sxs-lookup"><span data-stu-id="627df-202">The `processData` task is started automatically when `getData` finishes, and `displayData` is started when `processData` finishes.</span></span> <span data-ttu-id="627df-203">`getData` Vytvoří celočíselné pole, která je přístupná `processData` úkolů prostřednictvím `getData` úkolu <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> vlastnost.</span><span class="sxs-lookup"><span data-stu-id="627df-203">`getData` produces an integer array, which is accessible to the `processData` task through the `getData` task's <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="627df-204">`processData` Úloh zpracovává tohoto pole a vrátí výsledek, jehož typ je odvozen z návratový typ výrazu lambda předaný <xref:System.Threading.Tasks.Task%601.ContinueWith%60%601%28System.Func%7BSystem.Threading.Tasks.Task%7B%600%7D%2C%60%600%7D%29?displayProperty=nameWithType> metoda.</span><span class="sxs-lookup"><span data-stu-id="627df-204">The `processData` task processes that array and returns a result whose type is inferred from the return type of the lambda expression passed to the <xref:System.Threading.Tasks.Task%601.ContinueWith%60%601%28System.Func%7BSystem.Threading.Tasks.Task%7B%600%7D%2C%60%600%7D%29?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="627df-205">`displayData` Úloha se spustí automaticky při `processData` dokončí a <xref:System.Tuple%603> objekt vrácený `processData` výrazu lambda je přístupné `displayData` úlohy prostřednictvím `processData` úkolu <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> Vlastnost.</span><span class="sxs-lookup"><span data-stu-id="627df-205">The `displayData` task executes automatically when `processData` finishes, and the <xref:System.Tuple%603> object returned by the `processData` lambda expression is accessible to the `displayData` task through the `processData` task's <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="627df-206">`displayData` Úloh trvá výsledek `processData` úkolů a vytváří výsledek, jejichž typ je odvozen podobným způsobem a který je k dispozici v programu <xref:System.Threading.Tasks.Task%601.Result%2A> vlastnost.</span><span class="sxs-lookup"><span data-stu-id="627df-206">The `displayData` task takes the result of the `processData` task and produces a result whose type is inferred in a similar manner and which is made available to the program in the <xref:System.Threading.Tasks.Task%601.Result%2A> property.</span></span>  
  
 [!code-csharp[TPL_TaskIntro#5](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_taskintro/cs/continuations1.cs#5)]
 [!code-vb[TPL_TaskIntro#5](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_taskintro/vb/continuations1.vb#5)]  
  
 <span data-ttu-id="627df-207">Protože <xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType> je metoda instance, můžete řetězu volání metod společně, namísto vytváření instancí <xref:System.Threading.Tasks.Task%601> objekt pro každý předchozí úlohou.</span><span class="sxs-lookup"><span data-stu-id="627df-207">Because <xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType> is an instance method, you can chain method calls together instead of instantiating a <xref:System.Threading.Tasks.Task%601> object for each antecedent task.</span></span> <span data-ttu-id="627df-208">Následující příklad je funkčně stejný jako předchozí příklad, s tím rozdílem, že zřetězený společně volání <xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType> metoda.</span><span class="sxs-lookup"><span data-stu-id="627df-208">The following example is functionally identical to the previous example, except that it chains together calls to the <xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="627df-209">Všimněte si, že <xref:System.Threading.Tasks.Task%601> objekt vrácený řetězec volání metod je úloha konečné pokračování.</span><span class="sxs-lookup"><span data-stu-id="627df-209">Note that the <xref:System.Threading.Tasks.Task%601> object returned by the chain of method calls is the final continuation task.</span></span>  
  
 [!code-csharp[TPL_TaskIntro#24](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_taskintro/cs/continuations2.cs#24)]
 [!code-vb[TPL_TaskIntro#24](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_taskintro/vb/continuations2.vb#24)]  
  
 <span data-ttu-id="627df-210"><xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A> a <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAny%2A> metody umožňují pokračovat z více úloh.</span><span class="sxs-lookup"><span data-stu-id="627df-210">The <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A> and <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAny%2A> methods enable you to continue from multiple tasks.</span></span>  
  
 <span data-ttu-id="627df-211">Další informace najdete v tématu [řetězení úloh pomocí úloh pokračování pomocí](../../../docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="627df-211">For more information, see [Chaining Tasks by Using Continuation Tasks](../../../docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md).</span></span>  
  
## <a name="creating-detached-child-tasks"></a><span data-ttu-id="627df-212">Vytváření odpojené podřízené úlohy</span><span class="sxs-lookup"><span data-stu-id="627df-212">Creating detached child tasks</span></span>  
 <span data-ttu-id="627df-213">Když uživatelský kód, který běží v úloze vytvoří novou úlohu a neurčuje <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent> možnost, Nová úloha není synchronizován s nadřazené úlohy žádným zvláštním způsobem.</span><span class="sxs-lookup"><span data-stu-id="627df-213">When user code that is running in a task creates a new task and does not specify the <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent> option, the new task is not synchronized with the parent task in any special way.</span></span> <span data-ttu-id="627df-214">Tento typ úlohy není synchronizována se nazývá *odpojit vnořené úlohy* nebo *odpojené podřízené úlohy*.</span><span class="sxs-lookup"><span data-stu-id="627df-214">This type of non-synchronized task is called a *detached nested task* or *detached child task*.</span></span> <span data-ttu-id="627df-215">Následující příklad zobrazuje úlohu, která vytváří jednu odpojenou podřízenou úlohu.</span><span class="sxs-lookup"><span data-stu-id="627df-215">The following example shows a task that creates one detached child task.</span></span>  
  
 [!code-csharp[TPL_TaskIntro#07](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_taskintro/cs/taskintro.cs#07)]
 [!code-vb[TPL_TaskIntro#07](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_taskintro/vb/tpl_intro.vb#07)]  
  
 <span data-ttu-id="627df-216">Nadřazená úloha nečeká na dokončení odpojené podřízené úlohy.</span><span class="sxs-lookup"><span data-stu-id="627df-216">Note that the parent task does not wait for the detached child task to finish.</span></span>  
  
## <a name="creating-child-tasks"></a><span data-ttu-id="627df-217">Vytvoření podřízené úlohy</span><span class="sxs-lookup"><span data-stu-id="627df-217">Creating child tasks</span></span>  
 <span data-ttu-id="627df-218">Když uživatelský kód, který běží v úloze vytvoří úlohu s <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent> možnost Nová úloha se označuje jako *podřízené úlohy připojený* nadřazeného úkolu.</span><span class="sxs-lookup"><span data-stu-id="627df-218">When user code that is running in a task creates a task with the <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent> option, the new task is known as a *attached child task* of the parent task.</span></span> <span data-ttu-id="627df-219">Můžete použít <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent> možnost k strukturovaného paralelismu úloh, protože nadřazená úloha implicitně čeká na dokončení všech úloh připojené podřízené.</span><span class="sxs-lookup"><span data-stu-id="627df-219">You can use the <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent> option to express structured task parallelism, because the parent task implicitly waits for all attached child tasks to finish.</span></span> <span data-ttu-id="627df-220">Následující příklad zobrazuje nadřazenou úlohu, která vytvoří deset připojených podřízených úloh.</span><span class="sxs-lookup"><span data-stu-id="627df-220">The following example shows a parent task that creates ten attached child tasks.</span></span> <span data-ttu-id="627df-221">Všimněte si, že i když se volá v příkladu <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> metoda čekání na dokončení úlohy nadřazené nemá explicitně čekat na dokončení úlohy připojený podřízené.</span><span class="sxs-lookup"><span data-stu-id="627df-221">Note that although the example calls the <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> method to wait for the parent task to finish, it does not have to explicitly wait for the attached child tasks to complete.</span></span>  
  
 [!code-csharp[TPL_TaskIntro#8](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_taskintro/cs/child1.cs#8)]
 [!code-vb[TPL_TaskIntro#8](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_taskintro/vb/child1.vb#8)]  
  
 <span data-ttu-id="627df-222">Nadřazené úloh můžete použít <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType> možnost zabránění připojení do nadřazené úlohy další úlohy.</span><span class="sxs-lookup"><span data-stu-id="627df-222">A parent task can use the <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType> option to prevent other tasks from attaching to the parent task.</span></span> <span data-ttu-id="627df-223">Další informace najdete v tématu [připojené a odpojené podřízené úlohy](../../../docs/standard/parallel-programming/attached-and-detached-child-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="627df-223">For more information, see [Attached and Detached Child Tasks](../../../docs/standard/parallel-programming/attached-and-detached-child-tasks.md).</span></span>  
  
## <a name="waiting-for-tasks-to-finish"></a><span data-ttu-id="627df-224">Čekání na dokončení úkolů</span><span class="sxs-lookup"><span data-stu-id="627df-224">Waiting for tasks to finish</span></span>  
 <span data-ttu-id="627df-225"><xref:System.Threading.Tasks.Task?displayProperty=nameWithType> a <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> typy poskytují několik přetížení <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> a <!--zz <xref:System.Threading.Tasks.Task%601.Wait%2A?displayProperty=nameWithType>--> `System.Threading.Tasks.Task.Wait` metody, které vám umožní počkejte na dokončení úlohy.</span><span class="sxs-lookup"><span data-stu-id="627df-225">The <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> and <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> types provide several overloads of the <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> and        <!--zz <xref:System.Threading.Tasks.Task%601.Wait%2A?displayProperty=nameWithType>--> `System.Threading.Tasks.Task.Wait` methods that enable you to wait for a task to finish.</span></span> <span data-ttu-id="627df-226">Kromě toho přetížení statické <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> a <xref:System.Threading.Tasks.Task.WaitAny%2A?displayProperty=nameWithType> metody umožňují čekat některá nebo všechna pole na dokončení úkolů.</span><span class="sxs-lookup"><span data-stu-id="627df-226">In addition, overloads of the static <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> and <xref:System.Threading.Tasks.Task.WaitAny%2A?displayProperty=nameWithType> methods let you wait for any or all of an array of tasks to finish.</span></span>  
  
 <span data-ttu-id="627df-227">Obvykle se na úlohu čeká z některého z těchto důvodů:</span><span class="sxs-lookup"><span data-stu-id="627df-227">Typically, you would wait for a task for one of these reasons:</span></span>  
  
-   <span data-ttu-id="627df-228">Hlavní vlákno závisí na konečném výsledku vypočítaném úlohou.</span><span class="sxs-lookup"><span data-stu-id="627df-228">The main thread depends on the final result computed by a task.</span></span>  
  
-   <span data-ttu-id="627df-229">Je potřeba zpracovat výjimky, které mohou být vyvolány z úlohy.</span><span class="sxs-lookup"><span data-stu-id="627df-229">You have to handle exceptions that might be thrown from the task.</span></span>  
  
-   <span data-ttu-id="627df-230">Aplikace se může ukončit předtím, než se dokončí všechny úlohy.</span><span class="sxs-lookup"><span data-stu-id="627df-230">The application may terminate before all tasks have completed execution.</span></span> <span data-ttu-id="627df-231">Například konzolové aplikace se ukončí co nejdříve veškerých synchronních kód v `Main` provedlo (vstupní bod aplikace).</span><span class="sxs-lookup"><span data-stu-id="627df-231">For example, console applications will terminate as soon as all synchronous code in `Main` (the application entry point) has executed.</span></span>  
  
 <span data-ttu-id="627df-232">Následující příklad zobrazuje základní vzor, který nezahrnuje zpracování výjimek.</span><span class="sxs-lookup"><span data-stu-id="627df-232">The following example shows the basic pattern that does not involve exception handling.</span></span>  
  
 [!code-csharp[TPL_TaskIntro#06](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_taskintro/cs/taskintro.cs#06)]
 [!code-vb[TPL_TaskIntro#06](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_taskintro/vb/tpl_intro.vb#06)]  
  
 <span data-ttu-id="627df-233">Příklad, který ukazuje výjimek, naleznete v části [zpracování výjimek](../../../docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span><span class="sxs-lookup"><span data-stu-id="627df-233">For an example that shows exception handling, see [Exception Handling](../../../docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span></span>  
  
 <span data-ttu-id="627df-234">Některé přetížení umožňují zadat časový limit a jiné přijímají další <xref:System.Threading.CancellationToken> jako vstupní parametr, tak, aby mohlo být samotné čekání zrušeno buď programově, nebo jako odpověď na uživatelský vstup.</span><span class="sxs-lookup"><span data-stu-id="627df-234">Some overloads let you specify a time-out, and others take an additional <xref:System.Threading.CancellationToken> as an input parameter, so that the wait itself can be canceled either programmatically or in response to user input.</span></span>  
  
 <span data-ttu-id="627df-235">Když čekat úlohy je implicitně počkat všechny podřízené dané úlohy, které byly vytvořeny pomocí <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent?displayProperty=nameWithType> možnost.</span><span class="sxs-lookup"><span data-stu-id="627df-235">When you wait for a task, you implicitly wait for all children of that task that were created by using the <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent?displayProperty=nameWithType> option.</span></span> <span data-ttu-id="627df-236"><xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> Vrátí okamžitě, pokud je úloha je dokončeno.</span><span class="sxs-lookup"><span data-stu-id="627df-236"><xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> returns immediately if the task has already completed.</span></span> <span data-ttu-id="627df-237">Jakékoli výjimky vyvolané úloha bude vyvolané <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> metoda, i když <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> metoda byla volána po dokončení úlohy.</span><span class="sxs-lookup"><span data-stu-id="627df-237">Any exceptions raised by a task will be thrown by a <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> method, even if the <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> method was called after the task completed.</span></span>  
  
## <a name="composing-tasks"></a><span data-ttu-id="627df-238">Skládání úlohy</span><span class="sxs-lookup"><span data-stu-id="627df-238">Composing tasks</span></span>  
 <span data-ttu-id="627df-239"><xref:System.Threading.Tasks.Task> a <xref:System.Threading.Tasks.Task%601> tříd poskytuje několik metod, které vám mohou pomoci vytvořit více úloh k implementaci běžných vzorů a lepší využití asynchronní jazykové funkce, které jsou k dispozici C#, Visual Basic a F #.</span><span class="sxs-lookup"><span data-stu-id="627df-239">The <xref:System.Threading.Tasks.Task> and <xref:System.Threading.Tasks.Task%601> classes provide several methods that can help you compose multiple tasks to implement common patterns and to better use the asynchronous language features that are provided by C#, Visual Basic, and F#.</span></span> <span data-ttu-id="627df-240">Tato část popisuje <xref:System.Threading.Tasks.Task.WhenAll%2A>, <xref:System.Threading.Tasks.Task.WhenAny%2A>, <xref:System.Threading.Tasks.Task.Delay%2A>, a <xref:System.Threading.Tasks.Task.FromResult%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="627df-240">This section describes the <xref:System.Threading.Tasks.Task.WhenAll%2A>, <xref:System.Threading.Tasks.Task.WhenAny%2A>, <xref:System.Threading.Tasks.Task.Delay%2A>, and <xref:System.Threading.Tasks.Task.FromResult%2A> methods.</span></span>  
  
### <a name="taskwhenall"></a><span data-ttu-id="627df-241">Task.WhenAll</span><span class="sxs-lookup"><span data-stu-id="627df-241">Task.WhenAll</span></span>  
 <span data-ttu-id="627df-242"><xref:System.Threading.Tasks.Task.WhenAll%2A?displayProperty=nameWithType> Metoda asynchronně čeká více <xref:System.Threading.Tasks.Task> nebo <xref:System.Threading.Tasks.Task%601> objekty, které chcete dokončit.</span><span class="sxs-lookup"><span data-stu-id="627df-242">The <xref:System.Threading.Tasks.Task.WhenAll%2A?displayProperty=nameWithType> method asynchronously waits for multiple <xref:System.Threading.Tasks.Task> or <xref:System.Threading.Tasks.Task%601> objects to finish.</span></span> <span data-ttu-id="627df-243">Poskytuje přetížené verze, které umožňují čekání na nerovnoměrné sady úloh.</span><span class="sxs-lookup"><span data-stu-id="627df-243">It provides overloaded versions that enable you to wait for non-uniform sets of tasks.</span></span> <span data-ttu-id="627df-244">Například můžete počkat několik <xref:System.Threading.Tasks.Task> a <xref:System.Threading.Tasks.Task%601> objekty k dokončení z volání jednu metodu.</span><span class="sxs-lookup"><span data-stu-id="627df-244">For example, you can wait for multiple <xref:System.Threading.Tasks.Task> and <xref:System.Threading.Tasks.Task%601> objects to complete from one method call.</span></span>  
  
### <a name="taskwhenany"></a><span data-ttu-id="627df-245">Task.WhenAny</span><span class="sxs-lookup"><span data-stu-id="627df-245">Task.WhenAny</span></span>  
 <span data-ttu-id="627df-246"><xref:System.Threading.Tasks.Task.WhenAny%2A?displayProperty=nameWithType> Metoda asynchronně čeká na jednu více <xref:System.Threading.Tasks.Task> nebo <xref:System.Threading.Tasks.Task%601> objekty, které chcete dokončit.</span><span class="sxs-lookup"><span data-stu-id="627df-246">The <xref:System.Threading.Tasks.Task.WhenAny%2A?displayProperty=nameWithType> method asynchronously waits for one of multiple <xref:System.Threading.Tasks.Task> or <xref:System.Threading.Tasks.Task%601> objects to finish.</span></span> <span data-ttu-id="627df-247">Stejně jako na <xref:System.Threading.Tasks.Task.WhenAll%2A?displayProperty=nameWithType> metoda, tato metoda poskytuje přetížené verze, které vám umožní počkejte neuniformní sady úlohy.</span><span class="sxs-lookup"><span data-stu-id="627df-247">As in the <xref:System.Threading.Tasks.Task.WhenAll%2A?displayProperty=nameWithType> method, this method provides overloaded versions that enable you to wait for non-uniform sets of tasks.</span></span> <span data-ttu-id="627df-248"><xref:System.Threading.Tasks.Task.WhenAny%2A> Metoda je užitečná zejména v následujících scénářích.</span><span class="sxs-lookup"><span data-stu-id="627df-248">The <xref:System.Threading.Tasks.Task.WhenAny%2A> method is especially useful in the following scenarios.</span></span>  
  
-   <span data-ttu-id="627df-249">Nadbytečné operace.</span><span class="sxs-lookup"><span data-stu-id="627df-249">Redundant operations.</span></span> <span data-ttu-id="627df-250">Zvažte algoritmus nebo operaci, které lze provést mnoha způsoby.</span><span class="sxs-lookup"><span data-stu-id="627df-250">Consider an algorithm or operation that can be performed in many ways.</span></span> <span data-ttu-id="627df-251">Můžete použít <xref:System.Threading.Tasks.Task.WhenAny%2A> metoda vyberte operaci, nejprve dokončí a poté zrušte zbývajících operací.</span><span class="sxs-lookup"><span data-stu-id="627df-251">You can use the <xref:System.Threading.Tasks.Task.WhenAny%2A> method to select the operation that finishes first and then cancel the remaining operations.</span></span>  
  
-   <span data-ttu-id="627df-252">Prokládané operace.</span><span class="sxs-lookup"><span data-stu-id="627df-252">Interleaved operations.</span></span> <span data-ttu-id="627df-253">Můžete spustit více operací, které musíte dokončit všechny a použít <xref:System.Threading.Tasks.Task.WhenAny%2A> metoda zpracovat výsledky, protože dokončení jednotlivých operací.</span><span class="sxs-lookup"><span data-stu-id="627df-253">You can start multiple operations that must all finish and use the <xref:System.Threading.Tasks.Task.WhenAny%2A> method to process results as each operation finishes.</span></span> <span data-ttu-id="627df-254">Po dokončení jedné operace můžete spustit jednu nebo více dalších úloh.</span><span class="sxs-lookup"><span data-stu-id="627df-254">After one operation finishes, you can start one or more additional tasks.</span></span>  
  
-   <span data-ttu-id="627df-255">Omezené operace.</span><span class="sxs-lookup"><span data-stu-id="627df-255">Throttled operations.</span></span> <span data-ttu-id="627df-256">Můžete použít <xref:System.Threading.Tasks.Task.WhenAny%2A> metodu pro předchozí scénář rozšířit tak, že omezí počet souběžných operací.</span><span class="sxs-lookup"><span data-stu-id="627df-256">You can use the <xref:System.Threading.Tasks.Task.WhenAny%2A> method to extend the previous scenario by limiting the number of concurrent operations.</span></span>  
  
-   <span data-ttu-id="627df-257">Operace, jejichž platnost vypršela.</span><span class="sxs-lookup"><span data-stu-id="627df-257">Expired operations.</span></span> <span data-ttu-id="627df-258">Můžete použít <xref:System.Threading.Tasks.Task.WhenAny%2A> metoda můžete vybrat, jestli jeden nebo více úloh a úlohu, která se dokončí po určitý čas, jako je například úlohu, která je vrácena <xref:System.Threading.Tasks.Task.Delay%2A> metoda.</span><span class="sxs-lookup"><span data-stu-id="627df-258">You can use the <xref:System.Threading.Tasks.Task.WhenAny%2A> method to select between one or more tasks and a task that finishes after a specific time, such as a task that is returned by the <xref:System.Threading.Tasks.Task.Delay%2A> method.</span></span> <span data-ttu-id="627df-259"><xref:System.Threading.Tasks.Task.Delay%2A> Metoda je popsaná v následující části.</span><span class="sxs-lookup"><span data-stu-id="627df-259">The <xref:System.Threading.Tasks.Task.Delay%2A> method is described in the following section.</span></span>  
  
### <a name="taskdelay"></a><span data-ttu-id="627df-260">Task.Delay</span><span class="sxs-lookup"><span data-stu-id="627df-260">Task.Delay</span></span>  
 <span data-ttu-id="627df-261"><xref:System.Threading.Tasks.Task.Delay%2A?displayProperty=nameWithType> Metoda vytváří <xref:System.Threading.Tasks.Task> objekt, který končí po zadanou dobu.</span><span class="sxs-lookup"><span data-stu-id="627df-261">The <xref:System.Threading.Tasks.Task.Delay%2A?displayProperty=nameWithType> method produces a <xref:System.Threading.Tasks.Task> object that finishes after the specified time.</span></span> <span data-ttu-id="627df-262">Tuto metodu můžete použít k vytvoření cyklů, které občas provádějí dotazování na data, zavedení limitů, zpracování vstupu uživatele na předem stanovenou dobu zpoždění a tak dále.</span><span class="sxs-lookup"><span data-stu-id="627df-262">You can use this method to build loops that occasionally poll for data, introduce time-outs, delay the handling of user input for a predetermined time, and so on.</span></span>  
  
### <a name="tasktfromresult"></a><span data-ttu-id="627df-263">Task(T).FromResult</span><span class="sxs-lookup"><span data-stu-id="627df-263">Task(T).FromResult</span></span>  
 <span data-ttu-id="627df-264">Pomocí <xref:System.Threading.Tasks.Task.FromResult%2A?displayProperty=nameWithType> metodu, můžete vytvořit <xref:System.Threading.Tasks.Task%601> objekt, který obsahuje předvypočítaných výsledek.</span><span class="sxs-lookup"><span data-stu-id="627df-264">By using the <xref:System.Threading.Tasks.Task.FromResult%2A?displayProperty=nameWithType> method, you can create a <xref:System.Threading.Tasks.Task%601> object that holds a pre-computed result.</span></span> <span data-ttu-id="627df-265">Tato metoda je užitečná při provádění asynchronní operace, která vrátí <xref:System.Threading.Tasks.Task%601> objektu a výsledek této <xref:System.Threading.Tasks.Task%601> objektu již je počítaný.</span><span class="sxs-lookup"><span data-stu-id="627df-265">This method is useful when you perform an asynchronous operation that returns a <xref:System.Threading.Tasks.Task%601> object, and the result of that <xref:System.Threading.Tasks.Task%601> object is already computed.</span></span> <span data-ttu-id="627df-266">Pro příklad, který používá <xref:System.Threading.Tasks.Task.FromResult%2A> načíst výsledky stahování asynchronní operace, které jsou uložené v mezipaměti, najdete v části [postupy: vytvoření úlohy Pre-Computed](../../../docs/standard/parallel-programming/how-to-create-pre-computed-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="627df-266">For an example that uses <xref:System.Threading.Tasks.Task.FromResult%2A> to retrieve the results of asynchronous download operations that are held in a cache, see [How to: Create Pre-Computed Tasks](../../../docs/standard/parallel-programming/how-to-create-pre-computed-tasks.md).</span></span>  
  
## <a name="handling-exceptions-in-tasks"></a><span data-ttu-id="627df-267">Zpracování výjimek v úlohách</span><span class="sxs-lookup"><span data-stu-id="627df-267">Handling exceptions in tasks</span></span>  
 <span data-ttu-id="627df-268">Pokud úloha vyvolá jednu nebo více výjimek, výjimky jsou uzavřen do <xref:System.AggregateException> výjimka.</span><span class="sxs-lookup"><span data-stu-id="627df-268">When a task throws one or more exceptions, the exceptions are wrapped in an <xref:System.AggregateException> exception.</span></span> <span data-ttu-id="627df-269">Že výjimka rozšířena zpět na vlákno, které spojí s úkolu, který je obvykle vláken, která čeká na dokončení úlohy nebo podproces, který přistupuje <xref:System.Threading.Tasks.Task%601.Result%2A> vlastnost.</span><span class="sxs-lookup"><span data-stu-id="627df-269">That exception is propagated back to the thread that joins with the task, which is typically the thread that is waiting for the task to finish or the thread that accesses the <xref:System.Threading.Tasks.Task%601.Result%2A> property.</span></span> <span data-ttu-id="627df-270">Toto chování slouží k vynucení, aby při všech neošetřených výjimkách ve výchozím nastavení zásady rozhraní .NET Framework ukončily proces.</span><span class="sxs-lookup"><span data-stu-id="627df-270">This behavior serves to enforce the .NET Framework policy that all unhandled exceptions by default should terminate the process.</span></span> <span data-ttu-id="627df-271">Volání kódu můžete zpracování výjimky pomocí některé z těchto v `try` / `catch` bloku:</span><span class="sxs-lookup"><span data-stu-id="627df-271">The calling code can handle the exceptions by using any of the following in a `try`/`catch` block:</span></span>  
  
-   <span data-ttu-id="627df-272"><xref:System.Threading.Tasks.Task.Wait%2A> – Metoda</span><span class="sxs-lookup"><span data-stu-id="627df-272">The <xref:System.Threading.Tasks.Task.Wait%2A> method</span></span>  
  
-   <span data-ttu-id="627df-273"><xref:System.Threading.Tasks.Task.WaitAll%2A> – Metoda</span><span class="sxs-lookup"><span data-stu-id="627df-273">The <xref:System.Threading.Tasks.Task.WaitAll%2A> method</span></span>  
  
-   <span data-ttu-id="627df-274"><xref:System.Threading.Tasks.Task.WaitAny%2A> – Metoda</span><span class="sxs-lookup"><span data-stu-id="627df-274">The <xref:System.Threading.Tasks.Task.WaitAny%2A> method</span></span>  
  
-   <span data-ttu-id="627df-275"><xref:System.Threading.Tasks.Task%601.Result%2A> Vlastnost</span><span class="sxs-lookup"><span data-stu-id="627df-275">The <xref:System.Threading.Tasks.Task%601.Result%2A> property</span></span>  
  
 <span data-ttu-id="627df-276">Spojovací vlákno může také zpracování výjimek přímým přístupem <xref:System.Threading.Tasks.Task.Exception%2A> vlastnost před úlohu uvolňování paměti.</span><span class="sxs-lookup"><span data-stu-id="627df-276">The joining thread can also handle exceptions by accessing the <xref:System.Threading.Tasks.Task.Exception%2A> property before the task is garbage-collected.</span></span> <span data-ttu-id="627df-277">Přístupem k této vlastnosti nebude nezpracovaná výjimka spouštět chování šíření výjimky, které ukončí proces, když je objekt finalizován.</span><span class="sxs-lookup"><span data-stu-id="627df-277">By accessing this property, you prevent the unhandled exception from triggering the exception propagation behavior that terminates the process when the object is finalized.</span></span>  
  
 <span data-ttu-id="627df-278">Další informace o výjimkách a úlohách najdete v tématu [zpracování výjimek](../../../docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span><span class="sxs-lookup"><span data-stu-id="627df-278">For more information about exceptions and tasks, see [Exception Handling](../../../docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span></span>  
  
## <a name="canceling-tasks"></a><span data-ttu-id="627df-279">Zrušení úloh</span><span class="sxs-lookup"><span data-stu-id="627df-279">Canceling tasks</span></span>  
 <span data-ttu-id="627df-280">`Task` Třída podporuje spolupráci zrušení a jsou plně integrované s <xref:System.Threading.CancellationTokenSource?displayProperty=nameWithType> a <xref:System.Threading.CancellationToken?displayProperty=nameWithType> třídy, které byly představeny v rozhraní .NET Framework 4.</span><span class="sxs-lookup"><span data-stu-id="627df-280">The `Task` class supports cooperative cancellation and is fully integrated with the <xref:System.Threading.CancellationTokenSource?displayProperty=nameWithType> and <xref:System.Threading.CancellationToken?displayProperty=nameWithType> classes, which were introduced in the .NET Framework 4.</span></span> <span data-ttu-id="627df-281">Mnoho z konstruktorů v <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> proveďte třídy <xref:System.Threading.CancellationToken> objektu jako vstupní parametr.</span><span class="sxs-lookup"><span data-stu-id="627df-281">Many of the constructors in the <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> class take a <xref:System.Threading.CancellationToken> object as an input parameter.</span></span> <span data-ttu-id="627df-282">Řadu <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> a <xref:System.Threading.Tasks.Task.Run%2A> přetížení také zahrnovat <xref:System.Threading.CancellationToken> parametr.</span><span class="sxs-lookup"><span data-stu-id="627df-282">Many of the <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> and <xref:System.Threading.Tasks.Task.Run%2A> overloads also include a <xref:System.Threading.CancellationToken> parameter.</span></span>  
  
 <span data-ttu-id="627df-283">Můžete vytvořit token a vydat žádost o zrušení některých později pomocí <xref:System.Threading.CancellationTokenSource> třídy.</span><span class="sxs-lookup"><span data-stu-id="627df-283">You can create the token, and issue the cancellation request at some later time, by using the <xref:System.Threading.CancellationTokenSource> class.</span></span> <span data-ttu-id="627df-284">Předejte token, který má <xref:System.Threading.Tasks.Task> jako argument a také odkaz na stejný token v uživatelském delegátovi, který provádí reakci na žádost o zrušení.</span><span class="sxs-lookup"><span data-stu-id="627df-284">Pass the token to the <xref:System.Threading.Tasks.Task> as an argument, and also reference the same token in your user delegate, which does the work of responding to a cancellation request.</span></span>  
  
 <span data-ttu-id="627df-285">Další informace najdete v tématu [zrušení úlohy](../../../docs/standard/parallel-programming/task-cancellation.md) a [postupy: zrušení úlohy a její podřízené položky](../../../docs/standard/parallel-programming/how-to-cancel-a-task-and-its-children.md).</span><span class="sxs-lookup"><span data-stu-id="627df-285">For more information, see [Task Cancellation](../../../docs/standard/parallel-programming/task-cancellation.md) and [How to: Cancel a Task and Its Children](../../../docs/standard/parallel-programming/how-to-cancel-a-task-and-its-children.md).</span></span>  
  
## <a name="the-taskfactory-class"></a><span data-ttu-id="627df-286">Třída TaskFactory</span><span class="sxs-lookup"><span data-stu-id="627df-286">The TaskFactory class</span></span>  
 <span data-ttu-id="627df-287"><xref:System.Threading.Tasks.TaskFactory> Třída poskytuje statické metody, které zapouzdřují některé obecné vzory pro vytváření a spouštění úloh a úloh pokračování.</span><span class="sxs-lookup"><span data-stu-id="627df-287">The <xref:System.Threading.Tasks.TaskFactory> class provides static methods that encapsulate some common patterns for creating and starting tasks and continuation tasks.</span></span>  
  
-   <span data-ttu-id="627df-288">Nejběžnější vzor <xref:System.Threading.Tasks.TaskFactory.StartNew%2A>, která vytvoří a spustí úlohu v jednom příkazu.</span><span class="sxs-lookup"><span data-stu-id="627df-288">The most common pattern is <xref:System.Threading.Tasks.TaskFactory.StartNew%2A>, which creates and starts a task in one statement.</span></span>  
  
-   <span data-ttu-id="627df-289">Při vytváření úloh pokračování z více předchůdců, použijte <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A> metoda nebo <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAny%2A> metoda nebo jejich ekvivalenty v <xref:System.Threading.Tasks.Task%601> třídy.</span><span class="sxs-lookup"><span data-stu-id="627df-289">When you create continuation tasks from multiple antecedents, use the <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A> method or <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAny%2A> method or their equivalents in the <xref:System.Threading.Tasks.Task%601> class.</span></span> <span data-ttu-id="627df-290">Další informace najdete v tématu [řetězení úloh pomocí úloh pokračování pomocí](../../../docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="627df-290">For more information, see [Chaining Tasks by Using Continuation Tasks](../../../docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md).</span></span>  
  
-   <span data-ttu-id="627df-291">K zapouzdření asynchronní programovací Model `BeginX` a `EndX` metody v <xref:System.Threading.Tasks.Task> nebo <xref:System.Threading.Tasks.Task%601> instance, použijte <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="627df-291">To encapsulate Asynchronous Programming Model `BeginX` and `EndX` methods in a <xref:System.Threading.Tasks.Task> or <xref:System.Threading.Tasks.Task%601> instance, use the <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> methods.</span></span> <span data-ttu-id="627df-292">Další informace najdete v tématu [TPL a tradiční rozhraní .NET Framework asynchronní programování](../../../docs/standard/parallel-programming/tpl-and-traditional-async-programming.md).</span><span class="sxs-lookup"><span data-stu-id="627df-292">For more information, see [TPL and Traditional .NET Framework Asynchronous Programming](../../../docs/standard/parallel-programming/tpl-and-traditional-async-programming.md).</span></span>  
  
 <span data-ttu-id="627df-293">Výchozí <xref:System.Threading.Tasks.TaskFactory> můžou mít přístup pomocí statické vlastnosti na <xref:System.Threading.Tasks.Task> třídy nebo <xref:System.Threading.Tasks.Task%601> třídy.</span><span class="sxs-lookup"><span data-stu-id="627df-293">The default <xref:System.Threading.Tasks.TaskFactory> can be accessed as a static property on the <xref:System.Threading.Tasks.Task> class or <xref:System.Threading.Tasks.Task%601> class.</span></span> <span data-ttu-id="627df-294">Můžete také vytvořit instanci <xref:System.Threading.Tasks.TaskFactory> přímo a určit různé možnosti, které zahrnují <xref:System.Threading.CancellationToken>, <xref:System.Threading.Tasks.TaskCreationOptions> možnost, <xref:System.Threading.Tasks.TaskContinuationOptions> možnost, nebo <xref:System.Threading.Tasks.TaskScheduler>.</span><span class="sxs-lookup"><span data-stu-id="627df-294">You can also instantiate a <xref:System.Threading.Tasks.TaskFactory> directly and specify various options that include a <xref:System.Threading.CancellationToken>, a <xref:System.Threading.Tasks.TaskCreationOptions> option, a <xref:System.Threading.Tasks.TaskContinuationOptions> option, or a <xref:System.Threading.Tasks.TaskScheduler>.</span></span> <span data-ttu-id="627df-295">Jakékoliv možnosti jsou zadány při vytváření úloh se použijí na všechny úlohy, které vytvoří, pokud <xref:System.Threading.Tasks.Task> je vytvořená pomocí <xref:System.Threading.Tasks.TaskCreationOptions> výčtu, ve kterém případ úkolu možnosti přepsání u objektu pro vytváření úloh.</span><span class="sxs-lookup"><span data-stu-id="627df-295">Whatever options are specified when you create the task factory will be applied to all tasks that it creates, unless the <xref:System.Threading.Tasks.Task> is created by using the <xref:System.Threading.Tasks.TaskCreationOptions> enumeration, in which case the task's options override those of the task factory.</span></span>  
  
## <a name="tasks-without-delegates"></a><span data-ttu-id="627df-296">Úlohy bez delegátů</span><span class="sxs-lookup"><span data-stu-id="627df-296">Tasks without delegates</span></span>  
 <span data-ttu-id="627df-297">V některých případech můžete chtít použít <xref:System.Threading.Tasks.Task> k zapouzdření některé asynchronní operace, které se provádí pomocí externí komponenta namísto uživatelského delegáta.</span><span class="sxs-lookup"><span data-stu-id="627df-297">In some cases, you may want to use a <xref:System.Threading.Tasks.Task> to encapsulate some asynchronous operation that is performed by an external component instead of your own user delegate.</span></span> <span data-ttu-id="627df-298">Pokud operace je založená na vzoru Begin/End Model asynchronního programování, můžete použít <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="627df-298">If the operation is based on the Asynchronous Programming Model Begin/End pattern, you can use the <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> methods.</span></span> <span data-ttu-id="627df-299">Pokud není tento případ, můžete použít <xref:System.Threading.Tasks.TaskCompletionSource%601> objekt, který chcete zalomení operaci v úloze a získat tak některé z výhod <xref:System.Threading.Tasks.Task> programovatelnosti, například podporu pro šíření výjimek a pokračování.</span><span class="sxs-lookup"><span data-stu-id="627df-299">If that is not the case, you can use the <xref:System.Threading.Tasks.TaskCompletionSource%601> object to wrap the operation in a task and thereby gain some of the benefits of <xref:System.Threading.Tasks.Task> programmability, for example, support for exception propagation and continuations.</span></span> <span data-ttu-id="627df-300">Další informace naleznete v tématu <xref:System.Threading.Tasks.TaskCompletionSource%601>.</span><span class="sxs-lookup"><span data-stu-id="627df-300">For more information, see <xref:System.Threading.Tasks.TaskCompletionSource%601>.</span></span>  
  
## <a name="custom-schedulers"></a><span data-ttu-id="627df-301">Vlastní plánovače</span><span class="sxs-lookup"><span data-stu-id="627df-301">Custom schedulers</span></span>  
 <span data-ttu-id="627df-302">Většina vývojářů aplikace nebo knihovna nezáleží na kterém procesoru úloha spuštěna, jak synchronizuje svou práci s ostatními úkoly nebo jak je naplánována na <xref:System.Threading.ThreadPool?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="627df-302">Most application or library developers do not care which processor the task runs on, how it synchronizes its work with other tasks, or how it is scheduled on the <xref:System.Threading.ThreadPool?displayProperty=nameWithType>.</span></span> <span data-ttu-id="627df-303">Vyžadují pouze to, aby byly tyto úkony v hostitelském počítači prováděny tak efektivně, jak je to možné.</span><span class="sxs-lookup"><span data-stu-id="627df-303">They only require that it execute as efficiently as possible on the host computer.</span></span> <span data-ttu-id="627df-304">Pokud požadujete jemněji odstupňovanou kontrolu nad podrobnostmi plánování, Task Parallel Library umožňuje konfigurovat některá nastavení výchozího plánovače úloh a dokonce umožňuje zadat vlastní plánovač.</span><span class="sxs-lookup"><span data-stu-id="627df-304">If you require more fine-grained control over the scheduling details, the Task Parallel Library lets you configure some settings on the default task scheduler, and even lets you supply a custom scheduler.</span></span> <span data-ttu-id="627df-305">Další informace naleznete v tématu <xref:System.Threading.Tasks.TaskScheduler>.</span><span class="sxs-lookup"><span data-stu-id="627df-305">For more information, see <xref:System.Threading.Tasks.TaskScheduler>.</span></span>  
  
## <a name="related-data-structures"></a><span data-ttu-id="627df-306">Související datové struktury</span><span class="sxs-lookup"><span data-stu-id="627df-306">Related data structures</span></span>  
 <span data-ttu-id="627df-307">TPL má několik nových veřejných typů, které jsou použitelné jak v situacích paralelního, tak i sekvenčního vykonávání.</span><span class="sxs-lookup"><span data-stu-id="627df-307">The TPL has several new public types that are useful in both parallel and sequential scenarios.</span></span> <span data-ttu-id="627df-308">Patří mezi ně několik třídy bezpečné pro přístup z více vláken, rychlá a škálovatelná kolekce v <xref:System.Collections.Concurrent?displayProperty=nameWithType> obor názvů a synchronizace několik nových typů například <xref:System.Threading.Semaphore?displayProperty=nameWithType> a <xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType>, které jsou efektivnější než jejich předchůdci pro konkrétní druhy zátěží.</span><span class="sxs-lookup"><span data-stu-id="627df-308">These include several thread-safe, fast and scalable collection classes in the <xref:System.Collections.Concurrent?displayProperty=nameWithType> namespace, and several new synchronization types, for example, <xref:System.Threading.Semaphore?displayProperty=nameWithType> and <xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType>, which are more efficient than their predecessors for specific kinds of workloads.</span></span> <span data-ttu-id="627df-309">Další nové typy v rozhraní .NET Framework 4, například <xref:System.Threading.Barrier?displayProperty=nameWithType> a <xref:System.Threading.SpinLock?displayProperty=nameWithType>, poskytovat funkce, které nebyly k dispozici ve starších verzích.</span><span class="sxs-lookup"><span data-stu-id="627df-309">Other new types in the .NET Framework 4, for example, <xref:System.Threading.Barrier?displayProperty=nameWithType> and <xref:System.Threading.SpinLock?displayProperty=nameWithType>, provide functionality that was not available in earlier releases.</span></span> <span data-ttu-id="627df-310">Další informace najdete v tématu [datové struktury pro paralelní programování](../../../docs/standard/parallel-programming/data-structures-for-parallel-programming.md).</span><span class="sxs-lookup"><span data-stu-id="627df-310">For more information, see [Data Structures for Parallel Programming](../../../docs/standard/parallel-programming/data-structures-for-parallel-programming.md).</span></span>  
  
## <a name="custom-task-types"></a><span data-ttu-id="627df-311">Typy úloh</span><span class="sxs-lookup"><span data-stu-id="627df-311">Custom task types</span></span>  
 <span data-ttu-id="627df-312">Doporučujeme vám, že není dědit z <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> nebo <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="627df-312">We recommend that you do not inherit from <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> or <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType>.</span></span> <span data-ttu-id="627df-313">Místo toho doporučujeme používat <xref:System.Threading.Tasks.Task.AsyncState%2A> vlastnost pro přidružení dalších dat nebo stavu s <xref:System.Threading.Tasks.Task> nebo <xref:System.Threading.Tasks.Task%601> objektu.</span><span class="sxs-lookup"><span data-stu-id="627df-313">Instead, we recommend that you use the <xref:System.Threading.Tasks.Task.AsyncState%2A> property to associate additional data or state with a <xref:System.Threading.Tasks.Task> or <xref:System.Threading.Tasks.Task%601> object.</span></span> <span data-ttu-id="627df-314">Můžete taky rozšiřující metody pro rozšíření funkcí <xref:System.Threading.Tasks.Task> a <xref:System.Threading.Tasks.Task%601> třídy.</span><span class="sxs-lookup"><span data-stu-id="627df-314">You can also use extension methods to extend the functionality of the <xref:System.Threading.Tasks.Task> and <xref:System.Threading.Tasks.Task%601> classes.</span></span> <span data-ttu-id="627df-315">Další informace o metodách rozšíření najdete v tématu [rozšiřující metody](~/docs/csharp/programming-guide/classes-and-structs/extension-methods.md) a [rozšiřující metody](~/docs/visual-basic/programming-guide/language-features/procedures/extension-methods.md).</span><span class="sxs-lookup"><span data-stu-id="627df-315">For more information about extension methods, see [Extension Methods](~/docs/csharp/programming-guide/classes-and-structs/extension-methods.md) and [Extension Methods](~/docs/visual-basic/programming-guide/language-features/procedures/extension-methods.md).</span></span>  
  
 <span data-ttu-id="627df-316">Pokud musí dědit z <xref:System.Threading.Tasks.Task> nebo <xref:System.Threading.Tasks.Task%601>, nemůžete použít <xref:System.Threading.Tasks.Task.Run%2A>, <xref:System.Threading.Tasks.Task.Run%2A>, nebo <xref:System.Threading.Tasks.TaskFactory?displayProperty=nameWithType>, <xref:System.Threading.Tasks.TaskFactory%601?displayProperty=nameWithType>, nebo <xref:System.Threading.Tasks.TaskCompletionSource%601?displayProperty=nameWithType> třídy pro vytvoření instance vlastní úlohu zadat, protože tyto mechanismy vytvořit pouze <xref:System.Threading.Tasks.Task> a <xref:System.Threading.Tasks.Task%601> objekty.</span><span class="sxs-lookup"><span data-stu-id="627df-316">If you must inherit from <xref:System.Threading.Tasks.Task> or <xref:System.Threading.Tasks.Task%601>, you cannot use <xref:System.Threading.Tasks.Task.Run%2A>, <xref:System.Threading.Tasks.Task.Run%2A>, or the <xref:System.Threading.Tasks.TaskFactory?displayProperty=nameWithType>, <xref:System.Threading.Tasks.TaskFactory%601?displayProperty=nameWithType>, or <xref:System.Threading.Tasks.TaskCompletionSource%601?displayProperty=nameWithType> classes to create instances of your custom task type because these mechanisms create only <xref:System.Threading.Tasks.Task> and <xref:System.Threading.Tasks.Task%601> objects.</span></span> <span data-ttu-id="627df-317">Kromě toho nelze použít na úkolů pokračování mechanismy, které jsou poskytovány <xref:System.Threading.Tasks.Task>, <xref:System.Threading.Tasks.Task%601>, <xref:System.Threading.Tasks.TaskFactory>, a <xref:System.Threading.Tasks.TaskFactory%601> vytvořit instance typu vaše vlastní úlohu, protože tyto mechanismy také vytvořit pouze <xref:System.Threading.Tasks.Task> a  <xref:System.Threading.Tasks.Task%601> objekty.</span><span class="sxs-lookup"><span data-stu-id="627df-317">In addition, you cannot use the task continuation mechanisms that are provided by <xref:System.Threading.Tasks.Task>, <xref:System.Threading.Tasks.Task%601>, <xref:System.Threading.Tasks.TaskFactory>, and  <xref:System.Threading.Tasks.TaskFactory%601> to create instances of your custom task type because these mechanisms also create only <xref:System.Threading.Tasks.Task> and  <xref:System.Threading.Tasks.Task%601> objects.</span></span>  
  
## <a name="related-topics"></a><span data-ttu-id="627df-318">Související témata</span><span class="sxs-lookup"><span data-stu-id="627df-318">Related topics</span></span>  
  
|<span data-ttu-id="627df-319">Název</span><span class="sxs-lookup"><span data-stu-id="627df-319">Title</span></span>|<span data-ttu-id="627df-320">Popis</span><span class="sxs-lookup"><span data-stu-id="627df-320">Description</span></span>|  
|-|-|  
|[<span data-ttu-id="627df-321">Řetězení úloh pomocí úloh pokračování</span><span class="sxs-lookup"><span data-stu-id="627df-321">Chaining Tasks by Using Continuation Tasks</span></span>](../../../docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md)|<span data-ttu-id="627df-322">Popisuje, jak fungují pokračování.</span><span class="sxs-lookup"><span data-stu-id="627df-322">Describes how continuations work.</span></span>|  
|[<span data-ttu-id="627df-323">Připojené a odpojené podřízené úlohy</span><span class="sxs-lookup"><span data-stu-id="627df-323">Attached and Detached Child Tasks</span></span>](../../../docs/standard/parallel-programming/attached-and-detached-child-tasks.md)|<span data-ttu-id="627df-324">Popisuje rozdíl mezi připojenými a odpojenými podřízenými úlohami.</span><span class="sxs-lookup"><span data-stu-id="627df-324">Describes the difference between attached and detached child tasks.</span></span>|  
|[<span data-ttu-id="627df-325">Zrušení úlohy</span><span class="sxs-lookup"><span data-stu-id="627df-325">Task Cancellation</span></span>](../../../docs/standard/parallel-programming/task-cancellation.md)|<span data-ttu-id="627df-326">Popisuje podporu zrušení, který je součástí <xref:System.Threading.Tasks.Task> objektu.</span><span class="sxs-lookup"><span data-stu-id="627df-326">Describes the cancellation support that is built into the <xref:System.Threading.Tasks.Task> object.</span></span>|  
|[<span data-ttu-id="627df-327">Zpracování výjimek</span><span class="sxs-lookup"><span data-stu-id="627df-327">Exception Handling</span></span>](../../../docs/standard/parallel-programming/exception-handling-task-parallel-library.md)|<span data-ttu-id="627df-328">Popisuje způsob zpracování výjimek v souběžných vláknech.</span><span class="sxs-lookup"><span data-stu-id="627df-328">Describes how exceptions on concurrent threads are handled.</span></span>|  
|[<span data-ttu-id="627df-329">Postupy: Použití algoritmu Parallel.Invoke k provádění paralelních operací</span><span class="sxs-lookup"><span data-stu-id="627df-329">How to: Use Parallel.Invoke to Execute Parallel Operations</span></span>](../../../docs/standard/parallel-programming/how-to-use-parallel-invoke-to-execute-parallel-operations.md)|<span data-ttu-id="627df-330">Popisuje způsob použití <xref:System.Threading.Tasks.Parallel.Invoke%2A>.</span><span class="sxs-lookup"><span data-stu-id="627df-330">Describes how to use <xref:System.Threading.Tasks.Parallel.Invoke%2A>.</span></span>|  
|[<span data-ttu-id="627df-331">Postupy: Vrácení hodnoty z úlohy</span><span class="sxs-lookup"><span data-stu-id="627df-331">How to: Return a Value from a Task</span></span>](../../../docs/standard/parallel-programming/how-to-return-a-value-from-a-task.md)|<span data-ttu-id="627df-332">Popisuje, jak z úloh vracet hodnoty.</span><span class="sxs-lookup"><span data-stu-id="627df-332">Describes how to return values from tasks.</span></span>|  
|[<span data-ttu-id="627df-333">Postupy: Zrušení úlohy a podřízených elementů</span><span class="sxs-lookup"><span data-stu-id="627df-333">How to: Cancel a Task and Its Children</span></span>](../../../docs/standard/parallel-programming/how-to-cancel-a-task-and-its-children.md)|<span data-ttu-id="627df-334">Popisuje, jak zrušit úlohy.</span><span class="sxs-lookup"><span data-stu-id="627df-334">Describes how to cancel tasks.</span></span>|  
|[<span data-ttu-id="627df-335">Postupy: Vytváření předvypočítaných úloh</span><span class="sxs-lookup"><span data-stu-id="627df-335">How to: Create Pre-Computed Tasks</span></span>](../../../docs/standard/parallel-programming/how-to-create-pre-computed-tasks.md)|<span data-ttu-id="627df-336">Popisuje postup použití <xref:System.Threading.Tasks.Task.FromResult%2A?displayProperty=nameWithType> metoda načíst výsledky stahování asynchronní operace, které jsou uložené v mezipaměti.</span><span class="sxs-lookup"><span data-stu-id="627df-336">Describes how to use the <xref:System.Threading.Tasks.Task.FromResult%2A?displayProperty=nameWithType> method to retrieve the results of asynchronous download operations that are held in a cache.</span></span>|  
|[<span data-ttu-id="627df-337">Postupy: Procházení binárního stromu s paralelními úlohami</span><span class="sxs-lookup"><span data-stu-id="627df-337">How to: Traverse a Binary Tree with Parallel Tasks</span></span>](../../../docs/standard/parallel-programming/how-to-traverse-a-binary-tree-with-parallel-tasks.md)|<span data-ttu-id="627df-338">Popisuje, jak použít úlohy k procházení binárního stromu.</span><span class="sxs-lookup"><span data-stu-id="627df-338">Describes how to use tasks to traverse a binary tree.</span></span>|  
|[<span data-ttu-id="627df-339">Postupy: Rozbalení vnořené úlohy</span><span class="sxs-lookup"><span data-stu-id="627df-339">How to: Unwrap a Nested Task</span></span>](../../../docs/standard/parallel-programming/how-to-unwrap-a-nested-task.md)|<span data-ttu-id="627df-340">Ukazuje, jak používat <xref:System.Threading.Tasks.TaskExtensions.Unwrap%2A> metoda rozšíření.</span><span class="sxs-lookup"><span data-stu-id="627df-340">Demonstrates how to use the <xref:System.Threading.Tasks.TaskExtensions.Unwrap%2A> extension method.</span></span>|  
|[<span data-ttu-id="627df-341">Datový paralelismus</span><span class="sxs-lookup"><span data-stu-id="627df-341">Data Parallelism</span></span>](../../../docs/standard/parallel-programming/data-parallelism-task-parallel-library.md)|<span data-ttu-id="627df-342">Popisuje způsob použití <xref:System.Threading.Tasks.Parallel.For%2A> a <xref:System.Threading.Tasks.Parallel.ForEach%2A> pro vytvoření paralelní smyčky nad daty.</span><span class="sxs-lookup"><span data-stu-id="627df-342">Describes how to use <xref:System.Threading.Tasks.Parallel.For%2A> and <xref:System.Threading.Tasks.Parallel.ForEach%2A> to create parallel loops over data.</span></span>|  
|[<span data-ttu-id="627df-343">Paralelní programování</span><span class="sxs-lookup"><span data-stu-id="627df-343">Parallel Programming</span></span>](../../../docs/standard/parallel-programming/index.md)|<span data-ttu-id="627df-344">Uzel nejvyšší úrovně pro paralelní programování rozhraní .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="627df-344">Top level node for .NET Framework parallel programming.</span></span>|  
  
## <a name="see-also"></a><span data-ttu-id="627df-345">Viz také</span><span class="sxs-lookup"><span data-stu-id="627df-345">See Also</span></span>  
 [<span data-ttu-id="627df-346">Paralelní programování</span><span class="sxs-lookup"><span data-stu-id="627df-346">Parallel Programming</span></span>](../../../docs/standard/parallel-programming/index.md)  
 [<span data-ttu-id="627df-347">Ukázky pro paralelní programování s rozhraním .NET Framework</span><span class="sxs-lookup"><span data-stu-id="627df-347">Samples for Parallel Programming with the .NET Framework</span></span>](https://code.msdn.microsoft.com/Samples-for-Parallel-b4b76364)
