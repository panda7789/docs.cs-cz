---
title: Řetězení úloh pomocí úloh pokračování
description: Naučte se řetězit úkol pomocí úloh pokračování v .NET. Pokračující úkol je asynchronní úloha, která je vyvolána jinou úlohou.
ms.date: 07/20/2020
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- tasks, continuations
ms.assetid: 0b45e9a2-de28-46ce-8212-1817280ed42d
ms.openlocfilehash: 53457f7f99d96c288b002f58c9db36f431ba863a
ms.sourcegitcommit: 552b4b60c094559db9d8178fa74f5bafaece0caf
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 07/29/2020
ms.locfileid: "87381304"
---
# <a name="chaining-tasks-using-continuation-tasks"></a><span data-ttu-id="5e6fb-104">Řetězení úloh pomocí úloh pokračování</span><span class="sxs-lookup"><span data-stu-id="5e6fb-104">Chaining tasks using continuation tasks</span></span>

<span data-ttu-id="5e6fb-105">V asynchronním programování je běžné pro jednu asynchronní operaci po dokončení pro vyvolání druhé operace.</span><span class="sxs-lookup"><span data-stu-id="5e6fb-105">In asynchronous programming, it's common for one asynchronous operation, on completion, to invoke a second operation.</span></span> <span data-ttu-id="5e6fb-106">Pokračování umožňují, aby operace samé využívaly výsledky první operace.</span><span class="sxs-lookup"><span data-stu-id="5e6fb-106">Continuations allow decedent operations to consume the results of the first operation.</span></span> <span data-ttu-id="5e6fb-107">Pokračování je tradičně prováděno pomocí metod zpětného volání.</span><span class="sxs-lookup"><span data-stu-id="5e6fb-107">Traditionally, continuations have been done by using callback methods.</span></span> <span data-ttu-id="5e6fb-108">V knihovně Task Parallel Library jsou stejné funkce poskytovány _pokračujícími úkoly_.</span><span class="sxs-lookup"><span data-stu-id="5e6fb-108">In the Task Parallel Library, the same functionality is provided by _continuation tasks_.</span></span> <span data-ttu-id="5e6fb-109">Pokračování úlohy (označované také jako pokračování) je asynchronní úloha, která je vyvolána jinou úlohou, která se označuje jako _předchůdce_po dokončení předchůdce.</span><span class="sxs-lookup"><span data-stu-id="5e6fb-109">A continuation task (also known just as a continuation) is an asynchronous task that's invoked by another task, known as the _antecedent_, when the antecedent finishes.</span></span>

<span data-ttu-id="5e6fb-110">Pokračování je poměrně snadné použít, ale jsou ale výkonné a flexibilní.</span><span class="sxs-lookup"><span data-stu-id="5e6fb-110">Continuations are relatively easy to use, but are nevertheless powerful and flexible.</span></span> <span data-ttu-id="5e6fb-111">Můžete například:</span><span class="sxs-lookup"><span data-stu-id="5e6fb-111">For example, you can:</span></span>

- <span data-ttu-id="5e6fb-112">Předat data z předchůdce do pokračování.</span><span class="sxs-lookup"><span data-stu-id="5e6fb-112">Pass data from the antecedent to the continuation.</span></span>
- <span data-ttu-id="5e6fb-113">Určete přesné podmínky, za kterých bude pokračování vyvoláno nebo není vyvoláno.</span><span class="sxs-lookup"><span data-stu-id="5e6fb-113">Specify the precise conditions under which the continuation will be invoked or not invoked.</span></span>
- <span data-ttu-id="5e6fb-114">Zrušení pokračování buď před jeho spuštěním, nebo ve spolupráci s tím, jak běží.</span><span class="sxs-lookup"><span data-stu-id="5e6fb-114">Cancel a continuation either before it starts or cooperatively as it is running.</span></span>
- <span data-ttu-id="5e6fb-115">Poskytněte nápovědu, jak má být pokračování naplánováno.</span><span class="sxs-lookup"><span data-stu-id="5e6fb-115">Provide hints about how the continuation should be scheduled.</span></span>
- <span data-ttu-id="5e6fb-116">Vyvolá několik pokračování ze stejného předchůdce.</span><span class="sxs-lookup"><span data-stu-id="5e6fb-116">Invoke multiple continuations from the same antecedent.</span></span>
- <span data-ttu-id="5e6fb-117">Vyvolat jedno pokračování, až se dokončí všechny nebo některé z více předchůdců.</span><span class="sxs-lookup"><span data-stu-id="5e6fb-117">Invoke one continuation when all or any one of multiple antecedents complete.</span></span>
- <span data-ttu-id="5e6fb-118">Zřetězit pokračování jedno po druhém do jakékoli libovolné délky.</span><span class="sxs-lookup"><span data-stu-id="5e6fb-118">Chain continuations one after another to any arbitrary length.</span></span>
- <span data-ttu-id="5e6fb-119">Použijte pokračování pro zpracování výjimek vyvolaných předchůdcem.</span><span class="sxs-lookup"><span data-stu-id="5e6fb-119">Use a continuation to handle exceptions thrown by the antecedent.</span></span>

## <a name="about-continuations"></a><span data-ttu-id="5e6fb-120">O pokračování</span><span class="sxs-lookup"><span data-stu-id="5e6fb-120">About continuations</span></span>

<span data-ttu-id="5e6fb-121">Pokračování je úkol, který je vytvořen ve <xref:System.Threading.Tasks.TaskStatus.WaitingForActivation> stavu.</span><span class="sxs-lookup"><span data-stu-id="5e6fb-121">A continuation is a task that is created in the <xref:System.Threading.Tasks.TaskStatus.WaitingForActivation> state.</span></span> <span data-ttu-id="5e6fb-122">Aktivuje se automaticky po dokončení jeho předchozí úlohy nebo úkolů.</span><span class="sxs-lookup"><span data-stu-id="5e6fb-122">It is activated automatically when its antecedent task or tasks complete.</span></span> <span data-ttu-id="5e6fb-123">Volání <xref:System.Threading.Tasks.Task.Start%2A?displayProperty=nameWithType> při pokračování v uživatelském kódu vyvolá <xref:System.InvalidOperationException?displayProperty=nameWithType> výjimku.</span><span class="sxs-lookup"><span data-stu-id="5e6fb-123">Calling <xref:System.Threading.Tasks.Task.Start%2A?displayProperty=nameWithType> on a continuation in user code throws an <xref:System.InvalidOperationException?displayProperty=nameWithType> exception.</span></span>

<span data-ttu-id="5e6fb-124">Pokračování je samo <xref:System.Threading.Tasks.Task> a neblokuje vlákno, ve kterém je spuštěno.</span><span class="sxs-lookup"><span data-stu-id="5e6fb-124">A continuation is itself a <xref:System.Threading.Tasks.Task> and does not block the thread on which it is started.</span></span> <span data-ttu-id="5e6fb-125">Zavolejte <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> metodu pro blokování do dokončení pokračování úlohy.</span><span class="sxs-lookup"><span data-stu-id="5e6fb-125">Call the <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> method to block until the continuation task finishes.</span></span>

## <a name="create-a-continuation-for-a-single-antecedent"></a><span data-ttu-id="5e6fb-126">Vytvoří pokračování pro jeden předchůdce.</span><span class="sxs-lookup"><span data-stu-id="5e6fb-126">Create a continuation for a single antecedent</span></span>

<span data-ttu-id="5e6fb-127">Můžete vytvořit pokračování, které se provede po dokončení jeho předchůdce voláním <xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="5e6fb-127">You create a continuation that executes when its antecedent has completed by calling the <xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="5e6fb-128">Následující příklad znázorňuje základní vzorek (pro přehlednost, vynechává se zpracování výjimek).</span><span class="sxs-lookup"><span data-stu-id="5e6fb-128">The following example shows the basic pattern (for clarity, exception handling is omitted).</span></span> <span data-ttu-id="5e6fb-129">Spustí předchozí úlohu, `taskA` která vrátí <xref:System.DayOfWeek> objekt, který označuje název aktuálního dne v týdnu.</span><span class="sxs-lookup"><span data-stu-id="5e6fb-129">It executes an antecedent task, `taskA`, that returns a <xref:System.DayOfWeek> object that indicates the name of the current day of the week.</span></span> <span data-ttu-id="5e6fb-130">Po dokončení předchůdce se úkol pokračování předá `continuation` do předchůdce a zobrazí řetězec, který obsahuje jeho výsledek.</span><span class="sxs-lookup"><span data-stu-id="5e6fb-130">When the antecedent completes, the continuation task, `continuation`, is passed the antecedent and displays a string that includes its result.</span></span>

> [!NOTE]
> <span data-ttu-id="5e6fb-131">Ukázky v jazyce C# v tomto článku využívají `async` Modifikátor `Main` metody.</span><span class="sxs-lookup"><span data-stu-id="5e6fb-131">The C# samples in this article make use of the `async` modifier on the `Main` method.</span></span> <span data-ttu-id="5e6fb-132">Tato funkce je k dispozici v C# 7,1 a novějších.</span><span class="sxs-lookup"><span data-stu-id="5e6fb-132">That feature is available in C# 7.1 and later.</span></span> <span data-ttu-id="5e6fb-133">Předchozí verze vygenerovaly [`CS5001`](../../csharp/misc/cs5001.md) při kompilování tohoto ukázkového kódu.</span><span class="sxs-lookup"><span data-stu-id="5e6fb-133">Previous versions generate [`CS5001`](../../csharp/misc/cs5001.md) when compiling this sample code.</span></span> <span data-ttu-id="5e6fb-134">Je nutné nastavit jazykovou verzi na C# 7,1 nebo novější.</span><span class="sxs-lookup"><span data-stu-id="5e6fb-134">You'll need to set the language version to C# 7.1 or newer.</span></span> <span data-ttu-id="5e6fb-135">Informace o tom, jak nakonfigurovat jazykovou verzi, najdete v článku o [konfiguraci jazykové verze](../../csharp/language-reference/configure-language-version.md).</span><span class="sxs-lookup"><span data-stu-id="5e6fb-135">You can learn how to configure the language version in the article on [configure language version](../../csharp/language-reference/configure-language-version.md).</span></span>

:::code language="csharp" source="snippets/cs/simple1.cs":::

[!code-vb[TPL_Continuations#1](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_continuations/vb/simple1.vb#1)]

## <a name="create-a-continuation-for-multiple-antecedents"></a><span data-ttu-id="5e6fb-136">Vytvořit pokračování pro více předchůdců</span><span class="sxs-lookup"><span data-stu-id="5e6fb-136">Create a continuation for multiple antecedents</span></span>

<span data-ttu-id="5e6fb-137">Můžete také vytvořit pokračování, které se spustí, když se dokončí kterákoli nebo celá skupina úkolů.</span><span class="sxs-lookup"><span data-stu-id="5e6fb-137">You can also create a continuation that will run when any or all of a group of tasks has completed.</span></span> <span data-ttu-id="5e6fb-138">Chcete-li provést pokračování po dokončení všech předchozích úloh, zavoláte statickou `Shared` metodu (v Visual Basic) <xref:System.Threading.Tasks.Task.WhenAll%2A?displayProperty=nameWithType> nebo metodu instance <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="5e6fb-138">To execute a continuation when all antecedent tasks have completed, you call the static (`Shared` in Visual Basic) <xref:System.Threading.Tasks.Task.WhenAll%2A?displayProperty=nameWithType> method or the instance <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="5e6fb-139">Chcete-li provést pokračování po dokončení kteréhokoliv z předchozích úloh, zavoláte statickou metodu ( `Shared` v Visual Basic) <xref:System.Threading.Tasks.Task.WhenAny%2A?displayProperty=nameWithType> nebo <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAny%2A?displayProperty=nameWithType> metodu instance.</span><span class="sxs-lookup"><span data-stu-id="5e6fb-139">To execute a continuation when any of the antecedent tasks has completed, you call the static (`Shared` in Visual Basic) <xref:System.Threading.Tasks.Task.WhenAny%2A?displayProperty=nameWithType> method or the instance <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAny%2A?displayProperty=nameWithType> method.</span></span>

<span data-ttu-id="5e6fb-140">Všimněte si, že volání <xref:System.Threading.Tasks.Task.WhenAll%2A?displayProperty=nameWithType> a <xref:System.Threading.Tasks.Task.WhenAny%2A?displayProperty=nameWithType> přetížení neblokují volající vlákno.</span><span class="sxs-lookup"><span data-stu-id="5e6fb-140">Note that calls to the <xref:System.Threading.Tasks.Task.WhenAll%2A?displayProperty=nameWithType> and <xref:System.Threading.Tasks.Task.WhenAny%2A?displayProperty=nameWithType> overloads do not block the calling thread.</span></span> <span data-ttu-id="5e6fb-141">Nicméně obvykle zavoláte <xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29?displayProperty=nameWithType> metodu a, <xref:System.Threading.Tasks.Task.WhenAll%28System.Threading.Tasks.Task%5B%5D%29?displayProperty=nameWithType> která načte vrácenou <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> vlastnost, která zablokuje volající vlákno.</span><span class="sxs-lookup"><span data-stu-id="5e6fb-141">However, you typically call all but the <xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29?displayProperty=nameWithType> and <xref:System.Threading.Tasks.Task.WhenAll%28System.Threading.Tasks.Task%5B%5D%29?displayProperty=nameWithType> methods to retrieve the returned <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> property, which does block the calling thread.</span></span>

<span data-ttu-id="5e6fb-142">Následující příklad volá <xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29?displayProperty=nameWithType> metodu pro vytvoření úlohy pokračování, která odráží výsledky jeho 10 předchozích úloh.</span><span class="sxs-lookup"><span data-stu-id="5e6fb-142">The following example calls the <xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29?displayProperty=nameWithType> method to create a continuation task that reflects the results of its 10 antecedent tasks.</span></span> <span data-ttu-id="5e6fb-143">Každý předchozí úkol napředá hodnotu indexu, která je v rozsahu od 1 do 10.</span><span class="sxs-lookup"><span data-stu-id="5e6fb-143">Each antecedent task squares an index value that ranges from one to 10.</span></span> <span data-ttu-id="5e6fb-144">Pokud se předchůdce úspěšně dokončí (jejich <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> vlastnost je <xref:System.Threading.Tasks.TaskStatus.RanToCompletion?displayProperty=nameWithType> ), <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> vlastnost pokračování je pole <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> hodnot vrácených jednotlivými předchůdci.</span><span class="sxs-lookup"><span data-stu-id="5e6fb-144">If the antecedents complete successfully (their <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> property is <xref:System.Threading.Tasks.TaskStatus.RanToCompletion?displayProperty=nameWithType>), the <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> property of the continuation is an array of the <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> values returned by each antecedent.</span></span> <span data-ttu-id="5e6fb-145">Tento příklad je přidá k výpočtu součtu čtverců pro všechna čísla od 1 do 10.</span><span class="sxs-lookup"><span data-stu-id="5e6fb-145">The example adds them to compute the sum of squares for all numbers between one and 10.</span></span>

:::code language="csharp" source="snippets/cs/whenall1.cs":::

[!code-vb[TPL_Continuations#5](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_continuations/vb/whenall1.vb#5)]

## <a name="continuation-options"></a><span data-ttu-id="5e6fb-146">Možnosti pokračování</span><span class="sxs-lookup"><span data-stu-id="5e6fb-146">Continuation options</span></span>

<span data-ttu-id="5e6fb-147">Když vytvoříte pokračování jedné úlohy, můžete použít <xref:System.Threading.Tasks.Task.ContinueWith%2A> přetížení, které přebírá <xref:System.Threading.Tasks.TaskContinuationOptions?displayProperty=nameWithType> hodnotu výčtu, a určit podmínky, za kterých se spustí pokračování.</span><span class="sxs-lookup"><span data-stu-id="5e6fb-147">When you create a single-task continuation, you can use a <xref:System.Threading.Tasks.Task.ContinueWith%2A> overload that takes a <xref:System.Threading.Tasks.TaskContinuationOptions?displayProperty=nameWithType> enumeration value to specify the conditions under which the continuation starts.</span></span> <span data-ttu-id="5e6fb-148">Můžete například určit, že pokračování bude spuštěno pouze v případě, že se předchůdce úspěšně dokončí, nebo pouze v případě, že se dokončí v chybovém stavu.</span><span class="sxs-lookup"><span data-stu-id="5e6fb-148">For example, you can specify that the continuation is to run only if the antecedent completes successfully, or only if it completes in a faulted state.</span></span> <span data-ttu-id="5e6fb-149">Pokud podmínka není pravdivá, pokud je předchůdce připraven k vyvolání pokračování, přechod pokračování přímo do <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> stavu a následně nemůže být spuštěn.</span><span class="sxs-lookup"><span data-stu-id="5e6fb-149">If the condition is not true when the antecedent is ready to invoke the continuation, the continuation transitions directly to the <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> state and subsequently cannot be started.</span></span>

<span data-ttu-id="5e6fb-150">Několik metod pokračování více úloh, jako jsou například přetížení <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A?displayProperty=nameWithType> metody, zahrnují také <xref:System.Threading.Tasks.TaskContinuationOptions?displayProperty=nameWithType> parametr.</span><span class="sxs-lookup"><span data-stu-id="5e6fb-150">A number of multi-task continuation methods, such as overloads of the <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A?displayProperty=nameWithType> method, also include a <xref:System.Threading.Tasks.TaskContinuationOptions?displayProperty=nameWithType> parameter.</span></span> <span data-ttu-id="5e6fb-151">Platná je však pouze podmnožina všech <xref:System.Threading.Tasks.TaskContinuationOptions?displayProperty=nameWithType> členů výčtu.</span><span class="sxs-lookup"><span data-stu-id="5e6fb-151">Only a subset of all <xref:System.Threading.Tasks.TaskContinuationOptions?displayProperty=nameWithType> enumeration members are valid, however.</span></span> <span data-ttu-id="5e6fb-152">Můžete zadat <xref:System.Threading.Tasks.TaskContinuationOptions?displayProperty=nameWithType> hodnoty, které mají protějšky ve <xref:System.Threading.Tasks.TaskCreationOptions?displayProperty=nameWithType> výčtu, například <xref:System.Threading.Tasks.TaskContinuationOptions.AttachedToParent?displayProperty=nameWithType> , <xref:System.Threading.Tasks.TaskContinuationOptions.LongRunning?displayProperty=nameWithType> a <xref:System.Threading.Tasks.TaskContinuationOptions.PreferFairness?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="5e6fb-152">You can specify <xref:System.Threading.Tasks.TaskContinuationOptions?displayProperty=nameWithType> values that have counterparts in the <xref:System.Threading.Tasks.TaskCreationOptions?displayProperty=nameWithType> enumeration, such as <xref:System.Threading.Tasks.TaskContinuationOptions.AttachedToParent?displayProperty=nameWithType>, <xref:System.Threading.Tasks.TaskContinuationOptions.LongRunning?displayProperty=nameWithType>, and <xref:System.Threading.Tasks.TaskContinuationOptions.PreferFairness?displayProperty=nameWithType>.</span></span> <span data-ttu-id="5e6fb-153">Pokud zadáte některou z `NotOn` možností nebo v případě `OnlyOn` pokračování s více úlohami, <xref:System.ArgumentOutOfRangeException> bude vyvolána výjimka v době běhu.</span><span class="sxs-lookup"><span data-stu-id="5e6fb-153">If you specify any of the `NotOn` or `OnlyOn` options with a multi-task continuation, an <xref:System.ArgumentOutOfRangeException> exception will be thrown at run time.</span></span>

<span data-ttu-id="5e6fb-154">Další informace o možnostech pokračování úlohy najdete v <xref:System.Threading.Tasks.TaskContinuationOptions> tématu.</span><span class="sxs-lookup"><span data-stu-id="5e6fb-154">For more information on task continuation options, see the <xref:System.Threading.Tasks.TaskContinuationOptions> topic.</span></span>

## <a name="pass-data-to-a-continuation"></a><span data-ttu-id="5e6fb-155">Předání dat do pokračování</span><span class="sxs-lookup"><span data-stu-id="5e6fb-155">Pass data to a continuation</span></span>

<span data-ttu-id="5e6fb-156"><xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType>Metoda předává odkaz na předchůdce uživateli, který by pokračoval jako argument.</span><span class="sxs-lookup"><span data-stu-id="5e6fb-156">The <xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType> method passes a reference to the antecedent to the user delegate of the continuation as an argument.</span></span> <span data-ttu-id="5e6fb-157">Pokud je předchůdce <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> objekt a úloha byla spuštěna až do dokončení, pokračování může získat přístup k <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> Vlastnosti úlohy.</span><span class="sxs-lookup"><span data-stu-id="5e6fb-157">If the antecedent is a <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> object, and the task ran until it was completed, then the continuation can access the <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> property of the task.</span></span>

<span data-ttu-id="5e6fb-158"><xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType>Vlastnost blokuje až do dokončení úlohy.</span><span class="sxs-lookup"><span data-stu-id="5e6fb-158">The <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> property blocks until the task has completed.</span></span> <span data-ttu-id="5e6fb-159">Pokud se ale úloha zrušila nebo došlo k chybě, pokus o přístup k <xref:System.Threading.Tasks.Task%601.Result%2A> vlastnosti vyvolá <xref:System.AggregateException> výjimku.</span><span class="sxs-lookup"><span data-stu-id="5e6fb-159">However, if the task was canceled or faulted, attempting to access the <xref:System.Threading.Tasks.Task%601.Result%2A> property throws an <xref:System.AggregateException> exception.</span></span> <span data-ttu-id="5e6fb-160">Tomuto problému se můžete vyhnout pomocí <xref:System.Threading.Tasks.TaskContinuationOptions.OnlyOnRanToCompletion> Možnosti, jak je znázorněno v následujícím příkladu.</span><span class="sxs-lookup"><span data-stu-id="5e6fb-160">You can avoid this problem by using the <xref:System.Threading.Tasks.TaskContinuationOptions.OnlyOnRanToCompletion> option, as shown in the following example.</span></span>

:::code language="csharp" source="snippets/cs/result1.cs":::

[!code-vb[TPL_Continuations#2](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_continuations/vb/result1.vb#2)]

<span data-ttu-id="5e6fb-161">Pokud chcete pokračovat v běhu i v případě, že předchůdce nebyl úspěšně dokončen, je nutné před výjimkou provést ochranu.</span><span class="sxs-lookup"><span data-stu-id="5e6fb-161">If you want the continuation to run even if the antecedent did not run to successful completion, you must guard against the exception.</span></span> <span data-ttu-id="5e6fb-162">Jedním z přístupů je otestování <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> vlastnosti předchůdce a pokus o přístup k vlastnosti pouze v <xref:System.Threading.Tasks.Task%601.Result%2A> případě, že stav není <xref:System.Threading.Tasks.TaskStatus.Faulted> nebo <xref:System.Threading.Tasks.TaskStatus.Canceled> .</span><span class="sxs-lookup"><span data-stu-id="5e6fb-162">One approach is to test the <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> property of the antecedent, and only attempt to access the <xref:System.Threading.Tasks.Task%601.Result%2A> property if the status is not <xref:System.Threading.Tasks.TaskStatus.Faulted> or <xref:System.Threading.Tasks.TaskStatus.Canceled>.</span></span> <span data-ttu-id="5e6fb-163">Můžete také prostudovat <xref:System.Threading.Tasks.Task.Exception%2A> vlastnost předchůdce.</span><span class="sxs-lookup"><span data-stu-id="5e6fb-163">You can also examine the <xref:System.Threading.Tasks.Task.Exception%2A> property of the antecedent.</span></span> <span data-ttu-id="5e6fb-164">Další informace naleznete v tématu [zpracování výjimek](exception-handling-task-parallel-library.md).</span><span class="sxs-lookup"><span data-stu-id="5e6fb-164">For more information, see [Exception Handling](exception-handling-task-parallel-library.md).</span></span> <span data-ttu-id="5e6fb-165">Následující příklad upravuje předchozí příklad pro přístup k vlastnosti předchůdce <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> pouze v případě, že je její stav <xref:System.Threading.Tasks.TaskStatus.RanToCompletion?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="5e6fb-165">The following example modifies the previous example to access antecedent's <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> property only if its status is <xref:System.Threading.Tasks.TaskStatus.RanToCompletion?displayProperty=nameWithType>.</span></span>

:::code language="csharp" source="snippets/cs/result2.cs":::

[!code-vb[TPL_Continuations#7](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_continuations/vb/result2.vb#7)]

## <a name="cancel-a-continuation"></a><span data-ttu-id="5e6fb-166">Zrušit pokračování</span><span class="sxs-lookup"><span data-stu-id="5e6fb-166">Cancel a continuation</span></span>

<span data-ttu-id="5e6fb-167"><xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType>Vlastnost pokračování je nastavena <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> v následujících situacích:</span><span class="sxs-lookup"><span data-stu-id="5e6fb-167">The <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> property of a continuation is set to <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> in the following situations:</span></span>

- <span data-ttu-id="5e6fb-168">Vyvolá <xref:System.OperationCanceledException> výjimku v reakci na žádost o zrušení.</span><span class="sxs-lookup"><span data-stu-id="5e6fb-168">It throws an <xref:System.OperationCanceledException> exception in response to a cancellation request.</span></span> <span data-ttu-id="5e6fb-169">Stejně jako u jakékoli úlohy, pokud výjimka obsahuje stejný token, který byl předán pokračování, je považována za potvrzení kooperativního zrušení.</span><span class="sxs-lookup"><span data-stu-id="5e6fb-169">As with any task, if the exception contains the same token that was passed to the continuation, it is treated as an acknowledgement of cooperative cancellation.</span></span>
- <span data-ttu-id="5e6fb-170">Pokračování je úspěšné, <xref:System.Threading.CancellationToken?displayProperty=nameWithType> jehož <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> vlastnost je `true` .</span><span class="sxs-lookup"><span data-stu-id="5e6fb-170">The continuation is passed a <xref:System.Threading.CancellationToken?displayProperty=nameWithType> whose <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> property is `true`.</span></span> <span data-ttu-id="5e6fb-171">V takovém případě se pokračování nespustí a přejde do <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> stavu.</span><span class="sxs-lookup"><span data-stu-id="5e6fb-171">In this case, the continuation does not start, and it transitions to the <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> state.</span></span>
- <span data-ttu-id="5e6fb-172">Pokračování se nikdy nespustí, protože podmínka nastavená podle jeho <xref:System.Threading.Tasks.TaskContinuationOptions> argumentu nebyla splněna.</span><span class="sxs-lookup"><span data-stu-id="5e6fb-172">The continuation never runs because the condition set by its <xref:System.Threading.Tasks.TaskContinuationOptions> argument was not met.</span></span> <span data-ttu-id="5e6fb-173">Například pokud předchůdce přejde do <xref:System.Threading.Tasks.TaskStatus.Faulted?displayProperty=nameWithType> stavu, jeho pokračování, které bylo předáno, se <xref:System.Threading.Tasks.TaskContinuationOptions.NotOnFaulted?displayProperty=nameWithType> nespustí, ale převede do <xref:System.Threading.Tasks.TaskStatus.Canceled> stavu.</span><span class="sxs-lookup"><span data-stu-id="5e6fb-173">For example, if an antecedent goes into a <xref:System.Threading.Tasks.TaskStatus.Faulted?displayProperty=nameWithType> state, its continuation that was passed the <xref:System.Threading.Tasks.TaskContinuationOptions.NotOnFaulted?displayProperty=nameWithType> option will not run but will transition to the <xref:System.Threading.Tasks.TaskStatus.Canceled> state.</span></span>

<span data-ttu-id="5e6fb-174">Pokud úloha a její pokračování reprezentují dvě části stejné logické operace, můžete stejný token zrušení předat oběma úkolům, jak je znázorněno v následujícím příkladu.</span><span class="sxs-lookup"><span data-stu-id="5e6fb-174">If a task and its continuation represent two parts of the same logical operation, you can pass the same cancellation token to both tasks, as shown in the following example.</span></span> <span data-ttu-id="5e6fb-175">Skládá se z předchůdce, který generuje seznam celých čísel, která jsou dělitelná 33, která je předána pokračování.</span><span class="sxs-lookup"><span data-stu-id="5e6fb-175">It consists of an antecedent that generates a list of integers that are divisible by 33, which it passes to the continuation.</span></span> <span data-ttu-id="5e6fb-176">Pokračování zobrazí seznam.</span><span class="sxs-lookup"><span data-stu-id="5e6fb-176">The continuation in turn displays the list.</span></span> <span data-ttu-id="5e6fb-177">Předchůdce i pokračování v pravidelných intervalech se v náhodných intervalech pozastaví.</span><span class="sxs-lookup"><span data-stu-id="5e6fb-177">Both the antecedent and the continuation pause regularly for random intervals.</span></span> <span data-ttu-id="5e6fb-178">Kromě toho <xref:System.Threading.Timer?displayProperty=nameWithType> se objekt používá ke spuštění `Elapsed` metody po pěti sekundách intervalu časového limitu.</span><span class="sxs-lookup"><span data-stu-id="5e6fb-178">In addition, a <xref:System.Threading.Timer?displayProperty=nameWithType> object is used to execute the `Elapsed` method after a five-second timeout interval.</span></span> <span data-ttu-id="5e6fb-179">Tento příklad volá <xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType> metodu, která způsobí, že aktuálně vykonávaná úloha volá <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> metodu.</span><span class="sxs-lookup"><span data-stu-id="5e6fb-179">This example calls the <xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType> method, which causes the currently executing task to call the <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="5e6fb-180">Určuje, zda <xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType> je metoda volána, když předchůdce nebo jeho pokračování probíhá, závisí na době trvání náhodně generovaných pozastavení.</span><span class="sxs-lookup"><span data-stu-id="5e6fb-180">Whether the <xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType> method is called when the antecedent or its continuation is executing depends on the duration of the randomly generated pauses.</span></span> <span data-ttu-id="5e6fb-181">Pokud je předchůdce zrušen, pokračování nebude zahájeno.</span><span class="sxs-lookup"><span data-stu-id="5e6fb-181">If the antecedent is canceled, the continuation will not start.</span></span> <span data-ttu-id="5e6fb-182">Pokud předchůdce není zrušen, token lze nadále použít k zrušení pokračování.</span><span class="sxs-lookup"><span data-stu-id="5e6fb-182">If the antecedent is not canceled, the token can still be used to cancel the continuation.</span></span>

:::code language="csharp" source="snippets/cs/cancellation1.cs":::

[!code-vb[TPL_Continuations#3](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_continuations/vb/cancellation1.vb#3)]

<span data-ttu-id="5e6fb-183">Můžete také zabránit spuštění pokračování, pokud je jeho předchůdce zrušen bez zadání pokračování tokenu zrušení zadáním <xref:System.Threading.Tasks.TaskContinuationOptions.NotOnCanceled?displayProperty=nameWithType> Možnosti při vytváření pokračování.</span><span class="sxs-lookup"><span data-stu-id="5e6fb-183">You can also prevent a continuation from executing if its antecedent is canceled without supplying the continuation a cancellation token by specifying the <xref:System.Threading.Tasks.TaskContinuationOptions.NotOnCanceled?displayProperty=nameWithType> option when you create the continuation.</span></span> <span data-ttu-id="5e6fb-184">Následuje jednoduchý příklad.</span><span class="sxs-lookup"><span data-stu-id="5e6fb-184">The following is a simple example.</span></span>

:::code language="csharp" source="snippets/cs/cancellation2.cs":::

[!code-vb[TPL_Continuations#8](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_continuations/vb/cancellation2.vb#8)]

<span data-ttu-id="5e6fb-185">Poté, co pokračování přejde do <xref:System.Threading.Tasks.TaskStatus.Canceled> stavu, může ovlivnit pokračování, která následují, v závislosti na <xref:System.Threading.Tasks.TaskContinuationOptions> tom, které byly pro tyto pokračování zadány.</span><span class="sxs-lookup"><span data-stu-id="5e6fb-185">After a continuation goes into the <xref:System.Threading.Tasks.TaskStatus.Canceled> state, it may affect continuations that follow, depending on the <xref:System.Threading.Tasks.TaskContinuationOptions> that were specified for those continuations.</span></span>

<span data-ttu-id="5e6fb-186">Pokračování, která jsou uvolněna, se nespustí.</span><span class="sxs-lookup"><span data-stu-id="5e6fb-186">Continuations that are disposed will not start.</span></span>

## <a name="continuations-and-child-tasks"></a><span data-ttu-id="5e6fb-187">Pokračování a podřízené úlohy</span><span class="sxs-lookup"><span data-stu-id="5e6fb-187">Continuations and child tasks</span></span>

<span data-ttu-id="5e6fb-188">Pokračování není spuštěno, dokud předchůdce a všechny jeho připojené podřízené úlohy nebyly dokončeny.</span><span class="sxs-lookup"><span data-stu-id="5e6fb-188">A continuation does not run until the antecedent and all of its attached child tasks have completed.</span></span> <span data-ttu-id="5e6fb-189">Pokračování nečeká na dokončení odpojených podřízených úloh.</span><span class="sxs-lookup"><span data-stu-id="5e6fb-189">The continuation does not wait for detached child tasks to finish.</span></span> <span data-ttu-id="5e6fb-190">Následující dva příklady ilustrují podřízené úlohy, které jsou připojeny k a odpojeny od předchůdce, který vytváří pokračování.</span><span class="sxs-lookup"><span data-stu-id="5e6fb-190">The following two examples illustrate child tasks that are attached to and detached from an antecedent that creates a continuation.</span></span> <span data-ttu-id="5e6fb-191">V následujícím příkladu se pokračování spustí až po dokončení všech podřízených úloh a spuštění příkladu několikrát vytvoří stejný výstup.</span><span class="sxs-lookup"><span data-stu-id="5e6fb-191">In the following example, the continuation runs only after all child tasks have completed, and running the example multiple times produces identical output each time.</span></span> <span data-ttu-id="5e6fb-192">V příkladu se spustí předchůdce voláním <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> metody, protože ve výchozím nastavení <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> Metoda vytvoří nadřazený úkol, jehož výchozí možnost vytvoření úlohy je <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="5e6fb-192">The example launches the antecedent by calling the <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> method, since by default the <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> method creates a parent task whose default task creation option is <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType>.</span></span>

:::code language="csharp" source="snippets/cs/attached1.cs":::

[!code-vb[TPL_Continuations#9](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_continuations/vb/attached1.vb#9)]

<span data-ttu-id="5e6fb-193">Pokud se ale podřízené úlohy odpojí od předchůdce, pokračování se spustí hned po ukončení předchůdce, a to bez ohledu na stav podřízených úloh.</span><span class="sxs-lookup"><span data-stu-id="5e6fb-193">If child tasks are detached from the antecedent, however, the continuation runs as soon as the antecedent has terminated, regardless of the state of the child tasks.</span></span> <span data-ttu-id="5e6fb-194">V důsledku toho může více spuštění z následujícího příkladu vytvořit proměnnou výstup, který závisí na tom, jak Plánovač úloh zpracoval každou podřízenou úlohu.</span><span class="sxs-lookup"><span data-stu-id="5e6fb-194">As a result, multiple runs of the following example can produce variable output that depends on how the task scheduler handled each child task.</span></span>

:::code language="csharp" source="snippets/cs/detached1.cs":::

[!code-vb[TPL_Continuations#10](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_continuations/vb/detached1.vb#10)]

<span data-ttu-id="5e6fb-195">Konečný stav předchozí úlohy závisí na konečném stavu všech připojených podřízených úloh.</span><span class="sxs-lookup"><span data-stu-id="5e6fb-195">The final status of the antecedent task depends on the final status of any attached child tasks.</span></span> <span data-ttu-id="5e6fb-196">Stav odpojených podřízených úloh nemá vliv na nadřazenou položku.</span><span class="sxs-lookup"><span data-stu-id="5e6fb-196">The status of detached child tasks does not affect the parent.</span></span> <span data-ttu-id="5e6fb-197">Další informace najdete v tématu [připojené a odpojené podřízené úlohy](attached-and-detached-child-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="5e6fb-197">For more information, see [Attached and Detached Child Tasks](attached-and-detached-child-tasks.md).</span></span>

## <a name="associate-state-with-continuations"></a><span data-ttu-id="5e6fb-198">Přidružit stav k pokračování</span><span class="sxs-lookup"><span data-stu-id="5e6fb-198">Associate state with continuations</span></span>

<span data-ttu-id="5e6fb-199">Můžete přidružit libovolný stav pokračování úlohy.</span><span class="sxs-lookup"><span data-stu-id="5e6fb-199">You can associate arbitrary state with a task continuation.</span></span> <span data-ttu-id="5e6fb-200"><xref:System.Threading.Tasks.Task.ContinueWith%2A>Metoda poskytuje přetížené verze, které každá z nich vezme <xref:System.Object> hodnotu, která představuje stav pokračování.</span><span class="sxs-lookup"><span data-stu-id="5e6fb-200">The <xref:System.Threading.Tasks.Task.ContinueWith%2A> method provides overloaded versions that each take an <xref:System.Object> value that represents the state of the continuation.</span></span> <span data-ttu-id="5e6fb-201">Později můžete přistupovat k tomuto objektu stavu pomocí <xref:System.Threading.Tasks.Task.AsyncState%2A?displayProperty=nameWithType> Vlastnosti.</span><span class="sxs-lookup"><span data-stu-id="5e6fb-201">You can later access this state object by using the <xref:System.Threading.Tasks.Task.AsyncState%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="5e6fb-202">Tento objekt stavu je `null` v případě, že nezadáte hodnotu.</span><span class="sxs-lookup"><span data-stu-id="5e6fb-202">This state object is `null` if you do not provide a value.</span></span>

<span data-ttu-id="5e6fb-203">Pokračování stavu je užitečné, pokud převedete existující kód, který používá [asynchronní programovací model (APM)](../asynchronous-programming-patterns/asynchronous-programming-model-apm.md) pro použití rozhraní TPL.</span><span class="sxs-lookup"><span data-stu-id="5e6fb-203">Continuation state is useful when you convert existing code that uses the [Asynchronous Programming Model (APM)](../asynchronous-programming-patterns/asynchronous-programming-model-apm.md) to use the TPL.</span></span> <span data-ttu-id="5e6fb-204">V APM obvykle poskytujete stav objektu v metodě **Begin**_metody_ a později získáte přístup k tomuto stavu pomocí <xref:System.IAsyncResult.AsyncState%2A?displayProperty=nameWithType> Vlastnosti.</span><span class="sxs-lookup"><span data-stu-id="5e6fb-204">In the APM, you typically provide object state in the **Begin**_Method_ method and later access that state by using the <xref:System.IAsyncResult.AsyncState%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="5e6fb-205">Pomocí <xref:System.Threading.Tasks.Task.ContinueWith%2A> metody můžete zachovat tento stav při převodu kódu, který používá APM k použití rozhraní TPL.</span><span class="sxs-lookup"><span data-stu-id="5e6fb-205">By using the <xref:System.Threading.Tasks.Task.ContinueWith%2A> method, you can preserve this state when you convert code that uses the APM to use the TPL.</span></span>

<span data-ttu-id="5e6fb-206">Stav pokračování může být užitečné také při práci s <xref:System.Threading.Tasks.Task> objekty v ladicím programu sady Visual Studio.</span><span class="sxs-lookup"><span data-stu-id="5e6fb-206">Continuation state can also be useful when you work with <xref:System.Threading.Tasks.Task> objects in the Visual Studio debugger.</span></span> <span data-ttu-id="5e6fb-207">Například v okně **Paralelní úlohy** zobrazuje sloupec **úkoly** řetězcovou reprezentaci objektu State pro každý úkol.</span><span class="sxs-lookup"><span data-stu-id="5e6fb-207">For example, in the **Parallel Tasks** window, the **Task** column displays the string representation of the state object for each task.</span></span> <span data-ttu-id="5e6fb-208">Další informace o okně **Paralelní úlohy** najdete v tématu [použití okna úlohy](/visualstudio/debugger/using-the-tasks-window).</span><span class="sxs-lookup"><span data-stu-id="5e6fb-208">For more information about the **Parallel Tasks** window, see [Using the Tasks Window](/visualstudio/debugger/using-the-tasks-window).</span></span>

<span data-ttu-id="5e6fb-209">Následující příklad ukazuje, jak použít stav pokračování.</span><span class="sxs-lookup"><span data-stu-id="5e6fb-209">The following example shows how to use continuation state.</span></span> <span data-ttu-id="5e6fb-210">Vytvoří řetězec pokračujících úloh.</span><span class="sxs-lookup"><span data-stu-id="5e6fb-210">It creates a chain of continuation tasks.</span></span> <span data-ttu-id="5e6fb-211">Každý úkol poskytuje aktuální čas, <xref:System.DateTime> objekt pro `state` parametr <xref:System.Threading.Tasks.Task.ContinueWith%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="5e6fb-211">Each task provides the current time, a <xref:System.DateTime> object, for the `state` parameter of the <xref:System.Threading.Tasks.Task.ContinueWith%2A> method.</span></span> <span data-ttu-id="5e6fb-212">Každý <xref:System.DateTime> objekt představuje čas, kdy je vytvořen úkol pokračování.</span><span class="sxs-lookup"><span data-stu-id="5e6fb-212">Each <xref:System.DateTime> object represents the time at which the continuation task is created.</span></span> <span data-ttu-id="5e6fb-213">Každý úkol vytváří jako výsledek druhý <xref:System.DateTime> objekt, který představuje čas, kdy se úkol dokončí.</span><span class="sxs-lookup"><span data-stu-id="5e6fb-213">Each task produces as its result a second <xref:System.DateTime> object that represents the time at which the task finishes.</span></span> <span data-ttu-id="5e6fb-214">Po dokončení všech úloh v tomto příkladu se zobrazí čas vytvoření a čas, kdy se Každá úloha pokračování dokončí.</span><span class="sxs-lookup"><span data-stu-id="5e6fb-214">After all tasks finish, this example displays the creation time and the time at which each continuation task finishes.</span></span>

:::code language="csharp" source="snippets/cs/continuationstate.cs":::

[!code-vb[TPL_ContinuationState#1](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_continuationstate/vb/continuationstate.vb#1)]

## <a name="continuations-that-return-task-types"></a><span data-ttu-id="5e6fb-215">Pokračování, která vracejí typy úloh</span><span class="sxs-lookup"><span data-stu-id="5e6fb-215">Continuations that return Task types</span></span>

<span data-ttu-id="5e6fb-216">Někdy možná budete muset zřetězit pokračování, které vrací <xref:System.Threading.Tasks.Task> typ.</span><span class="sxs-lookup"><span data-stu-id="5e6fb-216">Sometimes you may need to chain a continuation that returns a <xref:System.Threading.Tasks.Task> type.</span></span> <span data-ttu-id="5e6fb-217">Jsou označovány jako vnořené úlohy a jsou běžné.</span><span class="sxs-lookup"><span data-stu-id="5e6fb-217">These are referred to as nested tasks, and they are common.</span></span> <span data-ttu-id="5e6fb-218">Když nadřazený úkol volá <xref:System.Threading.Tasks.Task%601.ContinueWith%2A?displayProperty=nameWithType> a poskytuje `continuationFunction` , který úkol vrací volání, <xref:System.Threading.Tasks.TaskExtensions.Unwrap%2A> Vytvoření úlohy proxy, která představuje asynchronní operaci `<Task<Task<T>>>` nebo `Task(Of Task(Of T))` (Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="5e6fb-218">When a parent task calls <xref:System.Threading.Tasks.Task%601.ContinueWith%2A?displayProperty=nameWithType>, and provides a `continuationFunction` that is task returning you call <xref:System.Threading.Tasks.TaskExtensions.Unwrap%2A> to create a proxy task that represents the asynchronous operation of the `<Task<Task<T>>>` or `Task(Of Task(Of T))` (Visual Basic).</span></span>

<span data-ttu-id="5e6fb-219">Následující příklad ukazuje, jak používat pokračování, která zabalí další funkce vracející úkoly.</span><span class="sxs-lookup"><span data-stu-id="5e6fb-219">The following example shows how to use continuations that wrap additional task returning functions.</span></span> <span data-ttu-id="5e6fb-220">Každé pokračování lze rozbalením a vystavit vnitřní úkol, který byl zabalen.</span><span class="sxs-lookup"><span data-stu-id="5e6fb-220">Each continuation can be unwrapped, exposing the inner task that was wrapped.</span></span>

:::code language="csharp" source="snippets/cs/unwrap.cs":::
:::code language="csharp" source="snippets/vb/unwrap.vb":::

<span data-ttu-id="5e6fb-221">Další informace o použití naleznete <xref:System.Threading.Tasks.TaskExtensions.Unwrap%2A> v tématu [How to: Unwrap a vnořená úloha](how-to-unwrap-a-nested-task.md).</span><span class="sxs-lookup"><span data-stu-id="5e6fb-221">For more information on using <xref:System.Threading.Tasks.TaskExtensions.Unwrap%2A>, see [How to: Unwrap a nested Task](how-to-unwrap-a-nested-task.md).</span></span>

## <a name="handle-exceptions-thrown-from-continuations"></a><span data-ttu-id="5e6fb-222">Zpracování výjimek vyvolaných z pokračování</span><span class="sxs-lookup"><span data-stu-id="5e6fb-222">Handle exceptions thrown from continuations</span></span>

<span data-ttu-id="5e6fb-223">Vztah předchůdce-pokračování není relace typu nadřazený-podřízený.</span><span class="sxs-lookup"><span data-stu-id="5e6fb-223">An antecedent-continuation relationship is not a parent-child relationship.</span></span> <span data-ttu-id="5e6fb-224">Výjimky vyvolané pokračováním nejsou šířeny do předchůdce.</span><span class="sxs-lookup"><span data-stu-id="5e6fb-224">Exceptions thrown by continuations are not propagated to the antecedent.</span></span> <span data-ttu-id="5e6fb-225">Proto zpracujte výjimky vyvolané pokračováním, protože byste je měli zpracovat v jakékoli jiné úloze, a to následujícím způsobem:</span><span class="sxs-lookup"><span data-stu-id="5e6fb-225">Therefore, handle exceptions thrown by continuations as you would handle them in any other task, as follows:</span></span>

- <span data-ttu-id="5e6fb-226"><xref:System.Threading.Tasks.Task.Wait%2A> <xref:System.Threading.Tasks.Task.WaitAll%2A> <xref:System.Threading.Tasks.Task.WaitAny%2A> Pro čekání na pokračování lze použít metodu, nebo nebo její obecné protějšky.</span><span class="sxs-lookup"><span data-stu-id="5e6fb-226">You can use the <xref:System.Threading.Tasks.Task.Wait%2A>, <xref:System.Threading.Tasks.Task.WaitAll%2A>, or <xref:System.Threading.Tasks.Task.WaitAny%2A> method, or its generic counterpart, to wait on the continuation.</span></span> <span data-ttu-id="5e6fb-227">Můžete počkat na předchůdce a jeho pokračování v rámci stejného `try` příkazu, jak je znázorněno v následujícím příkladu.</span><span class="sxs-lookup"><span data-stu-id="5e6fb-227">You can wait for an antecedent and its continuations in the same `try` statement, as shown in the following example.</span></span>

:::code language="csharp" source="snippets/cs/exception1.cs":::

[!code-vb[TPL_Continuations#6](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_continuations/vb/exception1.vb#6)]

- <span data-ttu-id="5e6fb-228">Můžete použít druhé pokračování a sledovat <xref:System.Threading.Tasks.Task.Exception%2A> vlastnost prvního pokračování.</span><span class="sxs-lookup"><span data-stu-id="5e6fb-228">You can use a second continuation to observe the <xref:System.Threading.Tasks.Task.Exception%2A> property of the first continuation.</span></span> <span data-ttu-id="5e6fb-229">V následujícím příkladu se úloha pokusí o čtení z neexistujícího souboru.</span><span class="sxs-lookup"><span data-stu-id="5e6fb-229">In the following example, a task attempts to read from a non-existent file.</span></span> <span data-ttu-id="5e6fb-230">Pokračování potom zobrazí informace o výjimce v předchozí úloze.</span><span class="sxs-lookup"><span data-stu-id="5e6fb-230">The continuation then displays information about the exception in the antecedent task.</span></span>

:::code language="csharp" source="snippets/cs/exception2.cs" id="example":::

[!code-vb[TPL_Continuations#4](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_continuations/vb/exception2.vb#4)]

<span data-ttu-id="5e6fb-231">Vzhledem k tomu, že byl spuštěn s <xref:System.Threading.Tasks.TaskContinuationOptions.OnlyOnFaulted?displayProperty=nameWithType> možností, pokračování se spustí pouze v případě, že v předchůdci dojde k výjimce, a proto může předpokládat, že vlastnost předchůdce není <xref:System.Threading.Tasks.Task.Exception%2A> `null` .</span><span class="sxs-lookup"><span data-stu-id="5e6fb-231">Because it was run with the <xref:System.Threading.Tasks.TaskContinuationOptions.OnlyOnFaulted?displayProperty=nameWithType> option, the continuation executes only if an exception occurs in the antecedent, and therefore it can assume that the antecedent's <xref:System.Threading.Tasks.Task.Exception%2A> property is not `null`.</span></span> <span data-ttu-id="5e6fb-232">Pokud se pokračování provede bez ohledu na to, zda je výjimka vyvolána v předchůdci, bude nutné <xref:System.Threading.Tasks.Task.Exception%2A> před pokusem o zpracování výjimky ověřit, zda je vlastnost předchůdce `null` nepřed pokusem o zpracování výjimky, jak ukazuje následující fragment kódu.</span><span class="sxs-lookup"><span data-stu-id="5e6fb-232">If the continuation executes whether or not an exception is thrown in the antecedent, it would have to check whether the antecedent's <xref:System.Threading.Tasks.Task.Exception%2A> property is not `null` before attempting to handle the exception, as the following code fragment shows.</span></span>

:::code language="csharp" source="snippets/cs/exception2.cs" id="exception":::

[!code-vb[TPL_Continuations#11](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_continuations/vb/exception2.vb#11)]

<span data-ttu-id="5e6fb-233">Další informace naleznete v tématu [zpracování výjimek](exception-handling-task-parallel-library.md).</span><span class="sxs-lookup"><span data-stu-id="5e6fb-233">For more information, see [Exception Handling](exception-handling-task-parallel-library.md).</span></span>

- <span data-ttu-id="5e6fb-234">Pokud je pokračování připojená podřízená úloha, která byla vytvořena pomocí <xref:System.Threading.Tasks.TaskContinuationOptions.AttachedToParent?displayProperty=nameWithType> Možnosti, jejich výjimky budou rozšířeny nadřazeným objektem zpět do volajícího vlákna, jako je případ v jakémkoli jiném připojeném podřízeném prvku.</span><span class="sxs-lookup"><span data-stu-id="5e6fb-234">If the continuation is an attached child task that was created by using the <xref:System.Threading.Tasks.TaskContinuationOptions.AttachedToParent?displayProperty=nameWithType> option, its exceptions will be propagated by the parent back to the calling thread, as is the case in any other attached child.</span></span> <span data-ttu-id="5e6fb-235">Další informace najdete v tématu [připojené a odpojené podřízené úlohy](attached-and-detached-child-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="5e6fb-235">For more information, see [Attached and Detached Child Tasks](attached-and-detached-child-tasks.md).</span></span>

## <a name="see-also"></a><span data-ttu-id="5e6fb-236">Viz také:</span><span class="sxs-lookup"><span data-stu-id="5e6fb-236">See also</span></span>

- [<span data-ttu-id="5e6fb-237">Task Parallel Library (TPL)</span><span class="sxs-lookup"><span data-stu-id="5e6fb-237">Task Parallel Library (TPL)</span></span>](task-parallel-library-tpl.md)
