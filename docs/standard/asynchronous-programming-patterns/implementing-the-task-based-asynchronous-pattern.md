---
title: Implementace asynchronního vzoru založeného na úlohách
ms.date: 06/14/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- .NET Framework, and TAP
- asynchronous design patterns, .NET Framework
- TAP, .NET Framework support for
- Task-based Asynchronous Pattern, .NET Framework support for
- .NET Framework, asynchronous design patterns
ms.assetid: fab6bd41-91bd-44ad-86f9-d8319988aa78
author: rpetrusha
ms.author: ronpet
ms.openlocfilehash: 639a7ae4eb20cfc95f4d01dd0c7035f17656e3e1
ms.sourcegitcommit: c7f3e2e9d6ead6cc3acd0d66b10a251d0c66e59d
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 09/08/2018
ms.locfileid: "44207340"
---
# <a name="implementing-the-task-based-asynchronous-pattern"></a><span data-ttu-id="6be7e-102">Implementace asynchronního vzoru založeného na úlohách</span><span class="sxs-lookup"><span data-stu-id="6be7e-102">Implementing the Task-based Asynchronous Pattern</span></span>
<span data-ttu-id="6be7e-103">Asynchronní vzor založený na úkolech (TAP) můžete implementovat třemi způsoby: pomocí kompilátorů jazyka C# a Visual Basic v sadě Visual Studio, ručně nebo kombinací obou metod.</span><span class="sxs-lookup"><span data-stu-id="6be7e-103">You can implement the Task-based Asynchronous Pattern (TAP) in three ways: by using the C# and Visual Basic compilers in Visual Studio, manually, or through a combination of the compiler and manual methods.</span></span> <span data-ttu-id="6be7e-104">Jednotlivé metody jsou podrobně popsány v následujících částech.</span><span class="sxs-lookup"><span data-stu-id="6be7e-104">The following sections discuss each method in detail.</span></span> <span data-ttu-id="6be7e-105">Vzor TAP můžete implementovat výpočetní i vstupně-výstupní asynchronní operace.</span><span class="sxs-lookup"><span data-stu-id="6be7e-105">You can use the TAP pattern to implement both compute-bound and I/O-bound asynchronous operations.</span></span> <span data-ttu-id="6be7e-106">[Úlohy](#workloads) část popisuje každý typ provozu.</span><span class="sxs-lookup"><span data-stu-id="6be7e-106">The [Workloads](#workloads) section discusses each type of operation.</span></span>

## <a name="generating-tap-methods"></a><span data-ttu-id="6be7e-107">Generování metod TAP</span><span class="sxs-lookup"><span data-stu-id="6be7e-107">Generating TAP methods</span></span>

### <a name="using-the-compilers"></a><span data-ttu-id="6be7e-108">Pomocí kompilátorů</span><span class="sxs-lookup"><span data-stu-id="6be7e-108">Using the compilers</span></span>
<span data-ttu-id="6be7e-109">Počínaje [!INCLUDE[net_v45](../../../includes/net-v45-md.md)], jakoukoli metodu s atributem `async` – klíčové slovo (`Async` v jazyce Visual Basic) považována za asynchronní metodu a kompilátory C# a Visual Basic provádějí nezbytné transformace pro implementaci metody asynchronně pomocí vzoru TAP.</span><span class="sxs-lookup"><span data-stu-id="6be7e-109">Starting with [!INCLUDE[net_v45](../../../includes/net-v45-md.md)], any method that is attributed with the `async` keyword (`Async` in Visual Basic) is considered an asynchronous method, and the C# and Visual Basic compilers perform the necessary transformations to implement the method asynchronously by using TAP.</span></span> <span data-ttu-id="6be7e-110">Asynchronní metoda by měla vrátit buď objekt <xref:System.Threading.Tasks.Task?displayProperty=nameWithType>, nebo objekt <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="6be7e-110">An asynchronous method should return either a <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> or a <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> object.</span></span> <span data-ttu-id="6be7e-111">K tomu by měla vrátit tělo funkce `TResult`, a kompilátor pak zajistí, že tento výsledek je k dispozici prostřednictvím výsledného objektu úkolu.</span><span class="sxs-lookup"><span data-stu-id="6be7e-111">For the latter, the body of the function should return a `TResult`, and the compiler ensures that this result is made available through the resulting task object.</span></span> <span data-ttu-id="6be7e-112">Stejně tak veškeré výjimky, které nejsou zpracovány v těle metody, jsou zařazeny do výstupního úkolu, což způsobí, že výsledný úkol bude ukončen ve stavu <xref:System.Threading.Tasks.TaskStatus.Faulted?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="6be7e-112">Similarly, any exceptions that go unhandled within the body of the method are marshaled to the output task and cause the resulting task to end in the <xref:System.Threading.Tasks.TaskStatus.Faulted?displayProperty=nameWithType> state.</span></span> <span data-ttu-id="6be7e-113">Výjimkou je situace, kdy není zpracována výjimka typu <xref:System.OperationCanceledException> (nebo odvozeného typu). V takovém případě skončí výsledný úkol ve stavu <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="6be7e-113">The exception is when an <xref:System.OperationCanceledException> (or derived type) goes unhandled, in which case the resulting task ends in the <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> state.</span></span>

### <a name="generating-tap-methods-manually"></a><span data-ttu-id="6be7e-114">Ruční generování metod TAP</span><span class="sxs-lookup"><span data-stu-id="6be7e-114">Generating TAP methods manually</span></span>
<span data-ttu-id="6be7e-115">Vzor TAP můžete implementovat ručně a dosáhnout tak lepší kontroly nad implementací.</span><span class="sxs-lookup"><span data-stu-id="6be7e-115">You may implement the TAP pattern manually for better control over implementation.</span></span> <span data-ttu-id="6be7e-116">Kompilátor spoléhá na veřejnou oblast vystavenou z oboru názvů <xref:System.Threading.Tasks?displayProperty=nameWithType> s podporou typů v oboru názvů <xref:System.Runtime.CompilerServices?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="6be7e-116">The compiler relies on the public surface area exposed from the <xref:System.Threading.Tasks?displayProperty=nameWithType> namespace and supporting types in the <xref:System.Runtime.CompilerServices?displayProperty=nameWithType> namespace.</span></span> <span data-ttu-id="6be7e-117">Při vlastní implementaci vzoru TAP vytvoříte objekt <xref:System.Threading.Tasks.TaskCompletionSource%601>, provedete asynchronní operaci a po jejím dokončení zavoláte metodu <xref:System.Threading.Tasks.TaskCompletionSource%601.SetResult%2A>, <xref:System.Threading.Tasks.TaskCompletionSource%601.SetException%2A> nebo <xref:System.Threading.Tasks.TaskCompletionSource%601.SetCanceled%2A> anebo verzi `Try` jedné z těchto metod.</span><span class="sxs-lookup"><span data-stu-id="6be7e-117">To implement the TAP yourself, you create a <xref:System.Threading.Tasks.TaskCompletionSource%601> object, perform the asynchronous operation, and when it completes, call the <xref:System.Threading.Tasks.TaskCompletionSource%601.SetResult%2A>, <xref:System.Threading.Tasks.TaskCompletionSource%601.SetException%2A>, or <xref:System.Threading.Tasks.TaskCompletionSource%601.SetCanceled%2A> method, or the `Try` version of one of these methods.</span></span> <span data-ttu-id="6be7e-118">Při ruční implementaci metody TAP musíte dokončit výsledný úkol po dokončení zastoupené asynchronní operace.</span><span class="sxs-lookup"><span data-stu-id="6be7e-118">When you implement a TAP method manually, you must complete the resulting task when the represented asynchronous operation completes.</span></span> <span data-ttu-id="6be7e-119">Příklad:</span><span class="sxs-lookup"><span data-stu-id="6be7e-119">For example:</span></span>

[!code-csharp[Conceptual.TAP_Patterns#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap_patterns/cs/patterns1.cs#1)]
[!code-vb[Conceptual.TAP_Patterns#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap_patterns/vb/patterns1.vb#1)]

### <a name="hybrid-approach"></a><span data-ttu-id="6be7e-120">Hybridní přístup</span><span class="sxs-lookup"><span data-stu-id="6be7e-120">Hybrid approach</span></span>
 <span data-ttu-id="6be7e-121">Pravděpodobně pro vás bude užitečné, pokud implementujete vzor TAP ručně, ale delegujete základní logiku pro implementaci na kompilátor.</span><span class="sxs-lookup"><span data-stu-id="6be7e-121">You may find it useful to implement the TAP pattern manually but to delegate the core logic for the implementation to the compiler.</span></span> <span data-ttu-id="6be7e-122">Hybridní přístup budete pravděpodobně uplatňovat při ověřování argumentů mimo kompilátorem generovanou asynchronní metodu tak, aby výjimky mohly namísto vystavení prostřednictvím objektu <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> uniknout přímému volajícímu metody:</span><span class="sxs-lookup"><span data-stu-id="6be7e-122">For example, you may want to use the hybrid approach when you want to verify arguments outside a compiler-generated asynchronous method so that exceptions can escape to the method’s direct caller rather than being exposed through the <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> object:</span></span>

 [!code-csharp[Conceptual.TAP_Patterns#2](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap_patterns/cs/patterns1.cs#2)]
 [!code-vb[Conceptual.TAP_Patterns#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap_patterns/vb/patterns1.vb#2)]

 <span data-ttu-id="6be7e-123">Dalším užitečným použitím takového delegování je implementace optimalizace rychlé cesty a vrácení úkolu v mezipaměti.</span><span class="sxs-lookup"><span data-stu-id="6be7e-123">Another case where such delegation is useful is when you're implementing fast-path optimization and want to return a cached task.</span></span>

## <a name="workloads"></a><span data-ttu-id="6be7e-124">Úkoly</span><span class="sxs-lookup"><span data-stu-id="6be7e-124">Workloads</span></span>
<span data-ttu-id="6be7e-125">Jako metody TAP lze implementovat výpočetní i vstupně-výstupní asynchronní operace.</span><span class="sxs-lookup"><span data-stu-id="6be7e-125">You may implement both compute-bound and I/O-bound asynchronous operations as TAP methods.</span></span> <span data-ttu-id="6be7e-126">Jsou-li však metody TAP vystaveny veřejně z knihovny, měly by být poskytnuty pouze pro úkoly, které se týkají vstupně-výstupních operací (mohou také zahrnovat výpočet, ale neměly by být čistě výpočetní).</span><span class="sxs-lookup"><span data-stu-id="6be7e-126">However, when TAP methods are exposed publicly from a library, they should be provided only for workloads that involve I/O-bound operations (they may also involve computation, but should not be purely computational).</span></span> <span data-ttu-id="6be7e-127">Pokud je metoda čistě výpočetní, měla by být vystavena pouze jako synchronní implementace.</span><span class="sxs-lookup"><span data-stu-id="6be7e-127">If a method is purely compute-bound, it should be exposed only as a synchronous implementation.</span></span> <span data-ttu-id="6be7e-128">Kód, který ji využívá, pak se rozhodnout, jestli se má zabalit vyvolání této synchronní metody do úkolu pro snížení zatížení využitím do jiného vlákna nebo za účelem dosažení paralelismu.</span><span class="sxs-lookup"><span data-stu-id="6be7e-128">The code that consumes it may then choose whether to wrap an invocation of that synchronous method into a task to offload the work to another thread or to achieve parallelism.</span></span> <span data-ttu-id="6be7e-129">A pokud je metoda vstupně-výstupní, měla by být vystavena pouze jako asynchronní provádění.</span><span class="sxs-lookup"><span data-stu-id="6be7e-129">And if a method is I/O-bound, it should be exposed only as an asynchronous implementation.</span></span>

### <a name="compute-bound-tasks"></a><span data-ttu-id="6be7e-130">Výpočetní úkoly</span><span class="sxs-lookup"><span data-stu-id="6be7e-130">Compute-bound tasks</span></span>
<span data-ttu-id="6be7e-131">Třída <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> je nejvhodnější pro zastoupení výpočetně náročných operací.</span><span class="sxs-lookup"><span data-stu-id="6be7e-131">The <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> class is ideally suited for representing computationally intensive operations.</span></span> <span data-ttu-id="6be7e-132">Ve výchozím nastavení využívá speciální podporu v rámci třídy <xref:System.Threading.ThreadPool> za účelem poskytování účinného provádění a zároveň poskytuje významnou kontrolu nad tím, kdy, kde a jakým způsobem lze provádět asynchronní výpočty.</span><span class="sxs-lookup"><span data-stu-id="6be7e-132">By default, it takes advantage of special support within the <xref:System.Threading.ThreadPool> class to provide efficient execution, and it also provides significant control over when, where, and how asynchronous computations execute.</span></span>

<span data-ttu-id="6be7e-133">Výpočetní úkoly můžete generovat následujícími způsoby:</span><span class="sxs-lookup"><span data-stu-id="6be7e-133">You can generate compute-bound tasks in the following ways:</span></span>

- <span data-ttu-id="6be7e-134">V rozhraní .NET Framework 4 použijte metodu <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType>, jež přijímá delegát (obvykle typu <xref:System.Action%601> nebo <xref:System.Func%601>), který se provádí asynchronně.</span><span class="sxs-lookup"><span data-stu-id="6be7e-134">In the .NET Framework 4, use the <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> method, which accepts a delegate (typically an <xref:System.Action%601> or a <xref:System.Func%601>) to be executed asynchronously.</span></span> <span data-ttu-id="6be7e-135">Pokud poskytnete delegát typu <xref:System.Action%601>, vrátí metoda objekt <xref:System.Threading.Tasks.Task?displayProperty=nameWithType>, který představuje asynchronní provádění tohoto delegátu.</span><span class="sxs-lookup"><span data-stu-id="6be7e-135">If you provide an <xref:System.Action%601> delegate, the method returns a <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> object that represents the asynchronous execution of that delegate.</span></span> <span data-ttu-id="6be7e-136">Pokud zadáte delegát typu <xref:System.Func%601>, vrátí metoda objekt <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="6be7e-136">If you provide a <xref:System.Func%601> delegate, the method returns a <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> object.</span></span> <span data-ttu-id="6be7e-137">Přetížení metody <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> přijímá token zrušení (<xref:System.Threading.CancellationToken>), možnosti vytvoření úkolu (<xref:System.Threading.Tasks.TaskCreationOptions>) a plánovač úkolů (<xref:System.Threading.Tasks.TaskScheduler>), které poskytují detailní kontrolu nad plánováním a prováděním úkolu.</span><span class="sxs-lookup"><span data-stu-id="6be7e-137">Overloads of the <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> method accept a cancellation token (<xref:System.Threading.CancellationToken>), task creation options (<xref:System.Threading.Tasks.TaskCreationOptions>), and a task scheduler (<xref:System.Threading.Tasks.TaskScheduler>), all of which provide fine-grained control over the scheduling and execution of the task.</span></span> <span data-ttu-id="6be7e-138">Instance objektu pro vytváření úkolů, která je určena pro aktuální plánovač úkolů, je k dispozici jako statická vlastnost (<xref:System.Threading.Tasks.Task.Factory%2A>) třídy <xref:System.Threading.Tasks.Task>, například `Task.Factory.StartNew(…)`.</span><span class="sxs-lookup"><span data-stu-id="6be7e-138">A factory instance that targets the current task scheduler is available as a static property (<xref:System.Threading.Tasks.Task.Factory%2A>) of the <xref:System.Threading.Tasks.Task> class; for example: `Task.Factory.StartNew(…)`.</span></span>

- <span data-ttu-id="6be7e-139">V [!INCLUDE[net_v45](../../../includes/net-v45-md.md)] a novější verze (včetně .NET Core a .NET Standard), použít statické <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> metody jako zástupce <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="6be7e-139">In the [!INCLUDE[net_v45](../../../includes/net-v45-md.md)] and later versions (including .NET Core and .NET Standard), use the static <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> method as a shortcut to <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="6be7e-140">Metodu <xref:System.Threading.Tasks.Task.Run%2A> můžete použít pro snadné spouštění výpočetního úkolu, který se zaměřuje na fond vláken.</span><span class="sxs-lookup"><span data-stu-id="6be7e-140">You may use <xref:System.Threading.Tasks.Task.Run%2A> to easily launch a compute-bound task that targets the thread pool.</span></span> <span data-ttu-id="6be7e-141">V [!INCLUDE[net_v45](../../../includes/net-v45-md.md)] a novějších verzích se jedná o upřednostňovaný postup spuštění výpočetního úkolu.</span><span class="sxs-lookup"><span data-stu-id="6be7e-141">In the [!INCLUDE[net_v45](../../../includes/net-v45-md.md)] and later versions, this is the preferred mechanism for launching a compute-bound task.</span></span> <span data-ttu-id="6be7e-142">Použití `StartNew` přímo pouze pokud budete chtít jemněji odstupňovanou kontrolu nad tímto úkolem.</span><span class="sxs-lookup"><span data-stu-id="6be7e-142">Use `StartNew` directly only when you want more fine-grained control over the task.</span></span>

- <span data-ttu-id="6be7e-143">Pokud chcete generovat a plánovat úkol samostatně, použijte konstruktory typu `Task` nebo metodu `Start`.</span><span class="sxs-lookup"><span data-stu-id="6be7e-143">Use the constructors of the `Task` type or the `Start` method if you want to generate and schedule the task separately.</span></span> <span data-ttu-id="6be7e-144">Veřejné metody smí vracet pouze úkoly, které již byly zahájeny.</span><span class="sxs-lookup"><span data-stu-id="6be7e-144">Public methods must only return tasks that have already been started.</span></span>

- <span data-ttu-id="6be7e-145">Použijte přetížení metody <xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="6be7e-145">Use the overloads of the <xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="6be7e-146">Tato metoda vytvoří nový úkol, jehož spuštění je naplánováno po dokončení jiného úkolu.</span><span class="sxs-lookup"><span data-stu-id="6be7e-146">This method creates a new task that is scheduled when another task completes.</span></span> <span data-ttu-id="6be7e-147">Některá přetížení <xref:System.Threading.Tasks.Task.ContinueWith%2A> přijímají token zrušení, možnosti pokračování a plánovač úkolů pro lepší kontrolu nad plánováním a prováděním úkolu pokračování.</span><span class="sxs-lookup"><span data-stu-id="6be7e-147">Some of the <xref:System.Threading.Tasks.Task.ContinueWith%2A> overloads accept a cancellation token, continuation options, and a task scheduler for better control over the scheduling and execution of the continuation task.</span></span>

- <span data-ttu-id="6be7e-148">Použití <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A?displayProperty=nameWithType> a <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAny%2A?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="6be7e-148">Use the <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A?displayProperty=nameWithType> and <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAny%2A?displayProperty=nameWithType> methods.</span></span> <span data-ttu-id="6be7e-149">Tyto metody vytvoří nový úkol, který je naplánován na dobu, kdy skončí všechny nebo libovolná zadaná sada úkolů.</span><span class="sxs-lookup"><span data-stu-id="6be7e-149">These methods create a new task that is scheduled when all or any of a supplied set of tasks completes.</span></span> <span data-ttu-id="6be7e-150">Tyto metody poskytují také přetížení k řízení plánování a provádění těchto úkolů.</span><span class="sxs-lookup"><span data-stu-id="6be7e-150">These methods also provide overloads to control the scheduling and execution of these tasks.</span></span>

<span data-ttu-id="6be7e-151">V případě výpočetních úkolů může systém zabránit spuštění naplánovaného úkolu, pokud obdrží požadavek na zrušení před spuštěním úkolu.</span><span class="sxs-lookup"><span data-stu-id="6be7e-151">In compute-bound tasks, the system can prevent the execution of a scheduled task if it receives a cancellation request before it starts running the task.</span></span> <span data-ttu-id="6be7e-152">Pokud je takto poskytován token zrušení (<xref:System.Threading.CancellationToken>), můžete tento token předat asynchronnímu kódu, který tento token sleduje.</span><span class="sxs-lookup"><span data-stu-id="6be7e-152">As such, if you provide a cancellation token (<xref:System.Threading.CancellationToken> object), you can pass that token to the asynchronous code that monitors the token.</span></span> <span data-ttu-id="6be7e-153">Token můžete také poskytnout jedné z výše uvedených metod, jako je `StartNew` nebo `Run`, aby modul runtime typu `Task` mohl tento token také sledovat.</span><span class="sxs-lookup"><span data-stu-id="6be7e-153">You can also provide the token to one of the previously mentioned methods such as `StartNew` or `Run` so that the `Task` runtime may also monitor the token.</span></span>

<span data-ttu-id="6be7e-154">Zvažte například asynchronní metodu, která vytváří obrázek.</span><span class="sxs-lookup"><span data-stu-id="6be7e-154">For example, consider an asynchronous method that renders an image.</span></span> <span data-ttu-id="6be7e-155">Tělo úkolu může dotazovat token zrušení tak, aby se kód mohl předčasně ukončit, pokud bude požadavek na zrušení doručen během vykreslování.</span><span class="sxs-lookup"><span data-stu-id="6be7e-155">The body of the task can poll the cancellation token so that the code may exit early if a cancellation request arrives during rendering.</span></span> <span data-ttu-id="6be7e-156">Pokud bude navíc požadavek na zrušení doručen před spuštěním vykreslování, budete chtít zabránit operaci vykreslování:</span><span class="sxs-lookup"><span data-stu-id="6be7e-156">In addition, if the cancellation request arrives before rendering starts, you'll want to prevent the rendering operation:</span></span>

[!code-csharp[Conceptual.TAP_Patterns#3](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap_patterns/cs/patterns1.cs#3)]
[!code-vb[Conceptual.TAP_Patterns#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap_patterns/vb/patterns1.vb#3)]

<span data-ttu-id="6be7e-157">Výpočetní úkoly skončí ve stavu <xref:System.Threading.Tasks.TaskStatus.Canceled>, pokud je splněna alespoň jedna z následujících podmínek:</span><span class="sxs-lookup"><span data-stu-id="6be7e-157">Compute-bound tasks end in a <xref:System.Threading.Tasks.TaskStatus.Canceled> state if at least one of the following conditions is true:</span></span>

- <span data-ttu-id="6be7e-158">Dříve než úkol přejde do stavu <xref:System.Threading.CancellationToken>, je požadavek na zrušení doručen prostřednictvím objektu `StartNew`, který je k dispozici ve formě argumentu metody vytváření (například metody `Run` nebo <xref:System.Threading.Tasks.TaskStatus.Running>).</span><span class="sxs-lookup"><span data-stu-id="6be7e-158">A cancellation request arrives through the <xref:System.Threading.CancellationToken> object, which is provided as an argument to the creation method (for example, `StartNew` or `Run`) before the task transitions to the <xref:System.Threading.Tasks.TaskStatus.Running> state.</span></span>

- <span data-ttu-id="6be7e-159">Výjimka <xref:System.OperationCanceledException> zůstane v těle takového úkolu nezpracovaná. Tato výjimka obsahuje stejný token <xref:System.Threading.CancellationToken>, který je předán úkolu. Tento token dokazuje, že je požadováno zrušení.</span><span class="sxs-lookup"><span data-stu-id="6be7e-159">An <xref:System.OperationCanceledException> exception goes unhandled within the body of such a task, that exception contains the same <xref:System.Threading.CancellationToken> that is passed to the task, and that token shows that cancellation is requested.</span></span>

<span data-ttu-id="6be7e-160">Pokud uvnitř těla úkolu zůstane další nezpracovaná výjimka, skončí tento úkol ve stavu <xref:System.Threading.Tasks.TaskStatus.Faulted> a pokusy o čekání na úkol nebo přístup k výsledku úkolu způsobí vyvolání výjimky.</span><span class="sxs-lookup"><span data-stu-id="6be7e-160">If another exception goes unhandled within the body of the task, the task ends in the <xref:System.Threading.Tasks.TaskStatus.Faulted> state, and any attempts to wait on the task or access its result causes an exception to be thrown.</span></span>

### <a name="io-bound-tasks"></a><span data-ttu-id="6be7e-161">Vstupně-výstupní úlohy</span><span class="sxs-lookup"><span data-stu-id="6be7e-161">I/O-bound tasks</span></span>
<span data-ttu-id="6be7e-162">Chcete-li vytvořit úkol, pro který by po celou dobu provádění nemělo existovat podkladové vlákno, použijte typ <xref:System.Threading.Tasks.TaskCompletionSource%601>.</span><span class="sxs-lookup"><span data-stu-id="6be7e-162">To create a task that should not be directly backed by a thread for the entirety of its execution, use the <xref:System.Threading.Tasks.TaskCompletionSource%601> type.</span></span> <span data-ttu-id="6be7e-163">Tento typ vystavuje vlastnost <xref:System.Threading.Tasks.TaskCompletionSource%601.Task%2A>, která vrací přidruženou instanci typu <xref:System.Threading.Tasks.Task%601>.</span><span class="sxs-lookup"><span data-stu-id="6be7e-163">This type exposes a <xref:System.Threading.Tasks.TaskCompletionSource%601.Task%2A> property that returns an associated <xref:System.Threading.Tasks.Task%601> instance.</span></span> <span data-ttu-id="6be7e-164">Životní cyklus tohoto úkolu je řízen metodami typu <xref:System.Threading.Tasks.TaskCompletionSource%601>, jako jsou <xref:System.Threading.Tasks.TaskCompletionSource%601.SetResult%2A>, <xref:System.Threading.Tasks.TaskCompletionSource%601.SetException%2A>, <xref:System.Threading.Tasks.TaskCompletionSource%601.SetCanceled%2A>, a jejich variantami `TrySet`.</span><span class="sxs-lookup"><span data-stu-id="6be7e-164">The life cycle of this task is controlled by <xref:System.Threading.Tasks.TaskCompletionSource%601> methods such as <xref:System.Threading.Tasks.TaskCompletionSource%601.SetResult%2A>, <xref:System.Threading.Tasks.TaskCompletionSource%601.SetException%2A>, <xref:System.Threading.Tasks.TaskCompletionSource%601.SetCanceled%2A>, and their `TrySet` variants.</span></span>

<span data-ttu-id="6be7e-165">Předpokládejte, že chcete vytvořit úkol, který bude dokončen po určitém časovém období.</span><span class="sxs-lookup"><span data-stu-id="6be7e-165">Let's say that you want to create a task that will complete after a specified period of time.</span></span> <span data-ttu-id="6be7e-166">Například budete chtít odložit aktivitu v uživatelském rozhraní na pozdější dobu.</span><span class="sxs-lookup"><span data-stu-id="6be7e-166">For example, you may want to delay an activity in the user interface.</span></span> <span data-ttu-id="6be7e-167">Třída <xref:System.Threading.Timer?displayProperty=nameWithType> již poskytuje schopnost asynchronního vyvolání delegátu po zadaném časovém intervalu a pomocí typu <xref:System.Threading.Tasks.TaskCompletionSource%601> lze umístit typ <xref:System.Threading.Tasks.Task%601> před časovač, například:</span><span class="sxs-lookup"><span data-stu-id="6be7e-167">The <xref:System.Threading.Timer?displayProperty=nameWithType> class already provides the ability to asynchronously invoke a delegate after a specified period of time, and by using <xref:System.Threading.Tasks.TaskCompletionSource%601> you can put a <xref:System.Threading.Tasks.Task%601> front on the timer, for example:</span></span>

[!code-csharp[Conceptual.TAP_Patterns#4](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap_patterns/cs/patterns1.cs#4)]
[!code-vb[Conceptual.TAP_Patterns#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap_patterns/vb/patterns1.vb#4)]

<span data-ttu-id="6be7e-168">Počínaje rozhraním [!INCLUDE[net_v45](../../../includes/net-v45-md.md)] je pro tento účel k dispozici metoda <xref:System.Threading.Tasks.Task.Delay%2A?displayProperty=nameWithType> a lze ji používat uvnitř jiné asynchronní metody, například k implementaci smyčky asynchronního dotazování:</span><span class="sxs-lookup"><span data-stu-id="6be7e-168">Starting with the [!INCLUDE[net_v45](../../../includes/net-v45-md.md)], the <xref:System.Threading.Tasks.Task.Delay%2A?displayProperty=nameWithType> method is provided for this purpose, and you can use it inside another asynchronous method, for example, to implement an asynchronous polling loop:</span></span>

[!code-csharp[Conceptual.TAP_Patterns#5](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap_patterns/cs/patterns1.cs#5)]
[!code-vb[Conceptual.TAP_Patterns#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap_patterns/vb/patterns1.vb#5)]

<span data-ttu-id="6be7e-169">Třída <xref:System.Threading.Tasks.TaskCompletionSource%601> nemá neobecný protějšek.</span><span class="sxs-lookup"><span data-stu-id="6be7e-169">The <xref:System.Threading.Tasks.TaskCompletionSource%601> class doesn't have a non-generic counterpart.</span></span> <span data-ttu-id="6be7e-170">Typ <xref:System.Threading.Tasks.Task%601> je však odvozen od typu <xref:System.Threading.Tasks.Task>, takže obecný objekt <xref:System.Threading.Tasks.TaskCompletionSource%601> můžete použít pro vstupně-výstupní metody, které jednoduše vrátí úkol.</span><span class="sxs-lookup"><span data-stu-id="6be7e-170">However, <xref:System.Threading.Tasks.Task%601> derives from <xref:System.Threading.Tasks.Task>, so you can use the generic <xref:System.Threading.Tasks.TaskCompletionSource%601> object for I/O-bound methods that simply return a task.</span></span> <span data-ttu-id="6be7e-171">Chcete-li tuto operaci provést, můžete použít prostředek s fiktivním typem `TResult` (<xref:System.Boolean> je dobrá výchozí volba, ale pokud se obáváte, že uživatel typu <xref:System.Threading.Tasks.Task> ji bude přetypovávat dolů na typ <xref:System.Threading.Tasks.Task%601>, lze namísto toho použít privátní typ `TResult`).</span><span class="sxs-lookup"><span data-stu-id="6be7e-171">To do this, you can use a source with a dummy `TResult` (<xref:System.Boolean> is a good default choice, but if you're concerned about the user of the <xref:System.Threading.Tasks.Task> downcasting it to a <xref:System.Threading.Tasks.Task%601>, you can use a private `TResult` type instead).</span></span> <span data-ttu-id="6be7e-172">Například metoda `Delay` v předchozím příkladu vrátí aktuální čas s výsledným posunem (`Task<DateTimeOffset>`).</span><span class="sxs-lookup"><span data-stu-id="6be7e-172">For example, the `Delay` method in the previous example returns the current time along with the resulting offset (`Task<DateTimeOffset>`).</span></span> <span data-ttu-id="6be7e-173">Pokud je výsledná hodnota nepotřebná, může být metoda kódována spíše takto (všimněte si změny návratového typu a změny argumentu na hodnotu <xref:System.Threading.Tasks.TaskCompletionSource%601.TrySetResult%2A>):</span><span class="sxs-lookup"><span data-stu-id="6be7e-173">If such a result value is unnecessary, the method could instead be coded as follows (note the change of return type and the change of argument to <xref:System.Threading.Tasks.TaskCompletionSource%601.TrySetResult%2A>):</span></span>

[!code-csharp[Conceptual.TAP_Patterns#6](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap_patterns/cs/patterns1.cs#6)]
[!code-vb[Conceptual.TAP_Patterns#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap_patterns/vb/patterns1.vb#6)]

### <a name="mixed-compute-bound-and-io-bound-tasks"></a><span data-ttu-id="6be7e-174">Smíšené výpočetní a vstupně-výstupní úlohy</span><span class="sxs-lookup"><span data-stu-id="6be7e-174">Mixed compute-bound and I/O-bound tasks</span></span>
<span data-ttu-id="6be7e-175">Asynchronní metody nejsou omezeny pouze na výpočetní nebo vstupně-výstupní operace, ale mohou představovat kombinaci obou metod.</span><span class="sxs-lookup"><span data-stu-id="6be7e-175">Asynchronous methods are not limited to just compute-bound or I/O-bound operations but may represent a mixture of the two.</span></span> <span data-ttu-id="6be7e-176">Ve skutečnosti je větší počet asynchronních operací často sloučen do větších smíšených operací.</span><span class="sxs-lookup"><span data-stu-id="6be7e-176">In fact, multiple asynchronous operations are often combined into larger mixed operations.</span></span> <span data-ttu-id="6be7e-177">Například metoda `RenderAsync` v předchozím příkladu provedla výpočetně náročnou operaci za účelem vykreslení obrázku na základě vstupu proměnné `imageData`.</span><span class="sxs-lookup"><span data-stu-id="6be7e-177">For example, the `RenderAsync` method in a previous example performed a computationally intensive operation to render an image based on some input `imageData`.</span></span> <span data-ttu-id="6be7e-178">Zdrojem této proměnné `imageData` může být webová služba s asynchronním přístupem:</span><span class="sxs-lookup"><span data-stu-id="6be7e-178">This `imageData` could come from a web service that you asynchronously access:</span></span>

[!code-csharp[Conceptual.TAP_Patterns#7](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap_patterns/cs/patterns1.cs#7)]
[!code-vb[Conceptual.TAP_Patterns#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap_patterns/vb/patterns1.vb#7)]

<span data-ttu-id="6be7e-179">Tento příklad také znázorňuje, jakým způsobem lze jeden token zrušení zřetězit prostřednictvím několika asynchronních operací.</span><span class="sxs-lookup"><span data-stu-id="6be7e-179">This example also demonstrates how a single cancellation token may be threaded through multiple asynchronous operations.</span></span> <span data-ttu-id="6be7e-180">Další informace najdete v části zrušení využití v [využívání Task-based Asynchronous Pattern](../../../docs/standard/asynchronous-programming-patterns/consuming-the-task-based-asynchronous-pattern.md).</span><span class="sxs-lookup"><span data-stu-id="6be7e-180">For more information, see the cancellation usage section in [Consuming the Task-based Asynchronous Pattern](../../../docs/standard/asynchronous-programming-patterns/consuming-the-task-based-asynchronous-pattern.md).</span></span>

## <a name="see-also"></a><span data-ttu-id="6be7e-181">Viz také:</span><span class="sxs-lookup"><span data-stu-id="6be7e-181">See also</span></span>

- [<span data-ttu-id="6be7e-182">Asynchronní vzor založený na úlohách (TAP)</span><span class="sxs-lookup"><span data-stu-id="6be7e-182">Task-based Asynchronous Pattern (TAP)</span></span>](../../../docs/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md)  
- [<span data-ttu-id="6be7e-183">Použití asynchronního vzoru založeného na úlohách</span><span class="sxs-lookup"><span data-stu-id="6be7e-183">Consuming the Task-based Asynchronous Pattern</span></span>](../../../docs/standard/asynchronous-programming-patterns/consuming-the-task-based-asynchronous-pattern.md)  
- [<span data-ttu-id="6be7e-184">Interoperabilita s jinými asynchronními vzory a typy</span><span class="sxs-lookup"><span data-stu-id="6be7e-184">Interop with Other Asynchronous Patterns and Types</span></span>](../../../docs/standard/asynchronous-programming-patterns/interop-with-other-asynchronous-patterns-and-types.md)  
