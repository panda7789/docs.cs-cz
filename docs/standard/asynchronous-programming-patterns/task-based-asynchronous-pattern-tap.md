---
title: Asynchronní vzor založený na úlohách (TAP)
ms.date: 02/26/2019
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- .NET Framework, and TAP
- asynchronous design patterns, .NET Framework
- TAP, .NET Framework support for
- Task-based Asynchronous Pattern, .NET Framework support for
- .NET Framework, asynchronous design patterns
ms.assetid: 8cef1fcf-6f9f-417c-b21f-3fd8bac75007
ms.openlocfilehash: 89c486618729c334bf74f0a1f4f9dd1b3cee8b0e
ms.sourcegitcommit: 00aa62e2f469c2272a457b04e66b4cc3c97a800b
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 02/28/2020
ms.locfileid: "78158165"
---
# <a name="task-based-asynchronous-pattern-tap"></a><span data-ttu-id="c3b4a-102">Asynchronní vzor založený na úlohách (klepnutím)</span><span class="sxs-lookup"><span data-stu-id="c3b4a-102">Task-based asynchronous pattern (TAP)</span></span>
<span data-ttu-id="c3b4a-103">Asynchronní vzor založený na úlohách (klepněte) je založen na <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> a <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> typech v oboru názvů <xref:System.Threading.Tasks?displayProperty=nameWithType>, které slouží k reprezentaci libovolných asynchronních operací.</span><span class="sxs-lookup"><span data-stu-id="c3b4a-103">The Task-based Asynchronous Pattern (TAP) is based on the <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> and <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> types in the <xref:System.Threading.Tasks?displayProperty=nameWithType> namespace, which are used to represent arbitrary asynchronous operations.</span></span> <span data-ttu-id="c3b4a-104">TAP je doporučený asynchronní návrh vzoru pro nový vývoj.</span><span class="sxs-lookup"><span data-stu-id="c3b4a-104">TAP is the recommended asynchronous design pattern for new development.</span></span>  
  
## <a name="naming-parameters-and-return-types"></a><span data-ttu-id="c3b4a-105">Pojmenovávání, parametry a návratové typy</span><span class="sxs-lookup"><span data-stu-id="c3b4a-105">Naming, parameters, and return types</span></span>

<span data-ttu-id="c3b4a-106">TAP používá jedinou metodu k reprezentaci zahájení a dokončení asynchronní operace.</span><span class="sxs-lookup"><span data-stu-id="c3b4a-106">TAP uses a single method to represent the initiation and completion of an asynchronous operation.</span></span> <span data-ttu-id="c3b4a-107">To se liší od vzoru asynchronního programovacího modelu (APM nebo `IAsyncResult`) a asynchronního vzoru založeného na událostech (EAP).</span><span class="sxs-lookup"><span data-stu-id="c3b4a-107">This contrasts with both the Asynchronous Programming Model (APM or `IAsyncResult`) pattern and the Event-based Asynchronous Pattern (EAP).</span></span> <span data-ttu-id="c3b4a-108">APM vyžaduje `Begin` a `End` metody.</span><span class="sxs-lookup"><span data-stu-id="c3b4a-108">APM requires `Begin` and `End` methods.</span></span> <span data-ttu-id="c3b4a-109">Protokol EAP vyžaduje metodu, která má příponu `Async` a také vyžaduje jednu nebo více událostí, typy delegátů obslužné rutiny události a typy odvozené od `EventArg`.</span><span class="sxs-lookup"><span data-stu-id="c3b4a-109">EAP requires a method that has the `Async` suffix and also requires one or more events, event handler delegate types, and `EventArg`-derived types.</span></span> <span data-ttu-id="c3b4a-110">Asynchronní metody v klepnutím zahrnují příponu `Async` za názvem operace pro metody, které vracejí neočekávané typy, například <xref:System.Threading.Tasks.Task>, <xref:System.Threading.Tasks.Task%601>, <xref:System.Threading.Tasks.ValueTask>a <xref:System.Threading.Tasks.ValueTask%601>.</span><span class="sxs-lookup"><span data-stu-id="c3b4a-110">Asynchronous methods in TAP include the `Async` suffix after the operation name for methods that return awaitable types, such as <xref:System.Threading.Tasks.Task>, <xref:System.Threading.Tasks.Task%601>, <xref:System.Threading.Tasks.ValueTask>, and <xref:System.Threading.Tasks.ValueTask%601>.</span></span> <span data-ttu-id="c3b4a-111">Například asynchronní operace `Get`, která vrací `Task<String>`, může být pojmenována `GetAsync`.</span><span class="sxs-lookup"><span data-stu-id="c3b4a-111">For example, an asynchronous `Get` operation that returns a `Task<String>` can be named `GetAsync`.</span></span> <span data-ttu-id="c3b4a-112">Pokud přidáváte metodu klepněte na třídu, která již obsahuje název metody EAP s příponou `Async`, použijte místo toho příponu `TaskAsync`.</span><span class="sxs-lookup"><span data-stu-id="c3b4a-112">If you're adding a TAP method to a class that already contains an EAP method name with the `Async` suffix, use the suffix `TaskAsync` instead.</span></span> <span data-ttu-id="c3b4a-113">Například pokud třída již má metodu `GetAsync`, použijte název `GetTaskAsync`.</span><span class="sxs-lookup"><span data-stu-id="c3b4a-113">For example, if the class already has a `GetAsync` method, use the name `GetTaskAsync`.</span></span> <span data-ttu-id="c3b4a-114">Pokud metoda spustí asynchronní operaci, ale nevrátí očekávaný typ, jeho název by měl začínat `Begin`, `Start`nebo některé jiné operace, aby bylo možné navrhnout, že tato metoda nevrací nebo nevyvolává výsledek operace.</span><span class="sxs-lookup"><span data-stu-id="c3b4a-114">If a method starts an asynchronous operation but does not return an awaitable type, its name should start with `Begin`, `Start`, or some other verb to suggest that this method does not return or throw the result of the operation.</span></span>  
  
 <span data-ttu-id="c3b4a-115">Metoda klepnutí vrátí buď <xref:System.Threading.Tasks.Task?displayProperty=nameWithType>, nebo <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType>, na základě toho, zda odpovídající synchronní metoda vrátí typ void nebo typ `TResult`.</span><span class="sxs-lookup"><span data-stu-id="c3b4a-115">A TAP method returns either a <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> or a <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType>, based on whether the corresponding synchronous method returns void or a type `TResult`.</span></span>  
  
 <span data-ttu-id="c3b4a-116">Parametry metody klepnutí by měly odpovídat parametrům jeho synchronního protějšku a měly by být zadány ve stejném pořadí.</span><span class="sxs-lookup"><span data-stu-id="c3b4a-116">The parameters of a TAP method should match the parameters of its synchronous counterpart and should be provided in the same order.</span></span>  <span data-ttu-id="c3b4a-117">Parametry `out` a `ref` však nejsou z tohoto pravidla vyňaty a je třeba se jim vyhnout zcela.</span><span class="sxs-lookup"><span data-stu-id="c3b4a-117">However, `out` and `ref` parameters are exempt from this rule and should be avoided entirely.</span></span> <span data-ttu-id="c3b4a-118">Všechna data, která by byla vrácena pomocí `out` nebo `ref` parametru, by měla být vrácena jako součást `TResult` vrácená <xref:System.Threading.Tasks.Task%601>a měla by použít řazenou kolekci členů nebo vlastní datovou strukturu pro přizpůsobení více hodnot.</span><span class="sxs-lookup"><span data-stu-id="c3b4a-118">Any data that would have been returned through an `out` or `ref` parameter should instead be returned as part of the `TResult` returned by <xref:System.Threading.Tasks.Task%601>, and should use a tuple or a custom data structure to accommodate multiple values.</span></span> <span data-ttu-id="c3b4a-119">Měli byste také zvážit přidání parametru <xref:System.Threading.CancellationToken> i v případě, že se synchronní protějšek metody klepnutí na ni nenabídne.</span><span class="sxs-lookup"><span data-stu-id="c3b4a-119">You should also consider adding a <xref:System.Threading.CancellationToken> parameter even if the TAP method's synchronous counterpart does not offer one.</span></span>

 <span data-ttu-id="c3b4a-120">Metody, které jsou odčleněny výhradně na vytváření, manipulaci nebo kombinaci úloh (kde je asynchronní záměr metody jasný v názvu metody nebo v názvu typu, ke kterému patří metoda), nemusí následovat po tomto vzoru názvů. Tyto metody jsou často označovány jako *kombinátory*.</span><span class="sxs-lookup"><span data-stu-id="c3b4a-120">Methods that are devoted exclusively to the creation, manipulation, or combination of tasks (where the asynchronous intent of the method is clear in the method name or in the name of the type to which the method belongs) need not follow this naming pattern; such methods are often referred to as *combinators*.</span></span> <span data-ttu-id="c3b4a-121">Příklady kombinátory zahrnují <xref:System.Threading.Tasks.Task.WhenAll%2A> a <xref:System.Threading.Tasks.Task.WhenAny%2A>a jsou popsány v tématu [použití integrovaného oddílu založeného na úlohách kombinátory](../../../docs/standard/asynchronous-programming-patterns/consuming-the-task-based-asynchronous-pattern.md#combinators) článku, který [spotřebovává asynchronní vzor založený na úlohách](../../../docs/standard/asynchronous-programming-patterns/consuming-the-task-based-asynchronous-pattern.md).</span><span class="sxs-lookup"><span data-stu-id="c3b4a-121">Examples of combinators include <xref:System.Threading.Tasks.Task.WhenAll%2A> and <xref:System.Threading.Tasks.Task.WhenAny%2A>, and are discussed in the [Using the Built-in Task-based Combinators](../../../docs/standard/asynchronous-programming-patterns/consuming-the-task-based-asynchronous-pattern.md#combinators) section of the article [Consuming the Task-based Asynchronous Pattern](../../../docs/standard/asynchronous-programming-patterns/consuming-the-task-based-asynchronous-pattern.md).</span></span>  
  
 <span data-ttu-id="c3b4a-122">Příklady, jak se syntaxe klepnutí liší od syntaxe používané v zastaralých asynchronních vzorech programování, jako je asynchronní programovací model (APM) a asynchronní vzor založený na událostech (EAP), naleznete v tématu [asynchronní programovací vzory](../../../docs/standard/asynchronous-programming-patterns/index.md).</span><span class="sxs-lookup"><span data-stu-id="c3b4a-122">For examples of how the TAP syntax differs from the syntax used in legacy asynchronous programming patterns such as the Asynchronous Programming Model (APM) and the Event-based Asynchronous Pattern (EAP), see [Asynchronous Programming Patterns](../../../docs/standard/asynchronous-programming-patterns/index.md).</span></span>  
  
## <a name="initiating-an-asynchronous-operation"></a><span data-ttu-id="c3b4a-123">Inicializace asynchronní operace</span><span class="sxs-lookup"><span data-stu-id="c3b4a-123">Initiating an asynchronous operation</span></span>  
 <span data-ttu-id="c3b4a-124">Asynchronní metoda, která je založena na TAP, zvládne malé množství práce synchronně, například validaci argumentů a spouštění asynchronní operace před vrácením výsledné úlohy.</span><span class="sxs-lookup"><span data-stu-id="c3b4a-124">An asynchronous method that is based on TAP can do a small amount of work synchronously, such as validating arguments and initiating the asynchronous operation, before it returns the resulting task.</span></span> <span data-ttu-id="c3b4a-125">Synchronní práce by měly být neustále udržovány na minimu, aby asynchronní metody mohly vracet rychle.</span><span class="sxs-lookup"><span data-stu-id="c3b4a-125">Synchronous work should be kept to the minimum so the asynchronous method can return quickly.</span></span> <span data-ttu-id="c3b4a-126">Mezi důvody pro rychlý návrat patří:</span><span class="sxs-lookup"><span data-stu-id="c3b4a-126">Reasons for a quick return include the following:</span></span>  
  
- <span data-ttu-id="c3b4a-127">Asynchronní metody mohou být vyvolány z vlákna uživatelského rozhraní (UI) a dlouhotrvající synchronní práce může mít negativní dopad na odezvu aplikace.</span><span class="sxs-lookup"><span data-stu-id="c3b4a-127">Asynchronous methods may be invoked from user interface (UI) threads, and any long-running synchronous work could harm the responsiveness of the application.</span></span>  
  
- <span data-ttu-id="c3b4a-128">Je možné spustit několik asynchronních metod současně.</span><span class="sxs-lookup"><span data-stu-id="c3b4a-128">Multiple asynchronous methods may be launched concurrently.</span></span> <span data-ttu-id="c3b4a-129">Proto by jakékoli dlouhotrvající práce v synchronní části asynchronní metody mohly zpožďovat zahájení jiné asynchronní operace, a tím zmenšit výhody souběžnosti.</span><span class="sxs-lookup"><span data-stu-id="c3b4a-129">Therefore, any long-running work in the synchronous portion of an asynchronous method could delay the initiation of other asynchronous operations, thereby decreasing the benefits of concurrency.</span></span>  
  
 <span data-ttu-id="c3b4a-130">V některých případech je množství práce potřebné k dokončení operace menší než množství práce potřebné ke spuštění operace asynchronně.</span><span class="sxs-lookup"><span data-stu-id="c3b4a-130">In some cases, the amount of work required to complete the operation is less than the amount of work required to launch the operation asynchronously.</span></span> <span data-ttu-id="c3b4a-131">Příkladem takového scénáře je čtení z datového proudu, kde lze operaci čtení naplnit daty, která jsou již uložena do vyrovnávací paměti.</span><span class="sxs-lookup"><span data-stu-id="c3b4a-131">Reading from a stream where the read operation can be satisfied by data that is already buffered in memory is an example of such a scenario.</span></span> <span data-ttu-id="c3b4a-132">Operace v těchto případech může být dokončena synchronně a může vrátit úlohu, která již byla dokončena.</span><span class="sxs-lookup"><span data-stu-id="c3b4a-132">In such cases, the operation may complete synchronously, and may return a task that has already been completed.</span></span>  
  
## <a name="exceptions"></a><span data-ttu-id="c3b4a-133">Výjimky</span><span class="sxs-lookup"><span data-stu-id="c3b4a-133">Exceptions</span></span>  
 <span data-ttu-id="c3b4a-134">Asynchronní metoda by měla vyvolat výjimku z volání asynchronní metody pouze jako odpověď na chybu použití.</span><span class="sxs-lookup"><span data-stu-id="c3b4a-134">An asynchronous method should raise an exception to be thrown out of the asynchronous method call only in response to a usage error.</span></span> <span data-ttu-id="c3b4a-135">Chyby použití by se nikdy neměly objevit v produkčním kódu.</span><span class="sxs-lookup"><span data-stu-id="c3b4a-135">Usage errors should never occur in production code.</span></span> <span data-ttu-id="c3b4a-136">Například Pokud předáte odkaz s hodnotou null (`Nothing` v Visual Basic), protože jeden z argumentů metody způsobí chybový stav (obvykle reprezentovaný <xref:System.ArgumentNullException> výjimkou), můžete změnit volající kód, aby se zajistilo, že odkaz s hodnotou null není nikdy předán.</span><span class="sxs-lookup"><span data-stu-id="c3b4a-136">For example, if passing a null reference (`Nothing` in Visual Basic) as one of the method’s arguments causes an error state (usually represented by an <xref:System.ArgumentNullException> exception), you can modify the calling code to ensure that a null reference is never passed.</span></span> <span data-ttu-id="c3b4a-137">U všech ostatních chyb by měly být výjimky, ke kterým dochází při spuštění asynchronní metody, přiřazeny vrácené úloze i v případě, že se asynchronní metoda dokončí synchronně předtím, než je úloha vrácena.</span><span class="sxs-lookup"><span data-stu-id="c3b4a-137">For all other errors, exceptions that occur when an asynchronous method is running should be assigned to the returned task, even if the asynchronous method happens to complete synchronously before the task is returned.</span></span> <span data-ttu-id="c3b4a-138">Úloha obvykle obsahuje nanejvýš jednu výjimku.</span><span class="sxs-lookup"><span data-stu-id="c3b4a-138">Typically, a task contains at most one exception.</span></span> <span data-ttu-id="c3b4a-139">Pokud však úloha představuje více operací (například <xref:System.Threading.Tasks.Task.WhenAll%2A>), může být k jedné úloze přidruženo více výjimek.</span><span class="sxs-lookup"><span data-stu-id="c3b4a-139">However, if the task represents multiple operations (for example, <xref:System.Threading.Tasks.Task.WhenAll%2A>), multiple exceptions may be associated with a single task.</span></span>  
  
## <a name="target-environment"></a><span data-ttu-id="c3b4a-140">Cílové prostředí</span><span class="sxs-lookup"><span data-stu-id="c3b4a-140">Target environment</span></span>  
 <span data-ttu-id="c3b4a-141">Při implementaci metody TAP můžete určit, kde dochází k asynchronnímu spouštění.</span><span class="sxs-lookup"><span data-stu-id="c3b4a-141">When you implement a TAP method, you can determine where asynchronous execution occurs.</span></span> <span data-ttu-id="c3b4a-142">Úlohy můžete spouštět ve fondu vláken, implementovat je pomocí asynchronního I/O (bez vázání na vlákno pro většinu spuštění operace), spustit je na konkrétním vlákně (například vlákně UI) nebo použít libovolný počet potenciálních kontextů.</span><span class="sxs-lookup"><span data-stu-id="c3b4a-142">You may choose to execute the workload on the thread pool, implement it by using asynchronous I/O (without being bound to a thread for the majority of the operation’s execution), run it on a specific thread (such as the UI thread), or use any number of potential contexts.</span></span> <span data-ttu-id="c3b4a-143">Metoda klepnutí může dokonce mít nic ke spuštění a může vrátit <xref:System.Threading.Tasks.Task>, která představuje výskyt podmínky jinde v systému (například úkol, který představuje data přicházející do struktury dat zařazené do fronty).</span><span class="sxs-lookup"><span data-stu-id="c3b4a-143">A TAP method may even have nothing to execute, and may just return a <xref:System.Threading.Tasks.Task> that represents the occurrence of a condition elsewhere in the system (for example, a task that represents data arriving at a queued data structure).</span></span>

 <span data-ttu-id="c3b4a-144">Volající metody klepnutí může blokovat čekání na provedení metody klepnutí synchronním čekáním na výsledný úkol nebo může spustit další (pokračování) kód po dokončení asynchronní operace.</span><span class="sxs-lookup"><span data-stu-id="c3b4a-144">The caller of the TAP method may block waiting for the TAP method to complete by synchronously waiting on the resulting task, or may run additional (continuation) code when the asynchronous operation completes.</span></span> <span data-ttu-id="c3b4a-145">Tvůrce kódu pokračování má kontrolu nad tím, kde se spustí kód.</span><span class="sxs-lookup"><span data-stu-id="c3b4a-145">The creator of the continuation code has control over where that code executes.</span></span> <span data-ttu-id="c3b4a-146">Kód pro pokračování můžete vytvořit buď explicitně, prostřednictvím metod <xref:System.Threading.Tasks.Task> třídy (například <xref:System.Threading.Tasks.Task.ContinueWith%2A>) nebo implicitně pomocí jazykové podpory založené na pokračováních (například `await` v C#`Await` Visual Basic `AwaitValue` v F#).</span><span class="sxs-lookup"><span data-stu-id="c3b4a-146">You may create the continuation code either explicitly, through methods on the <xref:System.Threading.Tasks.Task> class (for example, <xref:System.Threading.Tasks.Task.ContinueWith%2A>) or implicitly, by using language support built on top of continuations (for example, `await` in C#, `Await` in Visual Basic, `AwaitValue` in F#).</span></span>  
  
## <a name="task-status"></a><span data-ttu-id="c3b4a-147">Stav úlohy</span><span class="sxs-lookup"><span data-stu-id="c3b4a-147">Task status</span></span>  
 <span data-ttu-id="c3b4a-148">Třída <xref:System.Threading.Tasks.Task> poskytuje životní cyklus pro asynchronní operace a tento cyklus je reprezentován výčtem <xref:System.Threading.Tasks.TaskStatus>.</span><span class="sxs-lookup"><span data-stu-id="c3b4a-148">The <xref:System.Threading.Tasks.Task> class provides a life cycle for asynchronous operations, and that cycle is represented by the <xref:System.Threading.Tasks.TaskStatus> enumeration.</span></span> <span data-ttu-id="c3b4a-149">Pro podporu rohových případů typů, které jsou odvozeny z <xref:System.Threading.Tasks.Task> a <xref:System.Threading.Tasks.Task%601>a pro podporu oddělení konstrukce od plánování, třída <xref:System.Threading.Tasks.Task> zpřístupňuje metodu <xref:System.Threading.Tasks.Task.Start%2A>.</span><span class="sxs-lookup"><span data-stu-id="c3b4a-149">To support corner cases of types that derive from <xref:System.Threading.Tasks.Task> and <xref:System.Threading.Tasks.Task%601>,  and to support the separation of construction from scheduling, the <xref:System.Threading.Tasks.Task> class exposes a <xref:System.Threading.Tasks.Task.Start%2A> method.</span></span> <span data-ttu-id="c3b4a-150">Úlohy, které jsou vytvořeny pomocí veřejných <xref:System.Threading.Tasks.Task> konstruktory, jsou označovány jako *studené úlohy*, protože začínají jejich životní cyklus v neplánovaném <xref:System.Threading.Tasks.TaskStatus.Created> stavu a jsou plánovány pouze v případě, že je na těchto instancích volána <xref:System.Threading.Tasks.Task.Start%2A>.</span><span class="sxs-lookup"><span data-stu-id="c3b4a-150">Tasks that are created by the public <xref:System.Threading.Tasks.Task> constructors are referred to as *cold tasks*, because they begin their life cycle in the non-scheduled <xref:System.Threading.Tasks.TaskStatus.Created> state and are scheduled only when <xref:System.Threading.Tasks.Task.Start%2A> is called on these instances.</span></span>

 <span data-ttu-id="c3b4a-151">Všechny ostatní úlohy zahájí svůj životní cyklus v horkém stavu, což znamená, že asynchronní operace, které představují, již byly iniciovány a jejich stav úlohy je jiná hodnota výčtu než <xref:System.Threading.Tasks.TaskStatus.Created?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="c3b4a-151">All other tasks begin their life cycle in a hot state, which means that the asynchronous operations they represent have already been initiated and their task status is an enumeration value other than <xref:System.Threading.Tasks.TaskStatus.Created?displayProperty=nameWithType>.</span></span> <span data-ttu-id="c3b4a-152">Všechny úlohy, které jsou vráceny z metod TAP, musí být aktivovány.</span><span class="sxs-lookup"><span data-stu-id="c3b4a-152">All tasks that are returned from TAP methods must be activated.</span></span> <span data-ttu-id="c3b4a-153">**Pokud metoda klepnutí interně používá konstruktor úkolu k vytvoření instance úkolu, který má být vrácen, metoda klepnutí musí volat <xref:System.Threading.Tasks.Task.Start%2A> na objektu <xref:System.Threading.Tasks.Task> před jeho vrácením.**</span><span class="sxs-lookup"><span data-stu-id="c3b4a-153">**If a TAP method internally uses a task’s constructor to instantiate the task to be returned, the TAP method must call <xref:System.Threading.Tasks.Task.Start%2A> on the <xref:System.Threading.Tasks.Task> object before returning it.**</span></span> <span data-ttu-id="c3b4a-154">Příjemci metody klepnutí můžou bezpečně předpokládat, že vrácená úloha je aktivní a neměla by se pokoušet o volání <xref:System.Threading.Tasks.Task.Start%2A> na všech <xref:System.Threading.Tasks.Task>, které se vrátí z metody klepnutí.</span><span class="sxs-lookup"><span data-stu-id="c3b4a-154">Consumers of a TAP method may safely assume that the returned task is active and should not try to call <xref:System.Threading.Tasks.Task.Start%2A> on any <xref:System.Threading.Tasks.Task> that is returned from a TAP method.</span></span> <span data-ttu-id="c3b4a-155">Volání <xref:System.Threading.Tasks.Task.Start%2A> na aktivní úloze má za následek výjimku <xref:System.InvalidOperationException>.</span><span class="sxs-lookup"><span data-stu-id="c3b4a-155">Calling <xref:System.Threading.Tasks.Task.Start%2A> on an active task results in an <xref:System.InvalidOperationException> exception.</span></span>  
  
## <a name="cancellation-optional"></a><span data-ttu-id="c3b4a-156">Zrušení (volitelné)</span><span class="sxs-lookup"><span data-stu-id="c3b4a-156">Cancellation (optional)</span></span>  
 <span data-ttu-id="c3b4a-157">Pro implementátory asynchronní metody i příjemce asynchronní metody je v TAP zrušení volitelné.</span><span class="sxs-lookup"><span data-stu-id="c3b4a-157">In TAP, cancellation is optional for both asynchronous method implementers and asynchronous method consumers.</span></span> <span data-ttu-id="c3b4a-158">Pokud operace umožňuje zrušení, zveřejňuje přetížení asynchronní metody, která přijímá token zrušení (<xref:System.Threading.CancellationToken> instance).</span><span class="sxs-lookup"><span data-stu-id="c3b4a-158">If an operation allows cancellation, it exposes an overload of the asynchronous method that accepts a cancellation token (<xref:System.Threading.CancellationToken> instance).</span></span> <span data-ttu-id="c3b4a-159">Podle konvence má parametr název `cancellationToken`.</span><span class="sxs-lookup"><span data-stu-id="c3b4a-159">By convention, the parameter is named `cancellationToken`.</span></span>  
  
 [!code-csharp[Conceptual.TAP#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap/cs/examples1.cs#1)]
 [!code-vb[Conceptual.TAP#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap/vb/examples1.vb#1)]  
  
 <span data-ttu-id="c3b4a-160">Asynchronní operace sleduje tento token kvůli žádostem o zrušení.</span><span class="sxs-lookup"><span data-stu-id="c3b4a-160">The asynchronous operation monitors this token for cancellation requests.</span></span> <span data-ttu-id="c3b4a-161">Pokud obdrží žádost o zrušení, může vyhovět žádosti a operaci zrušit.</span><span class="sxs-lookup"><span data-stu-id="c3b4a-161">If it receives a cancellation request, it may choose to honor that request and cancel the operation.</span></span> <span data-ttu-id="c3b4a-162">Pokud výsledkem požadavku na zrušení je předčasně ukončena práce, metoda klepnutí vrátí úlohu, která skončí ve stavu <xref:System.Threading.Tasks.TaskStatus.Canceled>. k dispozici není žádný výsledek a není vyvolána žádná výjimka.</span><span class="sxs-lookup"><span data-stu-id="c3b4a-162">If the cancellation request results in work being ended prematurely, the TAP method returns a task that ends in the <xref:System.Threading.Tasks.TaskStatus.Canceled> state; there is no available result and no exception is thrown.</span></span>  <span data-ttu-id="c3b4a-163"><xref:System.Threading.Tasks.TaskStatus.Canceled> stav se považuje za konečný (dokončený) stav úlohy společně s <xref:System.Threading.Tasks.TaskStatus.Faulted> a <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> stavy.</span><span class="sxs-lookup"><span data-stu-id="c3b4a-163">The <xref:System.Threading.Tasks.TaskStatus.Canceled> state is considered to be a final (completed) state for a task, along with the <xref:System.Threading.Tasks.TaskStatus.Faulted> and <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> states.</span></span> <span data-ttu-id="c3b4a-164">Proto pokud je úkol ve stavu <xref:System.Threading.Tasks.TaskStatus.Canceled>, jeho vlastnost <xref:System.Threading.Tasks.Task.IsCompleted%2A> vrátí `true`.</span><span class="sxs-lookup"><span data-stu-id="c3b4a-164">Therefore, if a task is in the <xref:System.Threading.Tasks.TaskStatus.Canceled> state, its <xref:System.Threading.Tasks.Task.IsCompleted%2A> property returns `true`.</span></span> <span data-ttu-id="c3b4a-165">Když se úloha dokončí ve stavu <xref:System.Threading.Tasks.TaskStatus.Canceled>, všechna pokračování zaregistrovaná v rámci úlohy se naplánují nebo spustí, pokud není možnost pokračování, jako je třeba <xref:System.Threading.Tasks.TaskContinuationOptions.NotOnCanceled>, nedošlo k odhlášení z pokračování.</span><span class="sxs-lookup"><span data-stu-id="c3b4a-165">When a task completes in the <xref:System.Threading.Tasks.TaskStatus.Canceled> state, any continuations registered with the task are scheduled or executed, unless a continuation option such as <xref:System.Threading.Tasks.TaskContinuationOptions.NotOnCanceled> was specified to opt out of continuation.</span></span> <span data-ttu-id="c3b4a-166">Jakýkoli kód, který asynchronně čeká na zrušený úkol prostřednictvím použití funkcí jazyka, pokračuje v běhu, ale přijímá <xref:System.OperationCanceledException> nebo výjimku z něj odvozenou.</span><span class="sxs-lookup"><span data-stu-id="c3b4a-166">Any code that is asynchronously waiting for a canceled task through use of language features continues to run but receives an <xref:System.OperationCanceledException> or an exception derived from it.</span></span> <span data-ttu-id="c3b4a-167">Kód, který je blokován synchronně čekáním na úlohu prostřednictvím metod, jako je například <xref:System.Threading.Tasks.Task.Wait%2A> a <xref:System.Threading.Tasks.Task.WaitAll%2A> také i nadále běžet s výjimkou.</span><span class="sxs-lookup"><span data-stu-id="c3b4a-167">Code that is blocked synchronously waiting on the task through methods such as <xref:System.Threading.Tasks.Task.Wait%2A> and <xref:System.Threading.Tasks.Task.WaitAll%2A> also continue to run with an exception.</span></span>  
  
 <span data-ttu-id="c3b4a-168">Pokud token zrušení požadoval zrušení před tím, než je volána metoda klepnutí, která přijímá tento token, metoda klepnutí by měla vrátit úlohu <xref:System.Threading.Tasks.TaskStatus.Canceled>.</span><span class="sxs-lookup"><span data-stu-id="c3b4a-168">If a cancellation token has requested cancellation before the TAP method that accepts that token is called, the TAP method should return a <xref:System.Threading.Tasks.TaskStatus.Canceled> task.</span></span>  <span data-ttu-id="c3b4a-169">Pokud je však požadováno zrušení při spuštěné asynchronní operaci, asynchronní operace nemusí přijmout žádost o zrušení.</span><span class="sxs-lookup"><span data-stu-id="c3b4a-169">However, if cancellation is requested while the asynchronous operation is running, the asynchronous operation need not accept the cancellation request.</span></span>  <span data-ttu-id="c3b4a-170">Vrácený úkol by měl končit ve stavu <xref:System.Threading.Tasks.TaskStatus.Canceled> pouze v případě, že operace skončí v důsledku požadavku na zrušení.</span><span class="sxs-lookup"><span data-stu-id="c3b4a-170">The returned task should end in the <xref:System.Threading.Tasks.TaskStatus.Canceled> state only if the operation ends as a result of the cancellation request.</span></span> <span data-ttu-id="c3b4a-171">Pokud je požadováno zrušení, ale výsledek nebo výjimka jsou stále vyprodukovány, úloha by měla skončit ve <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> nebo <xref:System.Threading.Tasks.TaskStatus.Faulted>m stavu.</span><span class="sxs-lookup"><span data-stu-id="c3b4a-171">If cancellation is requested but a result or an exception is still produced, the task should end in the <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> or <xref:System.Threading.Tasks.TaskStatus.Faulted> state.</span></span>

 <span data-ttu-id="c3b4a-172">Pro asynchronní metody, které chtějí vystavit možnost zrušit první a nejpřednější, nemusíte poskytovat přetížení, které nepřijímá token zrušení.</span><span class="sxs-lookup"><span data-stu-id="c3b4a-172">For asynchronous methods that want to expose the ability to be cancelled first and foremost, you don't have to provide an overload that doesn’t accept a cancellation token.</span></span> <span data-ttu-id="c3b4a-173">Pro metody, které nelze zrušit, neposkytujte přetížení, která přijímají token zrušení. To pomáhá volajícímu určit, zda je skutečně možné zrušit cílovou metodu.</span><span class="sxs-lookup"><span data-stu-id="c3b4a-173">For methods that cannot be canceled, do not provide overloads that accept a cancellation token; this helps indicate to the caller whether the target method is actually cancelable.</span></span>  <span data-ttu-id="c3b4a-174">Kód příjemce, který není žádoucí pro zrušení, může volat metodu, která přijímá <xref:System.Threading.CancellationToken> a jako hodnotu argumentu zadat <xref:System.Threading.CancellationToken.None%2A>.</span><span class="sxs-lookup"><span data-stu-id="c3b4a-174">Consumer code that does not desire cancellation may call a method that accepts a <xref:System.Threading.CancellationToken> and provide <xref:System.Threading.CancellationToken.None%2A> as the argument value.</span></span> <span data-ttu-id="c3b4a-175"><xref:System.Threading.CancellationToken.None%2A> je funkčně ekvivalentní výchozímu <xref:System.Threading.CancellationToken>.</span><span class="sxs-lookup"><span data-stu-id="c3b4a-175"><xref:System.Threading.CancellationToken.None%2A> is functionally equivalent to the default <xref:System.Threading.CancellationToken>.</span></span>  
  
## <a name="progress-reporting-optional"></a><span data-ttu-id="c3b4a-176">Vytváření sestav průběhu (volitelné)</span><span class="sxs-lookup"><span data-stu-id="c3b4a-176">Progress reporting (optional)</span></span>  
 <span data-ttu-id="c3b4a-177">Některé asynchronní operace těží z poskytování oznámení o průběhu. Ta se obvykle používají k aktualizaci uživatelského rozhraní informacemi o průběhu asynchronní operace.</span><span class="sxs-lookup"><span data-stu-id="c3b4a-177">Some asynchronous operations benefit from providing progress notifications; these are typically used to update a user interface with information about the progress of the asynchronous operation.</span></span>

 <span data-ttu-id="c3b4a-178">V klepněte, průběh je zpracován prostřednictvím rozhraní <xref:System.IProgress%601>, které je předáno asynchronní metodě jako parametr, který je obvykle pojmenován `progress`.</span><span class="sxs-lookup"><span data-stu-id="c3b4a-178">In TAP, progress is handled through an <xref:System.IProgress%601> interface, which is passed to the asynchronous method as a parameter that is usually named `progress`.</span></span>  <span data-ttu-id="c3b4a-179">Poskytnutí rozhraní průběhu při volání asynchronní metody pomáhá eliminovat konflikty časování, které jsou výsledkem nesprávného použití (to znamená, když obslužným rutinám, které jsou nesprávně zaregistrovány po zahájení operace, chybí aktualizace).</span><span class="sxs-lookup"><span data-stu-id="c3b4a-179">Providing the progress interface when the asynchronous method is called helps eliminate race conditions that result from incorrect usage (that is, when event handlers that are incorrectly registered after the operation starts may miss updates).</span></span>  <span data-ttu-id="c3b4a-180">Důležitější je, že rozhraní průběhu podporuje různé implementace průběhu podle náročnosti kódu.</span><span class="sxs-lookup"><span data-stu-id="c3b4a-180">More importantly, the progress interface supports varying implementations of progress, as determined by the consuming code.</span></span>  <span data-ttu-id="c3b4a-181">Náročný kód se bude například starat pouze o nejnovější aktualizaci průběhu nebo může chtít mít všechny aktualizace ve vyrovnávací paměti nebo může chtít vyvolat akci pro každou aktualizaci nebo může chtít řídit, zda je volání zařazeno do konkrétního vlákna.</span><span class="sxs-lookup"><span data-stu-id="c3b4a-181">For example, the consuming code may only care about the latest progress update, or may want to buffer all updates, or may want to invoke an action for each update, or may want to control whether the invocation is marshaled to a particular thread.</span></span> <span data-ttu-id="c3b4a-182">Všech těchto možností lze dosáhnout pomocí různých implementací rozhraní přizpůsobených potřebám konkrétního příjemce.</span><span class="sxs-lookup"><span data-stu-id="c3b4a-182">All these options may be achieved by using a different implementation of the interface, customized to the particular consumer’s needs.</span></span>  <span data-ttu-id="c3b4a-183">Stejně jako u zrušení, klepnutí na implementace by měly poskytnout parametr <xref:System.IProgress%601>, pouze pokud rozhraní API podporuje oznámení o průběhu.</span><span class="sxs-lookup"><span data-stu-id="c3b4a-183">As with cancellation, TAP implementations should provide an <xref:System.IProgress%601> parameter only if the API supports progress notifications.</span></span>

 <span data-ttu-id="c3b4a-184">Pokud například metoda `ReadAsync` popsaná výše v tomto článku dokáže podávat sestavy o mezilehlém pokroku ve formě počtu přečtených bajtů, může zpětné volání průběhu představovat <xref:System.IProgress%601> rozhraní:</span><span class="sxs-lookup"><span data-stu-id="c3b4a-184">For example, if the `ReadAsync` method discussed earlier in this article is able to report intermediate progress in the form of the number of bytes read thus far, the progress callback could be an <xref:System.IProgress%601> interface:</span></span>  
  
 [!code-csharp[Conceptual.TAP#2](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap/cs/examples1.cs#2)]
 [!code-vb[Conceptual.TAP#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap/vb/examples1.vb#2)]  
  
 <span data-ttu-id="c3b4a-185">Pokud metoda `FindFilesAsync` vrátí seznam všech souborů, které splňují konkrétní vzor hledání, zpětné volání průběhu může poskytnout odhad procentuální hodnoty dokončené práce a také aktuální sadu částečných výsledků.</span><span class="sxs-lookup"><span data-stu-id="c3b4a-185">If a `FindFilesAsync` method returns a list of all files that meet a particular search pattern, the progress callback could provide an estimate of the percentage of work completed as well as the current set of partial results.</span></span>  <span data-ttu-id="c3b4a-186">To může provést buď s uspořádanou n-ticí:</span><span class="sxs-lookup"><span data-stu-id="c3b4a-186">It could do this either with a tuple:</span></span>  
  
 [!code-csharp[Conceptual.TAP#3](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap/cs/examples1.cs#3)]
 [!code-vb[Conceptual.TAP#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap/vb/examples1.vb#3)]  
  
 <span data-ttu-id="c3b4a-187">nebo s datovým typem, který je specifický pro rozhraní API:</span><span class="sxs-lookup"><span data-stu-id="c3b4a-187">or with a data type that is specific to the API:</span></span>  
  
 [!code-csharp[Conceptual.TAP#4](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap/cs/examples1.cs#4)]
 [!code-vb[Conceptual.TAP#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap/vb/examples1.vb#4)]  
  
 <span data-ttu-id="c3b4a-188">V druhém případě je zvláštní datový typ obvykle `ProgressInfo`příponou.</span><span class="sxs-lookup"><span data-stu-id="c3b4a-188">In the latter case, the special data type is usually suffixed with `ProgressInfo`.</span></span>  
  
 <span data-ttu-id="c3b4a-189">Pokud klepnutím na implementace zadáte přetížení, která přijímají parametr `progress`, musí umožnit, aby byl argument `null`. v takovém případě se nebude hlásit žádný pokrok.</span><span class="sxs-lookup"><span data-stu-id="c3b4a-189">If TAP implementations provide overloads that accept a `progress` parameter, they must allow the argument to be `null`, in which case no progress will be reported.</span></span> <span data-ttu-id="c3b4a-190">Klepnutím na implementace by měl být průběh na objekt <xref:System.Progress%601> synchronně, což umožňuje asynchronní metodě rychle poskytnout průběh a umožnit spotřebiteli postup, jak určit, jak a kde nejlépe zpracovávat informace.</span><span class="sxs-lookup"><span data-stu-id="c3b4a-190">TAP implementations should report the progress to the <xref:System.Progress%601> object synchronously, which enables the asynchronous method to quickly provide progress, and allow the consumer of the progress to determine how and where best to handle the information.</span></span> <span data-ttu-id="c3b4a-191">Například instance průběhu může zvolit zařazování zpětných volání a vyvolat události na zachyceném synchronizačním kontextu.</span><span class="sxs-lookup"><span data-stu-id="c3b4a-191">For example, the progress instance could choose to marshal callbacks and raise events on a captured synchronization context.</span></span>  
  
## <a name="iprogresst-implementations"></a><span data-ttu-id="c3b4a-192">Implementace > IProgress\<T</span><span class="sxs-lookup"><span data-stu-id="c3b4a-192">IProgress\<T> implementations</span></span>  
 <span data-ttu-id="c3b4a-193">.NET Framework 4,5 poskytuje jednu <xref:System.IProgress%601> implementaci: <xref:System.Progress%601>.</span><span class="sxs-lookup"><span data-stu-id="c3b4a-193">The .NET Framework 4.5 provides a single <xref:System.IProgress%601> implementation: <xref:System.Progress%601>.</span></span> <span data-ttu-id="c3b4a-194">Třída <xref:System.Progress%601> je deklarována takto:</span><span class="sxs-lookup"><span data-stu-id="c3b4a-194">The <xref:System.Progress%601> class is declared as follows:</span></span>  
  
```csharp  
public class Progress<T> : IProgress<T>  
{  
    public Progress();  
    public Progress(Action<T> handler);  
    protected virtual void OnReport(T value);  
    public event EventHandler<T> ProgressChanged;  
}  
```  
  
```vb  
Public Class Progress(Of T) : Inherits IProgress(Of T)  
    Public Sub New()  
    Public Sub New(handler As Action(Of T))  
    Protected Overridable Sub OnReport(value As T)  
    Public Event ProgressChanged As EventHandler(Of T>  
End Class  
```  
  
 <span data-ttu-id="c3b4a-195">Instance <xref:System.Progress%601> zpřístupňuje událost <xref:System.Progress%601.ProgressChanged>, která je vyvolána pokaždé, když asynchronní operace ohlásí aktualizaci průběhu.</span><span class="sxs-lookup"><span data-stu-id="c3b4a-195">An instance of <xref:System.Progress%601> exposes a <xref:System.Progress%601.ProgressChanged> event, which is raised every time the asynchronous operation reports a progress update.</span></span> <span data-ttu-id="c3b4a-196">Událost <xref:System.Progress%601.ProgressChanged> je vyvolána na objektu <xref:System.Threading.SynchronizationContext>, který byl zachycen při vytváření instance <xref:System.Progress%601> instance.</span><span class="sxs-lookup"><span data-stu-id="c3b4a-196">The <xref:System.Progress%601.ProgressChanged> event is raised on the <xref:System.Threading.SynchronizationContext> object that was captured when the <xref:System.Progress%601> instance was instantiated.</span></span> <span data-ttu-id="c3b4a-197">Pokud nebyl k dispozici žádný kontext synchronizace, je použit výchozí kontext určený pro fond vláken.</span><span class="sxs-lookup"><span data-stu-id="c3b4a-197">If no synchronization context was available, a default context that targets the thread pool is used.</span></span> <span data-ttu-id="c3b4a-198">Pro tuto událost lze registrovat obslužné rutiny.</span><span class="sxs-lookup"><span data-stu-id="c3b4a-198">Handlers may be registered with this event.</span></span> <span data-ttu-id="c3b4a-199">Jedna obslužná rutina může být také poskytnuta konstruktoru <xref:System.Progress%601> pro usnadnění a chová se stejně jako obslužná rutina události <xref:System.Progress%601.ProgressChanged> událost.</span><span class="sxs-lookup"><span data-stu-id="c3b4a-199">A single handler may also be provided to the <xref:System.Progress%601> constructor for convenience, and behaves just like an event handler for the <xref:System.Progress%601.ProgressChanged> event.</span></span> <span data-ttu-id="c3b4a-200">Aktualizace průběhu jsou vyvolány asynchronně, aby se předešlo zpoždění asynchronní operace, zatímco se provádějí obslužné rutiny události.</span><span class="sxs-lookup"><span data-stu-id="c3b4a-200">Progress updates are raised asynchronously to avoid delaying the asynchronous operation while event handlers are executing.</span></span> <span data-ttu-id="c3b4a-201">Jiná implementace <xref:System.IProgress%601> by se mohla rozhodnout použít odlišnou sémantiku.</span><span class="sxs-lookup"><span data-stu-id="c3b4a-201">Another <xref:System.IProgress%601> implementation could choose to apply different semantics.</span></span>  
  
## <a name="choosing-the-overloads-to-provide"></a><span data-ttu-id="c3b4a-202">Výběr přetížení k poskytnutí</span><span class="sxs-lookup"><span data-stu-id="c3b4a-202">Choosing the overloads to provide</span></span>  
 <span data-ttu-id="c3b4a-203">Pokud implementace klepnutí používá volitelné <xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A> a volitelné <xref:System.IProgress%601> parametry, může potenciálně vyžadovat až čtyři přetížení:</span><span class="sxs-lookup"><span data-stu-id="c3b4a-203">If a TAP implementation uses both the optional <xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A> and optional <xref:System.IProgress%601> parameters, it could potentially require up to four overloads:</span></span>  
  
```csharp  
public Task MethodNameAsync(…);  
public Task MethodNameAsync(…, CancellationToken cancellationToken);  
public Task MethodNameAsync(…, IProgress<T> progress);
public Task MethodNameAsync(…,
    CancellationToken cancellationToken, IProgress<T> progress);  
```  
  
```vb  
Public MethodNameAsync(…) As Task  
Public MethodNameAsync(…, cancellationToken As CancellationToken cancellationToken) As Task  
Public MethodNameAsync(…, progress As IProgress(Of T)) As Task
Public MethodNameAsync(…, cancellationToken As CancellationToken,
                       progress As IProgress(Of T)) As Task  
```  
  
 <span data-ttu-id="c3b4a-204">Mnoho implementací TAP však neposkytuje funkce zrušení ani průběhu, takže vyžadují jedinou metodu:</span><span class="sxs-lookup"><span data-stu-id="c3b4a-204">However, many TAP implementations provide neither cancellation or progress capabilities, so they require a single method:</span></span>  
  
```csharp  
public Task MethodNameAsync(…);  
```  
  
```vb  
Public MethodNameAsync(…) As Task  
```  
  
 <span data-ttu-id="c3b4a-205">Pokud implementace TAP podporuje buď zrušení, nebo průběh, ale ne oboje, může poskytnout dvě přetížení:</span><span class="sxs-lookup"><span data-stu-id="c3b4a-205">If a TAP implementation supports either cancellation or progress but not both, it may provide two overloads:</span></span>  
  
```csharp  
public Task MethodNameAsync(…);  
public Task MethodNameAsync(…, CancellationToken cancellationToken);  
  
// … or …  
  
public Task MethodNameAsync(…);  
public Task MethodNameAsync(…, IProgress<T> progress);  
```  
  
```vb  
Public MethodNameAsync(…) As Task  
Public MethodNameAsync(…, cancellationToken As CancellationToken) As Task  
  
' … or …  
  
Public MethodNameAsync(…) As Task  
Public MethodNameAsync(…, progress As IProgress(Of T)) As Task  
```  
  
 <span data-ttu-id="c3b4a-206">Pokud implementace TAP podporuje zrušení i průběh, může poskytnout všechna čtyři přetížení.</span><span class="sxs-lookup"><span data-stu-id="c3b4a-206">If a TAP implementation supports both cancellation and progress, it may expose all four overloads.</span></span> <span data-ttu-id="c3b4a-207">Může však také poskytnout pouze dvě následující:</span><span class="sxs-lookup"><span data-stu-id="c3b4a-207">However, it may provide only the following two:</span></span>  
  
```csharp  
public Task MethodNameAsync(…);  
public Task MethodNameAsync(…,
    CancellationToken cancellationToken, IProgress<T> progress);  
```  
  
```vb  
Public MethodNameAsync(…) As Task  
Public MethodNameAsync(…, cancellationToken As CancellationToken,
                       progress As IProgress(Of T)) As Task  
```  
  
 <span data-ttu-id="c3b4a-208">Pro kompenzaci dvou chybějících mezilehlých kombinací můžou vývojáři předat <xref:System.Threading.CancellationToken.None%2A> nebo výchozí <xref:System.Threading.CancellationToken> pro parametr `cancellationToken` a `null` pro parametr `progress`.</span><span class="sxs-lookup"><span data-stu-id="c3b4a-208">To compensate for the two missing intermediate combinations, developers may pass <xref:System.Threading.CancellationToken.None%2A> or a default <xref:System.Threading.CancellationToken> for the `cancellationToken` parameter and `null` for the `progress` parameter.</span></span>  
  
 <span data-ttu-id="c3b4a-209">Pokud očekáváte, že každé použití metody TAP bude podporovat zrušení nebo průběh, můžete vynechat přetížení, které nepřijímá odpovídající parametr.</span><span class="sxs-lookup"><span data-stu-id="c3b4a-209">If you expect every usage of the TAP method to support cancellation or progress, you may omit the overloads that don’t accept the relevant parameter.</span></span>  
  
 <span data-ttu-id="c3b4a-210">Pokud se rozhodnete vystavit více přetížení, aby bylo zrušení nebo průběh volitelné, přetížení, která nepodporují zrušení nebo průběh, by se měla chovat, jako by byla předána <xref:System.Threading.CancellationToken.None%2A> pro zrušení nebo `null` pro průběh přetížení, který je podporuje.</span><span class="sxs-lookup"><span data-stu-id="c3b4a-210">If you decide to expose multiple overloads to make cancellation or progress optional, the overloads that don’t support cancellation or progress should behave as if they passed <xref:System.Threading.CancellationToken.None%2A> for cancellation or `null` for progress to the overload that does support these.</span></span>  
  
## <a name="related-topics"></a><span data-ttu-id="c3b4a-211">Související témata</span><span class="sxs-lookup"><span data-stu-id="c3b4a-211">Related topics</span></span>  
  
|<span data-ttu-id="c3b4a-212">Název</span><span class="sxs-lookup"><span data-stu-id="c3b4a-212">Title</span></span>|<span data-ttu-id="c3b4a-213">Popis</span><span class="sxs-lookup"><span data-stu-id="c3b4a-213">Description</span></span>|  
|-----------|-----------------|  
|[<span data-ttu-id="c3b4a-214">Vzory asynchronního programování</span><span class="sxs-lookup"><span data-stu-id="c3b4a-214">Asynchronous Programming Patterns</span></span>](../../../docs/standard/asynchronous-programming-patterns/index.md)|<span data-ttu-id="c3b4a-215">Zavádí tři vzory pro provádění asynchronních operací: synchronní vzor založený na úlohách (TAP), asynchronní programovací model (APM) a asynchronní vzor založený na událostech (EAP).</span><span class="sxs-lookup"><span data-stu-id="c3b4a-215">Introduces the three patterns for performing asynchronous operations: the Task-based Asynchronous Pattern (TAP), the Asynchronous Programming Model (APM), and the Event-based Asynchronous Pattern (EAP).</span></span>|  
|[<span data-ttu-id="c3b4a-216">Implementace asynchronního vzoru založeného na úlohách</span><span class="sxs-lookup"><span data-stu-id="c3b4a-216">Implementing the Task-based Asynchronous Pattern</span></span>](../../../docs/standard/asynchronous-programming-patterns/implementing-the-task-based-asynchronous-pattern.md)|<span data-ttu-id="c3b4a-217">Popisuje tři způsoby implementace asynchronního vzoru založeného na úlohách (TAP): pomocí kompilátorů jazyka C# a Visual Basic v sadě Visual Studio, ručně nebo kombinací obou metod.</span><span class="sxs-lookup"><span data-stu-id="c3b4a-217">Describes how to implement the Task-based Asynchronous Pattern (TAP) in three ways: by using the C# and Visual Basic compilers in Visual Studio, manually, or through a combination of the compiler and manual methods.</span></span>|  
|[<span data-ttu-id="c3b4a-218">Použití asynchronního vzoru založeného na úlohách</span><span class="sxs-lookup"><span data-stu-id="c3b4a-218">Consuming the Task-based Asynchronous Pattern</span></span>](../../../docs/standard/asynchronous-programming-patterns/consuming-the-task-based-asynchronous-pattern.md)|<span data-ttu-id="c3b4a-219">Popisuje, jak použít úlohy a zpětná volání k dosažení čekání bez blokování.</span><span class="sxs-lookup"><span data-stu-id="c3b4a-219">Describes how you can use tasks and callbacks to achieve waiting without blocking.</span></span>|  
|[<span data-ttu-id="c3b4a-220">Interoperabilita s jinými asynchronními vzory a typy</span><span class="sxs-lookup"><span data-stu-id="c3b4a-220">Interop with Other Asynchronous Patterns and Types</span></span>](../../../docs/standard/asynchronous-programming-patterns/interop-with-other-asynchronous-patterns-and-types.md)|<span data-ttu-id="c3b4a-221">Popisuje způsob použití asynchronního vzoru založeného na úlohách (TAP) k implementaci asynchronního programovacího modelu (APM) a asynchronního vzoru založeného na událostech (EAP).</span><span class="sxs-lookup"><span data-stu-id="c3b4a-221">Describes how to use the Task-based Asynchronous Pattern (TAP) to implement the Asynchronous Programming Model (APM) and Event-based Asynchronous Pattern (EAP).</span></span>|
