---
title: Implementace metody Dispose
ms.date: 05/27/2020
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- Dispose method
- garbage collection, Dispose method
ms.assetid: eb4e1af0-3b48-4fbc-ad4e-fc2f64138bf9
ms.openlocfilehash: a16034b074b518b25244c47a7d00cb484e145c6e
ms.sourcegitcommit: 5280b2aef60a1ed99002dba44e4b9e7f6c830604
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 06/03/2020
ms.locfileid: "84307017"
---
# <a name="implement-a-dispose-method"></a><span data-ttu-id="213ae-102">Implementace metody Dispose</span><span class="sxs-lookup"><span data-stu-id="213ae-102">Implement a Dispose method</span></span>

<span data-ttu-id="213ae-103">Implementace <xref:System.IDisposable.Dispose%2A> metody je primárně určena pro uvolňování nespravovaných prostředků používaných vaším kódem.</span><span class="sxs-lookup"><span data-stu-id="213ae-103">Implementing the <xref:System.IDisposable.Dispose%2A> method is primarily for releasing unmanaged resources used by your code.</span></span> <span data-ttu-id="213ae-104">Při práci se členy instance, které jsou <xref:System.IDisposable> implementace, je běžné volání kaskády <xref:System.IDisposable.Dispose%2A> .</span><span class="sxs-lookup"><span data-stu-id="213ae-104">When working with instance members that are <xref:System.IDisposable> implementations, it's common to cascade <xref:System.IDisposable.Dispose%2A> calls.</span></span> <span data-ttu-id="213ae-105">K dispozici jsou další důvody pro implementaci <xref:System.IDisposable.Dispose%2A> , jako je například vrácení dříve provedených změn.</span><span class="sxs-lookup"><span data-stu-id="213ae-105">There are additional reasons for implementing <xref:System.IDisposable.Dispose%2A>, such as undoing something that was previously done.</span></span> <span data-ttu-id="213ae-106">Například uvolnění paměti, která byla přidělena, odebrání položky z kolekce, která byla přidána, signalizace vydání zámku, který byl získán a tak dále.</span><span class="sxs-lookup"><span data-stu-id="213ae-106">For example, freeing memory that was allocated, removing an item from a collection that was added, signaling the release of a lock that was acquired, and so on.</span></span>

<span data-ttu-id="213ae-107">[Systém uvolňování paměti .NET](index.md) nepřiřazuje ani neuvolní nespravovanou paměť.</span><span class="sxs-lookup"><span data-stu-id="213ae-107">The [.NET garbage collector](index.md) does not allocate or release unmanaged memory.</span></span> <span data-ttu-id="213ae-108">Vzor pro likvidaci objektu, který je označován jako vzor Dispose, ukládá pořadí pro životnost objektu.</span><span class="sxs-lookup"><span data-stu-id="213ae-108">The pattern for disposing an object, referred to as the dispose pattern, imposes order on the lifetime of an object.</span></span> <span data-ttu-id="213ae-109">Vzor Dispose se používá pro objekty, které implementují <xref:System.IDisposable> rozhraní a je běžné při interakci s popisovači souborů a kanálů, obslužnými rutinami registru, obslužnými rutinami čekání nebo ukazateli na bloky nespravované paměti.</span><span class="sxs-lookup"><span data-stu-id="213ae-109">The dispose pattern is used for objects that implement the <xref:System.IDisposable> interface, and is common when interacting with file and pipe handles, registry handles, wait handles, or pointers to blocks of unmanaged memory.</span></span> <span data-ttu-id="213ae-110">Důvodem je to, že systém uvolňování paměti nemůže uvolnit nespravované objekty.</span><span class="sxs-lookup"><span data-stu-id="213ae-110">This is because the garbage collector is unable to reclaim unmanaged objects.</span></span>

<span data-ttu-id="213ae-111">Aby bylo možné zajistit, aby se prostředky vždy vyčistily správně, <xref:System.IDisposable.Dispose%2A> měla by být metoda idempotentní, aby byla vícenásobně volat bez vyvolání výjimky.</span><span class="sxs-lookup"><span data-stu-id="213ae-111">To help ensure that resources are always cleaned up appropriately, a <xref:System.IDisposable.Dispose%2A> method should be idempotent, such that it is callable multiple times without throwing an exception.</span></span> <span data-ttu-id="213ae-112">Kromě toho by následné vyvolání <xref:System.IDisposable.Dispose%2A> nemělo dělat nic.</span><span class="sxs-lookup"><span data-stu-id="213ae-112">Furthermore, subsequent invocations of <xref:System.IDisposable.Dispose%2A> should do nothing.</span></span>

<span data-ttu-id="213ae-113">Příklad kódu, který je k dispozici pro <xref:System.GC.KeepAlive%2A?displayProperty=nameWithType> metodu, ukazuje, jak uvolňování paměti může způsobit spuštění finalizační metody, zatímco nespravovaný odkaz na objekt nebo jeho členy se stále používá.</span><span class="sxs-lookup"><span data-stu-id="213ae-113">The code example provided for the <xref:System.GC.KeepAlive%2A?displayProperty=nameWithType> method shows how garbage collection can cause a finalizer to run, while an unmanaged reference to the object or its members is still in use.</span></span> <span data-ttu-id="213ae-114">Může být vhodné využít <xref:System.GC.KeepAlive%2A?displayProperty=nameWithType> k tomu, aby objekt nezpůsobil pro uvolňování paměti od začátku aktuální rutiny do bodu, ve kterém je tato metoda volána.</span><span class="sxs-lookup"><span data-stu-id="213ae-114">It may make sense to utilize <xref:System.GC.KeepAlive%2A?displayProperty=nameWithType> to make the object ineligible for garbage collection from the start of the current routine to the point where this method is called.</span></span>

## <a name="safe-handles"></a><span data-ttu-id="213ae-115">Bezpečné popisovače</span><span class="sxs-lookup"><span data-stu-id="213ae-115">Safe handles</span></span>

<span data-ttu-id="213ae-116">Psaní kódu pro finalizační metodu objektu je složitý úkol, který může způsobit problémy, není-li prováděn správně.</span><span class="sxs-lookup"><span data-stu-id="213ae-116">Writing code for an object's finalizer is a complex task that can cause problems if not done correctly.</span></span> <span data-ttu-id="213ae-117">Proto doporučujeme <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> místo implementace finalizační metody vytvořit objekty.</span><span class="sxs-lookup"><span data-stu-id="213ae-117">Therefore, we recommend that you construct <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> objects instead of implementing a finalizer.</span></span>

<span data-ttu-id="213ae-118"><xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>Je abstraktní spravovaný typ, který zabalí <xref:System.IntPtr?displayProperty=nameWithType> , který identifikuje nespravovaný prostředek.</span><span class="sxs-lookup"><span data-stu-id="213ae-118">A <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> is an abstract managed type that wraps an <xref:System.IntPtr?displayProperty=nameWithType> that identifies an unmanaged resource.</span></span> <span data-ttu-id="213ae-119">V systému Windows může identifikovat popisovač v systému UNIX, popisovač souboru.</span><span class="sxs-lookup"><span data-stu-id="213ae-119">On Windows it might identify a handle while on Unix, a file descriptor.</span></span> <span data-ttu-id="213ae-120">Poskytuje veškerou logiku nutnou k zajištění toho, že se tento prostředek vydává jednou a jenom jednou, když `SafeHandle` je vyřazený z nebo když jsou všechny odkazy na `SafeHandle` vyřazené a `SafeHandle` instance se dokončuje.</span><span class="sxs-lookup"><span data-stu-id="213ae-120">It provides all of the logic necessary to ensure that this resource is released once and only once, when the `SafeHandle` is disposed of or when all references to the `SafeHandle` have been dropped and the `SafeHandle` instance is finalized.</span></span>

<span data-ttu-id="213ae-121"><xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>Je abstraktní základní třída.</span><span class="sxs-lookup"><span data-stu-id="213ae-121">The <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> is an abstract base class.</span></span> <span data-ttu-id="213ae-122">Odvozené třídy poskytují konkrétní instance pro různé druhy popisovačů.</span><span class="sxs-lookup"><span data-stu-id="213ae-122">Derived classes provide specific instances for different kinds of handle.</span></span> <span data-ttu-id="213ae-123">Tyto odvozené třídy ověřují, které hodnoty pro <xref:System.IntPtr?displayProperty=nameWithType> jsou považovány za neplatné a jak je ve skutečnosti zadarmo zadarmo.</span><span class="sxs-lookup"><span data-stu-id="213ae-123">These derived classes validate what values for the <xref:System.IntPtr?displayProperty=nameWithType> are considered invalid and how to actually free the handle.</span></span> <span data-ttu-id="213ae-124">Například <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> je odvozen od `SafeHandle` pro zabalení `IntPtrs` , které identifikuje otevřené popisovače souborů/popisovače, a Přepisuje její <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle?displayProperty=nameWithType> metodu pro její zavření (prostřednictvím `close` funkce v systému UNIX nebo `CloseHandle` ve Windows).</span><span class="sxs-lookup"><span data-stu-id="213ae-124">For example, <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> derives from `SafeHandle` to wrap `IntPtrs` that identify open file handles/descriptors, and overrides its <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle?displayProperty=nameWithType> method to close it (via the `close` function on Unix or `CloseHandle` function on Windows).</span></span> <span data-ttu-id="213ae-125">Většina rozhraní API v knihovnách .NET, které vytváří nespravovaný prostředek, zabalí ho do `SafeHandle` a a vrátí, `SafeHandle` co je potřeba, místo ručního vrácení nezpracovaného ukazatele zpět.</span><span class="sxs-lookup"><span data-stu-id="213ae-125">Most APIs in .NET libraries that create an unmanaged resource will wrap it in a `SafeHandle` and return that `SafeHandle` to you as needed, rather than handing back the raw pointer.</span></span> <span data-ttu-id="213ae-126">V situacích, kdy pracujete s nespravovanou komponentou a získáte `IntPtr` pro nespravovaný prostředek, můžete vytvořit vlastní `SafeHandle` typ, který ho zabalí.</span><span class="sxs-lookup"><span data-stu-id="213ae-126">In situations where you interact with an unmanaged component and get an `IntPtr` for an unmanaged resource, you can create your own `SafeHandle` type to wrap it.</span></span> <span data-ttu-id="213ae-127">V důsledku toho některé `SafeHandle` netypy nemusejí implementovat finalizační metody; většina implementací vzorku na jedno použití pouze ukončí zalamování jiných spravovaných prostředků, z nichž některé mohou být `SafeHandle` s.</span><span class="sxs-lookup"><span data-stu-id="213ae-127">As a result, few non-`SafeHandle` types need to implement finalizers; most disposable pattern implementations only end up wrapping other managed resources, some of which may be `SafeHandle`s.</span></span>

<span data-ttu-id="213ae-128">Následující odvozené třídy v <xref:Microsoft.Win32.SafeHandles> oboru názvů poskytují bezpečné popisovače:</span><span class="sxs-lookup"><span data-stu-id="213ae-128">The following derived classes in the <xref:Microsoft.Win32.SafeHandles> namespace provide safe handles:</span></span>

- <span data-ttu-id="213ae-129"><xref:Microsoft.Win32.SafeHandles.SafeFileHandle>Třídy, <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle> a <xref:Microsoft.Win32.SafeHandles.SafePipeHandle> pro soubory, soubory mapované paměti a kanály.</span><span class="sxs-lookup"><span data-stu-id="213ae-129">The <xref:Microsoft.Win32.SafeHandles.SafeFileHandle>, <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle>, and <xref:Microsoft.Win32.SafeHandles.SafePipeHandle> class, for files, memory mapped files, and pipes.</span></span>
- <span data-ttu-id="213ae-130"><xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle>Třída pro zobrazení paměti.</span><span class="sxs-lookup"><span data-stu-id="213ae-130">The <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle> class, for memory views.</span></span>
- <span data-ttu-id="213ae-131"><xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle>Třídy, <xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle> a <xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle> pro konstrukce kryptografie.</span><span class="sxs-lookup"><span data-stu-id="213ae-131">The <xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle>, <xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle>, and <xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle> classes, for cryptography constructs.</span></span>
- <span data-ttu-id="213ae-132"><xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle>Třída pro klíče registru.</span><span class="sxs-lookup"><span data-stu-id="213ae-132">The <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> class, for registry keys.</span></span>
- <span data-ttu-id="213ae-133"><xref:Microsoft.Win32.SafeHandles.SafeWaitHandle>Třída pro obslužné rutiny čekání.</span><span class="sxs-lookup"><span data-stu-id="213ae-133">The <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> class, for wait handles.</span></span>

## <a name="dispose-and-disposebool"></a><span data-ttu-id="213ae-134">Dispose () a Dispose (bool)</span><span class="sxs-lookup"><span data-stu-id="213ae-134">Dispose() and Dispose(bool)</span></span>

<span data-ttu-id="213ae-135"><xref:System.IDisposable>Rozhraní vyžaduje implementaci jediné metody bez parametrů, <xref:System.IDisposable.Dispose%2A> .</span><span class="sxs-lookup"><span data-stu-id="213ae-135">The <xref:System.IDisposable> interface requires the implementation of a single parameterless method, <xref:System.IDisposable.Dispose%2A>.</span></span> <span data-ttu-id="213ae-136">Kromě toho by měla být jakákoli nezapečetěná Třída mít `Dispose(bool)` k implementaci další metodu přetížení:</span><span class="sxs-lookup"><span data-stu-id="213ae-136">Also, any non-sealed class should have an additional `Dispose(bool)` overload method to be implemented:</span></span>

- <span data-ttu-id="213ae-137">`public`Nevirtuální ( `NonInheritable` v Visual Basic) <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementace bez parametrů.</span><span class="sxs-lookup"><span data-stu-id="213ae-137">A `public` non-virtual (`NonInheritable` in Visual Basic) <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementation that has no parameters.</span></span>

- <span data-ttu-id="213ae-138">`protected virtual`Metoda ( `Overridable` in Visual Basic), `Dispose` jejíž signatura je:</span><span class="sxs-lookup"><span data-stu-id="213ae-138">A `protected virtual` (`Overridable` in Visual Basic) `Dispose` method whose signature is:</span></span>

  [!code-csharp[Conceptual.Disposable#8](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.disposable/cs/dispose1.cs#8)]
  [!code-vb[Conceptual.Disposable#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.disposable/vb/dispose1.vb#8)]

  > [!IMPORTANT]
  > <span data-ttu-id="213ae-139">`disposing`Parametr by měl být `false` při volání z finalizační `true` metody a při volání z <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="213ae-139">The `disposing` parameter should be `false` when called from a finalizer, and `true` when called from the <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="213ae-140">Jinými slovy, je `true` při deterministickém volání a `false` při nedeterministickém volání.</span><span class="sxs-lookup"><span data-stu-id="213ae-140">In other words, it is `true` when deterministically called and `false` when non-deterministically called.</span></span>

### <a name="the-dispose-method"></a><span data-ttu-id="213ae-141">Metoda Dispose ()</span><span class="sxs-lookup"><span data-stu-id="213ae-141">The Dispose() method</span></span>

<span data-ttu-id="213ae-142">Vzhledem k tomu, že `public` nevirtuální ( `NonInheritable` v Visual Basic), metoda bez parametrů `Dispose` je volána příjemcem typu, jeho účelem je uvolnit nespravované prostředky, provést obecné vyčištění a označit, že finalizační metoda, pokud je k dispozici, nemusí být spuštěna.</span><span class="sxs-lookup"><span data-stu-id="213ae-142">Because the `public`, non-virtual (`NonInheritable` in Visual Basic), parameterless `Dispose` method is called by a consumer of the type, its purpose is to free unmanaged resources, perform general cleanup, and to indicate that the finalizer, if one is present, doesn't have to run.</span></span> <span data-ttu-id="213ae-143">Uvolnění aktuální paměti přidružené ke spravovanému objektu je vždy doména [uvolňování paměti](index.md).</span><span class="sxs-lookup"><span data-stu-id="213ae-143">Freeing the actual memory associated with a managed object is always the domain of the [garbage collector](index.md).</span></span> <span data-ttu-id="213ae-144">Z tohoto důvodu má standardní implementaci:</span><span class="sxs-lookup"><span data-stu-id="213ae-144">Because of this, it has a standard implementation:</span></span>

[!code-csharp[Conceptual.Disposable#7](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.disposable/cs/dispose1.cs#7)]
[!code-vb[Conceptual.Disposable#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.disposable/vb/dispose1.vb#7)]

<span data-ttu-id="213ae-145">`Dispose`Metoda provádí vyčištění všech objektů, takže systém uvolňování paměti již nemusí volat <xref:System.Object.Finalize%2A?displayProperty=nameWithType> přepis objektů.</span><span class="sxs-lookup"><span data-stu-id="213ae-145">The `Dispose` method performs all object cleanup, so the garbage collector no longer needs to call the objects' <xref:System.Object.Finalize%2A?displayProperty=nameWithType> override.</span></span> <span data-ttu-id="213ae-146">Proto volání <xref:System.GC.SuppressFinalize%2A> metody zabrání systému uvolňování paměti ve spuštění finalizační metody.</span><span class="sxs-lookup"><span data-stu-id="213ae-146">Therefore, the call to the <xref:System.GC.SuppressFinalize%2A> method prevents the garbage collector from running the finalizer.</span></span> <span data-ttu-id="213ae-147">Pokud typ nemá finalizační metodu, volání <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> nemá žádný vliv.</span><span class="sxs-lookup"><span data-stu-id="213ae-147">If the type has no finalizer, the call to <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> has no effect.</span></span> <span data-ttu-id="213ae-148">Všimněte si, že vlastní vyčištění je provedeno `Dispose(bool)` přetížením metody.</span><span class="sxs-lookup"><span data-stu-id="213ae-148">Note that the actual cleanup is performed by the `Dispose(bool)` method overload.</span></span>

### <a name="the-disposebool-method-overload"></a><span data-ttu-id="213ae-149">Přetížení metody Dispose (bool)</span><span class="sxs-lookup"><span data-stu-id="213ae-149">The Dispose(bool) method overload</span></span>

<span data-ttu-id="213ae-150">V přetížení `disposing` je parametr <xref:System.Boolean> , který označuje, zda volání metody pochází z <xref:System.IDisposable.Dispose%2A> metody (její hodnota je `true` ) nebo z finalizační metody (její hodnota je `false` ).</span><span class="sxs-lookup"><span data-stu-id="213ae-150">In the overload, the `disposing` parameter is a <xref:System.Boolean> that indicates whether the method call comes from a <xref:System.IDisposable.Dispose%2A> method (its value is `true`) or from a finalizer (its value is `false`).</span></span>

<span data-ttu-id="213ae-151">Tělo metody sestává ze dvou bloků kódu:</span><span class="sxs-lookup"><span data-stu-id="213ae-151">The body of the method consists of two blocks of code:</span></span>

- <span data-ttu-id="213ae-152">Blok, který uvolní nespravované prostředky.</span><span class="sxs-lookup"><span data-stu-id="213ae-152">A block that frees unmanaged resources.</span></span> <span data-ttu-id="213ae-153">Tento blok se provede bez ohledu na hodnotu `disposing` parametru.</span><span class="sxs-lookup"><span data-stu-id="213ae-153">This block executes regardless of the value of the `disposing` parameter.</span></span>
- <span data-ttu-id="213ae-154">Podmíněný blok, který uvolní spravované prostředky.</span><span class="sxs-lookup"><span data-stu-id="213ae-154">A conditional block that frees managed resources.</span></span> <span data-ttu-id="213ae-155">Tento blok `disposing` se spustí, pokud je hodnota `true` .</span><span class="sxs-lookup"><span data-stu-id="213ae-155">This block executes if the value of `disposing` is `true`.</span></span> <span data-ttu-id="213ae-156">Mezi uvolněné spravované prostředky patří:</span><span class="sxs-lookup"><span data-stu-id="213ae-156">The managed resources that it frees can include:</span></span>

  - <span data-ttu-id="213ae-157">**Spravované objekty, které implementují <xref:System.IDisposable> .**</span><span class="sxs-lookup"><span data-stu-id="213ae-157">**Managed objects that implement <xref:System.IDisposable>.**</span></span> <span data-ttu-id="213ae-158">Podmíněný blok lze použít k volání jejich <xref:System.IDisposable.Dispose%2A> implementace (Dispose kaskády).</span><span class="sxs-lookup"><span data-stu-id="213ae-158">The conditional block can be used to call their <xref:System.IDisposable.Dispose%2A> implementation (cascade dispose).</span></span> <span data-ttu-id="213ae-159">Pokud jste použili odvozenou třídu <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> pro zabalení nespravovaného prostředku, měli byste zavolat <xref:System.Runtime.InteropServices.SafeHandle.Dispose?displayProperty=nameWithType> implementaci zde.</span><span class="sxs-lookup"><span data-stu-id="213ae-159">If you have used a derived class of <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> to wrap your unmanaged resource, you should call the <xref:System.Runtime.InteropServices.SafeHandle.Dispose?displayProperty=nameWithType> implementation here.</span></span>

  - <span data-ttu-id="213ae-160">**Spravované objekty, které využívají velké množství paměti nebo využívají omezených prostředky.**</span><span class="sxs-lookup"><span data-stu-id="213ae-160">**Managed objects that consume large amounts of memory or consume scarce resources.**</span></span> <span data-ttu-id="213ae-161">Přiřazení rozsáhlých odkazů na spravované objekty, aby `null` bylo pravděpodobnější, že budou pravděpodobně nedostupné.</span><span class="sxs-lookup"><span data-stu-id="213ae-161">Assign large managed object references to `null` to make them more likely to be unreachable.</span></span> <span data-ttu-id="213ae-162">Tato verze je rychlejší, než kdyby byla uvolněna bez jejich nedeterministického.</span><span class="sxs-lookup"><span data-stu-id="213ae-162">This releases them faster than if they were reclaimed non-deterministically.</span></span>

<span data-ttu-id="213ae-163">Pokud volání metody pochází z finalizační metody, měla by být spuštěna pouze kód, který uvolní nespravované prostředky.</span><span class="sxs-lookup"><span data-stu-id="213ae-163">If the method call comes from a finalizer, only the code that frees unmanaged resources should execute.</span></span> <span data-ttu-id="213ae-164">Implementátor zodpovídá za to, že nepravdivá cesta nekomunikuje se spravovanými objekty, které mohou být uvolněny.</span><span class="sxs-lookup"><span data-stu-id="213ae-164">The implementer is responsible for ensuring the the false path doesn't interact with managed objects that may have been reclaimed.</span></span> <span data-ttu-id="213ae-165">To je důležité kvůli tomu, že systém uvolňování paměti během finalizace nedeterministické spravované objekty.</span><span class="sxs-lookup"><span data-stu-id="213ae-165">This is important because the order in which the garbage collector destroys managed objects during finalization is non-deterministic.</span></span>

## <a name="cascade-dispose-calls"></a><span data-ttu-id="213ae-166">Volání Dispose pro kaskády</span><span class="sxs-lookup"><span data-stu-id="213ae-166">Cascade dispose calls</span></span>

<span data-ttu-id="213ae-167">Pokud vaše třída vlastní pole nebo vlastnost a její typ implementuje <xref:System.IDisposable> , měla by být také implementována obsažená třída <xref:System.IDisposable> .</span><span class="sxs-lookup"><span data-stu-id="213ae-167">If your class owns a field or property, and its type implements <xref:System.IDisposable>, the containing class itself should also implement <xref:System.IDisposable>.</span></span> <span data-ttu-id="213ae-168">Třída, která vytváří instanci <xref:System.IDisposable> implementace a ukládá ji jako člen instance, je také zodpovědná za její vyčištění.</span><span class="sxs-lookup"><span data-stu-id="213ae-168">A class that instantiates an <xref:System.IDisposable> implementation and storing it as an instance member, is also responsible for its cleanup.</span></span> <span data-ttu-id="213ae-169">To vám umožní zajistit, aby se odkazované typy na jedno použití dostaly do čistého výkonu prostřednictvím <xref:System.IDisposable.Dispose%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="213ae-169">This is to help ensure that the referenced disposable types are given the opportunity to deterministically perform clean up through the <xref:System.IDisposable.Dispose%2A> method.</span></span> <span data-ttu-id="213ae-170">V tomto příkladu je třída `sealed` (nebo `NotInheritable` v Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="213ae-170">In this example, the class is `sealed` (or `NotInheritable` in Visual Basic).</span></span>

[!code-csharp[Conceptual.Disposable#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.disposable/cs/disposable1.cs#1)]
[!code-vb[Conceptual.Disposable#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.disposable/vb/disposable1.vb#1)]

## <a name="implement-the-dispose-pattern"></a><span data-ttu-id="213ae-171">Implementace vzoru Dispose</span><span class="sxs-lookup"><span data-stu-id="213ae-171">Implement the dispose pattern</span></span>

<span data-ttu-id="213ae-172">Všechny nezapečetěné třídy nebo (Visual Basic třídy neupravené jako `NotInheritable` ) by měly být považovány za potenciální základní třídu, protože by mohly být děděny.</span><span class="sxs-lookup"><span data-stu-id="213ae-172">All non-sealed classes or (Visual Basic classes not modified as `NotInheritable`) should be considered a potential base class, because they could be inherited.</span></span> <span data-ttu-id="213ae-173">Pokud implementujete vzor Dispose pro jakoukoli potenciální základní třídu, je nutné zadat následující:</span><span class="sxs-lookup"><span data-stu-id="213ae-173">If you implement the dispose pattern for any potential base class, you must provide the following:</span></span>

- <span data-ttu-id="213ae-174"><xref:System.IDisposable.Dispose%2A>Implementace, která volá `Dispose(bool)` metodu.</span><span class="sxs-lookup"><span data-stu-id="213ae-174">A <xref:System.IDisposable.Dispose%2A> implementation that calls the `Dispose(bool)` method.</span></span>
- <span data-ttu-id="213ae-175">`Dispose(bool)`Metoda, která provede skutečné vyčištění.</span><span class="sxs-lookup"><span data-stu-id="213ae-175">A `Dispose(bool)` method that performs the actual cleanup.</span></span>
- <span data-ttu-id="213ae-176">Buď třída odvozená z <xref:System.Runtime.InteropServices.SafeHandle> , která zabalí váš nespravovaný prostředek (doporučeno), nebo přepíše <xref:System.Object.Finalize%2A?displayProperty=nameWithType> metodu.</span><span class="sxs-lookup"><span data-stu-id="213ae-176">Either a class derived from <xref:System.Runtime.InteropServices.SafeHandle> that wraps your unmanaged resource (recommended), or an override to the <xref:System.Object.Finalize%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="213ae-177"><xref:System.Runtime.InteropServices.SafeHandle>Třída poskytuje finalizační metodu, takže nemusíte psát sami sebe.</span><span class="sxs-lookup"><span data-stu-id="213ae-177">The <xref:System.Runtime.InteropServices.SafeHandle> class provides a finalizer, so you do not have to write one yourself.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="213ae-178">Základní třída může odkazovat pouze na spravované objekty a implementovat vzor Dispose.</span><span class="sxs-lookup"><span data-stu-id="213ae-178">It is possible for a base class to only reference managed objects, and implement the dispose pattern.</span></span> <span data-ttu-id="213ae-179">V těchto případech není finalizační metoda nutná.</span><span class="sxs-lookup"><span data-stu-id="213ae-179">In these cases, a finalizer is unnecessary.</span></span> <span data-ttu-id="213ae-180">Finalizační metoda je nutná pouze v případě, že přímo odkazujete na nespravované prostředky.</span><span class="sxs-lookup"><span data-stu-id="213ae-180">A finalizer is only required if you directly reference unmanaged resources.</span></span>

<span data-ttu-id="213ae-181">Zde je obecný vzor pro implementaci vzoru dispose pro základní třídu, která používá bezpečný popisovač.</span><span class="sxs-lookup"><span data-stu-id="213ae-181">Here's the general pattern for implementing the dispose pattern for a base class that uses a safe handle.</span></span>

[!code-csharp[System.IDisposable#3](../../../samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/base1.cs#3)]
[!code-vb[System.IDisposable#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/base1.vb#3)]

> [!NOTE]
> <span data-ttu-id="213ae-182">Předchozí příklad používá <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> objekt k ilustraci vzoru; <xref:System.Runtime.InteropServices.SafeHandle> namísto toho lze použít libovolný objekt odvozený od.</span><span class="sxs-lookup"><span data-stu-id="213ae-182">The previous example uses a <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> object to illustrate the pattern; any object derived from <xref:System.Runtime.InteropServices.SafeHandle> could be used instead.</span></span> <span data-ttu-id="213ae-183">Všimněte si, že v příkladu není správně vytvořena instance <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> objektu.</span><span class="sxs-lookup"><span data-stu-id="213ae-183">Note that the example does not properly instantiate its <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> object.</span></span>

<span data-ttu-id="213ae-184">Zde je obecný vzor pro implementaci vzoru dispose pro základní třídu, která přepisuje <xref:System.Object.Finalize%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="213ae-184">Here's the general pattern for implementing the dispose pattern for a base class that overrides <xref:System.Object.Finalize%2A?displayProperty=nameWithType>.</span></span>

[!code-csharp[System.IDisposable#5](../../../samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/base2.cs#5)]
[!code-vb[System.IDisposable#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/base2.vb#5)]

> [!TIP]
> <span data-ttu-id="213ae-185">V jazyce C# vytvoříte [finalizační metodu](../../csharp/programming-guide/classes-and-structs/destructors.md) přepsáním <xref:System.Object.Finalize%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="213ae-185">In C#, you create a [finalizer](../../csharp/programming-guide/classes-and-structs/destructors.md) by overriding <xref:System.Object.Finalize%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="213ae-186">V Visual Basic se to dělá s `Protected Overrides Sub Finalize()` .</span><span class="sxs-lookup"><span data-stu-id="213ae-186">In Visual Basic, this is done with `Protected Overrides Sub Finalize()`.</span></span>

## <a name="implement-the-dispose-pattern-for-a-derived-class"></a><span data-ttu-id="213ae-187">Implementace vzoru dispose pro odvozenou třídu</span><span class="sxs-lookup"><span data-stu-id="213ae-187">Implement the dispose pattern for a derived class</span></span>

<span data-ttu-id="213ae-188">Třída odvozená od třídy, která implementuje <xref:System.IDisposable> rozhraní, by neměla implementovat <xref:System.IDisposable> , protože implementace základní třídy <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> je zděděna svými odvozenými třídami.</span><span class="sxs-lookup"><span data-stu-id="213ae-188">A class derived from a class that implements the <xref:System.IDisposable> interface shouldn't implement <xref:System.IDisposable>, because the base class implementation of <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> is inherited by its derived classes.</span></span> <span data-ttu-id="213ae-189">Místo toho pro vyčištění odvozené třídy zadejte následující:</span><span class="sxs-lookup"><span data-stu-id="213ae-189">Instead, to cleanup a derived class, you provide the following:</span></span>

- <span data-ttu-id="213ae-190">`protected override void Dispose(bool)`Metoda, která přepisuje metodu základní třídy a provede skutečné vyčištění odvozené třídy.</span><span class="sxs-lookup"><span data-stu-id="213ae-190">A `protected override void Dispose(bool)` method that overrides the base class method and performs the actual cleanup of the derived class.</span></span> <span data-ttu-id="213ae-191">Tato metoda musí také volat `base.Dispose(bool)` metodu ( `MyBase.Dispose(bool)` v Visual Basic) základní třídy a předat její stav disposing argumentu.</span><span class="sxs-lookup"><span data-stu-id="213ae-191">This method must also call the `base.Dispose(bool)` (`MyBase.Dispose(bool)` in Visual Basic) method of the base class and pass its disposing status for the argument.</span></span>
- <span data-ttu-id="213ae-192">Buď třída odvozená z <xref:System.Runtime.InteropServices.SafeHandle> , která zabalí váš nespravovaný prostředek (doporučeno), nebo přepíše <xref:System.Object.Finalize%2A?displayProperty=nameWithType> metodu.</span><span class="sxs-lookup"><span data-stu-id="213ae-192">Either a class derived from <xref:System.Runtime.InteropServices.SafeHandle> that wraps your unmanaged resource (recommended), or an override to the <xref:System.Object.Finalize%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="213ae-193"><xref:System.Runtime.InteropServices.SafeHandle>Třída poskytuje finalizační metodu, která vám uvolní, abyste ji nemuseli nakódovat.</span><span class="sxs-lookup"><span data-stu-id="213ae-193">The <xref:System.Runtime.InteropServices.SafeHandle> class provides a finalizer that frees you from having to code one.</span></span> <span data-ttu-id="213ae-194">Pokud zadáte finalizační metodu, musí volat `Dispose(bool)` přetížení s `disposing` argumentem `false` .</span><span class="sxs-lookup"><span data-stu-id="213ae-194">If you do provide a finalizer, it must call the `Dispose(bool)` overload with a `disposing` argument of `false`.</span></span>

<span data-ttu-id="213ae-195">Toto je obecný vzor implementace vzoru Dispose pro odvozenou třídu, která používá bezpečný popisovač:</span><span class="sxs-lookup"><span data-stu-id="213ae-195">Here's the general pattern for implementing the dispose pattern for a derived class that uses a safe handle:</span></span>

[!code-csharp[System.IDisposable#4](../../../samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/derived1.cs#4)]
[!code-vb[System.IDisposable#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/derived1.vb#4)]

> [!NOTE]
> <span data-ttu-id="213ae-196">Předchozí příklad používá <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> objekt k ilustraci vzoru; <xref:System.Runtime.InteropServices.SafeHandle> namísto toho lze použít libovolný objekt odvozený od.</span><span class="sxs-lookup"><span data-stu-id="213ae-196">The previous example uses a <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> object to illustrate the pattern; any object derived from <xref:System.Runtime.InteropServices.SafeHandle> could be used instead.</span></span> <span data-ttu-id="213ae-197">Všimněte si, že v příkladu není správně vytvořena instance <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> objektu.</span><span class="sxs-lookup"><span data-stu-id="213ae-197">Note that the example does not properly instantiate its <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> object.</span></span>

<span data-ttu-id="213ae-198">Zde je obecný vzor pro implementaci vzoru dispose pro odvozenou třídu, která přepisuje <xref:System.Object.Finalize%2A?displayProperty=nameWithType> :</span><span class="sxs-lookup"><span data-stu-id="213ae-198">Here's the general pattern for implementing the dispose pattern for a derived class that overrides <xref:System.Object.Finalize%2A?displayProperty=nameWithType>:</span></span>

[!code-csharp[System.IDisposable#6](../../../samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/derived2.cs#6)]
[!code-vb[System.IDisposable#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/derived2.vb#6)]

## <a name="implement-the-dispose-pattern-with-safe-handles"></a><span data-ttu-id="213ae-199">Implementace vzoru dispose pomocí bezpečných popisovačů</span><span class="sxs-lookup"><span data-stu-id="213ae-199">Implement the dispose pattern with safe handles</span></span>

<span data-ttu-id="213ae-200">Následující příklad znázorňuje vzor Dispose pro základní třídu, `DisposableStreamResource` , který používá bezpečný popisovač k zapouzdření nespravovaných prostředků.</span><span class="sxs-lookup"><span data-stu-id="213ae-200">The following example illustrates the dispose pattern for a base class, `DisposableStreamResource`, that uses a safe handle to encapsulate unmanaged resources.</span></span> <span data-ttu-id="213ae-201">Definuje `DisposableStreamResource` třídu, která používá <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> k zabalení <xref:System.IO.Stream> objektu, který představuje otevřený soubor.</span><span class="sxs-lookup"><span data-stu-id="213ae-201">It defines a `DisposableStreamResource` class that uses a <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> to wrap a <xref:System.IO.Stream> object that represents an open file.</span></span> <span data-ttu-id="213ae-202">Třída také obsahuje jedinou vlastnost, `Size` která vrací celkový počet bajtů v datovém proudu souboru.</span><span class="sxs-lookup"><span data-stu-id="213ae-202">The class also includes a single property, `Size`, that returns the total number of bytes in the file stream.</span></span>

[!code-csharp[Conceptual.Disposable#9](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.disposable/cs/base1.cs#9)]
[!code-vb[Conceptual.Disposable#9](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.disposable/vb/base1.vb#9)]

## <a name="implement-the-dispose-pattern-for-a-derived-class-with-safe-handles"></a><span data-ttu-id="213ae-203">Implementace vzoru dispose pro odvozenou třídu s bezpečnými popisovači</span><span class="sxs-lookup"><span data-stu-id="213ae-203">Implement the dispose pattern for a derived class with safe handles</span></span>

<span data-ttu-id="213ae-204">Následující příklad znázorňuje vzor Dispose pro odvozenou třídu, `DisposableStreamResource2` , která dědí z třídy uvedené `DisposableStreamResource` v předchozím příkladu.</span><span class="sxs-lookup"><span data-stu-id="213ae-204">The following example illustrates the dispose pattern for a derived class, `DisposableStreamResource2`, that inherits from the `DisposableStreamResource` class presented in the previous example.</span></span> <span data-ttu-id="213ae-205">Třída přidá další metodu, `WriteFileInfo` a pomocí <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> objektu zabalí popisovač zapisovatelného souboru.</span><span class="sxs-lookup"><span data-stu-id="213ae-205">The class adds an additional method, `WriteFileInfo`, and uses a <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> object to wrap the handle of the writable file.</span></span>

[!code-csharp[Conceptual.Disposable#10](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.disposable/cs/derived1.cs#10)]
[!code-vb[Conceptual.Disposable#10](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.disposable/vb/derived1.vb#10)]

## <a name="see-also"></a><span data-ttu-id="213ae-206">Viz také</span><span class="sxs-lookup"><span data-stu-id="213ae-206">See also</span></span>

- <xref:System.GC.SuppressFinalize%2A>
- <xref:System.IDisposable>
- <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>
- <xref:Microsoft.Win32.SafeHandles>
- <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>
- <xref:System.Object.Finalize%2A?displayProperty=nameWithType>
- [<span data-ttu-id="213ae-207">Definování a využívání tříd a struktur (C++/CLI)</span><span class="sxs-lookup"><span data-stu-id="213ae-207">Define and consume classes and structs (C++/CLI)</span></span>](/cpp/dotnet/how-to-define-and-consume-classes-and-structs-cpp-cli)
