---
title: Strategie pro zpracování částečného selhání
description: Architektura Mikroslužeb .NET pro Kontejnerizované aplikace .NET | Strategie pro zpracování částečného selhání
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 06/08/2018
ms.openlocfilehash: ac82f6d506213614c7a4079e0f55f798f26a6550
ms.sourcegitcommit: 59b51cd7c95c75be85bd6ef715e9ef8c85720bac
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 07/06/2018
ms.locfileid: "37874400"
---
# <a name="strategies-for-handling-partial-failure"></a><span data-ttu-id="1f2e3-103">Strategie pro zpracování částečného selhání</span><span class="sxs-lookup"><span data-stu-id="1f2e3-103">Strategies for handling partial failure</span></span>

<span data-ttu-id="1f2e3-104">Strategie pro práci s částečně neúspěšné patří.</span><span class="sxs-lookup"><span data-stu-id="1f2e3-104">Strategies for dealing with partial failures include the following.</span></span>

<span data-ttu-id="1f2e3-105">**Použít asynchronní komunikaci (například založenou na zprávách) napříč interní mikroslužeb**.</span><span class="sxs-lookup"><span data-stu-id="1f2e3-105">**Use asynchronous communication (for example, message-based communication) across internal microservices**.</span></span> <span data-ttu-id="1f2e3-106">Se důrazně doporučuje nechcete vytvořit dlouhé řetězce o synchronních voláních HTTP mezi interní mikroslužeb, protože tento nesprávné návrhu se nakonec stanou hlavní příčinou chybný výpadků.</span><span class="sxs-lookup"><span data-stu-id="1f2e3-106">It is highly advisable not to create long chains of synchronous HTTP calls across the internal microservices because that incorrect design will eventually become the main cause of bad outages.</span></span> <span data-ttu-id="1f2e3-107">Naopak, s výjimkou front-endu komunikace mezi klientskými aplikacemi a první úroveň z mikroslužeb nebo jemné brány rozhraní API, se doporučuje používat pouze asynchronní (založená na zprávách) jednou za počáteční požadavek / cyklus odezvy mezi interní mikroslužeb.</span><span class="sxs-lookup"><span data-stu-id="1f2e3-107">On the contrary, except for the front-end communications between the client applications and the first level of microservices or fine-grained API Gateways, it is recommended to use only asynchronous (message-based) communication once past the initial request/response cycle, across the internal microservices.</span></span> <span data-ttu-id="1f2e3-108">Konečné konzistence a architektury řízené událostmi pomůže omezit ripple účinky.</span><span class="sxs-lookup"><span data-stu-id="1f2e3-108">Eventual consistency and event-driven architectures will help to minimize ripple effects.</span></span> <span data-ttu-id="1f2e3-109">Tyto přístupy vynutit vyšší úroveň autonomie mikroslužeb a zabránit tak před problémem jsou tady uvedené.</span><span class="sxs-lookup"><span data-stu-id="1f2e3-109">These approaches enforce a higher level of microservice autonomy and therefore prevent against the problem noted here.</span></span>

<span data-ttu-id="1f2e3-110">**Opakování pomocí exponenciálního omezení rychlosti**.</span><span class="sxs-lookup"><span data-stu-id="1f2e3-110">**Use retries with exponential backoff**.</span></span> <span data-ttu-id="1f2e3-111">Tento přístup umožňuje vyhnout se krátký a občasné chyby pomocí provádí volání opakování s určitým počtem opakování, v případě, že služba nebyla k dispozici pouze krátkou dobu.</span><span class="sxs-lookup"><span data-stu-id="1f2e3-111">This technique helps to avoid short and intermittent failures by performing call retries a certain number of times, in case the service was not available only for a short time.</span></span> <span data-ttu-id="1f2e3-112">Tato situace může nastat kvůli problémům s sítě nebo mikroslužeb a kontejnerů se přesune do jiného uzlu v clusteru.</span><span class="sxs-lookup"><span data-stu-id="1f2e3-112">This might occur due to intermittent network issues or when a microservice/container is moved to a different node in a cluster.</span></span> <span data-ttu-id="1f2e3-113">Ale pokud tyto opakování nejsou správně navržená se jističe a to zhoršit ripple účinky, takže v konečném důsledku i způsobující [útok na dostupnost služby (DoS)](https://en.wikipedia.org/wiki/Denial-of-service_attack).</span><span class="sxs-lookup"><span data-stu-id="1f2e3-113">However, if these retries are not designed properly with circuit breakers, it can aggravate the ripple effects, ultimately even causing a [Denial of Service (DoS)](https://en.wikipedia.org/wiki/Denial-of-service_attack).</span></span>

<span data-ttu-id="1f2e3-114">**Alternativní vypršení časového limitu sítě**.</span><span class="sxs-lookup"><span data-stu-id="1f2e3-114">**Work around network timeouts**.</span></span> <span data-ttu-id="1f2e3-115">Obecně platí klienti by se měly navrhovat blokovaná a používat vypršení časového limitu při čekání na odpověď.</span><span class="sxs-lookup"><span data-stu-id="1f2e3-115">In general, clients should be designed not to block indefinitely and to always use timeouts when waiting for a response.</span></span> <span data-ttu-id="1f2e3-116">Použití časových limitů zajistí, že prostředky nikdy svázané s po neomezenou dobu.</span><span class="sxs-lookup"><span data-stu-id="1f2e3-116">Using timeouts ensures that resources are never tied up indefinitely.</span></span>

<span data-ttu-id="1f2e3-117">**Použití vzoru Circuit Breaker**.</span><span class="sxs-lookup"><span data-stu-id="1f2e3-117">**Use the Circuit Breaker pattern**.</span></span> <span data-ttu-id="1f2e3-118">V takovém případě proces klienta sleduje počet neúspěšných žádostí.</span><span class="sxs-lookup"><span data-stu-id="1f2e3-118">In this approach, the client process tracks the number of failed requests.</span></span> <span data-ttu-id="1f2e3-119">Pokud chybovost překročí nakonfigurovaný limit "jistič" cesty tak, aby další pokusy selhala okamžitě.</span><span class="sxs-lookup"><span data-stu-id="1f2e3-119">If the error rate exceeds a configured limit, a “circuit breaker” trips so that further attempts fail immediately.</span></span> <span data-ttu-id="1f2e3-120">(Pokud se nedaří velký počet požadavků, návrhy služby není k dispozici a že je zbytečný odesílání požadavků.) Po uplynutí časového limitu klienta by měl zkuste to znovu a pokud jsou úspěšné, nové požadavky zavřít jistič.</span><span class="sxs-lookup"><span data-stu-id="1f2e3-120">(If a large number of requests are failing, that suggests the service is unavailable and that sending requests is pointless.) After a timeout period, the client should try again and, if the new requests are successful, close the circuit breaker.</span></span>

<span data-ttu-id="1f2e3-121">**Zadejte náhrad**.</span><span class="sxs-lookup"><span data-stu-id="1f2e3-121">**Provide fallbacks**.</span></span> <span data-ttu-id="1f2e3-122">V takovém případě proces klienta provede náhradní logiku, když bude žádost neúspěšná, jako je vracení dat uložených v mezipaměti nebo výchozí hodnotu.</span><span class="sxs-lookup"><span data-stu-id="1f2e3-122">In this approach, the client process performs fallback logic when a request fails, such as returning cached data or a default value.</span></span> <span data-ttu-id="1f2e3-123">To je vhodný pro dotazy, přístup a je složitější aktualizací nebo příkazy.</span><span class="sxs-lookup"><span data-stu-id="1f2e3-123">This is an approach suitable for queries, and is more complex for updates or commands.</span></span>

<span data-ttu-id="1f2e3-124">**Omezení počtu požadavků zařazených do fronty**.</span><span class="sxs-lookup"><span data-stu-id="1f2e3-124">**Limit the number of queued requests**.</span></span> <span data-ttu-id="1f2e3-125">Klienti musí také ukládat horní mez počtu nevyřízených požadavků klienta mikroslužby mohou odesílat do konkrétní služby.</span><span class="sxs-lookup"><span data-stu-id="1f2e3-125">Clients should also impose an upper bound on the number of outstanding requests that a client microservice can send to a particular service.</span></span> <span data-ttu-id="1f2e3-126">Pokud bylo dosaženo limitu, je pravděpodobně bezúčelné další požadavky a těchto pokusů musí selhat, okamžitě.</span><span class="sxs-lookup"><span data-stu-id="1f2e3-126">If the limit has been reached, it is probably pointless to make additional requests, and those attempts should fail immediately.</span></span> <span data-ttu-id="1f2e3-127">Z hlediska implementace, Polly [přepážka izolace](https://github.com/App-vNext/Polly/wiki/Bulkhead) zásadu lze použít ke splnění tohoto požadavku.</span><span class="sxs-lookup"><span data-stu-id="1f2e3-127">In terms of implementation, the Polly [Bulkhead Isolation](https://github.com/App-vNext/Polly/wiki/Bulkhead) policy can be used to fulfill this requirement.</span></span> <span data-ttu-id="1f2e3-128">Tento přístup je v podstatě paralelizace omezení s <xref:System.Threading.SemaphoreSlim> jako implementace.</span><span class="sxs-lookup"><span data-stu-id="1f2e3-128">This approach is essentially a parallelization throttle with <xref:System.Threading.SemaphoreSlim> as the implementation.</span></span> <span data-ttu-id="1f2e3-129">Umožňuje také "fronty" mimo přepážky.</span><span class="sxs-lookup"><span data-stu-id="1f2e3-129">It also permits a "queue" outside the bulkhead.</span></span> <span data-ttu-id="1f2e3-130">Můžete aktivně zbavit nadměrné zatížení ještě před spuštěním (například proto kapacity se bude považovat za úplné).</span><span class="sxs-lookup"><span data-stu-id="1f2e3-130">You can proactively shed excess load even before execution (for example, because capacity is deemed full).</span></span> <span data-ttu-id="1f2e3-131">Díky tomu odpověď určitých scénářích selhání rychleji, než by jistič, protože jistič čeká na chyby.</span><span class="sxs-lookup"><span data-stu-id="1f2e3-131">This makes its response to certain failure scenarios faster than a circuit breaker would be, since the circuit breaker waits for the failures.</span></span> <span data-ttu-id="1f2e3-132">Objekt BulkheadPolicy v Polly zpřístupňuje jak přepážka a jsou fronty a nabídky události při přetečení tak můžete také použít Centrum umožňující prosazovat automatické horizontální škálování.</span><span class="sxs-lookup"><span data-stu-id="1f2e3-132">The BulkheadPolicy object in Polly exposes how full the bulkhead and queue are, and offers events on overflow so can also be used to drive automated horizontal scaling.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="1f2e3-133">Další zdroje</span><span class="sxs-lookup"><span data-stu-id="1f2e3-133">Additional resources</span></span>

-   <span data-ttu-id="1f2e3-134">**Způsoby zajištění odolnosti**
    [*https://docs.microsoft.com/azure/architecture/patterns/category/resiliency*](https://docs.microsoft.com/azure/architecture/patterns/category/resiliency)</span><span class="sxs-lookup"><span data-stu-id="1f2e3-134">**Resiliency patterns**
[*https://docs.microsoft.com/azure/architecture/patterns/category/resiliency*](https://docs.microsoft.com/azure/architecture/patterns/category/resiliency)</span></span>

-   <span data-ttu-id="1f2e3-135">**Přidání odolnost a optimalizace výkonu**
    [*https://msdn.microsoft.com/library/jj591574.aspx*](https://msdn.microsoft.com/library/jj591574.aspx)</span><span class="sxs-lookup"><span data-stu-id="1f2e3-135">**Adding Resilience and Optimizing Performance**
[*https://msdn.microsoft.com/library/jj591574.aspx*](https://msdn.microsoft.com/library/jj591574.aspx)</span></span>

-   <span data-ttu-id="1f2e3-136">**Přepážky.**</span><span class="sxs-lookup"><span data-stu-id="1f2e3-136">**Bulkhead.**</span></span> <span data-ttu-id="1f2e3-137">Úložiště GitHub.</span><span class="sxs-lookup"><span data-stu-id="1f2e3-137">GitHub repo.</span></span> <span data-ttu-id="1f2e3-138">Implementace pomocí knihovny Polly zásad. \\</span><span class="sxs-lookup"><span data-stu-id="1f2e3-138">Implementation with Polly policy.\\</span></span>
    [*https://github.com/App-vNext/Polly/wiki/Bulkhead*](https://github.com/App-vNext/Polly/wiki/Bulkhead)

-   <span data-ttu-id="1f2e3-139">**Návrh odolných aplikací pro Azure**
    [*https://docs.microsoft.com/azure/architecture/resiliency/*](https://docs.microsoft.com/azure/architecture/resiliency/)</span><span class="sxs-lookup"><span data-stu-id="1f2e3-139">**Designing resilient applications for Azure**
[*https://docs.microsoft.com/azure/architecture/resiliency/*](https://docs.microsoft.com/azure/architecture/resiliency/)</span></span>

-   <span data-ttu-id="1f2e3-140">**Zpracování přechodných chyb**
    <https://docs.microsoft.com/azure/architecture/best-practices/transient-faults></span><span class="sxs-lookup"><span data-stu-id="1f2e3-140">**Transient fault handling**
<https://docs.microsoft.com/azure/architecture/best-practices/transient-faults></span></span>


>[!div class="step-by-step"]
<span data-ttu-id="1f2e3-141">[Předchozí](handle-partial-failure.md)
[další](implement-retries-exponential-backoff.md)</span><span class="sxs-lookup"><span data-stu-id="1f2e3-141">[Previous](handle-partial-failure.md)
[Next](implement-retries-exponential-backoff.md)</span></span>
