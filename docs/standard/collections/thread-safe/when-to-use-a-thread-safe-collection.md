---
title: Kdy použít kolekci s bezpečnými vlákny
ms.date: 03/30/2017
ms.technology: dotnet-standard
helpviewer_keywords:
- thread-safe collections, when to upgrade
ms.assetid: a9babe97-e457-4ff3-b528-a1bc940d5320
ms.openlocfilehash: 5a0abef6de9f932f44fc7e3239b98c3a27846580
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 03/15/2020
ms.locfileid: "75711217"
---
# <a name="when-to-use-a-thread-safe-collection"></a><span data-ttu-id="abd33-102">Kdy použít kolekci s bezpečnými vlákny</span><span class="sxs-lookup"><span data-stu-id="abd33-102">When to Use a Thread-Safe Collection</span></span>
<span data-ttu-id="abd33-103">Rozhraní .NET Framework 4 zavádí pět nových typů kolekce, které jsou speciálně navrženy pro podporu vícevláknových operací přidání a odebrání.</span><span class="sxs-lookup"><span data-stu-id="abd33-103">The .NET Framework 4 introduces five new collection types that are specially designed to support multi-threaded add and remove operations.</span></span> <span data-ttu-id="abd33-104">Pro dosažení bezpečnosti závitů používají tyto nové typy různé druhy efektivních mechanismů uzamčení a synchronizace bez zámků.</span><span class="sxs-lookup"><span data-stu-id="abd33-104">To achieve thread-safety, these new types use various kinds of efficient locking and lock-free synchronization mechanisms.</span></span> <span data-ttu-id="abd33-105">Synchronizace zvyšuje režii operace.</span><span class="sxs-lookup"><span data-stu-id="abd33-105">Synchronization adds overhead to an operation.</span></span> <span data-ttu-id="abd33-106">Množství režie závisí na druhu synchronizace, která se používá, druh operací, které jsou prováděny a další faktory, jako je například počet podprocesů, které se pokoušejí souběžně přistupovat ke kolekci.</span><span class="sxs-lookup"><span data-stu-id="abd33-106">The amount of overhead depends on the kind of synchronization that is used, the kind of operations that are performed, and other factors such as the number of threads that are trying to concurrently access the collection.</span></span>  
  
 <span data-ttu-id="abd33-107">V některých scénářích je režie synchronizace zanedbatelná a umožňuje vícevláknovému typu provádět výrazně rychleji a škálovat mnohem lépe než jeho ekvivalent bez bezpečnosti vláken, pokud je chráněn externím zámkem.</span><span class="sxs-lookup"><span data-stu-id="abd33-107">In some scenarios, synchronization overhead is negligible and enables the multi-threaded type to perform significantly faster and scale far better than its non-thread-safe equivalent when protected by an external lock.</span></span> <span data-ttu-id="abd33-108">V jiných scénářích může režie způsobit, že typ bezpečný pro přístup z více vláken provede a škáluje přibližně stejně nebo dokonce pomaleji než externě uzamčená verze typu, která není bezpečná pro přístup z více vláken.</span><span class="sxs-lookup"><span data-stu-id="abd33-108">In other scenarios, the overhead can cause the thread-safe type to perform and scale about the same or even more slowly than the externally-locked, non-thread-safe version of the type.</span></span>  
  
 <span data-ttu-id="abd33-109">Následující části poskytují obecné pokyny o tom, kdy použít kolekci bezpečnou pro přístup z více vláken oproti jeho ekvivalentu, který není bezpečný pro přístup z více vláken a který má zámek zadaný uživatelem kolem operací čtení a zápisu.</span><span class="sxs-lookup"><span data-stu-id="abd33-109">The following sections provide general guidance about when to use a thread-safe collection versus its non-thread-safe equivalent that has a user-provided lock around its read and write operations.</span></span> <span data-ttu-id="abd33-110">Vzhledem k tomu, že výkon se může lišit v závislosti na mnoha faktorech, pokyny nejsou specifické a nemusí být nutně platné za všech okolností.</span><span class="sxs-lookup"><span data-stu-id="abd33-110">Because performance may vary depending on many factors, the guidance is not specific and is not necessarily valid in all circumstances.</span></span> <span data-ttu-id="abd33-111">Pokud výkon je velmi důležité, pak nejlepší způsob, jak určit, který typ kolekce použít, je měření výkonu na základě konfigurace reprezentativní počítače a zatížení.</span><span class="sxs-lookup"><span data-stu-id="abd33-111">If performance is very important, then the best way to determine which collection type to use is to measure performance based on representative computer configurations and loads.</span></span> <span data-ttu-id="abd33-112">Tento dokument používá následující termíny:</span><span class="sxs-lookup"><span data-stu-id="abd33-112">This document uses the following terms:</span></span>  
  
 <span data-ttu-id="abd33-113">*Čistý scénář výrobce a spotřebitele*</span><span class="sxs-lookup"><span data-stu-id="abd33-113">*Pure producer-consumer scenario*</span></span>  
 <span data-ttu-id="abd33-114">Jakékoli dané vlákno je buď přidání nebo odebrání prvků, ale ne obojí.</span><span class="sxs-lookup"><span data-stu-id="abd33-114">Any given thread is either adding or removing elements, but not both.</span></span>  
  
 <span data-ttu-id="abd33-115">*Smíšený scénář mezi producentem a spotřebitelem*</span><span class="sxs-lookup"><span data-stu-id="abd33-115">*Mixed producer-consumer scenario*</span></span>  
 <span data-ttu-id="abd33-116">Jakékoli dané vlákno je přidání a odebrání prvků.</span><span class="sxs-lookup"><span data-stu-id="abd33-116">Any given thread is both adding and removing elements.</span></span>  
  
 <span data-ttu-id="abd33-117">*Zrychlení*</span><span class="sxs-lookup"><span data-stu-id="abd33-117">*Speedup*</span></span>  
 <span data-ttu-id="abd33-118">Rychlejší algoritmický výkon vzhledem k jinému typu ve stejném scénáři.</span><span class="sxs-lookup"><span data-stu-id="abd33-118">Faster algorithmic performance relative to another type in the same scenario.</span></span>  
  
 <span data-ttu-id="abd33-119">*Škálovatelnost*</span><span class="sxs-lookup"><span data-stu-id="abd33-119">*Scalability*</span></span>  
 <span data-ttu-id="abd33-120">Zvýšení výkonu, který je úměrný počtu jader v počítači.</span><span class="sxs-lookup"><span data-stu-id="abd33-120">The increase in performance that is proportional to the number of cores on the computer.</span></span> <span data-ttu-id="abd33-121">Algoritmus, který škáluje provádí rychleji na osm jader, než to dělá na dvou jádrech.</span><span class="sxs-lookup"><span data-stu-id="abd33-121">An algorithm that scales performs faster on eight cores than it does on two cores.</span></span>  
  
## <a name="concurrentqueuet-vs-queuet"></a><span data-ttu-id="abd33-122">ConcurrentQueue(T) vs. Queue(T)</span><span class="sxs-lookup"><span data-stu-id="abd33-122">ConcurrentQueue(T) vs. Queue(T)</span></span>  
 <span data-ttu-id="abd33-123">V čistě výrobce a spotřebitele scénáře, kde doba zpracování pro každý <xref:System.Collections.Concurrent.ConcurrentQueue%601?displayProperty=nameWithType> prvek je velmi malý <xref:System.Collections.Generic.Queue%601?displayProperty=nameWithType> (několik pokynů), pak může nabídnout skromné výhody výkonu oproti který má externí zámek.</span><span class="sxs-lookup"><span data-stu-id="abd33-123">In pure producer-consumer scenarios, where the processing time for each element is very small (a few instructions), then <xref:System.Collections.Concurrent.ConcurrentQueue%601?displayProperty=nameWithType> can offer modest performance benefits over a <xref:System.Collections.Generic.Queue%601?displayProperty=nameWithType> that has an external lock.</span></span> <span data-ttu-id="abd33-124">V tomto <xref:System.Collections.Concurrent.ConcurrentQueue%601> scénáři funguje nejlépe, když jeden vyhrazené vlákno je fronty a jeden vyhrazené vlákno je de-queuing.</span><span class="sxs-lookup"><span data-stu-id="abd33-124">In this scenario, <xref:System.Collections.Concurrent.ConcurrentQueue%601> performs best when one dedicated thread is queuing and one dedicated thread is de-queuing.</span></span> <span data-ttu-id="abd33-125">Pokud toto pravidlo nevynucujete, může <xref:System.Collections.Generic.Queue%601> <xref:System.Collections.Concurrent.ConcurrentQueue%601> být dokonce rychlejší než v počítačích s více jádry.</span><span class="sxs-lookup"><span data-stu-id="abd33-125">If you do not enforce this rule, then <xref:System.Collections.Generic.Queue%601> might even perform slightly faster than <xref:System.Collections.Concurrent.ConcurrentQueue%601> on computers that have multiple cores.</span></span>  
  
 <span data-ttu-id="abd33-126">Pokud doba zpracování je kolem 500 FLOPS (operace s plovoucí desetinnou <xref:System.Collections.Concurrent.ConcurrentQueue%601>tísní) nebo více, pak pravidlo dvou vláken se nevztahuje na , který pak má velmi dobrou škálovatelnost.</span><span class="sxs-lookup"><span data-stu-id="abd33-126">When processing time is around 500 FLOPS (floating point operations) or more, then the two-thread rule does not apply to <xref:System.Collections.Concurrent.ConcurrentQueue%601>, which then has very good scalability.</span></span> <span data-ttu-id="abd33-127"><xref:System.Collections.Generic.Queue%601>není škálovat dobře v tomto scénáři.</span><span class="sxs-lookup"><span data-stu-id="abd33-127"><xref:System.Collections.Generic.Queue%601> does not scale well in this scenario.</span></span>  
  
 <span data-ttu-id="abd33-128">Ve smíšených scénářích výrobce a spotřebitele, když <xref:System.Collections.Generic.Queue%601> je doba zpracování velmi <xref:System.Collections.Concurrent.ConcurrentQueue%601> malá, a která má externí zámek váhy lepší než nemá.</span><span class="sxs-lookup"><span data-stu-id="abd33-128">In mixed producer-consumer scenarios, when the processing time is very small, a <xref:System.Collections.Generic.Queue%601> that has an external lock scales better than <xref:System.Collections.Concurrent.ConcurrentQueue%601> does.</span></span> <span data-ttu-id="abd33-129">Nicméně, když doba zpracování je kolem 500 <xref:System.Collections.Concurrent.ConcurrentQueue%601> FLOPS nebo více, pak váhy lepší.</span><span class="sxs-lookup"><span data-stu-id="abd33-129">However, when processing time is around 500 FLOPS or more, then the <xref:System.Collections.Concurrent.ConcurrentQueue%601> scales better.</span></span>  
  
## <a name="concurrentstack-vs-stack"></a><span data-ttu-id="abd33-130">Souběžný zásobník vs. zásobník</span><span class="sxs-lookup"><span data-stu-id="abd33-130">ConcurrentStack vs. Stack</span></span>  
 <span data-ttu-id="abd33-131">V čistě výrobce-spotřebitelské scénáře, kdy je <xref:System.Collections.Concurrent.ConcurrentStack%601?displayProperty=nameWithType> doba <xref:System.Collections.Generic.Stack%601?displayProperty=nameWithType> zpracování velmi malá, pak a že má externí zámek bude pravděpodobně provádět přibližně stejné s jedním vyhrazeným tlačí cípem a jeden vyhrazený odprýskávání vlákno.</span><span class="sxs-lookup"><span data-stu-id="abd33-131">In pure producer-consumer scenarios, when processing time is very small, then <xref:System.Collections.Concurrent.ConcurrentStack%601?displayProperty=nameWithType> and <xref:System.Collections.Generic.Stack%601?displayProperty=nameWithType> that has an external lock will probably perform about the same with one dedicated pushing thread and one dedicated popping thread.</span></span> <span data-ttu-id="abd33-132">Však jako počet podprocesů zvyšuje, oba typy zpomalit <xref:System.Collections.Generic.Stack%601> z důvodu <xref:System.Collections.Concurrent.ConcurrentStack%601>zvýšené kolize a může fungovat lépe než .</span><span class="sxs-lookup"><span data-stu-id="abd33-132">However, as the number of threads increases, both types slow down because of increased contention, and <xref:System.Collections.Generic.Stack%601> might perform better than <xref:System.Collections.Concurrent.ConcurrentStack%601>.</span></span> <span data-ttu-id="abd33-133">Pokud je doba zpracování kolem 500 FLOPS nebo více, pak oba typy měřítko na přibližně stejnou rychlostí.</span><span class="sxs-lookup"><span data-stu-id="abd33-133">When processing time is around 500 FLOPS or more, then both types scale at about the same rate.</span></span>  
  
 <span data-ttu-id="abd33-134">Ve smíšených scénářích <xref:System.Collections.Concurrent.ConcurrentStack%601> výrobce a spotřebitele je rychlejší pro malé i velké úlohy.</span><span class="sxs-lookup"><span data-stu-id="abd33-134">In mixed producer-consumer scenarios, <xref:System.Collections.Concurrent.ConcurrentStack%601> is faster for both small and large workloads.</span></span>  
  
 <span data-ttu-id="abd33-135">Použití <xref:System.Collections.Concurrent.ConcurrentStack%601.PushRange%2A> a <xref:System.Collections.Concurrent.ConcurrentStack%601.TryPopRange%2A> může výrazně urychlit přístupové časy.</span><span class="sxs-lookup"><span data-stu-id="abd33-135">The use of the <xref:System.Collections.Concurrent.ConcurrentStack%601.PushRange%2A> and <xref:System.Collections.Concurrent.ConcurrentStack%601.TryPopRange%2A> may greatly speed up access times.</span></span>  
  
## <a name="concurrentdictionary-vs-dictionary"></a><span data-ttu-id="abd33-136">ConcurrentDictionary vs. Slovník</span><span class="sxs-lookup"><span data-stu-id="abd33-136">ConcurrentDictionary vs. Dictionary</span></span>  
 <span data-ttu-id="abd33-137">Obecně použijte <xref:System.Collections.Concurrent.ConcurrentDictionary%602?displayProperty=nameWithType> v každém scénáři, kde přidáváte a aktualizujete klíče nebo hodnoty současně z více vláken.</span><span class="sxs-lookup"><span data-stu-id="abd33-137">In general, use a <xref:System.Collections.Concurrent.ConcurrentDictionary%602?displayProperty=nameWithType> in any scenario where you are adding and updating keys or values concurrently from multiple threads.</span></span> <span data-ttu-id="abd33-138">Ve scénářích, které zahrnují časté <xref:System.Collections.Concurrent.ConcurrentDictionary%602> aktualizace a relativně málo čtení, obecně nabízí skromné výhody.</span><span class="sxs-lookup"><span data-stu-id="abd33-138">In scenarios that involve frequent updates and relatively few reads, the <xref:System.Collections.Concurrent.ConcurrentDictionary%602> generally offers modest benefits.</span></span> <span data-ttu-id="abd33-139">Ve scénářích, které zahrnují mnoho <xref:System.Collections.Concurrent.ConcurrentDictionary%602> čtení a mnoho aktualizací, obecně je výrazně rychlejší v počítačích, které mají libovolný počet jader.</span><span class="sxs-lookup"><span data-stu-id="abd33-139">In scenarios that involve many reads and many updates, the <xref:System.Collections.Concurrent.ConcurrentDictionary%602> generally is significantly faster on computers that have any number of cores.</span></span>  
  
 <span data-ttu-id="abd33-140">Ve scénářích, které zahrnují časté aktualizace, můžete <xref:System.Collections.Concurrent.ConcurrentDictionary%602> zvýšit stupeň souběžnosti v a pak měřit, zda zvýšení výkonu v počítačích, které mají více jader.</span><span class="sxs-lookup"><span data-stu-id="abd33-140">In scenarios that involve frequent updates, you can increase the degree of concurrency in the <xref:System.Collections.Concurrent.ConcurrentDictionary%602> and then measure to see whether performance increases on computers that have more cores.</span></span> <span data-ttu-id="abd33-141">Pokud změníte úroveň souběžnosti, vyhněte se globální operace co nejvíce.</span><span class="sxs-lookup"><span data-stu-id="abd33-141">If you change the concurrency level, avoid global operations as much as possible.</span></span>  
  
 <span data-ttu-id="abd33-142">Pokud čtete pouze klíč nebo <xref:System.Collections.Generic.Dictionary%602> hodnoty, je rychlejší, protože není vyžadována žádná synchronizace, pokud slovník není měněn žádnými vlákny.</span><span class="sxs-lookup"><span data-stu-id="abd33-142">If you are only reading key or values, the <xref:System.Collections.Generic.Dictionary%602> is faster because no synchronization is required if the dictionary is not being modified by any threads.</span></span>  
  
## <a name="concurrentbag"></a><span data-ttu-id="abd33-143">Concurrentbag</span><span class="sxs-lookup"><span data-stu-id="abd33-143">ConcurrentBag</span></span>  
 <span data-ttu-id="abd33-144">V čistě výrobce a <xref:System.Collections.Concurrent.ConcurrentBag%601?displayProperty=nameWithType> spotřebitele scénáře bude pravděpodobně provádět pomaleji než ostatní typy souběžných kolekcí.</span><span class="sxs-lookup"><span data-stu-id="abd33-144">In pure producer-consumer scenarios, <xref:System.Collections.Concurrent.ConcurrentBag%601?displayProperty=nameWithType> will probably perform more slowly than the other concurrent collection types.</span></span>  
  
 <span data-ttu-id="abd33-145">Ve smíšených scénáře <xref:System.Collections.Concurrent.ConcurrentBag%601> výrobce a spotřebitele je obecně mnohem rychlejší a škálovatelné než jakýkoli jiný typ souběžné kolekce pro velké i malé úlohy.</span><span class="sxs-lookup"><span data-stu-id="abd33-145">In mixed producer-consumer scenarios, <xref:System.Collections.Concurrent.ConcurrentBag%601> is generally much faster and more scalable than any other concurrent collection type for both large and small workloads.</span></span>  
  
## <a name="blockingcollection"></a><span data-ttu-id="abd33-146">BlockingCollection</span><span class="sxs-lookup"><span data-stu-id="abd33-146">BlockingCollection</span></span>  
 <span data-ttu-id="abd33-147">Při ohraničování a blokování <xref:System.Collections.Concurrent.BlockingCollection%601?displayProperty=nameWithType> sémantiku jsou požadovány, bude pravděpodobně provádět rychleji než jakékoli vlastní implementace.</span><span class="sxs-lookup"><span data-stu-id="abd33-147">When bounding and blocking semantics are required, <xref:System.Collections.Concurrent.BlockingCollection%601?displayProperty=nameWithType> will probably perform faster than any custom implementation.</span></span> <span data-ttu-id="abd33-148">Podporuje také bohaté zrušení, výčtu a zpracování výjimek.</span><span class="sxs-lookup"><span data-stu-id="abd33-148">It also supports rich cancellation, enumeration, and exception handling.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="abd33-149">Viz také</span><span class="sxs-lookup"><span data-stu-id="abd33-149">See also</span></span>

- <xref:System.Collections.Concurrent?displayProperty=nameWithType>
- [<span data-ttu-id="abd33-150">Kolekce se zabezpečenými vlákny</span><span class="sxs-lookup"><span data-stu-id="abd33-150">Thread-Safe Collections</span></span>](../../../../docs/standard/collections/thread-safe/index.md)
- [<span data-ttu-id="abd33-151">Paralelní programování</span><span class="sxs-lookup"><span data-stu-id="abd33-151">Parallel Programming</span></span>](../../../../docs/standard/parallel-programming/index.md)
