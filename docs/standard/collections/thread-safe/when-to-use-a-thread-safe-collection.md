---
title: Kdy použít kolekci s bezpečnými vlákny
description: Zjistěte, kdy použít kolekci bezpečnou pro přístup z více vláken v rozhraní .NET. K dispozici je 5 typů kolekcí, které jsou speciálně navržené pro podporu vícevláknových operací Add & Remove.
ms.date: 03/30/2017
ms.technology: dotnet-standard
helpviewer_keywords:
- thread-safe collections, when to upgrade
ms.assetid: a9babe97-e457-4ff3-b528-a1bc940d5320
ms.openlocfilehash: 499af6d7b8de1decbcffefe0a3b1420cc548488a
ms.sourcegitcommit: dc2feef0794cf41dbac1451a13b8183258566c0e
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 06/24/2020
ms.locfileid: "85326040"
---
# <a name="when-to-use-a-thread-safe-collection"></a><span data-ttu-id="d5770-104">Kdy použít kolekci bezpečnou pro přístup z více vláken</span><span class="sxs-lookup"><span data-stu-id="d5770-104">When to use a thread-safe collection</span></span>

<span data-ttu-id="d5770-105">.NET Framework 4 zavedl pět typů kolekcí, které jsou speciálně navržené pro podporu vícevláknových operací přidávání a odebírání.</span><span class="sxs-lookup"><span data-stu-id="d5770-105">.NET Framework 4 introduced five collection types that are specially designed to support multi-threaded add and remove operations.</span></span> <span data-ttu-id="d5770-106">Pro zajištění bezpečnosti vláken tyto typy používají různé druhy efektivních zámků a synchronizačních mechanismů bez zámků.</span><span class="sxs-lookup"><span data-stu-id="d5770-106">To achieve thread-safety, these types use various kinds of efficient locking and lock-free synchronization mechanisms.</span></span> <span data-ttu-id="d5770-107">Synchronizace přidává k operaci režii.</span><span class="sxs-lookup"><span data-stu-id="d5770-107">Synchronization adds overhead to an operation.</span></span> <span data-ttu-id="d5770-108">Množství režie závisí na druhu používané synchronizace, typu prováděných operací a dalších faktorech, jako je počet vláken, která se pokoušejí souběžně přistupovat ke kolekci.</span><span class="sxs-lookup"><span data-stu-id="d5770-108">The amount of overhead depends on the kind of synchronization that is used, the kind of operations that are performed, and other factors such as the number of threads that are trying to concurrently access the collection.</span></span>  
  
 <span data-ttu-id="d5770-109">V některých scénářích je režijní náklady na synchronizaci zanedbatelná a umožňuje, aby vícevláknový typ byl výrazně rychlejší a lépe škálovatelný, než je ekvivalent bez bezpečného vlákna, pokud je chráněn externím zámkem.</span><span class="sxs-lookup"><span data-stu-id="d5770-109">In some scenarios, synchronization overhead is negligible and enables the multi-threaded type to perform significantly faster and scale far better than its non-thread-safe equivalent when protected by an external lock.</span></span> <span data-ttu-id="d5770-110">V jiných scénářích může režie způsobit, že typ bezpečný pro přístup z více vláken provede a škáluje o stejné nebo ještě pomalejší úrovni než verze typu externě uzamčená bez možnosti bezpečného přístupu z více vláken.</span><span class="sxs-lookup"><span data-stu-id="d5770-110">In other scenarios, the overhead can cause the thread-safe type to perform and scale about the same or even more slowly than the externally-locked, non-thread-safe version of the type.</span></span>  
  
 <span data-ttu-id="d5770-111">V následujících částech najdete obecné pokyny k tomu, kdy použít kolekci bezpečnou pro přístup z více vláken a jejich ekvivalent bez bezpečného přístupu k vláknům, který má uživatelem poskytnutý zámek pro operace čtení a zápisu.</span><span class="sxs-lookup"><span data-stu-id="d5770-111">The following sections provide general guidance about when to use a thread-safe collection versus its non-thread-safe equivalent that has a user-provided lock around its read and write operations.</span></span> <span data-ttu-id="d5770-112">Vzhledem k tomu, že výkon se může lišit v závislosti na mnoha faktorech, doprovodné materiály nejsou specifické a nemusí nutně platit za všech okolností.</span><span class="sxs-lookup"><span data-stu-id="d5770-112">Because performance may vary depending on many factors, the guidance is not specific and is not necessarily valid in all circumstances.</span></span> <span data-ttu-id="d5770-113">Pokud je výkon velmi důležitý, pak nejlepším způsobem určení toho, který typ kolekce použít, je měření výkonu na základě reprezentativních konfigurací počítačů a zatížení.</span><span class="sxs-lookup"><span data-stu-id="d5770-113">If performance is very important, then the best way to determine which collection type to use is to measure performance based on representative computer configurations and loads.</span></span> <span data-ttu-id="d5770-114">Tento dokument používá následující výrazy:</span><span class="sxs-lookup"><span data-stu-id="d5770-114">This document uses the following terms:</span></span>  
  
 <span data-ttu-id="d5770-115">*Scénář čistého producenta pro spotřebitele*</span><span class="sxs-lookup"><span data-stu-id="d5770-115">*Pure producer-consumer scenario*</span></span>\
 <span data-ttu-id="d5770-116">Jakékoli dané vlákno buď přidává nebo odebírá prvky, ale ne obojí.</span><span class="sxs-lookup"><span data-stu-id="d5770-116">Any given thread is either adding or removing elements, but not both.</span></span>  
  
 <span data-ttu-id="d5770-117">*Smíšený scénář producent – příjemce*</span><span class="sxs-lookup"><span data-stu-id="d5770-117">*Mixed producer-consumer scenario*</span></span>\
 <span data-ttu-id="d5770-118">Jakékoli dané vlákno je přidávání a odebírání prvků.</span><span class="sxs-lookup"><span data-stu-id="d5770-118">Any given thread is both adding and removing elements.</span></span>  
  
 <span data-ttu-id="d5770-119">*Zrychlení*</span><span class="sxs-lookup"><span data-stu-id="d5770-119">*Speedup*</span></span>\
 <span data-ttu-id="d5770-120">Rychlejší výkon algoritmu vzhledem k jinému typu ve stejném scénáři.</span><span class="sxs-lookup"><span data-stu-id="d5770-120">Faster algorithmic performance relative to another type in the same scenario.</span></span>  
  
 <span data-ttu-id="d5770-121">*Škálovatelnost*</span><span class="sxs-lookup"><span data-stu-id="d5770-121">*Scalability*</span></span>\
 <span data-ttu-id="d5770-122">Zvýšení výkonu, které je úměrné počtu jader v počítači.</span><span class="sxs-lookup"><span data-stu-id="d5770-122">The increase in performance that is proportional to the number of cores on the computer.</span></span> <span data-ttu-id="d5770-123">Algoritmus, který se škáluje, se zrychluje na osm jader, než na dvou jádrech.</span><span class="sxs-lookup"><span data-stu-id="d5770-123">An algorithm that scales performs faster on eight cores than it does on two cores.</span></span>  
  
## <a name="concurrentqueuet-vs-queuet"></a><span data-ttu-id="d5770-124">ConcurrentQueue (T) vs. Queue (T)</span><span class="sxs-lookup"><span data-stu-id="d5770-124">ConcurrentQueue(T) vs. Queue(T)</span></span>  
 <span data-ttu-id="d5770-125">V čistých scénářích producent – spotřebitel, kde je čas zpracování každého prvku velmi malý (několik pokynů), pak <xref:System.Collections.Concurrent.ConcurrentQueue%601?displayProperty=nameWithType> může nabídnout mírné zvýšení výkonu v případě <xref:System.Collections.Generic.Queue%601?displayProperty=nameWithType> , že má externí zámek.</span><span class="sxs-lookup"><span data-stu-id="d5770-125">In pure producer-consumer scenarios, where the processing time for each element is very small (a few instructions), then <xref:System.Collections.Concurrent.ConcurrentQueue%601?displayProperty=nameWithType> can offer modest performance benefits over a <xref:System.Collections.Generic.Queue%601?displayProperty=nameWithType> that has an external lock.</span></span> <span data-ttu-id="d5770-126">V tomto scénáři má <xref:System.Collections.Concurrent.ConcurrentQueue%601> nejlepší výkon, když jedno vyhrazené vlákno zařadí do fronty a jedno vyhrazené vlákno rozchází do fronty.</span><span class="sxs-lookup"><span data-stu-id="d5770-126">In this scenario, <xref:System.Collections.Concurrent.ConcurrentQueue%601> performs best when one dedicated thread is queuing and one dedicated thread is de-queuing.</span></span> <span data-ttu-id="d5770-127">Pokud toto pravidlo nevyberete, <xref:System.Collections.Generic.Queue%601> může být dokonce mnohem rychlejší než <xref:System.Collections.Concurrent.ConcurrentQueue%601> na počítačích, které mají více jader.</span><span class="sxs-lookup"><span data-stu-id="d5770-127">If you do not enforce this rule, then <xref:System.Collections.Generic.Queue%601> might even perform slightly faster than <xref:System.Collections.Concurrent.ConcurrentQueue%601> on computers that have multiple cores.</span></span>  
  
 <span data-ttu-id="d5770-128">Když je čas zpracování okolo 500. (operace s plovoucí desetinnou čárkou) nebo více, pak pravidlo dvou vláken se nevztahuje na <xref:System.Collections.Concurrent.ConcurrentQueue%601> , které pak má velmi dobrou škálovatelnost.</span><span class="sxs-lookup"><span data-stu-id="d5770-128">When processing time is around 500 FLOPS (floating point operations) or more, then the two-thread rule does not apply to <xref:System.Collections.Concurrent.ConcurrentQueue%601>, which then has very good scalability.</span></span> <span data-ttu-id="d5770-129"><xref:System.Collections.Generic.Queue%601>v tomto scénáři se dobře neškáluje.</span><span class="sxs-lookup"><span data-stu-id="d5770-129"><xref:System.Collections.Generic.Queue%601> does not scale well in this scenario.</span></span>  
  
 <span data-ttu-id="d5770-130">Ve smíšených scénářích pro spotřebitele, pokud je doba zpracování velmi malá, <xref:System.Collections.Generic.Queue%601> má externí zámek větší měřítko než to <xref:System.Collections.Concurrent.ConcurrentQueue%601> dělá.</span><span class="sxs-lookup"><span data-stu-id="d5770-130">In mixed producer-consumer scenarios, when the processing time is very small, a <xref:System.Collections.Generic.Queue%601> that has an external lock scales better than <xref:System.Collections.Concurrent.ConcurrentQueue%601> does.</span></span> <span data-ttu-id="d5770-131">Pokud je však čas zpracování okolo 500 nebo více, je <xref:System.Collections.Concurrent.ConcurrentQueue%601> lepší škálování.</span><span class="sxs-lookup"><span data-stu-id="d5770-131">However, when processing time is around 500 FLOPS or more, then the <xref:System.Collections.Concurrent.ConcurrentQueue%601> scales better.</span></span>  
  
## <a name="concurrentstack-vs-stack"></a><span data-ttu-id="d5770-132">Objektu ConcurrentStack vs. Stack</span><span class="sxs-lookup"><span data-stu-id="d5770-132">ConcurrentStack vs. Stack</span></span>  
 <span data-ttu-id="d5770-133">V čistých scénářích producent – spotřebitel, pokud je doba zpracování velmi malá, pak <xref:System.Collections.Concurrent.ConcurrentStack%601?displayProperty=nameWithType> a s <xref:System.Collections.Generic.Stack%601?displayProperty=nameWithType> tím, že se externí zámek bude pravděpodobně provádět přibližně stejně jako jedno vyhrazené vlákno vložení a jedno vyhrazené vyjímáné vlákno.</span><span class="sxs-lookup"><span data-stu-id="d5770-133">In pure producer-consumer scenarios, when processing time is very small, then <xref:System.Collections.Concurrent.ConcurrentStack%601?displayProperty=nameWithType> and <xref:System.Collections.Generic.Stack%601?displayProperty=nameWithType> that has an external lock will probably perform about the same with one dedicated pushing thread and one dedicated popping thread.</span></span> <span data-ttu-id="d5770-134">Vzhledem k tomu, že počet vláken se zvyšuje, oba typy zpomalují kvůli zvýšenému kolizí a <xref:System.Collections.Generic.Stack%601> můžou dosáhnout lepšího výkonu <xref:System.Collections.Concurrent.ConcurrentStack%601> .</span><span class="sxs-lookup"><span data-stu-id="d5770-134">However, as the number of threads increases, both types slow down because of increased contention, and <xref:System.Collections.Generic.Stack%601> might perform better than <xref:System.Collections.Concurrent.ConcurrentStack%601>.</span></span> <span data-ttu-id="d5770-135">Když je čas zpracování okolo 500 nebo více, pak oba typy škálují přibližně stejnou sazbu.</span><span class="sxs-lookup"><span data-stu-id="d5770-135">When processing time is around 500 FLOPS or more, then both types scale at about the same rate.</span></span>  
  
 <span data-ttu-id="d5770-136">Ve smíšených scénářích pro zákazníky <xref:System.Collections.Concurrent.ConcurrentStack%601> je pro malé i velké úlohy rychlejší.</span><span class="sxs-lookup"><span data-stu-id="d5770-136">In mixed producer-consumer scenarios, <xref:System.Collections.Concurrent.ConcurrentStack%601> is faster for both small and large workloads.</span></span>  
  
 <span data-ttu-id="d5770-137">Použití <xref:System.Collections.Concurrent.ConcurrentStack%601.PushRange%2A> a <xref:System.Collections.Concurrent.ConcurrentStack%601.TryPopRange%2A> může značně zrychlit dobu přístupu.</span><span class="sxs-lookup"><span data-stu-id="d5770-137">The use of the <xref:System.Collections.Concurrent.ConcurrentStack%601.PushRange%2A> and <xref:System.Collections.Concurrent.ConcurrentStack%601.TryPopRange%2A> may greatly speed up access times.</span></span>  
  
## <a name="concurrentdictionary-vs-dictionary"></a><span data-ttu-id="d5770-138">ConcurrentDictionary vs. Dictionary</span><span class="sxs-lookup"><span data-stu-id="d5770-138">ConcurrentDictionary vs. Dictionary</span></span>  
 <span data-ttu-id="d5770-139">Obecně použijte a <xref:System.Collections.Concurrent.ConcurrentDictionary%602?displayProperty=nameWithType> v jakémkoli scénáři, kdy přidáváte a aktualizujete klíče nebo hodnoty souběžně z více vláken.</span><span class="sxs-lookup"><span data-stu-id="d5770-139">In general, use a <xref:System.Collections.Concurrent.ConcurrentDictionary%602?displayProperty=nameWithType> in any scenario where you are adding and updating keys or values concurrently from multiple threads.</span></span> <span data-ttu-id="d5770-140">Ve scénářích, které zahrnují časté aktualizace a poměrně málo čtení, <xref:System.Collections.Concurrent.ConcurrentDictionary%602> všeobecně nabízí mírné výhody.</span><span class="sxs-lookup"><span data-stu-id="d5770-140">In scenarios that involve frequent updates and relatively few reads, the <xref:System.Collections.Concurrent.ConcurrentDictionary%602> generally offers modest benefits.</span></span> <span data-ttu-id="d5770-141">Ve scénářích, které zahrnují mnoho čtení a mnoho aktualizací, <xref:System.Collections.Concurrent.ConcurrentDictionary%602> je všeobecně výrazně rychlejší v počítačích, které mají libovolný počet jader.</span><span class="sxs-lookup"><span data-stu-id="d5770-141">In scenarios that involve many reads and many updates, the <xref:System.Collections.Concurrent.ConcurrentDictionary%602> generally is significantly faster on computers that have any number of cores.</span></span>  
  
 <span data-ttu-id="d5770-142">Ve scénářích, které zahrnují časté aktualizace, můžete zvýšit stupeň souběžnosti v <xref:System.Collections.Concurrent.ConcurrentDictionary%602> a pak změřit, abyste viděli, zda se výkon zvyšuje na počítačích s více jádry.</span><span class="sxs-lookup"><span data-stu-id="d5770-142">In scenarios that involve frequent updates, you can increase the degree of concurrency in the <xref:System.Collections.Concurrent.ConcurrentDictionary%602> and then measure to see whether performance increases on computers that have more cores.</span></span> <span data-ttu-id="d5770-143">Pokud změníte úroveň souběžnosti, vyhněte se globálním operacím co nejvíce.</span><span class="sxs-lookup"><span data-stu-id="d5770-143">If you change the concurrency level, avoid global operations as much as possible.</span></span>  
  
 <span data-ttu-id="d5770-144">Pokud čtete jenom klíč nebo hodnoty, <xref:System.Collections.Generic.Dictionary%602> je rychlejší, protože není nutná žádná synchronizace, pokud slovník neupravuje žádná vlákna.</span><span class="sxs-lookup"><span data-stu-id="d5770-144">If you are only reading key or values, the <xref:System.Collections.Generic.Dictionary%602> is faster because no synchronization is required if the dictionary is not being modified by any threads.</span></span>  
  
## <a name="concurrentbag"></a><span data-ttu-id="d5770-145">ConcurrentBag</span><span class="sxs-lookup"><span data-stu-id="d5770-145">ConcurrentBag</span></span>  
 <span data-ttu-id="d5770-146">V čistých scénářích producent-příjemce <xref:System.Collections.Concurrent.ConcurrentBag%601?displayProperty=nameWithType> bude pravděpodobně pomalejší než u ostatních typů souběžných kolekcí.</span><span class="sxs-lookup"><span data-stu-id="d5770-146">In pure producer-consumer scenarios, <xref:System.Collections.Concurrent.ConcurrentBag%601?displayProperty=nameWithType> will probably perform more slowly than the other concurrent collection types.</span></span>  
  
 <span data-ttu-id="d5770-147">Ve smíšených scénářích pro spotřebitele zákazníků <xref:System.Collections.Concurrent.ConcurrentBag%601> je všeobecně mnohem rychlejší a škálovatelnější než jakýkoli jiný typ souběžného shromažďování pro velké i malé úlohy.</span><span class="sxs-lookup"><span data-stu-id="d5770-147">In mixed producer-consumer scenarios, <xref:System.Collections.Concurrent.ConcurrentBag%601> is generally much faster and more scalable than any other concurrent collection type for both large and small workloads.</span></span>  
  
## <a name="blockingcollection"></a><span data-ttu-id="d5770-148">BlockingCollection</span><span class="sxs-lookup"><span data-stu-id="d5770-148">BlockingCollection</span></span>  
 <span data-ttu-id="d5770-149">Pokud jsou požadovány sémantika ohraničování a blokování, <xref:System.Collections.Concurrent.BlockingCollection%601?displayProperty=nameWithType> bude pravděpodobně prováděna rychleji než jakákoli vlastní implementace.</span><span class="sxs-lookup"><span data-stu-id="d5770-149">When bounding and blocking semantics are required, <xref:System.Collections.Concurrent.BlockingCollection%601?displayProperty=nameWithType> will probably perform faster than any custom implementation.</span></span> <span data-ttu-id="d5770-150">Podporuje také bohatou manipulaci s zrušením, výčtem a zpracováním výjimek.</span><span class="sxs-lookup"><span data-stu-id="d5770-150">It also supports rich cancellation, enumeration, and exception handling.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="d5770-151">Viz také</span><span class="sxs-lookup"><span data-stu-id="d5770-151">See also</span></span>

- <xref:System.Collections.Concurrent?displayProperty=nameWithType>
- [<span data-ttu-id="d5770-152">Kolekce bezpečné pro přístup z více vláken</span><span class="sxs-lookup"><span data-stu-id="d5770-152">Thread-Safe Collections</span></span>](index.md)
- [<span data-ttu-id="d5770-153">Paralelní programování</span><span class="sxs-lookup"><span data-stu-id="d5770-153">Parallel Programming</span></span>](../../parallel-programming/index.md)
