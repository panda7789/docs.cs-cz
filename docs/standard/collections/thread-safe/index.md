---
title: Kolekce se zabezpečenými vlákny
ms.date: 03/30/2017
ms.technology: dotnet-standard
helpviewer_keywords:
- thread-safe collections, overview
ms.assetid: 2e7ca21f-786c-4367-96be-0cf3f3dcc6bd
ms.openlocfilehash: 7af59cf0fdbe8d5c7d7d586b4b86992ae1dc7601
ms.sourcegitcommit: 33deec3e814238fb18a49b2a7e89278e27888291
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 06/02/2020
ms.locfileid: "84290367"
---
# <a name="thread-safe-collections"></a><span data-ttu-id="f7d8d-102">Kolekce se zabezpečenými vlákny</span><span class="sxs-lookup"><span data-stu-id="f7d8d-102">Thread-Safe Collections</span></span>
<span data-ttu-id="f7d8d-103">.NET Framework 4 zavádí <xref:System.Collections.Concurrent?displayProperty=nameWithType> obor názvů, který obsahuje několik tříd kolekcí, které jsou bezpečné pro přístup z více vláken a jsou škálovatelné.</span><span class="sxs-lookup"><span data-stu-id="f7d8d-103">The .NET Framework 4 introduces the <xref:System.Collections.Concurrent?displayProperty=nameWithType> namespace, which includes several collection classes that are both thread-safe and scalable.</span></span> <span data-ttu-id="f7d8d-104">Více vláken může bezpečně a efektivně přidávat nebo odebírat položky z těchto kolekcí, aniž by bylo potřeba provádět další synchronizaci v uživatelském kódu.</span><span class="sxs-lookup"><span data-stu-id="f7d8d-104">Multiple threads can safely and efficiently add or remove items from these collections, without requiring additional synchronization in user code.</span></span> <span data-ttu-id="f7d8d-105">Při psaní nového kódu, použijte souběžné třídy kolekce vždy, když více vláken bude zapisovat do kolekce současně.</span><span class="sxs-lookup"><span data-stu-id="f7d8d-105">When you write new code, use the concurrent collection classes whenever multiple threads will write to the collection concurrently.</span></span> <span data-ttu-id="f7d8d-106">Pokud čtete pouze ze sdílené kolekce, pak můžete použít třídy v <xref:System.Collections.Generic?displayProperty=nameWithType> oboru názvů.</span><span class="sxs-lookup"><span data-stu-id="f7d8d-106">If you are only reading from a shared collection, then you can use the classes in the <xref:System.Collections.Generic?displayProperty=nameWithType> namespace.</span></span> <span data-ttu-id="f7d8d-107">Doporučujeme, abyste nepoužívali třídy kolekcí 1,0, pokud není nutné cílit na .NET Framework 1,1 nebo starší modul runtime.</span><span class="sxs-lookup"><span data-stu-id="f7d8d-107">We recommend that you do not use 1.0 collection classes unless you are required to target the .NET Framework 1.1 or earlier runtime.</span></span>  
  
## <a name="thread-synchronization-in-the-net-framework-10-and-20-collections"></a><span data-ttu-id="f7d8d-108">Synchronizace vláken v kolekcích .NET Framework 1,0 a 2,0</span><span class="sxs-lookup"><span data-stu-id="f7d8d-108">Thread Synchronization in the .NET Framework 1.0 and 2.0 Collections</span></span>  
 <span data-ttu-id="f7d8d-109">Kolekce představené v .NET Framework 1,0 se nacházejí v <xref:System.Collections?displayProperty=nameWithType> oboru názvů.</span><span class="sxs-lookup"><span data-stu-id="f7d8d-109">The collections introduced in the .NET Framework 1.0 are found in the <xref:System.Collections?displayProperty=nameWithType> namespace.</span></span> <span data-ttu-id="f7d8d-110">Tyto kolekce, které zahrnují běžně používané <xref:System.Collections.ArrayList> a <xref:System.Collections.Hashtable> , poskytují určitá zabezpečení vlákna prostřednictvím `Synchronized` vlastnosti, která vrací obálku bezpečnou pro přístup z více vláken v kolekci.</span><span class="sxs-lookup"><span data-stu-id="f7d8d-110">These collections, which include the commonly used <xref:System.Collections.ArrayList> and <xref:System.Collections.Hashtable>, provide some thread-safety through the `Synchronized` property, which returns a thread-safe wrapper around the collection.</span></span> <span data-ttu-id="f7d8d-111">Obálka funguje tak, že při každé operaci přidání nebo odebrání zamkne celou kolekci.</span><span class="sxs-lookup"><span data-stu-id="f7d8d-111">The wrapper works by locking the entire collection on every add or remove operation.</span></span> <span data-ttu-id="f7d8d-112">Proto musí každé vlákno, které se pokouší o přístup ke kolekci, počkat na jeho vypnutí, aby bylo možné provést jeden zámek.</span><span class="sxs-lookup"><span data-stu-id="f7d8d-112">Therefore, each thread that is attempting to access the collection must wait for its turn to take the one lock.</span></span> <span data-ttu-id="f7d8d-113">To není škálovatelné a může způsobit výrazné snížení výkonu pro velké kolekce.</span><span class="sxs-lookup"><span data-stu-id="f7d8d-113">This is not scalable and can cause significant performance degradation for large collections.</span></span> <span data-ttu-id="f7d8d-114">Návrh také není zcela chráněn před konflikty časování.</span><span class="sxs-lookup"><span data-stu-id="f7d8d-114">Also, the design is not completely protected from race conditions.</span></span> <span data-ttu-id="f7d8d-115">Další informace najdete v tématu [synchronizace v obecných kolekcích](https://docs.microsoft.com/archive/blogs/bclteam/synchronization-in-generic-collections-brian-grunkemeyer).</span><span class="sxs-lookup"><span data-stu-id="f7d8d-115">For more information, see [Synchronization in Generic Collections](https://docs.microsoft.com/archive/blogs/bclteam/synchronization-in-generic-collections-brian-grunkemeyer).</span></span>  
  
 <span data-ttu-id="f7d8d-116">Třídy kolekce představené v .NET Framework 2,0 se nacházejí v <xref:System.Collections.Generic?displayProperty=nameWithType> oboru názvů.</span><span class="sxs-lookup"><span data-stu-id="f7d8d-116">The collection classes introduced in the .NET Framework 2.0 are found in the <xref:System.Collections.Generic?displayProperty=nameWithType> namespace.</span></span> <span data-ttu-id="f7d8d-117">Patří mezi ně <xref:System.Collections.Generic.List%601> , <xref:System.Collections.Generic.Dictionary%602> a tak dále.</span><span class="sxs-lookup"><span data-stu-id="f7d8d-117">These include <xref:System.Collections.Generic.List%601>, <xref:System.Collections.Generic.Dictionary%602>, and so on.</span></span> <span data-ttu-id="f7d8d-118">Tyto třídy poskytují lepší bezpečnost typů a výkon v porovnání s třídami .NET Framework 1,0.</span><span class="sxs-lookup"><span data-stu-id="f7d8d-118">These classes provide improved type safety and performance compared to the .NET Framework 1.0 classes.</span></span> <span data-ttu-id="f7d8d-119">Třídy kolekce .NET Framework 2,0 však neposkytují žádnou synchronizaci vláken; uživatelský kód musí poskytovat veškerou synchronizaci při přidávání nebo odebírání položek na více vláknech současně.</span><span class="sxs-lookup"><span data-stu-id="f7d8d-119">However, the .NET Framework 2.0 collection classes do not provide any thread synchronization; user code must provide all synchronization when items are added or removed on multiple threads concurrently.</span></span>  
  
 <span data-ttu-id="f7d8d-120">V .NET Framework 4 doporučujeme třídy souběžných kolekcí, protože neposkytují pouze bezpečnost typů tříd kolekce .NET Framework 2,0, ale také efektivnější a více kompletních bezpečnostních vláken, než poskytují kolekce .NET Framework 1,0.</span><span class="sxs-lookup"><span data-stu-id="f7d8d-120">We recommend the concurrent collections classes in the .NET Framework 4 because they provide not only the type safety of the .NET Framework 2.0 collection classes, but also more efficient and more complete thread safety than the .NET Framework 1.0 collections provide.</span></span>  
  
## <a name="fine-grained-locking-and-lock-free-mechanisms"></a><span data-ttu-id="f7d8d-121">Jemně odstupňované uzamykání a mechanismy bez zámků</span><span class="sxs-lookup"><span data-stu-id="f7d8d-121">Fine-Grained Locking and Lock-Free Mechanisms</span></span>  
 <span data-ttu-id="f7d8d-122">Některé typy souběžných kolekcí používají zjednodušené synchronizační mechanismy, jako jsou <xref:System.Threading.SpinLock> ,, <xref:System.Threading.SpinWait> <xref:System.Threading.SemaphoreSlim> a <xref:System.Threading.CountdownEvent> , které jsou v .NET Framework 4 novinkou.</span><span class="sxs-lookup"><span data-stu-id="f7d8d-122">Some of the concurrent collection types use lightweight synchronization mechanisms such as <xref:System.Threading.SpinLock>, <xref:System.Threading.SpinWait>, <xref:System.Threading.SemaphoreSlim>, and <xref:System.Threading.CountdownEvent>, which are new in the .NET Framework 4.</span></span> <span data-ttu-id="f7d8d-123">Tyto typy synchronizace obvykle využívají *zaneprázdněné odstřeďování* pro krátká období, předtím než se vlákno umístí do stavu true Wait.</span><span class="sxs-lookup"><span data-stu-id="f7d8d-123">These synchronization types typically use *busy spinning* for brief periods before they put the thread into a true Wait state.</span></span> <span data-ttu-id="f7d8d-124">Pokud se očekává, že čekací časy budou velmi krátké, otáčející se mnohem méně výpočetně nákladný než čekání, což zahrnuje nákladný přechod jádra.</span><span class="sxs-lookup"><span data-stu-id="f7d8d-124">When wait times are expected to be very short, spinning is far less computationally expensive than waiting, which involves an expensive kernel transition.</span></span> <span data-ttu-id="f7d8d-125">Pro třídy kolekcí, které používají odstřeďování, tato efektivita znamená, že více vláken může přidávat a odebírat položky s velmi vysokou mírou.</span><span class="sxs-lookup"><span data-stu-id="f7d8d-125">For collection classes that use spinning, this efficiency means that multiple threads can add and remove items at a very high rate.</span></span> <span data-ttu-id="f7d8d-126">Další informace o zablokování vs. blokování naleznete v tématu [struktuře SpinLock](../../threading/spinlock.md) a [objektu SpinWait](../../threading/spinwait.md).</span><span class="sxs-lookup"><span data-stu-id="f7d8d-126">For more information about spinning vs. blocking, see [SpinLock](../../threading/spinlock.md) and [SpinWait](../../threading/spinwait.md).</span></span>  
  
 <span data-ttu-id="f7d8d-127"><xref:System.Collections.Concurrent.ConcurrentQueue%601>Třídy a <xref:System.Collections.Concurrent.ConcurrentStack%601> nepoužívají zámky vůbec.</span><span class="sxs-lookup"><span data-stu-id="f7d8d-127">The <xref:System.Collections.Concurrent.ConcurrentQueue%601> and <xref:System.Collections.Concurrent.ConcurrentStack%601> classes do not use locks at all.</span></span> <span data-ttu-id="f7d8d-128">Místo toho spoléhají na <xref:System.Threading.Interlocked> operace pro zajištění bezpečnosti vlákna.</span><span class="sxs-lookup"><span data-stu-id="f7d8d-128">Instead, they rely on <xref:System.Threading.Interlocked> operations to achieve thread-safety.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="f7d8d-129">Vzhledem k tomu, že třídy souběžných kolekcí podporují <xref:System.Collections.ICollection> , poskytují implementace pro <xref:System.Collections.ICollection.IsSynchronized%2A> <xref:System.Collections.ICollection.SyncRoot%2A> vlastnosti a, i když tyto vlastnosti nejsou důležité.</span><span class="sxs-lookup"><span data-stu-id="f7d8d-129">Because the concurrent collections classes support <xref:System.Collections.ICollection>, they provide implementations for the <xref:System.Collections.ICollection.IsSynchronized%2A> and <xref:System.Collections.ICollection.SyncRoot%2A> properties, even though these properties are irrelevant.</span></span> <span data-ttu-id="f7d8d-130">`IsSynchronized`vždycky vrátí `false` a `SyncRoot` je vždycky `null` ( `Nothing` v Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="f7d8d-130">`IsSynchronized` always returns `false` and `SyncRoot` is always `null` (`Nothing` in Visual Basic).</span></span>  
  
 <span data-ttu-id="f7d8d-131">V následující tabulce jsou uvedeny typy kolekce v <xref:System.Collections.Concurrent?displayProperty=nameWithType> oboru názvů.</span><span class="sxs-lookup"><span data-stu-id="f7d8d-131">The following table lists the collection types in the <xref:System.Collections.Concurrent?displayProperty=nameWithType> namespace.</span></span>  
  
|<span data-ttu-id="f7d8d-132">Typ</span><span class="sxs-lookup"><span data-stu-id="f7d8d-132">Type</span></span>|<span data-ttu-id="f7d8d-133">Description</span><span class="sxs-lookup"><span data-stu-id="f7d8d-133">Description</span></span>|  
|----------|-----------------|  
|<xref:System.Collections.Concurrent.BlockingCollection%601>|<span data-ttu-id="f7d8d-134">Poskytuje ohraničování a blokování funkcionality pro jakýkoli typ, který implementuje <xref:System.Collections.Concurrent.IProducerConsumerCollection%601> .</span><span class="sxs-lookup"><span data-stu-id="f7d8d-134">Provides bounding and blocking functionality for any type that implements <xref:System.Collections.Concurrent.IProducerConsumerCollection%601>.</span></span> <span data-ttu-id="f7d8d-135">Další informace naleznete v tématu [BlockingCollection – přehled](blockingcollection-overview.md).</span><span class="sxs-lookup"><span data-stu-id="f7d8d-135">For more information, see [BlockingCollection Overview](blockingcollection-overview.md).</span></span>|  
|<xref:System.Collections.Concurrent.ConcurrentDictionary%602>|<span data-ttu-id="f7d8d-136">Implementace slovníku párů klíč-hodnota, který je bezpečný pro přístup z více vláken.</span><span class="sxs-lookup"><span data-stu-id="f7d8d-136">Thread-safe implementation of a dictionary of key-value pairs.</span></span>|  
|<xref:System.Collections.Concurrent.ConcurrentQueue%601>|<span data-ttu-id="f7d8d-137">Implementace fronty FIFO (First-in, First-in), která je bezpečná pro přístup z více vláken.</span><span class="sxs-lookup"><span data-stu-id="f7d8d-137">Thread-safe implementation of a FIFO (first-in, first-out) queue.</span></span>|  
|<xref:System.Collections.Concurrent.ConcurrentStack%601>|<span data-ttu-id="f7d8d-138">Implementace zásobníku LIFO (poslední v, první ven), bezpečná pro přístup z více vláken.</span><span class="sxs-lookup"><span data-stu-id="f7d8d-138">Thread-safe implementation of a LIFO (last-in, first-out) stack.</span></span>|  
|<xref:System.Collections.Concurrent.ConcurrentBag%601>|<span data-ttu-id="f7d8d-139">Implementace neuspořádané kolekce prvků v bezpečném vlákně</span><span class="sxs-lookup"><span data-stu-id="f7d8d-139">Thread-safe implementation of an unordered collection of elements.</span></span>|  
|<xref:System.Collections.Concurrent.IProducerConsumerCollection%601>|<span data-ttu-id="f7d8d-140">Rozhraní, které musí typ implementovat pro použití v `BlockingCollection` .</span><span class="sxs-lookup"><span data-stu-id="f7d8d-140">The interface that a type must implement to be used in a `BlockingCollection`.</span></span>|  
  
## <a name="related-topics"></a><span data-ttu-id="f7d8d-141">Související témata</span><span class="sxs-lookup"><span data-stu-id="f7d8d-141">Related Topics</span></span>  
  
|<span data-ttu-id="f7d8d-142">Nadpis</span><span class="sxs-lookup"><span data-stu-id="f7d8d-142">Title</span></span>|<span data-ttu-id="f7d8d-143">Popis</span><span class="sxs-lookup"><span data-stu-id="f7d8d-143">Description</span></span>|  
|-----------|-----------------|  
|[<span data-ttu-id="f7d8d-144">BlockingCollection – přehled</span><span class="sxs-lookup"><span data-stu-id="f7d8d-144">BlockingCollection Overview</span></span>](blockingcollection-overview.md)|<span data-ttu-id="f7d8d-145">Popisuje funkce poskytované <xref:System.Collections.Concurrent.BlockingCollection%601> typem.</span><span class="sxs-lookup"><span data-stu-id="f7d8d-145">Describes the functionality provided by the <xref:System.Collections.Concurrent.BlockingCollection%601> type.</span></span>|  
|[<span data-ttu-id="f7d8d-146">Postupy: Přidávání a odebírání položek v ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="f7d8d-146">How to: Add and Remove Items from a ConcurrentDictionary</span></span>](how-to-add-and-remove-items.md)|<span data-ttu-id="f7d8d-147">Popisuje, jak přidat nebo odebrat prvky z<xref:System.Collections.Concurrent.ConcurrentDictionary%602></span><span class="sxs-lookup"><span data-stu-id="f7d8d-147">Describes how to add and remove elements from a <xref:System.Collections.Concurrent.ConcurrentDictionary%602></span></span>|  
|[<span data-ttu-id="f7d8d-148">Postupy: Přidávání a odebírání jednotlivých položek v BlockingCollection</span><span class="sxs-lookup"><span data-stu-id="f7d8d-148">How to: Add and Take Items Individually from a BlockingCollection</span></span>](how-to-add-and-take-items.md)|<span data-ttu-id="f7d8d-149">Popisuje, jak přidat a načíst položky z blokující kolekce bez použití enumerátoru jen pro čtení.</span><span class="sxs-lookup"><span data-stu-id="f7d8d-149">Describes how to add and retrieve items from a blocking collection without using the read-only enumerator.</span></span>|  
|[<span data-ttu-id="f7d8d-150">Postupy: Přidání funkcí ohraničování a blokování do kolekce</span><span class="sxs-lookup"><span data-stu-id="f7d8d-150">How to: Add Bounding and Blocking Functionality to a Collection</span></span>](how-to-add-bounding-and-blocking.md)|<span data-ttu-id="f7d8d-151">Popisuje způsob použití libovolné třídy kolekce jako základního mechanismu úložiště pro <xref:System.Collections.Concurrent.IProducerConsumerCollection%601> kolekci.</span><span class="sxs-lookup"><span data-stu-id="f7d8d-151">Describes how to use any collection class as the underlying storage mechanism for an <xref:System.Collections.Concurrent.IProducerConsumerCollection%601> collection.</span></span>|  
|[<span data-ttu-id="f7d8d-152">Postupy: Použití příkazu ForEach k odebrání položek v kolekci BlockingCollection</span><span class="sxs-lookup"><span data-stu-id="f7d8d-152">How to: Use ForEach to Remove Items in a BlockingCollection</span></span>](how-to-use-foreach-to-remove.md)|<span data-ttu-id="f7d8d-153">Popisuje, jak použít `foreach` , ( `For Each` v Visual Basic) k odebrání všech položek v blokující kolekci.</span><span class="sxs-lookup"><span data-stu-id="f7d8d-153">Describes how to use `foreach`, (`For Each` in Visual Basic) to remove all items in a blocking collection.</span></span>|  
|[<span data-ttu-id="f7d8d-154">Postupy: Použití polí blokujících kolekcí v datovém kanálu</span><span class="sxs-lookup"><span data-stu-id="f7d8d-154">How to: Use Arrays of Blocking Collections in a Pipeline</span></span>](how-to-use-arrays-of-blockingcollections.md)|<span data-ttu-id="f7d8d-155">Popisuje, jak použít více blokujících kolekcí současně pro implementaci kanálu.</span><span class="sxs-lookup"><span data-stu-id="f7d8d-155">Describes how to use multiple blocking collections at the same time to implement a pipeline.</span></span>|  
|[<span data-ttu-id="f7d8d-156">Postupy: Vytvoření fondu objektů pomocí ConcurrentBag</span><span class="sxs-lookup"><span data-stu-id="f7d8d-156">How to: Create an Object Pool by Using a ConcurrentBag</span></span>](how-to-create-an-object-pool.md)|<span data-ttu-id="f7d8d-157">Zobrazuje způsob používání souběžného kontejneru za účelem zlepšení výkonu v situacích, kdy je možné namísto neustálého vytváření nových objektů opětovně používat stávající objekty.</span><span class="sxs-lookup"><span data-stu-id="f7d8d-157">Shows how to use a concurrent bag to improve performance in scenarios where you can reuse objects instead of continually creating new ones.</span></span>|  
  
## <a name="reference"></a><span data-ttu-id="f7d8d-158">Reference</span><span class="sxs-lookup"><span data-stu-id="f7d8d-158">Reference</span></span>  
 <xref:System.Collections.Concurrent?displayProperty=nameWithType>
