---
title: Formáty cesty k souborům v systémech Windows
description: V tomto článku se dozvíte o formátech souborů cest v systémech Windows, například tradičních cestách DOS, cestách zařízení se systémem DOS a cestách UNC (Universal Naming Convention).
ms.date: 06/06/2019
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- I/O, long paths
- long paths
- path formats, Windows
ms.openlocfilehash: 8cbb687b0c7cfb69d3f3807c083f1c25e9d39594
ms.sourcegitcommit: e0803b8975d3eb12e735a5d07637020dd6dac5ef
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 09/01/2020
ms.locfileid: "89271786"
---
# <a name="file-path-formats-on-windows-systems"></a><span data-ttu-id="d9cdb-103">Formáty cesty k souborům v systémech Windows</span><span class="sxs-lookup"><span data-stu-id="d9cdb-103">File path formats on Windows systems</span></span>

<span data-ttu-id="d9cdb-104">Členové mnoha typů v <xref:System.IO> oboru názvů zahrnují `path` parametr, který umožňuje zadat absolutní nebo relativní cestu k prostředku systému souborů.</span><span class="sxs-lookup"><span data-stu-id="d9cdb-104">Members of many of the types in the <xref:System.IO> namespace include a `path` parameter that lets you specify an absolute or relative path to a file system resource.</span></span> <span data-ttu-id="d9cdb-105">Tato cesta je pak předána [rozhraním API systému souborů systému Windows](/windows/desktop/fileio/file-systems).</span><span class="sxs-lookup"><span data-stu-id="d9cdb-105">This path is then passed to [Windows file system APIs](/windows/desktop/fileio/file-systems).</span></span> <span data-ttu-id="d9cdb-106">Toto téma pojednává o formátech pro cesty k souborům, které můžete použít v systémech Windows.</span><span class="sxs-lookup"><span data-stu-id="d9cdb-106">This topic discusses the formats for file paths that you can use on Windows systems.</span></span>

## <a name="traditional-dos-paths"></a><span data-ttu-id="d9cdb-107">Tradiční cesty DOS</span><span class="sxs-lookup"><span data-stu-id="d9cdb-107">Traditional DOS paths</span></span>

<span data-ttu-id="d9cdb-108">Standardní cesta systému DOS se může skládat ze tří součástí:</span><span class="sxs-lookup"><span data-stu-id="d9cdb-108">A standard DOS path can consist of three components:</span></span>

- <span data-ttu-id="d9cdb-109">Svazek nebo písmeno jednotky následované oddělovačem svazků ( `:` ).</span><span class="sxs-lookup"><span data-stu-id="d9cdb-109">A volume or drive letter followed by the volume separator (`:`).</span></span>
- <span data-ttu-id="d9cdb-110">Název adresáře.</span><span class="sxs-lookup"><span data-stu-id="d9cdb-110">A directory name.</span></span> <span data-ttu-id="d9cdb-111">[Znak oddělovače adresáře](<xref:System.IO.Path.DirectorySeparatorChar>) odděluje podadresáře v rámci hierarchie vnořeného adresáře.</span><span class="sxs-lookup"><span data-stu-id="d9cdb-111">The [directory separator character](<xref:System.IO.Path.DirectorySeparatorChar>) separates subdirectories within the nested directory hierarchy.</span></span>
- <span data-ttu-id="d9cdb-112">Nepovinný název souboru.</span><span class="sxs-lookup"><span data-stu-id="d9cdb-112">An optional filename.</span></span> <span data-ttu-id="d9cdb-113">[Znak oddělovače adresáře](<xref:System.IO.Path.DirectorySeparatorChar>) odděluje cestu k souboru a název souboru.</span><span class="sxs-lookup"><span data-stu-id="d9cdb-113">The [directory separator character](<xref:System.IO.Path.DirectorySeparatorChar>) separates the file path and the filename.</span></span>

<span data-ttu-id="d9cdb-114">Pokud jsou k dispozici všechny tři komponenty, je cesta absolutní.</span><span class="sxs-lookup"><span data-stu-id="d9cdb-114">If all three components are present, the path is absolute.</span></span> <span data-ttu-id="d9cdb-115">Pokud není zadán žádný svazek ani písmeno jednotky a název adresáře začíná [znakem oddělovače adresáře](<xref:System.IO.Path.DirectorySeparatorChar>), bude cesta relativní od kořene aktuální jednotky.</span><span class="sxs-lookup"><span data-stu-id="d9cdb-115">If no volume or drive letter is specified and the directory name begins with the [directory separator character](<xref:System.IO.Path.DirectorySeparatorChar>), the path is relative from the root of the current drive.</span></span> <span data-ttu-id="d9cdb-116">V opačném případě je cesta relativní vzhledem k aktuálnímu adresáři.</span><span class="sxs-lookup"><span data-stu-id="d9cdb-116">Otherwise, the path is relative to the current directory.</span></span> <span data-ttu-id="d9cdb-117">V následující tabulce jsou uvedeny některé možné cesty k adresářům a souborům.</span><span class="sxs-lookup"><span data-stu-id="d9cdb-117">The following table shows some possible directory and file paths.</span></span>

|<span data-ttu-id="d9cdb-118">Cesta</span><span class="sxs-lookup"><span data-stu-id="d9cdb-118">Path</span></span>  |<span data-ttu-id="d9cdb-119">Popis</span><span class="sxs-lookup"><span data-stu-id="d9cdb-119">Description</span></span>  |
| -- | -- |
| `C:\Documents\Newsletters\Summer2018.pdf` | <span data-ttu-id="d9cdb-120">Absolutní cesta k souboru z kořene jednotky `C:` .</span><span class="sxs-lookup"><span data-stu-id="d9cdb-120">An absolute file path from the root of drive `C:`.</span></span> |
| `\Program Files\Custom Utilities\StringFinder.exe` | <span data-ttu-id="d9cdb-121">Absolutní cesta z kořene aktuální jednotky.</span><span class="sxs-lookup"><span data-stu-id="d9cdb-121">An absolute path from the root of the current drive.</span></span> |
| `2018\January.xlsx` | <span data-ttu-id="d9cdb-122">Relativní cesta k souboru v podadresáři aktuálního adresáře.</span><span class="sxs-lookup"><span data-stu-id="d9cdb-122">A relative path to a file in a subdirectory of the current directory.</span></span> |
| `..\Publications\TravelBrochure.pdf` | <span data-ttu-id="d9cdb-123">Relativní cesta k souboru v adresáři, který je partnerským uzlem aktuálního adresáře.</span><span class="sxs-lookup"><span data-stu-id="d9cdb-123">A relative path to file in a directory that is a peer of the current directory.</span></span> |
| `C:\Projects\apilibrary\apilibrary.sln` | <span data-ttu-id="d9cdb-124">Absolutní cesta k souboru z kořene jednotky `C:` .</span><span class="sxs-lookup"><span data-stu-id="d9cdb-124">An absolute path to a file from the root of drive `C:`.</span></span> |
| `C:Projects\apilibrary\apilibrary.sln` | <span data-ttu-id="d9cdb-125">Relativní cesta z aktuálního adresáře `C:` jednotky.</span><span class="sxs-lookup"><span data-stu-id="d9cdb-125">A relative path from the current directory of the `C:` drive.</span></span> |

> [!IMPORTANT]
> <span data-ttu-id="d9cdb-126">Všimněte si rozdílu mezi posledními dvěma cestami.</span><span class="sxs-lookup"><span data-stu-id="d9cdb-126">Note the difference between the last two paths.</span></span> <span data-ttu-id="d9cdb-127">Oba určují volitelné specifikátory svazku ( `C:` v obou případech), ale první začíná kořenem zadaného svazku, zatímco druhý ne.</span><span class="sxs-lookup"><span data-stu-id="d9cdb-127">Both specify the optional volume specifier (`C:` in both cases), but the first begins with the root of the specified volume, whereas the second does not.</span></span> <span data-ttu-id="d9cdb-128">V důsledku toho je první absolutní cesta z kořenového adresáře jednotky `C:` , zatímco druhá je relativní cesta z aktuálního adresáře jednotky `C:` .</span><span class="sxs-lookup"><span data-stu-id="d9cdb-128">As result, the first is an absolute path from the root directory of drive `C:`, whereas the second is a relative path from the current directory of drive `C:`.</span></span> <span data-ttu-id="d9cdb-129">Použití druhého formuláře, pokud je první záměr, je běžným zdrojem chyb, které obsahují cesty k souborům Windows.</span><span class="sxs-lookup"><span data-stu-id="d9cdb-129">Use of the second form when the first is intended is a common source of bugs that involve Windows file paths.</span></span>

<span data-ttu-id="d9cdb-130">Můžete určit, zda je cesta k souboru plně kvalifikovaná (to znamená, že cesta je nezávislá na aktuálním adresáři a nemění se, když se změní aktuální adresář) voláním <xref:System.IO.Path.IsPathFullyQualified%2A?displayProperty=nameWthType> metody.</span><span class="sxs-lookup"><span data-stu-id="d9cdb-130">You can determine whether a file path is fully qualified (that is, it the path is independent of the current directory and does not change when the current directory changes) by calling the <xref:System.IO.Path.IsPathFullyQualified%2A?displayProperty=nameWthType> method.</span></span> <span data-ttu-id="d9cdb-131">Všimněte si, že taková cesta může zahrnovat relativní segmenty adresářů ( `.` a `..` ) a pořád musí být plně kvalifikované, pokud se přeložená cesta vždy odkazuje na stejné umístění.</span><span class="sxs-lookup"><span data-stu-id="d9cdb-131">Note that such a path can include relative directory segments (`.` and `..`) and still be fully qualified if the resolved path always points to the same location.</span></span>

<span data-ttu-id="d9cdb-132">Následující příklad znázorňuje rozdíl mezi absolutními a relativními cestami.</span><span class="sxs-lookup"><span data-stu-id="d9cdb-132">The following example illustrates the difference between absolute and relative paths.</span></span> <span data-ttu-id="d9cdb-133">Předpokládá, že adresář `D:\FY2018\` existuje a že jste před spuštěním tohoto příkladu nestavili žádný aktuální adresář pro `D:\` z příkazového řádku.</span><span class="sxs-lookup"><span data-stu-id="d9cdb-133">It assumes that the directory `D:\FY2018\` exists, and that you haven't set any current directory for `D:\` from the command prompt before running the example.</span></span>

[!code-csharp[absolute-and-relative-paths](~/samples/snippets/standard/io/file-names/cs/paths.cs)]
[!code-vb[absolute-and-relative-paths](~/samples/snippets/standard/io/file-names/vb/paths.vb)]

[!INCLUDE [localized code comments](../../../includes/code-comments-loc.md)]

## <a name="unc-paths"></a><span data-ttu-id="d9cdb-134">Cesty UNC</span><span class="sxs-lookup"><span data-stu-id="d9cdb-134">UNC paths</span></span>

<span data-ttu-id="d9cdb-135">Cesty UNC (Universal Naming Convention), které se používají pro přístup k síťovým prostředkům, mají následující formát:</span><span class="sxs-lookup"><span data-stu-id="d9cdb-135">Universal naming convention (UNC) paths, which are used to access network resources, have the following format:</span></span>

- <span data-ttu-id="d9cdb-136">Název serveru nebo hostitele, který je v rámci `\\` .</span><span class="sxs-lookup"><span data-stu-id="d9cdb-136">A server or host name, which is prefaced by `\\`.</span></span> <span data-ttu-id="d9cdb-137">Název serveru může být název počítače pro rozhraní NetBIOS nebo adresa IP nebo plně kvalifikovaného názvu domény (IPv4 a i taky 6 – podporované).</span><span class="sxs-lookup"><span data-stu-id="d9cdb-137">The server name can be a NetBIOS machine name or an IP/FQDN address (IPv4 as well as v6 are supported).</span></span>
- <span data-ttu-id="d9cdb-138">Název sdílené složky, který je oddělený od názvu hostitele `\` .</span><span class="sxs-lookup"><span data-stu-id="d9cdb-138">A share name, which is separated from the host name by `\`.</span></span> <span data-ttu-id="d9cdb-139">Společně se název serveru a sdílené složky skládá ze svazku.</span><span class="sxs-lookup"><span data-stu-id="d9cdb-139">Together, the server and share name make up the volume.</span></span>
- <span data-ttu-id="d9cdb-140">Název adresáře.</span><span class="sxs-lookup"><span data-stu-id="d9cdb-140">A directory name.</span></span> <span data-ttu-id="d9cdb-141">[Znak oddělovače adresáře](<xref:System.IO.Path.DirectorySeparatorChar>) odděluje podadresáře v rámci hierarchie vnořeného adresáře.</span><span class="sxs-lookup"><span data-stu-id="d9cdb-141">The [directory separator character](<xref:System.IO.Path.DirectorySeparatorChar>) separates subdirectories within the nested directory hierarchy.</span></span>
- <span data-ttu-id="d9cdb-142">Nepovinný název souboru.</span><span class="sxs-lookup"><span data-stu-id="d9cdb-142">An optional filename.</span></span> <span data-ttu-id="d9cdb-143">[Znak oddělovače adresáře](<xref:System.IO.Path.DirectorySeparatorChar>) odděluje cestu k souboru a název souboru.</span><span class="sxs-lookup"><span data-stu-id="d9cdb-143">The [directory separator character](<xref:System.IO.Path.DirectorySeparatorChar>) separates the file path and the filename.</span></span>

<span data-ttu-id="d9cdb-144">Následuje několik příkladů cest UNC:</span><span class="sxs-lookup"><span data-stu-id="d9cdb-144">The following are some examples of UNC paths:</span></span>

|<span data-ttu-id="d9cdb-145">Cesta</span><span class="sxs-lookup"><span data-stu-id="d9cdb-145">Path</span></span>  |<span data-ttu-id="d9cdb-146">Popis</span><span class="sxs-lookup"><span data-stu-id="d9cdb-146">Description</span></span>  |
| -- | -- |
| `\\system07\C$\` | <span data-ttu-id="d9cdb-147">Kořenový adresář `C:` jednotky `system07` .</span><span class="sxs-lookup"><span data-stu-id="d9cdb-147">The root directory of the `C:` drive on `system07`.</span></span> |
| `\\Server2\Share\Test\Foo.txt` | <span data-ttu-id="d9cdb-148">`Foo.txt`Soubor v adresáři testu `\\Server2\Share` svazku.</span><span class="sxs-lookup"><span data-stu-id="d9cdb-148">The `Foo.txt` file in the Test directory of the `\\Server2\Share` volume.</span></span>|

<span data-ttu-id="d9cdb-149">Cesty UNC musí být vždy plně kvalifikované.</span><span class="sxs-lookup"><span data-stu-id="d9cdb-149">UNC paths must always be fully qualified.</span></span> <span data-ttu-id="d9cdb-150">Můžou zahrnovat relativní segmenty adresářů ( `.` a `..` ), ale musí být součástí plně kvalifikované cesty.</span><span class="sxs-lookup"><span data-stu-id="d9cdb-150">They can include relative directory segments (`.` and `..`), but these must be part of a fully qualified path.</span></span> <span data-ttu-id="d9cdb-151">Relativní cesty můžete použít jenom tak, že namapujete cestu UNC k písmenu jednotky.</span><span class="sxs-lookup"><span data-stu-id="d9cdb-151">You can use relative paths only by mapping a UNC path to a drive letter.</span></span>

## <a name="dos-device-paths"></a><span data-ttu-id="d9cdb-152">Cesty zařízení DOS</span><span class="sxs-lookup"><span data-stu-id="d9cdb-152">DOS device paths</span></span>

<span data-ttu-id="d9cdb-153">Operační systém Windows má jednotný objektový model, který odkazuje na všechny prostředky, včetně souborů.</span><span class="sxs-lookup"><span data-stu-id="d9cdb-153">The Windows operating system has a unified object model that points to all resources, including files.</span></span> <span data-ttu-id="d9cdb-154">Tyto cesty k objektům jsou přístupné z okna konzoly a jsou zpřístupněny vrstvě Win32 prostřednictvím speciální složky symbolických odkazů, na které jsou namapovány starší verze DOS a cesty UNC.</span><span class="sxs-lookup"><span data-stu-id="d9cdb-154">These object paths are accessible from the console window and are exposed to the Win32 layer through a special folder of symbolic links that legacy DOS and UNC paths are mapped to.</span></span> <span data-ttu-id="d9cdb-155">K této speciální složce se dostanete pomocí syntaxe cesty zařízení DOS, což je jedna z těchto:</span><span class="sxs-lookup"><span data-stu-id="d9cdb-155">This special folder is accessed via the DOS device path syntax, which is one of:</span></span>

`\\.\C:\Test\Foo.txt`
`\\?\C:\Test\Foo.txt`

<span data-ttu-id="d9cdb-156">Kromě identifikace jednotky podle písmene jednotky můžete určit svazek pomocí identifikátoru GUID svazku.</span><span class="sxs-lookup"><span data-stu-id="d9cdb-156">In addition to identifying a drive by its drive letter, you can identify a volume by using its volume GUID.</span></span> <span data-ttu-id="d9cdb-157">To má podobu:</span><span class="sxs-lookup"><span data-stu-id="d9cdb-157">This takes the form:</span></span>

`\\.\Volume{b75e2c83-0000-0000-0000-602f00000000}\Test\Foo.txt`
`\\?\Volume{b75e2c83-0000-0000-0000-602f00000000}\Test\Foo.txt`

> [!NOTE]
> <span data-ttu-id="d9cdb-158">Syntaxe cest zařízení DOS je podporovaná u implementací .NET běžících na Windows počínaje .NET Core 1,1 a .NET Framework 4.6.2.</span><span class="sxs-lookup"><span data-stu-id="d9cdb-158">DOS device path syntax is supported on .NET implementations running on Windows starting with .NET Core 1.1 and .NET Framework 4.6.2.</span></span>

<span data-ttu-id="d9cdb-159">Cesta k zařízení DOS se skládá z následujících součástí:</span><span class="sxs-lookup"><span data-stu-id="d9cdb-159">The DOS device path consists of the following components:</span></span>

- <span data-ttu-id="d9cdb-160">Specifikátor cesty zařízení ( `\\.\` nebo `\\?\` ), který identifikuje cestu jako cestu k zařízení DOS.</span><span class="sxs-lookup"><span data-stu-id="d9cdb-160">The device path specifier (`\\.\` or `\\?\`), which identifies the path as a DOS device path.</span></span>

   > [!NOTE]
   > <span data-ttu-id="d9cdb-161">`\\?\`Je podporován ve všech verzích rozhraní .NET Core a v .NET Framework počínaje verzí 4.6.2.</span><span class="sxs-lookup"><span data-stu-id="d9cdb-161">The `\\?\` is supported in all versions of .NET Core and in the .NET Framework starting with version 4.6.2.</span></span>

- <span data-ttu-id="d9cdb-162">Symbolický odkaz na "reálný" objekt zařízení (C: v případě názvu jednotky nebo svazek {b75e2c83-0000-0000-0000-602f00000000} v případě identifikátoru GUID svazku).</span><span class="sxs-lookup"><span data-stu-id="d9cdb-162">A symbolic link to the "real" device object (C: in the case of a drive name, or Volume{b75e2c83-0000-0000-0000-602f00000000} in the case of a volume GUID).</span></span>

   <span data-ttu-id="d9cdb-163">První segment cesty zařízení systému DOS po určení svazku cesty zařízení, který identifikuje svazek nebo jednotku.</span><span class="sxs-lookup"><span data-stu-id="d9cdb-163">The first segment of the DOS device path after the device path specifier identifies the volume or drive.</span></span> <span data-ttu-id="d9cdb-164">(Například `\\?\C:\` a `\\.\BootPartition\` .)</span><span class="sxs-lookup"><span data-stu-id="d9cdb-164">(For example, `\\?\C:\` and `\\.\BootPartition\`.)</span></span>

   <span data-ttu-id="d9cdb-165">Pro UNCs je k dispozici konkrétní odkaz, který se nazývá, nikoli překvapivě `UNC` .</span><span class="sxs-lookup"><span data-stu-id="d9cdb-165">There is a specific link for UNCs that is called, not surprisingly, `UNC`.</span></span> <span data-ttu-id="d9cdb-166">Příklad:</span><span class="sxs-lookup"><span data-stu-id="d9cdb-166">For example:</span></span>

  `\\.\UNC\Server\Share\Test\Foo.txt`
  `\\?\UNC\Server\Share\Test\Foo.txt`

    <span data-ttu-id="d9cdb-167">V případě UNCs zařízení tvoří část server/sdílení svazku svazek.</span><span class="sxs-lookup"><span data-stu-id="d9cdb-167">For device UNCs, the server/share portion forms the volume.</span></span> <span data-ttu-id="d9cdb-168">Například v nástroji `\\?\server1\e:\utilities\\filecomparer\` je část serveru nebo sdílené složky `server1\utilities` .</span><span class="sxs-lookup"><span data-stu-id="d9cdb-168">For example, in `\\?\server1\e:\utilities\\filecomparer\`, the server/share portion is `server1\utilities`.</span></span> <span data-ttu-id="d9cdb-169">To je důležité při volání metody, jako je například <xref:System.IO.Path.GetFullPath(System.String,System.String)?displayProperty=nameWithType> s relativními segmenty adresářů; není nikdy možné přejít na předchozí svazek.</span><span class="sxs-lookup"><span data-stu-id="d9cdb-169">This is significant when calling a method such as <xref:System.IO.Path.GetFullPath(System.String,System.String)?displayProperty=nameWithType> with relative directory segments; it is never possible to navigate past the volume.</span></span>

<span data-ttu-id="d9cdb-170">Cesty zařízení DOS jsou plně kvalifikované podle definice.</span><span class="sxs-lookup"><span data-stu-id="d9cdb-170">DOS device paths are fully qualified by definition.</span></span> <span data-ttu-id="d9cdb-171">Relativní segmenty adresářů ( `.` a `..` ) nejsou povoleny.</span><span class="sxs-lookup"><span data-stu-id="d9cdb-171">Relative directory segments (`.` and `..`) are not allowed.</span></span> <span data-ttu-id="d9cdb-172">Aktuální adresáře nikdy nevstoupí do jejich použití.</span><span class="sxs-lookup"><span data-stu-id="d9cdb-172">Current directories never enter into their usage.</span></span>

## <a name="example-ways-to-refer-to-the-same-file"></a><span data-ttu-id="d9cdb-173">Příklad: způsoby, jak odkazovat na stejný soubor</span><span class="sxs-lookup"><span data-stu-id="d9cdb-173">Example: Ways to refer to the same file</span></span>

<span data-ttu-id="d9cdb-174">Následující příklad znázorňuje některé způsoby, jak můžete odkazovat na soubor při použití rozhraní API v <xref:System.IO> oboru názvů.</span><span class="sxs-lookup"><span data-stu-id="d9cdb-174">The following example illustrates some of the ways in which you can refer to a file when using the APIs in the <xref:System.IO> namespace.</span></span> <span data-ttu-id="d9cdb-175">Příklad vytvoří instanci <xref:System.IO.FileInfo> objektu a pomocí jeho <xref:System.IO.FileInfo.Name> <xref:System.IO.FileInfo.Length> vlastností a zobrazí název souboru a délku souboru.</span><span class="sxs-lookup"><span data-stu-id="d9cdb-175">The example instantiates a <xref:System.IO.FileInfo> object and uses its <xref:System.IO.FileInfo.Name> and <xref:System.IO.FileInfo.Length> properties to display the filename and the length of the file.</span></span>

[!code-csharp[referring-to-the-same-file](~/samples/snippets/standard/io/file-names/cs/file-refs.cs)]
[!code-vb[referring-to-the-same-file](~/samples/snippets/standard/io/file-names/vb/file-refs.vb)]

## <a name="path-normalization"></a><span data-ttu-id="d9cdb-176">Normalizace cest</span><span class="sxs-lookup"><span data-stu-id="d9cdb-176">Path normalization</span></span>

<span data-ttu-id="d9cdb-177">Skoro všechny cesty předané rozhraním API systému Windows jsou normalizovány.</span><span class="sxs-lookup"><span data-stu-id="d9cdb-177">Almost all paths passed to Windows APIs are normalized.</span></span> <span data-ttu-id="d9cdb-178">Během normalizace systém Windows provede následující kroky:</span><span class="sxs-lookup"><span data-stu-id="d9cdb-178">During normalization, Windows performs the following steps:</span></span>

- <span data-ttu-id="d9cdb-179">Identifikuje cestu.</span><span class="sxs-lookup"><span data-stu-id="d9cdb-179">Identifies the path.</span></span>
- <span data-ttu-id="d9cdb-180">Použije aktuální adresář na částečně kvalifikované (relativní) cesty.</span><span class="sxs-lookup"><span data-stu-id="d9cdb-180">Applies the current directory to partially qualified (relative) paths.</span></span>
- <span data-ttu-id="d9cdb-181">Canonicalizes součásti a oddělovače adresářů.</span><span class="sxs-lookup"><span data-stu-id="d9cdb-181">Canonicalizes component and directory separators.</span></span>
- <span data-ttu-id="d9cdb-182">Vyhodnotí relativní součásti adresáře ( `.` pro aktuální adresář a `..` pro nadřazený adresář).</span><span class="sxs-lookup"><span data-stu-id="d9cdb-182">Evaluates relative directory components (`.` for the current directory and `..` for the parent directory).</span></span>
- <span data-ttu-id="d9cdb-183">Ořízne určité znaky.</span><span class="sxs-lookup"><span data-stu-id="d9cdb-183">Trims certain characters.</span></span>

<span data-ttu-id="d9cdb-184">Tato normalizace proběhne implicitně, ale můžete ji provést explicitně voláním <xref:System.IO.Path.GetFullPath%2A?displayProperty=nameWithType> metody, která zabalí volání  [funkce GetFullPathName ()](/windows/desktop/api/fileapi/nf-fileapi-getfullpathnamea).</span><span class="sxs-lookup"><span data-stu-id="d9cdb-184">This normalization happens implicitly, but you can do it explicitly by calling the <xref:System.IO.Path.GetFullPath%2A?displayProperty=nameWithType> method, which wraps a call to the  [GetFullPathName() function](/windows/desktop/api/fileapi/nf-fileapi-getfullpathnamea).</span></span> <span data-ttu-id="d9cdb-185">[Funkci Windows GetFullPathName ()](/windows/desktop/api/fileapi/nf-fileapi-getfullpathnamea) můžete také volat přímo pomocí volání nespravovaného volání.</span><span class="sxs-lookup"><span data-stu-id="d9cdb-185">You can also call the Windows [GetFullPathName() function](/windows/desktop/api/fileapi/nf-fileapi-getfullpathnamea) directly using P/Invoke.</span></span>

### <a name="identify-the-path"></a><span data-ttu-id="d9cdb-186">Identifikujte cestu</span><span class="sxs-lookup"><span data-stu-id="d9cdb-186">Identify the path</span></span>

<span data-ttu-id="d9cdb-187">Prvním krokem normalizace cesty je určení typu cesty.</span><span class="sxs-lookup"><span data-stu-id="d9cdb-187">The first step in path normalization is identifying the type of path.</span></span> <span data-ttu-id="d9cdb-188">Cesty spadají do jedné z několika kategorií:</span><span class="sxs-lookup"><span data-stu-id="d9cdb-188">Paths fall into one of a few categories:</span></span>

- <span data-ttu-id="d9cdb-189">Jsou to cesty zařízení; To znamená, že začínají dvěma oddělovači a otazníkem nebo tečkou ( `\\?` nebo `\\.` ).</span><span class="sxs-lookup"><span data-stu-id="d9cdb-189">They are device paths; that is, they begin with two separators and a question mark or period (`\\?` or `\\.`).</span></span>
- <span data-ttu-id="d9cdb-190">Jsou to cesty UNC; To znamená, že začínají dvěma oddělovači bez otazníku nebo tečky.</span><span class="sxs-lookup"><span data-stu-id="d9cdb-190">They are UNC paths; that is, they begin with two separators without a question mark or period.</span></span>
- <span data-ttu-id="d9cdb-191">Jsou to plně kvalifikované cesty DOS; To znamená, že začínají písmenem jednotky, oddělovačem svazků a oddělovačem součásti ( `C:\` ).</span><span class="sxs-lookup"><span data-stu-id="d9cdb-191">They are fully qualified DOS paths; that is, they begin with a drive letter, a volume separator, and a component separator (`C:\`).</span></span>
- <span data-ttu-id="d9cdb-192">Určují starší zařízení ( `CON` , `LPT1` ).</span><span class="sxs-lookup"><span data-stu-id="d9cdb-192">They designate a legacy device (`CON`, `LPT1`).</span></span>
- <span data-ttu-id="d9cdb-193">Jsou relativní vzhledem ke kořenu aktuální jednotky; To znamená, že začínají jedním oddělovačem součásti ( `\` ).</span><span class="sxs-lookup"><span data-stu-id="d9cdb-193">They are relative to the root of the current drive; that is, they begin with a single component separator (`\`).</span></span>
- <span data-ttu-id="d9cdb-194">Jsou relativní vzhledem k aktuálnímu adresáři zadané jednotky; To znamená, že začínají písmenem jednotky, oddělovačem svazků a bez oddělovače komponent ( `C:` ).</span><span class="sxs-lookup"><span data-stu-id="d9cdb-194">They are relative to the current directory of a specified drive; that is, they begin with a drive letter, a volume separator, and no component separator (`C:`).</span></span>
- <span data-ttu-id="d9cdb-195">Jsou relativní vzhledem k aktuálnímu adresáři. To znamená, že začínají cokoliv jiného ( `temp\testfile.txt` ).</span><span class="sxs-lookup"><span data-stu-id="d9cdb-195">They are relative to the current directory; that is, they begin with anything else (`temp\testfile.txt`).</span></span>

<span data-ttu-id="d9cdb-196">Typ cesty určuje, zda je aktuální adresář použit nějakým způsobem.</span><span class="sxs-lookup"><span data-stu-id="d9cdb-196">The type of the path determines whether or not a current directory is applied in some way.</span></span> <span data-ttu-id="d9cdb-197">Také určuje, co je "kořen" cesty.</span><span class="sxs-lookup"><span data-stu-id="d9cdb-197">It also determines what the "root" of the path is.</span></span>

### <a name="handle-legacy-devices"></a><span data-ttu-id="d9cdb-198">Zpracování starších zařízení</span><span class="sxs-lookup"><span data-stu-id="d9cdb-198">Handle legacy devices</span></span>

<span data-ttu-id="d9cdb-199">Pokud se jedná o starší zařízení se systémem DOS, jako je `CON` , `COM1` , nebo `LPT1` se převede na cestu k zařízení pomocí předpřipraveného `\\.\` a vráceného.</span><span class="sxs-lookup"><span data-stu-id="d9cdb-199">If the path is a legacy DOS device such as `CON`, `COM1`, or `LPT1`, it is converted into a device path by prepending `\\.\` and returned.</span></span>

<span data-ttu-id="d9cdb-200">Cesta začínající starším názvem zařízení je vždy interpretována jako starší zařízení <xref:System.IO.Path.GetFullPath(System.String)?displayProperty=nameWithType> metodou.</span><span class="sxs-lookup"><span data-stu-id="d9cdb-200">A path that begins with a legacy device name is always interpreted as a legacy device by the <xref:System.IO.Path.GetFullPath(System.String)?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="d9cdb-201">Například cesta zařízení DOS pro `CON.TXT` je `\\.\CON` a cesta k zařízení DOS pro `COM1.TXT\file1.txt` je `\\.\COM1` .</span><span class="sxs-lookup"><span data-stu-id="d9cdb-201">For example, the DOS device path for `CON.TXT` is `\\.\CON`, and the DOS device path for `COM1.TXT\file1.txt` is `\\.\COM1`.</span></span>

### <a name="apply-the-current-directory"></a><span data-ttu-id="d9cdb-202">Použít aktuální adresář</span><span class="sxs-lookup"><span data-stu-id="d9cdb-202">Apply the current directory</span></span>

<span data-ttu-id="d9cdb-203">Pokud cesta není plně kvalifikovaná, systém Windows použije pro něj aktuální adresář.</span><span class="sxs-lookup"><span data-stu-id="d9cdb-203">If a path isn't fully qualified, Windows applies the current directory to it.</span></span> <span data-ttu-id="d9cdb-204">UNCs a cesty zařízení nemají použit aktuální adresář.</span><span class="sxs-lookup"><span data-stu-id="d9cdb-204">UNCs and device paths do not have the current directory applied.</span></span> <span data-ttu-id="d9cdb-205">Ani celá jednotka s oddělovačem `C:\` .</span><span class="sxs-lookup"><span data-stu-id="d9cdb-205">Neither does a full drive with separator `C:\`.</span></span>

<span data-ttu-id="d9cdb-206">Pokud cesta začíná jediným oddělovačem komponent, použije se jednotka z aktuálního adresáře.</span><span class="sxs-lookup"><span data-stu-id="d9cdb-206">If the path starts with a single component separator, the drive from the current directory is applied.</span></span> <span data-ttu-id="d9cdb-207">Například pokud je cesta k souboru `\utilities` a aktuální adresář je `C:\temp\` , normalizace vytvoří `C:\utilities` .</span><span class="sxs-lookup"><span data-stu-id="d9cdb-207">For example, if the file path is `\utilities` and the current directory is `C:\temp\`, normalization produces `C:\utilities`.</span></span>

<span data-ttu-id="d9cdb-208">Pokud cesta začíná písmenem jednotky, oddělovačem svazků a žádným oddělovačem komponent, použije se poslední aktuální adresářová sada z příkazového prostředí pro zadanou jednotku.</span><span class="sxs-lookup"><span data-stu-id="d9cdb-208">If the path starts with a drive letter, volume separator, and no component separator, the last current directory set from the command shell for the specified drive is applied.</span></span> <span data-ttu-id="d9cdb-209">Pokud nebyl poslední aktuální adresář nastaven, použije se samotný disk.</span><span class="sxs-lookup"><span data-stu-id="d9cdb-209">If the last current directory was not set, the drive alone is applied.</span></span> <span data-ttu-id="d9cdb-210">Pokud je například cesta k souboru `D:sources` , aktuální adresář je `C:\Documents\` a poslední aktuální adresář na jednotce D: `D:\sources\` , výsledkem je `D:\sources\sources` .</span><span class="sxs-lookup"><span data-stu-id="d9cdb-210">For example, if the file path is `D:sources`, the current directory is `C:\Documents\`, and the last current directory on drive D: was `D:\sources\`, the result is `D:\sources\sources`.</span></span> <span data-ttu-id="d9cdb-211">Tyto "relativní" cesty k jednotce jsou běžným zdrojem chyb logiky programu a skriptu.</span><span class="sxs-lookup"><span data-stu-id="d9cdb-211">These "drive relative" paths are a common source of program and script logic errors.</span></span> <span data-ttu-id="d9cdb-212">Za předpokladu, že cesta začínající písmenem a dvojtečkou není relativní, je zjevně nesprávná.</span><span class="sxs-lookup"><span data-stu-id="d9cdb-212">Assuming that a path beginning with a letter and a colon isn't relative is obviously not correct.</span></span>

<span data-ttu-id="d9cdb-213">Pokud cesta začíná jinou než oddělovačem, použije se aktuální jednotka a aktuální adresář.</span><span class="sxs-lookup"><span data-stu-id="d9cdb-213">If the path starts with something other than a separator, the current drive and current directory are applied.</span></span> <span data-ttu-id="d9cdb-214">Například pokud je cesta `filecompare` a aktuální adresář je `C:\utilities\` , je výsledkem `C:\utilities\filecompare\` .</span><span class="sxs-lookup"><span data-stu-id="d9cdb-214">For example, if the path is `filecompare` and the current directory is `C:\utilities\`, the result is `C:\utilities\filecompare\`.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="d9cdb-215">Relativní cesty jsou nebezpečné v aplikacích s více vlákny (tj. ve většině aplikací), protože aktuální adresář je nastavení pro jednotlivé procesy.</span><span class="sxs-lookup"><span data-stu-id="d9cdb-215">Relative paths are dangerous in multithreaded applications (that is, most applications) because the current directory is a per-process setting.</span></span> <span data-ttu-id="d9cdb-216">V každém vlákně může aktuální adresář kdykoli změnit.</span><span class="sxs-lookup"><span data-stu-id="d9cdb-216">Any thread can change the current directory at any time.</span></span> <span data-ttu-id="d9cdb-217">Počínaje rozhraním .NET Core 2,1 můžete zavolat <xref:System.IO.Path.GetFullPath(System.String,System.String)?displayProperty=nameWithType> metodu a získat tak absolutní cestu z relativní cesty a základní cestu (aktuální adresář), pro kterou ji chcete vyřešit.</span><span class="sxs-lookup"><span data-stu-id="d9cdb-217">Starting with .NET Core 2.1, you can call the <xref:System.IO.Path.GetFullPath(System.String,System.String)?displayProperty=nameWithType> method to get an absolute path from a relative path and the base path (the current directory) that you want to resolve it against.</span></span>

### <a name="canonicalize-separators"></a><span data-ttu-id="d9cdb-218">Oddělovače kanonického tvaru</span><span class="sxs-lookup"><span data-stu-id="d9cdb-218">Canonicalize separators</span></span>

<span data-ttu-id="d9cdb-219">Všechna lomítka ( `/` ) jsou převedena do standardního oddělovače systému Windows, zpětného lomítka ( `\` ).</span><span class="sxs-lookup"><span data-stu-id="d9cdb-219">All forward slashes (`/`) are converted into the standard Windows separator, the back slash (`\`).</span></span> <span data-ttu-id="d9cdb-220">Pokud jsou k dispozici, řada lomítek, které následují dvě lomítka, jsou sbaleny do jednoho lomítka.</span><span class="sxs-lookup"><span data-stu-id="d9cdb-220">If they are present, a series of slashes that follow the first two slashes are collapsed into a single slash.</span></span>

### <a name="evaluate-relative-components"></a><span data-ttu-id="d9cdb-221">Vyhodnotit relativní součásti</span><span class="sxs-lookup"><span data-stu-id="d9cdb-221">Evaluate relative components</span></span>

<span data-ttu-id="d9cdb-222">Jak je cesta zpracována, `.` jsou vyhodnoceny všechny součásti nebo segmenty, které se skládají z jedné nebo dvě tečky (nebo `..` ):</span><span class="sxs-lookup"><span data-stu-id="d9cdb-222">As the path is processed, any components or segments that are composed of a single or a double period (`.` or `..`) are evaluated:</span></span>

- <span data-ttu-id="d9cdb-223">V rámci jednoho období je aktuální segment odebraný, protože odkazuje na aktuální adresář.</span><span class="sxs-lookup"><span data-stu-id="d9cdb-223">For a single period, the current segment is removed, since it refers to the current directory.</span></span>

- <span data-ttu-id="d9cdb-224">Pro dvojitou dobu se odstraní aktuální segment a nadřazený segment, protože dvojitá tečka odkazuje na nadřazený adresář.</span><span class="sxs-lookup"><span data-stu-id="d9cdb-224">For a double period, the current segment and the parent segment are removed, since the double period refers to the parent directory.</span></span>

   <span data-ttu-id="d9cdb-225">Nadřazené adresáře jsou odebrány pouze v případě, že nejsou za kořenem cesty.</span><span class="sxs-lookup"><span data-stu-id="d9cdb-225">Parent directories are only removed if they aren't past the root of the path.</span></span> <span data-ttu-id="d9cdb-226">Kořen cesty závisí na typu cesty.</span><span class="sxs-lookup"><span data-stu-id="d9cdb-226">The root of the path depends on the type of path.</span></span> <span data-ttu-id="d9cdb-227">Je to jednotka ( `C:\` ) pro cesty DOS, server/sdílená složka pro UNCS ( `\\Server\Share` ) a Předpona cesty zařízení pro cesty zařízení ( `\\?\` nebo `\\.\` ).</span><span class="sxs-lookup"><span data-stu-id="d9cdb-227">It is the drive (`C:\`) for DOS paths, the server/share for UNCs (`\\Server\Share`), and the device path prefix for device paths (`\\?\` or `\\.\`).</span></span>

### <a name="trim-characters"></a><span data-ttu-id="d9cdb-228">Oříznout znaky</span><span class="sxs-lookup"><span data-stu-id="d9cdb-228">Trim characters</span></span>

<span data-ttu-id="d9cdb-229">Společně s odebranými oddělovači a relativními segmenty odebranými dříve byly některé další znaky během normalizace odebrány:</span><span class="sxs-lookup"><span data-stu-id="d9cdb-229">Along with the runs of separators and relative segments removed earlier, some additional characters are removed during normalization:</span></span>

- <span data-ttu-id="d9cdb-230">Pokud segment skončí v jednom období, toto období se odebere.</span><span class="sxs-lookup"><span data-stu-id="d9cdb-230">If a segment ends in a single period, that period is removed.</span></span> <span data-ttu-id="d9cdb-231">(V předchozím kroku jsou normalizovány segmenty jedné nebo dvojité tečky.</span><span class="sxs-lookup"><span data-stu-id="d9cdb-231">(A segment of a single or double period is normalized in the previous step.</span></span> <span data-ttu-id="d9cdb-232">Segment tří nebo více teček není normalizován a ve skutečnosti je platný název souboru nebo adresáře.)</span><span class="sxs-lookup"><span data-stu-id="d9cdb-232">A segment of three or more periods is not normalized and is actually a valid file/directory name.)</span></span>

- <span data-ttu-id="d9cdb-233">Pokud cesta nekončí oddělovačem, odeberou se všechna koncová tečka a mezery (U + 0020).</span><span class="sxs-lookup"><span data-stu-id="d9cdb-233">If the path doesn't end in a separator, all trailing periods and spaces (U+0020) are removed.</span></span> <span data-ttu-id="d9cdb-234">Pokud je poslední segment jednoduše jedna nebo dvojitá tečka, spadá do výše uvedeného pravidla relativních součástí.</span><span class="sxs-lookup"><span data-stu-id="d9cdb-234">If the last segment is simply a single or double period, it falls under the relative components rule above.</span></span>

   <span data-ttu-id="d9cdb-235">Toto pravidlo znamená, že můžete vytvořit název adresáře s koncovým místem přidáním koncového oddělovače za mezerou.</span><span class="sxs-lookup"><span data-stu-id="d9cdb-235">This rule means that you can create a directory name with a trailing space by adding a trailing separator after the space.</span></span>

   > [!IMPORTANT]
   > <span data-ttu-id="d9cdb-236">**Nikdy** byste neměli vytvořit adresář nebo název souboru s koncovým místem.</span><span class="sxs-lookup"><span data-stu-id="d9cdb-236">You should **never** create a directory or filename with a trailing space.</span></span> <span data-ttu-id="d9cdb-237">Koncové mezery můžou ztížit nebo nemožné získat přístup k adresáři a aplikace se často nezdaří při pokusu o zpracování adresářů nebo souborů, jejichž názvy obsahují koncové mezery.</span><span class="sxs-lookup"><span data-stu-id="d9cdb-237">Trailing spaces can make it difficult or impossible to access a directory, and applications commonly fail when attempting to handle directories or files whose names include trailing spaces.</span></span>

## <a name="skip-normalization"></a><span data-ttu-id="d9cdb-238">Přeskočit normalizaci</span><span class="sxs-lookup"><span data-stu-id="d9cdb-238">Skip normalization</span></span>

<span data-ttu-id="d9cdb-239">V normálním případě je jakákoli Cesta předaná do rozhraní API systému Windows (efektivně) předána [funkci GetFullPathName](/windows/desktop/api/fileapi/nf-fileapi-getfullpathnamea) a normalizována.</span><span class="sxs-lookup"><span data-stu-id="d9cdb-239">Normally, any path passed to a Windows API is (effectively) passed to the [GetFullPathName function](/windows/desktop/api/fileapi/nf-fileapi-getfullpathnamea) and normalized.</span></span> <span data-ttu-id="d9cdb-240">Existuje jedna důležitá výjimka: cesta zařízení, která začíná otazníkem místo tečky.</span><span class="sxs-lookup"><span data-stu-id="d9cdb-240">There is one important exception: a device path that begins with a question mark instead of a period.</span></span> <span data-ttu-id="d9cdb-241">Pokud cesta začíná přesně s `\\?\` (Všimněte si použití kanonického zpětného lomítka), je normalizovaná.</span><span class="sxs-lookup"><span data-stu-id="d9cdb-241">Unless the path starts exactly with `\\?\` (note the use of the canonical backslash), it is normalized.</span></span>

<span data-ttu-id="d9cdb-242">Proč byste chtěli přeskočit normalizaci?</span><span class="sxs-lookup"><span data-stu-id="d9cdb-242">Why would you want to skip normalization?</span></span> <span data-ttu-id="d9cdb-243">Existují tři hlavní důvody:</span><span class="sxs-lookup"><span data-stu-id="d9cdb-243">There are three major reasons:</span></span>

1. <span data-ttu-id="d9cdb-244">Získat přístup k cestám, které jsou normálně nedostupné, ale jsou právní.</span><span class="sxs-lookup"><span data-stu-id="d9cdb-244">To get access to paths that are normally unavailable but are legal.</span></span> <span data-ttu-id="d9cdb-245">K souboru nebo adresáři s názvem například `hidden.` nelze přistupovat jiným způsobem.</span><span class="sxs-lookup"><span data-stu-id="d9cdb-245">A file or directory called `hidden.`, for example, is impossible to access in any other way.</span></span>

1. <span data-ttu-id="d9cdb-246">Chcete-li zvýšit výkon, přeskočí normalizace, pokud jste již byli normalizováni.</span><span class="sxs-lookup"><span data-stu-id="d9cdb-246">To improve performance by skipping normalization if you've already normalized.</span></span>

1. <span data-ttu-id="d9cdb-247">Pouze v .NET Framework, pokud chcete přeskočit `MAX_PATH` kontrolu délky cesty, aby bylo možné použít cesty větší než 259 znaků.</span><span class="sxs-lookup"><span data-stu-id="d9cdb-247">On the .NET Framework only, to skip the `MAX_PATH` check for path length to allow for paths that are greater than 259 characters.</span></span> <span data-ttu-id="d9cdb-248">Většina rozhraní API to umožňuje s některými výjimkami.</span><span class="sxs-lookup"><span data-stu-id="d9cdb-248">Most APIs allow this, with some exceptions.</span></span>

> [!NOTE]
> <span data-ttu-id="d9cdb-249">.NET Core zpracovává dlouhé cesty implicitně a neprovádí `MAX_PATH` kontrolu.</span><span class="sxs-lookup"><span data-stu-id="d9cdb-249">.NET Core handles long paths implicitly and does not perform a `MAX_PATH` check.</span></span> <span data-ttu-id="d9cdb-250">Tato `MAX_PATH` kontroly se vztahuje pouze na .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="d9cdb-250">The `MAX_PATH` check applies only to the .NET Framework.</span></span>

<span data-ttu-id="d9cdb-251">Normalizace a maximální počet kontrol cest se přeskočí jediným rozdílem mezi těmito dvěma syntaxemi cesty zařízení: jsou jinak identické.</span><span class="sxs-lookup"><span data-stu-id="d9cdb-251">Skipping normalization and max path checks is the only difference between the two device path syntaxes; they are otherwise identical.</span></span> <span data-ttu-id="d9cdb-252">Při přeskočení normalizace buďte opatrní, protože můžete snadno vytvářet cesty, které jsou obtížné pro práci s běžnými aplikacemi.</span><span class="sxs-lookup"><span data-stu-id="d9cdb-252">Be careful with skipping normalization, since you can easily create paths that are difficult for "normal" applications to deal with.</span></span>

<span data-ttu-id="d9cdb-253">`\\?\`Pokud explicitně předáte [funkci GetFullPathName](/windows/desktop/api/fileapi/nf-fileapi-getfullpathnamea), cesty začínající na jsou stále normalizovány.</span><span class="sxs-lookup"><span data-stu-id="d9cdb-253">Paths that start with `\\?\` are still normalized if you explicitly pass them to the [GetFullPathName function](/windows/desktop/api/fileapi/nf-fileapi-getfullpathnamea).</span></span>

<span data-ttu-id="d9cdb-254">Můžete předat cesty více než znaků, které `MAX_PATH` mají být [GetFullPathName](/windows/desktop/api/fileapi/nf-fileapi-getfullpathnamea) bez `\\?\` .</span><span class="sxs-lookup"><span data-stu-id="d9cdb-254">You can pass paths of more than `MAX_PATH` characters to [GetFullPathName](/windows/desktop/api/fileapi/nf-fileapi-getfullpathnamea) without `\\?\`.</span></span> <span data-ttu-id="d9cdb-255">Podporuje cesty s libovolnou délkou až do maximální velikosti řetězce, kterou může systém Windows zpracovat.</span><span class="sxs-lookup"><span data-stu-id="d9cdb-255">It supports arbitrary length paths up to the maximum string size that Windows can handle.</span></span>

## <a name="case-and-the-windows-file-system"></a><span data-ttu-id="d9cdb-256">Případ a systém souborů systému Windows</span><span class="sxs-lookup"><span data-stu-id="d9cdb-256">Case and the Windows file system</span></span>

<span data-ttu-id="d9cdb-257">V systému souborů systému Windows, který nepoužívají uživatelé a vývojáři systému Windows, se v názvech cest a adresářů nerozlišují velká a malá písmena.</span><span class="sxs-lookup"><span data-stu-id="d9cdb-257">A peculiarity of the Windows file system that non-Windows users and developers find confusing is that path and directory names are case-insensitive.</span></span> <span data-ttu-id="d9cdb-258">To znamená, že názvy adresářů a souborů odrážejí velikost písmen řetězců použitých při jejich vytvoření.</span><span class="sxs-lookup"><span data-stu-id="d9cdb-258">That is, directory and file names reflect the casing of the strings used when they are created.</span></span> <span data-ttu-id="d9cdb-259">Například volání metody</span><span class="sxs-lookup"><span data-stu-id="d9cdb-259">For example, the method call</span></span>

```csharp
Directory.Create("TeStDiReCtOrY");
```

```vb
Directory.Create("TeStDiReCtOrY")
```

<span data-ttu-id="d9cdb-260">vytvoří adresář s názvem TeStDiReCtOrY.</span><span class="sxs-lookup"><span data-stu-id="d9cdb-260">creates a directory named TeStDiReCtOrY.</span></span> <span data-ttu-id="d9cdb-261">Pokud přejmenujete adresář nebo soubor, aby se změnil jeho případ, název adresáře nebo souboru bude odpovídat velikosti řetězce použitého při jeho přejmenování.</span><span class="sxs-lookup"><span data-stu-id="d9cdb-261">If you rename a directory or file to change its case, the directory or file name reflects the case of the string used when you rename it.</span></span> <span data-ttu-id="d9cdb-262">Například následující kód přejmenuje soubor s názvem test.txt na Test.txt:</span><span class="sxs-lookup"><span data-stu-id="d9cdb-262">For example, the following code renames a file named test.txt to Test.txt:</span></span>

[!code-csharp[case-and-renaming](~/samples/snippets/standard/io/file-names/cs/rename.cs)]
[!code-vb[case-and-renaming](~/samples/snippets/standard/io/file-names/vb/rename.vb)]

<span data-ttu-id="d9cdb-263">Porovnávání názvů adresářů a souborů ale nerozlišuje velká a malá písmena.</span><span class="sxs-lookup"><span data-stu-id="d9cdb-263">However, directory and file name comparisons are case-insensitive.</span></span> <span data-ttu-id="d9cdb-264">Pokud vyhledáte soubor s názvem "test.txt", rozhraní API systému souborů .NET ignorují velikost písmen v porovnání.</span><span class="sxs-lookup"><span data-stu-id="d9cdb-264">If you search for a file named "test.txt", .NET file system APIs ignore case in the comparison.</span></span> <span data-ttu-id="d9cdb-265">"Test.txt", "TEST.TXT", "test.TXT" a jakékoli další kombinace velkých a malých písmen budou odpovídat "test.txt".</span><span class="sxs-lookup"><span data-stu-id="d9cdb-265">"Test.txt", "TEST.TXT", "test.TXT", and any other combination of uppercase and lowercase letters will match "test.txt".</span></span>
