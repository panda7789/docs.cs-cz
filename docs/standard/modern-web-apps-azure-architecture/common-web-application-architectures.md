---
title: Běžné architektury webových aplikací
description: Navrhování moderních webových aplikací pomocí ASP.NET Core a Azure | Prozkoumejte běžné architektury webových aplikací
author: ardalis
ms.author: wiwagn
ms.date: 06/28/2018
ms.openlocfilehash: ff483c9b555fdf394d11626536c28e7e07516d05
ms.sourcegitcommit: 4c158beee818c408d45a9609bfc06f209a523e22
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 07/03/2018
ms.locfileid: "37404629"
---
# <a name="common-web-application-architectures"></a><span data-ttu-id="2b371-103">Běžné architektury webových aplikací</span><span class="sxs-lookup"><span data-stu-id="2b371-103">Common web application architectures</span></span>

> <span data-ttu-id="2b371-104">"Pokud se domníváte, že je dobré architektura nákladné, zkuste chybný architektury."</span><span class="sxs-lookup"><span data-stu-id="2b371-104">"If you think good architecture is expensive, try bad architecture."</span></span>  
> <span data-ttu-id="2b371-105">_– Brian zápatí a Joseph Yoder_</span><span class="sxs-lookup"><span data-stu-id="2b371-105">_- Brian Foote and Joseph Yoder_</span></span>

<span data-ttu-id="2b371-106">Většina tradičních aplikací rozhraní .NET jsou nasazeny jako jedné jednotky odpovídající spustitelný soubor nebo jednu webovou aplikaci spuštěnou v rámci jedné domény aplikace služby IIS.</span><span class="sxs-lookup"><span data-stu-id="2b371-106">Most traditional .NET applications are deployed as single units corresponding to an executable or a single web application running within a single IIS appdomain.</span></span> <span data-ttu-id="2b371-107">Toto je nejjednodušší model nasazení a velmi dobře slouží řada aplikací menší veřejné a vnitřní.</span><span class="sxs-lookup"><span data-stu-id="2b371-107">This is the simplest deployment model and serves many internal and smaller public applications very well.</span></span> <span data-ttu-id="2b371-108">Ale i směru tato jedna jednotka nasazení, většina netriviální obchodních aplikací těžit z některé logické rozdělení do několika vrstev.</span><span class="sxs-lookup"><span data-stu-id="2b371-108">However, even given this single unit of deployment, most non-trivial business applications benefit from some logical separation into several layers.</span></span>

## <a name="what-is-a-monolithic-application"></a><span data-ttu-id="2b371-109">Co je u monolitické aplikace?</span><span class="sxs-lookup"><span data-stu-id="2b371-109">What is a monolithic application?</span></span>

<span data-ttu-id="2b371-110">Monolitické aplikace je ten, který je zcela nezávislý, z hlediska své chování.</span><span class="sxs-lookup"><span data-stu-id="2b371-110">A monolithic application is one that is entirely self-contained, in terms of its behavior.</span></span> <span data-ttu-id="2b371-111">Může komunikovat s dalšími službám nebo datům úložišti v průběhu provádění jeho operací, ale základní chování aplikace běží v rámci svého vlastního procesu a celá aplikace je obvykle nasazeni jako jeden celek.</span><span class="sxs-lookup"><span data-stu-id="2b371-111">It may interact with other services or data stores in the course of performing its operations, but the core of its behavior runs within its own process and the entire application is typically deployed as a single unit.</span></span> <span data-ttu-id="2b371-112">Pokud takové aplikace potřebuje k horizontálnímu škálování, obvykle bude celá aplikace je duplicitní v rámci více serverů nebo virtuálních počítačů.</span><span class="sxs-lookup"><span data-stu-id="2b371-112">If such an application needs to scale horizontally, typically the entire application is duplicated across multiple servers or virtual machines.</span></span>

## <a name="all-in-one-applications"></a><span data-ttu-id="2b371-113">Aplikace: 1</span><span class="sxs-lookup"><span data-stu-id="2b371-113">All-in-one applications</span></span>

<span data-ttu-id="2b371-114">Nejmenší možný počet projektů pro architekturu aplikace patří.</span><span class="sxs-lookup"><span data-stu-id="2b371-114">The smallest possible number of projects for an application architecture is one.</span></span> <span data-ttu-id="2b371-115">V této architektuře celý logiku aplikace je obsažená v jednom projektu zkompilován do jednoho sestavení a nasazených jako celek.</span><span class="sxs-lookup"><span data-stu-id="2b371-115">In this architecture, the entire logic of the application is contained in a single project, compiled to a single assembly, and deployed as a single unit.</span></span>

<span data-ttu-id="2b371-116">Nový projekt ASP.NET Core, vytvořené v sadě Visual Studio nebo z příkazového řádku, je na začátku jako jednoduchý monolitu "vše v jednom".</span><span class="sxs-lookup"><span data-stu-id="2b371-116">A new ASP.NET Core project, whether created in Visual Studio or from the command line, starts out as a simple "all-in-one" monolith.</span></span> <span data-ttu-id="2b371-117">Obsahuje všechny chování aplikace, včetně logikou přístupu prezentační, obchodní a datové sady.</span><span class="sxs-lookup"><span data-stu-id="2b371-117">It contains all of the behavior of the application, including presentation, business, and data access logic.</span></span> <span data-ttu-id="2b371-118">Obrázek 5-1 zobrazuje strukturu souborů z jednoho projektu aplikace.</span><span class="sxs-lookup"><span data-stu-id="2b371-118">Figure 5-1 shows the file structure of a single-project app.</span></span>

![](./media/image5-1.png)

<span data-ttu-id="2b371-119">**Obrázek 5-1.**</span><span class="sxs-lookup"><span data-stu-id="2b371-119">**Figure 5-1.**</span></span> <span data-ttu-id="2b371-120">Jednoho projektu aplikace ASP.NET Core.</span><span class="sxs-lookup"><span data-stu-id="2b371-120">A single project ASP.NET Core app.</span></span>

<span data-ttu-id="2b371-121">V případě jediného projektu v oddělení oblastí zájmu je dosaženo pomocí složky.</span><span class="sxs-lookup"><span data-stu-id="2b371-121">In a single project scenario, separation of concerns is achieved through the use of folders.</span></span> <span data-ttu-id="2b371-122">Výchozí šablona obsahuje samostatné složky pro vzor odpovědnosti modelů, zobrazení a Kontrolerů MVC, stejně jako další složky pro Data a služby.</span><span class="sxs-lookup"><span data-stu-id="2b371-122">The default template includes separate folders for MVC pattern responsibilities of Models, Views, and Controllers, as well as additional folders for Data and Services.</span></span> <span data-ttu-id="2b371-123">V tomto případě by měla být omezena prezentace podrobnosti co nejvíc do zobrazení složky a podrobnosti implementace přístupu dat by měla být omezena na třídy, které jsou uloženy ve složce Data.</span><span class="sxs-lookup"><span data-stu-id="2b371-123">In this arrangement, presentation details should be limited as much as possible to the Views folder, and data access implementation details should be limited to classes kept in the Data folder.</span></span> <span data-ttu-id="2b371-124">Obchodní logika by měl být uložený v třídy v rámci složky modelů a služeb.</span><span class="sxs-lookup"><span data-stu-id="2b371-124">Business logic should reside in services and classes within the Models folder.</span></span>

<span data-ttu-id="2b371-125">I když je jednoduché, monolitické řešení jednoprojektové má některé nevýhody.</span><span class="sxs-lookup"><span data-stu-id="2b371-125">Although simple, the single-project monolithic solution has some disadvantages.</span></span> <span data-ttu-id="2b371-126">Nárůstu velikosti a složitosti projektu, bude počet souborů a složek i růst.</span><span class="sxs-lookup"><span data-stu-id="2b371-126">As the project's size and complexity grows, the number of files and folders will continue to grow as well.</span></span> <span data-ttu-id="2b371-127">Rozhraní (UI) obavy uživatelů (modelů, zobrazení, kontrolery) jsou umístěny v více složek, které nejsou seskupeny podle abecedy.</span><span class="sxs-lookup"><span data-stu-id="2b371-127">User interface (UI) concerns (models, views, controllers) reside in multiple folders, which aren't grouped together alphabetically.</span></span> <span data-ttu-id="2b371-128">Tento problém pouze získá horší, když se další úroveň uživatelského rozhraní konstruktorů, jako jsou filtry nebo ModelBinders, jsou přidány do jejich vlastních složek.</span><span class="sxs-lookup"><span data-stu-id="2b371-128">This issue only gets worse when additional UI-level constructs, such as Filters or ModelBinders, are added in their own folders.</span></span> <span data-ttu-id="2b371-129">Obchodní logika je rozmístěno jinde mezi složkami modelů a služeb, a není není jasný náznak, z nichž třídy do složky, které by neměly být závislé na které ostatní.</span><span class="sxs-lookup"><span data-stu-id="2b371-129">Business logic is scattered between the Models and Services folders, and there's no clear indication of which classes in which folders should depend on which others.</span></span> <span data-ttu-id="2b371-130">Tato nedostatečná organizace na úrovni projektu často vede k [špagety kód](https://deviq.com/spaghetti-code/).</span><span class="sxs-lookup"><span data-stu-id="2b371-130">This lack of organization at the project level frequently leads to [spaghetti code](https://deviq.com/spaghetti-code/).</span></span>

<span data-ttu-id="2b371-131">Pro řešení těchto problémů, často vyvíjet aplikace do multiprojektových řešení, kde je považován za každý projekt uložená v konkrétní _vrstvy_ aplikace.</span><span class="sxs-lookup"><span data-stu-id="2b371-131">To address these issues, applications often evolve into multi-project solutions, where each project is considered to reside in a particular _layer_ of the application.</span></span>

## <a name="what-are-layers"></a><span data-ttu-id="2b371-132">Co jsou vrstvy?</span><span class="sxs-lookup"><span data-stu-id="2b371-132">What are layers?</span></span>

<span data-ttu-id="2b371-133">Jak aplikace jejich složitost v, je jeden způsob, jak spravovat složitost rozdělte aplikace podle její odpovědnosti nebo připomínky.</span><span class="sxs-lookup"><span data-stu-id="2b371-133">As applications grow in complexity, one way to manage that complexity is to break up the application according to its responsibilities or concerns.</span></span> <span data-ttu-id="2b371-134">Následuje oddělení hlavní otázky a pomoct chránit rostoucí základu kódu uspořádané tak, aby vývojáři mohli snadno najít, kde je implementovat určité funkce.</span><span class="sxs-lookup"><span data-stu-id="2b371-134">This follows the separation of concerns principle, and can help keep a growing codebase organized so that developers can easily find where certain functionality is implemented.</span></span> <span data-ttu-id="2b371-135">Vrstvené architektury nabízí několik výhod nad rámec právě kódu organizace, i když.</span><span class="sxs-lookup"><span data-stu-id="2b371-135">Layered architecture offers a number of advantages beyond just code organization, though.</span></span>

<span data-ttu-id="2b371-136">Uspořádáním kódu do vrstev lze opětovně použít běžné funkce nízké úrovně v celé aplikaci.</span><span class="sxs-lookup"><span data-stu-id="2b371-136">By organizing code into layers, common low-level functionality can be reused throughout the application.</span></span> <span data-ttu-id="2b371-137">Použití je výhodné, protože to znamená méně kódu musí být napsaný, a proto ji povolí aplikaci používají jako standard jedna implementace, po [Neopakovat sami (zkušební)](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself) zásadě.</span><span class="sxs-lookup"><span data-stu-id="2b371-137">This reuse is beneficial because it means less code needs to be written and because it can allow the application to standardize on a single implementation, following the [don't repeat yourself (DRY)](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself) principle.</span></span>

<span data-ttu-id="2b371-138">Pomocí vrstev architektury můžete aplikace vynucovat omezení, na které vrstvy mohou komunikovat s jinými vrstvami.</span><span class="sxs-lookup"><span data-stu-id="2b371-138">With a layered architecture, applications can enforce restrictions on which layers can communicate with other layers.</span></span> <span data-ttu-id="2b371-139">To pomáhá zajistit zapouzdření.</span><span class="sxs-lookup"><span data-stu-id="2b371-139">This helps to achieve encapsulation.</span></span> <span data-ttu-id="2b371-140">Když vrstvu je změnit nebo nahradit, by měla mít vliv pouze vrstvy, které s ním pracovat.</span><span class="sxs-lookup"><span data-stu-id="2b371-140">When a layer is changed or replaced, only those layers that work with it should be impacted.</span></span> <span data-ttu-id="2b371-141">Tím, že omezíte, které vrstvy závisí, na kterých můžete minimalizovat jinými vrstvami, dopad změn, tak, aby jeden změna nebude mít vliv na celou aplikaci.</span><span class="sxs-lookup"><span data-stu-id="2b371-141">By limiting which layers depend on which other layers, the impact of changes can be mitigated so that a single change doesn't impact the entire application.</span></span>

<span data-ttu-id="2b371-142">Vrstvy (a zapouzdření) to značně zjednodušují nahrazují funkce v rámci aplikace.</span><span class="sxs-lookup"><span data-stu-id="2b371-142">Layers (and encapsulation) make it much easier to replace functionality within the application.</span></span> <span data-ttu-id="2b371-143">Aplikace například může zpočátku používat vlastní databázi systému SQL Server pro trvalost, ale později může zvolit strategii trvalost založené na cloudu, nebo jeden za webového rozhraní API.</span><span class="sxs-lookup"><span data-stu-id="2b371-143">For example, an application might initially use its own SQL Server database for persistence, but later could choose to use a cloud-based persistence strategy, or one behind a web API.</span></span> <span data-ttu-id="2b371-144">Pokud aplikace nemá správně zapouzdřené jeho implementace trvalého v rámci logické vrstvy, mohla být, že systém SQL Server zvláštní vrstva nahrazena novou implementaci stejné veřejné rozhraní.</span><span class="sxs-lookup"><span data-stu-id="2b371-144">If the application has properly encapsulated its persistence implementation within a logical layer, that SQL Server specific layer could be replaced by a new one implementing the same public interface.</span></span>

<span data-ttu-id="2b371-145">Kromě potenciál záměnu implementace v reakci na budoucí změny v požadavcích aplikace může také usnadňují vyměnit implementace pro účely testování.</span><span class="sxs-lookup"><span data-stu-id="2b371-145">In addition to the potential of swapping out implementations in response to future changes in requirements, application layers can also make it easier to swap out implementations for testing purposes.</span></span> <span data-ttu-id="2b371-146">Namísto nutnosti psát testy, které pracují na skutečné datové vrstvy nebo vrstvě uživatelského rozhraní aplikace, lze tyto vrstvy nahradit v době testu s falešnou implementace, které poskytují známé odpovědí na požadavky.</span><span class="sxs-lookup"><span data-stu-id="2b371-146">Instead of having to write tests that operate against the real data layer or UI layer of the application, these layers can be replaced at test time with fake implementations that provide known responses to requests.</span></span> <span data-ttu-id="2b371-147">Testy díky obvykle mnohem jednodušší zápis a mnohem rychlejší spouštění ve srovnání s spuštění testů znovu aplikace skutečný infrastruktury.</span><span class="sxs-lookup"><span data-stu-id="2b371-147">This typically makes tests much easier to write and much faster to run when compared to running tests again the application's real infrastructure.</span></span>

<span data-ttu-id="2b371-148">Logické vrstvení je běžná technika pro zlepšení organizaci kódu v oddílu podnikové aplikace softwaru a existuje několik způsobů, jimiž kódu je možné uspořádat do vrstvy.</span><span class="sxs-lookup"><span data-stu-id="2b371-148">Logical layering is a common technique for improving the organization of code in enterprise software applications, and there are several ways in which code can be organized into layers.</span></span>

> [!NOTE]
 > <span data-ttu-id="2b371-149">_Vrstvy_ představují logické oddělení v rámci aplikace.</span><span class="sxs-lookup"><span data-stu-id="2b371-149">_Layers_ represent logical separation within the application.</span></span> <span data-ttu-id="2b371-150">V případě, že aplikace logiky je fyzicky distribuovány na samostatných serverech nebo procesy, tyto cíle samostatné fyzické nasazení se označují jako _úrovně_.</span><span class="sxs-lookup"><span data-stu-id="2b371-150">In the event that application logic is physically distributed to separate servers or processes, these separate physical deployment targets are referred to as _tiers_.</span></span> <span data-ttu-id="2b371-151">Je možné a celkem běžné, aby N vrstvy aplikace, která se nasadí do jedné vrstvě.</span><span class="sxs-lookup"><span data-stu-id="2b371-151">It's possible, and quite common, to have an N-Layer application that is deployed to a single tier.</span></span>

## <a name="traditional-n-layer-architecture-applications"></a><span data-ttu-id="2b371-152">Tradiční aplikace s architekturou "N-vrstva"</span><span class="sxs-lookup"><span data-stu-id="2b371-152">Traditional "N-Layer" architecture applications</span></span>

<span data-ttu-id="2b371-153">Nejběžnější organizace aplikace logiky do vrstvy se zobrazí obrázek 5-2.</span><span class="sxs-lookup"><span data-stu-id="2b371-153">The most common organization of application logic into layers is shown in Figure 5-2.</span></span>

![](./media/image5-2.png)

<span data-ttu-id="2b371-154">**Obrázek 5-2.**</span><span class="sxs-lookup"><span data-stu-id="2b371-154">**Figure 5-2.**</span></span> <span data-ttu-id="2b371-155">Typická aplikace vrstvy.</span><span class="sxs-lookup"><span data-stu-id="2b371-155">Typical application layers.</span></span>

<span data-ttu-id="2b371-156">Tyto vrstvy jsou často se zkracuje jako uživatelského rozhraní, vrstvu obchodní logiky () knihoven BLL a DAL (Data Access Layer).</span><span class="sxs-lookup"><span data-stu-id="2b371-156">These layers are frequently abbreviated as UI, BLL (Business Logic Layer), and DAL (Data Access Layer).</span></span> <span data-ttu-id="2b371-157">Pomocí této architektury, uživatelům provádět požadavky prostřednictvím vrstvě uživatelského rozhraní, která komunikuje jenom s BLL.</span><span class="sxs-lookup"><span data-stu-id="2b371-157">Using this architecture, users make requests through the UI layer, which interacts only with the BLL.</span></span> <span data-ttu-id="2b371-158">BLL, pak můžete volat DAL data žádosti o přístup.</span><span class="sxs-lookup"><span data-stu-id="2b371-158">The BLL, in turn, can call the DAL for data access requests.</span></span> <span data-ttu-id="2b371-159">Vrstvě uživatelského rozhraní neměli provádět všechny požadavky vrstvy DAL přímo ani by měl pracovat s trvalostí přímo prostřednictvím jiným způsobem.</span><span class="sxs-lookup"><span data-stu-id="2b371-159">The UI layer shouldn't make any requests to the DAL directly, nor should it interact with persistence directly through other means.</span></span> <span data-ttu-id="2b371-160">Podobně BLL by měl pouze pracovat s trvalostí prostřednictvím vrstvy DAL.</span><span class="sxs-lookup"><span data-stu-id="2b371-160">Likewise, the BLL should only interact with persistence by going through the DAL.</span></span> <span data-ttu-id="2b371-161">Tímto způsobem každá vrstva má svou vlastní dobře známé odpovědnost.</span><span class="sxs-lookup"><span data-stu-id="2b371-161">In this way, each layer has its own well-known responsibility.</span></span>

<span data-ttu-id="2b371-162">Jednou z nevýhod tohoto přístupu tradiční vrstvení je, že závislostí kompilace v horní části do dolní části.</span><span class="sxs-lookup"><span data-stu-id="2b371-162">One disadvantage of this traditional layering approach is that compile-time dependencies run from the top to the bottom.</span></span> <span data-ttu-id="2b371-163">To znamená vrstvě uživatelského rozhraní závisí na BLL, která závisí na vrstvy DAL.</span><span class="sxs-lookup"><span data-stu-id="2b371-163">That is, the UI layer depends on the BLL, which depends on the DAL.</span></span> <span data-ttu-id="2b371-164">To znamená, že BLL, který obvykle obsahuje nejdůležitější logiky v aplikaci, je závislá na podrobnosti implementace přístupu dat (a často na existenci databáze).</span><span class="sxs-lookup"><span data-stu-id="2b371-164">This means that the BLL, which usually holds the most important logic in the application, is dependent on data access implementation details (and often on the existence of a database).</span></span> <span data-ttu-id="2b371-165">Testování obchodní logiku v takové architektury je často obtížné, které vyžadují testovací databázi.</span><span class="sxs-lookup"><span data-stu-id="2b371-165">Testing business logic in such an architecture is often difficult, requiring a test database.</span></span> <span data-ttu-id="2b371-166">Princip inverzi závislostí lze použít k vyřešení tohoto problému, jak uvidíte v další části.</span><span class="sxs-lookup"><span data-stu-id="2b371-166">The dependency inversion principle can be used to address this issue, as you'll see in the next section.</span></span>

<span data-ttu-id="2b371-167">Obrázek 5 – 3 ukazuje příklad řešení, rozdělení aplikace do tří projektů odpovědnost (nebo vrstvy).</span><span class="sxs-lookup"><span data-stu-id="2b371-167">Figure 5-3 shows an example solution, breaking the application into three projects by responsibility (or layer).</span></span>

![](./media/image5-3.png)

<span data-ttu-id="2b371-168">**Obrázek 5 – 3.**</span><span class="sxs-lookup"><span data-stu-id="2b371-168">**Figure 5-3.**</span></span> <span data-ttu-id="2b371-169">Jednoduché monolitické aplikace pomocí tří projektů.</span><span class="sxs-lookup"><span data-stu-id="2b371-169">A simple monolithic application with three projects.</span></span>

<span data-ttu-id="2b371-170">I když se tato aplikace používá několik projektů pro účely organizace, stále je nasazen jako jednu jednotku a jeho klienti budou pracovat s ním jako jednu webovou aplikaci.</span><span class="sxs-lookup"><span data-stu-id="2b371-170">Although this application uses several projects for organizational purposes, it's still deployed as a single unit and its clients will interact with it as a single web app.</span></span> <span data-ttu-id="2b371-171">To umožňuje proces velmi jednoduché nasazení.</span><span class="sxs-lookup"><span data-stu-id="2b371-171">This allows for very simple deployment process.</span></span> <span data-ttu-id="2b371-172">Obrázek 5 – 4 ukazuje, jak mohou být takové aplikace hostované pomocí Azure.</span><span class="sxs-lookup"><span data-stu-id="2b371-172">Figure 5-4 shows how such an app might be hosted using Azure.</span></span>

![](./media/image5-4.png)

<span data-ttu-id="2b371-173">**Obrázek 5 – 4.**</span><span class="sxs-lookup"><span data-stu-id="2b371-173">**Figure 5-4.**</span></span> <span data-ttu-id="2b371-174">Jednoduché nasazení webové aplikace Azure</span><span class="sxs-lookup"><span data-stu-id="2b371-174">Simple deployment of Azure Web App</span></span>

<span data-ttu-id="2b371-175">Jak rostou potřeby aplikace, může být složité a robustní řešení nasazení požadováno.</span><span class="sxs-lookup"><span data-stu-id="2b371-175">As application needs grow, more complex and robust deployment solutions may be required.</span></span> <span data-ttu-id="2b371-176">Obrázek 5 až 5 ukazuje příklad složitější plánu nasazení, který podporuje další funkce.</span><span class="sxs-lookup"><span data-stu-id="2b371-176">Figure 5-5 shows an example of a more complex deployment plan that supports additional capabilities.</span></span>

![](./media/image5-5.png)

<span data-ttu-id="2b371-177">**Obrázek 5 – 5.**</span><span class="sxs-lookup"><span data-stu-id="2b371-177">**Figure 5-5.**</span></span> <span data-ttu-id="2b371-178">Nasazení webové aplikace do služby Azure App Service</span><span class="sxs-lookup"><span data-stu-id="2b371-178">Deploying a web app to an Azure App Service</span></span>

<span data-ttu-id="2b371-179">Tento projekt organizace do více projekty založené na odpovědnost interně, zvyšuje udržovatelnost aplikace.</span><span class="sxs-lookup"><span data-stu-id="2b371-179">Internally, this project's organization into multiple projects based on responsibility improves the maintainability of the application.</span></span>

<span data-ttu-id="2b371-180">Tato jednotka je možné škálovat směrem nahoru nebo navýšení kapacity využívat škálovatelnost na vyžádání založené na cloudu.</span><span class="sxs-lookup"><span data-stu-id="2b371-180">This unit can be scaled up or out to take advantage of cloud-based on-demand scalability.</span></span> <span data-ttu-id="2b371-181">Vertikální navýšení kapacity znamená, že přidáte další procesor, paměť, místo na disku nebo další prostředky na serverech, které hostují vaši aplikaci.</span><span class="sxs-lookup"><span data-stu-id="2b371-181">Scaling up means adding additional CPU, memory, disk space, or other resources to the server(s) hosting your app.</span></span> <span data-ttu-id="2b371-182">Horizontální navýšení kapacity znamená, že přidávání dalších instancí těchto serverů, ať už jde o fyzických serverech nebo virtuálních počítačů.</span><span class="sxs-lookup"><span data-stu-id="2b371-182">Scaling out means adding additional instances of such servers, whether these are physical servers or virtual machines.</span></span> <span data-ttu-id="2b371-183">Když aplikace běží na několika instancích, nástroj pro vyrovnávání zatížení slouží k přiřazení požadavků k instance jednotlivých aplikací.</span><span class="sxs-lookup"><span data-stu-id="2b371-183">When your app is hosted across multiple instances, a load balancer is used to assign requests to individual app instances.</span></span>

<span data-ttu-id="2b371-184">Nejjednodušším přístupem při škálování webové aplikace v Azure je nakonfigurovat ručně škálování v plánu služby vaší aplikace App Service.</span><span class="sxs-lookup"><span data-stu-id="2b371-184">The simplest approach to scaling a web application in Azure is to configure scaling manually in the application's App Service Plan.</span></span> <span data-ttu-id="2b371-185">Obrázek 5 – 6 se zobrazuje obrazovka odpovídající řídicí panel Azure nakonfigurovat, kolik instancí má aplikace.</span><span class="sxs-lookup"><span data-stu-id="2b371-185">Figure 5-6 shows the appropriate Azure dashboard screen to configure how many instances are serving an app.</span></span>

![](./media/image5-6.png)

<span data-ttu-id="2b371-186">**Obrázek 5 a 6.**</span><span class="sxs-lookup"><span data-stu-id="2b371-186">**Figure 5-6.**</span></span> <span data-ttu-id="2b371-187">Plán služby App Service škálování v Azure.</span><span class="sxs-lookup"><span data-stu-id="2b371-187">App Service Plan scaling in Azure.</span></span>

## <a name="clean-architecture"></a><span data-ttu-id="2b371-188">Vyčištění architektury</span><span class="sxs-lookup"><span data-stu-id="2b371-188">Clean architecture</span></span>

<span data-ttu-id="2b371-189">Můžete přejít na podobnou architekturu mají tendenci aplikací podle principu inverzi závislostí, jakož i principů návrhu Domain-Driven (DDD).</span><span class="sxs-lookup"><span data-stu-id="2b371-189">Applications that follow the Dependency Inversion Principle as well as the Domain-Driven Design (DDD) principles tend to arrive at a similar architecture.</span></span> <span data-ttu-id="2b371-190">Tato architektura se dostaly celou řadu názvů v průběhu let.</span><span class="sxs-lookup"><span data-stu-id="2b371-190">This architecture has gone by many names over the years.</span></span> <span data-ttu-id="2b371-191">Jeden z názvů první byl šestiúhelníkový architektury, za nímž následuje adaptéry a porty.</span><span class="sxs-lookup"><span data-stu-id="2b371-191">One of the first names was Hexagonal Architecture, followed by Ports-and-Adapters.</span></span> <span data-ttu-id="2b371-192">Nedávno, je byl uvedený jako [průsvitek architektura](http://jeffreypalermo.com/blog/the-onion-architecture-part-1/) nebo [čisté architektura](https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html).</span><span class="sxs-lookup"><span data-stu-id="2b371-192">More recently, it's been cited as the [Onion Architecture](http://jeffreypalermo.com/blog/the-onion-architecture-part-1/) or [Clean Architecture](https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html).</span></span> <span data-ttu-id="2b371-193">Tento název, vyčistit architektury, se používá jako název pro tuto architekturu v této e knihy.</span><span class="sxs-lookup"><span data-stu-id="2b371-193">The latter name, Clean Architecture, is used as the name for this architecture in this e-book.</span></span>

> [!NOTE]
> <span data-ttu-id="2b371-194">Termín čisté architekturu je možné použít pro aplikace, které se vytvářejí pomocí DDD zásady stejně jako ty, které nejsou sestavené pomocí DDD.</span><span class="sxs-lookup"><span data-stu-id="2b371-194">The term Clean Architecture can be applied to applications that are built using DDD Principles as well as to those that are not built using DDD.</span></span> <span data-ttu-id="2b371-195">V případě nejprve, může být tato kombinace označovány jako "Architektuře čistého DDD".</span><span class="sxs-lookup"><span data-stu-id="2b371-195">In the case of the former, this combination may be referred to as "Clean DDD Architecture".</span></span>

<span data-ttu-id="2b371-196">Vyčistit architektuře umístí obchodní logiky a aplikace modelu v Centru pro aplikace.</span><span class="sxs-lookup"><span data-stu-id="2b371-196">Clean architecture puts the business logic and application model at the center of the application.</span></span> <span data-ttu-id="2b371-197">Namísto toho, aby obchodní logika závisí na přístup k datům nebo jiných starostí o infrastrukturu, je obrácený této závislosti: infrastruktury a podrobnosti implementace závisí na základní aplikace.</span><span class="sxs-lookup"><span data-stu-id="2b371-197">Instead of having business logic depend on data access or other infrastructure concerns, this dependency is inverted: infrastructure and implementation details depend on the Application Core.</span></span> <span data-ttu-id="2b371-198">Toho dosáhnete tak, že definujete abstrakce, rozhraní, nebo v samotném aplikace, které jsou následně implementované typy definované ve vrstvě infrastruktury.</span><span class="sxs-lookup"><span data-stu-id="2b371-198">This is achieved by defining abstractions, or interfaces, in the Application Core, which are then implemented by types defined in the Infrastructure layer.</span></span> <span data-ttu-id="2b371-199">Běžný způsob vizualizace tato architektura je použít řadu soustředných kruhy, podobně jako průsvitek.</span><span class="sxs-lookup"><span data-stu-id="2b371-199">A common way of visualizing this architecture is to use a series of concentric circles, similar to an onion.</span></span> <span data-ttu-id="2b371-200">Obrázek 5 – 7 ukazuje příklad tohoto stylu architektury reprezentace.</span><span class="sxs-lookup"><span data-stu-id="2b371-200">Figure 5-7 shows an example of this style of architectural representation.</span></span>

![](./media/image5-7.png)

<span data-ttu-id="2b371-201">**Obrázek 5 – 7.**</span><span class="sxs-lookup"><span data-stu-id="2b371-201">**Figure 5-7.**</span></span> <span data-ttu-id="2b371-202">Vyčistit architektura; průsvitek zobrazení</span><span class="sxs-lookup"><span data-stu-id="2b371-202">Clean Architecture; onion view</span></span>

<span data-ttu-id="2b371-203">V tomto diagramu závislosti tok směrem k nejvnitřnější kruh.</span><span class="sxs-lookup"><span data-stu-id="2b371-203">In this diagram, dependencies flow toward the innermost circle.</span></span> <span data-ttu-id="2b371-204">Jádro aplikace trvá jeho název z jeho pozice v jádru tento diagram.</span><span class="sxs-lookup"><span data-stu-id="2b371-204">The Application Core takes its name from its position at the core of this diagram.</span></span> <span data-ttu-id="2b371-205">A můžete zobrazit v diagramu, jádro aplikace nemá žádné závislosti na ostatních aplikačních vrstev.</span><span class="sxs-lookup"><span data-stu-id="2b371-205">And you can see on the diagram that the Application Core has no dependencies on other application layers.</span></span> <span data-ttu-id="2b371-206">Entity aplikace a rozhraní jsou velmi uprostřed.</span><span class="sxs-lookup"><span data-stu-id="2b371-206">The application's entities and interfaces are at the very center.</span></span> <span data-ttu-id="2b371-207">Pouze mimo, ale stále v základní aplikaci jsou služby domain services, které obvykle implementují rozhraní definované v vnitřního kroužku.</span><span class="sxs-lookup"><span data-stu-id="2b371-207">Just outside, but still in the Application Core, are domain services, which typically implement interfaces defined in the inner circle.</span></span> <span data-ttu-id="2b371-208">Mimo jádro aplikace uživatelského rozhraní a infrastruktura vrstvy závisí na základní aplikaci, ale ne na sebe navzájem (nemusí).</span><span class="sxs-lookup"><span data-stu-id="2b371-208">Outside of the Application Core, both the UI and the Infrastructure layers depend on the Application Core, but not on one another (necessarily).</span></span>

<span data-ttu-id="2b371-209">Obrázek 5 – 8 ukazuje tradičnější diagram vodorovné vrstev, která lépe odpovídá závislost mezi uživatelského rozhraní a dalšími vrstvami.</span><span class="sxs-lookup"><span data-stu-id="2b371-209">Figure 5-8 shows a more traditional horizontal layer diagram that better reflects the dependency between the UI and other layers.</span></span>

![](./media/image5-8.png)

<span data-ttu-id="2b371-210">**Obrázek 5 až 8.**</span><span class="sxs-lookup"><span data-stu-id="2b371-210">**Figure 5-8.**</span></span> <span data-ttu-id="2b371-211">Vyčistit architektura; horizontální vrstvy zobrazení</span><span class="sxs-lookup"><span data-stu-id="2b371-211">Clean Architecture; horizontal layer view</span></span>

<span data-ttu-id="2b371-212">Všimněte si, že solid šipky představují závislosti za kompilace, zatímco představuje přerušovanou šipku závislosti jen pro modul runtime.</span><span class="sxs-lookup"><span data-stu-id="2b371-212">Note that the solid arrows represent compile-time dependencies, while the dashed arrow represents a runtime-only dependency.</span></span> <span data-ttu-id="2b371-213">S čistou architekturou vrstvě uživatelského rozhraní pracuje s rozhraní definované v samotném aplikace v době kompilace a v ideálním případě by neměla vědět o implementaci typů definovaných ve vrstvě infrastruktury.</span><span class="sxs-lookup"><span data-stu-id="2b371-213">With the clean architecture, the UI layer works with interfaces defined in the Application Core at compile time, and ideally shouldn't know about the implementation types defined in the Infrastructure layer.</span></span> <span data-ttu-id="2b371-214">V době běhu ale tyto typy implementace jsou aplikace provést, vyžaduje, musí mít k dispozici i tradiční sítě až po aplikace základní rozhraní pomocí vkládání závislostí.</span><span class="sxs-lookup"><span data-stu-id="2b371-214">At run time, however, these implementation types are required for the app to execute, so they need to be present and wired up to the Application Core interfaces via dependency injection.</span></span>

<span data-ttu-id="2b371-215">Obrázek 5 až 9 ukazuje podrobnější zobrazení architektury aplikace ASP.NET Core při sestavení po těchto doporučení.</span><span class="sxs-lookup"><span data-stu-id="2b371-215">Figure 5-9 shows a more detailed view of an ASP.NET Core application's architecture when built following these recommendations.</span></span>

![Architektura jádra ASPNET](./media/image5-9.png)

<span data-ttu-id="2b371-217">**Obrázek 5 až 9.**</span><span class="sxs-lookup"><span data-stu-id="2b371-217">**Figure 5-9.**</span></span> <span data-ttu-id="2b371-218">Diagram architektury ASP.NET Core po vyčištění architektury.</span><span class="sxs-lookup"><span data-stu-id="2b371-218">ASP.NET Core architecture diagram following Clean Architecture.</span></span>

<span data-ttu-id="2b371-219">Protože základní aplikace nejsou závislé na infrastruktuře, je velmi jednoduše můžete vytvořit automatizované testy jednotky pro tuto vrstvu.</span><span class="sxs-lookup"><span data-stu-id="2b371-219">Because the Application Core doesn't depend on Infrastructure, it's very easy to write automated unit tests for this layer.</span></span> <span data-ttu-id="2b371-220">Hodnoty 5 až 10 a 11. 5 ukazují, jak přizpůsobit testy do této architektury.</span><span class="sxs-lookup"><span data-stu-id="2b371-220">Figures 5-10 and 5-11 show how tests fit into this architecture.</span></span>

![UnitTestCore](./media/image5-10.png)

<span data-ttu-id="2b371-222">**Obrázek 5 – 10.**</span><span class="sxs-lookup"><span data-stu-id="2b371-222">**Figure 5-10.**</span></span> <span data-ttu-id="2b371-223">Testování jednotek základní aplikaci v izolaci.</span><span class="sxs-lookup"><span data-stu-id="2b371-223">Unit testing Application Core in isolation.</span></span>

![IntegrationTests](./media/image5-11.png)

<span data-ttu-id="2b371-225">**Obrázek 5 – 11.**</span><span class="sxs-lookup"><span data-stu-id="2b371-225">**Figure 5-11.**</span></span> <span data-ttu-id="2b371-226">Integrační testování implementace infrastruktury s externími závislostmi.</span><span class="sxs-lookup"><span data-stu-id="2b371-226">Integration testing Infrastructure implementations with external dependencies.</span></span>

<span data-ttu-id="2b371-227">Protože vrstvě uživatelského rozhraní nemá žádné přímé závislosti na typy definované v projektu infrastruktury, je rovněž velmi snadno zaměnit implementace, buď usnadňuje testování nebo v reakci na měnící se požadavky na aplikace.</span><span class="sxs-lookup"><span data-stu-id="2b371-227">Since the UI layer doesn't have any direct dependency on types defined in the Infrastructure project, it's likewise very easy to swap out implementations, either to facilitate testing or in response to changing application requirements.</span></span> <span data-ttu-id="2b371-228">Integrované použití ASP.NET Core a podpora pro vkládání závislostí díky této architektuře nejvhodnější způsob, jak struktura netriviální monolitické aplikace.</span><span class="sxs-lookup"><span data-stu-id="2b371-228">ASP.NET Core's built-in use of and support for dependency injection makes this architecture the most appropriate way to structure non-trivial monolithic applications.</span></span>

<span data-ttu-id="2b371-229">U monolitické aplikace jsou všechny projekty jádro aplikace, infrastruktury a uživatelského rozhraní spustit jako jednu aplikaci.</span><span class="sxs-lookup"><span data-stu-id="2b371-229">For monolithic applications the Application Core, Infrastructure, and UI projects are all run as a single application.</span></span> <span data-ttu-id="2b371-230">Architektura modulu runtime aplikace bude vypadat přibližně jako obrázek 5 – 12.</span><span class="sxs-lookup"><span data-stu-id="2b371-230">The runtime application architecture might look something like Figure 5-12.</span></span>

![Architektura ASP.NET Core 2](./media/image5-12.png)

<span data-ttu-id="2b371-232">**Obrázek 5 – 12.**</span><span class="sxs-lookup"><span data-stu-id="2b371-232">**Figure 5-12.**</span></span> <span data-ttu-id="2b371-233">Architektura modulu runtime aplikace ASP.NET Core vzorku.</span><span class="sxs-lookup"><span data-stu-id="2b371-233">A sample ASP.NET Core app's runtime architecture.</span></span>

### <a name="organizing-code-in-clean-architecture"></a><span data-ttu-id="2b371-234">Uspořádání v architektuře čistého kódu</span><span class="sxs-lookup"><span data-stu-id="2b371-234">Organizing code in Clean Architecture</span></span>

<span data-ttu-id="2b371-235">V architektuře čistého řešení každý projekt má vymazat odpovědnosti.</span><span class="sxs-lookup"><span data-stu-id="2b371-235">In a Clean Architecture solution, each project has clear responsibilities.</span></span> <span data-ttu-id="2b371-236">V důsledku toho některé typy patří do jednotlivých projektů a často zjistíte složky odpovídající typy v příslušného projektu.</span><span class="sxs-lookup"><span data-stu-id="2b371-236">As such, certain types belong in each project and you'll frequently find folders corresponding to these types in the appropriate project.</span></span>

<span data-ttu-id="2b371-237">Jádro aplikace obsahuje obchodní model, který obsahuje entity, služby a rozhraní.</span><span class="sxs-lookup"><span data-stu-id="2b371-237">The Application Core holds the business model, which includes entities, services, and interfaces.</span></span> <span data-ttu-id="2b371-238">Tato rozhraní zahrnují abstrakce pro operace, které budou provedeny pomocí infrastruktury, jako je přístup k datům, přístupu k systému souborů, volání sítě atd. Někdy služby nebo rozhraní definované v této vrstvě bude nutné spolupracovat s nonentity typy, které nemají žádné závislosti na uživatelské rozhraní nebo infrastruktury.</span><span class="sxs-lookup"><span data-stu-id="2b371-238">These interfaces include abstractions for operations that will be performed using Infrastructure, such as data access, file system access, network calls, etc. Sometimes services or interfaces defined at this layer will need to work with non-entity types that have no dependencies on UI or Infrastructure.</span></span> <span data-ttu-id="2b371-239">Ty lze definovat jako jednoduché objekty Data Transfer (DTO).</span><span class="sxs-lookup"><span data-stu-id="2b371-239">These can be defined as simple Data Transfer Objects (DTOs).</span></span>

### <a name="application-core-types"></a><span data-ttu-id="2b371-240">Základní typy aplikací</span><span class="sxs-lookup"><span data-stu-id="2b371-240">Application Core types</span></span>

- <span data-ttu-id="2b371-241">Entity (obchodní model tříd, které jsou trvalé)</span><span class="sxs-lookup"><span data-stu-id="2b371-241">Entities (business model classes that are persisted)</span></span>
- <span data-ttu-id="2b371-242">Rozhraní</span><span class="sxs-lookup"><span data-stu-id="2b371-242">Interfaces</span></span>
- <span data-ttu-id="2b371-243">Služby</span><span class="sxs-lookup"><span data-stu-id="2b371-243">Services</span></span>
- <span data-ttu-id="2b371-244">DTO</span><span class="sxs-lookup"><span data-stu-id="2b371-244">DTOs</span></span>

<span data-ttu-id="2b371-245">Projekt infrastruktury obvykle zahrnuje implementace dat přístup.</span><span class="sxs-lookup"><span data-stu-id="2b371-245">The Infrastructure project typically includes data access implementations.</span></span> <span data-ttu-id="2b371-246">V typické webové aplikace ASP.NET Core, patří tyto implementace Entity Framework (EF) uvolněn objekt DbContext, všechny EF Core `Migration` objekty, které byly definovány a přístupu k datům třídy implementace.</span><span class="sxs-lookup"><span data-stu-id="2b371-246">In a typical ASP.NET Core web application, these implementations include the Entity Framework (EF) DbContext, any EF Core `Migration` objects that have been defined, and data access implementation classes.</span></span> <span data-ttu-id="2b371-247">Nejběžnější způsob abstraktní kód implementace přístupu k datům je prostřednictvím [vzor návrhu úložiště](https://deviq.com/repository-pattern/).</span><span class="sxs-lookup"><span data-stu-id="2b371-247">The most common way to abstract data access implementation code is through the use of the [Repository design pattern](https://deviq.com/repository-pattern/).</span></span>

<span data-ttu-id="2b371-248">Kromě dat přístup implementace infrastruktury projektu by měl obsahovat implementace služby, které musí spolupracovat s starostí o infrastrukturu.</span><span class="sxs-lookup"><span data-stu-id="2b371-248">In addition to data access implementations, the Infrastructure project should contain implementations of services that must interact with infrastructure concerns.</span></span> <span data-ttu-id="2b371-249">Tyto služby by měly implementovat rozhraní definované v samotném aplikace a proto infrastruktury by měly mít odkaz na projekt aplikace Core.</span><span class="sxs-lookup"><span data-stu-id="2b371-249">These services should implement interfaces defined in the Application Core, and so Infrastructure should have a reference to the Application Core project.</span></span>

### <a name="infrastructure-types"></a><span data-ttu-id="2b371-250">Typy infrastruktury</span><span class="sxs-lookup"><span data-stu-id="2b371-250">Infrastructure types</span></span>

- <span data-ttu-id="2b371-251">EF Core typy (`DbContext`, `Migration`)</span><span class="sxs-lookup"><span data-stu-id="2b371-251">EF Core types (`DbContext`, `Migration`)</span></span>
- <span data-ttu-id="2b371-252">Datové typy implementace (úložiště)</span><span class="sxs-lookup"><span data-stu-id="2b371-252">Data access implementation types (Repositories)</span></span>
- <span data-ttu-id="2b371-253">Specifické pro infrastrukturu služby (například `FileLogger` nebo `SmtpNotifier`)</span><span class="sxs-lookup"><span data-stu-id="2b371-253">Infrastructure-specific services (for example, `FileLogger` or `SmtpNotifier`)</span></span>

<span data-ttu-id="2b371-254">Vrstva uživatelské rozhraní v aplikaci ASP.NET Core MVC je vstupním bodem pro aplikaci.</span><span class="sxs-lookup"><span data-stu-id="2b371-254">The user interface layer in an ASP.NET Core MVC application is the entry point for the application.</span></span> <span data-ttu-id="2b371-255">Tento projekt by měl odkazovat na projekt, jádro aplikace a jeho typy by měly interakci s infrastrukturu výhradně prostřednictvím rozhraní definované v jádro aplikace.</span><span class="sxs-lookup"><span data-stu-id="2b371-255">This project should reference the Application Core project, and its types should interact with infrastructure strictly through interfaces defined in Application Core.</span></span> <span data-ttu-id="2b371-256">Žádné přímé vytvoření instance nebo statické volání typy vrstev infrastruktury by měl povolené ve vrstvě uživatelského rozhraní.</span><span class="sxs-lookup"><span data-stu-id="2b371-256">No direct instantiation of or static calls to the Infrastructure layer types should be allowed in the UI layer.</span></span>

### <a name="ui-layer-types"></a><span data-ttu-id="2b371-257">Typy vrstvy uživatelského rozhraní</span><span class="sxs-lookup"><span data-stu-id="2b371-257">UI layer types</span></span>

- <span data-ttu-id="2b371-258">Kontrolery</span><span class="sxs-lookup"><span data-stu-id="2b371-258">Controllers</span></span>
- <span data-ttu-id="2b371-259">Filtry</span><span class="sxs-lookup"><span data-stu-id="2b371-259">Filters</span></span>
- <span data-ttu-id="2b371-260">Zobrazení</span><span class="sxs-lookup"><span data-stu-id="2b371-260">Views</span></span>
- <span data-ttu-id="2b371-261">Modely ViewModels</span><span class="sxs-lookup"><span data-stu-id="2b371-261">ViewModels</span></span>
- <span data-ttu-id="2b371-262">Po spuštění</span><span class="sxs-lookup"><span data-stu-id="2b371-262">Startup</span></span>

<span data-ttu-id="2b371-263">Třída při spuštění je zodpovědný pro konfiguraci aplikace a pro její implementaci typů rozhraní, což injektáž závislostí do za běhu správně fungovat.</span><span class="sxs-lookup"><span data-stu-id="2b371-263">The Startup class is responsible for configuring the application, and for wiring up implementation types to interfaces, allowing dependency injection to work properly at run time.</span></span>

> [!NOTE]
> <span data-ttu-id="2b371-264">Aby bylo možné nastavit injektáž závislostí v ConfigureServices v souboru Startup.cs projekt uživatelského rozhraní, možná muset projektu odkazovat na projekt infrastruktury.</span><span class="sxs-lookup"><span data-stu-id="2b371-264">In order to wire up dependency injection in ConfigureServices in the Startup.cs file of the UI project, the project may need to reference the Infrastructure project.</span></span> <span data-ttu-id="2b371-265">Tato závislost jde je eliminovat nejsnadněji použít vlastní kontejner DI.</span><span class="sxs-lookup"><span data-stu-id="2b371-265">This dependency can be eliminated, most easily by using a custom DI container.</span></span> <span data-ttu-id="2b371-266">Pro účely tohoto příkladu je nejjednodušším přístupem umožnit projekt uživatelského rozhraní tak, aby se odkazovat na projekt infrastruktury.</span><span class="sxs-lookup"><span data-stu-id="2b371-266">For the purposes of this sample, the simplest approach is to allow the UI project to reference the Infrastructure project.</span></span>

## <a name="monolithic-applications-and-containers"></a><span data-ttu-id="2b371-267">Monolitické aplikace a kontejnery</span><span class="sxs-lookup"><span data-stu-id="2b371-267">Monolithic applications and containers</span></span>

<span data-ttu-id="2b371-268">Můžete vytvořit jeden a monolitické nasazení na základě webové aplikace nebo služby a nasadit ho jako kontejner.</span><span class="sxs-lookup"><span data-stu-id="2b371-268">You can build a single and monolithic-deployment based Web Application or Service and deploy it as a container.</span></span> <span data-ttu-id="2b371-269">V rámci aplikace nemusí být monolitické ale uspořádaných do několika knihoven, komponenty nebo vrstvy.</span><span class="sxs-lookup"><span data-stu-id="2b371-269">Within the application, it might not be monolithic but organized into several libraries, components, or layers.</span></span> <span data-ttu-id="2b371-270">Externě je jedním kontejnerem jako jeden proces, jednu webovou aplikaci nebo jedinou službou.</span><span class="sxs-lookup"><span data-stu-id="2b371-270">Externally, it's a single container like a single process, single web application, or single service.</span></span>

<span data-ttu-id="2b371-271">Správa tohoto modelu, nasadíte jedním kontejnerem pro reprezentaci aplikace.</span><span class="sxs-lookup"><span data-stu-id="2b371-271">To manage this model, you deploy a single container to represent the application.</span></span> <span data-ttu-id="2b371-272">Pokud chcete škálovat, stačí přidáte další kopie se nástroj pro vyrovnávání zatížení v popředí.</span><span class="sxs-lookup"><span data-stu-id="2b371-272">To scale, just add additional copies with a load balancer in front.</span></span> <span data-ttu-id="2b371-273">Jednoduchost pochází z jednoho nasazení ve virtuální počítač s jedním kontejnerem nebo Správa.</span><span class="sxs-lookup"><span data-stu-id="2b371-273">The simplicity comes from managing a single deployment in a single container or VM.</span></span>

![](./media/image5-13.png)

<span data-ttu-id="2b371-274">Jak je znázorněno v obrázek 5-13 může obsahovat více komponent a knihovny nebo interní vrstvy v rámci každého kontejneru.</span><span class="sxs-lookup"><span data-stu-id="2b371-274">You can include multiple components/libraries or internal layers within each container, as illustrated in Figure 5-13.</span></span> <span data-ttu-id="2b371-275">Ale po Princip kontejneru _"kontejner provede jednu věc a dělá v jednom procesu_", monolitické vzorek může dojít ke konfliktu.</span><span class="sxs-lookup"><span data-stu-id="2b371-275">But, following the container principle of _"a container does one thing, and does it in one process_", the monolithic pattern might be a conflict.</span></span>

<span data-ttu-id="2b371-276">Nevýhodou tento přístup se dodává pokud/když aplikace poroste, požadují škálování.</span><span class="sxs-lookup"><span data-stu-id="2b371-276">The downside of this approach comes if/when the application grows, requiring it to scale.</span></span> <span data-ttu-id="2b371-277">Pokud bude celá aplikace se škáluje, není ve skutečnosti k problému.</span><span class="sxs-lookup"><span data-stu-id="2b371-277">If the entire application scales, it's not really a problem.</span></span> <span data-ttu-id="2b371-278">Ve většině případů však několik částí aplikace jsou body potlačení nutnosti škálování, zatímco ostatní součásti jsou používá menší.</span><span class="sxs-lookup"><span data-stu-id="2b371-278">However, in most cases, a few parts of the application are the choke points requiring scaling, while other components are used less.</span></span>

<span data-ttu-id="2b371-279">Použijeme příklad typické elektronického obchodování, co budete pravděpodobně muset škálovat je součást informace o produktu.</span><span class="sxs-lookup"><span data-stu-id="2b371-279">Using the typical eCommerce example, what you likely need to scale is the product information component.</span></span> <span data-ttu-id="2b371-280">Mnoho zákazníků další procházet produktů, než je koupit.</span><span class="sxs-lookup"><span data-stu-id="2b371-280">Many more customers browse products than purchase them.</span></span> <span data-ttu-id="2b371-281">Větší počet zákazníků pomocí nákupního košíku, než použití kanálu platby.</span><span class="sxs-lookup"><span data-stu-id="2b371-281">More customers use their basket than use the payment pipeline.</span></span> <span data-ttu-id="2b371-282">Méně zákazníky přidat komentáře nebo zobrazení jejich historie nákupů.</span><span class="sxs-lookup"><span data-stu-id="2b371-282">Fewer customers add comments or view their purchase history.</span></span> <span data-ttu-id="2b371-283">A pravděpodobně máte pouze několik zaměstnanců, v jedné oblasti, které potřebují spravovat obsah a marketingových kampaní.</span><span class="sxs-lookup"><span data-stu-id="2b371-283">And you likely only have a handful of employees, in a single region, that need to manage the content and marketing campaigns.</span></span> <span data-ttu-id="2b371-284">Díky škálování monolitický návrh, všechny se kód nasazuje více než jednou.</span><span class="sxs-lookup"><span data-stu-id="2b371-284">By scaling the monolithic design, all the code is deployed multiple times.</span></span>

<span data-ttu-id="2b371-285">Kromě problém "škálovat vše" vyžadovat změny jedné komponenty kompletní opakované celé aplikace a dokončení opětovné nasazení všech instancí.</span><span class="sxs-lookup"><span data-stu-id="2b371-285">In addition to the "scale everything" problem, changes to a single component require complete retesting of the entire application, and a complete redeployment of all the instances.</span></span>

<span data-ttu-id="2b371-286">Monolitického přístupu je běžné a mnoha organizacích jsou vývoj s využitím tento architektonický přístup umožňuje vytvářet.</span><span class="sxs-lookup"><span data-stu-id="2b371-286">The monolithic approach is common, and many organizations are developing with this architectural approach.</span></span> <span data-ttu-id="2b371-287">Mnoho máte kvalitní dostatek výsledky, zatímco ostatní omezení výskytu.</span><span class="sxs-lookup"><span data-stu-id="2b371-287">Many are having good enough results, while others are hitting limits.</span></span> <span data-ttu-id="2b371-288">Mnoho navržené svých aplikací v tomto modelu, protože bylo příliš obtížné umožňuje vytvářet architektury orientované na služby (SOA) nástroje a infrastruktura a jejich nezobrazila potřeby, dokud zvětšoval aplikace.</span><span class="sxs-lookup"><span data-stu-id="2b371-288">Many designed their applications in this model, because the tools and infrastructure were too difficult to build service-oriented architectures (SOA), and they didn't see the need until the app grew.</span></span> <span data-ttu-id="2b371-289">Pokud zjistíte, že narazíte na omezení monolitického přístupu, může být dalším logickým krokem po rozdělení aplikace, který umožňuje lepší využití kontejnerů a mikroslužeb.</span><span class="sxs-lookup"><span data-stu-id="2b371-289">If you find you're hitting the limits of the monolithic approach, breaking up the app to enable it to better leverage containers and microservices may be the next logical step.</span></span>

![](./media/image5-14.png)

<span data-ttu-id="2b371-290">Nasazení monolitických aplikací v Microsoft Azure můžete dosáhnout pomocí vyhrazených virtuálních počítačů pro každou instanci.</span><span class="sxs-lookup"><span data-stu-id="2b371-290">Deploying monolithic applications in Microsoft Azure can be achieved using dedicated VMs for each instance.</span></span> <span data-ttu-id="2b371-291">Pomocí [Škálovací sady virtuálních počítačů Azure](https://docs.microsoft.com/azure/virtual-machine-scale-sets/), je možné snadno škálovat virtuální počítače.</span><span class="sxs-lookup"><span data-stu-id="2b371-291">Using [Azure Virtual Machine Scale Sets](https://docs.microsoft.com/azure/virtual-machine-scale-sets/), you can easily scale the VMs.</span></span> <span data-ttu-id="2b371-292">[Služba Azure App Services](https://azure.microsoft.com/services/app-service/) můžete spustit monolitické aplikace a snadno škálovat instance, aniž byste museli spravovat virtuální počítače.</span><span class="sxs-lookup"><span data-stu-id="2b371-292">[Azure App Services](https://azure.microsoft.com/services/app-service/) can run monolithic applications and easily scale instances without having to manage the VMs.</span></span> <span data-ttu-id="2b371-293">Azure App Services můžete spustit jeden instancí kontejnerů Dockeru, zjednodušuje nasazení.</span><span class="sxs-lookup"><span data-stu-id="2b371-293">Azure App Services can run single instances of Docker containers as well, simplifying the deployment.</span></span> <span data-ttu-id="2b371-294">Pomocí Dockeru, můžete nasadit jeden virtuální počítač jako hostitele Dockeru a spouštět více instancí.</span><span class="sxs-lookup"><span data-stu-id="2b371-294">Using Docker, you can deploy a single VM as a Docker host, and run multiple instances.</span></span> <span data-ttu-id="2b371-295">Pomocí nástroje pro vyrovnávání Azure, jak je znázorněno v obrázek 5-14, můžete spravovat škálování.</span><span class="sxs-lookup"><span data-stu-id="2b371-295">Using the Azure balancer, as shown in the Figure 5-14, you can manage scaling.</span></span>

<span data-ttu-id="2b371-296">Nasazení do různých hostitelů lze spravovat pomocí nasazení tradiční techniky.</span><span class="sxs-lookup"><span data-stu-id="2b371-296">The deployment to the various hosts can be managed with traditional deployment techniques.</span></span> <span data-ttu-id="2b371-297">Hostitele Docker můžete spravovat pomocí příkazů, jako jsou **dockeru spustit** provést ručně nebo pomocí automatizace, jako je průběžné doručování (CD) kanálů.</span><span class="sxs-lookup"><span data-stu-id="2b371-297">The Docker hosts can be managed with commands like **docker run** performed manually, or through automation such as Continuous Delivery (CD) pipelines.</span></span>

### <a name="monolithic-application-deployed-as-a-container"></a><span data-ttu-id="2b371-298">Monolitické aplikace nasazená jako kontejner</span><span class="sxs-lookup"><span data-stu-id="2b371-298">Monolithic application deployed as a container</span></span>

<span data-ttu-id="2b371-299">Existují výhody použití kontejnerů ke správě nasazení monolitických aplikací.</span><span class="sxs-lookup"><span data-stu-id="2b371-299">There are benefits of using containers to manage monolithic application deployments.</span></span> <span data-ttu-id="2b371-300">Škálování instance kontejnerů je mnohem jednodušší a rychlejší než nasazení dalších virtuálních počítačů.</span><span class="sxs-lookup"><span data-stu-id="2b371-300">Scaling the instances of containers is far faster and easier than deploying additional VMs.</span></span> <span data-ttu-id="2b371-301">I když použijete virtuálního počítače škálovací sady škálování virtuálních počítačů, jejich trvat dobu na instanci.</span><span class="sxs-lookup"><span data-stu-id="2b371-301">Even when using virtual machine scale sets to scale VMs, they take time to instance.</span></span> <span data-ttu-id="2b371-302">Po nasazení jako instance aplikace, je konfigurace aplikace spravovaná v rámci virtuálního počítače.</span><span class="sxs-lookup"><span data-stu-id="2b371-302">When deployed as app instances, the configuration of the app is managed as part of the VM.</span></span>

<span data-ttu-id="2b371-303">Nasazení aktualizací, je mnohem rychlejší imagí Dockeru a efektivní sítě.</span><span class="sxs-lookup"><span data-stu-id="2b371-303">Deploying updates as Docker images is far faster and network efficient.</span></span> <span data-ttu-id="2b371-304">Image dockeru se obvykle začít během několika sekund, a tím i urychlení uvedení.</span><span class="sxs-lookup"><span data-stu-id="2b371-304">Docker Images typically start in seconds, speeding rollouts.</span></span> <span data-ttu-id="2b371-305">Opětné do instance Docker je stejně jednoduché jako vydání `docker stop` příkaz obvykle dokončení v menší než druhý.</span><span class="sxs-lookup"><span data-stu-id="2b371-305">Tearing down a Docker instance is as easy as issuing a `docker stop` command, typically completing in less than a second.</span></span>

<span data-ttu-id="2b371-306">Kontejnery jsou ze své podstaty neměnné záměrné, je nikdy potřeba starat o poškozená virtuálních počítačů, zatímco zapomenout skripty pro aktualizaci. aby se zohlednily některé konkrétní konfiguraci nebo doleva souboru na disku.</span><span class="sxs-lookup"><span data-stu-id="2b371-306">As containers are inherently immutable by design, you never need to worry about corrupted VMs, whereas update scripts might forget to account for some specific configuration or file left on disk.</span></span>

<span data-ttu-id="2b371-307">_Kontejnery Dockeru můžete použít pro monolitické nasazení jednodušší webových aplikací. Tím se zlepšuje průběžnou integraci a průběžné nasazování kanálů a pomáhá dosahovat úspěšnosti nasazení do produkčního prostředí. Už to funguje"v počítači, proč to nebude fungovat v produkčním prostředí?"_</span><span class="sxs-lookup"><span data-stu-id="2b371-307">_You can use Docker containers for monolithic deployment of simpler web applications. This improves continuous integration and continuous deployment pipelines and helps achieve deployment-to-production success. No more “It works in my machine, why does it not work in production?”_</span></span>

<span data-ttu-id="2b371-308">Architektura založená na mikroslužbách má spoustu výhod, ale tyto výhody pocházet za cenu zvýšení složitosti.</span><span class="sxs-lookup"><span data-stu-id="2b371-308">A microservices-based architecture has many benefits, but those benefits come at a cost of increased complexity.</span></span> <span data-ttu-id="2b371-309">V některých případech se náklady převažují nad přínosy, je lepší volbou monolitické nasazení aplikace s jedním kontejnerem nebo v několika kontejnerů.</span><span class="sxs-lookup"><span data-stu-id="2b371-309">In some cases, the costs outweigh the benefits, a monolithic deployment application running in a single container or in just a few containers is a better option.</span></span>

<span data-ttu-id="2b371-310">Monolitické aplikace nemusí být snadno decomposable do jasně oddělené mikroslužeb.</span><span class="sxs-lookup"><span data-stu-id="2b371-310">A monolithic application might not be easily decomposable into well-separated microservices.</span></span> <span data-ttu-id="2b371-311">Mikroslužby by měla fungovat nezávisle na sobě zajistit odolnost aplikace.</span><span class="sxs-lookup"><span data-stu-id="2b371-311">Microservices should work independently of each other to provide a more resilient application.</span></span> <span data-ttu-id="2b371-312">Pokud nelze doručit řezy nezávislé funkce aplikace, oddělení pouze zvyšuje složitost.</span><span class="sxs-lookup"><span data-stu-id="2b371-312">If you can't deliver independent feature slices of the application, separating it only adds complexity.</span></span>

<span data-ttu-id="2b371-313">Aplikace nemusí potřebovat ještě nezávisle škálovat funkce.</span><span class="sxs-lookup"><span data-stu-id="2b371-313">An application might not yet need to scale features independently.</span></span> <span data-ttu-id="2b371-314">Mnoho aplikací, když potřebují škálovat na více než jednu instanci, můžete to udělat prostřednictvím poměrně jednoduchý proces klonování celý instance.</span><span class="sxs-lookup"><span data-stu-id="2b371-314">Many applications, when they need to scale beyond a single instance, can do so through the relatively simple process of cloning that entire instance.</span></span> <span data-ttu-id="2b371-315">Další práci pro oddělení aplikací do samostatných služeb poskytuje minimální výhodu při škálování úplná instance aplikace je jednoduché a nákladově efektivní.</span><span class="sxs-lookup"><span data-stu-id="2b371-315">The additional work to separate the application into discrete services provides minimal benefit when scaling full instances of the application is simple and cost-effective.</span></span>

<span data-ttu-id="2b371-316">Již v rané fázi při vývoji aplikace se nemusí mít jasno, kde jsou přirozené hranice funkční.</span><span class="sxs-lookup"><span data-stu-id="2b371-316">Early in the development of an application, you might not have a clear idea where the natural functional boundaries are.</span></span> <span data-ttu-id="2b371-317">Při vývoji minimální přijatelné produktu, nemusí mít ještě umístila fyzické oddělení.</span><span class="sxs-lookup"><span data-stu-id="2b371-317">As you develop a minimum viable product, the natural separation might not yet have emerged.</span></span> <span data-ttu-id="2b371-318">Některé z těchto podmínek může být dočasné.</span><span class="sxs-lookup"><span data-stu-id="2b371-318">Some of these conditions might be temporary.</span></span> <span data-ttu-id="2b371-319">Může být začněte vytvořením jednotlivou aplikaci a později oddělení několik funkcí, které vyvinul a nasadit jako mikroslužeb.</span><span class="sxs-lookup"><span data-stu-id="2b371-319">You might start by creating a monolithic application, and later separate some features to be developed and deployed as microservices.</span></span> <span data-ttu-id="2b371-320">Další podmínky může být nezbytné pro aplikace problém místa, což znamená, že aplikace může být nikdy rozdělená do několika mikroslužeb.</span><span class="sxs-lookup"><span data-stu-id="2b371-320">Other conditions might be essential to the application’s problem space, meaning that the application might never be broken into multiple microservices.</span></span>

<span data-ttu-id="2b371-321">Oddělení aplikace do mnoha samostatné procesy také zavádí režijní náklady.</span><span class="sxs-lookup"><span data-stu-id="2b371-321">Separating an application into many discrete processes also introduces overhead.</span></span> <span data-ttu-id="2b371-322">Rozdělení funkcí do různých procesů je složitější.</span><span class="sxs-lookup"><span data-stu-id="2b371-322">There's more complexity in separating features into different processes.</span></span> <span data-ttu-id="2b371-323">Komunikační protokoly budou složitější.</span><span class="sxs-lookup"><span data-stu-id="2b371-323">The communication protocols become more complex.</span></span> <span data-ttu-id="2b371-324">Namísto volání metody je nutné použít asynchronní komunikace mezi službami.</span><span class="sxs-lookup"><span data-stu-id="2b371-324">Instead of method calls, you must use asynchronous communications between services.</span></span> <span data-ttu-id="2b371-325">Při přesunu na architekturu mikroslužeb, budete muset přidat řadu stavební bloky implementované v mikroslužbách verze aplikace aplikaci eShopOnContainers: zpracování událostí Service bus, zprávy odolnost proti chybám a opakovaných pokusů, konečnou konzistenci a další.</span><span class="sxs-lookup"><span data-stu-id="2b371-325">As you move to a microservices architecture, you need to add many of the building blocks implemented in the microservices version of the eShopOnContainers application: event bus handling, message resiliency and retries, eventual consistency, and more.</span></span>

<span data-ttu-id="2b371-326">Mnohem jednodušší [eShopOnWeb referenční aplikace](https://github.com/dotnet-architecture/eShopOnWeb) podporuje použití monolitického kontejneru jeden kontejner.</span><span class="sxs-lookup"><span data-stu-id="2b371-326">The much simpler [eShopOnWeb reference application](https://github.com/dotnet-architecture/eShopOnWeb) supports single-container monolithic container usage.</span></span> <span data-ttu-id="2b371-327">Aplikace obsahuje dvě webové aplikace: jednu pomocí tradiční MVC a další pomocí stránky Razor.</span><span class="sxs-lookup"><span data-stu-id="2b371-327">The application includes two web applications: one using traditional MVC and another using Razor Pages.</span></span> <span data-ttu-id="2b371-328">Obojí se dají spustit pomocí kořenového řešení `docker-compose build` a `docker-compose up` příkazy.</span><span class="sxs-lookup"><span data-stu-id="2b371-328">Both can be launched from the solution root using the `docker-compose build` and `docker-compose up` commands.</span></span> <span data-ttu-id="2b371-329">Tento příkaz nakonfiguruje samostatný kontejnery pro každé webové instance, pomocí `Dockerfile` najít v kořenovém adresáři každé webový projekt a spustí každý kontejner v samostatných portů.</span><span class="sxs-lookup"><span data-stu-id="2b371-329">This command configures separate containers for each web instance, using the `Dockerfile` found in each web project's root, and runs each container on a separate port.</span></span> <span data-ttu-id="2b371-330">Můžete zdroj pro tuto aplikaci stáhnout z webu GitHub a spustit ho místně.</span><span class="sxs-lookup"><span data-stu-id="2b371-330">You can download the source for this application from GitHub and run it locally.</span></span> <span data-ttu-id="2b371-331">Tato monolitické aplikace využívá výhod nasazení v prostředí kontejneru.</span><span class="sxs-lookup"><span data-stu-id="2b371-331">Even this monolithic application benefits from being deployed in a container environment.</span></span>

<span data-ttu-id="2b371-332">Za prvé nasazení kontejnerizované znamená, že každá instance aplikace běží ve stejném prostředí.</span><span class="sxs-lookup"><span data-stu-id="2b371-332">For one, the containerized deployment means that every instance of the application runs in the same environment.</span></span> <span data-ttu-id="2b371-333">Jedná se o prostředí pro vývojáře, kde vývoj a testování již v rané fázi probíhat.</span><span class="sxs-lookup"><span data-stu-id="2b371-333">This includes the developer environment where early testing and development take place.</span></span> <span data-ttu-id="2b371-334">Vývojový tým můžete spustit aplikaci v kontejnerizovaných prostředí, která odpovídá produkčního prostředí.</span><span class="sxs-lookup"><span data-stu-id="2b371-334">The development team can run the application in a containerized environment that matches the production environment.</span></span>

<span data-ttu-id="2b371-335">Kromě toho kontejnerizovaných aplikací pro horizontální navýšení kapacity za nižší cenu.</span><span class="sxs-lookup"><span data-stu-id="2b371-335">In addition, containerized applications scale out at lower cost.</span></span> <span data-ttu-id="2b371-336">Použití prostředí kontejnerů umožňuje větší prostředků sdílení než tradiční prostředí virtuálních počítačů.</span><span class="sxs-lookup"><span data-stu-id="2b371-336">Using a container environment enables greater resource sharing than traditional VM environments.</span></span>

<span data-ttu-id="2b371-337">Nakonec se uzavření aplikace do kontejneru vynutí oddělení mezi obchodní logiku a storage server.</span><span class="sxs-lookup"><span data-stu-id="2b371-337">Finally, containerizing the application forces a separation between the business logic and the storage server.</span></span> <span data-ttu-id="2b371-338">Jak škálovat aplikaci se několik kontejnerů spoléhat na střední jednoho fyzického úložiště.</span><span class="sxs-lookup"><span data-stu-id="2b371-338">As the application scales out, the multiple containers will all rely on a single physical storage medium.</span></span> <span data-ttu-id="2b371-339">Toto médium úložiště by obvykle vysokou dostupnost serveru databáze SQL serveru.</span><span class="sxs-lookup"><span data-stu-id="2b371-339">This storage medium would typically be a high-availability server running a SQL Server database.</span></span>

## <a name="docker-support"></a><span data-ttu-id="2b371-340">Podpora dockeru</span><span class="sxs-lookup"><span data-stu-id="2b371-340">Docker support</span></span>

<span data-ttu-id="2b371-341">`eShopOnWeb` Projekt poběží v .NET Core.</span><span class="sxs-lookup"><span data-stu-id="2b371-341">The `eShopOnWeb` project runs on .NET Core.</span></span> <span data-ttu-id="2b371-342">Proto můžete spustit v kontejnerech založených na Linuxu nebo založené na Windows.</span><span class="sxs-lookup"><span data-stu-id="2b371-342">Therefore, it can run in either Linux-based or Windows-based containers.</span></span> <span data-ttu-id="2b371-343">Všimněte si, že pro nasazení prostředí Docker, chcete použít stejný typ hostitele pro SQL Server.</span><span class="sxs-lookup"><span data-stu-id="2b371-343">Note that for Docker deployment, you want to use the same host type for SQL Server.</span></span> <span data-ttu-id="2b371-344">Kontejnery založené na Linuxu povolit menší nároky na místo a jsou upřednostňované.</span><span class="sxs-lookup"><span data-stu-id="2b371-344">Linux-based containers allow a smaller footprint and are preferred.</span></span>

<span data-ttu-id="2b371-345">Visual Studio 2017 můžete použít k přidání podpory Dockeru k existující aplikaci kliknutím pravým tlačítkem myši na projekt v **Průzkumníka řešení** a zvolíte **přidat** > **podporu Dockeru** .</span><span class="sxs-lookup"><span data-stu-id="2b371-345">You can use Visual Studio 2017 to add Docker support to an existing application by right-clicking on a project in **Solution Explorer** and choosing **Add** > **Docker Support**.</span></span> <span data-ttu-id="2b371-346">To přidá potřebné soubory a změní projekt, k jejich použití.</span><span class="sxs-lookup"><span data-stu-id="2b371-346">This adds the files required and modifies the project to use them.</span></span> <span data-ttu-id="2b371-347">Aktuální `eShopOnWeb` ukázka již má tyto soubory na místě.</span><span class="sxs-lookup"><span data-stu-id="2b371-347">The current `eShopOnWeb` sample already has these files in place.</span></span>

<span data-ttu-id="2b371-348">Úroveň řešení `docker-compose.yml` soubor obsahuje informace o co k sestavení Image a jaké kontejnery ke spuštění.</span><span class="sxs-lookup"><span data-stu-id="2b371-348">The solution-level `docker-compose.yml` file contains information about what images to build and what containers to launch.</span></span> <span data-ttu-id="2b371-349">Soubor umožňuje používat `docker-compose` příkaz spustit obě verze webové aplikace ve stejnou dobu.</span><span class="sxs-lookup"><span data-stu-id="2b371-349">The file allows you to use the `docker-compose` command to launch both versions of the web application at the same time.</span></span> <span data-ttu-id="2b371-350">Také ho můžete použít ke konfiguraci závislostí, jako je například kontejner samostatné databáze.</span><span class="sxs-lookup"><span data-stu-id="2b371-350">You can also use it to configure dependencies, such as a separate database container.</span></span>

```yml
version: '3'

services:
  eshopwebrazor:
    image: eshopwebrazor
    build:
      context: .
      dockerfile: src/WebRazorPages/Dockerfile
    environment:
      - ASPNETCORE_ENVIRONMENT=Development
    ports:
      - "5107:5107"

  eshopwebmvc:
    image: eshopwebmvc
    build:
      context: .
      dockerfile: src/Web/Dockerfile
    environment:
      - ASPNETCORE_ENVIRONMENT=Development
    ports:
      - "5106:5106"

networks:
  default:
    external:
      name: nat
```

<span data-ttu-id="2b371-351">`docker-compose.yml` Souboru odkazy `Dockerfile` v `Web` a `WebRazorPages` projekty.</span><span class="sxs-lookup"><span data-stu-id="2b371-351">The `docker-compose.yml` file references the `Dockerfile` in the `Web` and `WebRazorPages` projects.</span></span> <span data-ttu-id="2b371-352">`Dockerfile` Slouží k určení, které základní kontejneru se použije a konfiguraci aplikace na ní.</span><span class="sxs-lookup"><span data-stu-id="2b371-352">The `Dockerfile` is used to specify which base container will be used and how the application will be configured on it.</span></span> <span data-ttu-id="2b371-353">`WebRazorPages`" `Dockerfile`:</span><span class="sxs-lookup"><span data-stu-id="2b371-353">The `WebRazorPages`' `Dockerfile`:</span></span>

```
FROM microsoft/dotnet:2.1-aspnetcore-runtime AS base
WORKDIR /app
EXPOSE 80

FROM microsoft/aspnetcore-build:2.1.300-preview1 AS build
RUN npm install -g bower@1.8.4
WORKDIR /src
COPY . .
WORKDIR /src/src/WebRazorPages
RUN dotnet restore -nowarn:msb3202,nu1503
RUN dotnet build --no-restore -c Release -o /app

FROM build AS publish
RUN dotnet publish --no-restore -c Release -o /app

FROM base AS final
WORKDIR /app
COPY --from=publish /app .
ENTRYPOINT ["dotnet", "Microsoft.eShopWeb.RazorPages.dll"]
```

### <a name="troubleshooting-docker-problems"></a><span data-ttu-id="2b371-354">Řešení potíží s Dockerem</span><span class="sxs-lookup"><span data-stu-id="2b371-354">Troubleshooting Docker problems</span></span>

<span data-ttu-id="2b371-355">Po spuštění kontejnerizované aplikace pokračuje v běhu až po ukončení.</span><span class="sxs-lookup"><span data-stu-id="2b371-355">Once you run the containerized application, it continues to run until you stop it.</span></span> <span data-ttu-id="2b371-356">Můžete zobrazit, které kontejnery běží s `docker ps` příkazu.</span><span class="sxs-lookup"><span data-stu-id="2b371-356">You can view which containers are running with the `docker ps` command.</span></span> <span data-ttu-id="2b371-357">Spuštěný kontejner můžete zastavit pomocí `docker stop` příkazu a zadáte ID kontejneru.</span><span class="sxs-lookup"><span data-stu-id="2b371-357">You can stop a running container by using the `docker stop` command and specifying the container ID.</span></span>

<span data-ttu-id="2b371-358">Všimněte si, že spuštěné kontejnery Docker může být vázaný na porty, které může být jinak pokusu o použití ve vašem vývojovém prostředí.</span><span class="sxs-lookup"><span data-stu-id="2b371-358">Note that running Docker containers may be bound to ports you might otherwise try to use in your development environment.</span></span> <span data-ttu-id="2b371-359">Pokud se pokusíte spustit nebo ladit aplikaci používající stejný port jako spuštěný kontejner Dockeru, získáte chybu s informacemi o tom, že server nejde vytvořit vazbu k tomuto portu.</span><span class="sxs-lookup"><span data-stu-id="2b371-359">If you try to run or debug an application using the same port as a running Docker container, you'll get an error stating that the server can't bind to that port.</span></span> <span data-ttu-id="2b371-360">Zastavování kontejneru znovu, by měla vyřešit problém.</span><span class="sxs-lookup"><span data-stu-id="2b371-360">Once again, stopping the container should resolve the issue.</span></span>

<span data-ttu-id="2b371-361">Pokud chcete přidat podporu Dockeru do vaší aplikace pomocí sady Visual Studio, ujistěte se, jestli že je spuštěný Docker, pokud tak učiníte.</span><span class="sxs-lookup"><span data-stu-id="2b371-361">If you want to add Docker support to your application using Visual Studio, make sure Docker is running when you do so.</span></span> <span data-ttu-id="2b371-362">Průvodce nespustí správně, pokud Docker není spuštěn, když spustíte průvodce.</span><span class="sxs-lookup"><span data-stu-id="2b371-362">The wizard won't run correctly if Docker isn't running when you start the wizard.</span></span> <span data-ttu-id="2b371-363">Kromě toho Průvodce zkontroluje zvoleného aktuálního kontejneru pro přidání správné podpory Dockeru.</span><span class="sxs-lookup"><span data-stu-id="2b371-363">In addition, the wizard examines your current container choice to add the correct Docker support.</span></span> <span data-ttu-id="2b371-364">Pokud chcete přidat podporu pro kontejnery Windows, musíte spustit průvodce, dokud máte Docker s kontejnery Windows nakonfigurovaný.</span><span class="sxs-lookup"><span data-stu-id="2b371-364">If you want to add support for Windows Containers, you need to run the wizard while you have Docker running with Windows Containers configured.</span></span> <span data-ttu-id="2b371-365">Pokud chcete přidat podporu pro Linuxové kontejnery, spusťte Průvodce mají Dockeru s kontejnery Linuxu, které jsou nakonfigurované.</span><span class="sxs-lookup"><span data-stu-id="2b371-365">If you want to add support for Linux containers, run the wizard while you have Docker running with Linux containers configured.</span></span>

> ### <a name="references--common-web-architectures"></a><span data-ttu-id="2b371-366">Odkazy – běžné architektury webových</span><span class="sxs-lookup"><span data-stu-id="2b371-366">References – Common web architectures</span></span>
>
> - <span data-ttu-id="2b371-367">**Vyčištění architektury**</span><span class="sxs-lookup"><span data-stu-id="2b371-367">**The Clean Architecture**</span></span>  
>   <https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html>
> - <span data-ttu-id="2b371-368">**Architektura průsvitek**</span><span class="sxs-lookup"><span data-stu-id="2b371-368">**The Onion Architecture**</span></span>  
>   <http://jeffreypalermo.com/blog/the-onion-architecture-part-1/>
> - <span data-ttu-id="2b371-369">**Model úložiště**</span><span class="sxs-lookup"><span data-stu-id="2b371-369">**The Repository Pattern**</span></span>  
>   <https://deviq.com/repository-pattern/>
> - <span data-ttu-id="2b371-370">**Vyčistit ukázkové architektury řešení**</span><span class="sxs-lookup"><span data-stu-id="2b371-370">**Clean Architecture Solution Sample**</span></span>  
>   <https://github.com/ardalis/cleanarchitecture>
> - <span data-ttu-id="2b371-371">**Aplikační architektura založená na Mikroslužbách elektronickou knihu**</span><span class="sxs-lookup"><span data-stu-id="2b371-371">**Architecting Microservices e-book**</span></span>  
>   <https://aka.ms/MicroservicesEbook>

>[!div class="step-by-step"]
<span data-ttu-id="2b371-372">[Předchozí](architectural-principles.md)
[další](common-client-side-web-technologies.md)</span><span class="sxs-lookup"><span data-stu-id="2b371-372">[Previous](architectural-principles.md)
[Next](common-client-side-web-technologies.md)</span></span>
