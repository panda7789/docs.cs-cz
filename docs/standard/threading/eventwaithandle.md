---
title: EventWaitHandle
ms.date: 03/30/2017
ms.technology: dotnet-standard
helpviewer_keywords:
- threading [.NET Framework], EventWaitHandle class
- EventWaitHandle class
- event wait handles [.NET Framework]
- threading [.NET Framework], cross-process synchronization
ms.assetid: 11ee0b38-d663-4617-b793-35eb6c64e9fc
ms.openlocfilehash: 80c90254978495a58d228c4302eda84d6165c800
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 03/15/2020
ms.locfileid: "73138079"
---
# <a name="eventwaithandle"></a><span data-ttu-id="e4b9d-102">EventWaitHandle</span><span class="sxs-lookup"><span data-stu-id="e4b9d-102">EventWaitHandle</span></span>
<span data-ttu-id="e4b9d-103">Třída <xref:System.Threading.EventWaitHandle> umožňuje vláknům vzájemnou komunikaci signalizací a čekáním na signály.</span><span class="sxs-lookup"><span data-stu-id="e4b9d-103">The <xref:System.Threading.EventWaitHandle> class allows threads to communicate with each other by signaling and by waiting for signals.</span></span> <span data-ttu-id="e4b9d-104">Popisovače čekání událostí (označované také jednoduše jako události) jsou popisovače čekání, které mohou být signalizovány, aby se uvolnilo jedno nebo více čekajících vláken.</span><span class="sxs-lookup"><span data-stu-id="e4b9d-104">Event wait handles (also referred to simply as events) are wait handles that can be signaled in order to release one or more waiting threads.</span></span> <span data-ttu-id="e4b9d-105">Po signalizaci je popisovač čekání události resetován ručně nebo automaticky.</span><span class="sxs-lookup"><span data-stu-id="e4b9d-105">After it is signaled, an event wait handle is reset either manually or automatically.</span></span> <span data-ttu-id="e4b9d-106">Třída <xref:System.Threading.EventWaitHandle> může představovat buď místní popisovač čekání události (místní událost) nebo pojmenovaný popisovač čekání systémové události (pojmenovaná událost nebo systémová událost, viditelná pro všechny procesy).</span><span class="sxs-lookup"><span data-stu-id="e4b9d-106">The <xref:System.Threading.EventWaitHandle> class can represent either a local event wait handle (local event) or a named system event wait handle (named event or system event, visible to all processes).</span></span>  
  
> [!NOTE]
> <span data-ttu-id="e4b9d-107">Popisovače čekání událostí nejsou [události](../events/index.md).NET .</span><span class="sxs-lookup"><span data-stu-id="e4b9d-107">Event wait handles are not .NET [events](../events/index.md).</span></span> <span data-ttu-id="e4b9d-108">Nejsou zapojeni žádní delegáti nebo obslužné rutiny událostí.</span><span class="sxs-lookup"><span data-stu-id="e4b9d-108">There are no delegates or event handlers involved.</span></span> <span data-ttu-id="e4b9d-109">Slovo "událost" se používá k jejich popisu, protože byly tradičně označovány jako události operačního systému a protože akt signalizace popisovač čekání označuje čekající vlákna, ke kterým došlo k události.</span><span class="sxs-lookup"><span data-stu-id="e4b9d-109">The word "event" is used to describe them because they have traditionally been referred to as operating-system events, and because the act of signaling the wait handle indicates to waiting threads that an event has occurred.</span></span>  
  
 <span data-ttu-id="e4b9d-110">Popisovače čekání místní i pojmenované události používají objekty <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> synchronizace systému, které jsou chráněny obálkami, aby bylo zajištěno, že prostředky jsou uvolněny.</span><span class="sxs-lookup"><span data-stu-id="e4b9d-110">Both local and named event wait handles use system synchronization objects, which are protected by <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> wrappers to ensure that the resources are released.</span></span> <span data-ttu-id="e4b9d-111">Tuto metodu <xref:System.Threading.WaitHandle.Dispose%2A> můžete použít k okamžitému uvolnění prostředků po dokončení použití objektu.</span><span class="sxs-lookup"><span data-stu-id="e4b9d-111">You can use the <xref:System.Threading.WaitHandle.Dispose%2A> method to free the resources immediately when you have finished using the object.</span></span>  
  
## <a name="event-wait-handles-that-reset-automatically"></a><span data-ttu-id="e4b9d-112">Popisovače čekání událostí, které se automaticky resetují</span><span class="sxs-lookup"><span data-stu-id="e4b9d-112">Event Wait Handles That Reset Automatically</span></span>  
 <span data-ttu-id="e4b9d-113">Událost automatického obnovení vytvoříte <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> zadáním <xref:System.Threading.EventWaitHandle> při vytváření objektu.</span><span class="sxs-lookup"><span data-stu-id="e4b9d-113">You create an automatic reset event by specifying <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> when you create the <xref:System.Threading.EventWaitHandle> object.</span></span> <span data-ttu-id="e4b9d-114">Jak již název napovídá, tato událost synchronizace se automaticky resetuje, když je signalizována, po uvolnění jednoho čekajícího vlákna.</span><span class="sxs-lookup"><span data-stu-id="e4b9d-114">As its name implies, this synchronization event resets automatically when signaled, after releasing a single waiting thread.</span></span> <span data-ttu-id="e4b9d-115">Signalizační událost voláním její <xref:System.Threading.EventWaitHandle.Set%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="e4b9d-115">Signal the event by calling its <xref:System.Threading.EventWaitHandle.Set%2A> method.</span></span>  
  
 <span data-ttu-id="e4b9d-116">Automatické obnovení události se obvykle používají k poskytování výhradní přístup k prostředku pro jedno vlákno najednou.</span><span class="sxs-lookup"><span data-stu-id="e4b9d-116">Automatic reset events are usually used to provide exclusive access to a resource for a single thread at a time.</span></span> <span data-ttu-id="e4b9d-117">Podproces požaduje prostředek voláním <xref:System.Threading.WaitHandle.WaitOne%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="e4b9d-117">A thread requests the resource by calling the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span> <span data-ttu-id="e4b9d-118">Pokud žádné jiné vlákno drží popisovač `true` čekání, metoda vrátí a volající vlákno má kontrolu nad prostředek.</span><span class="sxs-lookup"><span data-stu-id="e4b9d-118">If no other thread is holding the wait handle, the method returns `true` and the calling thread has control of the resource.</span></span>  
  
> [!IMPORTANT]
> <span data-ttu-id="e4b9d-119">Stejně jako u všech synchronizačních mechanismů, musíte zajistit, že všechny cesty kódu čekat na příslušné čekání popisovač před přístupem k chráněnému prostředku.</span><span class="sxs-lookup"><span data-stu-id="e4b9d-119">As with all synchronization mechanisms, you must ensure that all code paths wait on the appropriate wait handle before accessing a protected resource.</span></span> <span data-ttu-id="e4b9d-120">Synchronizace vláken je kooperativní.</span><span class="sxs-lookup"><span data-stu-id="e4b9d-120">Thread synchronization is cooperative.</span></span>  
  
 <span data-ttu-id="e4b9d-121">Pokud je událost automatického resetování signalizována, když nečekají žádná vlákna, zůstane signalizována, dokud se na ni vlákno nepokusí čekat.</span><span class="sxs-lookup"><span data-stu-id="e4b9d-121">If an automatic reset event is signaled when no threads are waiting, it remains signaled until a thread attempts to wait on it.</span></span> <span data-ttu-id="e4b9d-122">Událost uvolní vlákno a okamžitě se resetuje a blokuje následující vlákna.</span><span class="sxs-lookup"><span data-stu-id="e4b9d-122">The event releases the thread and immediately resets, blocking subsequent threads.</span></span>  
  
## <a name="event-wait-handles-that-reset-manually"></a><span data-ttu-id="e4b9d-123">Popisovače čekání událostí, které se resetují ručně</span><span class="sxs-lookup"><span data-stu-id="e4b9d-123">Event Wait Handles That Reset Manually</span></span>  
 <span data-ttu-id="e4b9d-124">Událost ručního obnovení vytvoříte <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> zadáním <xref:System.Threading.EventWaitHandle> při vytváření objektu.</span><span class="sxs-lookup"><span data-stu-id="e4b9d-124">You create a manual reset event by specifying <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> when you create the <xref:System.Threading.EventWaitHandle> object.</span></span> <span data-ttu-id="e4b9d-125">Jak již název napovídá, tato událost synchronizace musí být resetována ručně poté, co byla signalizována.</span><span class="sxs-lookup"><span data-stu-id="e4b9d-125">As its name implies, this synchronization event must be reset manually after it has been signaled.</span></span> <span data-ttu-id="e4b9d-126">Dokud je resetován, <xref:System.Threading.EventWaitHandle.Reset%2A> voláním jeho metody, vlákna, která čekají na popisovač události pokračovat okamžitě bez blokování.</span><span class="sxs-lookup"><span data-stu-id="e4b9d-126">Until it is reset, by calling its <xref:System.Threading.EventWaitHandle.Reset%2A> method, threads that wait on the event handle proceed immediately without blocking.</span></span>  
  
 <span data-ttu-id="e4b9d-127">Událost ručního resetu se chová jako brána ohrady.</span><span class="sxs-lookup"><span data-stu-id="e4b9d-127">A manual reset event acts like the gate of a corral.</span></span> <span data-ttu-id="e4b9d-128">Když událost není signalizována, vlákna, která na ní čekají, blokují, jako koně v ohradě.</span><span class="sxs-lookup"><span data-stu-id="e4b9d-128">When the event is not signaled, threads that wait on it block, like horses in a corral.</span></span> <span data-ttu-id="e4b9d-129">Když je událost signalizována <xref:System.Threading.EventWaitHandle.Set%2A> voláním její metody, všechna čekající vlákna mohou pokračovat.</span><span class="sxs-lookup"><span data-stu-id="e4b9d-129">When the event is signaled, by calling its <xref:System.Threading.EventWaitHandle.Set%2A> method, all waiting threads are free to proceed.</span></span> <span data-ttu-id="e4b9d-130">Událost zůstává signalizována, dokud není volána její <xref:System.Threading.EventWaitHandle.Reset%2A> metoda.</span><span class="sxs-lookup"><span data-stu-id="e4b9d-130">The event remains signaled until its <xref:System.Threading.EventWaitHandle.Reset%2A> method is called.</span></span> <span data-ttu-id="e4b9d-131">Díky ručnímu resetování události ideální způsob, jak zdržet podprocesy, které je třeba počkat, dokud jeden podproces dokončí úlohu.</span><span class="sxs-lookup"><span data-stu-id="e4b9d-131">This makes the manual reset event an ideal way to hold up threads that need to wait until one thread finishes a task.</span></span>  
  
 <span data-ttu-id="e4b9d-132">Stejně jako koně opouštějící ohrady, to vyžaduje čas pro uvolněné podprocesů, které mají být naplánovány operačním systémem a obnovit provádění.</span><span class="sxs-lookup"><span data-stu-id="e4b9d-132">Like horses leaving a corral, it takes time for the released threads to be scheduled by the operating system and to resume execution.</span></span> <span data-ttu-id="e4b9d-133">Pokud <xref:System.Threading.EventWaitHandle.Reset%2A> je metoda volána před všechna vlákna obnovily provádění, zbývající vlákna opět blokovat.</span><span class="sxs-lookup"><span data-stu-id="e4b9d-133">If the <xref:System.Threading.EventWaitHandle.Reset%2A> method is called before all the threads have resumed execution, the remaining threads once again block.</span></span> <span data-ttu-id="e4b9d-134">Která vlákna pokračovat a které podprocesy bloku závisí na náhodné faktory, jako je zatížení systému, počet podprocesů čekání na plánovače a tak dále.</span><span class="sxs-lookup"><span data-stu-id="e4b9d-134">Which threads resume and which threads block depends on random factors like the load on the system, the number of threads waiting for the scheduler, and so on.</span></span> <span data-ttu-id="e4b9d-135">To není problém, pokud podproces, který signalizuje událost končí po signalizaci, což je nejběžnější vzor použití.</span><span class="sxs-lookup"><span data-stu-id="e4b9d-135">This is not a problem if the thread that signals the event ends after signaling, which is the most common usage pattern.</span></span> <span data-ttu-id="e4b9d-136">Pokud chcete, aby vlákno, které signalizovalo událost, zahájilo nový úkol poté, co byla obnovena všechna čekající vlákna, musíte ji zablokovat, dokud nebudou obnovena všechna čekající vlákna.</span><span class="sxs-lookup"><span data-stu-id="e4b9d-136">If you want the thread that signaled the event to begin a new task after all the waiting threads have resumed, you must block it until all the waiting threads have resumed.</span></span> <span data-ttu-id="e4b9d-137">V opačném případě máte spor a chování kódu je nepředvídatelné.</span><span class="sxs-lookup"><span data-stu-id="e4b9d-137">Otherwise, you have a race condition, and the behavior of your code is unpredictable.</span></span>  
  
## <a name="features-common-to-automatic-and-manual-events"></a><span data-ttu-id="e4b9d-138">Funkce společné pro automatické a manuální události</span><span class="sxs-lookup"><span data-stu-id="e4b9d-138">Features Common to Automatic and Manual Events</span></span>  
 <span data-ttu-id="e4b9d-139">Obvykle jeden nebo více vláken blokovat <xref:System.Threading.EventWaitHandle> na dokud odblokované vlákno volá metodu, <xref:System.Threading.EventWaitHandle.Set%2A> která uvolní jeden z čekajících vláken (v případě automatického resetovat události) nebo všechny z nich (v případě ručního resetování událostí).</span><span class="sxs-lookup"><span data-stu-id="e4b9d-139">Typically, one or more threads block on an <xref:System.Threading.EventWaitHandle> until an unblocked thread calls the <xref:System.Threading.EventWaitHandle.Set%2A> method, which releases one of the waiting threads (in the case of automatic reset events) or all of them (in the case of manual reset events).</span></span> <span data-ttu-id="e4b9d-140">Podproces může <xref:System.Threading.EventWaitHandle> signalizovat a pak blokovat na něm, jako <xref:System.Threading.WaitHandle.SignalAndWait%2A?displayProperty=nameWithType> atomické operace voláním statické metody.</span><span class="sxs-lookup"><span data-stu-id="e4b9d-140">A thread can signal an <xref:System.Threading.EventWaitHandle> and then block on it, as an atomic operation, by calling the static <xref:System.Threading.WaitHandle.SignalAndWait%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="e4b9d-141"><xref:System.Threading.EventWaitHandle>objekty lze použít <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> se <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType> statickými a metodami.</span><span class="sxs-lookup"><span data-stu-id="e4b9d-141"><xref:System.Threading.EventWaitHandle> objects can be used with the static <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> and <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType> methods.</span></span> <span data-ttu-id="e4b9d-142">Vzhledem <xref:System.Threading.EventWaitHandle> <xref:System.Threading.Mutex> k tomu, <xref:System.Threading.WaitHandle>že a třídy odvozují z , můžete použít obě třídy s těmito metodami.</span><span class="sxs-lookup"><span data-stu-id="e4b9d-142">Because the <xref:System.Threading.EventWaitHandle> and <xref:System.Threading.Mutex> classes both derive from <xref:System.Threading.WaitHandle>, you can use both classes with these methods.</span></span>  
  
### <a name="named-events"></a><span data-ttu-id="e4b9d-143">Pojmenované události</span><span class="sxs-lookup"><span data-stu-id="e4b9d-143">Named Events</span></span>  
 <span data-ttu-id="e4b9d-144">Operační systém Windows umožňuje popisovače čekání událostí mít názvy.</span><span class="sxs-lookup"><span data-stu-id="e4b9d-144">The Windows operating system allows event wait handles to have names.</span></span> <span data-ttu-id="e4b9d-145">Pojmenovaná událost je celosystémová.</span><span class="sxs-lookup"><span data-stu-id="e4b9d-145">A named event is system wide.</span></span> <span data-ttu-id="e4b9d-146">To znamená, že po vytvoření pojmenované události je viditelná pro všechna vlákna ve všech procesech.</span><span class="sxs-lookup"><span data-stu-id="e4b9d-146">That is, once the named event is created, it is visible to all threads in all processes.</span></span> <span data-ttu-id="e4b9d-147">Pojmenované události lze tedy použít k synchronizaci aktivit procesů i vláken.</span><span class="sxs-lookup"><span data-stu-id="e4b9d-147">Thus, named events can be used to synchronize the activities of processes as well as threads.</span></span>  
  
 <span data-ttu-id="e4b9d-148">Můžete vytvořit <xref:System.Threading.EventWaitHandle> objekt, který představuje pojmenovanou systémovou událost pomocí jednoho z konstruktorů, který určuje název události.</span><span class="sxs-lookup"><span data-stu-id="e4b9d-148">You can create an <xref:System.Threading.EventWaitHandle> object that represents a named system event by using one of the constructors that specifies an event name.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="e4b9d-149">Vzhledem k tomu, že pojmenované události <xref:System.Threading.EventWaitHandle> jsou celého systému, je možné mít více objektů, které představují stejnou pojmenovanou událost.</span><span class="sxs-lookup"><span data-stu-id="e4b9d-149">Because named events are system wide, it is possible to have multiple <xref:System.Threading.EventWaitHandle> objects that represent the same named event.</span></span> <span data-ttu-id="e4b9d-150">Pokaždé, když voláte konstruktor <xref:System.Threading.EventWaitHandle.OpenExisting%2A> nebo metodu, je vytvořen nový <xref:System.Threading.EventWaitHandle> objekt.</span><span class="sxs-lookup"><span data-stu-id="e4b9d-150">Each time you call a constructor, or the <xref:System.Threading.EventWaitHandle.OpenExisting%2A> method, a new <xref:System.Threading.EventWaitHandle> object is created.</span></span> <span data-ttu-id="e4b9d-151">Zadání stejného názvu opakovaně vytvoří více objektů, které představují stejnou pojmenovanou událost.</span><span class="sxs-lookup"><span data-stu-id="e4b9d-151">Specifying the same name repeatedly creates multiple objects that represent the same named event.</span></span>  
  
 <span data-ttu-id="e4b9d-152">Při používání pojmenovaných událostí se doporučuje opatrnost.</span><span class="sxs-lookup"><span data-stu-id="e4b9d-152">Caution is advised in using named events.</span></span> <span data-ttu-id="e4b9d-153">Vzhledem k tomu, že jsou celého systému, jiný proces, který používá stejný název může neočekávaně blokovat podprocesy.</span><span class="sxs-lookup"><span data-stu-id="e4b9d-153">Because they are system wide, another process that uses the same name can block your threads unexpectedly.</span></span> <span data-ttu-id="e4b9d-154">Škodlivý kód spuštěný ve stejném počítači by jej mohl použít jako základ útoku typu denial of service.</span><span class="sxs-lookup"><span data-stu-id="e4b9d-154">Malicious code executing on the same computer could use this as the basis of a denial-of-service attack.</span></span>  
  
 <span data-ttu-id="e4b9d-155">Zabezpečení řízení přístupu <xref:System.Threading.EventWaitHandle> slouží k ochraně objektu, který představuje pojmenovanou <xref:System.Security.AccessControl.EventWaitHandleSecurity> událost, nejlépe pomocí konstruktoru, který určuje objekt.</span><span class="sxs-lookup"><span data-stu-id="e4b9d-155">Use access control security to protect an <xref:System.Threading.EventWaitHandle> object that represents a named event, preferably by using a constructor that specifies an <xref:System.Security.AccessControl.EventWaitHandleSecurity> object.</span></span> <span data-ttu-id="e4b9d-156">Můžete také použít zabezpečení řízení <xref:System.Threading.EventWaitHandle.SetAccessControl%2A> přístupu pomocí metody, ale to ponechává okno zranitelnosti mezi čas čekání popisovač události je vytvořen a čas je chráněn.</span><span class="sxs-lookup"><span data-stu-id="e4b9d-156">You can also apply access control security using the <xref:System.Threading.EventWaitHandle.SetAccessControl%2A> method, but this leaves a window of vulnerability between the time the event wait handle is created and the time it is protected.</span></span> <span data-ttu-id="e4b9d-157">Ochrana událostí pomocí zabezpečení řízení přístupu pomáhá zabránit škodlivým útokům, ale neřeší problém neúmyslných kolizí názvů.</span><span class="sxs-lookup"><span data-stu-id="e4b9d-157">Protecting events with access control security helps prevent malicious attacks, but it does not solve the problem of unintentional name collisions.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="e4b9d-158">Na <xref:System.Threading.EventWaitHandle> rozdíl od třídy <xref:System.Threading.AutoResetEvent> <xref:System.Threading.ManualResetEvent> odvozené třídy a může představovat pouze místní popisovače čekání.</span><span class="sxs-lookup"><span data-stu-id="e4b9d-158">Unlike the <xref:System.Threading.EventWaitHandle> class, the derived classes <xref:System.Threading.AutoResetEvent> and <xref:System.Threading.ManualResetEvent> can represent only local wait handles.</span></span> <span data-ttu-id="e4b9d-159">Nemohou představovat pojmenované systémové události.</span><span class="sxs-lookup"><span data-stu-id="e4b9d-159">They cannot represent named system events.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="e4b9d-160">Viz také</span><span class="sxs-lookup"><span data-stu-id="e4b9d-160">See also</span></span>

- <xref:System.Threading.EventWaitHandle>
- <xref:System.Threading.WaitHandle>
- <xref:System.Threading.AutoResetEvent>
- <xref:System.Threading.ManualResetEvent>
