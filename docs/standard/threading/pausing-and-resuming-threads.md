---
title: Pozastavení a přerušení vláken
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- interrupting threads
- threading [.NET Framework], pausing
- pausing threads
ms.assetid: 9fce4859-a19d-4506-b082-7dd0792688ca
ms.openlocfilehash: 369631603791d90c51244c1dc9907b9d8ec17364
ms.sourcegitcommit: 33deec3e814238fb18a49b2a7e89278e27888291
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 06/02/2020
ms.locfileid: "84291159"
---
# <a name="pausing-and-interrupting-threads"></a><span data-ttu-id="c7ae2-102">Pozastavení a přerušení vláken</span><span class="sxs-lookup"><span data-stu-id="c7ae2-102">Pausing and interrupting threads</span></span>

<span data-ttu-id="c7ae2-103">Nejběžnější způsob, jak synchronizovat aktivity vláken, je blokovat a vydávat vlákna nebo uzamknout objekty nebo oblasti kódu.</span><span class="sxs-lookup"><span data-stu-id="c7ae2-103">The most common ways to synchronize the activities of threads are to block and release threads, or to lock objects or regions of code.</span></span> <span data-ttu-id="c7ae2-104">Další informace o těchto mechanismech uzamykání a blokování najdete v tématu [Přehled primitiv synchronizace](overview-of-synchronization-primitives.md).</span><span class="sxs-lookup"><span data-stu-id="c7ae2-104">For more information on these locking and blocking mechanisms, see [Overview of Synchronization Primitives](overview-of-synchronization-primitives.md).</span></span>  
  
 <span data-ttu-id="c7ae2-105">Vlákna je také možné umístit do režimu spánku.</span><span class="sxs-lookup"><span data-stu-id="c7ae2-105">You can also have threads put themselves to sleep.</span></span> <span data-ttu-id="c7ae2-106">Pokud jsou vlákna blokována nebo v režimu spánku, můžete použít <xref:System.Threading.ThreadInterruptedException> k rozdělení do jejich čekacích stavů.</span><span class="sxs-lookup"><span data-stu-id="c7ae2-106">When threads are blocked or sleeping, you can use a <xref:System.Threading.ThreadInterruptedException> to break them out of their wait states.</span></span>  
  
## <a name="the-threadsleep-method"></a><span data-ttu-id="c7ae2-107">Thread. Sleep – Metoda</span><span class="sxs-lookup"><span data-stu-id="c7ae2-107">The Thread.Sleep method</span></span>

 <span data-ttu-id="c7ae2-108">Volání <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> metody způsobí, že aktuální vlákno okamžitě zablokuje počet milisekund nebo časový interval, který do metody předáte, a vyřadí zbytek časového řezu jinému vláknu.</span><span class="sxs-lookup"><span data-stu-id="c7ae2-108">Calling the <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> method causes the current thread to immediately block for the number of milliseconds or the time interval you pass to the method, and yields the remainder of its time slice to another thread.</span></span> <span data-ttu-id="c7ae2-109">Po uplynutí tohoto intervalu pokračuje běh vlákna v režimu spánku.</span><span class="sxs-lookup"><span data-stu-id="c7ae2-109">Once that interval elapses, the sleeping thread resumes execution.</span></span>  
  
 <span data-ttu-id="c7ae2-110">Jedno vlákno nemůže volat <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> jiné vlákno.</span><span class="sxs-lookup"><span data-stu-id="c7ae2-110">One thread cannot call <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> on another thread.</span></span>  <span data-ttu-id="c7ae2-111"><xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType>je statická metoda, která vždy způsobí, že aktuální vlákno bude v režimu spánku.</span><span class="sxs-lookup"><span data-stu-id="c7ae2-111"><xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> is a static method that always causes the current thread to sleep.</span></span>  
  
 <span data-ttu-id="c7ae2-112">Volání <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> s hodnotou způsobí, že se <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> vlákno dokončí do spánku, dokud není přerušeno jiným vláknem, které volá <xref:System.Threading.Thread.Interrupt%2A?displayProperty=nameWithType> metodu na pozastaveném vlákně, nebo dokud není ukončeno voláním <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="c7ae2-112">Calling <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> with a value of <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> causes a thread to sleep until it is interrupted by another thread that calls the  <xref:System.Threading.Thread.Interrupt%2A?displayProperty=nameWithType> method on the sleeping thread, or until it is terminated by a call to its <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType> method.</span></span>  <span data-ttu-id="c7ae2-113">Následující příklad ilustruje obě metody přerušení spícího vlákna.</span><span class="sxs-lookup"><span data-stu-id="c7ae2-113">The following example illustrates both methods of interrupting a sleeping thread.</span></span>  
  
 [!code-csharp[Conceptual.Threading.Resuming#1](../../../samples/snippets/csharp/VS_Snippets_CLR/Conceptual.Threading.Resuming/cs/Sleep1.cs#1)]
 [!code-vb[Conceptual.Threading.Resuming#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/Conceptual.Threading.Resuming/vb/Sleep1.vb#1)]  
  
## <a name="interrupting-threads"></a><span data-ttu-id="c7ae2-114">Přerušení vláken</span><span class="sxs-lookup"><span data-stu-id="c7ae2-114">Interrupting threads</span></span>

 <span data-ttu-id="c7ae2-115">Můžete přerušit čekající vlákno voláním <xref:System.Threading.Thread.Interrupt%2A?displayProperty=nameWithType> metody v blokovaném vláknu a vyvolat výjimku <xref:System.Threading.ThreadInterruptedException> , která přeruší vlákno mimo blokující volání.</span><span class="sxs-lookup"><span data-stu-id="c7ae2-115">You can interrupt a waiting thread by calling the <xref:System.Threading.Thread.Interrupt%2A?displayProperty=nameWithType> method on the blocked thread to throw a <xref:System.Threading.ThreadInterruptedException>, which breaks the thread out of the blocking call.</span></span> <span data-ttu-id="c7ae2-116">Vlákno by mělo zachytit <xref:System.Threading.ThreadInterruptedException> a dělat vše, co je vhodné pro pokračování v práci.</span><span class="sxs-lookup"><span data-stu-id="c7ae2-116">The thread should catch the <xref:System.Threading.ThreadInterruptedException> and do whatever is appropriate to continue working.</span></span> <span data-ttu-id="c7ae2-117">Pokud vlákno ignoruje výjimku, modul runtime zachytí výjimku a zastaví vlákno.</span><span class="sxs-lookup"><span data-stu-id="c7ae2-117">If the thread ignores the exception, the runtime catches the exception and stops the thread.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="c7ae2-118">Pokud cílové vlákno není blokováno při <xref:System.Threading.Thread.Interrupt%2A?displayProperty=nameWithType> volání, vlákno není přerušeno, dokud se neblokuje.</span><span class="sxs-lookup"><span data-stu-id="c7ae2-118">If the target thread is not blocked when <xref:System.Threading.Thread.Interrupt%2A?displayProperty=nameWithType> is called, the thread is not interrupted until it blocks.</span></span> <span data-ttu-id="c7ae2-119">Pokud vlákno nikdy není blokováno, může být dokončeno bez přerušení.</span><span class="sxs-lookup"><span data-stu-id="c7ae2-119">If the thread never blocks, it could complete without ever being interrupted.</span></span>  
  
 <span data-ttu-id="c7ae2-120">Pokud je čekání spravovaným čekáním, pak <xref:System.Threading.Thread.Interrupt%2A?displayProperty=nameWithType> <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType> obě vlákna okamžitě probudit.</span><span class="sxs-lookup"><span data-stu-id="c7ae2-120">If a wait is a managed wait, then <xref:System.Threading.Thread.Interrupt%2A?displayProperty=nameWithType> and <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType> both wake the thread immediately.</span></span> <span data-ttu-id="c7ae2-121">Pokud je čekání nespravovaným čekáním (například platforma vyvolá volání funkce Win32 [WaitForSingleObject](/windows/desktop/api/synchapi/nf-synchapi-waitforsingleobject) ), ani <xref:System.Threading.Thread.Interrupt%2A?displayProperty=nameWithType> <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType> nemůže převzít kontrolu nad vláknem, dokud se nevrátí do spravovaného kódu nebo do něj nevrátí volání.</span><span class="sxs-lookup"><span data-stu-id="c7ae2-121">If a wait is an unmanaged wait (for example, a platform invoke call to the Win32 [WaitForSingleObject](/windows/desktop/api/synchapi/nf-synchapi-waitforsingleobject) function), neither <xref:System.Threading.Thread.Interrupt%2A?displayProperty=nameWithType> nor <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType> can take control of the thread until it returns to or calls into managed code.</span></span> <span data-ttu-id="c7ae2-122">Ve spravovaném kódu je chování následující:</span><span class="sxs-lookup"><span data-stu-id="c7ae2-122">In managed code, the behavior is as follows:</span></span>  
  
- <span data-ttu-id="c7ae2-123"><xref:System.Threading.Thread.Interrupt%2A?displayProperty=nameWithType>probudí vlákno z jakéhokoli čekání, které může být v a způsobí, že bude <xref:System.Threading.ThreadInterruptedException> vyvoláno v cílovém vlákně.</span><span class="sxs-lookup"><span data-stu-id="c7ae2-123"><xref:System.Threading.Thread.Interrupt%2A?displayProperty=nameWithType> wakes a thread out of any wait it might be in and causes a <xref:System.Threading.ThreadInterruptedException> to be thrown in the destination thread.</span></span>  
  
- <span data-ttu-id="c7ae2-124"><xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType>probudí vlákno z jakéhokoli čekání, které může být v a způsobí, že bude ve <xref:System.Threading.ThreadAbortException> vlákně vyvolána výjimka.</span><span class="sxs-lookup"><span data-stu-id="c7ae2-124"><xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType> wakes a thread out of any wait it might be in and causes a <xref:System.Threading.ThreadAbortException> to be thrown on the thread.</span></span> <span data-ttu-id="c7ae2-125">Podrobnosti najdete v tématu [zničení vláken](destroying-threads.md).</span><span class="sxs-lookup"><span data-stu-id="c7ae2-125">For details, see [Destroying Threads](destroying-threads.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="c7ae2-126">Viz také</span><span class="sxs-lookup"><span data-stu-id="c7ae2-126">See also</span></span>

- <xref:System.Threading.Thread>
- <xref:System.Threading.ThreadInterruptedException>
- <xref:System.Threading.ThreadAbortException>
- [<span data-ttu-id="c7ae2-127">Dělení na vlákna</span><span class="sxs-lookup"><span data-stu-id="c7ae2-127">Threading</span></span>](index.md)
- [<span data-ttu-id="c7ae2-128">Použití vláken a dělení na vlákna</span><span class="sxs-lookup"><span data-stu-id="c7ae2-128">Using Threads and Threading</span></span>](using-threads-and-threading.md)
- [<span data-ttu-id="c7ae2-129">Přehled primitiv synchronizace</span><span class="sxs-lookup"><span data-stu-id="c7ae2-129">Overview of Synchronization Primitives</span></span>](overview-of-synchronization-primitives.md)
