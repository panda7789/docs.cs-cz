---
title: 'Lokální úložiště vláken: statická pole a datové sloty ve vztahu k vláknům'
ms.date: 03/30/2017
ms.technology: dotnet-standard
helpviewer_keywords:
- threading [.NET Framework], local storage
- threading [.NET Framework], thread-relative static fields
- local thread storage
- TLS
ms.assetid: c633a4dc-a790-4ed1-96b5-f72bd968b284
ms.openlocfilehash: b5a7c4b78f8599f64aa11f1c98c033866e582933
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 03/15/2020
ms.locfileid: "73127525"
---
# <a name="thread-local-storage-thread-relative-static-fields-and-data-slots"></a><span data-ttu-id="c9894-102">Lokální úložiště vláken: statická pole a datové sloty ve vztahu k vláknům</span><span class="sxs-lookup"><span data-stu-id="c9894-102">Thread Local Storage: Thread-Relative Static Fields and Data Slots</span></span>
<span data-ttu-id="c9894-103">Místní úložiště spravovaného vlákna (TLS) můžete použít k ukládání dat, která jsou jedinečná pro vlákno a doménu aplikace.</span><span class="sxs-lookup"><span data-stu-id="c9894-103">You can use managed thread local storage (TLS) to store data that is unique to a thread and application domain.</span></span> <span data-ttu-id="c9894-104">Rozhraní .NET Framework poskytuje dva způsoby použití spravovaného tls: statická pole relativní k vláknu a datové sloty.</span><span class="sxs-lookup"><span data-stu-id="c9894-104">The .NET Framework provides two ways to use managed TLS: thread-relative static fields and data slots.</span></span>  
  
- <span data-ttu-id="c9894-105">Pokud můžete předvídat přesné potřeby `Shared` v době kompilace, použijte statická pole relativní pro vlákno (pole relativní pod proces v jazyce Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="c9894-105">Use thread-relative static fields (thread-relative `Shared` fields in Visual Basic) if you can anticipate your exact needs at compile time.</span></span> <span data-ttu-id="c9894-106">Statická pole relativní k vláknu poskytují nejlepší výkon.</span><span class="sxs-lookup"><span data-stu-id="c9894-106">Thread-relative static fields provide the best performance.</span></span> <span data-ttu-id="c9894-107">Poskytují také výhody kontroly typu kompilace.</span><span class="sxs-lookup"><span data-stu-id="c9894-107">They also give you the benefits of compile-time type checking.</span></span>  
  
- <span data-ttu-id="c9894-108">Datové sloty používejte v případě, že vaše skutečné požadavky mohou být zjištěny pouze za běhu.</span><span class="sxs-lookup"><span data-stu-id="c9894-108">Use data slots when your actual requirements might be discovered only at run time.</span></span> <span data-ttu-id="c9894-109">Datové sloty jsou pomalejší a nepříjemnější než statická pole relativní k <xref:System.Object>vláknu a data jsou uložena jako typ , takže je nutné je před použitím přetypovat na správný typ.</span><span class="sxs-lookup"><span data-stu-id="c9894-109">Data slots are slower and more awkward to use than thread-relative static fields, and data is stored as type <xref:System.Object>, so you must cast it to the correct type before you use it.</span></span>  
  
 <span data-ttu-id="c9894-110">V nespravovaném jazyce `TlsAlloc` C++ slouží k `__declspec(thread)` dynamickému přidělování slotů a k deklarování, že proměnná by měla být přidělena v úložišti relativním k vláknu.</span><span class="sxs-lookup"><span data-stu-id="c9894-110">In unmanaged C++, you use `TlsAlloc` to allocate slots dynamically and `__declspec(thread)` to declare that a variable should be allocated in thread-relative storage.</span></span> <span data-ttu-id="c9894-111">Statická pole a datové sloty relativní k vláknu poskytují spravovanou verzi tohoto chování.</span><span class="sxs-lookup"><span data-stu-id="c9894-111">Thread-relative static fields and data slots provide the managed version of this behavior.</span></span>  
  
 <span data-ttu-id="c9894-112">V rozhraní .NET Framework 4 <xref:System.Threading.ThreadLocal%601?displayProperty=nameWithType> můžete použít třídu k vytvoření místních objektů podprocesů, které jsou inicializovány líně při prvním spotřebování objektu.</span><span class="sxs-lookup"><span data-stu-id="c9894-112">In the .NET Framework 4, you can use the <xref:System.Threading.ThreadLocal%601?displayProperty=nameWithType> class to create thread-local objects that are initialized lazily when the object is first consumed.</span></span> <span data-ttu-id="c9894-113">Další informace naleznete [v tématu Opožděná inicializace](../../../docs/framework/performance/lazy-initialization.md).</span><span class="sxs-lookup"><span data-stu-id="c9894-113">For more information, see [Lazy Initialization](../../../docs/framework/performance/lazy-initialization.md).</span></span>  
  
## <a name="uniqueness-of-data-in-managed-tls"></a><span data-ttu-id="c9894-114">Jedinečnost dat ve spravovaném tls</span><span class="sxs-lookup"><span data-stu-id="c9894-114">Uniqueness of Data in Managed TLS</span></span>  
 <span data-ttu-id="c9894-115">Bez ohledu na to, zda používáte statická pole relativní pro vlákno nebo datové sloty, data ve spravovaném tls jsou jedinečná pro kombinaci vlákna a domény aplikace.</span><span class="sxs-lookup"><span data-stu-id="c9894-115">Whether you use thread-relative static fields or data slots, data in managed TLS is unique to the combination of thread and application domain.</span></span>  
  
- <span data-ttu-id="c9894-116">V rámci domény aplikace jedno vlákno nemůže upravovat data z jiného vlákna, i když obě vlákna používají stejné pole nebo patici.</span><span class="sxs-lookup"><span data-stu-id="c9894-116">Within an application domain, one thread cannot modify data from another thread, even when both threads use the same field or slot.</span></span>  
  
- <span data-ttu-id="c9894-117">Když vlákno přistupuje ke stejnému poli nebo patice z více aplikačních domén, je v každé doméně aplikace zachována samostatná hodnota.</span><span class="sxs-lookup"><span data-stu-id="c9894-117">When a thread accesses the same field or slot from multiple application domains, a separate value is maintained in each application domain.</span></span>  
  
 <span data-ttu-id="c9894-118">Pokud například vlákno nastaví hodnotu statického pole relativního k vláknu, zadá jinou doménu aplikace a pak načte hodnotu pole, hodnota načtená v druhé doméně aplikace se liší od hodnoty v první doméně aplikace.</span><span class="sxs-lookup"><span data-stu-id="c9894-118">For example, if a thread sets the value of a thread-relative static field, enters another application domain, and then retrieves the value of the field, the value retrieved in the second application domain differs from the value in the first application domain.</span></span> <span data-ttu-id="c9894-119">Nastavení nové hodnoty pro pole v druhé doméně aplikace nemá vliv na hodnotu pole v první doméně aplikace.</span><span class="sxs-lookup"><span data-stu-id="c9894-119">Setting a new value for the field in the second application domain does not affect the field's value in the first application domain.</span></span>  
  
 <span data-ttu-id="c9894-120">Podobně když vlákno získá stejný pojmenovaný datový slot ve dvou různých aplikačních doménách, data v první doméně aplikace zůstanou nezávislá na datech v druhé doméně aplikace.</span><span class="sxs-lookup"><span data-stu-id="c9894-120">Similarly, when a thread gets the same named data slot in two different application domains, the data in the first application domain remains independent of the data in the second application domain.</span></span>  
  
## <a name="thread-relative-static-fields"></a><span data-ttu-id="c9894-121">Statická pole relativní k vláknu</span><span class="sxs-lookup"><span data-stu-id="c9894-121">Thread-Relative Static Fields</span></span>  
 <span data-ttu-id="c9894-122">Pokud víte, že část dat je vždy jedinečná pro kombinaci <xref:System.ThreadStaticAttribute> vlákna a aplikace a domény, použijte atribut na statické pole.</span><span class="sxs-lookup"><span data-stu-id="c9894-122">If you know that a piece of data is always unique to a thread and application-domain combination, apply the <xref:System.ThreadStaticAttribute> attribute to the static field.</span></span> <span data-ttu-id="c9894-123">Použijte toto pole stejně jako jakékoli jiné statické pole.</span><span class="sxs-lookup"><span data-stu-id="c9894-123">Use the field as you would use any other static field.</span></span> <span data-ttu-id="c9894-124">Data v poli jsou jedinečná pro každé vlákno, které je používá.</span><span class="sxs-lookup"><span data-stu-id="c9894-124">The data in the field is unique to each thread that uses it.</span></span>  
  
 <span data-ttu-id="c9894-125">Statická pole relativní k vláknům poskytují lepší výkon než datové sloty a mají výhodu kontroly typu kompilace.</span><span class="sxs-lookup"><span data-stu-id="c9894-125">Thread-relative static fields provide better performance than data slots and have the benefit of compile-time type checking.</span></span>  
  
 <span data-ttu-id="c9894-126">Uvědomte si, že jakýkoli kód konstruktoru třídy bude spuštěn v prvním vlákně v prvním kontextu, který přistupuje k poli.</span><span class="sxs-lookup"><span data-stu-id="c9894-126">Be aware that any class constructor code will run on the first thread in the first context that accesses the field.</span></span> <span data-ttu-id="c9894-127">Ve všech ostatních vláknech nebo kontextech ve stejné doméně `null` `Nothing` aplikace budou pole inicializována do (v jazyce Visual Basic), pokud jsou to typy odkazů, nebo na jejich výchozí hodnoty, pokud se jedná o typy hodnot.</span><span class="sxs-lookup"><span data-stu-id="c9894-127">In all other threads or contexts in the same application domain, the fields will be initialized to `null` (`Nothing` in Visual Basic) if they are reference types, or to their default values if they are value types.</span></span> <span data-ttu-id="c9894-128">Proto byste neměli spoléhat na konstruktory třídy k inicializaci statických polí relativních k vláknu.</span><span class="sxs-lookup"><span data-stu-id="c9894-128">Therefore, you should not rely on class constructors to initialize thread-relative static fields.</span></span> <span data-ttu-id="c9894-129">Místo toho se vyhněte inicializaci statických `null` polí`Nothing`relativních k vláknu a předpokládejme, že jsou inicializována na ( ) nebo na jejich výchozí hodnoty.</span><span class="sxs-lookup"><span data-stu-id="c9894-129">Instead, avoid initializing thread-relative static fields and assume that they are initialized to `null` (`Nothing`) or to their default values.</span></span>  
  
## <a name="data-slots"></a><span data-ttu-id="c9894-130">Datové sloty</span><span class="sxs-lookup"><span data-stu-id="c9894-130">Data Slots</span></span>  
 <span data-ttu-id="c9894-131">Rozhraní .NET Framework poskytuje dynamické datové sloty, které jsou jedinečné pro kombinaci vlákna a domény aplikace.</span><span class="sxs-lookup"><span data-stu-id="c9894-131">The .NET Framework provides dynamic data slots that are unique to a combination of thread and application-domain.</span></span> <span data-ttu-id="c9894-132">Existují dva typy datových slotů: pojmenované sloty a nepojmenované sloty.</span><span class="sxs-lookup"><span data-stu-id="c9894-132">There are two types of data slots: named slots and unnamed slots.</span></span> <span data-ttu-id="c9894-133">Obě jsou implementovány <xref:System.LocalDataStoreSlot> pomocí struktury.</span><span class="sxs-lookup"><span data-stu-id="c9894-133">Both are implemented by using the <xref:System.LocalDataStoreSlot> structure.</span></span>  
  
- <span data-ttu-id="c9894-134">Chcete-li vytvořit pojmenovanou <xref:System.Threading.Thread.AllocateNamedDataSlot%2A?displayProperty=nameWithType> <xref:System.Threading.Thread.GetNamedDataSlot%2A?displayProperty=nameWithType> datovou patku, použijte metodu nebo.</span><span class="sxs-lookup"><span data-stu-id="c9894-134">To create a named data slot, use the <xref:System.Threading.Thread.AllocateNamedDataSlot%2A?displayProperty=nameWithType> or <xref:System.Threading.Thread.GetNamedDataSlot%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="c9894-135">Chcete-li získat odkaz na existující pojmenovaný slot, předajte jeho název metodě. <xref:System.Threading.Thread.GetNamedDataSlot%2A></span><span class="sxs-lookup"><span data-stu-id="c9894-135">To get a reference to an existing named slot, pass its name to the <xref:System.Threading.Thread.GetNamedDataSlot%2A> method.</span></span>  
  
- <span data-ttu-id="c9894-136">Chcete-li vytvořit nepojmenovaný datový <xref:System.Threading.Thread.AllocateDataSlot%2A?displayProperty=nameWithType> slot, použijte metodu.</span><span class="sxs-lookup"><span data-stu-id="c9894-136">To create an unnamed data slot, use the <xref:System.Threading.Thread.AllocateDataSlot%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="c9894-137">Pro pojmenované i nepojmenované sloty <xref:System.Threading.Thread.SetData%2A?displayProperty=nameWithType> <xref:System.Threading.Thread.GetData%2A?displayProperty=nameWithType> použijte metody a nastavte a načtěte informace v patici.</span><span class="sxs-lookup"><span data-stu-id="c9894-137">For both named and unnamed slots, use the <xref:System.Threading.Thread.SetData%2A?displayProperty=nameWithType> and <xref:System.Threading.Thread.GetData%2A?displayProperty=nameWithType> methods to set and retrieve the information in the slot.</span></span> <span data-ttu-id="c9894-138">Jedná se o statické metody, které vždy působí na data pro vlákno, které je aktuálně provádí.</span><span class="sxs-lookup"><span data-stu-id="c9894-138">These are static methods that always act on the data for the thread that is currently executing them.</span></span>  
  
 <span data-ttu-id="c9894-139">Pojmenované sloty mohou být pohodlné, protože můžete načíst slot, když <xref:System.Threading.Thread.GetNamedDataSlot%2A> ji potřebujete, předáním jeho názvu metodě, namísto zachování odkazu na nepojmenovanou patici.</span><span class="sxs-lookup"><span data-stu-id="c9894-139">Named slots can be convenient, because you can retrieve the slot when you need it by passing its name to the <xref:System.Threading.Thread.GetNamedDataSlot%2A> method, instead of maintaining a reference to an unnamed slot.</span></span> <span data-ttu-id="c9894-140">Pokud však jiná komponenta používá stejný název pro své úložiště relativní k vláknu a vlákno spustí kód z komponenty i z druhé součásti, mohou být obě součásti navzájem poškozeny.</span><span class="sxs-lookup"><span data-stu-id="c9894-140">However, if another component uses the same name for its thread-relative storage and a thread executes code from both your component and the other component, the two components might corrupt each other's data.</span></span> <span data-ttu-id="c9894-141">(Tento scénář předpokládá, že obě součásti jsou spuštěny ve stejné doméně aplikace a že nejsou navrženy tak, aby sdílet stejná data.)</span><span class="sxs-lookup"><span data-stu-id="c9894-141">(This scenario assumes that both components are running in the same application domain, and that they are not designed to share the same data.)</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="c9894-142">Viz také</span><span class="sxs-lookup"><span data-stu-id="c9894-142">See also</span></span>

- <xref:System.ContextStaticAttribute>
- <xref:System.Threading.Thread.GetNamedDataSlot%2A?displayProperty=nameWithType>
- <xref:System.ThreadStaticAttribute>
- <xref:System.Runtime.Remoting.Messaging.CallContext>
- [<span data-ttu-id="c9894-143">Threading</span><span class="sxs-lookup"><span data-stu-id="c9894-143">Threading</span></span>](../../../docs/standard/threading/index.md)
