---
title: 'Lokální úložiště vláken: statická pole a datové sloty ve vztahu k vláknům'
ms.date: 03/30/2017
ms.technology: dotnet-standard
helpviewer_keywords:
- threading [.NET Framework], local storage
- threading [.NET Framework], thread-relative static fields
- local thread storage
- TLS
ms.assetid: c633a4dc-a790-4ed1-96b5-f72bd968b284
ms.openlocfilehash: adeeb6c95769d8e1ac120d4fb26d8aaedf7a1d4d
ms.sourcegitcommit: 33deec3e814238fb18a49b2a7e89278e27888291
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 06/02/2020
ms.locfileid: "84291081"
---
# <a name="thread-local-storage-thread-relative-static-fields-and-data-slots"></a><span data-ttu-id="bad41-102">Lokální úložiště vláken: statická pole a datové sloty ve vztahu k vláknům</span><span class="sxs-lookup"><span data-stu-id="bad41-102">Thread Local Storage: Thread-Relative Static Fields and Data Slots</span></span>
<span data-ttu-id="bad41-103">Pomocí spravovaného úložiště thread local (TLS) můžete ukládat data, která jsou jedinečná pro vlákno a doménu aplikace.</span><span class="sxs-lookup"><span data-stu-id="bad41-103">You can use managed thread local storage (TLS) to store data that is unique to a thread and application domain.</span></span> <span data-ttu-id="bad41-104">.NET Framework poskytuje dva způsoby použití spravovaného TLS: statická pole a datové sloty související s vláknem.</span><span class="sxs-lookup"><span data-stu-id="bad41-104">The .NET Framework provides two ways to use managed TLS: thread-relative static fields and data slots.</span></span>  
  
- <span data-ttu-id="bad41-105">Použijte statická pole související s vlákny (pole související s vlákny `Shared` v Visual Basic), pokud můžete v době kompilace odhadnout vaše přesné potřeby.</span><span class="sxs-lookup"><span data-stu-id="bad41-105">Use thread-relative static fields (thread-relative `Shared` fields in Visual Basic) if you can anticipate your exact needs at compile time.</span></span> <span data-ttu-id="bad41-106">Statická pole, která jsou v závislosti na vláknech, poskytují nejlepší výkon.</span><span class="sxs-lookup"><span data-stu-id="bad41-106">Thread-relative static fields provide the best performance.</span></span> <span data-ttu-id="bad41-107">Poskytují vám také výhody kontroly typu při kompilaci.</span><span class="sxs-lookup"><span data-stu-id="bad41-107">They also give you the benefits of compile-time type checking.</span></span>  
  
- <span data-ttu-id="bad41-108">Datové sloty můžete použít, pokud vaše skutečné požadavky mohou být zjištěny pouze v době běhu.</span><span class="sxs-lookup"><span data-stu-id="bad41-108">Use data slots when your actual requirements might be discovered only at run time.</span></span> <span data-ttu-id="bad41-109">Datové sloty jsou pomalejší a obtížnější k použití než ke statickým polím relativním na vláknech a data jsou ukládána jako typ <xref:System.Object> , takže je musíte přetypovat na správný typ předtím, než je použijete.</span><span class="sxs-lookup"><span data-stu-id="bad41-109">Data slots are slower and more awkward to use than thread-relative static fields, and data is stored as type <xref:System.Object>, so you must cast it to the correct type before you use it.</span></span>  
  
 <span data-ttu-id="bad41-110">V nespravovaném jazyce C++ použijete `TlsAlloc` k dynamickému přidělování slotů a `__declspec(thread)` deklarujete, že proměnná by měla být přidělena v úložišti relativním pro vlákno.</span><span class="sxs-lookup"><span data-stu-id="bad41-110">In unmanaged C++, you use `TlsAlloc` to allocate slots dynamically and `__declspec(thread)` to declare that a variable should be allocated in thread-relative storage.</span></span> <span data-ttu-id="bad41-111">Statická pole a datové sloty související s vláknem poskytují spravovanou verzi tohoto chování.</span><span class="sxs-lookup"><span data-stu-id="bad41-111">Thread-relative static fields and data slots provide the managed version of this behavior.</span></span>  
  
 <span data-ttu-id="bad41-112">V .NET Framework 4 můžete použít <xref:System.Threading.ThreadLocal%601?displayProperty=nameWithType> třídu k vytvoření místních objektů vlákna, které jsou inicializovány laxně vytvářená při prvním použití objektu.</span><span class="sxs-lookup"><span data-stu-id="bad41-112">In the .NET Framework 4, you can use the <xref:System.Threading.ThreadLocal%601?displayProperty=nameWithType> class to create thread-local objects that are initialized lazily when the object is first consumed.</span></span> <span data-ttu-id="bad41-113">Další informace naleznete v tématu [opožděná inicializace](../../framework/performance/lazy-initialization.md).</span><span class="sxs-lookup"><span data-stu-id="bad41-113">For more information, see [Lazy Initialization](../../framework/performance/lazy-initialization.md).</span></span>  
  
## <a name="uniqueness-of-data-in-managed-tls"></a><span data-ttu-id="bad41-114">Jedinečnost dat ve spravovaném TLS</span><span class="sxs-lookup"><span data-stu-id="bad41-114">Uniqueness of Data in Managed TLS</span></span>  
 <span data-ttu-id="bad41-115">Bez ohledu na to, jestli používáte statická pole nebo datové sloty související s vláknem, jsou data v spravovaném TLS jedinečná pro kombinaci vlákna a domény aplikace.</span><span class="sxs-lookup"><span data-stu-id="bad41-115">Whether you use thread-relative static fields or data slots, data in managed TLS is unique to the combination of thread and application domain.</span></span>  
  
- <span data-ttu-id="bad41-116">V rámci domény aplikace nemůže jedno vlákno upravovat data z jiného vlákna, a to i v případě, že obě vlákna používají stejné pole nebo slot.</span><span class="sxs-lookup"><span data-stu-id="bad41-116">Within an application domain, one thread cannot modify data from another thread, even when both threads use the same field or slot.</span></span>  
  
- <span data-ttu-id="bad41-117">Když vlákno přistupuje ke stejnému poli nebo pozici z více domén aplikace, zachová se v každé doméně aplikace samostatná hodnota.</span><span class="sxs-lookup"><span data-stu-id="bad41-117">When a thread accesses the same field or slot from multiple application domains, a separate value is maintained in each application domain.</span></span>  
  
 <span data-ttu-id="bad41-118">Například pokud vlákno nastaví hodnotu statického pole relativního k vláknu, přejde do jiné aplikační domény a potom načte hodnotu pole, hodnota načtená v druhé doméně aplikace se liší od hodnoty v první doméně aplikace.</span><span class="sxs-lookup"><span data-stu-id="bad41-118">For example, if a thread sets the value of a thread-relative static field, enters another application domain, and then retrieves the value of the field, the value retrieved in the second application domain differs from the value in the first application domain.</span></span> <span data-ttu-id="bad41-119">Nastavení nové hodnoty pro pole v druhé aplikační doméně nemá vliv na hodnotu pole v první aplikační doméně.</span><span class="sxs-lookup"><span data-stu-id="bad41-119">Setting a new value for the field in the second application domain does not affect the field's value in the first application domain.</span></span>  
  
 <span data-ttu-id="bad41-120">Podobně, pokud vlákno získá stejnou pojmenovanou datovou oblast ve dvou různých aplikačních doménách, data v první aplikační doméně zůstanou nezávislá na datech v druhé aplikační doméně.</span><span class="sxs-lookup"><span data-stu-id="bad41-120">Similarly, when a thread gets the same named data slot in two different application domains, the data in the first application domain remains independent of the data in the second application domain.</span></span>  
  
## <a name="thread-relative-static-fields"></a><span data-ttu-id="bad41-121">Statická pole v závislosti na vláknech</span><span class="sxs-lookup"><span data-stu-id="bad41-121">Thread-Relative Static Fields</span></span>  
 <span data-ttu-id="bad41-122">Pokud víte, že část dat je vždy jedinečná pro kombinaci vlákna a domény aplikace, použijte <xref:System.ThreadStaticAttribute> atribut na statické pole.</span><span class="sxs-lookup"><span data-stu-id="bad41-122">If you know that a piece of data is always unique to a thread and application-domain combination, apply the <xref:System.ThreadStaticAttribute> attribute to the static field.</span></span> <span data-ttu-id="bad41-123">Použijte pole, jako byste použili jiné statické pole.</span><span class="sxs-lookup"><span data-stu-id="bad41-123">Use the field as you would use any other static field.</span></span> <span data-ttu-id="bad41-124">Data v poli jsou jedinečná pro každé vlákno, které ho používá.</span><span class="sxs-lookup"><span data-stu-id="bad41-124">The data in the field is unique to each thread that uses it.</span></span>  
  
 <span data-ttu-id="bad41-125">Statická pole v závislosti na vláknech poskytují lepší výkon než datové sloty a mají výhodu kontroly typu při kompilaci.</span><span class="sxs-lookup"><span data-stu-id="bad41-125">Thread-relative static fields provide better performance than data slots and have the benefit of compile-time type checking.</span></span>  
  
 <span data-ttu-id="bad41-126">Mějte na paměti, že jakýkoliv kód konstruktoru třídy se spustí v prvním vlákně v prvním kontextu, který přistupuje k poli.</span><span class="sxs-lookup"><span data-stu-id="bad41-126">Be aware that any class constructor code will run on the first thread in the first context that accesses the field.</span></span> <span data-ttu-id="bad41-127">Ve všech ostatních vláknech nebo kontextech ve stejné doméně aplikace budou pole inicializována `null` ( `Nothing` v Visual Basic), pokud jsou odkazy na typy nebo na jejich výchozí hodnoty, pokud jsou typy hodnot.</span><span class="sxs-lookup"><span data-stu-id="bad41-127">In all other threads or contexts in the same application domain, the fields will be initialized to `null` (`Nothing` in Visual Basic) if they are reference types, or to their default values if they are value types.</span></span> <span data-ttu-id="bad41-128">Proto byste neměli spoléhat na konstruktory třídy pro inicializaci statických polí relativních k vláknům.</span><span class="sxs-lookup"><span data-stu-id="bad41-128">Therefore, you should not rely on class constructors to initialize thread-relative static fields.</span></span> <span data-ttu-id="bad41-129">Místo toho Vyhněte se inicializaci statických polí relativních k vláknům a předpokládat, že jsou inicializovány na `null` ( `Nothing` ) nebo do jejich výchozích hodnot.</span><span class="sxs-lookup"><span data-stu-id="bad41-129">Instead, avoid initializing thread-relative static fields and assume that they are initialized to `null` (`Nothing`) or to their default values.</span></span>  
  
## <a name="data-slots"></a><span data-ttu-id="bad41-130">Datové sloty</span><span class="sxs-lookup"><span data-stu-id="bad41-130">Data Slots</span></span>  
 <span data-ttu-id="bad41-131">.NET Framework poskytuje dynamické datové sloty, které jsou jedinečné pro kombinaci vlákna a aplikační domény.</span><span class="sxs-lookup"><span data-stu-id="bad41-131">The .NET Framework provides dynamic data slots that are unique to a combination of thread and application-domain.</span></span> <span data-ttu-id="bad41-132">Existují dva typy datových slotů: pojmenované sloty a nepojmenované sloty.</span><span class="sxs-lookup"><span data-stu-id="bad41-132">There are two types of data slots: named slots and unnamed slots.</span></span> <span data-ttu-id="bad41-133">Obě jsou implementovány pomocí <xref:System.LocalDataStoreSlot> struktury.</span><span class="sxs-lookup"><span data-stu-id="bad41-133">Both are implemented by using the <xref:System.LocalDataStoreSlot> structure.</span></span>  
  
- <span data-ttu-id="bad41-134">Chcete-li vytvořit pojmenovanou datovou oblast, použijte <xref:System.Threading.Thread.AllocateNamedDataSlot%2A?displayProperty=nameWithType> <xref:System.Threading.Thread.GetNamedDataSlot%2A?displayProperty=nameWithType> metodu nebo.</span><span class="sxs-lookup"><span data-stu-id="bad41-134">To create a named data slot, use the <xref:System.Threading.Thread.AllocateNamedDataSlot%2A?displayProperty=nameWithType> or <xref:System.Threading.Thread.GetNamedDataSlot%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="bad41-135">Chcete-li získat odkaz na existující pojmenovanou pozici, předejte své jméno <xref:System.Threading.Thread.GetNamedDataSlot%2A> metodě.</span><span class="sxs-lookup"><span data-stu-id="bad41-135">To get a reference to an existing named slot, pass its name to the <xref:System.Threading.Thread.GetNamedDataSlot%2A> method.</span></span>  
  
- <span data-ttu-id="bad41-136">K vytvoření nepojmenované datové přihrádky použijte <xref:System.Threading.Thread.AllocateDataSlot%2A?displayProperty=nameWithType> metodu.</span><span class="sxs-lookup"><span data-stu-id="bad41-136">To create an unnamed data slot, use the <xref:System.Threading.Thread.AllocateDataSlot%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="bad41-137">Pro pojmenované i nepojmenované sloty použijte <xref:System.Threading.Thread.SetData%2A?displayProperty=nameWithType> metody a a <xref:System.Threading.Thread.GetData%2A?displayProperty=nameWithType> nastavte a načtěte informace v patici.</span><span class="sxs-lookup"><span data-stu-id="bad41-137">For both named and unnamed slots, use the <xref:System.Threading.Thread.SetData%2A?displayProperty=nameWithType> and <xref:System.Threading.Thread.GetData%2A?displayProperty=nameWithType> methods to set and retrieve the information in the slot.</span></span> <span data-ttu-id="bad41-138">Jedná se o statické metody, které vždy pracují s daty pro vlákno, které je právě spouští.</span><span class="sxs-lookup"><span data-stu-id="bad41-138">These are static methods that always act on the data for the thread that is currently executing them.</span></span>  
  
 <span data-ttu-id="bad41-139">Pojmenované sloty můžou být pohodlné, protože můžete načíst slot, když ho potřebujete, předáním jeho názvu do <xref:System.Threading.Thread.GetNamedDataSlot%2A> metody namísto udržování odkazu na nepojmenované sloty.</span><span class="sxs-lookup"><span data-stu-id="bad41-139">Named slots can be convenient, because you can retrieve the slot when you need it by passing its name to the <xref:System.Threading.Thread.GetNamedDataSlot%2A> method, instead of maintaining a reference to an unnamed slot.</span></span> <span data-ttu-id="bad41-140">Pokud však jiná komponenta používá stejný název pro své relativní úložiště vlákna a vlákno spustí kód z vaší komponenty i druhé komponenty, mohou tyto dvě součásti poškodit data každé druhé.</span><span class="sxs-lookup"><span data-stu-id="bad41-140">However, if another component uses the same name for its thread-relative storage and a thread executes code from both your component and the other component, the two components might corrupt each other's data.</span></span> <span data-ttu-id="bad41-141">(Tento scénář předpokládá, že obě komponenty jsou spuštěné ve stejné aplikační doméně a že nejsou navržené tak, aby sdílely stejná data.)</span><span class="sxs-lookup"><span data-stu-id="bad41-141">(This scenario assumes that both components are running in the same application domain, and that they are not designed to share the same data.)</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="bad41-142">Viz také</span><span class="sxs-lookup"><span data-stu-id="bad41-142">See also</span></span>

- <xref:System.ContextStaticAttribute>
- <xref:System.Threading.Thread.GetNamedDataSlot%2A?displayProperty=nameWithType>
- <xref:System.ThreadStaticAttribute>
- <xref:System.Runtime.Remoting.Messaging.CallContext>
- [<span data-ttu-id="bad41-143">Dělení na vlákna</span><span class="sxs-lookup"><span data-stu-id="bad41-143">Threading</span></span>](index.md)
