---
title: Zpětné navrácení v regulárních výrazech .NET
description: Naučte se řídit zpětné navrácení v porovnávání vzorů regulárních výrazů.
ms.date: 11/12/2018
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- .NET Framework regular expressions, backtracking
- alternative matching patterns
- optional matching patterns
- searching with regular expressions, backtracking
- pattern-matching with regular expressions, backtracking
- backtracking
- regular expressions [.NET Framework], backtracking
- strings [.NET Framework], regular expressions
- parsing text with regular expressions, backtracking
ms.assetid: 34df1152-0b22-4a1c-a76c-3c28c47b70d8
ms.openlocfilehash: d9fb976c73891646df60b5329beb09493acbae8a
ms.sourcegitcommit: 33deec3e814238fb18a49b2a7e89278e27888291
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 06/02/2020
ms.locfileid: "84277801"
---
# <a name="backtracking-in-regular-expressions"></a><span data-ttu-id="64c43-103">Zpětné navracení v regulárních výrazech</span><span class="sxs-lookup"><span data-stu-id="64c43-103">Backtracking in Regular Expressions</span></span>
<span data-ttu-id="64c43-104">K zpětnému navrácení dojde, když vzor regulárního výrazu obsahuje volitelné [kvantifikátory](quantifiers-in-regular-expressions.md) nebo [konstrukce alternace](alternation-constructs-in-regular-expressions.md)a modul regulárních výrazů se vrátí do předchozího uloženého stavu, aby bylo možné pokračovat ve vyhledávání shody.</span><span class="sxs-lookup"><span data-stu-id="64c43-104">Backtracking occurs when a regular expression pattern contains optional [quantifiers](quantifiers-in-regular-expressions.md) or [alternation constructs](alternation-constructs-in-regular-expressions.md), and the regular expression engine returns to a previous saved state to continue its search for a match.</span></span> <span data-ttu-id="64c43-105">Navracení má klíčový význam pro výkon regulárních výrazů, což umožňuje, aby výrazy byly výkonné a pružné a aby vyhovovaly velmi složitým vzorům.</span><span class="sxs-lookup"><span data-stu-id="64c43-105">Backtracking is central to the power of regular expressions; it makes it possible for expressions to be powerful and flexible, and to match very complex patterns.</span></span> <span data-ttu-id="64c43-106">Tento výkon však zároveň něco stojí.</span><span class="sxs-lookup"><span data-stu-id="64c43-106">At the same time, this power comes at a cost.</span></span> <span data-ttu-id="64c43-107">Navracení je často jediným nejdůležitějším faktorem, který ovlivňuje výkon modulu regulárních výrazů.</span><span class="sxs-lookup"><span data-stu-id="64c43-107">Backtracking is often the single most important factor that affects the performance of the regular expression engine.</span></span> <span data-ttu-id="64c43-108">Vývojář má naštěstí vliv na chování modulu regulárních výrazů a způsob používání mechanismu navracení.</span><span class="sxs-lookup"><span data-stu-id="64c43-108">Fortunately, the developer has control over the behavior of the regular expression engine and how it uses backtracking.</span></span> <span data-ttu-id="64c43-109">V tomto tématu je vysvětleno fungování a ovládání mechanismu navracení.</span><span class="sxs-lookup"><span data-stu-id="64c43-109">This topic explains how backtracking works and how it can be controlled.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="64c43-110">Obecně platí, že nedeterministické Automation modul (NFA), jako je modul .NET regulárních výrazů, je zodpovědný za vytváření efektivních a rychlých regulárních výrazů pro vývojáře.</span><span class="sxs-lookup"><span data-stu-id="64c43-110">In general, a Nondeterministic Finite Automaton (NFA) engine like .NET regular expression engine places the responsibility for crafting efficient, fast regular expressions on the developer.</span></span>  

## <a name="linear-comparison-without-backtracking"></a><span data-ttu-id="64c43-111">Lineární porovnání bez mechanismu navracení</span><span class="sxs-lookup"><span data-stu-id="64c43-111">Linear Comparison Without Backtracking</span></span>  
 <span data-ttu-id="64c43-112">Pokud vzor regulárního výrazu nemá žádné volitelné kvantifikátory nebo konstrukce alternace, bude modul regulárních výrazů spuštěn v lineárním čase.</span><span class="sxs-lookup"><span data-stu-id="64c43-112">If a regular expression pattern has no optional quantifiers or alternation constructs, the regular expression engine executes in linear time.</span></span> <span data-ttu-id="64c43-113">Což znamená, že jakmile se modul regulárních výrazů shoduje s prvním prvkem jazyka ve vzorci s textem ve vstupním řetězci, pokusí se vyhledat další prvek jazyka ve vzoru s dalším znakem nebo skupinou znaků ve vstupním řetězci.</span><span class="sxs-lookup"><span data-stu-id="64c43-113">That is, after the regular expression engine matches the first language element in the pattern with text in the input string, it tries to match the next language element in the pattern with the next character or group of characters in the input string.</span></span> <span data-ttu-id="64c43-114">Tento postup se opakuje, dokud je shoda buď úspěšná, anebo neúspěšná.</span><span class="sxs-lookup"><span data-stu-id="64c43-114">This continues until the match either succeeds or fails.</span></span> <span data-ttu-id="64c43-115">V obou případech se modul regulárních výrazů posune vždy o jeden znak ve vstupním řetězci.</span><span class="sxs-lookup"><span data-stu-id="64c43-115">In either case, the regular expression engine advances by one character at a time in the input string.</span></span>  
  
 <span data-ttu-id="64c43-116">V následujícím příkladu je uvedena ukázka.</span><span class="sxs-lookup"><span data-stu-id="64c43-116">The following example provides an illustration.</span></span> <span data-ttu-id="64c43-117">Regulární výraz `e{2}\w\b` hledá dva výskyty písmena "e" následovaný jakýmkoliv znakem slova následovaným hranicí slova.</span><span class="sxs-lookup"><span data-stu-id="64c43-117">The regular expression `e{2}\w\b` looks for two occurrences of the letter "e" followed by any word character followed by a word boundary.</span></span>  
  
 [!code-csharp[Conceptual.RegularExpressions.Backtracking#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/cs/backtracking1.cs#1)]
 [!code-vb[Conceptual.RegularExpressions.Backtracking#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/vb/backtracking1.vb#1)]  
  
 <span data-ttu-id="64c43-118">I když tento regulární výraz obsahuje kvantifikátor `{2}` , je vyhodnocen lineárním způsobem.</span><span class="sxs-lookup"><span data-stu-id="64c43-118">Although this regular expression includes the quantifier `{2}`, it is evaluated in a linear manner.</span></span> <span data-ttu-id="64c43-119">Modul regulárních výrazů neprovádí navracení `{2}` , protože není volitelná kvantifikátor; určuje přesný počet a nikoli proměnný počet, kolikrát se musí předchozí dílčí výraz shodovat.</span><span class="sxs-lookup"><span data-stu-id="64c43-119">The regular expression engine does not backtrack because `{2}` is not an optional quantifier; it specifies an exact number and not a variable number of times that the previous subexpression must match.</span></span> <span data-ttu-id="64c43-120">V důsledku toho se modul regulárních výrazů pokusí shodovat se vzorem regulárního výrazu se vstupním řetězcem, jak je znázorněno v následující tabulce.</span><span class="sxs-lookup"><span data-stu-id="64c43-120">As a result, the regular expression engine tries to match the regular expression pattern with the input string as shown in the following table.</span></span>  
  
|<span data-ttu-id="64c43-121">Operace</span><span class="sxs-lookup"><span data-stu-id="64c43-121">Operation</span></span>|<span data-ttu-id="64c43-122">Pozice ve vzoru</span><span class="sxs-lookup"><span data-stu-id="64c43-122">Position in pattern</span></span>|<span data-ttu-id="64c43-123">Pozice v řetězci</span><span class="sxs-lookup"><span data-stu-id="64c43-123">Position in string</span></span>|<span data-ttu-id="64c43-124">Výsledek</span><span class="sxs-lookup"><span data-stu-id="64c43-124">Result</span></span>|  
|---------------|-------------------------|------------------------|------------|  
|<span data-ttu-id="64c43-125">1</span><span class="sxs-lookup"><span data-stu-id="64c43-125">1</span></span>|<span data-ttu-id="64c43-126">e</span><span class="sxs-lookup"><span data-stu-id="64c43-126">e</span></span>|<span data-ttu-id="64c43-127">"needing a reed" (index 0)</span><span class="sxs-lookup"><span data-stu-id="64c43-127">"needing a reed" (index 0)</span></span>|<span data-ttu-id="64c43-128">Žádná shoda.</span><span class="sxs-lookup"><span data-stu-id="64c43-128">No match.</span></span>|  
|<span data-ttu-id="64c43-129">2</span><span class="sxs-lookup"><span data-stu-id="64c43-129">2</span></span>|<span data-ttu-id="64c43-130">e</span><span class="sxs-lookup"><span data-stu-id="64c43-130">e</span></span>|<span data-ttu-id="64c43-131">"eeding a reed" (index 1)</span><span class="sxs-lookup"><span data-stu-id="64c43-131">"eeding a reed" (index 1)</span></span>|<span data-ttu-id="64c43-132">Možná shoda.</span><span class="sxs-lookup"><span data-stu-id="64c43-132">Possible match.</span></span>|  
|<span data-ttu-id="64c43-133">3</span><span class="sxs-lookup"><span data-stu-id="64c43-133">3</span></span>|<span data-ttu-id="64c43-134">cerebrální{2}</span><span class="sxs-lookup"><span data-stu-id="64c43-134">e{2}</span></span>|<span data-ttu-id="64c43-135">"eding a reed" (index 2)</span><span class="sxs-lookup"><span data-stu-id="64c43-135">"eding a reed" (index 2)</span></span>|<span data-ttu-id="64c43-136">Možná shoda.</span><span class="sxs-lookup"><span data-stu-id="64c43-136">Possible match.</span></span>|  
|<span data-ttu-id="64c43-137">4</span><span class="sxs-lookup"><span data-stu-id="64c43-137">4</span></span>|<span data-ttu-id="64c43-138">\w</span><span class="sxs-lookup"><span data-stu-id="64c43-138">\w</span></span>|<span data-ttu-id="64c43-139">"ding a reed" (index 3)</span><span class="sxs-lookup"><span data-stu-id="64c43-139">"ding a reed" (index 3)</span></span>|<span data-ttu-id="64c43-140">Možná shoda.</span><span class="sxs-lookup"><span data-stu-id="64c43-140">Possible match.</span></span>|  
|<span data-ttu-id="64c43-141">5</span><span class="sxs-lookup"><span data-stu-id="64c43-141">5</span></span>|<span data-ttu-id="64c43-142">\b</span><span class="sxs-lookup"><span data-stu-id="64c43-142">\b</span></span>|<span data-ttu-id="64c43-143">"ing a reed" (index 4)</span><span class="sxs-lookup"><span data-stu-id="64c43-143">"ing a reed" (index 4)</span></span>|<span data-ttu-id="64c43-144">Možná shoda se nezdaří.</span><span class="sxs-lookup"><span data-stu-id="64c43-144">Possible match fails.</span></span>|  
|<span data-ttu-id="64c43-145">6</span><span class="sxs-lookup"><span data-stu-id="64c43-145">6</span></span>|<span data-ttu-id="64c43-146">e</span><span class="sxs-lookup"><span data-stu-id="64c43-146">e</span></span>|<span data-ttu-id="64c43-147">"eding a reed" (index 2)</span><span class="sxs-lookup"><span data-stu-id="64c43-147">"eding a reed" (index 2)</span></span>|<span data-ttu-id="64c43-148">Možná shoda.</span><span class="sxs-lookup"><span data-stu-id="64c43-148">Possible match.</span></span>|  
|<span data-ttu-id="64c43-149">7</span><span class="sxs-lookup"><span data-stu-id="64c43-149">7</span></span>|<span data-ttu-id="64c43-150">cerebrální{2}</span><span class="sxs-lookup"><span data-stu-id="64c43-150">e{2}</span></span>|<span data-ttu-id="64c43-151">"ding a reed" (index 3)</span><span class="sxs-lookup"><span data-stu-id="64c43-151">"ding a reed" (index 3)</span></span>|<span data-ttu-id="64c43-152">Možná shoda se nezdaří.</span><span class="sxs-lookup"><span data-stu-id="64c43-152">Possible match fails.</span></span>|  
|<span data-ttu-id="64c43-153">8</span><span class="sxs-lookup"><span data-stu-id="64c43-153">8</span></span>|<span data-ttu-id="64c43-154">e</span><span class="sxs-lookup"><span data-stu-id="64c43-154">e</span></span>|<span data-ttu-id="64c43-155">"ding a reed" (index 3)</span><span class="sxs-lookup"><span data-stu-id="64c43-155">"ding a reed" (index 3)</span></span>|<span data-ttu-id="64c43-156">Shoda se nezdaří.</span><span class="sxs-lookup"><span data-stu-id="64c43-156">Match fails.</span></span>|  
|<span data-ttu-id="64c43-157">9</span><span class="sxs-lookup"><span data-stu-id="64c43-157">9</span></span>|<span data-ttu-id="64c43-158">e</span><span class="sxs-lookup"><span data-stu-id="64c43-158">e</span></span>|<span data-ttu-id="64c43-159">"ing a reed" (index 4)</span><span class="sxs-lookup"><span data-stu-id="64c43-159">"ing a reed" (index 4)</span></span>|<span data-ttu-id="64c43-160">Žádná shoda.</span><span class="sxs-lookup"><span data-stu-id="64c43-160">No match.</span></span>|  
|<span data-ttu-id="64c43-161">10</span><span class="sxs-lookup"><span data-stu-id="64c43-161">10</span></span>|<span data-ttu-id="64c43-162">e</span><span class="sxs-lookup"><span data-stu-id="64c43-162">e</span></span>|<span data-ttu-id="64c43-163">"ng a reed" (index 5)</span><span class="sxs-lookup"><span data-stu-id="64c43-163">"ng a reed" (index 5)</span></span>|<span data-ttu-id="64c43-164">Žádná shoda.</span><span class="sxs-lookup"><span data-stu-id="64c43-164">No match.</span></span>|  
|<span data-ttu-id="64c43-165">11</span><span class="sxs-lookup"><span data-stu-id="64c43-165">11</span></span>|<span data-ttu-id="64c43-166">e</span><span class="sxs-lookup"><span data-stu-id="64c43-166">e</span></span>|<span data-ttu-id="64c43-167">"g a reed" (index 6)</span><span class="sxs-lookup"><span data-stu-id="64c43-167">"g a reed" (index 6)</span></span>|<span data-ttu-id="64c43-168">Žádná shoda.</span><span class="sxs-lookup"><span data-stu-id="64c43-168">No match.</span></span>|  
|<span data-ttu-id="64c43-169">12</span><span class="sxs-lookup"><span data-stu-id="64c43-169">12</span></span>|<span data-ttu-id="64c43-170">e</span><span class="sxs-lookup"><span data-stu-id="64c43-170">e</span></span>|<span data-ttu-id="64c43-171">"a Reed" (index 7)</span><span class="sxs-lookup"><span data-stu-id="64c43-171">" a reed" (index 7)</span></span>|<span data-ttu-id="64c43-172">Žádná shoda.</span><span class="sxs-lookup"><span data-stu-id="64c43-172">No match.</span></span>|  
|<span data-ttu-id="64c43-173">13</span><span class="sxs-lookup"><span data-stu-id="64c43-173">13</span></span>|<span data-ttu-id="64c43-174">e</span><span class="sxs-lookup"><span data-stu-id="64c43-174">e</span></span>|<span data-ttu-id="64c43-175">"a Reed" (index 8)</span><span class="sxs-lookup"><span data-stu-id="64c43-175">"a reed" (index 8)</span></span>|<span data-ttu-id="64c43-176">Žádná shoda.</span><span class="sxs-lookup"><span data-stu-id="64c43-176">No match.</span></span>|  
|<span data-ttu-id="64c43-177">14</span><span class="sxs-lookup"><span data-stu-id="64c43-177">14</span></span>|<span data-ttu-id="64c43-178">e</span><span class="sxs-lookup"><span data-stu-id="64c43-178">e</span></span>|<span data-ttu-id="64c43-179">"Reed" (index 9)</span><span class="sxs-lookup"><span data-stu-id="64c43-179">" reed" (index 9)</span></span>|<span data-ttu-id="64c43-180">Žádná shoda.</span><span class="sxs-lookup"><span data-stu-id="64c43-180">No match.</span></span>|  
|<span data-ttu-id="64c43-181">15</span><span class="sxs-lookup"><span data-stu-id="64c43-181">15</span></span>|<span data-ttu-id="64c43-182">e</span><span class="sxs-lookup"><span data-stu-id="64c43-182">e</span></span>|<span data-ttu-id="64c43-183">"Reed" (index 10)</span><span class="sxs-lookup"><span data-stu-id="64c43-183">"reed" (index 10)</span></span>|<span data-ttu-id="64c43-184">Žádná shoda</span><span class="sxs-lookup"><span data-stu-id="64c43-184">No match</span></span>|  
|<span data-ttu-id="64c43-185">16</span><span class="sxs-lookup"><span data-stu-id="64c43-185">16</span></span>|<span data-ttu-id="64c43-186">e</span><span class="sxs-lookup"><span data-stu-id="64c43-186">e</span></span>|<span data-ttu-id="64c43-187">"eed" (index 11)</span><span class="sxs-lookup"><span data-stu-id="64c43-187">"eed" (index 11)</span></span>|<span data-ttu-id="64c43-188">Možná shoda.</span><span class="sxs-lookup"><span data-stu-id="64c43-188">Possible match.</span></span>|  
|<span data-ttu-id="64c43-189">17</span><span class="sxs-lookup"><span data-stu-id="64c43-189">17</span></span>|<span data-ttu-id="64c43-190">cerebrální{2}</span><span class="sxs-lookup"><span data-stu-id="64c43-190">e{2}</span></span>|<span data-ttu-id="64c43-191">"ed" (index 12)</span><span class="sxs-lookup"><span data-stu-id="64c43-191">"ed" (index 12)</span></span>|<span data-ttu-id="64c43-192">Možná shoda.</span><span class="sxs-lookup"><span data-stu-id="64c43-192">Possible match.</span></span>|  
|<span data-ttu-id="64c43-193">18</span><span class="sxs-lookup"><span data-stu-id="64c43-193">18</span></span>|<span data-ttu-id="64c43-194">\w</span><span class="sxs-lookup"><span data-stu-id="64c43-194">\w</span></span>|<span data-ttu-id="64c43-195">"d" (index 13)</span><span class="sxs-lookup"><span data-stu-id="64c43-195">"d" (index 13)</span></span>|<span data-ttu-id="64c43-196">Možná shoda.</span><span class="sxs-lookup"><span data-stu-id="64c43-196">Possible match.</span></span>|  
|<span data-ttu-id="64c43-197">19</span><span class="sxs-lookup"><span data-stu-id="64c43-197">19</span></span>|<span data-ttu-id="64c43-198">\b</span><span class="sxs-lookup"><span data-stu-id="64c43-198">\b</span></span>|<span data-ttu-id="64c43-199">"" (index 14)</span><span class="sxs-lookup"><span data-stu-id="64c43-199">"" (index 14)</span></span>|<span data-ttu-id="64c43-200">Shoda.</span><span class="sxs-lookup"><span data-stu-id="64c43-200">Match.</span></span>|  
  
 <span data-ttu-id="64c43-201">Pokud vzor regulárního výrazu neobsahuje žádné volitelné kvantifikátory nebo konstrukce alternace, musí maximální počet porovnání odpovídající vzoru regulárního výrazu se vstupním řetězcem být zhruba ekvivalentní počtu znaků ve vstupním řetězci.</span><span class="sxs-lookup"><span data-stu-id="64c43-201">If a regular expression pattern includes no optional quantifiers or alternation constructs, the maximum number of comparisons required to match the regular expression pattern with the input string is roughly equivalent to the number of characters in the input string.</span></span> <span data-ttu-id="64c43-202">V tomto případě používá modul regulárních výrazů 19 porovnání k identifikaci možných shod v tomto řetězci o 13 znacích.</span><span class="sxs-lookup"><span data-stu-id="64c43-202">In this case, the regular expression engine uses 19 comparisons to identify possible matches in this 13-character string.</span></span>  <span data-ttu-id="64c43-203">Jinými slovy to znamená, že modul regulárních výrazů je spuštěn v téměř lineárním čase, pokud neobsahuje žádné volitelné kvantifikátory nebo konstrukce alternace.</span><span class="sxs-lookup"><span data-stu-id="64c43-203">In other words, the regular expression engine runs in near-linear time if it contains no optional quantifiers or alternation constructs.</span></span>

## <a name="backtracking-with-optional-quantifiers-or-alternation-constructs"></a><span data-ttu-id="64c43-204">Navracení pomocí volitelných kvantifikátorů nebo konstrukcí alternace</span><span class="sxs-lookup"><span data-stu-id="64c43-204">Backtracking with Optional Quantifiers or Alternation Constructs</span></span>  
 <span data-ttu-id="64c43-205">Pokud regulární výraz zahrnuje volitelné kvantifikátory nebo alternace konstrukce, hodnocení vstupního řetězce již není lineární.</span><span class="sxs-lookup"><span data-stu-id="64c43-205">When a regular expression includes optional quantifiers or alternation constructs, the evaluation of the input string is no longer linear.</span></span> <span data-ttu-id="64c43-206">Porovnání vzorů s modulem NFA řídí prvky jazyka v regulárním výrazu, nikoli znaky, které se musí shodovat ve vstupním řetězci.</span><span class="sxs-lookup"><span data-stu-id="64c43-206">Pattern matching with an NFA engine is driven by the language elements in the regular expression and not by the characters to be matched in the input string.</span></span> <span data-ttu-id="64c43-207">Proto se modul regulárních výrazů pokouší o úplnou shodu volitelných nebo alternativních dílčích výrazů.</span><span class="sxs-lookup"><span data-stu-id="64c43-207">Therefore, the regular expression engine tries to fully match optional or alternative subexpressions.</span></span> <span data-ttu-id="64c43-208">Jakmile přejde na další prvek jazyka v dílčím výrazu a shoda není úspěšná, může modul regulárních výrazů opustit část úspěšné shody a vrátit se ke dříve uloženému stavu v zájmu shody celého regulárního výrazu ve vstupním řetězci.</span><span class="sxs-lookup"><span data-stu-id="64c43-208">When it advances to the next language element in the subexpression and the match is unsuccessful, the regular expression engine can abandon a portion of its successful match and return to an earlier saved state in the interest of matching the regular expression as a whole with the input string.</span></span> <span data-ttu-id="64c43-209">Tento proces návratu k předchozímu stavu pro vyhledání shody se označuje jako navracení.</span><span class="sxs-lookup"><span data-stu-id="64c43-209">This process of returning to a previous saved state to find a match is known as backtracking.</span></span>  
  
 <span data-ttu-id="64c43-210">Zvažte například vzor regulárního výrazu `.*(es)` , který odpovídá znakům "ES" a všem znakům, které jí předcházejí.</span><span class="sxs-lookup"><span data-stu-id="64c43-210">For example, consider the regular expression pattern `.*(es)`, which matches the characters "es" and all the characters that precede it.</span></span> <span data-ttu-id="64c43-211">Jak znázorňuje následující příklad, pokud je vstupní řetězec zadán jako „Essential services are provided by regular expressions.“, shoduje se vzor s celým řetězcem a obsahuje výraz „es“ ve slově „expressions“.</span><span class="sxs-lookup"><span data-stu-id="64c43-211">As the following example shows, if the input string is "Essential services are provided by regular expressions.", the pattern matches the whole string up to and including the "es" in "expressions".</span></span>  
  
 [!code-csharp[Conceptual.RegularExpressions.Backtracking#2](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/cs/backtracking2.cs#2)]
 [!code-vb[Conceptual.RegularExpressions.Backtracking#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/vb/backtracking2.vb#2)]  
  
 <span data-ttu-id="64c43-212">Chcete-li provést tuto akci, používá modul regulárních výrazů mechanismus navracení takto:</span><span class="sxs-lookup"><span data-stu-id="64c43-212">To do this, the regular expression engine uses backtracking as follows:</span></span>  
  
- <span data-ttu-id="64c43-213">Odpovídá `.*` typu (který odpovídá žádnému nebo více výskytům libovolného znaku) s celým vstupním řetězcem.</span><span class="sxs-lookup"><span data-stu-id="64c43-213">It matches the `.*` (which matches zero, one, or more occurrences of any character) with the whole input string.</span></span>  
  
- <span data-ttu-id="64c43-214">Pokusí se najít shodu pro písmeno „e“ ve vzoru regulárního výrazu.</span><span class="sxs-lookup"><span data-stu-id="64c43-214">It attempts to match "e" in the regular expression pattern.</span></span> <span data-ttu-id="64c43-215">Vstupní řetězec však nemá žádné odpovídající zbývající znaky.</span><span class="sxs-lookup"><span data-stu-id="64c43-215">However, the input string has no remaining characters available to match.</span></span>  
  
- <span data-ttu-id="64c43-216">Navrátí se k poslední úspěšné shodě „Essential services are provided by regular expressions“ a pokusí se najít shodu pro písmeno „e“ s tečkou na konci věty.</span><span class="sxs-lookup"><span data-stu-id="64c43-216">It backtracks to its last successful match, "Essential services are provided by regular expressions", and attempts to match "e" with the period at the end of the sentence.</span></span> <span data-ttu-id="64c43-217">Tato shoda se nezdaří.</span><span class="sxs-lookup"><span data-stu-id="64c43-217">The match fails.</span></span>  
  
- <span data-ttu-id="64c43-218">Bude pokračovat v navracení k předchozí úspěšné shodě vždy po jednom znaku, dokud nebude vyhledán nezávazně se shodující podřetězec „Essential services are provided by regular expr“.</span><span class="sxs-lookup"><span data-stu-id="64c43-218">It continues to backtrack to a previous successful match one character at a time until the tentatively matched substring is "Essential services are provided by regular expr".</span></span> <span data-ttu-id="64c43-219">Poté porovná písmeno „e“ ve vzoru s druhým písmenem „e“ ve výrazu „expressions“ a najde shodu.</span><span class="sxs-lookup"><span data-stu-id="64c43-219">It then compares the "e" in the pattern to the second "e" in "expressions" and finds a match.</span></span>  
  
- <span data-ttu-id="64c43-220">Porovná písmeno „s“ ve vzoru s písmenem „s“, které následuje za shodujícím se znakem „e“ (první výskyt písmene „s“ ve výrazu „expressions“).</span><span class="sxs-lookup"><span data-stu-id="64c43-220">It compares "s" in the pattern to the "s" that follows the matched "e" character (the first "s" in "expressions").</span></span> <span data-ttu-id="64c43-221">Tato shoda je úspěšná.</span><span class="sxs-lookup"><span data-stu-id="64c43-221">The match is successful.</span></span>  
  
 <span data-ttu-id="64c43-222">Pokud použijete mechanismus navracení, vyžaduje shoda vzoru regulárního výrazu se vstupním řetězcem, který má 55 znaků, celkem 67 operací porovnání.</span><span class="sxs-lookup"><span data-stu-id="64c43-222">When you use backtracking, matching the regular expression pattern with the input string, which is 55 characters long, requires 67 comparison operations.</span></span> <span data-ttu-id="64c43-223">Obecně platí, že pokud vzor regulárních výrazů má jedinou konstrukci alternace nebo jediný volitelný kvantifikátor, je počet operací porovnání vyžadovaný pro shodu vzoru více než dvakrát větší než počet znaků ve vstupním řetězci.</span><span class="sxs-lookup"><span data-stu-id="64c43-223">Generally, if a regular expression pattern has a single alternation construct or a single optional quantifier, the number of comparison operations required to match the pattern is more than twice the number of characters in the input string.</span></span>

## <a name="backtracking-with-nested-optional-quantifiers"></a><span data-ttu-id="64c43-224">Mechanismus navracení s vnořenými volitelnými kvantifikátory</span><span class="sxs-lookup"><span data-stu-id="64c43-224">Backtracking with Nested Optional Quantifiers</span></span>  
 <span data-ttu-id="64c43-225">Počet operací porovnání vyžadovaný pro shodu vzoru regulárního výrazu lze zvýšit exponenciálně, pokud vzor obsahuje velký počet konstrukcí alternace, pokud obsahuje vnořené konstrukce alternace, nebo pokud obsahuje vnořené volitelné kvantifikátory, což je nejčastější případ.</span><span class="sxs-lookup"><span data-stu-id="64c43-225">The number of comparison operations required to match a regular expression pattern can increase exponentially if the pattern includes a large number of alternation constructs, if it includes nested alternation constructs, or, most commonly, if it includes nested optional quantifiers.</span></span> <span data-ttu-id="64c43-226">Například vzor regulárního výrazu `^(a+)+$` je navržen tak, aby odpovídal kompletnímu řetězci, který obsahuje jeden nebo více znaků "a".</span><span class="sxs-lookup"><span data-stu-id="64c43-226">For example, the regular expression pattern `^(a+)+$` is designed to match a complete string that contains one or more "a" characters.</span></span> <span data-ttu-id="64c43-227">Příklad obsahuje dva vstupní řetězce stejné délky, ale pouze první řetězec odpovídá vzoru.</span><span class="sxs-lookup"><span data-stu-id="64c43-227">The example provides two input strings of identical length, but only the first string matches the pattern.</span></span> <span data-ttu-id="64c43-228"><xref:System.Diagnostics.Stopwatch?displayProperty=nameWithType>Třída se používá k určení, jak dlouho operace porovnávání trvá.</span><span class="sxs-lookup"><span data-stu-id="64c43-228">The <xref:System.Diagnostics.Stopwatch?displayProperty=nameWithType> class is used to determine how long the match operation takes.</span></span>  
  
 [!code-csharp[Conceptual.RegularExpressions.Backtracking#3](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/cs/backtracking3.cs#3)]
 [!code-vb[Conceptual.RegularExpressions.Backtracking#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/vb/backtracking3.vb#3)]  
  
 <span data-ttu-id="64c43-229">Jak výstup v příkladu znázorňuje, trvalo modulu regulárních výrazů ve srovnání s délkou trvání identifikace odpovídajícího řetězce dvakrát tak dlouho, než vyhledal, že vstupní řetězec neodpovídá vzoru.</span><span class="sxs-lookup"><span data-stu-id="64c43-229">As the output from the example shows, the regular expression engine took about twice as long to find that an input string did not match the pattern as it did to identify a matching string.</span></span> <span data-ttu-id="64c43-230">Je to proto, že neúspěšná shoda vždy představuje nejhorší případ.</span><span class="sxs-lookup"><span data-stu-id="64c43-230">This is because an unsuccessful match always represents a worst-case scenario.</span></span> <span data-ttu-id="64c43-231">Modul regulárních výrazů musí prohledat všechny možné cesty dat předtím, než dojde k závěru, že shoda je neúspěšná, a vnořené závorky vytvoří velký počet dodatečných cest napříč daty.</span><span class="sxs-lookup"><span data-stu-id="64c43-231">The regular expression engine must use the regular expression to follow all possible paths through the data before it can conclude that the match is unsuccessful, and the nested parentheses create many additional paths through the data.</span></span> <span data-ttu-id="64c43-232">Modul regulárních výrazů dojde k závěru, že druhý řetězec neodpovídá vzoru následujícím způsobem:</span><span class="sxs-lookup"><span data-stu-id="64c43-232">The regular expression engine concludes that the second string did not match the pattern by doing the following:</span></span>  
  
- <span data-ttu-id="64c43-233">Kontroluje, zda se jednalo o začátek řetězce, a pak odpovídá prvních pěti znakům v řetězci se vzorem `a+` .</span><span class="sxs-lookup"><span data-stu-id="64c43-233">It checks that it was at the beginning of the string, and then matches the first five characters in the string with the pattern `a+`.</span></span> <span data-ttu-id="64c43-234">Poté určí, zda řetězec neobsahuje žádné další skupiny znaků „a“.</span><span class="sxs-lookup"><span data-stu-id="64c43-234">It then determines that there are no additional groups of "a" characters in the string.</span></span> <span data-ttu-id="64c43-235">Nakonec ověří konec řetězce.</span><span class="sxs-lookup"><span data-stu-id="64c43-235">Finally, it tests for the end of the string.</span></span> <span data-ttu-id="64c43-236">Vzhledem k tomu, že v řetězci zůstává jeden další znak, shoda se nezdaří.</span><span class="sxs-lookup"><span data-stu-id="64c43-236">Because one additional character remains in the string, the match fails.</span></span> <span data-ttu-id="64c43-237">Tato nezdařená shoda vyžaduje 9 porovnání.</span><span class="sxs-lookup"><span data-stu-id="64c43-237">This failed match requires 9 comparisons.</span></span> <span data-ttu-id="64c43-238">Modul regulárních výrazů také ukládá informace o stavu ze shody „a“ (který budeme nazývat shoda 1), „aa“ (shoda 2), „aaa“ (shoda 3) a „aaaa“ (shoda 4).</span><span class="sxs-lookup"><span data-stu-id="64c43-238">The regular expression engine also saves state information from its matches of "a" (which we will call match 1), "aa" (match 2), "aaa" (match 3), and "aaaa" (match 4).</span></span>  
  
- <span data-ttu-id="64c43-239">Vrátí se k předchozí uložené shodě 4.</span><span class="sxs-lookup"><span data-stu-id="64c43-239">It returns to the previously saved match 4.</span></span> <span data-ttu-id="64c43-240">Určí, že existuje další znak „a“, který lze přiřadit dodatečné zachycené skupině.</span><span class="sxs-lookup"><span data-stu-id="64c43-240">It determines that there is one additional "a" character to assign to an additional captured group.</span></span> <span data-ttu-id="64c43-241">Nakonec ověří konec řetězce.</span><span class="sxs-lookup"><span data-stu-id="64c43-241">Finally, it tests for the end of the string.</span></span> <span data-ttu-id="64c43-242">Vzhledem k tomu, že v řetězci zůstává jeden další znak, shoda se nezdaří.</span><span class="sxs-lookup"><span data-stu-id="64c43-242">Because one additional character remains in the string, the match fails.</span></span> <span data-ttu-id="64c43-243">Tato neúspěšná shoda vyžaduje 4 porovnání.</span><span class="sxs-lookup"><span data-stu-id="64c43-243">This failed match requires 4 comparisons.</span></span> <span data-ttu-id="64c43-244">Zatím bylo provedeno celkem 13 porovnání.</span><span class="sxs-lookup"><span data-stu-id="64c43-244">So far, a total of 13 comparisons have been performed.</span></span>  
  
- <span data-ttu-id="64c43-245">Vrátí se k dřív uložené shodě 3.</span><span class="sxs-lookup"><span data-stu-id="64c43-245">It returns to the previously saved match 3.</span></span> <span data-ttu-id="64c43-246">Určí, že existují další dva znaky „a“, které lze přiřadit dodatečné zachycené skupině.</span><span class="sxs-lookup"><span data-stu-id="64c43-246">It determines that there are two additional "a" characters to assign to an additional captured group.</span></span> <span data-ttu-id="64c43-247">Test konce řetězce se však nezdaří.</span><span class="sxs-lookup"><span data-stu-id="64c43-247">However, the end-of-string test fails.</span></span> <span data-ttu-id="64c43-248">Poté se vrátí ke shodě 3 a pokusí se porovnat další dva znaky „a“ v dodatečné zachycené skupině.</span><span class="sxs-lookup"><span data-stu-id="64c43-248">It then returns to match3 and tries to match the two additional "a" characters in two additional captured groups.</span></span> <span data-ttu-id="64c43-249">Test konce řetězce se však ani tentokrát nezdaří.</span><span class="sxs-lookup"><span data-stu-id="64c43-249">The end-of-string test still fails.</span></span> <span data-ttu-id="64c43-250">Tyto nezdařené shody vyžadují 12 porovnání.</span><span class="sxs-lookup"><span data-stu-id="64c43-250">These failed matches require 12 comparisons.</span></span> <span data-ttu-id="64c43-251">Doposud byl proveden celkem 25 porovnání.</span><span class="sxs-lookup"><span data-stu-id="64c43-251">So far, a total of 25 comparisons have been performed.</span></span>  
  
 <span data-ttu-id="64c43-252">Porovnání vstupního řetězce s regulárním výrazem pokračuje tímto způsobem, dokud se modul regulárních výrazů nepokusí vyhledat všechny možné kombinace shody, a poté dojde k závěru, že neexistuje žádná shoda.</span><span class="sxs-lookup"><span data-stu-id="64c43-252">Comparison of the input string with the regular expression continues in this way until the regular expression engine has tried all possible combinations of matches, and then concludes that there is no match.</span></span> <span data-ttu-id="64c43-253">Vzhledem k vnořeným kvantifikátorům je toto porovnání typu O (2<sup>n</sup>) nebo exponenciální operace, kde *n* je počet znaků ve vstupním řetězci.</span><span class="sxs-lookup"><span data-stu-id="64c43-253">Because of the nested quantifiers, this comparison is an O(2<sup>n</sup>) or an exponential operation, where *n* is the number of characters in the input string.</span></span> <span data-ttu-id="64c43-254">To znamená, že v nejhorším případě vyžaduje vstupní znak o délce 30 znaků přibližně 1 073 741 824 porovnání a vstupní znak o délce 40 znaků vyžaduje přibližně 1 099 511 627 776 porovnání.</span><span class="sxs-lookup"><span data-stu-id="64c43-254">This means that in the worst case, an input string of 30 characters requires approximately 1,073,741,824 comparisons, and an input string of 40 characters requires approximately 1,099,511,627,776 comparisons.</span></span> <span data-ttu-id="64c43-255">Pokud používáte řetězce o této nebo větší délce, může dokončení metod regulárních výrazů trvat extrémně dlouhou dobu, pokud zpracovávají obsah, který se neshoduje se vzorem regulárního výrazu.</span><span class="sxs-lookup"><span data-stu-id="64c43-255">If you use strings of these or even greater lengths, regular expression methods can take an extremely long time to complete when they process input that does not match the regular expression pattern.</span></span>

## <a name="controlling-backtracking"></a><span data-ttu-id="64c43-256">Řídicí mechanismus navracení</span><span class="sxs-lookup"><span data-stu-id="64c43-256">Controlling Backtracking</span></span>  
 <span data-ttu-id="64c43-257">Mechanismus navracení umožňuje vytvářet výkonné a pružné regulární výrazy.</span><span class="sxs-lookup"><span data-stu-id="64c43-257">Backtracking lets you create powerful, flexible regular expressions.</span></span> <span data-ttu-id="64c43-258">Jak již však bylo znázorněno v předchozích částech, mohou tyto výhody být vázány na nepřijatelně nízký výkon.</span><span class="sxs-lookup"><span data-stu-id="64c43-258">However, as the previous section showed, these benefits may be coupled with unacceptably poor performance.</span></span> <span data-ttu-id="64c43-259">Aby nedocházelo k nadměrnému navracení, měli byste definovat interval časového limitu při vytváření instance <xref:System.Text.RegularExpressions.Regex> objektu nebo volání statické metody pro porovnání regulárního výrazu.</span><span class="sxs-lookup"><span data-stu-id="64c43-259">To prevent excessive backtracking, you should define a time-out interval when you instantiate a <xref:System.Text.RegularExpressions.Regex> object or call a static regular expression matching method.</span></span> <span data-ttu-id="64c43-260">Tento postup je popsán v následujícím oddíle.</span><span class="sxs-lookup"><span data-stu-id="64c43-260">This is discussed in the next section.</span></span> <span data-ttu-id="64c43-261">Kromě toho rozhraní .NET podporuje tři prvky regulárního výrazu, které omezují nebo potlačí zpětné navrácení a které podporují složité regulární výrazy s minimální nebo žádnou pokutou výkonu: [atomické](#atomic-groups) [kontrolní výrazy](#lookbehind-assertions)a [kontrolní výrazy dopředného vyhledávání](#lookahead-assertions).</span><span class="sxs-lookup"><span data-stu-id="64c43-261">In addition, .NET supports three regular expression language elements that limit or suppress backtracking and that support complex regular expressions with little or no performance penalty: [atomic groups](#atomic-groups), [lookbehind assertions](#lookbehind-assertions), and [lookahead assertions](#lookahead-assertions).</span></span> <span data-ttu-id="64c43-262">Další informace o jednotlivých prvcích jazyka naleznete v tématu [Grouping konstrukcís](grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="64c43-262">For more information about each language element, see [Grouping Constructs](grouping-constructs-in-regular-expressions.md).</span></span>  

### <a name="defining-a-time-out-interval"></a><span data-ttu-id="64c43-263">Definování intervalu časového limitu</span><span class="sxs-lookup"><span data-stu-id="64c43-263">Defining a Time-out Interval</span></span>  
 <span data-ttu-id="64c43-264">Počínaje .NET Framework 4,5 můžete nastavit hodnotu časového limitu, která představuje nejdelší interval, který modul regulárních výrazů vyhledá jednu shodu předtím, než poruší pokus a vyvolá <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> výjimku.</span><span class="sxs-lookup"><span data-stu-id="64c43-264">Starting with the .NET Framework 4.5, you can set a time-out value that represents the longest interval the regular expression engine will search for a single match before it abandons the attempt and throws a <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exception.</span></span> <span data-ttu-id="64c43-265">Interval časového limitu určíte zadáním <xref:System.TimeSpan> hodnoty do <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> konstruktoru regulárních výrazů instance.</span><span class="sxs-lookup"><span data-stu-id="64c43-265">You specify the time-out interval by supplying a <xref:System.TimeSpan> value to the <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> constructor for instance regular expressions.</span></span> <span data-ttu-id="64c43-266">Kromě toho každá statická metoda porovnávání vzorů má přetížení s <xref:System.TimeSpan> parametrem, který umožňuje zadat hodnotu časového limitu.</span><span class="sxs-lookup"><span data-stu-id="64c43-266">In addition, each static pattern matching method has an overload with a <xref:System.TimeSpan> parameter that allows you to specify a time-out value.</span></span> <span data-ttu-id="64c43-267">Ve výchozím nastavení je interval časového limitu nastaven na hodnotu <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType> a modul regulárních výrazů nekončí časovým limitem.</span><span class="sxs-lookup"><span data-stu-id="64c43-267">By default, the time-out interval is set to <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType> and the regular expression engine does not time out.</span></span>  
  
> [!IMPORTANT]
> <span data-ttu-id="64c43-268">Pokud se regulární výraz spoléhá na mechanismus navracení, doporučujeme vždy nastavit interval časového limitu.</span><span class="sxs-lookup"><span data-stu-id="64c43-268">We recommend that you always set a time-out interval if your regular expression relies on backtracking.</span></span>  
  
 <span data-ttu-id="64c43-269"><xref:System.Text.RegularExpressions.RegexMatchTimeoutException>Výjimka indikuje, že modul regulárních výrazů nebyl schopen nalézt shodu v rámci zadaného časového limitu, ale neindikuje, proč byla výjimka vyvolána.</span><span class="sxs-lookup"><span data-stu-id="64c43-269">A <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exception indicates that the regular expression engine was unable to find a match within the specified time-out interval but does not indicate why the exception was thrown.</span></span> <span data-ttu-id="64c43-270">Důvodem může být nadměrné používání mechanismu navracení, je však také možné, že nastavený interval časového limitu byl příliš krátký vzhledem k zatížení systému v době vyvolání výjimky.</span><span class="sxs-lookup"><span data-stu-id="64c43-270">The reason might be excessive backtracking, but it is also possible that the time-out interval was set too low given the system load at the time the exception was thrown.</span></span> <span data-ttu-id="64c43-271">Při zpracování výjimek můžete zrušit další shody se vstupním řetězcem nebo zvýšit interval časového limitu a opakovat operaci porovnání.</span><span class="sxs-lookup"><span data-stu-id="64c43-271">When you handle the exception, you can choose to abandon further matches with the input string or increase the time-out interval and retry the matching operation.</span></span>  
  
 <span data-ttu-id="64c43-272">Například následující kód volá <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> konstruktor pro vytvoření instance <xref:System.Text.RegularExpressions.Regex> objektu s hodnotou časového limitu jedna sekunda.</span><span class="sxs-lookup"><span data-stu-id="64c43-272">For example, the following code calls the <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> constructor to instantiate a <xref:System.Text.RegularExpressions.Regex> object with a time-out value of one second.</span></span> <span data-ttu-id="64c43-273">Vzor regulárního výrazu `(a+)+$` , který se shoduje s jednou nebo více sekvencemi jednoho nebo více znaků "a" na konci řádku, podléhá nadměrnému navrácení.</span><span class="sxs-lookup"><span data-stu-id="64c43-273">The regular expression pattern `(a+)+$`, which matches one or more sequences of one or more "a" characters at the end of a line, is subject to excessive backtracking.</span></span> <span data-ttu-id="64c43-274">Pokud <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> je vyvolána, příklad zvyšuje hodnotu časového limitu až do maximálního intervalu tři sekund.</span><span class="sxs-lookup"><span data-stu-id="64c43-274">If a <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> is thrown, the example increases the time-out value up to a maximum interval of three seconds.</span></span> <span data-ttu-id="64c43-275">Poté zruší pokus o shodu se vzorem.</span><span class="sxs-lookup"><span data-stu-id="64c43-275">After that, it abandons the attempt to match the pattern.</span></span>  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.ctor#1](../../../samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ctor/cs/ctor1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.ctor#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ctor/vb/ctor1.vb#1)]  

### <a name="atomic-groups"></a><span data-ttu-id="64c43-276">Atomické skupiny</span><span class="sxs-lookup"><span data-stu-id="64c43-276">Atomic groups</span></span>
 <span data-ttu-id="64c43-277">`(?>` *subexpression* `)` Prvek jazyka dílčího výrazu potlačuje navrácení do dílčího výrazu.</span><span class="sxs-lookup"><span data-stu-id="64c43-277">The `(?>` *subexpression*`)` language element suppresses backtracking into the subexpression.</span></span> <span data-ttu-id="64c43-278">Po úspěšném spárování neposkytne žádnou součást shody k následnému navrácení.</span><span class="sxs-lookup"><span data-stu-id="64c43-278">Once it has successfully matched, it will not give up any part of its match to subsequent backtracking.</span></span> <span data-ttu-id="64c43-279">Například ve vzorci `(?>\w*\d*)1` , pokud `1` nelze porovnat, `\d*` neposkytne žádné z jeho shody, i když to znamená, že umožňuje `1` úspěšné párování.</span><span class="sxs-lookup"><span data-stu-id="64c43-279">For example, in the pattern `(?>\w*\d*)1`, if the `1` cannot be matched, the `\d*` will not give up any of its match even if that means it would allow the `1` to successfully match.</span></span> <span data-ttu-id="64c43-280">Atomické skupiny můžou pomáhat zabránit problémům s výkonem přidruženým k neúspěšným shodám.</span><span class="sxs-lookup"><span data-stu-id="64c43-280">Atomic groups can help prevent the performance problems associated with failed matches.</span></span>
  
 <span data-ttu-id="64c43-281">Následující příklad znázorňuje, jakým způsobem potlačení mechanismu navracení zlepšuje výkon při použití vnořených kvantifikátorů.</span><span class="sxs-lookup"><span data-stu-id="64c43-281">The following example illustrates how suppressing backtracking improves performance when using nested quantifiers.</span></span> <span data-ttu-id="64c43-282">Měří čas, který modul regulárních výrazů potřebuje k určení toho, zda se vstupní řetězec neshoduje s dvěma regulárními výrazy.</span><span class="sxs-lookup"><span data-stu-id="64c43-282">It measures the time required for the regular expression engine to determine that an input string does not match two regular expressions.</span></span> <span data-ttu-id="64c43-283">První regulární výraz používá mechanismus navracení k tomu, aby se pokusil porovnat řetězec, který obsahuje jeden výskyt nebo několik výskytů jedné nebo několika šestnáctkových číslic následovaných dvojtečkou, následovaných jednou nebo několika šestnáctkovými číslicemi, následovaných dvěma dvojtečkami.</span><span class="sxs-lookup"><span data-stu-id="64c43-283">The first regular expression uses backtracking to attempt to match a string that contains one or more occurrences of one or more hexadecimal digits, followed by a colon, followed by one or more hexadecimal digits, followed by two colons.</span></span> <span data-ttu-id="64c43-284">Druhý regulární výraz je shodný s prvním výrazem, s výjimkou toho, že zakáže mechanismus navracení.</span><span class="sxs-lookup"><span data-stu-id="64c43-284">The second regular expression is identical to the first, except that it disables backtracking.</span></span> <span data-ttu-id="64c43-285">Výstup z příkladu ukazuje, že zlepšení výkonu plynoucí ze zakázání mechanismu navracení je značné.</span><span class="sxs-lookup"><span data-stu-id="64c43-285">As the output from the example shows, the performance improvement from disabling backtracking is significant.</span></span>  
  
 [!code-csharp[Conceptual.RegularExpressions.Backtracking#4](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/cs/backtracking4.cs#4)]
 [!code-vb[Conceptual.RegularExpressions.Backtracking#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/vb/backtracking4.vb#4)]  

### <a name="lookbehind-assertions"></a><span data-ttu-id="64c43-286">Kontrolní výrazy zpětného vyhledávání</span><span class="sxs-lookup"><span data-stu-id="64c43-286">Lookbehind Assertions</span></span>  
 <span data-ttu-id="64c43-287">Rozhraní .NET obsahuje dva prvky jazyka, dílčí `(?<=` *výraz* `)` a dílčí `(?<!` *výraz* `)` , které odpovídají předchozímu znaku nebo znakům ve vstupním řetězci.</span><span class="sxs-lookup"><span data-stu-id="64c43-287">.NET includes two language elements, `(?<=`*subexpression*`)` and `(?<!`*subexpression*`)`, that match the previous character or characters in the input string.</span></span> <span data-ttu-id="64c43-288">Oba prvky jazyka jsou kontrolní výrazy s nulovou šířkou; To znamená, že určují, zda znak nebo znaky, které bezprostředně předcházejí aktuálnímu znaku, mohou odpovídat *podvýrazu*bez posunutí nebo navrácení.</span><span class="sxs-lookup"><span data-stu-id="64c43-288">Both language elements are zero-width assertions; that is, they determine whether the character or characters that immediately precede the current character can be matched by *subexpression*, without advancing or backtracking.</span></span>  
  
 <span data-ttu-id="64c43-289">`(?<=`dílčí *výraz* `)` je kontrolní výraz pozitivního zpětného vyhledávání; To znamená, že znak nebo znaky před aktuální pozicí se musí shodovat s *podvýrazem*.</span><span class="sxs-lookup"><span data-stu-id="64c43-289">`(?<=` *subexpression* `)` is a positive lookbehind assertion; that is, the character or characters before the current position must match *subexpression*.</span></span> <span data-ttu-id="64c43-290">`(?<!`dílčí *výraz* `)` je kontrolní výraz negativního zpětného vyhledávání; To znamená, že znak nebo znaky před aktuální pozicí nesmí odpovídat dílčímu *výrazu*.</span><span class="sxs-lookup"><span data-stu-id="64c43-290">`(?<!`*subexpression*`)` is a negative lookbehind assertion; that is, the character or characters before the current position must not match *subexpression*.</span></span> <span data-ttu-id="64c43-291">Kontrolní výrazy pozitivního i negativního zpětného vyhledávání jsou nejužitečnější, pokud je dílčí *výraz* podmnožinou předchozího dílčího výrazu.</span><span class="sxs-lookup"><span data-stu-id="64c43-291">Both positive and negative lookbehind assertions are most useful when *subexpression* is a subset of the previous subexpression.</span></span>  
  
 <span data-ttu-id="64c43-292">Následující příklad používá dva ekvivalentní vzory regulárních výrazů, které ověřují uživatelské jméno v e-mailové adrese.</span><span class="sxs-lookup"><span data-stu-id="64c43-292">The following example uses two equivalent regular expression patterns that validate the user name in an email address.</span></span> <span data-ttu-id="64c43-293">První vzor je ovlivněn nízkým výkonem z důvodu nadměrného používání mechanismu navracení.</span><span class="sxs-lookup"><span data-stu-id="64c43-293">The first pattern is subject to poor performance because of excessive backtracking.</span></span> <span data-ttu-id="64c43-294">Druhý vzor upraví první regulární výraz nahrazením vnořeného kvantifikátoru kontrolním výrazem pozitivního zpětného vyhledávání.</span><span class="sxs-lookup"><span data-stu-id="64c43-294">The second pattern modifies the first regular expression by replacing a nested quantifier with a positive lookbehind assertion.</span></span> <span data-ttu-id="64c43-295">Výstup z příkladu zobrazuje dobu provádění <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="64c43-295">The output from the example displays the execution time of the <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> method.</span></span>  
  
 [!code-csharp[Conceptual.RegularExpressions.Backtracking#5](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/cs/backtracking5.cs#5)]
 [!code-vb[Conceptual.RegularExpressions.Backtracking#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/vb/backtracking5.vb#5)]  
  
 <span data-ttu-id="64c43-296">První vzor regulárního výrazu `^[0-9A-Z]([-.\w]*[0-9A-Z])*@` je definován tak, jak je uvedeno v následující tabulce.</span><span class="sxs-lookup"><span data-stu-id="64c43-296">The first regular expression pattern, `^[0-9A-Z]([-.\w]*[0-9A-Z])*@`, is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="64c43-297">Vzor</span><span class="sxs-lookup"><span data-stu-id="64c43-297">Pattern</span></span>|<span data-ttu-id="64c43-298">Popis</span><span class="sxs-lookup"><span data-stu-id="64c43-298">Description</span></span>|  
|-------------|-----------------|  
|`^`|<span data-ttu-id="64c43-299">Zahájí porovnávání na začátku řetězce.</span><span class="sxs-lookup"><span data-stu-id="64c43-299">Start the match at the beginning of the string.</span></span>|  
|`[0-9A-Z]`|<span data-ttu-id="64c43-300">Porovná alfanumerický znak.</span><span class="sxs-lookup"><span data-stu-id="64c43-300">Match an alphanumeric character.</span></span> <span data-ttu-id="64c43-301">U tohoto porovnání se nerozlišují malá a velká písmena, protože <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> Metoda je volána s <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> možností.</span><span class="sxs-lookup"><span data-stu-id="64c43-301">This comparison is case-insensitive, because the <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> method is called with the <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> option.</span></span>|  
|`[-.\w]*`|<span data-ttu-id="64c43-302">Porovná žádný či jeden výskyt nebo několik výskytů spojovníku, tečky nebo znaku slova.</span><span class="sxs-lookup"><span data-stu-id="64c43-302">Match zero, one, or more occurrences of a hyphen, period, or word character.</span></span>|  
|`[0-9A-Z]`|<span data-ttu-id="64c43-303">Porovná alfanumerický znak.</span><span class="sxs-lookup"><span data-stu-id="64c43-303">Match an alphanumeric character.</span></span>|  
|`([-.\w]*[0-9A-Z])*`|<span data-ttu-id="64c43-304">Porovná žádný výskyt nebo několik výskytů kombinace nuly nebo několika spojovníků, teček či znaků slova, následovaných alfanumerickým znakem.</span><span class="sxs-lookup"><span data-stu-id="64c43-304">Match zero or more occurrences of the combination of zero or more hyphens, periods, or word characters, followed by an alphanumeric character.</span></span> <span data-ttu-id="64c43-305">Toto je první zachytávající skupina.</span><span class="sxs-lookup"><span data-stu-id="64c43-305">This is the first capturing group.</span></span>|  
|`@`|<span data-ttu-id="64c43-306">Porovná symbol při přihlášení (" \@ ").</span><span class="sxs-lookup"><span data-stu-id="64c43-306">Match an at sign ("\@").</span></span>|  
  
 <span data-ttu-id="64c43-307">Druhý vzor regulárního výrazu, `^[0-9A-Z][-.\w]*(?<=[0-9A-Z])@` používá kontrolní výraz pozitivního zpětného vyhledávání.</span><span class="sxs-lookup"><span data-stu-id="64c43-307">The second regular expression pattern, `^[0-9A-Z][-.\w]*(?<=[0-9A-Z])@`, uses a positive lookbehind assertion.</span></span> <span data-ttu-id="64c43-308">Je definován tak, jak je uvedeno v následující tabulce.</span><span class="sxs-lookup"><span data-stu-id="64c43-308">It is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="64c43-309">Vzor</span><span class="sxs-lookup"><span data-stu-id="64c43-309">Pattern</span></span>|<span data-ttu-id="64c43-310">Popis</span><span class="sxs-lookup"><span data-stu-id="64c43-310">Description</span></span>|  
|-------------|-----------------|  
|`^`|<span data-ttu-id="64c43-311">Zahájí porovnávání na začátku řetězce.</span><span class="sxs-lookup"><span data-stu-id="64c43-311">Start the match at the beginning of the string.</span></span>|  
|`[0-9A-Z]`|<span data-ttu-id="64c43-312">Porovná alfanumerický znak.</span><span class="sxs-lookup"><span data-stu-id="64c43-312">Match an alphanumeric character.</span></span> <span data-ttu-id="64c43-313">U tohoto porovnání se nerozlišují malá a velká písmena, protože <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> Metoda je volána s <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> možností.</span><span class="sxs-lookup"><span data-stu-id="64c43-313">This comparison is case-insensitive, because the <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> method is called with the <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> option.</span></span>|  
|`[-.\w]*`|<span data-ttu-id="64c43-314">Porovná žádný výskyt nebo několik výskytů spojovníku, tečky nebo znaku slova.</span><span class="sxs-lookup"><span data-stu-id="64c43-314">Match zero or more occurrences of a hyphen, period, or word character.</span></span>|  
|`(?<=[0-9A-Z])`|<span data-ttu-id="64c43-315">Ověří poslední shodující se znak a pokračuje v porovnání, pokud se jedná o znak alfanumerický.</span><span class="sxs-lookup"><span data-stu-id="64c43-315">Look back at the last matched character and continue the match if it is alphanumeric.</span></span> <span data-ttu-id="64c43-316">Alfanumerické znaky jsou podmnožinou množiny, která sestává z teček, spojovníků a znaků slov.</span><span class="sxs-lookup"><span data-stu-id="64c43-316">Note that alphanumeric characters are a subset of the set that consists of periods, hyphens, and all word characters.</span></span>|  
|`@`|<span data-ttu-id="64c43-317">Porovná symbol při přihlášení (" \@ ").</span><span class="sxs-lookup"><span data-stu-id="64c43-317">Match an at sign ("\@").</span></span>|  

### <a name="lookahead-assertions"></a><span data-ttu-id="64c43-318">Kontrolní výrazy dopředného vyhledávání</span><span class="sxs-lookup"><span data-stu-id="64c43-318">Lookahead Assertions</span></span>  
 <span data-ttu-id="64c43-319">Rozhraní .NET obsahuje dva prvky jazyka, dílčí `(?=` *výraz* `)` a dílčí `(?!` *výraz* `)` , které odpovídají dalšímu znaku nebo znakům ve vstupním řetězci.</span><span class="sxs-lookup"><span data-stu-id="64c43-319">.NET includes two language elements, `(?=`*subexpression*`)` and `(?!`*subexpression*`)`, that match the next character or characters in the input string.</span></span> <span data-ttu-id="64c43-320">Oba prvky jazyka jsou kontrolní výrazy s nulovou šířkou; To znamená, že určují, zda znak nebo znaky, které bezprostředně následují za aktuálním znakem, mohou odpovídat *podvýrazu*bez posunutí nebo navrácení.</span><span class="sxs-lookup"><span data-stu-id="64c43-320">Both language elements are zero-width assertions; that is, they determine whether the character or characters that immediately follow the current character can be matched by *subexpression*, without advancing or backtracking.</span></span>  
  
 <span data-ttu-id="64c43-321">`(?=`dílčí *výraz* `)` je pozitivní kontrolní výraz dopředného vyhledávání; To znamená, že znak nebo znaky za aktuální pozicí se musí shodovat s dílčím *výrazem*.</span><span class="sxs-lookup"><span data-stu-id="64c43-321">`(?=` *subexpression* `)` is a positive lookahead assertion; that is, the character or characters after the current position must match *subexpression*.</span></span> <span data-ttu-id="64c43-322">`(?!`dílčí *výraz* `)` je negativní kontrolní výraz dopředného vyhledávání; To znamená, že znak nebo znaky za aktuální pozicí se nesmí shodovat s *podvýrazem*.</span><span class="sxs-lookup"><span data-stu-id="64c43-322">`(?!`*subexpression*`)` is a negative lookahead assertion; that is, the character or characters after the current position must not match *subexpression*.</span></span> <span data-ttu-id="64c43-323">Kladné i záporné kontrolní výrazy dopředného vyhledávání jsou nejužitečnější, pokud je dílčí *výraz* podmnožinou dalšího dílčího výrazu.</span><span class="sxs-lookup"><span data-stu-id="64c43-323">Both positive and negative lookahead assertions are most useful when *subexpression* is a subset of the next subexpression.</span></span>  
  
 <span data-ttu-id="64c43-324">Následující příklad používá dva ekvivalentní vzory regulárních výrazů, které ověřují plně kvalifikovaný název typu.</span><span class="sxs-lookup"><span data-stu-id="64c43-324">The following example uses two equivalent regular expression patterns that validate a fully qualified type name.</span></span> <span data-ttu-id="64c43-325">První vzor je ovlivněn nízkým výkonem z důvodu nadměrného používání mechanismu navracení.</span><span class="sxs-lookup"><span data-stu-id="64c43-325">The first pattern is subject to poor performance because of excessive backtracking.</span></span> <span data-ttu-id="64c43-326">Druhý vzor upraví první regulární výraz nahrazením vnořeného kvantifikátoru kontrolním výrazem pozitivního dopředného vyhledávání.</span><span class="sxs-lookup"><span data-stu-id="64c43-326">The second modifies the first regular expression by replacing a nested quantifier with a positive lookahead assertion.</span></span> <span data-ttu-id="64c43-327">Výstup z příkladu zobrazuje dobu provádění <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="64c43-327">The output from the example displays the execution time of the <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> method.</span></span>  
  
 [!code-csharp[Conceptual.RegularExpressions.Backtracking#6](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/cs/backtracking6.cs#6)]
 [!code-vb[Conceptual.RegularExpressions.Backtracking#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/vb/backtracking6.vb#6)]  
  
 <span data-ttu-id="64c43-328">První vzor regulárního výrazu `^(([A-Z]\w*)+\.)*[A-Z]\w*$` je definován tak, jak je uvedeno v následující tabulce.</span><span class="sxs-lookup"><span data-stu-id="64c43-328">The first regular expression pattern, `^(([A-Z]\w*)+\.)*[A-Z]\w*$`, is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="64c43-329">Vzor</span><span class="sxs-lookup"><span data-stu-id="64c43-329">Pattern</span></span>|<span data-ttu-id="64c43-330">Popis</span><span class="sxs-lookup"><span data-stu-id="64c43-330">Description</span></span>|  
|-------------|-----------------|  
|`^`|<span data-ttu-id="64c43-331">Zahájí porovnávání na začátku řetězce.</span><span class="sxs-lookup"><span data-stu-id="64c43-331">Start the match at the beginning of the string.</span></span>|  
|`([A-Z]\w*)+\.`|<span data-ttu-id="64c43-332">Porovná abecední znak (A-Z) následovaný žádným nebo několika znaky slova jednou nebo vícekrát, následovaných tečkou.</span><span class="sxs-lookup"><span data-stu-id="64c43-332">Match an alphabetical character (A-Z) followed by zero or more word characters one or more times, followed by a period.</span></span> <span data-ttu-id="64c43-333">U tohoto porovnání se nerozlišují malá a velká písmena, protože <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> Metoda je volána s <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> možností.</span><span class="sxs-lookup"><span data-stu-id="64c43-333">This comparison is case-insensitive, because the <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> method is called with the <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> option.</span></span>|  
|`(([A-Z]\w*)+\.)*`|<span data-ttu-id="64c43-334">Porovná předchozí vzor nulakrát nebo vícekrát.</span><span class="sxs-lookup"><span data-stu-id="64c43-334">Match the previous pattern zero or more times.</span></span>|  
|`[A-Z]\w*`|<span data-ttu-id="64c43-335">Porovná abecední znak následovaný žádným nebo několika znaky slova.</span><span class="sxs-lookup"><span data-stu-id="64c43-335">Match an alphabetical character followed by zero or more word characters.</span></span>|  
|`$`|<span data-ttu-id="64c43-336">Ukončí porovnávání na konci vstupního řetězce.</span><span class="sxs-lookup"><span data-stu-id="64c43-336">End the match at the end of the input string.</span></span>|  
  
 <span data-ttu-id="64c43-337">Druhý vzor regulárního výrazu, `^((?=[A-Z])\w+\.)*[A-Z]\w*$` používá kontrolní výraz pozitivního dopředného vyhledávání.</span><span class="sxs-lookup"><span data-stu-id="64c43-337">The second regular expression pattern, `^((?=[A-Z])\w+\.)*[A-Z]\w*$`, uses a positive lookahead assertion.</span></span> <span data-ttu-id="64c43-338">Je definován tak, jak je uvedeno v následující tabulce.</span><span class="sxs-lookup"><span data-stu-id="64c43-338">It is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="64c43-339">Vzor</span><span class="sxs-lookup"><span data-stu-id="64c43-339">Pattern</span></span>|<span data-ttu-id="64c43-340">Popis</span><span class="sxs-lookup"><span data-stu-id="64c43-340">Description</span></span>|  
|-------------|-----------------|  
|`^`|<span data-ttu-id="64c43-341">Zahájí porovnávání na začátku řetězce.</span><span class="sxs-lookup"><span data-stu-id="64c43-341">Start the match at the beginning of the string.</span></span>|  
|`(?=[A-Z])`|<span data-ttu-id="64c43-342">Ověří první znak a pokračuje v porovnávání, pokud se jedná o abecední znak (A-Z).</span><span class="sxs-lookup"><span data-stu-id="64c43-342">Look ahead to the first character and continue the match if it is alphabetical (A-Z).</span></span> <span data-ttu-id="64c43-343">U tohoto porovnání se nerozlišují malá a velká písmena, protože <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> Metoda je volána s <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> možností.</span><span class="sxs-lookup"><span data-stu-id="64c43-343">This comparison is case-insensitive, because the <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> method is called with the <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> option.</span></span>|  
|`\w+\.`|<span data-ttu-id="64c43-344">Porovná jeden nebo více znaků slova následovaných tečkou.</span><span class="sxs-lookup"><span data-stu-id="64c43-344">Match one or more word characters followed by a period.</span></span>|  
|`((?=[A-Z])\w+\.)*`|<span data-ttu-id="64c43-345">Porovná vzor jednoho nebo několika znaků slova následovaných tečkou nulakrát nebo vícekrát.</span><span class="sxs-lookup"><span data-stu-id="64c43-345">Match the pattern of one or more word characters followed by a period zero or more times.</span></span> <span data-ttu-id="64c43-346">Prvním znakem slova musí být abecední znak.</span><span class="sxs-lookup"><span data-stu-id="64c43-346">The initial word character must be alphabetical.</span></span>|  
|`[A-Z]\w*`|<span data-ttu-id="64c43-347">Porovná abecední znak následovaný žádným nebo několika znaky slova.</span><span class="sxs-lookup"><span data-stu-id="64c43-347">Match an alphabetical character followed by zero or more word characters.</span></span>|  
|`$`|<span data-ttu-id="64c43-348">Ukončí porovnávání na konci vstupního řetězce.</span><span class="sxs-lookup"><span data-stu-id="64c43-348">End the match at the end of the input string.</span></span>|  
  
## <a name="see-also"></a><span data-ttu-id="64c43-349">Viz také</span><span class="sxs-lookup"><span data-stu-id="64c43-349">See also</span></span>

- [<span data-ttu-id="64c43-350">Regulární výrazy .NET</span><span class="sxs-lookup"><span data-stu-id="64c43-350">.NET Regular Expressions</span></span>](regular-expressions.md)
- [<span data-ttu-id="64c43-351">Jazyk regulárních výrazů – stručná referenční dokumentace</span><span class="sxs-lookup"><span data-stu-id="64c43-351">Regular Expression Language - Quick Reference</span></span>](regular-expression-language-quick-reference.md)
- [<span data-ttu-id="64c43-352">Kvantifikátory</span><span class="sxs-lookup"><span data-stu-id="64c43-352">Quantifiers</span></span>](quantifiers-in-regular-expressions.md)
- [<span data-ttu-id="64c43-353">Konstrukce alternace</span><span class="sxs-lookup"><span data-stu-id="64c43-353">Alternation Constructs</span></span>](alternation-constructs-in-regular-expressions.md)
- [<span data-ttu-id="64c43-354">Seskupovací konstrukce</span><span class="sxs-lookup"><span data-stu-id="64c43-354">Grouping Constructs</span></span>](grouping-constructs-in-regular-expressions.md)
