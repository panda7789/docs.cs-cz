---
title: Seskupovací konstrukce v regulárních výrazech
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- lookbehinds
- regular expressions, grouping constructs
- lookaheads
- .NET Framework regular expressions, grouping constructs
- constructs, grouping
- grouping constructs
ms.assetid: 0fc18634-f590-4062-8d5c-f0b71abe405b
ms.openlocfilehash: 87cc3d53cf06457191d9c87020c4151e3f848c51
ms.sourcegitcommit: 011314e0c8eb4cf4a11d92078f58176c8c3efd2d
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 02/11/2020
ms.locfileid: "77124322"
---
# <a name="grouping-constructs-in-regular-expressions"></a><span data-ttu-id="bfd30-102">Seskupovací konstrukce v regulárních výrazech</span><span class="sxs-lookup"><span data-stu-id="bfd30-102">Grouping Constructs in Regular Expressions</span></span>
<span data-ttu-id="bfd30-103">Seskupovací konstrukce vymezují dílčí výrazy regulárního výrazu a zachycují podřetězce vstupního řetězce.</span><span class="sxs-lookup"><span data-stu-id="bfd30-103">Grouping constructs delineate the subexpressions of a regular expression and capture the substrings of an input string.</span></span> <span data-ttu-id="bfd30-104">Konstrukce seskupení lze použít k následujícím akcím:</span><span class="sxs-lookup"><span data-stu-id="bfd30-104">You can use grouping constructs to do the following:</span></span>  
  
- <span data-ttu-id="bfd30-105">Porovnává dílčí výraz, který se opakuje ve vstupním řetězci.</span><span class="sxs-lookup"><span data-stu-id="bfd30-105">Match a subexpression that is repeated in the input string.</span></span>  
  
- <span data-ttu-id="bfd30-106">Použijte kvantifikátor na dílčí výraz, který má více prvků jazyka regulárních výrazů.</span><span class="sxs-lookup"><span data-stu-id="bfd30-106">Apply a quantifier to a subexpression that has multiple regular expression language elements.</span></span> <span data-ttu-id="bfd30-107">Další informace o kvantifikátorech naleznete v tématu [kvantifikátory](../../../docs/standard/base-types/quantifiers-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="bfd30-107">For more information about quantifiers, see [Quantifiers](../../../docs/standard/base-types/quantifiers-in-regular-expressions.md).</span></span>  
  
- <span data-ttu-id="bfd30-108">Zahrňte dílčí výraz do řetězce, který je vrácený metodami <xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType> a <xref:System.Text.RegularExpressions.Match.Result%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="bfd30-108">Include a subexpression in the string that is returned by the <xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType> and <xref:System.Text.RegularExpressions.Match.Result%2A?displayProperty=nameWithType> methods.</span></span>  
  
- <span data-ttu-id="bfd30-109">Načte jednotlivé dílčí výrazy z vlastnosti <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> a zpracuje je odděleně od odpovídajícího textu jako celku.</span><span class="sxs-lookup"><span data-stu-id="bfd30-109">Retrieve individual subexpressions from the <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> property and process them separately from the matched text as a whole.</span></span>  
  
 <span data-ttu-id="bfd30-110">V následující tabulce jsou uvedeny seskupovací konstrukce podporované modulem regulárních výrazů .NET a označuje, zda jsou zaznamenávány nebo nejsou zaznamenávány.</span><span class="sxs-lookup"><span data-stu-id="bfd30-110">The following table lists the grouping constructs supported by the .NET regular expression engine and indicates whether they are capturing or non-capturing.</span></span>  
  
|<span data-ttu-id="bfd30-111">Seskupovací konstrukce</span><span class="sxs-lookup"><span data-stu-id="bfd30-111">Grouping construct</span></span>|<span data-ttu-id="bfd30-112">Zachycení nebo nezachycení</span><span class="sxs-lookup"><span data-stu-id="bfd30-112">Capturing or noncapturing</span></span>|  
|------------------------|-------------------------------|  
|[<span data-ttu-id="bfd30-113">Odpovídající podvýrazy</span><span class="sxs-lookup"><span data-stu-id="bfd30-113">Matched subexpressions</span></span>](#matched_subexpression)|<span data-ttu-id="bfd30-114">Zachytávání</span><span class="sxs-lookup"><span data-stu-id="bfd30-114">Capturing</span></span>|  
|[<span data-ttu-id="bfd30-115">Pojmenované odpovídající podvýrazy</span><span class="sxs-lookup"><span data-stu-id="bfd30-115">Named matched subexpressions</span></span>](#named_matched_subexpression)|<span data-ttu-id="bfd30-116">Zachytávání</span><span class="sxs-lookup"><span data-stu-id="bfd30-116">Capturing</span></span>|  
|[<span data-ttu-id="bfd30-117">Vyrovnávání definic skupin</span><span class="sxs-lookup"><span data-stu-id="bfd30-117">Balancing group definitions</span></span>](#balancing_group_definition)|<span data-ttu-id="bfd30-118">Zachytávání</span><span class="sxs-lookup"><span data-stu-id="bfd30-118">Capturing</span></span>|  
|[<span data-ttu-id="bfd30-119">Skupiny bez zachycení</span><span class="sxs-lookup"><span data-stu-id="bfd30-119">Noncapturing groups</span></span>](#noncapturing_group)|<span data-ttu-id="bfd30-120">Nezachycující</span><span class="sxs-lookup"><span data-stu-id="bfd30-120">Noncapturing</span></span>|  
|[<span data-ttu-id="bfd30-121">Možnosti skupiny</span><span class="sxs-lookup"><span data-stu-id="bfd30-121">Group options</span></span>](#group_options)|<span data-ttu-id="bfd30-122">Nezachycující</span><span class="sxs-lookup"><span data-stu-id="bfd30-122">Noncapturing</span></span>|  
|[<span data-ttu-id="bfd30-123">Pozitivní kontrolní výrazy dopředného vyhledávání s nulovou šířkou</span><span class="sxs-lookup"><span data-stu-id="bfd30-123">Zero-width positive lookahead assertions</span></span>](#zerowidth_positive_lookahead_assertion)|<span data-ttu-id="bfd30-124">Nezachycující</span><span class="sxs-lookup"><span data-stu-id="bfd30-124">Noncapturing</span></span>|  
|[<span data-ttu-id="bfd30-125">Negativní kontrolní výrazy dopředného vyhledávání s nulovou šířkou</span><span class="sxs-lookup"><span data-stu-id="bfd30-125">Zero-width negative lookahead assertions</span></span>](#zerowidth_negative_lookahead_assertion)|<span data-ttu-id="bfd30-126">Nezachycující</span><span class="sxs-lookup"><span data-stu-id="bfd30-126">Noncapturing</span></span>|  
|[<span data-ttu-id="bfd30-127">Pozitivní kontrolní výrazy zpětného vyhledávání s nulovou šířkou</span><span class="sxs-lookup"><span data-stu-id="bfd30-127">Zero-width positive lookbehind assertions</span></span>](#zerowidth_positive_lookbehind_assertion)|<span data-ttu-id="bfd30-128">Nezachycující</span><span class="sxs-lookup"><span data-stu-id="bfd30-128">Noncapturing</span></span>|  
|[<span data-ttu-id="bfd30-129">Negativní kontrolní výrazy zpětného vyhledávání s nulovou šířkou</span><span class="sxs-lookup"><span data-stu-id="bfd30-129">Zero-width negative lookbehind assertions</span></span>](#zerowidth_negative_lookbehind_assertion)|<span data-ttu-id="bfd30-130">Nezachycující</span><span class="sxs-lookup"><span data-stu-id="bfd30-130">Noncapturing</span></span>|  
|[<span data-ttu-id="bfd30-131">Atomické skupiny</span><span class="sxs-lookup"><span data-stu-id="bfd30-131">Atomic groups</span></span>](#atomic_groups)|<span data-ttu-id="bfd30-132">Nezachycující</span><span class="sxs-lookup"><span data-stu-id="bfd30-132">Noncapturing</span></span>|  
  
 <span data-ttu-id="bfd30-133">Informace o skupinách a modelu objektu regulárních výrazů naleznete v tématu [seskupovací konstrukce a objekty regulárních výrazů](#Objects).</span><span class="sxs-lookup"><span data-stu-id="bfd30-133">For information on groups and the regular expression object model, see [Grouping constructs and regular expression objects](#Objects).</span></span>  
  
<a name="matched_subexpression"></a>   
## <a name="matched-subexpressions"></a><span data-ttu-id="bfd30-134">Odpovídající podvýrazy</span><span class="sxs-lookup"><span data-stu-id="bfd30-134">Matched Subexpressions</span></span>  
 <span data-ttu-id="bfd30-135">Následující seskupovací konstrukce zachytí odpovídající dílčí výraz:</span><span class="sxs-lookup"><span data-stu-id="bfd30-135">The following grouping construct captures a matched subexpression:</span></span>  
  
 <span data-ttu-id="bfd30-136">`(` dílčí *výraz* `)`</span><span class="sxs-lookup"><span data-stu-id="bfd30-136">`(` *subexpression* `)`</span></span>  
  
 <span data-ttu-id="bfd30-137">kde dílčí *výraz* je libovolný platný vzor regulárního výrazu.</span><span class="sxs-lookup"><span data-stu-id="bfd30-137">where *subexpression* is any valid regular expression pattern.</span></span> <span data-ttu-id="bfd30-138">Zachycení, která používají kulaté závorky, jsou automaticky číslovány zleva doprava na základě pořadí otevíracích závorek v regulárním výrazu, počínaje od jednoho.</span><span class="sxs-lookup"><span data-stu-id="bfd30-138">Captures that use parentheses are numbered automatically from left to right based on the order of the opening parentheses in the regular expression, starting from one.</span></span> <span data-ttu-id="bfd30-139">Záznam s číslem nula je text, který odpovídá celému vzoru regulárního výrazu.</span><span class="sxs-lookup"><span data-stu-id="bfd30-139">The capture that is numbered zero is the text matched by the entire regular expression pattern.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="bfd30-140">Ve výchozím nastavení `(`dílčí *výraz*`)` prvek jazyka zachytí odpovídající dílčí výraz.</span><span class="sxs-lookup"><span data-stu-id="bfd30-140">By default, the `(`*subexpression*`)` language element captures the matched subexpression.</span></span> <span data-ttu-id="bfd30-141">Pokud ale parametr <xref:System.Text.RegularExpressions.RegexOptions> metody porovnávání vzorů regulárních výrazů obsahuje příznak <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture?displayProperty=nameWithType> nebo pokud je pro tento dílčí výraz použita možnost `n` (viz [Možnosti skupiny](#group_options) dále v tomto tématu), odpovídající dílčí výraz není zachycen.</span><span class="sxs-lookup"><span data-stu-id="bfd30-141">But if the <xref:System.Text.RegularExpressions.RegexOptions> parameter of a regular expression pattern matching method includes the <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture?displayProperty=nameWithType> flag, or if the `n` option is applied to this subexpression (see [Group options](#group_options) later in this topic), the matched subexpression is not captured.</span></span>  
  
 <span data-ttu-id="bfd30-142">Zachycené skupiny můžete získat čtyřmi způsoby:</span><span class="sxs-lookup"><span data-stu-id="bfd30-142">You can access captured groups in four ways:</span></span>  
  
- <span data-ttu-id="bfd30-143">Pomocí konstrukce zpětných odkazů v rámci regulárního výrazu.</span><span class="sxs-lookup"><span data-stu-id="bfd30-143">By using the backreference construct within the regular expression.</span></span> <span data-ttu-id="bfd30-144">Odpovídající dílčí výraz je odkazován ve stejném regulárním výrazu pomocí syntaxe `\`*číslo*, kde *Number* je pořadové číslo zachyceného dílčího výrazu.</span><span class="sxs-lookup"><span data-stu-id="bfd30-144">The matched subexpression is referenced in the same regular expression by using the syntax `\`*number*, where *number* is the ordinal number of the captured subexpression.</span></span>  
  
- <span data-ttu-id="bfd30-145">Pomocí pojmenované konstrukce zpětného odkazu v rámci regulárního výrazu.</span><span class="sxs-lookup"><span data-stu-id="bfd30-145">By using the named backreference construct within the regular expression.</span></span> <span data-ttu-id="bfd30-146">Odpovídající dílčí výraz je odkazován ve stejném regulárním výrazu pomocí syntaxe `\k<`*název*`>`, kde *název* je název zachytávající skupiny nebo `\k<`*číslo*`>`, kde *Number* je ordinální číslo zachytávání skupiny.</span><span class="sxs-lookup"><span data-stu-id="bfd30-146">The matched subexpression is referenced in the same regular expression by using the syntax `\k<`*name*`>`, where *name* is the name of a capturing group, or `\k<`*number*`>`, where *number* is the ordinal number of a capturing group.</span></span> <span data-ttu-id="bfd30-147">Zachytávající skupina má výchozí název, který je totožný s pořadovým číslem.</span><span class="sxs-lookup"><span data-stu-id="bfd30-147">A capturing group has a default name that is identical to its ordinal number.</span></span> <span data-ttu-id="bfd30-148">Další informace naleznete v části [pojmenované odpovídající podvýrazy](#named_matched_subexpression) dále v tomto tématu.</span><span class="sxs-lookup"><span data-stu-id="bfd30-148">For more information, see [Named matched subexpressions](#named_matched_subexpression) later in this topic.</span></span>  
  
- <span data-ttu-id="bfd30-149">Pomocí sekvence nahrazení `$`ho *čísla* ve volání metody <xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType> nebo <xref:System.Text.RegularExpressions.Match.Result%2A?displayProperty=nameWithType>, kde *Number* je pořadové číslo zachyceného dílčího výrazu.</span><span class="sxs-lookup"><span data-stu-id="bfd30-149">By using the `$`*number* replacement sequence in a <xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType> or <xref:System.Text.RegularExpressions.Match.Result%2A?displayProperty=nameWithType> method call, where *number* is the ordinal number of the captured subexpression.</span></span>  
  
- <span data-ttu-id="bfd30-150">Programově pomocí objektu <xref:System.Text.RegularExpressions.GroupCollection> vráceného vlastností <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="bfd30-150">Programmatically, by using the <xref:System.Text.RegularExpressions.GroupCollection> object returned by the <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="bfd30-151">Člen na pozici nula v kolekci představuje celou shodu regulárního výrazu.</span><span class="sxs-lookup"><span data-stu-id="bfd30-151">The member at position zero in the collection represents the entire regular expression match.</span></span> <span data-ttu-id="bfd30-152">Každý další člen představuje odpovídající dílčí výraz.</span><span class="sxs-lookup"><span data-stu-id="bfd30-152">Each subsequent member represents a matched subexpression.</span></span> <span data-ttu-id="bfd30-153">Další informace naleznete v části [seskupovací konstrukce a objekty regulárních výrazů](#Objects) .</span><span class="sxs-lookup"><span data-stu-id="bfd30-153">For more information, see the [Grouping Constructs and Regular Expression Objects](#Objects) section.</span></span>  
  
 <span data-ttu-id="bfd30-154">Následující příklad ilustruje regulární výraz, který identifikuje duplicitní slova v textu.</span><span class="sxs-lookup"><span data-stu-id="bfd30-154">The following example illustrates a regular expression that identifies duplicated words in text.</span></span> <span data-ttu-id="bfd30-155">Dvě zachytávající skupiny vzoru regulárního výrazu reprezentují dvě instance duplikovaného slova.</span><span class="sxs-lookup"><span data-stu-id="bfd30-155">The regular expression pattern's two capturing groups represent the two instances of the duplicated word.</span></span> <span data-ttu-id="bfd30-156">Druhá instance je zachycena pro hlášení počáteční pozice ve vstupním řetězci.</span><span class="sxs-lookup"><span data-stu-id="bfd30-156">The second instance is captured to report its starting position in the input string.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#1](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/grouping1.cs#1)]
 [!code-vb[RegularExpressions.Language.Grouping#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/grouping1.vb#1)]  
  
 <span data-ttu-id="bfd30-157">Vzor regulárního výrazu je následující:</span><span class="sxs-lookup"><span data-stu-id="bfd30-157">The regular expression pattern is the following:</span></span>  
  
`(\w+)\s(\1)\W`  
  
 <span data-ttu-id="bfd30-158">Následující tabulka ukazuje, jak je interpretován vzor regulárního výrazu.</span><span class="sxs-lookup"><span data-stu-id="bfd30-158">The following table shows how the regular expression pattern is interpreted.</span></span>  
  
|<span data-ttu-id="bfd30-159">Vzor</span><span class="sxs-lookup"><span data-stu-id="bfd30-159">Pattern</span></span>|<span data-ttu-id="bfd30-160">Popis</span><span class="sxs-lookup"><span data-stu-id="bfd30-160">Description</span></span>|  
|-------------|-----------------|  
|`(\w+)`|<span data-ttu-id="bfd30-161">Porovná jeden nebo více znaků slova.</span><span class="sxs-lookup"><span data-stu-id="bfd30-161">Match one or more word characters.</span></span> <span data-ttu-id="bfd30-162">Toto je první zachytávající skupina.</span><span class="sxs-lookup"><span data-stu-id="bfd30-162">This is the first capturing group.</span></span>|  
|`\s`|<span data-ttu-id="bfd30-163">Porovná prázdný znak.</span><span class="sxs-lookup"><span data-stu-id="bfd30-163">Match a white-space character.</span></span>|  
|`(\1)`|<span data-ttu-id="bfd30-164">Porovnává s řetězcem v první zachycené skupině.</span><span class="sxs-lookup"><span data-stu-id="bfd30-164">Match the string in the first captured group.</span></span> <span data-ttu-id="bfd30-165">Toto je druhá zachytávající skupina.</span><span class="sxs-lookup"><span data-stu-id="bfd30-165">This is the second capturing group.</span></span> <span data-ttu-id="bfd30-166">Tento příklad přiřadí k zachycené skupině, aby bylo možné načíst počáteční pozici duplicitního slova z vlastnosti `Match.Index`.</span><span class="sxs-lookup"><span data-stu-id="bfd30-166">The example assigns it to a captured group so that the starting position of the duplicate word can be retrieved from the `Match.Index` property.</span></span>|  
|`\W`|<span data-ttu-id="bfd30-167">Porovnává znak, který není slovní, včetně mezer a interpunkce.</span><span class="sxs-lookup"><span data-stu-id="bfd30-167">Match a non-word character, including white space and punctuation.</span></span> <span data-ttu-id="bfd30-168">To brání vzoru regulárního výrazu v porovnání s slovem, které začíná slovem z první zachycené skupiny.</span><span class="sxs-lookup"><span data-stu-id="bfd30-168">This prevents the regular expression pattern from matching a word that starts with the word from the first captured group.</span></span>|  
  
<a name="named_matched_subexpression"></a>   
## <a name="named-matched-subexpressions"></a><span data-ttu-id="bfd30-169">Pojmenované odpovídající podvýrazy</span><span class="sxs-lookup"><span data-stu-id="bfd30-169">Named Matched Subexpressions</span></span>  
 <span data-ttu-id="bfd30-170">Následující seskupovací konstrukce zachytí odpovídající dílčí výraz a umožní vám k němu přistupovat podle názvu nebo čísla:</span><span class="sxs-lookup"><span data-stu-id="bfd30-170">The following grouping construct captures a matched subexpression and lets you access it by name or by number:</span></span>  
  
`(?<name>subexpression)`  
  
 <span data-ttu-id="bfd30-171">nebo:</span><span class="sxs-lookup"><span data-stu-id="bfd30-171">or:</span></span>  
  
`(?'name'subexpression)`  
  
 <span data-ttu-id="bfd30-172">kde *Name* je platný název skupiny a dílčí *výraz* je libovolný platný vzor regulárního výrazu.</span><span class="sxs-lookup"><span data-stu-id="bfd30-172">where *name* is a valid group name, and *subexpression* is any valid regular expression pattern.</span></span> <span data-ttu-id="bfd30-173">*název* nesmí obsahovat žádné znaky interpunkce a nesmí začínat číslicí.</span><span class="sxs-lookup"><span data-stu-id="bfd30-173">*name* must not contain any punctuation characters and cannot begin with a number.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="bfd30-174">Pokud parametr <xref:System.Text.RegularExpressions.RegexOptions> metody porovnávání vzorů regulárních výrazů zahrnuje příznak <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture?displayProperty=nameWithType>, nebo pokud je pro tento dílčí výraz použita možnost `n` (viz [Možnosti skupiny](#group_options) dále v tomto tématu), jediný způsob, jak zachytit dílčí výraz, je explicitně pojmenovat zachytávající skupiny.</span><span class="sxs-lookup"><span data-stu-id="bfd30-174">If the <xref:System.Text.RegularExpressions.RegexOptions> parameter of a regular expression pattern matching method includes the <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture?displayProperty=nameWithType> flag, or if the `n` option is applied to this subexpression (see [Group options](#group_options) later in this topic), the only way to capture a subexpression is to explicitly name capturing groups.</span></span>  
  
 <span data-ttu-id="bfd30-175">Pojmenované zachycené skupiny můžete získat následujícími způsoby:</span><span class="sxs-lookup"><span data-stu-id="bfd30-175">You can access named captured groups in the following ways:</span></span>  
  
- <span data-ttu-id="bfd30-176">Pomocí pojmenované konstrukce zpětného odkazu v rámci regulárního výrazu.</span><span class="sxs-lookup"><span data-stu-id="bfd30-176">By using the named backreference construct within the regular expression.</span></span> <span data-ttu-id="bfd30-177">Odpovídající dílčí výraz je odkazován ve stejném regulárním výrazu pomocí syntaxe `\k<`*název*`>`, kde *název* je název zachyceného dílčího výrazu.</span><span class="sxs-lookup"><span data-stu-id="bfd30-177">The matched subexpression is referenced in the same regular expression by using the syntax `\k<`*name*`>`, where *name* is the name of the captured subexpression.</span></span>  
  
- <span data-ttu-id="bfd30-178">Pomocí konstrukce zpětných odkazů v rámci regulárního výrazu.</span><span class="sxs-lookup"><span data-stu-id="bfd30-178">By using the backreference construct within the regular expression.</span></span> <span data-ttu-id="bfd30-179">Odpovídající dílčí výraz je odkazován ve stejném regulárním výrazu pomocí syntaxe `\`*číslo*, kde *Number* je pořadové číslo zachyceného dílčího výrazu.</span><span class="sxs-lookup"><span data-stu-id="bfd30-179">The matched subexpression is referenced in the same regular expression by using the syntax `\`*number*, where *number* is the ordinal number of the captured subexpression.</span></span> <span data-ttu-id="bfd30-180">Pojmenované odpovídající podvýrazy jsou po sobě řazeny po odpovídajících podvýrazech očíslovány zleva doprava.</span><span class="sxs-lookup"><span data-stu-id="bfd30-180">Named matched subexpressions are numbered consecutively from left to right after matched subexpressions.</span></span>  
  
- <span data-ttu-id="bfd30-181">Pomocí `${`*název*`}` sekvenci nahrazení ve volání metody <xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType> nebo <xref:System.Text.RegularExpressions.Match.Result%2A?displayProperty=nameWithType>, kde *název* je název zachyceného dílčího výrazu.</span><span class="sxs-lookup"><span data-stu-id="bfd30-181">By using the `${`*name*`}` replacement sequence in a <xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType> or <xref:System.Text.RegularExpressions.Match.Result%2A?displayProperty=nameWithType> method call, where *name* is the name of the captured subexpression.</span></span>  
  
- <span data-ttu-id="bfd30-182">Pomocí sekvence nahrazení `$`ho *čísla* ve volání metody <xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType> nebo <xref:System.Text.RegularExpressions.Match.Result%2A?displayProperty=nameWithType>, kde *Number* je pořadové číslo zachyceného dílčího výrazu.</span><span class="sxs-lookup"><span data-stu-id="bfd30-182">By using the `$`*number* replacement sequence in a <xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType> or <xref:System.Text.RegularExpressions.Match.Result%2A?displayProperty=nameWithType> method call, where *number* is the ordinal number of the captured subexpression.</span></span>  
  
- <span data-ttu-id="bfd30-183">Programově pomocí objektu <xref:System.Text.RegularExpressions.GroupCollection> vráceného vlastností <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="bfd30-183">Programmatically, by using the <xref:System.Text.RegularExpressions.GroupCollection> object returned by the <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="bfd30-184">Člen na pozici nula v kolekci představuje celou shodu regulárního výrazu.</span><span class="sxs-lookup"><span data-stu-id="bfd30-184">The member at position zero in the collection represents the entire regular expression match.</span></span> <span data-ttu-id="bfd30-185">Každý další člen představuje odpovídající dílčí výraz.</span><span class="sxs-lookup"><span data-stu-id="bfd30-185">Each subsequent member represents a matched subexpression.</span></span> <span data-ttu-id="bfd30-186">Pojmenované zachycené skupiny jsou uloženy v kolekci po číslovaných zachycených skupinách.</span><span class="sxs-lookup"><span data-stu-id="bfd30-186">Named captured groups are stored in the collection after numbered captured groups.</span></span>  
  
- <span data-ttu-id="bfd30-187">Prostřednictvím kódu programu zadáním názvu dílčího výrazu k indexeru objektu <xref:System.Text.RegularExpressions.GroupCollection> (v C#) nebo k jeho vlastnosti <xref:System.Text.RegularExpressions.GroupCollection.Item%2A> (v Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="bfd30-187">Programmatically, by providing the subexpression name to the <xref:System.Text.RegularExpressions.GroupCollection> object's indexer (in C#) or to its <xref:System.Text.RegularExpressions.GroupCollection.Item%2A> property (in Visual Basic).</span></span>  
  
 <span data-ttu-id="bfd30-188">Jednoduchý vzor regulárního výrazu ukazuje, jak číslované (nepojmenované) a pojmenované skupiny lze odkazovat buď programově nebo pomocí syntaxe regulárního výrazu.</span><span class="sxs-lookup"><span data-stu-id="bfd30-188">A simple regular expression pattern illustrates how numbered (unnamed) and named groups can be referenced either programmatically or by using regular expression language syntax.</span></span> <span data-ttu-id="bfd30-189">Regulární výraz `((?<One>abc)\d+)?(?<Two>xyz)(.*)` vytváří následující zachytávající skupiny podle čísla a podle názvu.</span><span class="sxs-lookup"><span data-stu-id="bfd30-189">The regular expression `((?<One>abc)\d+)?(?<Two>xyz)(.*)` produces the following capturing groups by number and by name.</span></span> <span data-ttu-id="bfd30-190">První zachytávající skupina (číslo 0) vždy odkazuje na celý vzor.</span><span class="sxs-lookup"><span data-stu-id="bfd30-190">The first capturing group (number 0) always refers to the entire pattern.</span></span>  
  
|<span data-ttu-id="bfd30-191">Číslo</span><span class="sxs-lookup"><span data-stu-id="bfd30-191">Number</span></span>|<span data-ttu-id="bfd30-192">Název</span><span class="sxs-lookup"><span data-stu-id="bfd30-192">Name</span></span>|<span data-ttu-id="bfd30-193">Vzor</span><span class="sxs-lookup"><span data-stu-id="bfd30-193">Pattern</span></span>|  
|------------|----------|-------------|  
|<span data-ttu-id="bfd30-194">0</span><span class="sxs-lookup"><span data-stu-id="bfd30-194">0</span></span>|<span data-ttu-id="bfd30-195">0 (výchozí název)</span><span class="sxs-lookup"><span data-stu-id="bfd30-195">0 (default name)</span></span>|`((?<One>abc)\d+)?(?<Two>xyz)(.*)`|  
|<span data-ttu-id="bfd30-196">1</span><span class="sxs-lookup"><span data-stu-id="bfd30-196">1</span></span>|<span data-ttu-id="bfd30-197">1 (výchozí název)</span><span class="sxs-lookup"><span data-stu-id="bfd30-197">1 (default name)</span></span>|`((?<One>abc)\d+)`|  
|<span data-ttu-id="bfd30-198">2</span><span class="sxs-lookup"><span data-stu-id="bfd30-198">2</span></span>|<span data-ttu-id="bfd30-199">2 (výchozí název)</span><span class="sxs-lookup"><span data-stu-id="bfd30-199">2 (default name)</span></span>|`(.*)`|  
|<span data-ttu-id="bfd30-200">3</span><span class="sxs-lookup"><span data-stu-id="bfd30-200">3</span></span>|<span data-ttu-id="bfd30-201">Jeden</span><span class="sxs-lookup"><span data-stu-id="bfd30-201">One</span></span>|`(?<One>abc)`|  
|<span data-ttu-id="bfd30-202">4</span><span class="sxs-lookup"><span data-stu-id="bfd30-202">4</span></span>|<span data-ttu-id="bfd30-203">Dva</span><span class="sxs-lookup"><span data-stu-id="bfd30-203">Two</span></span>|`(?<Two>xyz)`|  
  
 <span data-ttu-id="bfd30-204">Následující příklad ilustruje regulární výraz, který identifikuje duplicitní slova a slovo, které bezprostředně následuje po každém duplicitním slově.</span><span class="sxs-lookup"><span data-stu-id="bfd30-204">The following example illustrates a regular expression that identifies duplicated words and the word that immediately follows each duplicated word.</span></span> <span data-ttu-id="bfd30-205">Vzor regulárního výrazu definuje dva pojmenované dílčí výrazy: `duplicateWord`, které představují duplicitní slovo; a `nextWord`, který představuje slovo, které následuje za duplikovaným slovem.</span><span class="sxs-lookup"><span data-stu-id="bfd30-205">The regular expression pattern defines two named subexpressions: `duplicateWord`, which represents the duplicated word; and `nextWord`, which represents the word that follows the duplicated word.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#2](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/grouping2.cs#2)]
 [!code-vb[RegularExpressions.Language.Grouping#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/grouping2.vb#2)]  
  
 <span data-ttu-id="bfd30-206">Vzor regulárního výrazu je následující:</span><span class="sxs-lookup"><span data-stu-id="bfd30-206">The regular expression pattern is as follows:</span></span>  
  
`(?<duplicateWord>\w+)\s\k<duplicateWord>\W(?<nextWord>\w+)`  
  
 <span data-ttu-id="bfd30-207">Následující tabulka ukazuje, jak je interpretován regulární výraz.</span><span class="sxs-lookup"><span data-stu-id="bfd30-207">The following table shows how the regular expression is interpreted.</span></span>  
  
|<span data-ttu-id="bfd30-208">Vzor</span><span class="sxs-lookup"><span data-stu-id="bfd30-208">Pattern</span></span>|<span data-ttu-id="bfd30-209">Popis</span><span class="sxs-lookup"><span data-stu-id="bfd30-209">Description</span></span>|  
|-------------|-----------------|  
|`(?<duplicateWord>\w+)`|<span data-ttu-id="bfd30-210">Porovná jeden nebo více znaků slova.</span><span class="sxs-lookup"><span data-stu-id="bfd30-210">Match one or more word characters.</span></span> <span data-ttu-id="bfd30-211">Pojmenujte tuto zachytávající skupinu `duplicateWord`.</span><span class="sxs-lookup"><span data-stu-id="bfd30-211">Name this capturing group `duplicateWord`.</span></span>|  
|`\s`|<span data-ttu-id="bfd30-212">Porovná prázdný znak.</span><span class="sxs-lookup"><span data-stu-id="bfd30-212">Match a white-space character.</span></span>|  
|`\k<duplicateWord>`|<span data-ttu-id="bfd30-213">Porovnává řetězec ze zachycené skupiny s názvem `duplicateWord`.</span><span class="sxs-lookup"><span data-stu-id="bfd30-213">Match the string from the captured group that is named `duplicateWord`.</span></span>|  
|`\W`|<span data-ttu-id="bfd30-214">Porovnává znak, který není slovní, včetně mezer a interpunkce.</span><span class="sxs-lookup"><span data-stu-id="bfd30-214">Match a non-word character, including white space and punctuation.</span></span> <span data-ttu-id="bfd30-215">To brání vzoru regulárního výrazu v porovnání s slovem, které začíná slovem z první zachycené skupiny.</span><span class="sxs-lookup"><span data-stu-id="bfd30-215">This prevents the regular expression pattern from matching a word that starts with the word from the first captured group.</span></span>|  
|`(?<nextWord>\w+)`|<span data-ttu-id="bfd30-216">Porovná jeden nebo více znaků slova.</span><span class="sxs-lookup"><span data-stu-id="bfd30-216">Match one or more word characters.</span></span> <span data-ttu-id="bfd30-217">Pojmenujte tuto zachytávající skupinu `nextWord`.</span><span class="sxs-lookup"><span data-stu-id="bfd30-217">Name this capturing group `nextWord`.</span></span>|  
  
 <span data-ttu-id="bfd30-218">Všimněte si, že název skupiny se může opakovat v regulárním výrazu.</span><span class="sxs-lookup"><span data-stu-id="bfd30-218">Note that a group name can be repeated in a regular expression.</span></span> <span data-ttu-id="bfd30-219">Například je možné pro více než jednu skupinu pojmenovat `digit`, jak ukazuje následující příklad.</span><span class="sxs-lookup"><span data-stu-id="bfd30-219">For example, it is possible for more than one group to be named `digit`, as the following example illustrates.</span></span> <span data-ttu-id="bfd30-220">V případě duplicitních názvů je hodnota objektu <xref:System.Text.RegularExpressions.Group> určena posledním úspěšným zachycením ve vstupním řetězci.</span><span class="sxs-lookup"><span data-stu-id="bfd30-220">In the case of duplicate names, the value of the <xref:System.Text.RegularExpressions.Group> object is determined by the last successful capture in the input string.</span></span> <span data-ttu-id="bfd30-221"><xref:System.Text.RegularExpressions.CaptureCollection> se navíc naplní informacemi o každém zachycení, stejně jako by se jednalo o duplicitní název skupiny.</span><span class="sxs-lookup"><span data-stu-id="bfd30-221">In addition, the <xref:System.Text.RegularExpressions.CaptureCollection> is populated with information about each capture just as it would be if the group name was not duplicated.</span></span>  
  
 <span data-ttu-id="bfd30-222">V následujícím příkladu regulární výraz `\D+(?<digit>\d+)\D+(?<digit>\d+)?` obsahuje dva výskyty skupiny s názvem `digit`.</span><span class="sxs-lookup"><span data-stu-id="bfd30-222">In the following example, the regular expression `\D+(?<digit>\d+)\D+(?<digit>\d+)?` includes two occurrences of a group named `digit`.</span></span> <span data-ttu-id="bfd30-223">První `digit` pojmenovaná skupina zachycuje jeden nebo více znaků číslic.</span><span class="sxs-lookup"><span data-stu-id="bfd30-223">The first `digit` named group captures one or more digit characters.</span></span> <span data-ttu-id="bfd30-224">Druhá `digit` pojmenovaná skupina zachycuje buď žádný nebo jeden výskyt jednoho nebo více znaků číslic.</span><span class="sxs-lookup"><span data-stu-id="bfd30-224">The second `digit` named group captures either zero or one occurrence of one or more digit characters.</span></span> <span data-ttu-id="bfd30-225">Jak ukazuje výstup z příkladu, pokud druhá zachytávající skupina úspěšně odpovídá textu, hodnota tohoto textu definuje hodnotu objektu <xref:System.Text.RegularExpressions.Group>.</span><span class="sxs-lookup"><span data-stu-id="bfd30-225">As the output from the example shows, if the second capturing group successfully matches text, the value of that text defines the value of the <xref:System.Text.RegularExpressions.Group> object.</span></span> <span data-ttu-id="bfd30-226">Pokud druhá zachytávající skupina nemůže odpovídat vstupnímu řetězci, hodnota poslední úspěšné shody definuje hodnotu objektu <xref:System.Text.RegularExpressions.Group>.</span><span class="sxs-lookup"><span data-stu-id="bfd30-226">If the second capturing group cannot does not match the input string, the value of the last successful match defines the value of the <xref:System.Text.RegularExpressions.Group> object.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#12](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/duplicate1.cs#12)]
 [!code-vb[RegularExpressions.Language.Grouping#12](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/duplicate1.vb#12)]  
  
 <span data-ttu-id="bfd30-227">Následující tabulka ukazuje, jak je interpretován regulární výraz.</span><span class="sxs-lookup"><span data-stu-id="bfd30-227">The following table shows how the regular expression is interpreted.</span></span>  
  
|<span data-ttu-id="bfd30-228">Vzor</span><span class="sxs-lookup"><span data-stu-id="bfd30-228">Pattern</span></span>|<span data-ttu-id="bfd30-229">Popis</span><span class="sxs-lookup"><span data-stu-id="bfd30-229">Description</span></span>|  
|-------------|-----------------|  
|`\D+`|<span data-ttu-id="bfd30-230">Porovnává jeden nebo více znaků, které nejsou desítkové číslice.</span><span class="sxs-lookup"><span data-stu-id="bfd30-230">Match one or more non-decimal digit characters.</span></span>|  
|`(?<digit>\d+)`|<span data-ttu-id="bfd30-231">Porovnává jeden nebo více desítkových znaků.</span><span class="sxs-lookup"><span data-stu-id="bfd30-231">Match one or more decimal digit characters.</span></span> <span data-ttu-id="bfd30-232">Přiřaďte shodu k `digit` pojmenované skupině.</span><span class="sxs-lookup"><span data-stu-id="bfd30-232">Assign the match to the `digit` named group.</span></span>|  
|`\D+`|<span data-ttu-id="bfd30-233">Porovnává jeden nebo více znaků, které nejsou desítkové číslice.</span><span class="sxs-lookup"><span data-stu-id="bfd30-233">Match one or more non-decimal digit characters.</span></span>|  
|`(?<digit>\d+)?`|<span data-ttu-id="bfd30-234">Porovná žádný nebo jeden výskyt jednoho nebo více znaků desítkové číslice.</span><span class="sxs-lookup"><span data-stu-id="bfd30-234">Match zero or one occurrence of one or more decimal digit characters.</span></span> <span data-ttu-id="bfd30-235">Přiřaďte shodu k `digit` pojmenované skupině.</span><span class="sxs-lookup"><span data-stu-id="bfd30-235">Assign the match to the `digit` named group.</span></span>|  
  
<a name="balancing_group_definition"></a>   
## <a name="balancing-group-definitions"></a><span data-ttu-id="bfd30-236">Vyrovnávání definic skupin</span><span class="sxs-lookup"><span data-stu-id="bfd30-236">Balancing Group Definitions</span></span>  
 <span data-ttu-id="bfd30-237">Vyrovnávací Seskupovací definice odstraní definici dříve definované skupiny a obchodů v aktuální skupině, interval mezi dříve definovanou skupinou a aktuální skupinou.</span><span class="sxs-lookup"><span data-stu-id="bfd30-237">A balancing group definition deletes the definition of a previously defined group and stores, in the current group, the interval between the previously defined group and the current group.</span></span> <span data-ttu-id="bfd30-238">Tato seskupovací konstrukce má následující formát:</span><span class="sxs-lookup"><span data-stu-id="bfd30-238">This grouping construct has the following format:</span></span>  
  
`(?<name1-name2>subexpression)`  
  
 <span data-ttu-id="bfd30-239">nebo:</span><span class="sxs-lookup"><span data-stu-id="bfd30-239">or:</span></span>  
  
`(?'name1-name2' subexpression)`
  
 <span data-ttu-id="bfd30-240">kde *název1* je aktuální skupina (volitelné), *název2* je dříve definovaná skupina a dílčí *výraz* je libovolný platný vzor regulárního výrazu.</span><span class="sxs-lookup"><span data-stu-id="bfd30-240">where *name1* is the current group (optional), *name2* is a previously defined group, and *subexpression* is any valid regular expression pattern.</span></span> <span data-ttu-id="bfd30-241">Vyrovnávací Seskupovací definice odstraní definici *název2* a uloží interval mezi *název2* a *název1* v poli *název1*.</span><span class="sxs-lookup"><span data-stu-id="bfd30-241">The balancing group definition deletes the definition of *name2* and stores the interval between *name2* and *name1* in *name1*.</span></span> <span data-ttu-id="bfd30-242">Pokud není definována žádná skupina *název2* , porovnávání se zaznamená.</span><span class="sxs-lookup"><span data-stu-id="bfd30-242">If no *name2* group is defined, the match backtracks.</span></span> <span data-ttu-id="bfd30-243">Vzhledem k tomu, že odstranění poslední definice *název2* odhalí předchozí definici *název2*, Tato konstrukce vám umožní použít zásobník zachycení pro skupinu *název2* jako čítač pro udržení přehledu o vnořených konstrukcích, jako jsou závorky nebo otevírací a uzavírací závorky.</span><span class="sxs-lookup"><span data-stu-id="bfd30-243">Because deleting the last definition of *name2* reveals the previous definition of *name2*, this construct lets you use the stack of captures for group *name2* as a counter for keeping track of nested constructs such as parentheses or opening and closing brackets.</span></span>  
  
 <span data-ttu-id="bfd30-244">Vyrovnávací Seskupovací definice používá *název2* jako zásobník.</span><span class="sxs-lookup"><span data-stu-id="bfd30-244">The balancing group definition uses *name2* as a stack.</span></span> <span data-ttu-id="bfd30-245">Počáteční znak každé vnořené konstrukce se umístí do skupiny a do kolekce <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="bfd30-245">The beginning character of each nested construct is placed in the group and in its <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> collection.</span></span> <span data-ttu-id="bfd30-246">Při porovnání uzavíracího znaku je jeho odpovídající znak otevření ze skupiny odebrán a kolekce <xref:System.Text.RegularExpressions.Group.Captures%2A> poklesla o jednu.</span><span class="sxs-lookup"><span data-stu-id="bfd30-246">When the closing character is matched, its corresponding opening character is removed from the group, and the <xref:System.Text.RegularExpressions.Group.Captures%2A> collection is decreased by one.</span></span> <span data-ttu-id="bfd30-247">Po porovnání znaků pro otevření a ukončení všech vnořených konstrukcí je *název2* prázdné.</span><span class="sxs-lookup"><span data-stu-id="bfd30-247">After the opening and closing characters of all nested constructs have been matched, *name2* is empty.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="bfd30-248">Po úpravě regulárního výrazu v následujícím příkladu pro použití vhodného otevíracího a ukončovacího znaku vnořené konstrukce lze použít pro zpracování většiny vnořených konstrukcí, jako jsou matematické výrazy nebo řádky kódu programu, které zahrnují Vícenásobná volání vnořených metod</span><span class="sxs-lookup"><span data-stu-id="bfd30-248">After you modify the regular expression in the following example to use the appropriate opening and closing character of a nested construct, you can use it to handle most nested constructs, such as mathematical expressions or lines of program code that include multiple nested method calls.</span></span>  
  
 <span data-ttu-id="bfd30-249">V následujícím příkladu je použita definice vyrovnávací skupiny tak, aby odpovídala levou a pravou lomenou závorku (< >) ve vstupním řetězci.</span><span class="sxs-lookup"><span data-stu-id="bfd30-249">The following example uses a balancing group definition to match left and right angle brackets (<>) in an input string.</span></span> <span data-ttu-id="bfd30-250">V příkladu jsou definovány dvě pojmenované skupiny, `Open` a `Close`, které se používají jako zásobník pro sledování párů s odpovídajícími páry lomených závorek.</span><span class="sxs-lookup"><span data-stu-id="bfd30-250">The example defines two named groups, `Open` and `Close`, that are used like a stack to track matching pairs of angle brackets.</span></span> <span data-ttu-id="bfd30-251">Každá zachycená levá lomená závorka je vložena do kolekce zachycení skupiny `Open` a každá zachycená Pravá lomená závorka je vložena do kolekce zachycení `Close` skupiny.</span><span class="sxs-lookup"><span data-stu-id="bfd30-251">Each captured left angle bracket is pushed into the capture collection of the `Open` group, and each captured right angle bracket is pushed into the capture collection of the `Close` group.</span></span> <span data-ttu-id="bfd30-252">Definice vyrovnávací skupiny zajišťuje odpovídající pravou ostrou závorku pro každou levou lomenou závorku.</span><span class="sxs-lookup"><span data-stu-id="bfd30-252">The balancing group definition ensures that there is a matching right angle bracket for each left angle bracket.</span></span> <span data-ttu-id="bfd30-253">Pokud není, konečný dílčí vzor `(?(Open)(?!))`, je vyhodnocen pouze v případě, že skupina `Open` není prázdná (a proto, pokud nebyly všechny vnořené konstrukce uzavřeny).</span><span class="sxs-lookup"><span data-stu-id="bfd30-253">If there is not, the final subpattern, `(?(Open)(?!))`, is evaluated only if the `Open` group is not empty (and, therefore, if all nested constructs have not been closed).</span></span> <span data-ttu-id="bfd30-254">Pokud je výsledný dílčí vzor vyhodnocován, shoda se nezdařila, protože dílčí vzor `(?!)` je negativním kontrolním výrazem dopředného vyhledávání s nulovou šířkou, který vždy selhává.</span><span class="sxs-lookup"><span data-stu-id="bfd30-254">If the final subpattern is evaluated, the match fails, because the `(?!)` subpattern is a zero-width negative lookahead assertion that always fails.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#3](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/grouping3.cs#3)]
 [!code-vb[RegularExpressions.Language.Grouping#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/grouping3.vb#3)]  
  
 <span data-ttu-id="bfd30-255">Vzor regulárního výrazu je:</span><span class="sxs-lookup"><span data-stu-id="bfd30-255">The regular expression pattern is:</span></span>  
  
`^[^<>]*(((?'Open'<)[^<>]*)+((?'Close-Open'>)[^<>]*)+)*(?(Open)(?!))$`  
  
 <span data-ttu-id="bfd30-256">Regulární výraz je interpretován následujícím způsobem:</span><span class="sxs-lookup"><span data-stu-id="bfd30-256">The regular expression is interpreted as follows:</span></span>  
  
|<span data-ttu-id="bfd30-257">Vzor</span><span class="sxs-lookup"><span data-stu-id="bfd30-257">Pattern</span></span>|<span data-ttu-id="bfd30-258">Popis</span><span class="sxs-lookup"><span data-stu-id="bfd30-258">Description</span></span>|  
|-------------|-----------------|  
|`^`|<span data-ttu-id="bfd30-259">Začněte na začátku řetězce.</span><span class="sxs-lookup"><span data-stu-id="bfd30-259">Begin at the start of the string.</span></span>|  
|`[^<>]*`|<span data-ttu-id="bfd30-260">Porovná žádný nebo více znaků, které nejsou levou nebo pravou lomenou závorku.</span><span class="sxs-lookup"><span data-stu-id="bfd30-260">Match zero or more characters that are not left or right angle brackets.</span></span>|  
|`(?'Open'<)`|<span data-ttu-id="bfd30-261">Porovnává levou ostrou závorku a přiřadí ji do skupiny s názvem `Open`.</span><span class="sxs-lookup"><span data-stu-id="bfd30-261">Match a left angle bracket and assign it to a group named `Open`.</span></span>|  
|`[^<>]*`|<span data-ttu-id="bfd30-262">Porovná žádný nebo více znaků, které nejsou levou nebo pravou lomenou závorku.</span><span class="sxs-lookup"><span data-stu-id="bfd30-262">Match zero or more characters that are not left or right angle brackets.</span></span>|  
|`((?'Open'<)[^<>]*)+`|<span data-ttu-id="bfd30-263">Porovná jeden nebo více výskytů levé lomené závorky, za kterými následuje nula nebo více znaků, které nejsou levou nebo pravou lomenou závorku.</span><span class="sxs-lookup"><span data-stu-id="bfd30-263">Match one or more occurrences of a left angle bracket followed by zero or more characters that are not left or right angle brackets.</span></span> <span data-ttu-id="bfd30-264">Toto je druhá zachytávající skupina.</span><span class="sxs-lookup"><span data-stu-id="bfd30-264">This is the second capturing group.</span></span>|  
|`(?'Close-Open'>)`|<span data-ttu-id="bfd30-265">Porovnává pravou ostrou závorku, přiřadí podřetězec mezi `Open` skupinu a aktuální skupinou do `Close` skupiny a odstraní definici `Open` skupiny.</span><span class="sxs-lookup"><span data-stu-id="bfd30-265">Match a right angle bracket, assign the substring between the `Open` group and the current group to the `Close` group, and delete the definition of the `Open` group.</span></span>|  
|`[^<>]*`|<span data-ttu-id="bfd30-266">Porovná žádný nebo více výskytů libovolného znaku, který není levou ani pravou ostrou závorkou.</span><span class="sxs-lookup"><span data-stu-id="bfd30-266">Match zero or more occurrences of any character that is neither a left  nor a right angle bracket.</span></span>|  
|`((?'Close-Open'>)[^<>]*)+`|<span data-ttu-id="bfd30-267">Porovná jeden nebo více výskytů pravé lomené závorky, za kterými následuje nula nebo více výskytů libovolného znaku, který není levou ani pravou ostrou závorkou.</span><span class="sxs-lookup"><span data-stu-id="bfd30-267">Match one or more occurrences of a right angle bracket, followed by zero or more occurrences of any character that is neither a left nor a right angle bracket.</span></span> <span data-ttu-id="bfd30-268">Při porovnání pravé lomené závorky přiřaďte podřetězec mezi `Open` skupinou a aktuální skupinou do skupiny `Close` a odstraňte definici `Open` skupiny.</span><span class="sxs-lookup"><span data-stu-id="bfd30-268">When matching the right angle bracket, assign the substring between the `Open` group and the current group to the `Close` group, and delete the definition of the `Open` group.</span></span> <span data-ttu-id="bfd30-269">Toto je třetí zachytávající skupina.</span><span class="sxs-lookup"><span data-stu-id="bfd30-269">This is the third capturing group.</span></span>|  
|`(((?'Open'<)[^<>]*)+((?'Close-Open'>)[^<>]*)+)*`|<span data-ttu-id="bfd30-270">Porovná žádný nebo více výskytů následujícího vzoru: jeden nebo více výskytů levé lomené závorky, za kterými následuje nula nebo více znaků bez lomené závorky následované jedním nebo více výskyty pravé lomené závorky, za kterým následuje nula nebo více výskytů. mimo lomené závorky.</span><span class="sxs-lookup"><span data-stu-id="bfd30-270">Match zero or more occurrences of the following pattern: one or more occurrences of a left angle bracket, followed by zero or more non-angle bracket characters, followed by one or more occurrences of a right angle bracket, followed by zero or more occurrences of non-angle brackets.</span></span> <span data-ttu-id="bfd30-271">Při porovnání pravé lomené závorky odstraňte definici `Open` skupiny a podřetězec mezi `Open` skupinou a aktuální skupinou přiřaďte do skupiny `Close`.</span><span class="sxs-lookup"><span data-stu-id="bfd30-271">When matching the right angle bracket, delete the definition of the `Open` group, and assign the substring between the `Open` group and the current group to the `Close` group.</span></span> <span data-ttu-id="bfd30-272">Toto je první zachytávající skupina.</span><span class="sxs-lookup"><span data-stu-id="bfd30-272">This is the first capturing group.</span></span>|  
|`(?(Open)(?!))`|<span data-ttu-id="bfd30-273">Pokud `Open` skupina existuje, přenechání shody, pokud je možné spárovat prázdný řetězec, ale nezadávejte pozici modulu regulárních výrazů do řetězce.</span><span class="sxs-lookup"><span data-stu-id="bfd30-273">If the `Open` group exists, abandon the match if an empty string can be matched, but do not advance the position of the regular expression engine in the string.</span></span> <span data-ttu-id="bfd30-274">Toto je kontrolní výraz negativního dopředného vyhledávání s nulovou šířkou.</span><span class="sxs-lookup"><span data-stu-id="bfd30-274">This is a zero-width negative lookahead assertion.</span></span> <span data-ttu-id="bfd30-275">Vzhledem k tomu, že prázdný řetězec je vždy implicitně přítomen ve vstupním řetězci, tato shoda se vždy nezdařila.</span><span class="sxs-lookup"><span data-stu-id="bfd30-275">Because an empty string is always implicitly present in an input string, this match always fails.</span></span> <span data-ttu-id="bfd30-276">Selhání této shody znamená, že lomené závorky nejsou vyrovnané.</span><span class="sxs-lookup"><span data-stu-id="bfd30-276">Failure of this match indicates that the angle brackets are not balanced.</span></span>|  
|`$`|<span data-ttu-id="bfd30-277">Porovná konec vstupního řetězce.</span><span class="sxs-lookup"><span data-stu-id="bfd30-277">Match the end of the input string.</span></span>|  
  
 <span data-ttu-id="bfd30-278">Konečný dílčí výraz, `(?(Open)(?!))`, označuje, zda jsou vnořené konstrukce ve vstupním řetězci správně vyváženy (například zda je každá levá lomená závorka shodná s pravou ostrou závorkou).</span><span class="sxs-lookup"><span data-stu-id="bfd30-278">The final subexpression, `(?(Open)(?!))`, indicates whether the nesting constructs in the input string are properly balanced (for example, whether each left angle bracket is matched by a right angle bracket).</span></span> <span data-ttu-id="bfd30-279">Používá podmíněné porovnání na základě platné zachycené skupiny; Další informace naleznete v tématu [konstrukce alternace](../../../docs/standard/base-types/alternation-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="bfd30-279">It uses conditional matching based on a valid captured group; for more information, see [Alternation Constructs](../../../docs/standard/base-types/alternation-constructs-in-regular-expressions.md).</span></span> <span data-ttu-id="bfd30-280">Pokud je definována skupina `Open`, modul regulárních výrazů se pokusí porovnat dílčí výraz `(?!)` ve vstupním řetězci.</span><span class="sxs-lookup"><span data-stu-id="bfd30-280">If the `Open` group is defined, the regular expression engine attempts to match the subexpression `(?!)` in the input string.</span></span> <span data-ttu-id="bfd30-281">`Open` skupina by měla být definována pouze v případě, že vnořování konstrukcí jsou nevyvážené.</span><span class="sxs-lookup"><span data-stu-id="bfd30-281">The `Open` group should be defined only if nesting constructs are unbalanced.</span></span> <span data-ttu-id="bfd30-282">Proto by vzor, který má být porovnán ve vstupním řetězci, měl být ten, který vždy způsobí selhání shody.</span><span class="sxs-lookup"><span data-stu-id="bfd30-282">Therefore, the pattern to be matched in the input string should be one that always causes the match to fail.</span></span> <span data-ttu-id="bfd30-283">V tomto případě je `(?!)` kontrolní výraz negativního dopředného vyhledávání s nulovou šířkou, který se vždy nezdařil, protože prázdný řetězec je vždy implicitně přítomen na další pozici ve vstupním řetězci.</span><span class="sxs-lookup"><span data-stu-id="bfd30-283">In this case, `(?!)` is a zero-width negative lookahead assertion that always fails, because an empty string is always implicitly present at the next position in the input string.</span></span>  
  
 <span data-ttu-id="bfd30-284">V tomto příkladu modul regulárních výrazů vyhodnocuje vstupní řetězec "\<ABC > < mno\<XYZ > >", jak je znázorněno v následující tabulce.</span><span class="sxs-lookup"><span data-stu-id="bfd30-284">In the example, the regular expression engine evaluates the input string "\<abc><mno\<xyz>>" as shown in the following table.</span></span>  
  
|<span data-ttu-id="bfd30-285">Krok</span><span class="sxs-lookup"><span data-stu-id="bfd30-285">Step</span></span>|<span data-ttu-id="bfd30-286">Vzor</span><span class="sxs-lookup"><span data-stu-id="bfd30-286">Pattern</span></span>|<span data-ttu-id="bfd30-287">Výsledek</span><span class="sxs-lookup"><span data-stu-id="bfd30-287">Result</span></span>|  
|----------|-------------|------------|  
|<span data-ttu-id="bfd30-288">1</span><span class="sxs-lookup"><span data-stu-id="bfd30-288">1</span></span>|`^`|<span data-ttu-id="bfd30-289">Zahájí porovnávání na začátku vstupního řetězce.</span><span class="sxs-lookup"><span data-stu-id="bfd30-289">Starts the match at the beginning of the input string</span></span>|  
|<span data-ttu-id="bfd30-290">2</span><span class="sxs-lookup"><span data-stu-id="bfd30-290">2</span></span>|`[^<>]*`|<span data-ttu-id="bfd30-291">Vyhledá znaky bez lomené závorky před levou lomenou závorkou; nenajde žádné shody.</span><span class="sxs-lookup"><span data-stu-id="bfd30-291">Looks for non-angle bracket characters before the left angle bracket;finds no matches.</span></span>|  
|<span data-ttu-id="bfd30-292">3</span><span class="sxs-lookup"><span data-stu-id="bfd30-292">3</span></span>|`(((?'Open'<)`|<span data-ttu-id="bfd30-293">Porovná levou ostrou závorku v řetězci "\<ABC >" a přiřadí ji ke skupině `Open`.</span><span class="sxs-lookup"><span data-stu-id="bfd30-293">Matches the left angle bracket in "\<abc>" and assigns it to the `Open` group.</span></span>|  
|<span data-ttu-id="bfd30-294">4</span><span class="sxs-lookup"><span data-stu-id="bfd30-294">4</span></span>|`[^<>]*`|<span data-ttu-id="bfd30-295">Odpovídá "ABC".</span><span class="sxs-lookup"><span data-stu-id="bfd30-295">Matches "abc".</span></span>|  
|<span data-ttu-id="bfd30-296">5</span><span class="sxs-lookup"><span data-stu-id="bfd30-296">5</span></span>|`)+`|<span data-ttu-id="bfd30-297">"< ABC" je hodnota druhé zachycené skupiny.</span><span class="sxs-lookup"><span data-stu-id="bfd30-297">"<abc" is the value of the second captured group.</span></span><br /><br /> <span data-ttu-id="bfd30-298">Další znak ve vstupním řetězci není levá lomená závorka, takže modul regulárních výrazů nevrátí zpět do dílčího vzoru `(?'Open'<)[^<>]*)`.</span><span class="sxs-lookup"><span data-stu-id="bfd30-298">The next character in the input string is not a left angle bracket, so the regular expression engine does not loop back to the `(?'Open'<)[^<>]*)` subpattern.</span></span>|  
|<span data-ttu-id="bfd30-299">6</span><span class="sxs-lookup"><span data-stu-id="bfd30-299">6</span></span>|`((?'Close-Open'>)`|<span data-ttu-id="bfd30-300">Porovná pravou ostrou závorku v řetězci "\<ABC >", přiřadí "ABC", což je podřetězec mezi `Open` skupinou a pravou ostrou závorkou, do skupiny `Close` a odstraní aktuální hodnotu ("<") skupiny `Open`, přičemž je ponechána prázdná.</span><span class="sxs-lookup"><span data-stu-id="bfd30-300">Matches the right angle bracket in "\<abc>", assigns "abc", which is the substring between the `Open` group and the right angle bracket, to the `Close` group, and deletes the current value ("<") of the `Open` group, leaving it empty.</span></span>|  
|<span data-ttu-id="bfd30-301">7</span><span class="sxs-lookup"><span data-stu-id="bfd30-301">7</span></span>|`[^<>]*`|<span data-ttu-id="bfd30-302">Vyhledá znaky bez lomené závorky za pravou ostrou závorkou; nenajde žádné shody.</span><span class="sxs-lookup"><span data-stu-id="bfd30-302">Looks for non-angle bracket characters after the right angle bracket; finds no matches.</span></span>|  
|<span data-ttu-id="bfd30-303">8</span><span class="sxs-lookup"><span data-stu-id="bfd30-303">8</span></span>|`)+`|<span data-ttu-id="bfd30-304">Hodnota třetí zachycené skupiny je ">".</span><span class="sxs-lookup"><span data-stu-id="bfd30-304">The value of the third captured group is ">".</span></span><br /><br /> <span data-ttu-id="bfd30-305">Další znak ve vstupním řetězci není pravá lomená závorka, takže modul regulárních výrazů nevrátí zpět do dílčího vzoru `((?'Close-Open'>)[^<>]*)`.</span><span class="sxs-lookup"><span data-stu-id="bfd30-305">The next character in the input string is not a right angle bracket, so the regular expression engine does not loop back to the `((?'Close-Open'>)[^<>]*)` subpattern.</span></span>|  
|<span data-ttu-id="bfd30-306">9</span><span class="sxs-lookup"><span data-stu-id="bfd30-306">9</span></span>|`)*`|<span data-ttu-id="bfd30-307">Hodnota první zachycené skupiny je "\<ABC >".</span><span class="sxs-lookup"><span data-stu-id="bfd30-307">The value of the first captured group is "\<abc>".</span></span><br /><br /> <span data-ttu-id="bfd30-308">Dalším znakem ve vstupním řetězci je levá lomená závorka, takže modul regulárních výrazů se vrátí do `(((?'Open'<)` dílčího vzoru.</span><span class="sxs-lookup"><span data-stu-id="bfd30-308">The next character in the input string is a left  angle bracket, so the regular expression engine loops back to the `(((?'Open'<)` subpattern.</span></span>|  
|<span data-ttu-id="bfd30-309">10</span><span class="sxs-lookup"><span data-stu-id="bfd30-309">10</span></span>|`(((?'Open'<)`|<span data-ttu-id="bfd30-310">Porovná levou ostrou závorku v řetězci "\<mno" a přiřadí ji do skupiny `Open`.</span><span class="sxs-lookup"><span data-stu-id="bfd30-310">Matches the left angle bracket in "\<mno" and assigns it to the `Open` group.</span></span> <span data-ttu-id="bfd30-311"><xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> kolekce teď má jednu hodnotu "<".</span><span class="sxs-lookup"><span data-stu-id="bfd30-311">Its <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> collection now has a single value, "<".</span></span>|  
|<span data-ttu-id="bfd30-312">11</span><span class="sxs-lookup"><span data-stu-id="bfd30-312">11</span></span>|`[^<>]*`|<span data-ttu-id="bfd30-313">Odpovídá "mno".</span><span class="sxs-lookup"><span data-stu-id="bfd30-313">Matches "mno".</span></span>|  
|<span data-ttu-id="bfd30-314">12</span><span class="sxs-lookup"><span data-stu-id="bfd30-314">12</span></span>|`)+`|<span data-ttu-id="bfd30-315">"< mno" je hodnota druhé zachycené skupiny.</span><span class="sxs-lookup"><span data-stu-id="bfd30-315">"<mno" is the value of the second captured group.</span></span><br /><br /> <span data-ttu-id="bfd30-316">Dalším znakem ve vstupním řetězci je levá lomená závorka, takže modul regulárních výrazů se vrátí do `(?'Open'<)[^<>]*)` dílčího vzoru.</span><span class="sxs-lookup"><span data-stu-id="bfd30-316">The next character in the input string is an left angle bracket, so the regular expression engine loops back to the `(?'Open'<)[^<>]*)` subpattern.</span></span>|  
|<span data-ttu-id="bfd30-317">13</span><span class="sxs-lookup"><span data-stu-id="bfd30-317">13</span></span>|`(((?'Open'<)`|<span data-ttu-id="bfd30-318">Porovná levou ostrou závorku v "\<> xyz" a přiřadí ji ke skupině `Open`.</span><span class="sxs-lookup"><span data-stu-id="bfd30-318">Matches the left angle bracket in "\<xyz>" and assigns it to the `Open` group.</span></span> <span data-ttu-id="bfd30-319">Kolekce <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> skupiny `Open` nyní obsahuje dvě zachycení: levou lomenou závorku z "\<mno" a levou ostrou závorku z "\<XYZ >".</span><span class="sxs-lookup"><span data-stu-id="bfd30-319">The <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> collection of the `Open` group now includes two captures: the left angle bracket from "\<mno", and the left angle bracket from "\<xyz>".</span></span>|  
|<span data-ttu-id="bfd30-320">14</span><span class="sxs-lookup"><span data-stu-id="bfd30-320">14</span></span>|`[^<>]*`|<span data-ttu-id="bfd30-321">Odpovídá "xyz".</span><span class="sxs-lookup"><span data-stu-id="bfd30-321">Matches "xyz".</span></span>|  
|<span data-ttu-id="bfd30-322">15</span><span class="sxs-lookup"><span data-stu-id="bfd30-322">15</span></span>|`)+`|<span data-ttu-id="bfd30-323">"< xyz" je hodnota druhé zachycené skupiny.</span><span class="sxs-lookup"><span data-stu-id="bfd30-323">"<xyz" is the value of the second captured group.</span></span><br /><br /> <span data-ttu-id="bfd30-324">Další znak ve vstupním řetězci není levá lomená závorka, takže modul regulárních výrazů nevrátí zpět do dílčího vzoru `(?'Open'<)[^<>]*)`.</span><span class="sxs-lookup"><span data-stu-id="bfd30-324">The next character in the input string is not a left angle bracket, so the regular expression engine does not loop back to the `(?'Open'<)[^<>]*)` subpattern.</span></span>|  
|<span data-ttu-id="bfd30-325">16</span><span class="sxs-lookup"><span data-stu-id="bfd30-325">16</span></span>|`((?'Close-Open'>)`|<span data-ttu-id="bfd30-326">Porovná pravou ostrou závorku v\<XYZ >.</span><span class="sxs-lookup"><span data-stu-id="bfd30-326">Matches the right angle bracket in "\<xyz>".</span></span> <span data-ttu-id="bfd30-327">"xyz" přiřadí podřetězec mezi `Open` skupinou a pravou ostrou závorkou do skupiny `Close` a odstraní aktuální hodnotu skupiny `Open`.</span><span class="sxs-lookup"><span data-stu-id="bfd30-327">"xyz", assigns the substring between the `Open` group and the right angle bracket to the `Close` group, and deletes the current value of the `Open` group.</span></span> <span data-ttu-id="bfd30-328">Hodnota předchozího zachycení (levá lomená závorka v "\<mno") se stala aktuální hodnotou `Open` skupiny.</span><span class="sxs-lookup"><span data-stu-id="bfd30-328">The value of the previous capture (the left angle bracket in "\<mno") becomes the current value of the `Open` group.</span></span> <span data-ttu-id="bfd30-329">Kolekce <xref:System.Text.RegularExpressions.Group.Captures%2A> skupiny `Open` nyní obsahuje jedno zachycení, levou hranatou závorku z "\<XYZ >".</span><span class="sxs-lookup"><span data-stu-id="bfd30-329">The <xref:System.Text.RegularExpressions.Group.Captures%2A> collection of the `Open` group now includes a single capture, the left angle bracket from "\<xyz>".</span></span>|  
|<span data-ttu-id="bfd30-330">17</span><span class="sxs-lookup"><span data-stu-id="bfd30-330">17</span></span>|`[^<>]*`|<span data-ttu-id="bfd30-331">Hledá znaky, které nejsou lomené závorky. nenajde žádné shody.</span><span class="sxs-lookup"><span data-stu-id="bfd30-331">Looks for non-angle bracket characters; finds no matches.</span></span>|  
|<span data-ttu-id="bfd30-332">18</span><span class="sxs-lookup"><span data-stu-id="bfd30-332">18</span></span>|`)+`|<span data-ttu-id="bfd30-333">Hodnota třetí zachycené skupiny je ">".</span><span class="sxs-lookup"><span data-stu-id="bfd30-333">The value of the third captured group is ">".</span></span><br /><br /> <span data-ttu-id="bfd30-334">Dalším znakem ve vstupním řetězci je Pravá lomená závorka, takže modul regulárních výrazů se vrátí do `((?'Close-Open'>)[^<>]*)` dílčího vzoru.</span><span class="sxs-lookup"><span data-stu-id="bfd30-334">The next character in the input string is a right angle bracket, so the regular expression engine loops back to the `((?'Close-Open'>)[^<>]*)` subpattern.</span></span>|  
|<span data-ttu-id="bfd30-335">19</span><span class="sxs-lookup"><span data-stu-id="bfd30-335">19</span></span>|`((?'Close-Open'>)`|<span data-ttu-id="bfd30-336">Odpovídá konečné pravé lomené závorce v "XYZ > >" přiřadí "mno\<XYZ >" (podřetězec mezi skupinou `Open` a pravou ostrou závorkou) do skupiny `Close` a odstraní aktuální hodnotu skupiny `Open`.</span><span class="sxs-lookup"><span data-stu-id="bfd30-336">Matches the final right angle bracket in "xyz>>", assigns "mno\<xyz>" (the substring between the `Open` group and the right angle bracket) to the `Close` group, and deletes the current value of the `Open` group.</span></span> <span data-ttu-id="bfd30-337">`Open` skupina je teď prázdná.</span><span class="sxs-lookup"><span data-stu-id="bfd30-337">The `Open` group is now empty.</span></span>|  
|<span data-ttu-id="bfd30-338">20</span><span class="sxs-lookup"><span data-stu-id="bfd30-338">20</span></span>|`[^<>]*`|<span data-ttu-id="bfd30-339">Hledá znaky, které nejsou lomené závorky. nenajde žádné shody.</span><span class="sxs-lookup"><span data-stu-id="bfd30-339">Looks for non-angle bracket characters; finds no matches.</span></span>|  
|<span data-ttu-id="bfd30-340">21</span><span class="sxs-lookup"><span data-stu-id="bfd30-340">21</span></span>|`)+`|<span data-ttu-id="bfd30-341">Hodnota třetí zachycené skupiny je ">".</span><span class="sxs-lookup"><span data-stu-id="bfd30-341">The value of the third captured group is ">".</span></span><br /><br /> <span data-ttu-id="bfd30-342">Další znak ve vstupním řetězci není pravá lomená závorka, takže modul regulárních výrazů nevrátí zpět do dílčího vzoru `((?'Close-Open'>)[^<>]*)`.</span><span class="sxs-lookup"><span data-stu-id="bfd30-342">The next character in the input string is not a right angle bracket, so the regular expression engine does not loop back to the `((?'Close-Open'>)[^<>]*)` subpattern.</span></span>|  
|<span data-ttu-id="bfd30-343">22</span><span class="sxs-lookup"><span data-stu-id="bfd30-343">22</span></span>|`)*`|<span data-ttu-id="bfd30-344">Hodnota první zachycené skupiny je "< mno\<XYZ > >".</span><span class="sxs-lookup"><span data-stu-id="bfd30-344">The value of the first captured group is "<mno\<xyz>>".</span></span><br /><br /> <span data-ttu-id="bfd30-345">Další znak ve vstupním řetězci není levá lomená závorka, takže modul regulárních výrazů nevrátí zpět do dílčího vzoru `(((?'Open'<)`.</span><span class="sxs-lookup"><span data-stu-id="bfd30-345">The next character in the input string is not a left angle bracket, so the regular expression engine does not loop back to the `(((?'Open'<)` subpattern.</span></span>|  
|<span data-ttu-id="bfd30-346">23</span><span class="sxs-lookup"><span data-stu-id="bfd30-346">23</span></span>|`(?(Open)(?!))`|<span data-ttu-id="bfd30-347">Skupina `Open` není definována, takže se nezkouší žádná shoda.</span><span class="sxs-lookup"><span data-stu-id="bfd30-347">The `Open` group is not defined, so no match is attempted.</span></span>|  
|<span data-ttu-id="bfd30-348">24</span><span class="sxs-lookup"><span data-stu-id="bfd30-348">24</span></span>|`$`|<span data-ttu-id="bfd30-349">Odpovídá konci vstupního řetězce.</span><span class="sxs-lookup"><span data-stu-id="bfd30-349">Matches the end of the input string.</span></span>|  
  
<a name="noncapturing_group"></a>   
## <a name="noncapturing-groups"></a><span data-ttu-id="bfd30-350">Skupiny bez zachycení</span><span class="sxs-lookup"><span data-stu-id="bfd30-350">Noncapturing Groups</span></span>  
 <span data-ttu-id="bfd30-351">Následující seskupovací konstrukce nezachycuje podřetězec, který odpovídá dílčímu výrazu:</span><span class="sxs-lookup"><span data-stu-id="bfd30-351">The following grouping construct does not capture the substring that is matched by a subexpression:</span></span>  
  
`(?:subexpression)`
  
 <span data-ttu-id="bfd30-352">kde dílčí *výraz* je libovolný platný vzor regulárního výrazu.</span><span class="sxs-lookup"><span data-stu-id="bfd30-352">where *subexpression* is any valid regular expression pattern.</span></span> <span data-ttu-id="bfd30-353">Konstrukce nezachytávající skupiny se obvykle používá při použití kvantifikátoru na skupinu, ale podřetězce zachycené skupinou nejsou žádného zájmu.</span><span class="sxs-lookup"><span data-stu-id="bfd30-353">The noncapturing group construct is typically used when a quantifier is applied to a group, but the substrings captured by the group are of no interest.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="bfd30-354">Pokud regulární výraz obsahuje vnořené seskupovací konstrukce, vnější konstrukce nezachytávající skupinu se nevztahuje na vnitřní vnořené konstrukce skupiny.</span><span class="sxs-lookup"><span data-stu-id="bfd30-354">If a regular expression includes nested grouping constructs, an outer noncapturing group construct does not apply to the inner nested group constructs.</span></span>  
  
 <span data-ttu-id="bfd30-355">Následující příklad znázorňuje regulární výraz, který zahrnuje nezachytávající skupiny.</span><span class="sxs-lookup"><span data-stu-id="bfd30-355">The following example illustrates a regular expression that includes noncapturing groups.</span></span> <span data-ttu-id="bfd30-356">Všimněte si, že výstup neobsahuje žádné zachycené skupiny.</span><span class="sxs-lookup"><span data-stu-id="bfd30-356">Note that the output does not include any captured groups.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#5](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/noncapture1.cs#5)]
 [!code-vb[RegularExpressions.Language.Grouping#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/noncapture1.vb#5)]  
  
 <span data-ttu-id="bfd30-357">Regulární výraz `(?:\b(?:\w+)\W*)+\.` odpovídá větě, která je ukončena tečkou.</span><span class="sxs-lookup"><span data-stu-id="bfd30-357">The regular expression `(?:\b(?:\w+)\W*)+\.` matches a sentence that is terminated by a period.</span></span> <span data-ttu-id="bfd30-358">Vzhledem k tomu, že regulární výraz se zaměřuje na věty a ne na jednotlivá slova, seskupovací konstrukce se používají výhradně jako kvantifikátory.</span><span class="sxs-lookup"><span data-stu-id="bfd30-358">Because the regular expression focuses on sentences and not on individual words, grouping constructs are used exclusively as quantifiers.</span></span> <span data-ttu-id="bfd30-359">Vzor regulárního výrazu je interpretován tak, jak je uvedeno v následující tabulce.</span><span class="sxs-lookup"><span data-stu-id="bfd30-359">The regular expression pattern is interpreted as shown in the following table.</span></span>  
  
|<span data-ttu-id="bfd30-360">Vzor</span><span class="sxs-lookup"><span data-stu-id="bfd30-360">Pattern</span></span>|<span data-ttu-id="bfd30-361">Popis</span><span class="sxs-lookup"><span data-stu-id="bfd30-361">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="bfd30-362">Začne porovnání na hranici slova.</span><span class="sxs-lookup"><span data-stu-id="bfd30-362">Begin the match at a word boundary.</span></span>|  
|`(?:\w+)`|<span data-ttu-id="bfd30-363">Porovná jeden nebo více znaků slova.</span><span class="sxs-lookup"><span data-stu-id="bfd30-363">Match one or more word characters.</span></span> <span data-ttu-id="bfd30-364">Nepřiřazujte odpovídající text na zachycenou skupinu.</span><span class="sxs-lookup"><span data-stu-id="bfd30-364">Do not assign the matched text to a captured group.</span></span>|  
|`\W*`|<span data-ttu-id="bfd30-365">Porovná žádný nebo více znaků, které nejsou ve slovech.</span><span class="sxs-lookup"><span data-stu-id="bfd30-365">Match zero or more non-word characters.</span></span>|  
|`(?:\b(?:\w+)\W*)+`|<span data-ttu-id="bfd30-366">Porovná vzor jednoho nebo více slovních znaků počínaje hranicí slova, za nímž následuje nula nebo více znaků bez slova, jednou nebo vícekrát.</span><span class="sxs-lookup"><span data-stu-id="bfd30-366">Match the pattern of one or more word characters starting at a word boundary, followed by zero or more non-word characters, one or more times.</span></span> <span data-ttu-id="bfd30-367">Nepřiřazujte odpovídající text na zachycenou skupinu.</span><span class="sxs-lookup"><span data-stu-id="bfd30-367">Do not assign the matched text to a captured group.</span></span>|  
|`\.`|<span data-ttu-id="bfd30-368">Odpovídá tečkě.</span><span class="sxs-lookup"><span data-stu-id="bfd30-368">Match a period.</span></span>|  
  
<a name="group_options"></a>   
## <a name="group-options"></a><span data-ttu-id="bfd30-369">Možnosti skupiny</span><span class="sxs-lookup"><span data-stu-id="bfd30-369">Group Options</span></span>  
 <span data-ttu-id="bfd30-370">Následující seskupovací konstrukce aplikuje nebo zakáže zadané možnosti v rámci dílčího výrazu:</span><span class="sxs-lookup"><span data-stu-id="bfd30-370">The following grouping construct applies or disables the specified options within a subexpression:</span></span>  
  
 <span data-ttu-id="bfd30-371">`(?imnsx-imnsx:` dílčí *výraz* `)`</span><span class="sxs-lookup"><span data-stu-id="bfd30-371">`(?imnsx-imnsx:` *subexpression* `)`</span></span>  
  
 <span data-ttu-id="bfd30-372">kde dílčí *výraz* je libovolný platný vzor regulárního výrazu.</span><span class="sxs-lookup"><span data-stu-id="bfd30-372">where *subexpression* is any valid regular expression pattern.</span></span> <span data-ttu-id="bfd30-373">`(?i-s:)` například zapne nerozlišování velkých a malých písmen a zakáže jednořádkový režim.</span><span class="sxs-lookup"><span data-stu-id="bfd30-373">For example, `(?i-s:)` turns on case insensitivity and disables single-line mode.</span></span> <span data-ttu-id="bfd30-374">Další informace o vložených možnostech, které můžete zadat, najdete v tématu [Možnosti regulárních výrazů](../../../docs/standard/base-types/regular-expression-options.md).</span><span class="sxs-lookup"><span data-stu-id="bfd30-374">For more information about the inline options you can specify, see [Regular Expression Options](../../../docs/standard/base-types/regular-expression-options.md).</span></span>  
  
> [!NOTE]
> <span data-ttu-id="bfd30-375">Můžete určit možnosti, které se vztahují na celý regulární výraz místo dílčího výrazu pomocí konstruktoru <xref:System.Text.RegularExpressions.Regex?displayProperty=nameWithType> třídy nebo statické metody.</span><span class="sxs-lookup"><span data-stu-id="bfd30-375">You can specify options that apply to an entire regular expression rather than a subexpression by using a <xref:System.Text.RegularExpressions.Regex?displayProperty=nameWithType> class constructor or a static method.</span></span> <span data-ttu-id="bfd30-376">Můžete také zadat vložené možnosti, které se použijí po určitém místě regulárního výrazu pomocí konstrukce jazyka `(?imnsx-imnsx)`.</span><span class="sxs-lookup"><span data-stu-id="bfd30-376">You can also specify inline options that apply after a specific point in a regular expression by using the `(?imnsx-imnsx)` language construct.</span></span>  
  
 <span data-ttu-id="bfd30-377">Konstrukce možností skupiny není zachytávající skupina.</span><span class="sxs-lookup"><span data-stu-id="bfd30-377">The group options construct is not a capturing group.</span></span> <span data-ttu-id="bfd30-378">To znamená, že i když je část řetězce zachycená *podvýrazem* obsažena v shodě, není obsažena v zachycené skupině ani použita k naplnění objektu <xref:System.Text.RegularExpressions.GroupCollection>.</span><span class="sxs-lookup"><span data-stu-id="bfd30-378">That is, although any portion of a string that is captured by *subexpression* is included in the match, it is not included in a captured group nor used to populate the <xref:System.Text.RegularExpressions.GroupCollection> object.</span></span>  
  
 <span data-ttu-id="bfd30-379">Například regulární výraz `\b(?ix: d \w+)\s` v následujícím příkladu používá vložené možnosti v seskupovací konstrukci pro povolení porovnávání bez rozlišování velkých a malých písmen v identifikaci všech slov, která začínají písmenem "d".</span><span class="sxs-lookup"><span data-stu-id="bfd30-379">For example, the regular expression `\b(?ix: d \w+)\s` in the following example uses inline options in a grouping construct to enable case-insensitive matching and ignore pattern white space in identifying all words that begin with the letter "d".</span></span> <span data-ttu-id="bfd30-380">Regulární výraz je definován tak, jak je uvedeno v následující tabulce.</span><span class="sxs-lookup"><span data-stu-id="bfd30-380">The regular expression is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="bfd30-381">Vzor</span><span class="sxs-lookup"><span data-stu-id="bfd30-381">Pattern</span></span>|<span data-ttu-id="bfd30-382">Popis</span><span class="sxs-lookup"><span data-stu-id="bfd30-382">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="bfd30-383">Začne porovnání na hranici slova.</span><span class="sxs-lookup"><span data-stu-id="bfd30-383">Begin the match at a word boundary.</span></span>|  
|`(?ix: d \w+)`|<span data-ttu-id="bfd30-384">Použití porovnávání bez rozlišení velkých a malých písmen v tomto vzoru se shoduje s písmenem "d" následovaným jedním nebo více znaky slova.</span><span class="sxs-lookup"><span data-stu-id="bfd30-384">Using case-insensitive matching and ignoring white space in this pattern, match a "d" followed by one or more word characters.</span></span>|  
|`\s`|<span data-ttu-id="bfd30-385">Porovná prázdný znak.</span><span class="sxs-lookup"><span data-stu-id="bfd30-385">Match a white-space character.</span></span>|  
  
 [!code-csharp[Conceptual.Regex.Language.Options#8](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/example1.cs#8)]
 [!code-vb[Conceptual.Regex.Language.Options#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/example1.vb#8)]  
  
<a name="zerowidth_positive_lookahead_assertion"></a>   
## <a name="zero-width-positive-lookahead-assertions"></a><span data-ttu-id="bfd30-386">Pozitivní kontrolní výrazy dopředného vyhledávání s nulovou šířkou</span><span class="sxs-lookup"><span data-stu-id="bfd30-386">Zero-Width Positive Lookahead Assertions</span></span>  
 <span data-ttu-id="bfd30-387">Následující seskupovací konstrukce definuje kontrolní výraz pozitivního dopředného vyhledávání s nulovou šířkou:</span><span class="sxs-lookup"><span data-stu-id="bfd30-387">The following grouping construct defines a zero-width positive lookahead assertion:</span></span>  
  
 <span data-ttu-id="bfd30-388">`(?=` dílčí *výraz* `)`</span><span class="sxs-lookup"><span data-stu-id="bfd30-388">`(?=` *subexpression* `)`</span></span>  
  
 <span data-ttu-id="bfd30-389">kde dílčí *výraz* je libovolný vzor regulárního výrazu.</span><span class="sxs-lookup"><span data-stu-id="bfd30-389">where *subexpression* is any regular expression pattern.</span></span> <span data-ttu-id="bfd30-390">Aby shoda byla úspěšná, vstupní řetězec musí odpovídat vzoru regulárního výrazu v *podvýrazu*, i když odpovídající podřetězec není zahrnutý ve výsledku shody.</span><span class="sxs-lookup"><span data-stu-id="bfd30-390">For a match to be successful, the input string must match the regular expression pattern in *subexpression*, although the matched substring is not included in the match result.</span></span> <span data-ttu-id="bfd30-391">Kontrolní výraz pozitivního dopředného vyhledávání s nulovou šířkou nevrací.</span><span class="sxs-lookup"><span data-stu-id="bfd30-391">A zero-width positive lookahead assertion does not backtrack.</span></span>  
  
 <span data-ttu-id="bfd30-392">Obvykle je kontrolní výraz pozitivního dopředného vyhledávání s nulovou šířkou nalezen na konci vzoru regulárního výrazu.</span><span class="sxs-lookup"><span data-stu-id="bfd30-392">Typically, a zero-width positive lookahead assertion is found at the end of a regular expression pattern.</span></span> <span data-ttu-id="bfd30-393">Definuje podřetězec, který musí být nalezen na konci řetězce, aby došlo ke shodě, ale který by neměl být zahrnut do shody.</span><span class="sxs-lookup"><span data-stu-id="bfd30-393">It defines a substring that must be found at the end of a string for a match to occur but that should not be included in the match.</span></span> <span data-ttu-id="bfd30-394">Je to také užitečné pro zabránění nadměrnému navrácení.</span><span class="sxs-lookup"><span data-stu-id="bfd30-394">It is also useful for preventing excessive backtracking.</span></span> <span data-ttu-id="bfd30-395">Můžete použít kontrolní výraz pozitivního dopředného vyhledávání s nulovou šířkou pro zajištění, že konkrétní zachycená skupina začíná textem, který odpovídá podmnožině vzoru definované pro tuto zachycenou skupinu.</span><span class="sxs-lookup"><span data-stu-id="bfd30-395">You can use a zero-width positive lookahead assertion to ensure that a particular captured group begins with text that matches a subset of the pattern defined for that captured group.</span></span> <span data-ttu-id="bfd30-396">Například pokud zachytávající skupina odpovídá po sobě jdoucích znaků slova, můžete použít kontrolní výraz pozitivního dopředného vyhledávání s nulovou šířkou pro vyžadování prvního znaku na abecedním znaku.</span><span class="sxs-lookup"><span data-stu-id="bfd30-396">For example, if a capturing group matches consecutive word characters, you can use a zero-width positive lookahead assertion to require that the first character be an alphabetical uppercase character.</span></span>  
  
 <span data-ttu-id="bfd30-397">Následující příklad používá kontrolní výraz pozitivního dopředného vyhledávání s nulovou šířkou, aby odpovídal slovu, které předchází příkazu "is" ve vstupním řetězci.</span><span class="sxs-lookup"><span data-stu-id="bfd30-397">The following example uses a zero-width positive lookahead assertion to match the word that precedes the verb "is" in the input string.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#6](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/lookahead1.cs#6)]
 [!code-vb[RegularExpressions.Language.Grouping#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/lookahead1.vb#6)]  
  
 <span data-ttu-id="bfd30-398">Regulární výraz `\b\w+(?=\sis\b)` je interpretován tak, jak je uvedeno v následující tabulce.</span><span class="sxs-lookup"><span data-stu-id="bfd30-398">The regular expression `\b\w+(?=\sis\b)` is interpreted as shown in the following table.</span></span>  
  
|<span data-ttu-id="bfd30-399">Vzor</span><span class="sxs-lookup"><span data-stu-id="bfd30-399">Pattern</span></span>|<span data-ttu-id="bfd30-400">Popis</span><span class="sxs-lookup"><span data-stu-id="bfd30-400">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="bfd30-401">Začne porovnání na hranici slova.</span><span class="sxs-lookup"><span data-stu-id="bfd30-401">Begin the match at a word boundary.</span></span>|  
|`\w+`|<span data-ttu-id="bfd30-402">Porovná jeden nebo více znaků slova.</span><span class="sxs-lookup"><span data-stu-id="bfd30-402">Match one or more word characters.</span></span>|  
|`(?=\sis\b)`|<span data-ttu-id="bfd30-403">Určí, zda jsou znaky slova následovány prázdným znakem a řetězcem "is", který končí na hranici slova.</span><span class="sxs-lookup"><span data-stu-id="bfd30-403">Determine whether the word characters are followed by a white-space character and the string "is", which ends on a word boundary.</span></span> <span data-ttu-id="bfd30-404">V takovém případě je shoda úspěšná.</span><span class="sxs-lookup"><span data-stu-id="bfd30-404">If so, the match is successful.</span></span>|  
  
<a name="zerowidth_negative_lookahead_assertion"></a>   
## <a name="zero-width-negative-lookahead-assertions"></a><span data-ttu-id="bfd30-405">Negativní kontrolní výrazy dopředného vyhledávání s nulovou šířkou</span><span class="sxs-lookup"><span data-stu-id="bfd30-405">Zero-Width Negative Lookahead Assertions</span></span>  
 <span data-ttu-id="bfd30-406">Následující seskupovací konstrukce definuje kontrolní výraz negativního dopředného vyhledávání s nulovou šířkou:</span><span class="sxs-lookup"><span data-stu-id="bfd30-406">The following grouping construct defines a zero-width negative lookahead assertion:</span></span>  
  
 <span data-ttu-id="bfd30-407">`(?!` dílčí *výraz* `)`</span><span class="sxs-lookup"><span data-stu-id="bfd30-407">`(?!` *subexpression* `)`</span></span>  
  
 <span data-ttu-id="bfd30-408">kde dílčí *výraz* je libovolný vzor regulárního výrazu.</span><span class="sxs-lookup"><span data-stu-id="bfd30-408">where *subexpression* is any regular expression pattern.</span></span> <span data-ttu-id="bfd30-409">Aby shoda byla úspěšná, vstupní řetězec nesmí odpovídat vzoru regulárního výrazu v *podvýrazu*, i když odpovídající řetězec není zahrnutý ve výsledku shody.</span><span class="sxs-lookup"><span data-stu-id="bfd30-409">For the match to be successful, the input string must not match the regular expression pattern in *subexpression*, although the matched string is not included in the match result.</span></span>  
  
 <span data-ttu-id="bfd30-410">Negativní kontrolní výraz dopředného vyhledávání s nulovou šířkou se obvykle používá buď na začátku nebo na konci regulárního výrazu.</span><span class="sxs-lookup"><span data-stu-id="bfd30-410">A zero-width negative lookahead assertion is typically used either at the beginning or at the end of a regular expression.</span></span> <span data-ttu-id="bfd30-411">Na začátku regulárního výrazu může definovat konkrétní vzor, který by neměl být spárován, pokud začátek regulárního výrazu definuje podobný, ale obecnější vzor, který se má shodovat.</span><span class="sxs-lookup"><span data-stu-id="bfd30-411">At the beginning of a regular expression, it can define a specific pattern that should not be matched when the beginning of the regular expression defines a similar but more general pattern to be matched.</span></span> <span data-ttu-id="bfd30-412">V takovém případě se často používá k omezení zpětného navrácení.</span><span class="sxs-lookup"><span data-stu-id="bfd30-412">In this case, it is often used to limit backtracking.</span></span> <span data-ttu-id="bfd30-413">Na konci regulárního výrazu může definovat dílčí výraz, který nemůže být proveden na konci porovnávání.</span><span class="sxs-lookup"><span data-stu-id="bfd30-413">At the end of a regular expression, it can define a subexpression that cannot occur at the end of a match.</span></span>  
  
 <span data-ttu-id="bfd30-414">Následující příklad definuje regulární výraz, který používá kontrolní výraz dopředného vyhledávání s nulovou šířkou na začátku regulárního výrazu, aby odpovídal slovům, která nezačínají na "un".</span><span class="sxs-lookup"><span data-stu-id="bfd30-414">The following example defines a regular expression that uses a zero-width lookahead assertion at the beginning of the regular expression to match words that do not begin with "un".</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#7](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/negativelookahead1.cs#7)]
 [!code-vb[RegularExpressions.Language.Grouping#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/negativelookahead1.vb#7)]  
  
 <span data-ttu-id="bfd30-415">Regulární výraz `\b(?!un)\w+\b` je interpretován tak, jak je uvedeno v následující tabulce.</span><span class="sxs-lookup"><span data-stu-id="bfd30-415">The regular expression `\b(?!un)\w+\b` is interpreted as shown in the following table.</span></span>  
  
|<span data-ttu-id="bfd30-416">Vzor</span><span class="sxs-lookup"><span data-stu-id="bfd30-416">Pattern</span></span>|<span data-ttu-id="bfd30-417">Popis</span><span class="sxs-lookup"><span data-stu-id="bfd30-417">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="bfd30-418">Začne porovnání na hranici slova.</span><span class="sxs-lookup"><span data-stu-id="bfd30-418">Begin the match at a word boundary.</span></span>|  
|`(?!un)`|<span data-ttu-id="bfd30-419">Určí, zda jsou následující dva znaky "un".</span><span class="sxs-lookup"><span data-stu-id="bfd30-419">Determine whether the next two characters are "un".</span></span> <span data-ttu-id="bfd30-420">Pokud nejsou, je možné, že je shoda.</span><span class="sxs-lookup"><span data-stu-id="bfd30-420">If they are not, a match is possible.</span></span>|  
|`\w+`|<span data-ttu-id="bfd30-421">Porovná jeden nebo více znaků slova.</span><span class="sxs-lookup"><span data-stu-id="bfd30-421">Match one or more word characters.</span></span>|  
|`\b`|<span data-ttu-id="bfd30-422">Ukončí porovnání na hranici slova.</span><span class="sxs-lookup"><span data-stu-id="bfd30-422">End the match at a word boundary.</span></span>|  
  
 <span data-ttu-id="bfd30-423">Následující příklad definuje regulární výraz, který používá kontrolní výraz dopředného vyhledávání s nulovou šířkou na konci regulárního výrazu, aby odpovídal slovům, která nekončí znakem interpunkce.</span><span class="sxs-lookup"><span data-stu-id="bfd30-423">The following example defines a regular expression that uses a zero-width lookahead assertion at the end of the regular expression to match words that do not end with a punctuation character.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#8](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/negativelookahead2.cs#8)]
 [!code-vb[RegularExpressions.Language.Grouping#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/negativelookahead2.vb#8)]  
  
 <span data-ttu-id="bfd30-424">Regulární výraz `\b\w+\b(?!\p{P})` je interpretován tak, jak je uvedeno v následující tabulce.</span><span class="sxs-lookup"><span data-stu-id="bfd30-424">The regular expression `\b\w+\b(?!\p{P})` is interpreted as shown in the following table.</span></span>  
  
|<span data-ttu-id="bfd30-425">Vzor</span><span class="sxs-lookup"><span data-stu-id="bfd30-425">Pattern</span></span>|<span data-ttu-id="bfd30-426">Popis</span><span class="sxs-lookup"><span data-stu-id="bfd30-426">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="bfd30-427">Začne porovnání na hranici slova.</span><span class="sxs-lookup"><span data-stu-id="bfd30-427">Begin the match at a word boundary.</span></span>|  
|`\w+`|<span data-ttu-id="bfd30-428">Porovná jeden nebo více znaků slova.</span><span class="sxs-lookup"><span data-stu-id="bfd30-428">Match one or more word characters.</span></span>|  
|`\b`|<span data-ttu-id="bfd30-429">Ukončí porovnání na hranici slova.</span><span class="sxs-lookup"><span data-stu-id="bfd30-429">End the match at a word boundary.</span></span>|  
|`\p{P})`|<span data-ttu-id="bfd30-430">Pokud další znak není symbol interpunkce (například tečka nebo čárka), shoda se zdaří.</span><span class="sxs-lookup"><span data-stu-id="bfd30-430">If the next character is not a punctuation symbol (such as a period or a comma), the match succeeds.</span></span>|  
  
<a name="zerowidth_positive_lookbehind_assertion"></a>   
## <a name="zero-width-positive-lookbehind-assertions"></a><span data-ttu-id="bfd30-431">Pozitivní kontrolní výrazy zpětného vyhledávání s nulovou šířkou</span><span class="sxs-lookup"><span data-stu-id="bfd30-431">Zero-Width Positive Lookbehind Assertions</span></span>  
 <span data-ttu-id="bfd30-432">Následující seskupovací konstrukce definuje kontrolní výraz pozitivního zpětného vyhledávání s nulovou šířkou:</span><span class="sxs-lookup"><span data-stu-id="bfd30-432">The following grouping construct defines a zero-width positive lookbehind assertion:</span></span>  
  
 <span data-ttu-id="bfd30-433">`(?<=` dílčí *výraz* `)`</span><span class="sxs-lookup"><span data-stu-id="bfd30-433">`(?<=` *subexpression* `)`</span></span>  
  
 <span data-ttu-id="bfd30-434">kde dílčí *výraz* je libovolný vzor regulárního výrazu.</span><span class="sxs-lookup"><span data-stu-id="bfd30-434">where *subexpression* is any regular expression pattern.</span></span> <span data-ttu-id="bfd30-435">Aby byla shoda úspěšná, musí se dílčí *výraz* vyskytovat ve vstupním řetězci nalevo od aktuální pozice, i když `subexpression` není zahrnut ve výsledku shody.</span><span class="sxs-lookup"><span data-stu-id="bfd30-435">For a match to be successful, *subexpression* must occur at the input string to the left of the current position, although `subexpression` is not included in the match result.</span></span> <span data-ttu-id="bfd30-436">Kontrolní výraz pozitivního zpětného vyhledávání s nulovou šířkou nevrací.</span><span class="sxs-lookup"><span data-stu-id="bfd30-436">A zero-width positive lookbehind assertion does not backtrack.</span></span>  
  
 <span data-ttu-id="bfd30-437">Kontrolní výrazy pozitivního zpětného vyhledávání s nulovou šířkou jsou obvykle používány na začátku regulárních výrazů.</span><span class="sxs-lookup"><span data-stu-id="bfd30-437">Zero-width positive lookbehind assertions are typically used at the beginning of regular expressions.</span></span> <span data-ttu-id="bfd30-438">Vzor, který definuje, je podmínkou pro shodu, ačkoli se nejedná o součást výsledku shody.</span><span class="sxs-lookup"><span data-stu-id="bfd30-438">The pattern that they define is a precondition for a match, although it is not a part of the match result.</span></span>  
  
 <span data-ttu-id="bfd30-439">Například následující příklad odpovídá poslední dvě číslice roku pro dvacátý první století (to znamená, že číslice "20" předcházejí odpovídajícím řetězcem).</span><span class="sxs-lookup"><span data-stu-id="bfd30-439">For example, the following example matches the last two digits of the year for the twenty first century (that is, it requires that the digits "20" precede the matched string).</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#9](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/lookbehind1.cs#9)]
 [!code-vb[RegularExpressions.Language.Grouping#9](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/lookbehind1.vb#9)]  
  
 <span data-ttu-id="bfd30-440">Vzor regulárního výrazu `(?<=\b20)\d{2}\b` je interpretován tak, jak je znázorněno v následující tabulce.</span><span class="sxs-lookup"><span data-stu-id="bfd30-440">The regular expression pattern `(?<=\b20)\d{2}\b` is interpreted as shown in the following table.</span></span>  
  
|<span data-ttu-id="bfd30-441">Vzor</span><span class="sxs-lookup"><span data-stu-id="bfd30-441">Pattern</span></span>|<span data-ttu-id="bfd30-442">Popis</span><span class="sxs-lookup"><span data-stu-id="bfd30-442">Description</span></span>|  
|-------------|-----------------|  
|`\d{2}`|<span data-ttu-id="bfd30-443">Porovnává dvě desítkové číslice.</span><span class="sxs-lookup"><span data-stu-id="bfd30-443">Match two decimal digits.</span></span>|  
|`(?<=\b20)`|<span data-ttu-id="bfd30-444">Pokračovat v porovnávání, pokud se dvě desítkové číslice předcházejí desítkovými číslicemi "20" na hranici slova.</span><span class="sxs-lookup"><span data-stu-id="bfd30-444">Continue the match if the two decimal digits are preceded by the decimal digits "20" on a word boundary.</span></span>|  
|`\b`|<span data-ttu-id="bfd30-445">Ukončí porovnání na hranici slova.</span><span class="sxs-lookup"><span data-stu-id="bfd30-445">End the match at a word boundary.</span></span>|  
  
 <span data-ttu-id="bfd30-446">Kontrolní výrazy pozitivního zpětného vyhledávání s nulovou šířkou slouží také k omezení zpětného navrácení, pokud poslední znak nebo znaky v zachycené skupině musí být podmnožinou znaků, které odpovídají vzoru regulárního výrazu dané skupiny.</span><span class="sxs-lookup"><span data-stu-id="bfd30-446">Zero-width positive lookbehind assertions are also used to limit backtracking when the last character or characters in a captured group must be a subset of the characters that match that group's regular expression pattern.</span></span> <span data-ttu-id="bfd30-447">Například pokud skupina zachytává všechny po sobě jdoucí znaky slova, můžete použít kontrolní výraz pozitivního zpětného vyhledávání s nulovou šířkou pro vyžadování, aby byl poslední znak seřazený podle abecedy.</span><span class="sxs-lookup"><span data-stu-id="bfd30-447">For example, if a group captures all consecutive word characters, you can use a zero-width positive lookbehind assertion to require that the last character be alphabetical.</span></span>  
  
<a name="zerowidth_negative_lookbehind_assertion"></a>   
## <a name="zero-width-negative-lookbehind-assertions"></a><span data-ttu-id="bfd30-448">Negativní kontrolní výrazy zpětného vyhledávání s nulovou šířkou</span><span class="sxs-lookup"><span data-stu-id="bfd30-448">Zero-Width Negative Lookbehind Assertions</span></span>  
 <span data-ttu-id="bfd30-449">Následující seskupovací konstrukce definuje kontrolní výraz negativního zpětného vyhledávání s nulovou šířkou:</span><span class="sxs-lookup"><span data-stu-id="bfd30-449">The following grouping construct defines a zero-width negative lookbehind assertion:</span></span>  
  
 <span data-ttu-id="bfd30-450">`(?<!` dílčí *výraz* `)`</span><span class="sxs-lookup"><span data-stu-id="bfd30-450">`(?<!` *subexpression* `)`</span></span>  
  
 <span data-ttu-id="bfd30-451">kde dílčí *výraz* je libovolný vzor regulárního výrazu.</span><span class="sxs-lookup"><span data-stu-id="bfd30-451">where *subexpression* is any regular expression pattern.</span></span> <span data-ttu-id="bfd30-452">Aby porovnávání bylo úspěšné, nesmí se dílčí *výraz* vyskytovat ve vstupním řetězci nalevo od aktuální pozice.</span><span class="sxs-lookup"><span data-stu-id="bfd30-452">For a match to be successful, *subexpression* must not occur at the input string to the left of the current position.</span></span> <span data-ttu-id="bfd30-453">Nicméně jakýkoli podřetězec, který neodpovídá `subexpression`, není zahrnut ve výsledku shody.</span><span class="sxs-lookup"><span data-stu-id="bfd30-453">However, any substring that does not match `subexpression` is not included in the match result.</span></span>  
  
 <span data-ttu-id="bfd30-454">Negativní kontrolní výrazy zpětného vyhledávání s nulovou šířkou jsou obvykle používány na začátku regulárních výrazů.</span><span class="sxs-lookup"><span data-stu-id="bfd30-454">Zero-width negative lookbehind assertions are typically used at the beginning of regular expressions.</span></span> <span data-ttu-id="bfd30-455">Vzor, který definuje, vylučuje shodu v řetězci, který následuje.</span><span class="sxs-lookup"><span data-stu-id="bfd30-455">The pattern that they define precludes a match in the string that follows.</span></span> <span data-ttu-id="bfd30-456">Používají se také k omezení zpětného navrácení, pokud poslední znak nebo znaky v zachycené skupině nesmí být jedním nebo více znaky, které odpovídají vzoru regulárního výrazu dané skupiny.</span><span class="sxs-lookup"><span data-stu-id="bfd30-456">They are also used to limit backtracking when the last character or characters in a captured group must not be one or more of the characters that match that group's regular expression pattern.</span></span> <span data-ttu-id="bfd30-457">Například pokud skupina zachytává všechny po sobě jdoucí znaky slova, můžete použít kontrolní výraz pozitivního zpětného vyhledávání s nulovou šířkou pro vyžadování, aby poslední znak nebyl podtržítkem (\_).</span><span class="sxs-lookup"><span data-stu-id="bfd30-457">For example, if a group captures all consecutive word characters, you can use a zero-width positive lookbehind assertion to require that the last character not be an underscore (\_).</span></span>  
  
 <span data-ttu-id="bfd30-458">Následující příklad se shoduje s datem pro každý den v týdnu, který není víkend (tj. není to sobota ani neděle).</span><span class="sxs-lookup"><span data-stu-id="bfd30-458">The following example matches the date for any day of the week that is not a weekend (that is, that is neither Saturday nor Sunday).</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#10](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/negativelookbehind1.cs#10)]
 [!code-vb[RegularExpressions.Language.Grouping#10](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/negativelookbehind1.vb#10)]  
  
 <span data-ttu-id="bfd30-459">Vzor regulárního výrazu `(?<!(Saturday|Sunday) )\b\w+ \d{1,2}, \d{4}\b` je interpretován tak, jak je znázorněno v následující tabulce.</span><span class="sxs-lookup"><span data-stu-id="bfd30-459">The regular expression pattern `(?<!(Saturday|Sunday) )\b\w+ \d{1,2}, \d{4}\b` is interpreted as shown in the following table.</span></span>  
  
|<span data-ttu-id="bfd30-460">Vzor</span><span class="sxs-lookup"><span data-stu-id="bfd30-460">Pattern</span></span>|<span data-ttu-id="bfd30-461">Popis</span><span class="sxs-lookup"><span data-stu-id="bfd30-461">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="bfd30-462">Začne porovnání na hranici slova.</span><span class="sxs-lookup"><span data-stu-id="bfd30-462">Begin the match at a word boundary.</span></span>|  
|`\w+`|<span data-ttu-id="bfd30-463">Porovnává jeden nebo více slovních znaků následovaných prázdným znakem.</span><span class="sxs-lookup"><span data-stu-id="bfd30-463">Match one or more word characters followed by a white-space character.</span></span>|  
|`\d{1,2},`|<span data-ttu-id="bfd30-464">Porovnává buď jednu, nebo dvě desítkové číslice následovanou prázdným znakem a čárkou.</span><span class="sxs-lookup"><span data-stu-id="bfd30-464">Match either one or two decimal digits followed by a white-space character and a comma.</span></span>|  
|`\d{4}\b`|<span data-ttu-id="bfd30-465">Porovnává čtyři desítkové číslice a ukončí porovnávání na hranici slova.</span><span class="sxs-lookup"><span data-stu-id="bfd30-465">Match four decimal digits, and end the match at a word boundary.</span></span>|  
|<code>(?<!(Saturday&#124;Sunday) )</code>|<span data-ttu-id="bfd30-466">Pokud shoda předchází jiné než řetězce "Sobota" nebo "neděle" následovaný mezerou, shoda je úspěšná.</span><span class="sxs-lookup"><span data-stu-id="bfd30-466">If the match is preceded by something other than the strings "Saturday" or "Sunday" followed by a space, the match is successful.</span></span>|  
  
<a name="atomic_groups"></a>   
## <a name="atomic-groups"></a><span data-ttu-id="bfd30-467">Atomické skupiny</span><span class="sxs-lookup"><span data-stu-id="bfd30-467">Atomic groups</span></span>  
 <span data-ttu-id="bfd30-468">Následující seskupovací konstrukce představuje atomickou skupinu (známou v některých jiných modulech regulárních výrazů jako dílčí výraz bez mechanismu navracení, výraz atomické dílčí výrazy nebo pouze jednou):</span><span class="sxs-lookup"><span data-stu-id="bfd30-468">The following grouping construct represents an atomic group (known in some other regular expression engines as a nonbacktracking subexpression, an atomic subexpression, or a once-only subexpression):</span></span>
  
 <span data-ttu-id="bfd30-469">`(?>` dílčí *výraz* `)`</span><span class="sxs-lookup"><span data-stu-id="bfd30-469">`(?>` *subexpression* `)`</span></span>  
  
 <span data-ttu-id="bfd30-470">kde dílčí *výraz* je libovolný vzor regulárního výrazu.</span><span class="sxs-lookup"><span data-stu-id="bfd30-470">where *subexpression* is any regular expression pattern.</span></span>  
  
 <span data-ttu-id="bfd30-471">Obvykle, pokud regulární výraz obsahuje volitelný nebo alternativní odpovídající vzor a shoda není úspěšná, modul regulárních výrazů může vytvořit větve ve více směrech, aby odpovídal vstupnímu řetězci se vzorem.</span><span class="sxs-lookup"><span data-stu-id="bfd30-471">Ordinarily, if a regular expression includes an optional or alternative matching pattern and a match does not succeed, the regular expression engine can branch in multiple directions to match an input string with a pattern.</span></span> <span data-ttu-id="bfd30-472">Pokud se shoda nenajde, když vezme první větev, modul regulárních výrazů může zálohovat nebo přesměrovat do bodu, kde trvalo první shodě, a pokusit se o shodu pomocí druhé větve.</span><span class="sxs-lookup"><span data-stu-id="bfd30-472">If a match is not found when it takes the first branch, the regular expression engine can back up or backtrack to the point where it took the first match and attempt the match using the second branch.</span></span> <span data-ttu-id="bfd30-473">Tento proces může pokračovat, dokud nebudou všechny větve vyzkoušeny.</span><span class="sxs-lookup"><span data-stu-id="bfd30-473">This process can continue until all branches have been tried.</span></span>  
  
 <span data-ttu-id="bfd30-474">Konstrukce jazyka`)` `(?>`dílčího *výrazu* zakáže zpětné navrácení.</span><span class="sxs-lookup"><span data-stu-id="bfd30-474">The `(?>`*subexpression*`)` language construct disables backtracking.</span></span> <span data-ttu-id="bfd30-475">Modul regulárních výrazů bude odpovídat počtu znaků ve vstupním řetězci, jak může.</span><span class="sxs-lookup"><span data-stu-id="bfd30-475">The regular expression engine will match as many characters in the input string as it can.</span></span> <span data-ttu-id="bfd30-476">V případě, že žádná další shoda není možná, nebude při pokusu o alternativní porovnávání vzorů navázáno.</span><span class="sxs-lookup"><span data-stu-id="bfd30-476">When no further match is possible, it will not backtrack to attempt alternate pattern matches.</span></span> <span data-ttu-id="bfd30-477">(To znamená, že dílčí výraz odpovídá pouze řetězcům, které by odpovídaly samotnému dílčímu výrazu; nepokusí se porovnat řetězec na základě dílčího výrazu a všech dílčích výrazů, které následují.)</span><span class="sxs-lookup"><span data-stu-id="bfd30-477">(That is, the subexpression matches only strings that would be matched by the subexpression alone; it does not attempt to match a string based on the subexpression and any subexpressions that follow it.)</span></span>  
  
 <span data-ttu-id="bfd30-478">Tato možnost se doporučuje, pokud víte, že zpětné navrácení nebude úspěšné.</span><span class="sxs-lookup"><span data-stu-id="bfd30-478">This option is recommended if you know that backtracking will not succeed.</span></span> <span data-ttu-id="bfd30-479">Zabránění modulu regulárních výrazů v provádění zbytečných hledání zlepšuje výkon.</span><span class="sxs-lookup"><span data-stu-id="bfd30-479">Preventing the regular expression engine from performing unnecessary searching improves performance.</span></span>  
  
 <span data-ttu-id="bfd30-480">Následující příklad ukazuje, jak skupina Atom mění výsledky porovnávání vzorů.</span><span class="sxs-lookup"><span data-stu-id="bfd30-480">The following example illustrates how an atomic group modifies the results of a pattern match.</span></span> <span data-ttu-id="bfd30-481">Regulární výraz zpětného navracení úspěšně vyhledá řadu opakovaných znaků následovaných jedním dalším výskytem stejného znaku na hranici slova, ale regulární výraz bez mechanismu navrácení.</span><span class="sxs-lookup"><span data-stu-id="bfd30-481">The backtracking regular expression successfully matches a series of repeated characters followed by one more occurrence of the same character on a word boundary, but the nonbacktracking regular expression does not.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#11](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/nonbacktracking1.cs#11)]
 [!code-vb[RegularExpressions.Language.Grouping#11](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/nonbacktracking1.vb#11)]  
  
 <span data-ttu-id="bfd30-482">`(?>(\w)\1+).\b` regulární výraz nemechanismu navracení je definován tak, jak je uvedeno v následující tabulce.</span><span class="sxs-lookup"><span data-stu-id="bfd30-482">The nonbacktracking regular expression `(?>(\w)\1+).\b` is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="bfd30-483">Vzor</span><span class="sxs-lookup"><span data-stu-id="bfd30-483">Pattern</span></span>|<span data-ttu-id="bfd30-484">Popis</span><span class="sxs-lookup"><span data-stu-id="bfd30-484">Description</span></span>|  
|-------------|-----------------|  
|`(\w)`|<span data-ttu-id="bfd30-485">Porovnává s jedním slovním znakem a přiřadí ho k první zachytávající skupině.</span><span class="sxs-lookup"><span data-stu-id="bfd30-485">Match a single word character and assign it to the first capturing group.</span></span>|  
|`\1+`|<span data-ttu-id="bfd30-486">Porovnává hodnotu prvního zaznamenaného podřetězce jednou nebo vícekrát.</span><span class="sxs-lookup"><span data-stu-id="bfd30-486">Match the value of the first captured substring one or more times.</span></span>|  
|`.`|<span data-ttu-id="bfd30-487">Odpovídá jakémukoli znaku.</span><span class="sxs-lookup"><span data-stu-id="bfd30-487">Match any character.</span></span>|  
|`\b`|<span data-ttu-id="bfd30-488">Ukončí porovnávání na hranici slova.</span><span class="sxs-lookup"><span data-stu-id="bfd30-488">End the match on a word boundary.</span></span>|  
|`(?>(\w)\1+)`|<span data-ttu-id="bfd30-489">Porovnává jeden nebo více výskytů duplicitního znaku slova, ale nepoužívejte k tomu, aby se shodovala s posledním znakem na hranici slova.</span><span class="sxs-lookup"><span data-stu-id="bfd30-489">Match one or more occurrences of a duplicated word character, but do not backtrack to match the last character on a word boundary.</span></span>|  
  
<a name="Objects"></a>   
## <a name="grouping-constructs-and-regular-expression-objects"></a><span data-ttu-id="bfd30-490">Seskupovací konstrukce a objekty regulárních výrazů</span><span class="sxs-lookup"><span data-stu-id="bfd30-490">Grouping Constructs and Regular Expression Objects</span></span>  
 <span data-ttu-id="bfd30-491">Podřetězce, které jsou porovnány zachycující skupinou regulárního výrazu, jsou reprezentovány <xref:System.Text.RegularExpressions.Group?displayProperty=nameWithType> objekty, které lze načíst z objektu <xref:System.Text.RegularExpressions.GroupCollection?displayProperty=nameWithType>, který je vrácen vlastností <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="bfd30-491">Substrings that are matched by a regular expression capturing group are represented by <xref:System.Text.RegularExpressions.Group?displayProperty=nameWithType> objects, which can be retrieved from the <xref:System.Text.RegularExpressions.GroupCollection?displayProperty=nameWithType> object that is returned by the <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="bfd30-492">Objekt <xref:System.Text.RegularExpressions.GroupCollection> se vyplní následujícím způsobem:</span><span class="sxs-lookup"><span data-stu-id="bfd30-492">The <xref:System.Text.RegularExpressions.GroupCollection> object is populated as follows:</span></span>  
  
- <span data-ttu-id="bfd30-493">První objekt <xref:System.Text.RegularExpressions.Group> v kolekci (objekt na indexu nula) představuje celou shodu.</span><span class="sxs-lookup"><span data-stu-id="bfd30-493">The first <xref:System.Text.RegularExpressions.Group> object in the collection (the object at index zero) represents the entire match.</span></span>  
  
- <span data-ttu-id="bfd30-494">Další sada objektů <xref:System.Text.RegularExpressions.Group> představuje nepojmenované (očíslované) zachytávající skupiny.</span><span class="sxs-lookup"><span data-stu-id="bfd30-494">The next set of <xref:System.Text.RegularExpressions.Group> objects represent unnamed (numbered) capturing groups.</span></span> <span data-ttu-id="bfd30-495">Zobrazují se v pořadí, ve kterém jsou definované v regulárním výrazu zleva doprava.</span><span class="sxs-lookup"><span data-stu-id="bfd30-495">They appear in the order in which they are defined in the regular expression, from left to right.</span></span> <span data-ttu-id="bfd30-496">Hodnoty indexu těchto skupin jsou v rozsahu od 1 do počtu nepojmenovaných zachytávajících skupin v kolekci.</span><span class="sxs-lookup"><span data-stu-id="bfd30-496">The index values of these groups range from 1 to the number of unnamed capturing groups in the collection.</span></span> <span data-ttu-id="bfd30-497">(Index konkrétní skupiny odpovídá jeho číslovanému zpětnému odkazu.</span><span class="sxs-lookup"><span data-stu-id="bfd30-497">(The index of a particular group is equivalent to its numbered backreference.</span></span> <span data-ttu-id="bfd30-498">Další informace o zpětných odkazech naleznete v tématu [konstrukce zpětných odkazů](../../../docs/standard/base-types/backreference-constructs-in-regular-expressions.md).)</span><span class="sxs-lookup"><span data-stu-id="bfd30-498">For more information about backreferences, see [Backreference Constructs](../../../docs/standard/base-types/backreference-constructs-in-regular-expressions.md).)</span></span>  
  
- <span data-ttu-id="bfd30-499">Koncová sada objektů <xref:System.Text.RegularExpressions.Group> představuje pojmenované zachytávající skupiny.</span><span class="sxs-lookup"><span data-stu-id="bfd30-499">The final set of <xref:System.Text.RegularExpressions.Group> objects represent named capturing groups.</span></span> <span data-ttu-id="bfd30-500">Zobrazují se v pořadí, ve kterém jsou definované v regulárním výrazu zleva doprava.</span><span class="sxs-lookup"><span data-stu-id="bfd30-500">They appear in the order in which they are defined in the regular expression, from left to right.</span></span> <span data-ttu-id="bfd30-501">Hodnota indexu první pojmenované zachytávající skupiny je jedna větší než index poslední nepojmenované zachytávající skupiny.</span><span class="sxs-lookup"><span data-stu-id="bfd30-501">The index value of the first named capturing group is one greater than the index of the last unnamed capturing group.</span></span> <span data-ttu-id="bfd30-502">Pokud v regulárním výrazu nejsou žádné nepojmenované zachytávající skupiny, hodnota indexu první pojmenované zachytávající skupiny je jedna.</span><span class="sxs-lookup"><span data-stu-id="bfd30-502">If there are no unnamed capturing groups in the regular expression, the index value of the first named capturing group is one.</span></span>  
  
 <span data-ttu-id="bfd30-503">Použijete-li kvantifikátor pro zachytávající skupinu, odpovídající <xref:System.Text.RegularExpressions.Capture.Value%2A?displayProperty=nameWithType>, <xref:System.Text.RegularExpressions.Capture.Index%2A?displayProperty=nameWithType><xref:System.Text.RegularExpressions.Capture.Length%2A?displayProperty=nameWithType> a vlastnosti <xref:System.Text.RegularExpressions.Group> objektu odrážejí poslední podřetězec, který je zachycen zachytávající skupinou.</span><span class="sxs-lookup"><span data-stu-id="bfd30-503">If you apply a quantifier to a capturing group, the corresponding <xref:System.Text.RegularExpressions.Group> object's <xref:System.Text.RegularExpressions.Capture.Value%2A?displayProperty=nameWithType>, <xref:System.Text.RegularExpressions.Capture.Index%2A?displayProperty=nameWithType>, and <xref:System.Text.RegularExpressions.Capture.Length%2A?displayProperty=nameWithType> properties reflect the last substring that is captured by a capturing group.</span></span> <span data-ttu-id="bfd30-504">Můžete načíst úplnou sadu podřetězců, které jsou zachyceny skupinami, které mají kvantifikátory z objektu <xref:System.Text.RegularExpressions.CaptureCollection>, který je vrácen vlastností <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="bfd30-504">You can retrieve a complete set of substrings that are captured by groups that have quantifiers from the <xref:System.Text.RegularExpressions.CaptureCollection> object that is returned by the <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> property.</span></span>  
  
 <span data-ttu-id="bfd30-505">Následující příklad vysvětluje vztah mezi objekty <xref:System.Text.RegularExpressions.Group> a <xref:System.Text.RegularExpressions.Capture>.</span><span class="sxs-lookup"><span data-stu-id="bfd30-505">The following example clarifies the relationship between the <xref:System.Text.RegularExpressions.Group> and <xref:System.Text.RegularExpressions.Capture> objects.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#4](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/objectmodel1.cs#4)]
 [!code-vb[RegularExpressions.Language.Grouping#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/objectmodel1.vb#4)]  
  
 <span data-ttu-id="bfd30-506">Vzor regulárního výrazu `(\b(\w+)\W+)+` extrahuje jednotlivá slova z řetězce.</span><span class="sxs-lookup"><span data-stu-id="bfd30-506">The regular expression pattern `(\b(\w+)\W+)+` extracts individual words from a string.</span></span> <span data-ttu-id="bfd30-507">Je definován tak, jak je uvedeno v následující tabulce.</span><span class="sxs-lookup"><span data-stu-id="bfd30-507">It is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="bfd30-508">Vzor</span><span class="sxs-lookup"><span data-stu-id="bfd30-508">Pattern</span></span>|<span data-ttu-id="bfd30-509">Popis</span><span class="sxs-lookup"><span data-stu-id="bfd30-509">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="bfd30-510">Začne porovnání na hranici slova.</span><span class="sxs-lookup"><span data-stu-id="bfd30-510">Begin the match at a word boundary.</span></span>|  
|`(\w+)`|<span data-ttu-id="bfd30-511">Porovná jeden nebo více znaků slova.</span><span class="sxs-lookup"><span data-stu-id="bfd30-511">Match one or more word characters.</span></span> <span data-ttu-id="bfd30-512">Tyto znaky společně tvoří slovo.</span><span class="sxs-lookup"><span data-stu-id="bfd30-512">Together, these characters form a word.</span></span> <span data-ttu-id="bfd30-513">Toto je druhá zachytávající skupina.</span><span class="sxs-lookup"><span data-stu-id="bfd30-513">This is the second capturing group.</span></span>|  
|`\W+`|<span data-ttu-id="bfd30-514">Porovnává jeden nebo více znaků, které nejsou v textu.</span><span class="sxs-lookup"><span data-stu-id="bfd30-514">Match one or more non-word characters.</span></span>|  
|`(\b(\w+)\W+)`|<span data-ttu-id="bfd30-515">Porovnává vzor jednoho nebo více znaků slova následovaných jedním nebo více znaky, které jsou jednou nebo vícekrát.</span><span class="sxs-lookup"><span data-stu-id="bfd30-515">Match the pattern of one or more word characters followed by one or more non-word characters one or more times.</span></span> <span data-ttu-id="bfd30-516">Toto je první zachytávající skupina.</span><span class="sxs-lookup"><span data-stu-id="bfd30-516">This is the first capturing group.</span></span>|  
  
 <span data-ttu-id="bfd30-517">Druhá zachytávající skupina odpovídá každému slovu věty.</span><span class="sxs-lookup"><span data-stu-id="bfd30-517">The second capturing group matches each word of the sentence.</span></span> <span data-ttu-id="bfd30-518">První zachytávající skupina odpovídá jednotlivým slovům společně s interpunkčním znaménkem a prázdným znakem, který následuje za slovem.</span><span class="sxs-lookup"><span data-stu-id="bfd30-518">The first capturing group matches each word along with the punctuation and white space that follow the word.</span></span> <span data-ttu-id="bfd30-519">Objekt <xref:System.Text.RegularExpressions.Group>, jehož index je 2, poskytuje informace o textu, který odpovídá druhá zachytávající skupina.</span><span class="sxs-lookup"><span data-stu-id="bfd30-519">The <xref:System.Text.RegularExpressions.Group> object whose index is 2 provides information about the text matched by the second capturing group.</span></span> <span data-ttu-id="bfd30-520">Kompletní sada slov zachycených zachycující skupinou je k dispozici z objektu <xref:System.Text.RegularExpressions.CaptureCollection> vráceného vlastností <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="bfd30-520">The complete set of words captured by the capturing group are available from the <xref:System.Text.RegularExpressions.CaptureCollection> object returned by the <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> property.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="bfd30-521">Viz také</span><span class="sxs-lookup"><span data-stu-id="bfd30-521">See also</span></span>

- [<span data-ttu-id="bfd30-522">Jazyk regulárních výrazů – stručná referenční dokumentace</span><span class="sxs-lookup"><span data-stu-id="bfd30-522">Regular Expression Language - Quick Reference</span></span>](../../../docs/standard/base-types/regular-expression-language-quick-reference.md)
- [<span data-ttu-id="bfd30-523">Zpětné navracení</span><span class="sxs-lookup"><span data-stu-id="bfd30-523">Backtracking</span></span>](../../../docs/standard/base-types/backtracking-in-regular-expressions.md)
