---
title: Obecný systém typů
description: Přečtěte si o systému typů v .NET.
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- type system
- common type system
- assemblies [.NET Framework], types
- reference types
- value types
- cross-language interoperability
- namespaces [.NET Framework], types
- types, about types
ms.assetid: 53c57c96-83e1-4ee3-9543-9ac832671a89
ms.openlocfilehash: a1aa244d470402823fc22e12cb5e32bbbdcd87fe
ms.sourcegitcommit: 33deec3e814238fb18a49b2a7e89278e27888291
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 06/02/2020
ms.locfileid: "84289340"
---
# <a name="common-type-system"></a><span data-ttu-id="1e5c2-103">Obecný systém typů</span><span class="sxs-lookup"><span data-stu-id="1e5c2-103">Common type system</span></span>

<span data-ttu-id="1e5c2-104">Společný typ systému definuje, jak jsou typy deklarovány, používány a spravovány v modulu CLR (Common Language Runtime) a je také důležitou součástí podpory modulu runtime pro integraci mezi jazyky.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-104">The common type system defines how types are declared, used, and managed in the common language runtime, and is also an important part of the runtime's support for cross-language integration.</span></span> <span data-ttu-id="1e5c2-105">Společný typ systému provádí následující funkce:</span><span class="sxs-lookup"><span data-stu-id="1e5c2-105">The common type system performs the following functions:</span></span>  
  
- <span data-ttu-id="1e5c2-106">Vytvoří rozhraní, které pomáhá povolit integraci mezi jazyky, bezpečnost typů a vysoce výkonné provádění kódu.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-106">Establishes a framework that helps enable cross-language integration, type safety, and high-performance code execution.</span></span>  
  
- <span data-ttu-id="1e5c2-107">Poskytuje objektově orientovaný model, který podporuje kompletní implementaci mnoha programovacích jazyků.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-107">Provides an object-oriented model that supports the complete implementation of many programming languages.</span></span>  
  
- <span data-ttu-id="1e5c2-108">Definuje pravidla, která musí jazyky dodržovat, což pomáhá zajistit, aby objekty napsané v různých jazycích mohly vzájemně komunikovat.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-108">Defines rules that languages must follow, which helps ensure that objects written in different languages can interact with each other.</span></span>  
  
- <span data-ttu-id="1e5c2-109">Poskytuje knihovnu, která obsahuje primitivní datové typy (například <xref:System.Boolean> ,,, <xref:System.Byte> <xref:System.Char> <xref:System.Int32> , a <xref:System.UInt64> ) používané při vývoji aplikací.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-109">Provides a library that contains the primitive data types (such as <xref:System.Boolean>, <xref:System.Byte>, <xref:System.Char>, <xref:System.Int32>, and <xref:System.UInt64>) used in application development.</span></span>
  
## <a name="types-in-net"></a><span data-ttu-id="1e5c2-110">Typy v rozhraní .NET</span><span class="sxs-lookup"><span data-stu-id="1e5c2-110">Types in .NET</span></span>

 <span data-ttu-id="1e5c2-111">Všechny typy v rozhraní .NET jsou buď typy hodnot nebo typy odkazů.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-111">All types in .NET are either value types or reference types.</span></span>  
  
 <span data-ttu-id="1e5c2-112">Typy hodnot jsou datové typy, jejichž objekty jsou reprezentovány skutečnou hodnotou daného objektu.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-112">Value types are data types whose objects are represented by the object's actual value.</span></span> <span data-ttu-id="1e5c2-113">Pokud je instance hodnotového typu přiřazena proměnné, je této proměnné předána nová kopie hodnoty.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-113">If an instance of a value type is assigned to a variable, that variable is given a fresh copy of the value.</span></span>  
  
 <span data-ttu-id="1e5c2-114">Odkazové typy jsou datové typy, jejichž objekty jsou reprezentovány odkazem (podobně jako ukazatel) na skutečnou hodnotu objektu.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-114">Reference types are data types whose objects are represented by a reference (similar to a pointer) to the object's actual value.</span></span> <span data-ttu-id="1e5c2-115">Pokud je odkazový typ přiřazen proměnné, tato proměnná odkazuje (odkazuje na) na původní hodnotu.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-115">If a reference type is assigned to a variable, that variable references (points to) the original value.</span></span> <span data-ttu-id="1e5c2-116">Není provedena žádná kopie.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-116">No copy is made.</span></span>  
  
 <span data-ttu-id="1e5c2-117">Obecný systém typů v rozhraní .NET podporuje následující pět kategorií typů:</span><span class="sxs-lookup"><span data-stu-id="1e5c2-117">The common type system in .NET supports the following five categories of types:</span></span>  
  
- [<span data-ttu-id="1e5c2-118">Hmotnostní</span><span class="sxs-lookup"><span data-stu-id="1e5c2-118">Classes</span></span>](#classes)  
  
- [<span data-ttu-id="1e5c2-119">Struktury</span><span class="sxs-lookup"><span data-stu-id="1e5c2-119">Structures</span></span>](#structures)  
  
- [<span data-ttu-id="1e5c2-120">Výčty</span><span class="sxs-lookup"><span data-stu-id="1e5c2-120">Enumerations</span></span>](#enumerations)  
  
- [<span data-ttu-id="1e5c2-121">Rozhraní</span><span class="sxs-lookup"><span data-stu-id="1e5c2-121">Interfaces</span></span>](#interfaces)  
  
- [<span data-ttu-id="1e5c2-122">Delegáti</span><span class="sxs-lookup"><span data-stu-id="1e5c2-122">Delegates</span></span>](#delegates)  
  
### <a name="classes"></a><span data-ttu-id="1e5c2-123">Třídy</span><span class="sxs-lookup"><span data-stu-id="1e5c2-123">Classes</span></span>

 <span data-ttu-id="1e5c2-124">Třída je odkazový typ, který lze odvodit přímo z jiné třídy a implicitně odvozený z <xref:System.Object?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="1e5c2-124">A class is a reference type that can be derived directly from another class and that is derived implicitly from <xref:System.Object?displayProperty=nameWithType>.</span></span> <span data-ttu-id="1e5c2-125">Třída definuje operace, které může objekt (což je instance třídy) provádět (metody, události nebo vlastnosti) a data, která objekt obsahuje (pole).</span><span class="sxs-lookup"><span data-stu-id="1e5c2-125">The class defines the operations that an object (which is an instance of the class) can perform (methods, events, or properties) and the data that the object contains (fields).</span></span> <span data-ttu-id="1e5c2-126">I když třída obecně zahrnuje definice i implementaci (na rozdíl od rozhraní, například, která obsahuje pouze definici bez implementace), může mít jednoho nebo více členů, které nemají implementaci.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-126">Although a class generally includes both definition and implementation (unlike interfaces, for example, which contain only definition without implementation), it can have one or more members that have no implementation.</span></span>  
  
 <span data-ttu-id="1e5c2-127">Následující tabulka popisuje některé vlastnosti, které třída může mít.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-127">The following table describes some of the characteristics that a class may have.</span></span> <span data-ttu-id="1e5c2-128">Každý jazyk, který podporuje modul runtime, poskytuje způsob, jak označit, že třída nebo člen třídy má jednu nebo více těchto vlastností.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-128">Each language that supports the runtime provides a way to indicate that a class or class member has one or more of these characteristics.</span></span> <span data-ttu-id="1e5c2-129">Nicméně jednotlivé programovací jazyky, které cílí na rozhraní .NET, nemusí mít k dispozici všechny tyto vlastnosti.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-129">However, individual programming languages that target .NET may not make all these characteristics available.</span></span>  
  
|<span data-ttu-id="1e5c2-130">Charakteristika</span><span class="sxs-lookup"><span data-stu-id="1e5c2-130">Characteristic</span></span>|<span data-ttu-id="1e5c2-131">Popis</span><span class="sxs-lookup"><span data-stu-id="1e5c2-131">Description</span></span>|  
|--------------------|-----------------|  
|<span data-ttu-id="1e5c2-132">sealed</span><span class="sxs-lookup"><span data-stu-id="1e5c2-132">sealed</span></span>|<span data-ttu-id="1e5c2-133">Určuje, že jinou třídu nelze z tohoto typu odvodit.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-133">Specifies that another class cannot be derived from this type.</span></span>|  
|<span data-ttu-id="1e5c2-134">implements</span><span class="sxs-lookup"><span data-stu-id="1e5c2-134">implements</span></span>|<span data-ttu-id="1e5c2-135">Označuje, že třída používá jedno nebo více rozhraní tím, že poskytuje implementace členů rozhraní.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-135">Indicates that the class uses one or more interfaces by providing implementations of interface members.</span></span>|  
|<span data-ttu-id="1e5c2-136">abstract</span><span class="sxs-lookup"><span data-stu-id="1e5c2-136">abstract</span></span>|<span data-ttu-id="1e5c2-137">Označuje, že se nedá vytvořit instance třídy.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-137">Indicates that the class cannot be instantiated.</span></span> <span data-ttu-id="1e5c2-138">Pokud ho chcete použít, musíte z něj odvodit jinou třídu.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-138">To use it, you must derive another class from it.</span></span>|  
|<span data-ttu-id="1e5c2-139">zdědí</span><span class="sxs-lookup"><span data-stu-id="1e5c2-139">inherits</span></span>|<span data-ttu-id="1e5c2-140">Označuje, že instance třídy lze použít kdekoli je určena základní třída.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-140">Indicates that instances of the class can be used anywhere the base class is specified.</span></span> <span data-ttu-id="1e5c2-141">Odvozená třída, která dědí ze základní třídy, může používat implementaci všech veřejných členů poskytovaných základní třídou nebo odvozenou třídu může přepsat implementaci veřejných členů s vlastní implementací.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-141">A derived class that inherits from a base class can use the implementation of any public members provided by the base class, or the derived class can override the implementation of the public members with its own implementation.</span></span>|  
|<span data-ttu-id="1e5c2-142">exportováno nebo neexportováno</span><span class="sxs-lookup"><span data-stu-id="1e5c2-142">exported or not exported</span></span>|<span data-ttu-id="1e5c2-143">Označuje, zda je třída viditelná vně sestavení, ve kterém je definována.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-143">Indicates whether a class is visible outside the assembly in which it is defined.</span></span> <span data-ttu-id="1e5c2-144">Tato vlastnost se vztahuje pouze na třídy nejvyšší úrovně a nikoli na vnořené třídy.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-144">This characteristic applies only to top-level classes and not to nested classes.</span></span>|  
  
> [!NOTE]
> <span data-ttu-id="1e5c2-145">Třída může být také vnořena do nadřazené třídy nebo struktury.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-145">A class can also be nested in a parent class or structure.</span></span> <span data-ttu-id="1e5c2-146">Vnořené třídy mají také charakteristiky členů.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-146">Nested classes also have member characteristics.</span></span> <span data-ttu-id="1e5c2-147">Další informace naleznete v tématu [vnořené typy](#nested-types).</span><span class="sxs-lookup"><span data-stu-id="1e5c2-147">For more information, see [Nested Types](#nested-types).</span></span>  
  
 <span data-ttu-id="1e5c2-148">Členy třídy bez implementace jsou abstraktní členy.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-148">Class members that have no implementation are abstract members.</span></span> <span data-ttu-id="1e5c2-149">Třída, která má jednoho nebo více abstraktních členů, je sama o sobě abstraktní; Nelze vytvořit nové instance.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-149">A class that has one or more abstract members is itself abstract; new instances of it cannot be created.</span></span> <span data-ttu-id="1e5c2-150">Některé jazyky, které cílí na modul runtime, umožňují označit třídu jako abstraktní, a to i v případě, že žádný z jejích členů není abstraktní.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-150">Some languages that target the runtime let you mark a class as abstract even if none of its members are abstract.</span></span> <span data-ttu-id="1e5c2-151">Můžete použít abstraktní třídu, pokud chcete zapouzdřit základní sadu funkcí, které odvozené třídy mohou dědit nebo přepsat, pokud je to vhodné.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-151">You can use an abstract class when you want to encapsulate a basic set of functionality that derived classes can inherit or override when appropriate.</span></span> <span data-ttu-id="1e5c2-152">Třídy, které nejsou abstraktní, jsou označovány jako konkrétní třídy.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-152">Classes that are not abstract are referred to as concrete classes.</span></span>  
  
 <span data-ttu-id="1e5c2-153">Třída může implementovat libovolný počet rozhraní, ale může dědit pouze z jedné základní třídy kromě <xref:System.Object?displayProperty=nameWithType> , ze které všechny třídy dědí implicitní.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-153">A class can implement any number of interfaces, but it can inherit from only one base class in addition to <xref:System.Object?displayProperty=nameWithType>, from which all classes inherit implicitly.</span></span> <span data-ttu-id="1e5c2-154">Všechny třídy musí mít alespoň jeden konstruktor, který inicializuje nové instance třídy.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-154">All classes must have at least one constructor, which initializes new instances of the class.</span></span> <span data-ttu-id="1e5c2-155">Pokud konstruktor explicitně nedefinujete, většina kompilátorů automaticky nabídne konstruktor bez parametrů.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-155">If you do not explicitly define a constructor, most compilers will automatically provide a parameterless constructor.</span></span>  
  
### <a name="structures"></a><span data-ttu-id="1e5c2-156">Struktury</span><span class="sxs-lookup"><span data-stu-id="1e5c2-156">Structures</span></span>

 <span data-ttu-id="1e5c2-157">Struktura je hodnotový typ, který je odvozen implicitně z <xref:System.ValueType?displayProperty=nameWithType> , který je zase odvozen z <xref:System.Object?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="1e5c2-157">A structure is a value type that derives implicitly from <xref:System.ValueType?displayProperty=nameWithType>, which in turn is derived from <xref:System.Object?displayProperty=nameWithType>.</span></span> <span data-ttu-id="1e5c2-158">Struktura je užitečná pro reprezentace hodnot, jejichž požadavky na paměť jsou malé a pro předávání hodnot jako parametrů podle hodnot do metod, které mají parametry silného typu.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-158">A structure is useful for representing values whose memory requirements are small, and for passing values as by-value parameters to methods that have strongly typed parameters.</span></span> <span data-ttu-id="1e5c2-159">V rozhraní .NET jsou všechny primitivní datové typy ( <xref:System.Boolean> , <xref:System.Byte> ,, <xref:System.Char> <xref:System.DateTime> , <xref:System.Decimal> , <xref:System.Double> , <xref:System.Int16> , <xref:System.Int32> , <xref:System.Int64> ,,, <xref:System.SByte> <xref:System.Single> <xref:System.UInt16> , <xref:System.UInt32> a <xref:System.UInt64> ) definovány jako struktury.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-159">In .NET, all primitive data types (<xref:System.Boolean>, <xref:System.Byte>, <xref:System.Char>, <xref:System.DateTime>, <xref:System.Decimal>, <xref:System.Double>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.Int64>, <xref:System.SByte>, <xref:System.Single>, <xref:System.UInt16>, <xref:System.UInt32>, and <xref:System.UInt64>) are defined as structures.</span></span>  
  
 <span data-ttu-id="1e5c2-160">Podobně jako třídy struktury definují data (pole struktury) a operace, které mohou být provedeny na těchto datech (metody struktury).</span><span class="sxs-lookup"><span data-stu-id="1e5c2-160">Like classes, structures define both data (the fields of the structure) and the operations that can be performed on that data (the methods of the structure).</span></span> <span data-ttu-id="1e5c2-161">To znamená, že můžete volat metody ve strukturách, včetně virtuálních metod definovaných v <xref:System.Object?displayProperty=nameWithType> <xref:System.ValueType?displayProperty=nameWithType> třídách a a jakékoli metody definované v samotném typu hodnoty.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-161">This means that you can call methods on structures, including the virtual methods defined on the <xref:System.Object?displayProperty=nameWithType> and <xref:System.ValueType?displayProperty=nameWithType> classes, and any methods defined on the value type itself.</span></span> <span data-ttu-id="1e5c2-162">Jinými slovy struktury mohou mít pole, vlastnosti a události a také statické a nestatické metody.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-162">In other words, structures can have fields, properties, and events, as well as static and nonstatic methods.</span></span> <span data-ttu-id="1e5c2-163">Můžete vytvářet instance struktur, předávat je jako parametry, ukládat je jako lokální proměnné nebo je ukládat v poli jiného typu hodnoty nebo odkazu.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-163">You can create instances of structures, pass them as parameters, store them as local variables, or store them in a field of another value type or reference type.</span></span> <span data-ttu-id="1e5c2-164">Struktury mohou také implementovat rozhraní.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-164">Structures can also implement interfaces.</span></span>  
  
 <span data-ttu-id="1e5c2-165">Typy hodnot se také liší od tříd v několika ohledech.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-165">Value types also differ from classes in several respects.</span></span> <span data-ttu-id="1e5c2-166">Nejprve, i když implicitně dědí z <xref:System.ValueType?displayProperty=nameWithType> , nemohou přímo dědit z jakéhokoli typu.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-166">First, although they implicitly inherit from <xref:System.ValueType?displayProperty=nameWithType>, they cannot directly inherit from any type.</span></span> <span data-ttu-id="1e5c2-167">Podobně všechny typy hodnot jsou zapečetěné, což znamená, že z nich nemůže být odvozen žádný jiný typ.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-167">Similarly, all value types are sealed, which means that no other type can be derived from them.</span></span> <span data-ttu-id="1e5c2-168">Nevyžadují také konstruktory.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-168">They also do not require constructors.</span></span>  
  
 <span data-ttu-id="1e5c2-169">Pro každý typ hodnoty modul CLR (Common Language Runtime) dodá odpovídající zabalený typ, což je třída, která má stejný stav a chování jako typ hodnoty.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-169">For each value type, the common language runtime supplies a corresponding boxed type, which is a class that has the same state and behavior as the value type.</span></span> <span data-ttu-id="1e5c2-170">Instance hodnotového typu je zabalena, když je předána metodě, která přijímá parametr typu <xref:System.Object?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="1e5c2-170">An instance of a value type is boxed when it is passed to a method that accepts a parameter of type <xref:System.Object?displayProperty=nameWithType>.</span></span> <span data-ttu-id="1e5c2-171">Je-li ovládací prvek vrácen z volání metody, které přijímá typ hodnoty jako parametr podle odkazu, není v krabici (tj. převeden z instance třídy zpět na instanci typu hodnoty).</span><span class="sxs-lookup"><span data-stu-id="1e5c2-171">It is unboxed (that is, converted from an instance of a class back to an instance of a value type) when control returns from a method call that accepts a value type as a by-reference parameter.</span></span> <span data-ttu-id="1e5c2-172">Některé jazyky vyžadují použití speciální syntaxe, pokud je požadován zabalený typ; ostatní v případě potřeby automaticky používají zabalený typ.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-172">Some languages require that you use special syntax when the boxed type is required; others automatically use the boxed type when it is needed.</span></span> <span data-ttu-id="1e5c2-173">Při definování typu hodnoty definujete jak zabalený, tak i nezabalený typ.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-173">When you define a value type, you are defining both the boxed and the unboxed type.</span></span>  
  
### <a name="enumerations"></a><span data-ttu-id="1e5c2-174">Výčty</span><span class="sxs-lookup"><span data-stu-id="1e5c2-174">Enumerations</span></span>

 <span data-ttu-id="1e5c2-175">Výčet je hodnotový typ, který dědí přímo z <xref:System.Enum?displayProperty=nameWithType> a, který poskytuje alternativní názvy pro hodnoty základního primitivního typu.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-175">An enumeration is a value type that inherits directly from <xref:System.Enum?displayProperty=nameWithType> and that supplies alternate names for the values of an underlying primitive type.</span></span> <span data-ttu-id="1e5c2-176">Typ výčtu má název, nadřízený typ, který musí být jedním z vestavěných nebo unsigned integerch typů (například <xref:System.Byte> , <xref:System.Int32> nebo <xref:System.UInt64> ) a sadou polí.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-176">An enumeration type has a name, an underlying type that must be one of the built-in signed or unsigned integer types (such as <xref:System.Byte>, <xref:System.Int32>, or <xref:System.UInt64>), and a set of fields.</span></span> <span data-ttu-id="1e5c2-177">Pole jsou statické literální pole, z nichž každá představuje konstantu.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-177">The fields are static literal fields, each of which represents a constant.</span></span> <span data-ttu-id="1e5c2-178">Stejnou hodnotu lze přiřadit více polím.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-178">The same value can be assigned to multiple fields.</span></span> <span data-ttu-id="1e5c2-179">Pokud k tomu dojde, je nutné označit jednu z hodnot jako primární hodnotu výčtu pro reflexi a převod řetězce.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-179">When this occurs, you must mark one of the values as the primary enumeration value for reflection and string conversion.</span></span>  
  
 <span data-ttu-id="1e5c2-180">Můžete přiřadit hodnotu základního typu výčtu a naopak (modul runtime nevyžaduje žádné přetypování).</span><span class="sxs-lookup"><span data-stu-id="1e5c2-180">You can assign a value of the underlying type to an enumeration and vice versa (no cast is required by the runtime).</span></span> <span data-ttu-id="1e5c2-181">Můžete vytvořit instanci výčtu a volat metody <xref:System.Enum?displayProperty=nameWithType> , stejně tak jakékoli metody definované na základním typu výčtu.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-181">You can create an instance of an enumeration and call the methods of <xref:System.Enum?displayProperty=nameWithType>, as well as any methods defined on the enumeration's underlying type.</span></span> <span data-ttu-id="1e5c2-182">Některé jazyky však neumožňují předání výčtu jako parametru, pokud je vyžadována instance základního typu (nebo naopak).</span><span class="sxs-lookup"><span data-stu-id="1e5c2-182">However, some languages might not let you pass an enumeration as a parameter when an instance of the underlying type is required (or vice versa).</span></span>  
  
 <span data-ttu-id="1e5c2-183">Následující dodatečná omezení platí pro výčty:</span><span class="sxs-lookup"><span data-stu-id="1e5c2-183">The following additional restrictions apply to enumerations:</span></span>  
  
- <span data-ttu-id="1e5c2-184">Nemohou definovat své vlastní metody.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-184">They cannot define their own methods.</span></span>  
  
- <span data-ttu-id="1e5c2-185">Nemohou implementovat rozhraní.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-185">They cannot implement interfaces.</span></span>  
  
- <span data-ttu-id="1e5c2-186">Nemohou definovat vlastnosti nebo události.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-186">They cannot define properties or events.</span></span>  
  
- <span data-ttu-id="1e5c2-187">Nemohou být obecné, pokud nejsou obecné pouze proto, že jsou vnořené v rámci obecného typu.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-187">They cannot be generic, unless they are generic only because they are nested within a generic type.</span></span> <span data-ttu-id="1e5c2-188">To znamená, že výčet nemůže mít vlastní parametry typu.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-188">That is, an enumeration cannot have type parameters of its own.</span></span>  
  
    > [!NOTE]
    > <span data-ttu-id="1e5c2-189">Vnořené typy (včetně výčtů) vytvořené pomocí Visual Basic, C# a C++ zahrnují parametry typu všech nadřazených obecných typů a jsou proto Obecné i v případě, že nemají vlastní parametry typu.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-189">Nested types (including enumerations) created with Visual Basic, C#, and C++ include the type parameters of all enclosing generic types, and are therefore generic even if they do not have type parameters of their own.</span></span> <span data-ttu-id="1e5c2-190">Další informace naleznete v tématu "vnořené typy" v <xref:System.Type.MakeGenericType%2A?displayProperty=nameWithType> referenčním tématu.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-190">For more information, see "Nested Types" in the <xref:System.Type.MakeGenericType%2A?displayProperty=nameWithType> reference topic.</span></span>  
  
 <span data-ttu-id="1e5c2-191"><xref:System.FlagsAttribute>Atribut označuje speciální druh výčtu označovaného jako bitové pole.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-191">The <xref:System.FlagsAttribute> attribute denotes a special kind of enumeration called a bit field.</span></span> <span data-ttu-id="1e5c2-192">Samotný modul runtime nerozlišuje mezi tradičními výčty a bitovými poli, ale váš jazyk to může udělat.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-192">The runtime itself does not distinguish between traditional enumerations and bit fields, but your language might do so.</span></span> <span data-ttu-id="1e5c2-193">Po tomto rozlišení lze bitové operátory použít pro bitová pole, ale ne pro výčty, pro generování nepojmenovaných hodnot.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-193">When this distinction is made, bitwise operators can be used on bit fields, but not on enumerations, to generate unnamed values.</span></span> <span data-ttu-id="1e5c2-194">Výčty se obecně používají pro seznamy jedinečných prvků, například dny v týdnu, názvy zemí nebo oblastí atd.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-194">Enumerations are generally used for lists of unique elements, such as days of the week, country or region names, and so on.</span></span> <span data-ttu-id="1e5c2-195">Bitová pole jsou obecně používána pro seznamy kvality nebo množství, které mohou nastat v kombinaci, například `Red And Big And Fast` .</span><span class="sxs-lookup"><span data-stu-id="1e5c2-195">Bit fields are generally used for lists of qualities or quantities that might occur in combination, such as `Red And Big And Fast`.</span></span>  
  
 <span data-ttu-id="1e5c2-196">Následující příklad ukazuje, jak použít bitové pole i tradiční výčty.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-196">The following example shows how to use both bit fields and traditional enumerations.</span></span>  
  
 [!code-csharp[Conceptual.Types.Enum#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.types.enum/cs/example.cs#1)]
 [!code-vb[Conceptual.Types.Enum#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.types.enum/vb/example.vb#1)]  

### <a name="interfaces"></a><span data-ttu-id="1e5c2-197">Rozhraní</span><span class="sxs-lookup"><span data-stu-id="1e5c2-197">Interfaces</span></span>

 <span data-ttu-id="1e5c2-198">Rozhraní definuje kontrakt, který určuje relaci "může provádět" nebo "má" relaci.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-198">An interface defines a contract that specifies a "can do" relationship or a "has a" relationship.</span></span> <span data-ttu-id="1e5c2-199">Rozhraní se často používají k implementaci funkcí, jako je například porovnávání a třídění (rozhraní <xref:System.IComparable> a <xref:System.IComparable%601> ), testování rovnosti ( <xref:System.IEquatable%601> rozhraní) nebo výčet položek v kolekci ( <xref:System.Collections.IEnumerable> rozhraní a <xref:System.Collections.Generic.IEnumerable%601> ).</span><span class="sxs-lookup"><span data-stu-id="1e5c2-199">Interfaces are often used to implement functionality, such as comparing and sorting (the <xref:System.IComparable> and <xref:System.IComparable%601> interfaces), testing for equality (the <xref:System.IEquatable%601> interface), or enumerating items in a collection (the <xref:System.Collections.IEnumerable> and <xref:System.Collections.Generic.IEnumerable%601> interfaces).</span></span> <span data-ttu-id="1e5c2-200">Rozhraní mohou mít vlastnosti, metody a události, z nichž všechny jsou abstraktní členy; To znamená, že i když rozhraní definuje členy a jejich signatury, ponechá je typu, který implementuje rozhraní k definování funkcionality každého člena rozhraní.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-200">Interfaces can have properties, methods, and events, all of which are abstract members; that is, although the interface defines the members and their signatures, it leaves it to the type that implements the interface to define the functionality of each interface member.</span></span> <span data-ttu-id="1e5c2-201">To znamená, že jakákoliv třída nebo struktura, která implementuje rozhraní, musí poskytovat definice abstraktních členů deklarovaných v rozhraní.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-201">This means that any class or structure that implements an interface must supply definitions for the abstract members declared in the interface.</span></span> <span data-ttu-id="1e5c2-202">Rozhraní může vyžadovat, aby jakákoli implementující třída nebo struktura také implementovala jedno nebo více jiných rozhraní.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-202">An interface can require any implementing class or structure to also implement one or more other interfaces.</span></span>  
  
 <span data-ttu-id="1e5c2-203">Pro rozhraní platí následující omezení:</span><span class="sxs-lookup"><span data-stu-id="1e5c2-203">The following restrictions apply to interfaces:</span></span>  
  
- <span data-ttu-id="1e5c2-204">Rozhraní lze deklarovat s jakoukoli přístupností, ale členy rozhraní musí mít veřejnou přístupnost.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-204">An interface can be declared with any accessibility, but interface members must all have public accessibility.</span></span>  
  
- <span data-ttu-id="1e5c2-205">Rozhraní nemohou definovat konstruktory.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-205">Interfaces cannot define constructors.</span></span>  
  
- <span data-ttu-id="1e5c2-206">Rozhraní nemohou definovat pole.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-206">Interfaces cannot define fields.</span></span>  
  
- <span data-ttu-id="1e5c2-207">Rozhraní mohou definovat pouze členy instance.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-207">Interfaces can define only instance members.</span></span> <span data-ttu-id="1e5c2-208">Nemohou definovat statické členy.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-208">They cannot define static members.</span></span>  
  
 <span data-ttu-id="1e5c2-209">Každý jazyk musí poskytovat pravidla pro mapování implementace na rozhraní, které vyžaduje člen, protože více než jedno rozhraní může deklarovat člena se stejnou signaturou a tito členové mohou mít samostatné implementace.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-209">Each language must provide rules for mapping an implementation to the interface that requires the member, because more than one interface can declare a member with the same signature, and these members can have separate implementations.</span></span>  

### <a name="delegates"></a><span data-ttu-id="1e5c2-210">Delegáti</span><span class="sxs-lookup"><span data-stu-id="1e5c2-210">Delegates</span></span>

 <span data-ttu-id="1e5c2-211">Delegáti jsou odkazové typy, které slouží k podobnému účelu jako ukazatelé na funkci v jazyce C++.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-211">Delegates are reference types that serve a purpose similar to that of function pointers in C++.</span></span> <span data-ttu-id="1e5c2-212">Používají se pro obslužné rutiny událostí a funkce zpětného volání v rozhraní .NET.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-212">They are used for event handlers and callback functions in .NET.</span></span> <span data-ttu-id="1e5c2-213">Na rozdíl od ukazatelů na funkce jsou delegáti zabezpečeni, ověřitelné a typově bezpečné.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-213">Unlike function pointers, delegates are secure, verifiable, and type safe.</span></span> <span data-ttu-id="1e5c2-214">Typ delegáta může představovat libovolnou metodu instance nebo statickou metodu, která má kompatibilní podpis.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-214">A delegate type can represent any instance method or static method that has a compatible signature.</span></span>  
  
 <span data-ttu-id="1e5c2-215">Parametr delegáta je kompatibilní s odpovídajícím parametrem metody, pokud je typ parametru delegáta více omezující než typ parametru metody, protože to zaručuje, že argument předaný delegátovi může být bezpečně předán metodě.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-215">A parameter of a delegate is compatible with the corresponding parameter of a method if the type of the delegate parameter is more restrictive than the type of the method parameter, because this guarantees that an argument passed to the delegate can be passed safely to the method.</span></span>  
  
 <span data-ttu-id="1e5c2-216">Podobně je návratový typ delegáta kompatibilní s návratovým typem metody, pokud návratový typ metody je více omezující než návratový typ delegáta, protože to zaručuje, že návratová hodnota metody může být bezpečně převedena na návratový typ delegáta.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-216">Similarly, the return type of a delegate is compatible with the return type of a method if the return type of the method is more restrictive than the return type of the delegate, because this guarantees that the return value of the method can be cast safely to the return type of the delegate.</span></span>  
  
 <span data-ttu-id="1e5c2-217">Například delegát, který má parametr typu <xref:System.Collections.IEnumerable> a návratový typ <xref:System.Object> může představovat metodu, která má parametr typu <xref:System.Object> a návratovou hodnotu typu <xref:System.Collections.IEnumerable> .</span><span class="sxs-lookup"><span data-stu-id="1e5c2-217">For example, a delegate that has a parameter of type <xref:System.Collections.IEnumerable> and a return type of <xref:System.Object> can represent a method that has a parameter of type <xref:System.Object> and a return value of type <xref:System.Collections.IEnumerable>.</span></span> <span data-ttu-id="1e5c2-218">Další informace a příklady kódu naleznete v tématu <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%29?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="1e5c2-218">For more information and example code, see <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%29?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="1e5c2-219">Delegát je označován jako vázaný na metodu, kterou představuje.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-219">A delegate is said to be bound to the method it represents.</span></span> <span data-ttu-id="1e5c2-220">Kromě vazby k metodě může být delegát svázán s objektem.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-220">In addition to being bound to the method, a delegate can be bound to an object.</span></span> <span data-ttu-id="1e5c2-221">Objekt představuje první parametr metody a je předán metodě pokaždé, když je vyvolán delegát.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-221">The object represents the first parameter of the method, and is passed to the method every time the delegate is invoked.</span></span> <span data-ttu-id="1e5c2-222">Pokud je metoda metodou instance, je vázaný objekt předán jako implicitní `this` parametr ( `Me` v Visual Basic); Pokud je metoda statická, objekt je předán jako první formální parametr metody a signatura delegáta musí odpovídat zbývajícím parametrům.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-222">If the method is an instance method, the bound object is passed as the implicit `this` parameter (`Me` in Visual Basic); if the method is static, the object is passed as the first formal parameter of the method, and the delegate signature must match the remaining parameters.</span></span> <span data-ttu-id="1e5c2-223">Další informace a příklady kódu naleznete v tématu <xref:System.Delegate?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="1e5c2-223">For more information and example code, see <xref:System.Delegate?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="1e5c2-224">Všichni delegáti dědí z <xref:System.MulticastDelegate?displayProperty=nameWithType> , který dědí z <xref:System.Delegate?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="1e5c2-224">All delegates inherit from <xref:System.MulticastDelegate?displayProperty=nameWithType>, which inherits from <xref:System.Delegate?displayProperty=nameWithType>.</span></span> <span data-ttu-id="1e5c2-225">Jazyky C#, Visual Basic a C++ nepovolují dědění z těchto typů.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-225">The C#, Visual Basic, and C++ languages do not allow inheritance from these types.</span></span> <span data-ttu-id="1e5c2-226">Místo toho poskytují klíčová slova pro deklarování delegátů.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-226">Instead, they provide keywords for declaring delegates.</span></span>  
  
 <span data-ttu-id="1e5c2-227">Vzhledem k tomu, že delegáti dědí z <xref:System.MulticastDelegate> , má delegát seznam vyvolání, což je seznam metod, které delegát představuje a které jsou spouštěny, když je vyvolán delegát.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-227">Because delegates inherit from <xref:System.MulticastDelegate>, a delegate has an invocation list, which is a list of methods that the delegate represents and that are executed when the delegate is invoked.</span></span> <span data-ttu-id="1e5c2-228">Všechny metody v seznamu obdrží argumenty dodané při vyvolání delegáta.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-228">All methods in the list receive the arguments supplied when the delegate is invoked.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="1e5c2-229">Návratová hodnota není definována pro delegáta, který má ve svém seznamu vyvolání více než jednu metodu, i když má delegát návratový typ.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-229">The return value is not defined for a delegate that has more than one method in its invocation list, even if the delegate has a return type.</span></span>  
  
 <span data-ttu-id="1e5c2-230">V mnoha případech, jako je například metoda zpětného volání, představuje delegát pouze jednu metodu a jediné akce, které je třeba provést, vytvoří delegáta a vyvolá ho.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-230">In many cases, such as with callback methods, a delegate represents only one method, and the only actions you have to take are creating the delegate and invoking it.</span></span>  
  
 <span data-ttu-id="1e5c2-231">Pro delegáty, kteří představují více metod, poskytuje rozhraní .NET <xref:System.Delegate> metody <xref:System.MulticastDelegate> třídy a delegátů pro podporu operací, jako je přidání metody do seznamu volání delegáta ( <xref:System.Delegate.Combine%2A?displayProperty=nameWithType> Metoda), odebrání metody ( <xref:System.Delegate.Remove%2A?displayProperty=nameWithType> metody) a získání seznamu vyvolání ( <xref:System.Delegate.GetInvocationList%2A?displayProperty=nameWithType> Metoda).</span><span class="sxs-lookup"><span data-stu-id="1e5c2-231">For delegates that represent multiple methods, .NET provides methods of the <xref:System.Delegate> and <xref:System.MulticastDelegate> delegate classes to support operations such as adding a method to a delegate's invocation list (the <xref:System.Delegate.Combine%2A?displayProperty=nameWithType> method), removing a method (the <xref:System.Delegate.Remove%2A?displayProperty=nameWithType> method), and getting the invocation list (the <xref:System.Delegate.GetInvocationList%2A?displayProperty=nameWithType> method).</span></span>  
  
> [!NOTE]
> <span data-ttu-id="1e5c2-232">Není nutné používat tyto metody pro delegáty obslužných rutin událostí v jazycích C#, C++ a Visual Basic, protože tyto jazyky poskytují syntaxi pro přidávání a odebírání obslužných rutin událostí.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-232">It is not necessary to use these methods for event-handler delegates in C#, C++, and Visual Basic, because these languages provide syntax for adding and removing event handlers.</span></span>  

## <a name="type-definitions"></a><span data-ttu-id="1e5c2-233">Definice typů</span><span class="sxs-lookup"><span data-stu-id="1e5c2-233">Type definitions</span></span>

 <span data-ttu-id="1e5c2-234">Definice typu zahrnuje následující:</span><span class="sxs-lookup"><span data-stu-id="1e5c2-234">A type definition includes the following:</span></span>  
  
- <span data-ttu-id="1e5c2-235">Všechny atributy definované v typu.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-235">Any attributes defined on the type.</span></span>  
  
- <span data-ttu-id="1e5c2-236">Přístupnost typu (viditelnost).</span><span class="sxs-lookup"><span data-stu-id="1e5c2-236">The type's accessibility (visibility).</span></span>  
  
- <span data-ttu-id="1e5c2-237">Název typu.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-237">The type's name.</span></span>  
  
- <span data-ttu-id="1e5c2-238">Základní typ typu.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-238">The type's base type.</span></span>  
  
- <span data-ttu-id="1e5c2-239">Jakákoli rozhraní implementovaná tímto typem.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-239">Any interfaces implemented by the type.</span></span>  
  
- <span data-ttu-id="1e5c2-240">Definice pro každý ze členů typu.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-240">Definitions for each of the type's members.</span></span>  
  
### <a name="attributes"></a><span data-ttu-id="1e5c2-241">Atributy</span><span class="sxs-lookup"><span data-stu-id="1e5c2-241">Attributes</span></span>  
 <span data-ttu-id="1e5c2-242">Atributy poskytují další uživatelsky definovaná metadata.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-242">Attributes provide additional user-defined metadata.</span></span> <span data-ttu-id="1e5c2-243">Nejčastěji se používají k ukládání dalších informací o typu v jeho sestavení nebo k úpravě chování členu typu v době návrhu nebo prostředí run-time.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-243">Most commonly, they are used to store additional information about a type in its assembly, or to modify the behavior of a type member in either the design-time or run-time environment.</span></span>  
  
 <span data-ttu-id="1e5c2-244">Atributy jsou samotné třídy, které dědí z <xref:System.Attribute?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="1e5c2-244">Attributes are themselves classes that inherit from <xref:System.Attribute?displayProperty=nameWithType>.</span></span> <span data-ttu-id="1e5c2-245">Jazyky, které podporují použití atributů, mají vlastní syntaxi pro aplikování atributů na prvek jazyka.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-245">Languages that support the use of attributes each have their own syntax for applying attributes to a language element.</span></span> <span data-ttu-id="1e5c2-246">Atributy lze použít pro skoro libovolný prvek jazyka; konkrétní prvky, na které lze atribut použít, jsou definovány pomocí objektu <xref:System.AttributeUsageAttribute> , který je použit pro tuto třídu atributu.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-246">Attributes can be applied to almost any language element; the specific elements to which an attribute can be applied are defined by the <xref:System.AttributeUsageAttribute> that is applied to that attribute class.</span></span>  
  
### <a name="type-accessibility"></a><span data-ttu-id="1e5c2-247">Přístupnost typu</span><span class="sxs-lookup"><span data-stu-id="1e5c2-247">Type accessibility</span></span>  
 <span data-ttu-id="1e5c2-248">Všechny typy mají modifikátor, který určuje přístupnost z jiných typů.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-248">All types have a modifier that governs their accessibility from other types.</span></span> <span data-ttu-id="1e5c2-249">Následující tabulka popisuje typ přístupnosti podporovaný modulem runtime.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-249">The following table describes the type accessibilities supported by the runtime.</span></span>  
  
|<span data-ttu-id="1e5c2-250">Usnadnění</span><span class="sxs-lookup"><span data-stu-id="1e5c2-250">Accessibility</span></span>|<span data-ttu-id="1e5c2-251">Popis</span><span class="sxs-lookup"><span data-stu-id="1e5c2-251">Description</span></span>|  
|-------------------|-----------------|  
|<span data-ttu-id="1e5c2-252">public</span><span class="sxs-lookup"><span data-stu-id="1e5c2-252">public</span></span>|<span data-ttu-id="1e5c2-253">Typ je přístupný pro všechna sestavení.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-253">The type is accessible by all assemblies.</span></span>|  
|<span data-ttu-id="1e5c2-254">sestavení</span><span class="sxs-lookup"><span data-stu-id="1e5c2-254">assembly</span></span>|<span data-ttu-id="1e5c2-255">Typ je přístupný pouze v rámci jeho sestavení.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-255">The type is accessible only from within its assembly.</span></span>|  
  
 <span data-ttu-id="1e5c2-256">Přístupnost vnořeného typu závisí na své doméně přístupnosti, která je určena deklarovanou přístupností člena a doménou přístupnosti bezprostředně obsahujícího typu.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-256">The accessibility of a nested type depends on its accessibility domain, which is determined by both the declared accessibility of the member and the accessibility domain of the immediately containing type.</span></span> <span data-ttu-id="1e5c2-257">Nicméně doména přístupnosti vnořeného typu nemůže přesáhnout typ nadřazeného typu.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-257">However, the accessibility domain of a nested type cannot exceed that of the containing type.</span></span>  
  
 <span data-ttu-id="1e5c2-258">Doména přístupnosti vnořeného člena `M` deklarovaného v typu v `T` rámci programu `P` je definována takto (s označením, že `M` se může jednat o typ):</span><span class="sxs-lookup"><span data-stu-id="1e5c2-258">The accessibility domain of a nested member `M` declared in a type `T` within a program `P` is defined as follows (noting that `M` might itself be a type):</span></span>  
  
- <span data-ttu-id="1e5c2-259">Pokud je deklarovaná přístupnost `M` člena `public` , tak doména přístupnosti člena `M` je doména přístupnosti člena `T` .</span><span class="sxs-lookup"><span data-stu-id="1e5c2-259">If the declared accessibility of `M` is `public`, the accessibility domain of `M` is the accessibility domain of `T`.</span></span>  
  
- <span data-ttu-id="1e5c2-260">Pokud je deklarovaná přístupnost `M` člena `protected internal` , tak doména přístupnosti člena `M` je průsečík domény přístupnosti typu `T` s textem programu `P` a textem programu libovolného typu odvozeného z `T` deklarovaného mimo `P` .</span><span class="sxs-lookup"><span data-stu-id="1e5c2-260">If the declared accessibility of `M` is `protected internal`, the accessibility domain of `M` is the intersection of the accessibility domain of `T` with the program text of `P` and the program text of any type derived from `T` declared outside `P`.</span></span>  
  
- <span data-ttu-id="1e5c2-261">Pokud je deklarovaná přístupnost `M` člena `protected` , tak doména přístupnosti člena `M` je průsečík domény přístupnosti typu `T` s textem programu `T` a libovolného typu odvozeného z `T` .</span><span class="sxs-lookup"><span data-stu-id="1e5c2-261">If the declared accessibility of `M` is `protected`, the accessibility domain of `M` is the intersection of the accessibility domain of `T` with the program text of `T` and any type derived from `T`.</span></span>  
  
- <span data-ttu-id="1e5c2-262">Pokud je deklarovaná přístupnost `M` člena `internal` , tak doména přístupnosti člena `M` je průsečík domény přístupnosti typu `T` s textem programu `P` .</span><span class="sxs-lookup"><span data-stu-id="1e5c2-262">If the declared accessibility of `M` is `internal`, the accessibility domain of `M` is the intersection of the accessibility domain of `T` with the program text of `P`.</span></span>  
  
- <span data-ttu-id="1e5c2-263">Pokud je deklarovaná přístupnost `M` člena `private` , tak doména přístupnosti člena `M` je text programu `T` .</span><span class="sxs-lookup"><span data-stu-id="1e5c2-263">If the declared accessibility of `M` is `private`, the accessibility domain of `M` is the program text of `T`.</span></span>  
  
### <a name="type-names"></a><span data-ttu-id="1e5c2-264">Názvy typů</span><span class="sxs-lookup"><span data-stu-id="1e5c2-264">Type Names</span></span>  
 <span data-ttu-id="1e5c2-265">Společný typ systému ukládá pouze dvě omezení pro názvy:</span><span class="sxs-lookup"><span data-stu-id="1e5c2-265">The common type system imposes only two restrictions on names:</span></span>  
  
- <span data-ttu-id="1e5c2-266">Všechny názvy jsou kódované jako řetězce znaků Unicode (16 bitů).</span><span class="sxs-lookup"><span data-stu-id="1e5c2-266">All names are encoded as strings of Unicode (16-bit) characters.</span></span>  
  
- <span data-ttu-id="1e5c2-267">U názvů nejsou povoleny hodnoty typu Embedded (16bitová) hodnota 0x0000.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-267">Names are not permitted to have an embedded (16-bit) value of 0x0000.</span></span>  
  
 <span data-ttu-id="1e5c2-268">Většina jazyků však zavádí další omezení pro názvy typů.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-268">However, most languages impose additional restrictions on type names.</span></span> <span data-ttu-id="1e5c2-269">Všechna porovnání jsou prováděna po bajtech, a proto jsou nezávislé na velikosti písmen a v národním prostředí.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-269">All comparisons are done on a byte-by-byte basis, and are therefore case-sensitive and locale-independent.</span></span>  
  
 <span data-ttu-id="1e5c2-270">I když typ může odkazovat na typy z jiných modulů a sestavení, musí být typ plně definovaný v jednom modulu .NET.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-270">Although a type might reference types from other modules and assemblies, a type must be fully defined within one .NET module.</span></span> <span data-ttu-id="1e5c2-271">(V závislosti na podpoře kompilátoru je však možné ji rozdělit do více souborů zdrojového kódu.) Názvy typů musí být jedinečné jenom v rámci oboru názvů.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-271">(Depending on compiler support, however, it can be divided into multiple source code files.) Type names need be unique only within a namespace.</span></span> <span data-ttu-id="1e5c2-272">Aby bylo možné plně identifikovat typ, musí být název typu kvalifikován oborem názvů, který obsahuje implementaci typu.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-272">To fully identify a type, the type name must be qualified by the namespace that contains the implementation of the type.</span></span>  
  
### <a name="base-types-and-interfaces"></a><span data-ttu-id="1e5c2-273">Základní typy a rozhraní</span><span class="sxs-lookup"><span data-stu-id="1e5c2-273">Base types and interfaces</span></span>  
 <span data-ttu-id="1e5c2-274">Typ může dědit hodnoty a chování z jiného typu.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-274">A type can inherit values and behaviors from another type.</span></span> <span data-ttu-id="1e5c2-275">Společný typ systému nepovoluje, aby typy dědily z více než jednoho základního typu.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-275">The common type system does not allow types to inherit from more than one base type.</span></span>  
  
 <span data-ttu-id="1e5c2-276">Typ může implementovat libovolný počet rozhraní.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-276">A type can implement any number of interfaces.</span></span> <span data-ttu-id="1e5c2-277">Pro implementaci rozhraní musí typ implementovat všechny virtuální členy tohoto rozhraní.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-277">To implement an interface, a type must implement all the virtual members of that interface.</span></span> <span data-ttu-id="1e5c2-278">Virtuální metoda může být implementována odvozeným typem a lze ji vyvolat staticky nebo dynamicky.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-278">A virtual method can be implemented by a derived type and can be invoked either statically or dynamically.</span></span>  

## <a name="type-members"></a><span data-ttu-id="1e5c2-279">Členy typu</span><span class="sxs-lookup"><span data-stu-id="1e5c2-279">Type members</span></span>

 <span data-ttu-id="1e5c2-280">Modul runtime umožňuje definovat členy typu, který určuje chování a stav typu.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-280">The runtime enables you to define members of your type, which specifies the behavior and state of a type.</span></span> <span data-ttu-id="1e5c2-281">Mezi členy typu patří následující:</span><span class="sxs-lookup"><span data-stu-id="1e5c2-281">Type members include the following:</span></span>  
  
- [<span data-ttu-id="1e5c2-282">Pole</span><span class="sxs-lookup"><span data-stu-id="1e5c2-282">Fields</span></span>](#fields)  
  
- [<span data-ttu-id="1e5c2-283">Vlastnosti</span><span class="sxs-lookup"><span data-stu-id="1e5c2-283">Properties</span></span>](#properties)  
  
- [<span data-ttu-id="1e5c2-284">Metody</span><span class="sxs-lookup"><span data-stu-id="1e5c2-284">Methods</span></span>](#methods)  
  
- [<span data-ttu-id="1e5c2-285">Konstruktory</span><span class="sxs-lookup"><span data-stu-id="1e5c2-285">Constructors</span></span>](#constructors)  
  
- [<span data-ttu-id="1e5c2-286">Události</span><span class="sxs-lookup"><span data-stu-id="1e5c2-286">Events</span></span>](#events)  
  
- [<span data-ttu-id="1e5c2-287">Vnořené typy</span><span class="sxs-lookup"><span data-stu-id="1e5c2-287">Nested types</span></span>](#nested-types)  

### <a name="fields"></a><span data-ttu-id="1e5c2-288">Pole</span><span class="sxs-lookup"><span data-stu-id="1e5c2-288">Fields</span></span>

 <span data-ttu-id="1e5c2-289">Pole popisuje a obsahuje část stavu typu.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-289">A field describes and contains part of the type's state.</span></span> <span data-ttu-id="1e5c2-290">Pole mohou být libovolného typu podporovaného modulem runtime.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-290">Fields can be of any type supported by the runtime.</span></span> <span data-ttu-id="1e5c2-291">Nejčastěji jsou pole buď `private` nebo `protected` , aby byly přístupné pouze v rámci třídy nebo z odvozené třídy.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-291">Most commonly, fields are either `private` or `protected`, so that they are accessible only from within the class or from a derived class.</span></span> <span data-ttu-id="1e5c2-292">Pokud hodnota pole může být upravena mimo jeho typ, je obvykle použito přistupující objekt sady vlastností.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-292">If the value of a field can be modified from outside its type, a property set accessor is typically used.</span></span> <span data-ttu-id="1e5c2-293">Veřejně vystavená pole jsou obvykle jen pro čtení a můžou mít dva typy:</span><span class="sxs-lookup"><span data-stu-id="1e5c2-293">Publicly exposed fields are usually read-only and can be of two types:</span></span>  
  
- <span data-ttu-id="1e5c2-294">Konstanty, jejichž hodnota je přiřazena v době návrhu.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-294">Constants, whose value is assigned at design time.</span></span> <span data-ttu-id="1e5c2-295">Jedná se o statické členy třídy, i když nejsou definovány pomocí `static` `Shared` klíčového slova (in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="1e5c2-295">These are static members of a class, although they are not defined using the `static` (`Shared` in Visual Basic) keyword.</span></span>  
  
- <span data-ttu-id="1e5c2-296">Proměnné jen pro čtení, jejichž hodnoty lze přiřadit v konstruktoru třídy.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-296">Read-only variables, whose values can be assigned in the class constructor.</span></span>  
  
 <span data-ttu-id="1e5c2-297">Následující příklad znázorňuje tato dvě použití polí jen pro čtení.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-297">The following example illustrates these two usages of read-only fields.</span></span>  
  
 [!code-csharp[Conceptual.Types.Members.Fields#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.types.members.fields/cs/example.cs#1)]
 [!code-vb[Conceptual.Types.Members.Fields#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.types.members.fields/vb/example.vb#1)]  

### <a name="properties"></a><span data-ttu-id="1e5c2-298">Vlastnosti</span><span class="sxs-lookup"><span data-stu-id="1e5c2-298">Properties</span></span>

 <span data-ttu-id="1e5c2-299">Vlastnost pojmenovává hodnotu nebo stav typu a definuje metody pro získání nebo nastavení hodnoty vlastnosti.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-299">A property names a value or state of the type and defines methods for getting or setting the property's value.</span></span> <span data-ttu-id="1e5c2-300">Vlastnosti mohou být primitivní typy, kolekce primitivních typů, uživatelsky definované typy nebo kolekce uživatelsky definovaných typů.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-300">Properties can be primitive types, collections of primitive types, user-defined types, or collections of user-defined types.</span></span> <span data-ttu-id="1e5c2-301">Vlastnosti jsou často používány k zachování veřejného rozhraní typu nezávisle na skutečném vyjádření typu.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-301">Properties are often used to keep the public interface of a type independent from the type's actual representation.</span></span> <span data-ttu-id="1e5c2-302">To umožňuje vlastnostem odrážet hodnoty, které nejsou přímo uloženy ve třídě (například když vlastnost vrátí vypočítanou hodnotu) nebo provést ověření před přiřazením hodnot k soukromým polím.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-302">This enables properties to reflect values that are not directly stored in the class (for example, when a property returns a computed value) or to perform validation before values are assigned to private fields.</span></span> <span data-ttu-id="1e5c2-303">Následující příklad znázorňuje druhý model.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-303">The following example illustrates the latter pattern.</span></span>  
  
 [!code-csharp[Conceptual.Types.Members.Properties#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.types.members.properties/cs/example.cs#1)]
 [!code-vb[Conceptual.Types.Members.Properties#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.types.members.properties/vb/example.vb#1)]  
  
 <span data-ttu-id="1e5c2-304">Kromě zahrnutí samotné vlastnosti, jazyka MSIL (Microsoft Intermediate Language) pro typ, který obsahuje čitelnou vlastnost obsahuje `get_` metodu *PropertyName* a jazyk MSIL pro typ, který obsahuje vlastnost s možností zápisu, obsahuje `set_` metodu *PropertyName* .</span><span class="sxs-lookup"><span data-stu-id="1e5c2-304">In addition to including the property itself, the Microsoft intermediate language (MSIL) for a type that contains a readable property includes a `get_`*propertyname* method, and the MSIL for a type that contains a writable property includes a `set_`*propertyname* method.</span></span>  

### <a name="methods"></a><span data-ttu-id="1e5c2-305">Metody</span><span class="sxs-lookup"><span data-stu-id="1e5c2-305">Methods</span></span>

 <span data-ttu-id="1e5c2-306">Metoda popisuje operace, které jsou k dispozici na typu.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-306">A method describes operations that are available on the type.</span></span> <span data-ttu-id="1e5c2-307">Signatura metody specifikuje přípustné typy všech jeho parametrů a návratové hodnoty.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-307">A method's signature specifies the allowable types of all its parameters and of its return value.</span></span>  
  
 <span data-ttu-id="1e5c2-308">I když většina metod definuje přesný počet parametrů vyžadovaných pro volání metod, některé metody podporují proměnný počet parametrů.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-308">Although most methods define the precise number of parameters required for method calls, some methods support a variable number of parameters.</span></span> <span data-ttu-id="1e5c2-309">Výsledný deklarovaný parametr těchto metod je označen <xref:System.ParamArrayAttribute> atributem.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-309">The final declared parameter of these methods is marked with the <xref:System.ParamArrayAttribute> attribute.</span></span> <span data-ttu-id="1e5c2-310">Kompilátory jazyka obvykle poskytují klíčové slovo, například `params` v jazyce C# a `ParamArray` v Visual Basic, které umožňuje explicitní použití <xref:System.ParamArrayAttribute> zbytečných.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-310">Language compilers typically provide a keyword, such as `params` in C# and `ParamArray` in Visual Basic, that makes explicit use of <xref:System.ParamArrayAttribute> unnecessary.</span></span>  

### <a name="constructors"></a><span data-ttu-id="1e5c2-311">Konstruktory</span><span class="sxs-lookup"><span data-stu-id="1e5c2-311">Constructors</span></span>

 <span data-ttu-id="1e5c2-312">Konstruktor je speciální druh metody, který vytváří nové instance třídy nebo struktury.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-312">A constructor is a special kind of method that creates new instances of a class or structure.</span></span> <span data-ttu-id="1e5c2-313">Stejně jako jakékoli jiné metody může konstruktor obsahovat parametry; konstruktory ale nemají žádnou návratovou hodnotu (to znamená, že vrátí `void` ).</span><span class="sxs-lookup"><span data-stu-id="1e5c2-313">Like any other method, a constructor can include parameters; however, constructors have no return value (that is, they return `void`).</span></span>  
  
 <span data-ttu-id="1e5c2-314">Pokud zdrojový kód třídy explicitně nedefinuje konstruktor, kompilátor obsahuje konstruktor bez parametrů.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-314">If the source code for a class does not explicitly define a constructor, the compiler includes a parameterless constructor.</span></span> <span data-ttu-id="1e5c2-315">Nicméně pokud zdrojový kód třídy definuje pouze parametrizované konstruktory, kompilátory Visual Basic a C# negenerují konstruktor bez parametrů.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-315">However, if the source code for a class defines only parameterized constructors, the Visual Basic and C# compilers do not generate a parameterless constructor.</span></span>  
  
 <span data-ttu-id="1e5c2-316">Pokud zdrojový kód struktury definuje konstruktory, musí být parametrizované; Struktura nemůže definovat konstruktor bez parametrů a kompilátory negenerují konstruktory bez parametrů pro struktury a jiné typy hodnot.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-316">If the source code for a structure defines constructors, they must be parameterized; a structure cannot define a parameterless constructor, and compilers do not generate parameterless constructors for structures or other value types.</span></span> <span data-ttu-id="1e5c2-317">Všechny typy hodnot mají implicitní konstruktor bez parametrů.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-317">All value types do have an implicit parameterless constructor.</span></span> <span data-ttu-id="1e5c2-318">Tento konstruktor je implementován modulem CLR (Common Language Runtime) a inicializuje všechna pole struktury na jejich výchozí hodnoty.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-318">This constructor is implemented by the common language runtime and initializes all fields of the structure to their default values.</span></span>  

### <a name="events"></a><span data-ttu-id="1e5c2-319">Události</span><span class="sxs-lookup"><span data-stu-id="1e5c2-319">Events</span></span>

 <span data-ttu-id="1e5c2-320">Událost definuje incident, na který lze reagovat, a definuje metody pro odběr, zrušení odběru a vyvolání události.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-320">An event defines an incident that can be responded to, and defines methods for subscribing to, unsubscribing from, and raising the event.</span></span> <span data-ttu-id="1e5c2-321">Události se často používají k informování dalších typů změn stavu.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-321">Events are often used to inform other types of state changes.</span></span> <span data-ttu-id="1e5c2-322">Další informace najdete v tématu [události](../events/index.md).</span><span class="sxs-lookup"><span data-stu-id="1e5c2-322">For more information, see [Events](../events/index.md).</span></span>  

### <a name="nested-types"></a><span data-ttu-id="1e5c2-323">Vnořené typy</span><span class="sxs-lookup"><span data-stu-id="1e5c2-323">Nested types</span></span>

 <span data-ttu-id="1e5c2-324">Vnořený typ je typ, který je členem nějakého jiného typu.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-324">A nested type is a type that is a member of some other type.</span></span> <span data-ttu-id="1e5c2-325">Vnořené typy by měly být pevně spojeny s jejich nadřazeným typem a nesmí být užitečné jako typ obecného účelu.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-325">Nested types should be tightly coupled to their containing type and must not be useful as a general-purpose type.</span></span> <span data-ttu-id="1e5c2-326">Vnořené typy jsou užitečné v případě, že deklarující typ používá a vytváří instance vnořeného typu a použití vnořeného typu není zveřejněno ve veřejných členech.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-326">Nested types are useful when the declaring type uses and creates instances of the nested type, and use of the nested type is not exposed in public members.</span></span>  
  
 <span data-ttu-id="1e5c2-327">Vnořené typy jsou matoucí pro některé vývojáře a neměly by být veřejně viditelné, pokud neexistují přesvědčivé důvody pro přehlednost.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-327">Nested types are confusing to some developers and should not be publicly visible unless there is a compelling reason for visibility.</span></span> <span data-ttu-id="1e5c2-328">V dobře navržené knihovně by vývojáři měli použít vnořené typy pouze zřídka pro vytvoření instance objektů nebo deklarování proměnných.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-328">In a well-designed library, developers should rarely have to use nested types to instantiate objects or declare variables.</span></span>  

## <a name="characteristics-of-type-members"></a><span data-ttu-id="1e5c2-329">Charakteristiky členů typu</span><span class="sxs-lookup"><span data-stu-id="1e5c2-329">Characteristics of type members</span></span>

 <span data-ttu-id="1e5c2-330">Společný typ systému umožňuje členům typu mít různé charakteristiky. jazyky však nejsou vyžadovány k podpoře všech těchto vlastností.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-330">The common type system allows type members to have a variety of characteristics; however, languages are not required to support all these characteristics.</span></span> <span data-ttu-id="1e5c2-331">Následující tabulka obsahuje popis vlastností členů.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-331">The following table describes member characteristics.</span></span>  
  
|<span data-ttu-id="1e5c2-332">Charakteristika</span><span class="sxs-lookup"><span data-stu-id="1e5c2-332">Characteristic</span></span>|<span data-ttu-id="1e5c2-333">Může platit pro</span><span class="sxs-lookup"><span data-stu-id="1e5c2-333">Can apply to</span></span>|<span data-ttu-id="1e5c2-334">Popis</span><span class="sxs-lookup"><span data-stu-id="1e5c2-334">Description</span></span>|  
|--------------------|------------------|-----------------|  
|<span data-ttu-id="1e5c2-335">abstract</span><span class="sxs-lookup"><span data-stu-id="1e5c2-335">abstract</span></span>|<span data-ttu-id="1e5c2-336">Metody, vlastnosti a události</span><span class="sxs-lookup"><span data-stu-id="1e5c2-336">Methods, properties, and events</span></span>|<span data-ttu-id="1e5c2-337">Typ neposkytuje implementaci metody.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-337">The type does not supply the method's implementation.</span></span> <span data-ttu-id="1e5c2-338">Typy, které dědí nebo implementují abstraktní metody, musí poskytovat implementaci pro metodu.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-338">Types that inherit or implement abstract methods must supply an implementation for the method.</span></span> <span data-ttu-id="1e5c2-339">Jediná výjimka je v případě, že odvozený typ je sám abstraktní typ.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-339">The only exception is when the derived type is itself an abstract type.</span></span> <span data-ttu-id="1e5c2-340">Všechny abstraktní metody jsou virtuální.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-340">All abstract methods are virtual.</span></span>|  
|<span data-ttu-id="1e5c2-341">privátní, Rodina, sestavení, rodina a sestavení, Rodina, sestavení nebo veřejné</span><span class="sxs-lookup"><span data-stu-id="1e5c2-341">private, family, assembly, family and assembly, family or assembly, or public</span></span>|<span data-ttu-id="1e5c2-342">Vše</span><span class="sxs-lookup"><span data-stu-id="1e5c2-342">All</span></span>|<span data-ttu-id="1e5c2-343">Definuje přístupnost člena:</span><span class="sxs-lookup"><span data-stu-id="1e5c2-343">Defines the accessibility of the member:</span></span><br /><br /> <span data-ttu-id="1e5c2-344">private</span><span class="sxs-lookup"><span data-stu-id="1e5c2-344">private</span></span><br /> <span data-ttu-id="1e5c2-345">Přístupný pouze v rámci stejného typu jako člen nebo v rámci vnořeného typu.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-345">Accessible only from within the same type as the member, or within a nested type.</span></span><br /><br /> <span data-ttu-id="1e5c2-346">family</span><span class="sxs-lookup"><span data-stu-id="1e5c2-346">family</span></span><br /> <span data-ttu-id="1e5c2-347">Přístupné ze stejného typu jako člen a z odvozeného typu, který z něj dědí.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-347">Accessible from within the same type as the member, and from derived types that inherit from it.</span></span><br /><br /> <span data-ttu-id="1e5c2-348">sestavení</span><span class="sxs-lookup"><span data-stu-id="1e5c2-348">assembly</span></span><br /> <span data-ttu-id="1e5c2-349">Přístupný pouze v sestavení, ve kterém je definován typ.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-349">Accessible only in the assembly in which the type is defined.</span></span><br /><br /> <span data-ttu-id="1e5c2-350">Rodina a sestavení</span><span class="sxs-lookup"><span data-stu-id="1e5c2-350">family and assembly</span></span><br /> <span data-ttu-id="1e5c2-351">Přístupný pouze z typů, které jsou způsobilé pro rodinu a přístup k sestavení.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-351">Accessible only from types that qualify for both family and assembly access.</span></span><br /><br /> <span data-ttu-id="1e5c2-352">řada nebo sestavení</span><span class="sxs-lookup"><span data-stu-id="1e5c2-352">family or assembly</span></span><br /> <span data-ttu-id="1e5c2-353">Přístupný pouze z typů, které jsou způsobilé pro přístup buď k rodině, nebo k sestavení.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-353">Accessible only from types that qualify for either family or assembly access.</span></span><br /><br /> <span data-ttu-id="1e5c2-354">public</span><span class="sxs-lookup"><span data-stu-id="1e5c2-354">public</span></span><br /> <span data-ttu-id="1e5c2-355">Přístupný z libovolného typu.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-355">Accessible from any type.</span></span>|  
|<span data-ttu-id="1e5c2-356">finální</span><span class="sxs-lookup"><span data-stu-id="1e5c2-356">final</span></span>|<span data-ttu-id="1e5c2-357">Metody, vlastnosti a události</span><span class="sxs-lookup"><span data-stu-id="1e5c2-357">Methods, properties, and events</span></span>|<span data-ttu-id="1e5c2-358">Virtuální metodu nelze přepsat v odvozeném typu.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-358">The virtual method cannot be overridden in a derived type.</span></span>|  
|<span data-ttu-id="1e5c2-359">pouze pro inicializaci</span><span class="sxs-lookup"><span data-stu-id="1e5c2-359">initialize-only</span></span>|<span data-ttu-id="1e5c2-360">Pole</span><span class="sxs-lookup"><span data-stu-id="1e5c2-360">Fields</span></span>|<span data-ttu-id="1e5c2-361">Hodnotu lze inicializovat pouze a nelze ji zapsat po inicializaci.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-361">The value can only be initialized, and cannot be written after initialization.</span></span>|  
|<span data-ttu-id="1e5c2-362">případě</span><span class="sxs-lookup"><span data-stu-id="1e5c2-362">instance</span></span>|<span data-ttu-id="1e5c2-363">Pole, metody, vlastnosti a události</span><span class="sxs-lookup"><span data-stu-id="1e5c2-363">Fields, methods, properties, and events</span></span>|<span data-ttu-id="1e5c2-364">Pokud člen není označen jako `static` (c# a c++), `Shared` (Visual Basic), `virtual` (c# a c++) nebo `Overridable` (Visual Basic), je členem instance (není k dispozici žádné klíčové slovo instance).</span><span class="sxs-lookup"><span data-stu-id="1e5c2-364">If a member is not marked as `static` (C# and C++), `Shared` (Visual Basic), `virtual` (C# and C++), or `Overridable` (Visual Basic), it is an instance member (there is no instance keyword).</span></span> <span data-ttu-id="1e5c2-365">V paměti bude tolik kopií takových členů, jako jsou objekty, které ho používají.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-365">There will be as many copies of such members in memory as there are objects that use it.</span></span>|  
|<span data-ttu-id="1e5c2-366">literál</span><span class="sxs-lookup"><span data-stu-id="1e5c2-366">literal</span></span>|<span data-ttu-id="1e5c2-367">Pole</span><span class="sxs-lookup"><span data-stu-id="1e5c2-367">Fields</span></span>|<span data-ttu-id="1e5c2-368">Hodnota přiřazená k poli je pevná hodnota, která je známá v době kompilace předdefinovaného typu hodnoty.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-368">The value assigned to the field is a fixed value, known at compile time, of a built-in value type.</span></span> <span data-ttu-id="1e5c2-369">Pole literálu jsou někdy označována jako konstanty.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-369">Literal fields are sometimes referred to as constants.</span></span>|  
|<span data-ttu-id="1e5c2-370">NewSlot nebo override</span><span class="sxs-lookup"><span data-stu-id="1e5c2-370">newslot or override</span></span>|<span data-ttu-id="1e5c2-371">Vše</span><span class="sxs-lookup"><span data-stu-id="1e5c2-371">All</span></span>|<span data-ttu-id="1e5c2-372">Definuje, jak člen komunikuje se zděděnými členy, které mají stejnou signaturu:</span><span class="sxs-lookup"><span data-stu-id="1e5c2-372">Defines how the member interacts with inherited members that have the same signature:</span></span><br /><br /> <span data-ttu-id="1e5c2-373">NewSlot</span><span class="sxs-lookup"><span data-stu-id="1e5c2-373">newslot</span></span><br /> <span data-ttu-id="1e5c2-374">Skryje zděděné členy, které mají stejnou signaturu.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-374">Hides inherited members that have the same signature.</span></span><br /><br /> <span data-ttu-id="1e5c2-375">override</span><span class="sxs-lookup"><span data-stu-id="1e5c2-375">override</span></span><br /> <span data-ttu-id="1e5c2-376">Nahrazuje definici zděděné virtuální metody.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-376">Replaces the definition of an inherited virtual method.</span></span><br /><br /> <span data-ttu-id="1e5c2-377">Výchozí hodnota je NewSlot.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-377">The default is newslot.</span></span>|  
|<span data-ttu-id="1e5c2-378">static</span><span class="sxs-lookup"><span data-stu-id="1e5c2-378">static</span></span>|<span data-ttu-id="1e5c2-379">Pole, metody, vlastnosti a události</span><span class="sxs-lookup"><span data-stu-id="1e5c2-379">Fields, methods, properties, and events</span></span>|<span data-ttu-id="1e5c2-380">Člen patří do typu, ve kterém je definován, nikoli na konkrétní instanci typu; člen existuje i v případě, že instance typu není vytvořena a je sdílena mezi všemi instancemi typu.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-380">The member belongs to the type it is defined on, not to a particular instance of the type; the member exists even if an instance of the type is not created, and it is shared among all instances of the type.</span></span>|  
|<span data-ttu-id="1e5c2-381">virtual</span><span class="sxs-lookup"><span data-stu-id="1e5c2-381">virtual</span></span>|<span data-ttu-id="1e5c2-382">Metody, vlastnosti a události</span><span class="sxs-lookup"><span data-stu-id="1e5c2-382">Methods, properties, and events</span></span>|<span data-ttu-id="1e5c2-383">Metoda může být implementována odvozeným typem a lze ji vyvolat staticky nebo dynamicky.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-383">The method can be implemented by a derived type and can be invoked either statically or dynamically.</span></span> <span data-ttu-id="1e5c2-384">Pokud se používá dynamické volání, typ instance, která provádí volání v době běhu (spíše než typ známý v době kompilace), určuje, která implementace metody je volána.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-384">If dynamic invocation is used, the type of the instance that makes the call at run time (rather than the type known at compile time) determines which implementation of the method is called.</span></span> <span data-ttu-id="1e5c2-385">Chcete-li vyvolat virtuální metodu staticky, proměnná může být převedena na typ, který používá požadovanou verzi metody.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-385">To invoke a virtual method statically, the variable might have to be cast to a type that uses the desired version of the method.</span></span>|  
  
### <a name="overloading"></a><span data-ttu-id="1e5c2-386">Přetížení</span><span class="sxs-lookup"><span data-stu-id="1e5c2-386">Overloading</span></span>  
 <span data-ttu-id="1e5c2-387">Každý člen typu má jedinečný podpis.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-387">Each type member has a unique signature.</span></span> <span data-ttu-id="1e5c2-388">Signatury metody se skládají z názvu metody a seznamu parametrů (pořadí a typy argumentů metody).</span><span class="sxs-lookup"><span data-stu-id="1e5c2-388">Method signatures consist of the method name and a parameter list (the order and types of the method's arguments).</span></span> <span data-ttu-id="1e5c2-389">V rámci typu lze definovat více metod se stejným názvem, pokud se jejich signatury liší.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-389">Multiple methods with the same name can be defined within a type as long as their signatures differ.</span></span> <span data-ttu-id="1e5c2-390">Pokud jsou definovány dvě nebo více metod se stejným názvem, je metoda označována jako přetížená.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-390">When two or more methods with the same name are defined, the method is said to be overloaded.</span></span> <span data-ttu-id="1e5c2-391">Například v je <xref:System.Char?displayProperty=nameWithType> <xref:System.Char.IsDigit%2A> Metoda přetížena.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-391">For example, in <xref:System.Char?displayProperty=nameWithType>, the <xref:System.Char.IsDigit%2A> method is overloaded.</span></span> <span data-ttu-id="1e5c2-392">Jedna metoda přijímá <xref:System.Char> .</span><span class="sxs-lookup"><span data-stu-id="1e5c2-392">One method takes a <xref:System.Char>.</span></span> <span data-ttu-id="1e5c2-393">Druhá metoda bere <xref:System.String> a <xref:System.Int32> .</span><span class="sxs-lookup"><span data-stu-id="1e5c2-393">The other method takes a <xref:System.String> and an <xref:System.Int32>.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="1e5c2-394">Návratový typ není považován za součást signatury metody.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-394">The return type is not considered part of a method's signature.</span></span> <span data-ttu-id="1e5c2-395">To znamená, že metody nemohou být přetíženy, pokud se liší pouze návratovým typem.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-395">That is, methods cannot be overloaded if they differ only by return type.</span></span>  
  
### <a name="inherit-override-and-hide-members"></a><span data-ttu-id="1e5c2-396">Dědění, přepsání a skrytí členů</span><span class="sxs-lookup"><span data-stu-id="1e5c2-396">Inherit, override, and hide members</span></span>  
 <span data-ttu-id="1e5c2-397">Odvozený typ dědí všechny členy svého základního typu; To znamená, že tyto členy jsou definovány v a jsou k dispozici pro odvozený typ.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-397">A derived type inherits all members of its base type; that is, these members are defined on, and available to, the derived type.</span></span> <span data-ttu-id="1e5c2-398">Chování nebo vlastnosti zděděných členů lze upravit dvěma způsoby:</span><span class="sxs-lookup"><span data-stu-id="1e5c2-398">The behavior or qualities of inherited members can be modified in two ways:</span></span>  
  
- <span data-ttu-id="1e5c2-399">Odvozený typ může skrýt zděděného člena definováním nového člena se stejnou signaturou.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-399">A derived type can hide an inherited member by defining a new member with the same signature.</span></span> <span data-ttu-id="1e5c2-400">To může být provedeno pro vytvoření privátního veřejného člena nebo pro definování nového chování pro zděděnou metodu, která je označena jako `final` .</span><span class="sxs-lookup"><span data-stu-id="1e5c2-400">This might be done to make a previously public member private or to define new behavior for an inherited method that is marked as `final`.</span></span>  
  
- <span data-ttu-id="1e5c2-401">Odvozený typ může přepsat zděděnou virtuální metodu.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-401">A derived type can override an inherited virtual method.</span></span> <span data-ttu-id="1e5c2-402">Přepisování metody poskytuje novou definici metody, která bude vyvolána na základě typu hodnoty v době běhu, nikoli typu proměnné známé v době kompilace.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-402">The overriding method provides a new definition of the method that will be invoked based on the type of the value at run time rather than the type of the variable known at compile time.</span></span> <span data-ttu-id="1e5c2-403">Metoda může přepsat virtuální metodu pouze v případě, že virtuální metoda není označena jako `final` a nová metoda je přinejmenším dostupná jako virtuální metoda.</span><span class="sxs-lookup"><span data-stu-id="1e5c2-403">A method can override a virtual method only if the virtual method is not marked as `final` and the new method is at least as accessible as the virtual method.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="1e5c2-404">Viz také</span><span class="sxs-lookup"><span data-stu-id="1e5c2-404">See also</span></span>

- [<span data-ttu-id="1e5c2-405">.NET API – prohlížeč</span><span class="sxs-lookup"><span data-stu-id="1e5c2-405">.NET API Browser</span></span>](/dotnet/api)
- [<span data-ttu-id="1e5c2-406">CLR (Common Language Runtime)</span><span class="sxs-lookup"><span data-stu-id="1e5c2-406">Common Language Runtime</span></span>](../clr.md)
- [<span data-ttu-id="1e5c2-407">Převod typu v .NET</span><span class="sxs-lookup"><span data-stu-id="1e5c2-407">Type Conversion in .NET</span></span>](type-conversion.md)
