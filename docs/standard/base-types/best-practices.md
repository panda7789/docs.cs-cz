---
title: Doporučené postupy pro regulární výrazy v rozhraní .NET
description: Naučte se vytvářet efektivní a efektivní regulární výrazy v rozhraní .NET.
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- .NET Framework regular expressions, best practices
- regular expressions, best practices
ms.assetid: 618e5afb-3a97-440d-831a-70e4c526a51c
ms.openlocfilehash: 9b09f5a2505888c6154a58a3512c94c51f89295b
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 03/15/2020
ms.locfileid: "77124419"
---
# <a name="best-practices-for-regular-expressions-in-net"></a><span data-ttu-id="2eaca-103">Doporučené postupy pro regulární výrazy v rozhraní .NET</span><span class="sxs-lookup"><span data-stu-id="2eaca-103">Best practices for regular expressions in .NET</span></span>

<span data-ttu-id="2eaca-104">Modul regulárních výrazů v rozhraní .NET je výkonný, plně vybavený nástroj, který zpracovává text na základě shody vzorku, nikoli na porovnávání a porovnávání doslovného textu.</span><span class="sxs-lookup"><span data-stu-id="2eaca-104">The regular expression engine in .NET is a powerful, full-featured tool that processes text based on pattern matches rather than on comparing and matching literal text.</span></span> <span data-ttu-id="2eaca-105">Ve většině případů provádí porovnání vzorů rychle a efektivně.</span><span class="sxs-lookup"><span data-stu-id="2eaca-105">In most cases, it performs pattern matching rapidly and efficiently.</span></span> <span data-ttu-id="2eaca-106">V některých případech se však může zdát, že je modul regulárních výrazů velmi pomalý.</span><span class="sxs-lookup"><span data-stu-id="2eaca-106">However, in some cases, the regular expression engine can appear to be very slow.</span></span> <span data-ttu-id="2eaca-107">V extrémních případech se může dokonce zdát, že přestal při zpracování relativně malého vstupu odpovídat po dobu hodin nebo dokonce dní.</span><span class="sxs-lookup"><span data-stu-id="2eaca-107">In extreme cases, it can even appear to stop responding as it processes a relatively small input over the course of hours or even days.</span></span>

<span data-ttu-id="2eaca-108">Toto téma nastiňuje některé osvědčené postupy, které si mohou vývojáři osvojit za účelem dosažení optimálního výkonu regulárních výrazů.</span><span class="sxs-lookup"><span data-stu-id="2eaca-108">This topic outlines some of the best practices that developers can adopt to ensure that their regular expressions achieve optimal performance.</span></span>

## <a name="consider-the-input-source"></a><span data-ttu-id="2eaca-109">Zvažte vstupní zdroj</span><span class="sxs-lookup"><span data-stu-id="2eaca-109">Consider the input source</span></span>

<span data-ttu-id="2eaca-110">Regulární výrazy mohou většinou přijmout dva typy vstupů: vstupy s omezením a vstupy bez omezení.</span><span class="sxs-lookup"><span data-stu-id="2eaca-110">In general, regular expressions can accept two types of input: constrained or unconstrained.</span></span> <span data-ttu-id="2eaca-111">Vstup s omezením je text, který pochází ze známého nebo ověřeného zdroje a odpovídá předdefinovanému formátu.</span><span class="sxs-lookup"><span data-stu-id="2eaca-111">Constrained input is text that originates from a known or reliable source and follows a predefined format.</span></span> <span data-ttu-id="2eaca-112">Vstup bez omezení je text, který pochází z neověřeného zdroje, jako je například uživatel webu, a nemusí odpovídat předdefinovanému nebo očekávanému formátu.</span><span class="sxs-lookup"><span data-stu-id="2eaca-112">Unconstrained input is text that originates from an unreliable source, such as a web user, and may not follow a predefined or expected format.</span></span>

<span data-ttu-id="2eaca-113">Vzory regulárních výrazů jsou obvykle napsány tak, aby odpovídaly platnému vstupu.</span><span class="sxs-lookup"><span data-stu-id="2eaca-113">Regular expression patterns are typically written to match valid input.</span></span> <span data-ttu-id="2eaca-114">Vývojáři totiž prozkoumají text, který chtějí porovnat, a následně napíšou vzor regulárního výrazu, který mu odpovídá.</span><span class="sxs-lookup"><span data-stu-id="2eaca-114">That is, developers examine the text that they want to match and then write a regular expression pattern that matches it.</span></span> <span data-ttu-id="2eaca-115">Vývojáři následně určí, zda tento vzor vyžaduje korekci nebo další zpracování testováním pomocí většího množství platných vstupních položek.</span><span class="sxs-lookup"><span data-stu-id="2eaca-115">Developers then determine whether this pattern requires correction or further elaboration by testing it with multiple valid input items.</span></span> <span data-ttu-id="2eaca-116">Pokud vzor odpovídá všem předpokládaným platným vstupům, je možné jej uvést do produkce a může být vložen do vydané aplikace.</span><span class="sxs-lookup"><span data-stu-id="2eaca-116">When the pattern matches all presumed valid inputs, it is declared to be production-ready and can be included in a released application.</span></span> <span data-ttu-id="2eaca-117">To znamená, že vzor regulárního výrazu je vhodný pro porovnávání se vstupem s omezením.</span><span class="sxs-lookup"><span data-stu-id="2eaca-117">This makes a regular expression pattern suitable for matching constrained input.</span></span> <span data-ttu-id="2eaca-118">Neznamená to však, že je vhodný pro porovnávání se vstupem bez omezení.</span><span class="sxs-lookup"><span data-stu-id="2eaca-118">However, it does not make it suitable for matching unconstrained input.</span></span>

<span data-ttu-id="2eaca-119">Aby mohl regulární výraz odpovídat vstupu bez omezení, musí být schopen efektivně zpracovat tři druhy textu:</span><span class="sxs-lookup"><span data-stu-id="2eaca-119">To match unconstrained input, a regular expression must be able to efficiently handle three kinds of text:</span></span>

- <span data-ttu-id="2eaca-120">Text, který odpovídá vzoru regulárního výrazu.</span><span class="sxs-lookup"><span data-stu-id="2eaca-120">Text that matches the regular expression pattern.</span></span>

- <span data-ttu-id="2eaca-121">Text, který neodpovídá vzoru regulárního výrazu.</span><span class="sxs-lookup"><span data-stu-id="2eaca-121">Text that does not match the regular expression pattern.</span></span>

- <span data-ttu-id="2eaca-122">Text, který téměř odpovídá vzoru regulárního výrazu.</span><span class="sxs-lookup"><span data-stu-id="2eaca-122">Text that nearly matches the regular expression pattern.</span></span>

<span data-ttu-id="2eaca-123">Poslední typ je zvláště problematický pro regulární výrazy, které jsou napsány tak, aby zpracovávaly vstup s omezením.</span><span class="sxs-lookup"><span data-stu-id="2eaca-123">The last text type is especially problematic for a regular expression that has been written to handle constrained input.</span></span> <span data-ttu-id="2eaca-124">Pokud tento regulární výraz také závisí na [rozsáhlém navracení](../../../docs/standard/base-types/backtracking-in-regular-expressions.md), modul regulárních výrazů může strávit nadměrné množství času (v některých případech mnoho hodin nebo dní) zpracovánízdánlivě neškodného textu.</span><span class="sxs-lookup"><span data-stu-id="2eaca-124">If that regular expression also relies on extensive [backtracking](../../../docs/standard/base-types/backtracking-in-regular-expressions.md), the regular expression engine can spend an inordinate amount of time (in some cases, many hours or days) processing seemingly innocuous text.</span></span>

> [!WARNING]
> <span data-ttu-id="2eaca-125">V následujícím příkladu je použit regulární výraz, který je náchylný na časté používání mechanismu zpětného navracení a který pravděpodobně zamítne platné e-mailové adresy.</span><span class="sxs-lookup"><span data-stu-id="2eaca-125">The following example uses a regular expression that is prone to excessive backtracking and that is likely to reject valid email addresses.</span></span> <span data-ttu-id="2eaca-126">Neměl by být používán v rutině ověřování e-mailové adresy.</span><span class="sxs-lookup"><span data-stu-id="2eaca-126">You should not use it in an email validation routine.</span></span> <span data-ttu-id="2eaca-127">Pokud chcete regulární výraz, který ověřuje e-mailové adresy, [přečtěte si postup: Ověření, zda jsou řetězce v platném formátu e-mailu](../../../docs/standard/base-types/how-to-verify-that-strings-are-in-valid-email-format.md).</span><span class="sxs-lookup"><span data-stu-id="2eaca-127">If you would like a regular expression that validates email addresses, see [How to: Verify that Strings Are in Valid Email Format](../../../docs/standard/base-types/how-to-verify-that-strings-are-in-valid-email-format.md).</span></span>

<span data-ttu-id="2eaca-128">Předpokládejme například velmi často používaný, ale extrémně problematický regulární výraz pro ověřování aliasu e-mailové adresy.</span><span class="sxs-lookup"><span data-stu-id="2eaca-128">For example, consider a very commonly used but extremely problematic regular expression for validating the alias of an email address.</span></span> <span data-ttu-id="2eaca-129">Regulární `^[0-9A-Z]([-.\w]*[0-9A-Z])*$` výraz je zapsán ke zpracování platné e-mailové adresy, která se skládá z alfanumerického znaku následovaného nulou nebo více znaky, které mohou být alfanumerické, tečky nebo pomlčky.</span><span class="sxs-lookup"><span data-stu-id="2eaca-129">The regular expression `^[0-9A-Z]([-.\w]*[0-9A-Z])*$` is written to process what is considered to be a valid email address, which consists of an alphanumeric character, followed by zero or more characters that can be alphanumeric, periods, or hyphens.</span></span> <span data-ttu-id="2eaca-130">Regulární výraz musí končit alfanumerickým znakem.</span><span class="sxs-lookup"><span data-stu-id="2eaca-130">The regular expression must end with an alphanumeric character.</span></span> <span data-ttu-id="2eaca-131">Ačkoli tento regulární výraz snadno zpracovává platný vstup, je velmi neefektivní při zpracování téměř platného vstupu, jak vyplývá z následujícího příkladu.</span><span class="sxs-lookup"><span data-stu-id="2eaca-131">However, as the following example shows, although this regular expression handles valid input easily, its performance is very inefficient when it is processing nearly valid input.</span></span>

[!code-csharp[Conceptual.RegularExpressions.BestPractices#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/design2.cs#1)]
[!code-vb[Conceptual.RegularExpressions.BestPractices#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/design2.vb#1)]

<span data-ttu-id="2eaca-132">Jak znázorňuje výstup v příkladu, zpracovává modul regulárních výrazů platný alias e-mailové adresy zhruba stejnou dobu bez ohledu na délku.</span><span class="sxs-lookup"><span data-stu-id="2eaca-132">As the output from the example shows, the regular expression engine processes the valid email alias in about the same time interval regardless of its length.</span></span> <span data-ttu-id="2eaca-133">Na druhou stranu platí, že pokud téměř platná e-mailová adresa obsahuje více než pět znaků, čas zpracování se po přidání každého dalšího znaku do řetězce přibližně zdvojnásobí.</span><span class="sxs-lookup"><span data-stu-id="2eaca-133">On the other hand, when the nearly valid email address has more than five characters, processing time approximately doubles for each additional character in the string.</span></span> <span data-ttu-id="2eaca-134">To znamená, že zpracování téměř platného osmadvacetiznakového řetězce může trvat více než hodinu a zpracování téměř platného třiatřicetiznakového řetězce bude trvat skoro celý den.</span><span class="sxs-lookup"><span data-stu-id="2eaca-134">This means that a nearly valid 28-character string would take over an hour to process, and a nearly valid 33-character string would take nearly a day to process.</span></span>

<span data-ttu-id="2eaca-135">Vzhledem k tomu, že tento regulární řetězec byl vytvořen pouze za předpokladu, že formát vstupu se bude shodovat, nebere v potaz vstup, který neodpovídá vzoru.</span><span class="sxs-lookup"><span data-stu-id="2eaca-135">Because this regular expression was developed solely by considering the format of input to be matched, it fails to take account of input that does not match the pattern.</span></span> <span data-ttu-id="2eaca-136">Tato skutečnost pak může vést k tomu, že vstup bez omezení, který téměř odpovídá vzoru regulárního výrazu, významně sníží výkon.</span><span class="sxs-lookup"><span data-stu-id="2eaca-136">This, in turn, can allow unconstrained input that nearly matches the regular expression pattern to significantly degrade performance.</span></span>

<span data-ttu-id="2eaca-137">Chcete-li tento problém vyřešit, proveďte následující akce:</span><span class="sxs-lookup"><span data-stu-id="2eaca-137">To solve this problem, you can do the following:</span></span>

- <span data-ttu-id="2eaca-138">Při vytváření vzoru je třeba zvážit, jakým způsobem mechanismus zpětného navracení může ovlivnit výkon modulu regulárních výrazů, především tehdy, pokud je regulární výraz navržen pro zpracování vstupu bez omezení.</span><span class="sxs-lookup"><span data-stu-id="2eaca-138">When developing a pattern, you should consider how backtracking might affect the performance of the regular expression engine, particularly if your regular expression is designed to process unconstrained input.</span></span> <span data-ttu-id="2eaca-139">Další informace naleznete v části [Převzít zpětnosné navracení.](#take-charge-of-backtracking)</span><span class="sxs-lookup"><span data-stu-id="2eaca-139">For more information, see the [Take Charge of Backtracking](#take-charge-of-backtracking) section.</span></span>

- <span data-ttu-id="2eaca-140">Regulární výraz je nutné důkladně odzkoušet pomocí neplatných vstupů, téměř platných vstupů a také platných vstupů.</span><span class="sxs-lookup"><span data-stu-id="2eaca-140">Thoroughly test your regular expression using invalid and near-valid input as well as valid input.</span></span> <span data-ttu-id="2eaca-141">Chcete-li generovat vstup pro konkrétní regulární výraz náhodně, můžete použít [Rex](https://www.microsoft.com/research/project/rex-regular-expression-exploration/), což je nástroj pro průzkum regulárních výrazů z microsoft research.</span><span class="sxs-lookup"><span data-stu-id="2eaca-141">To generate input for a particular regular expression randomly, you can use [Rex](https://www.microsoft.com/research/project/rex-regular-expression-exploration/), which is a regular expression exploration tool from Microsoft Research.</span></span>

## <a name="handle-object-instantiation-appropriately"></a><span data-ttu-id="2eaca-142">Správně popisovat vytvoření instance objektu</span><span class="sxs-lookup"><span data-stu-id="2eaca-142">Handle object instantiation appropriately</span></span>

<span data-ttu-id="2eaca-143">V srdci . NET je objektový model <xref:System.Text.RegularExpressions.Regex?displayProperty=nameWithType> regulárního výrazu třída, která představuje modul regulárních výrazů.</span><span class="sxs-lookup"><span data-stu-id="2eaca-143">At the heart of .NET’s regular expression object model is the <xref:System.Text.RegularExpressions.Regex?displayProperty=nameWithType> class, which represents the regular expression engine.</span></span> <span data-ttu-id="2eaca-144">Často jeden největší faktor, který ovlivňuje výkon regulárních výrazů je způsob, jakým <xref:System.Text.RegularExpressions.Regex> je použit modul.</span><span class="sxs-lookup"><span data-stu-id="2eaca-144">Often, the single greatest factor that affects regular expression performance is the way in which the <xref:System.Text.RegularExpressions.Regex> engine is used.</span></span> <span data-ttu-id="2eaca-145">Definování regulárního výrazu zahrnuje pevné párování modulu regulárních výrazů se vzorem regulárního výrazu.</span><span class="sxs-lookup"><span data-stu-id="2eaca-145">Defining a regular expression involves tightly coupling the regular expression engine with a regular expression pattern.</span></span> <span data-ttu-id="2eaca-146">Tento proces párování, zda zahrnuje vytvoření <xref:System.Text.RegularExpressions.Regex> instance objektu předáním jeho konstruktoru vzor regulárního výrazu nebo volání statické metody předáním vzor regulárního výrazu spolu s řetězcem, který má být analyzován, je z nutnosti nákladné jeden.</span><span class="sxs-lookup"><span data-stu-id="2eaca-146">That coupling process, whether it involves instantiating a <xref:System.Text.RegularExpressions.Regex> object by passing its constructor a regular expression pattern or calling a static method by passing it the regular expression pattern along with the string to be analyzed, is by necessity an expensive one.</span></span>

> [!NOTE]
> <span data-ttu-id="2eaca-147">Podrobnější informace o dopadech použití interpretovaných a kompilovaných regulárních výrazů na výkon výkonu interpretace, [část II: Převzetí zpětného navracení](https://docs.microsoft.com/archive/blogs/bclteam/optimizing-regular-expression-performance-part-ii-taking-charge-of-backtracking-ron-petrusha) v blogu týmu BCL.</span><span class="sxs-lookup"><span data-stu-id="2eaca-147">For a more detailed discussion of the performance implications of using interpreted and compiled regular expressions, see [Optimizing Regular Expression Performance, Part II: Taking Charge of Backtracking](https://docs.microsoft.com/archive/blogs/bclteam/optimizing-regular-expression-performance-part-ii-taking-charge-of-backtracking-ron-petrusha) in the BCL Team blog.</span></span>

<span data-ttu-id="2eaca-148">Modul regulárních výrazů lze spárovat s konkrétním vzorem regulárního výrazu a následně modul použít pro porovnání textu několika různými způsoby:</span><span class="sxs-lookup"><span data-stu-id="2eaca-148">You can couple the regular expression engine with a particular regular expression pattern and then use the engine to match text in several ways:</span></span>

- <span data-ttu-id="2eaca-149">Můžete volat statickou metodu porovnávání <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29?displayProperty=nameWithType>vzorů, například .</span><span class="sxs-lookup"><span data-stu-id="2eaca-149">You can call a static pattern-matching method, such as <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29?displayProperty=nameWithType>.</span></span> <span data-ttu-id="2eaca-150">Tato akce nevyžaduje vytvoření instance objektu regulárních výrazů.</span><span class="sxs-lookup"><span data-stu-id="2eaca-150">This does not require instantiation of a regular expression object.</span></span>

- <span data-ttu-id="2eaca-151">Můžete vytvořit instanci <xref:System.Text.RegularExpressions.Regex> objektu a volat metodu porovnávání vzorů instance interpretovaného regulárního výrazu.</span><span class="sxs-lookup"><span data-stu-id="2eaca-151">You can instantiate a <xref:System.Text.RegularExpressions.Regex> object and call an instance pattern-matching method of an interpreted regular expression.</span></span> <span data-ttu-id="2eaca-152">Toto je výchozí metoda pro vytvoření vazby modulu regulárních výrazů se vzorem regulárního výrazu.</span><span class="sxs-lookup"><span data-stu-id="2eaca-152">This is the default method for binding the regular expression engine to a regular expression pattern.</span></span> <span data-ttu-id="2eaca-153">Výsledkem je, <xref:System.Text.RegularExpressions.Regex> když je objekt `options` vytvořena bez <xref:System.Text.RegularExpressions.RegexOptions.Compiled> argumentu, který obsahuje příznak.</span><span class="sxs-lookup"><span data-stu-id="2eaca-153">It results when a <xref:System.Text.RegularExpressions.Regex> object is instantiated without an `options` argument that includes the <xref:System.Text.RegularExpressions.RegexOptions.Compiled> flag.</span></span>

- <span data-ttu-id="2eaca-154">Můžete vytvořit instanci <xref:System.Text.RegularExpressions.Regex> objektu a volat metodu porovnávání vzorů instance zkompilovaného regulárního výrazu.</span><span class="sxs-lookup"><span data-stu-id="2eaca-154">You can instantiate a <xref:System.Text.RegularExpressions.Regex> object and call an instance pattern-matching method of a compiled regular expression.</span></span> <span data-ttu-id="2eaca-155">Objekty regulárních výrazů <xref:System.Text.RegularExpressions.Regex> představují kompilované vzorky, když je objekt instanci s argumentem, `options` který obsahuje <xref:System.Text.RegularExpressions.RegexOptions.Compiled> příznak.</span><span class="sxs-lookup"><span data-stu-id="2eaca-155">Regular expression objects represent compiled patterns when a <xref:System.Text.RegularExpressions.Regex> object is instantiated with an `options` argument that includes the <xref:System.Text.RegularExpressions.RegexOptions.Compiled> flag.</span></span>

- <span data-ttu-id="2eaca-156">Můžete vytvořit objekt pro <xref:System.Text.RegularExpressions.Regex> speciální účely, který je pevně spojen s určitým vzorem regulárního výrazu, zkompilovat jej a uložit do samostatného sestavení.</span><span class="sxs-lookup"><span data-stu-id="2eaca-156">You can create a special-purpose <xref:System.Text.RegularExpressions.Regex> object that is tightly coupled with a particular regular expression pattern, compile it, and save it to a standalone assembly.</span></span> <span data-ttu-id="2eaca-157">Provést voláním <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="2eaca-157">You do this by calling the <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A?displayProperty=nameWithType> method.</span></span>

<span data-ttu-id="2eaca-158">Způsob, jakým budou metody porovnávání regulárních výrazů volány, může mít zásadní vliv na vaši aplikaci.</span><span class="sxs-lookup"><span data-stu-id="2eaca-158">The particular way in which you call regular expression matching methods can have a significant impact on your application.</span></span> <span data-ttu-id="2eaca-159">V následujících částech jsou probírány způsoby volání statických metod, interpretovaných regulárních výrazů a zkompilovaných regulárních výrazů za účelem zvýšení výkonu aplikace.</span><span class="sxs-lookup"><span data-stu-id="2eaca-159">The following sections discuss when to use static method calls, interpreted regular expressions, and compiled regular expressions to improve your application's performance.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="2eaca-160">Způsob volání metod (statické, interpretované, zkompilované) ovlivňuje výkon, pokud pro volání metod použijete stejný regulární výraz, nebo pokud aplikace příliš často používá objekty regulárních výrazů.</span><span class="sxs-lookup"><span data-stu-id="2eaca-160">The form of the method call (static, interpreted, compiled) affects performance if the same regular expression is used repeatedly in method calls, or if an application makes extensive use of regular expression objects.</span></span>

### <a name="static-regular-expressions"></a><span data-ttu-id="2eaca-161">Statické regulární výrazy</span><span class="sxs-lookup"><span data-stu-id="2eaca-161">Static regular expressions</span></span>

<span data-ttu-id="2eaca-162">Statické metody regulárních výrazů jsou vhodnou alternativou k opakovanému vytváření instancí objektů regulárních výrazů se stejným regulárním výrazem.</span><span class="sxs-lookup"><span data-stu-id="2eaca-162">Static regular expression methods are recommended as an alternative to repeatedly instantiating a regular expression object with the same regular expression.</span></span> <span data-ttu-id="2eaca-163">Na rozdíl od vzorů regulárních výrazů používaných objekty regulárních výrazů jsou kódy operací nebo zkompilovaný zprostředkující jazyk Microsoftu (MSIL) ze vzorků používaných ve volání chodu statické metody interně ukládádo mezipaměti modulu regulárních výrazů.</span><span class="sxs-lookup"><span data-stu-id="2eaca-163">Unlike regular expression patterns used by regular expression objects, either the operation codes or the compiled Microsoft intermediate language (MSIL) from patterns used in static method calls is cached internally by the regular expression engine.</span></span>

<span data-ttu-id="2eaca-164">Například pro ověření uživatelského vstupu volá obslužná rutina události často jinou metodu.</span><span class="sxs-lookup"><span data-stu-id="2eaca-164">For example, an event handler frequently calls another method to validate user input.</span></span> <span data-ttu-id="2eaca-165">To se projeví v následujícím kódu, ve kterém se událost ovládacího <xref:System.Windows.Forms.Button> <xref:System.Windows.Forms.Control.Click> prvku používá k volání metody s názvem `IsValidCurrency`, která kontroluje, zda uživatel zadal symbol měny následovaný alespoň jednou desetinnou číslicí.</span><span class="sxs-lookup"><span data-stu-id="2eaca-165">This is reflected in the following code, in which a <xref:System.Windows.Forms.Button> control's <xref:System.Windows.Forms.Control.Click> event is used to call a method named `IsValidCurrency`, which checks whether the user has entered a currency symbol followed by at least one decimal digit.</span></span>

[!code-csharp[Conceptual.RegularExpressions.BestPractices#2](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/static1.cs#2)]
[!code-vb[Conceptual.RegularExpressions.BestPractices#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/static1.vb#2)]

<span data-ttu-id="2eaca-166">Velmi neefektivní implementace `IsValidCurrency` metody je uvedena v následujícím příkladu.</span><span class="sxs-lookup"><span data-stu-id="2eaca-166">A very inefficient implementation of the `IsValidCurrency` method is shown in the following example.</span></span> <span data-ttu-id="2eaca-167">Všimněte si, že každá metoda <xref:System.Text.RegularExpressions.Regex> volání reinstantiates objekt se stejným vzorem.</span><span class="sxs-lookup"><span data-stu-id="2eaca-167">Note that each method call reinstantiates a <xref:System.Text.RegularExpressions.Regex> object with the same pattern.</span></span> <span data-ttu-id="2eaca-168">To znamená, že vzor regulárního výrazu musí být při každém dalším volání metody znovu zkompilován.</span><span class="sxs-lookup"><span data-stu-id="2eaca-168">This, in turn, means that the regular expression pattern must be recompiled each time the method is called.</span></span>

[!code-csharp[Conceptual.RegularExpressions.BestPractices#3](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/static1.cs#3)]
[!code-vb[Conceptual.RegularExpressions.BestPractices#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/static1.vb#3)]

<span data-ttu-id="2eaca-169">Tento neefektivní kód byste měli nahradit <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29?displayProperty=nameWithType> voláním statické metody.</span><span class="sxs-lookup"><span data-stu-id="2eaca-169">You should replace this inefficient code with a call to the static <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="2eaca-170">To eliminuje potřebu vytvořit instanci <xref:System.Text.RegularExpressions.Regex> objektu pokaždé, když chcete volat metodu porovnávání vzorů, a umožňuje modulu regulárních výrazů načíst z kompilované verze regulárního výrazu z mezipaměti.</span><span class="sxs-lookup"><span data-stu-id="2eaca-170">This eliminates the need to instantiate a <xref:System.Text.RegularExpressions.Regex> object each time you want to call a pattern-matching method, and enables the regular expression engine to retrieve a compiled version of the regular expression from its cache.</span></span>

[!code-csharp[Conceptual.RegularExpressions.BestPractices#4](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/static2.cs#4)]
[!code-vb[Conceptual.RegularExpressions.BestPractices#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/static2.vb#4)]

<span data-ttu-id="2eaca-171">Ve výchozím nastavení je v mezipaměti uloženo posledních 15 použitých vzorů regulárních výrazů.</span><span class="sxs-lookup"><span data-stu-id="2eaca-171">By default, the last 15 most recently used static regular expression patterns are cached.</span></span> <span data-ttu-id="2eaca-172">U aplikací, které vyžadují větší počet statických regulárních výrazů v mezipaměti, lze velikost mezipaměti upravit nastavením vlastnosti. <xref:System.Text.RegularExpressions.Regex.CacheSize%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="2eaca-172">For applications that require a larger number of cached static regular expressions, the size of the cache can be adjusted by setting the <xref:System.Text.RegularExpressions.Regex.CacheSize%2A?displayProperty=nameWithType> property.</span></span>

<span data-ttu-id="2eaca-173">Regulární `\p{Sc}+\s*\d+` výraz, který se používá v tomto příkladu, ověří, zda se vstupní řetězec skládá ze symbolu měny a alespoň jedné desetinné číslice.</span><span class="sxs-lookup"><span data-stu-id="2eaca-173">The regular expression `\p{Sc}+\s*\d+` that is used in this example verifies that the input string consists of a currency symbol and at least one decimal digit.</span></span> <span data-ttu-id="2eaca-174">Vzor je definován tak, jak je uvedeno v následující tabulce.</span><span class="sxs-lookup"><span data-stu-id="2eaca-174">The pattern is defined as shown in the following table.</span></span>

|<span data-ttu-id="2eaca-175">Vzor</span><span class="sxs-lookup"><span data-stu-id="2eaca-175">Pattern</span></span>|<span data-ttu-id="2eaca-176">Popis</span><span class="sxs-lookup"><span data-stu-id="2eaca-176">Description</span></span>|
|-------------|-----------------|
|`\p{Sc}+`|<span data-ttu-id="2eaca-177">Porovná jeden nebo více znaků z kategorie měn a symbolů Unicode.</span><span class="sxs-lookup"><span data-stu-id="2eaca-177">Match one or more characters in the Unicode Symbol, Currency category.</span></span>|
|`\s*`|<span data-ttu-id="2eaca-178">Porovná žádný nebo více prázdných znaků.</span><span class="sxs-lookup"><span data-stu-id="2eaca-178">Match zero or more white-space characters.</span></span>|
|`\d+`|<span data-ttu-id="2eaca-179">Porovná jednu nebo více desítkových číslic.</span><span class="sxs-lookup"><span data-stu-id="2eaca-179">Match one or more decimal digits.</span></span>|

### <a name="interpreted-vs-compiled-regular-expressions"></a><span data-ttu-id="2eaca-180">Interpretováno vs. kompilované regulární výrazy</span><span class="sxs-lookup"><span data-stu-id="2eaca-180">Interpreted vs. compiled regular expressions</span></span>

<span data-ttu-id="2eaca-181">Jsou interpretovány vzory regulárních výrazů, které <xref:System.Text.RegularExpressions.RegexOptions.Compiled> nejsou vázány na modul regulárních výrazů prostřednictvím specifikace možnosti.</span><span class="sxs-lookup"><span data-stu-id="2eaca-181">Regular expression patterns that are not bound to the regular expression engine through the specification of the <xref:System.Text.RegularExpressions.RegexOptions.Compiled> option are interpreted.</span></span> <span data-ttu-id="2eaca-182">Po vytvoření instance objektu regulárního výrazu převede modul regulárních výrazů regulární výraz na množinu kódů operací.</span><span class="sxs-lookup"><span data-stu-id="2eaca-182">When a regular expression object is instantiated, the regular expression engine converts the regular expression to a set of operation codes.</span></span> <span data-ttu-id="2eaca-183">Po zavolání metody instance jsou operační kódy převedeny do jazyka MSIL a provedeny kompilátorem JIT.</span><span class="sxs-lookup"><span data-stu-id="2eaca-183">When an instance method is called, the operation codes are converted to MSIL and executed by the JIT compiler.</span></span> <span data-ttu-id="2eaca-184">Obdobně platí, že pokud zavoláte statickou metodu regulárních výrazů a regulární výraz nelze nalézt v mezipaměti, modul regulárních výrazů převede regulární výraz na množinu operačních kódů a uloží je do mezipaměti.</span><span class="sxs-lookup"><span data-stu-id="2eaca-184">Similarly, when a static regular expression method is called and the regular expression cannot be found in the cache, the regular expression engine converts the regular expression to a set of operation codes and stores them in the cache.</span></span> <span data-ttu-id="2eaca-185">Poté jsou tyto operační kódy převedeny do jazyka MSIL, aby je mohl kompilátor JIT provést.</span><span class="sxs-lookup"><span data-stu-id="2eaca-185">It then converts these operation codes to MSIL so that the JIT compiler can execute them.</span></span> <span data-ttu-id="2eaca-186">U interpretovaných regulárních výrazů je čas spuštění zkrácen na úkor delšího času provádění.</span><span class="sxs-lookup"><span data-stu-id="2eaca-186">Interpreted regular expressions reduce startup time at the cost of slower execution time.</span></span> <span data-ttu-id="2eaca-187">Z tohoto důvodu je nejvhodnější je používat tehdy, pokud je regulární výraz použit v nízkém počtu volání metod, nebo pokud přesný počet volání metod regulárních výrazů není znám, ale očekává se, že bude nízký.</span><span class="sxs-lookup"><span data-stu-id="2eaca-187">Because of this, they are best used when the regular expression is used in a small number of method calls, or if the exact number of calls to regular expression methods is unknown but is expected to be small.</span></span> <span data-ttu-id="2eaca-188">S rostoucím počtem volání metod je výkonový zisk plynoucí z kratší doby spouštění kompenzován nižší rychlostí provádění.</span><span class="sxs-lookup"><span data-stu-id="2eaca-188">As the number of method calls increases, the performance gain from reduced startup time is outstripped by the slower execution speed.</span></span>

<span data-ttu-id="2eaca-189">Jsou kompilovány vzory regulárních výrazů, <xref:System.Text.RegularExpressions.RegexOptions.Compiled> které jsou vázány na modul regulárních výrazů prostřednictvím specifikace možnosti.</span><span class="sxs-lookup"><span data-stu-id="2eaca-189">Regular expression patterns that are bound to the regular expression engine through the specification of the <xref:System.Text.RegularExpressions.RegexOptions.Compiled> option are compiled.</span></span> <span data-ttu-id="2eaca-190">To znamená, že když vytvoříte instanci objektu regulárního výrazu nebo když voláte statickou metodu regulárních výrazů a regulární výraz zároveň nelze nalézt v mezipaměti, modul regulárních výrazů převede regulární výraz na mezilehlou množinu operačních kódů, které jsou následně převedeny do jazyka MSIL.</span><span class="sxs-lookup"><span data-stu-id="2eaca-190">This means that, when a regular expression object is instantiated, or when a static regular expression method is called and the regular expression cannot be found in the cache, the regular expression engine converts the regular expression to an intermediary set of operation codes, which it then converts to MSIL.</span></span> <span data-ttu-id="2eaca-191">Jakmile metodu zavoláte, kompilátor JIT provede kód MSIL.</span><span class="sxs-lookup"><span data-stu-id="2eaca-191">When a method is called, the JIT compiler executes the MSIL.</span></span> <span data-ttu-id="2eaca-192">Na rozdíl od interpretovaných regulárních výrazů mají zkompilované regulární výrazy delší dobu spouštění, jednotlivé metody porovnávání se však provádí rychleji.</span><span class="sxs-lookup"><span data-stu-id="2eaca-192">In contrast to interpreted regular expressions, compiled regular expressions increase startup time but execute individual pattern-matching methods faster.</span></span> <span data-ttu-id="2eaca-193">Ve výsledku se výkonový zisk plynoucí z kompilování regulárního výrazu zvyšuje s počtem regulárních výrazů, které metoda volá.</span><span class="sxs-lookup"><span data-stu-id="2eaca-193">As a result, the performance benefit that results from compiling the regular expression increases in proportion to the number of regular expression methods called.</span></span>

<span data-ttu-id="2eaca-194">Shrnutí: V případě, že metody regulárních výrazů s konkrétním regulárním výrazem nebudou volány tak často, doporučujeme vám, abyste použili interpretované regulární výrazy.</span><span class="sxs-lookup"><span data-stu-id="2eaca-194">To summarize, we recommend that you use interpreted regular expressions when you call regular expression methods with a specific regular expression relatively infrequently.</span></span> <span data-ttu-id="2eaca-195">Pokud metody regulárních výrazů s konkrétním regulárním výrazem voláte relativně často, měli byste použít zkompilované regulární výrazy.</span><span class="sxs-lookup"><span data-stu-id="2eaca-195">You should use compiled regular expressions when you call regular expression methods with a specific regular expression relatively frequently.</span></span> <span data-ttu-id="2eaca-196">Je těžké stanovit přesný práh, kdy delší doba provádění interpretovaných regulárních výrazů převyšuje výkonový zisk plynoucí z kratší doby provádění, nebo práh, kdy kratší doba spouštění zkompilovaných regulárních výrazů převyšuje výkonový zisk plynoucí z kratší doby provádění.</span><span class="sxs-lookup"><span data-stu-id="2eaca-196">The exact threshold at which the slower execution speeds of interpreted regular expressions outweigh gains from their reduced startup time, or the threshold at which the slower startup times of compiled regular expressions outweigh gains from their faster execution speeds, is difficult to determine.</span></span> <span data-ttu-id="2eaca-197">Tato možnost závisí na různých faktorech, mezi které patří složitost regulárního výrazu a konkrétní data, která jsou zpracovávána.</span><span class="sxs-lookup"><span data-stu-id="2eaca-197">It depends on a variety of factors, including the complexity of the regular expression and the specific data that it processes.</span></span> <span data-ttu-id="2eaca-198">Chcete-li zjistit, zda interpretované nebo zkompilované regulární výrazy <xref:System.Diagnostics.Stopwatch> nabízejí nejlepší výkon pro konkrétní scénář aplikace, můžete použít třídu porovnat jejich doby provádění.</span><span class="sxs-lookup"><span data-stu-id="2eaca-198">To determine whether interpreted or compiled regular expressions offer the best performance for your particular application scenario, you can use the <xref:System.Diagnostics.Stopwatch> class to compare their execution times.</span></span>

<span data-ttu-id="2eaca-199">Následující příklad porovnává výkon kompilovaných a interpretovaných regulárních výrazů při čtení prvních deseti vět a při čtení všech vět v textu Theodora Dreisera *Finančník*.</span><span class="sxs-lookup"><span data-stu-id="2eaca-199">The following example compares the performance of compiled and interpreted regular expressions when reading the first ten sentences and when reading all the sentences in the text of Theodore Dreiser's *The Financier*.</span></span> <span data-ttu-id="2eaca-200">Jak znázorňuje výstup uvedený v příkladu, interpretovaný regulární výraz nabízí lepší výkon než zkompilovaný regulární výraz pouze tehdy, pokud je provedeno pouze deset volání metody porovnávání regulárních výrazů.</span><span class="sxs-lookup"><span data-stu-id="2eaca-200">As the output from the example shows, when only ten calls are made to regular expression matching methods, an interpreted regular expression offers better performance than a compiled regular expression.</span></span> <span data-ttu-id="2eaca-201">Zkompilovaný regulární výraz však nabízí lepší výkon, pokud je proveden větší počet volání (v tomto případě 13 000).</span><span class="sxs-lookup"><span data-stu-id="2eaca-201">However, a compiled regular expression offers better performance when a large number of calls (in this case, over 13,000) are made.</span></span>

[!code-csharp[Conceptual.RegularExpressions.BestPractices#5](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/compare1.cs#5)]
[!code-vb[Conceptual.RegularExpressions.BestPractices#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/compare1.vb#5)]

<span data-ttu-id="2eaca-202">Vzor regulárního výrazu `\b(\w+((\r?\n)|,?\s))*\w+[.?:;!]`použitý v příkladu , je definován tak, jak je znázorněno v následující tabulce.</span><span class="sxs-lookup"><span data-stu-id="2eaca-202">The regular expression pattern used in the example, `\b(\w+((\r?\n)|,?\s))*\w+[.?:;!]`, is defined as shown in the following table.</span></span>

|<span data-ttu-id="2eaca-203">Vzor</span><span class="sxs-lookup"><span data-stu-id="2eaca-203">Pattern</span></span>|<span data-ttu-id="2eaca-204">Popis</span><span class="sxs-lookup"><span data-stu-id="2eaca-204">Description</span></span>|
|-------------|-----------------|
|`\b`|<span data-ttu-id="2eaca-205">Začne porovnání na hranici slova.</span><span class="sxs-lookup"><span data-stu-id="2eaca-205">Begin the match at a word boundary.</span></span>|
|`\w+`|<span data-ttu-id="2eaca-206">Porovná jeden nebo více znaků slova.</span><span class="sxs-lookup"><span data-stu-id="2eaca-206">Match one or more word characters.</span></span>|
|<code>(\r?\n)&#124;,?\s)</code>|<span data-ttu-id="2eaca-207">Porovná buď žádný, nebo jeden návratový znak následovaný znakem nového řádku, nebo žádnou či jednou čárkou následovanou prázdným znakem.</span><span class="sxs-lookup"><span data-stu-id="2eaca-207">Match either zero or one carriage return followed by a newline character, or zero or one comma followed by a white-space character.</span></span>|
|<code>(\w+((\r?\n)&#124;,?\s))*</code>|<span data-ttu-id="2eaca-208">Porovná žádný nebo více výskytů jednoho nebo více znaků slova následovaných žádným nebo jedním návratovým znakem a znakem nového řádku, nebo žádnou či jednou čárkou následovanou prázdným znakem.</span><span class="sxs-lookup"><span data-stu-id="2eaca-208">Match zero or more occurrences of one or more word characters that are followed either by zero or one carriage return and a newline character, or by zero or one comma followed by a white-space character.</span></span>|
|`\w+`|<span data-ttu-id="2eaca-209">Porovná jeden nebo více znaků slova.</span><span class="sxs-lookup"><span data-stu-id="2eaca-209">Match one or more word characters.</span></span>|
|`[.?:;!]`|<span data-ttu-id="2eaca-210">Porovná tečku, otazník, dvojtečku, středník nebo vykřičník.</span><span class="sxs-lookup"><span data-stu-id="2eaca-210">Match a period, question mark, colon, semicolon, or exclamation point.</span></span>|

### <a name="regular-expressions-compiled-to-an-assembly"></a><span data-ttu-id="2eaca-211">Regulární výrazy: Zkompilován do sestavení</span><span class="sxs-lookup"><span data-stu-id="2eaca-211">Regular expressions: Compiled to an assembly</span></span>

<span data-ttu-id="2eaca-212">Rozhraní .NET také umožňuje vytvořit sestavení, které obsahuje kompilované regulární výrazy.</span><span class="sxs-lookup"><span data-stu-id="2eaca-212">.NET also enables you to create an assembly that contains compiled regular expressions.</span></span> <span data-ttu-id="2eaca-213">Tím dojde k přesunu výkonnosti regulárního výrazu z doby spuštění do doby návrhu.</span><span class="sxs-lookup"><span data-stu-id="2eaca-213">This moves the performance hit of regular expression compilation from run time to design time.</span></span> <span data-ttu-id="2eaca-214">Tato akce však zahrnuje další úkony: musíte předem definovat regulární výrazy a zkompilovat je do sestavení.</span><span class="sxs-lookup"><span data-stu-id="2eaca-214">However, it also involves some additional work: You must define the regular expressions in advance and compile them to an assembly.</span></span> <span data-ttu-id="2eaca-215">Kompilátor může poté odkazovat na toto sestavení při kompilaci zdrojového kódu, který používá regulární výrazy sestavení.</span><span class="sxs-lookup"><span data-stu-id="2eaca-215">The compiler can then reference this assembly when compiling source code that uses the assembly’s regular expressions.</span></span> <span data-ttu-id="2eaca-216">Každý zkompilovaný regulární výraz v sestavení <xref:System.Text.RegularExpressions.Regex>je reprezentován třídou, která je odvozena z aplikace .</span><span class="sxs-lookup"><span data-stu-id="2eaca-216">Each compiled regular expression in the assembly is represented by a class that derives from <xref:System.Text.RegularExpressions.Regex>.</span></span>

<span data-ttu-id="2eaca-217">Chcete-li zkompilovat regulární <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%29?displayProperty=nameWithType> výrazy do sestavení, zavolejte metodu a předejte ji pole <xref:System.Text.RegularExpressions.RegexCompilationInfo> objektů, které představují regulární výrazy, které mají být kompilovány, a <xref:System.Reflection.AssemblyName> objekt, který obsahuje informace o sestavení, které má být vytvořeno.</span><span class="sxs-lookup"><span data-stu-id="2eaca-217">To compile regular expressions to an assembly, you call the <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%29?displayProperty=nameWithType> method and pass it an array of <xref:System.Text.RegularExpressions.RegexCompilationInfo> objects that represent the regular expressions to be compiled, and an <xref:System.Reflection.AssemblyName> object that contains information about the assembly to be created.</span></span>

<span data-ttu-id="2eaca-218">Kompilaci regulárních výrazů do sestavení doporučujeme provádět v následujících situacích:</span><span class="sxs-lookup"><span data-stu-id="2eaca-218">We recommend that you compile regular expressions to an assembly in the following situations:</span></span>

- <span data-ttu-id="2eaca-219">Pokud pracujete jako vývojář komponent a chcete vytvořit knihovnu znovupoužitelných regulárních výrazů.</span><span class="sxs-lookup"><span data-stu-id="2eaca-219">If you are a component developer who wants to create a library of reusable regular expressions.</span></span>

- <span data-ttu-id="2eaca-220">Pokud očekáváte, že metody porovnávání se vzorem regulárních výrazů budou mít neurčitý počet volání – v rozsahu od jednoho nebo dvou do tisíců nebo desítek tisíců volání.</span><span class="sxs-lookup"><span data-stu-id="2eaca-220">If you expect your regular expression's pattern-matching methods to be called an indeterminate number of times -- anywhere from once or twice to thousands or tens of thousands of times.</span></span> <span data-ttu-id="2eaca-221">Na rozdíl od zkompilovaných nebo interpretovaných regulárních výrazů nabízejí regulární výrazy, které jsou zkompilovány do samostatných sestavení, výkon, který je konzistentní bez ohledu na počet volání metod.</span><span class="sxs-lookup"><span data-stu-id="2eaca-221">Unlike compiled or interpreted regular expressions, regular expressions that are compiled to separate assemblies offer performance that is consistent regardless of the number of method calls.</span></span>

<span data-ttu-id="2eaca-222">Pokud jsou pro optimalizaci výkonu použity kompilované regulární výrazy, neměla by pro vytvoření sestavení, načtení modulu regulárních výrazů a provedení metod porovnávání se vzorem být použita reflexe.</span><span class="sxs-lookup"><span data-stu-id="2eaca-222">If you are using compiled regular expressions to optimize performance, you should not use reflection to create the assembly, load the regular expression engine, and execute its pattern-matching methods.</span></span> <span data-ttu-id="2eaca-223">Tato akce vyžaduje vynechání dynamického sestavování vzorů regulárních výrazů a zadání možnosti nastavení porovnávání se vzorem (jako je například porovnávání s rozlišováním velkých a malých čísel) během vytváření sestavení.</span><span class="sxs-lookup"><span data-stu-id="2eaca-223">This requires that you avoid building regular expression patterns dynamically, and that you specify any pattern-matching options (such as case-insensitive pattern matching) at the time the assembly is created.</span></span> <span data-ttu-id="2eaca-224">Vyžaduje také oddělení kódu, který vytváří sestavení, od kódu, který používá regulární výraz.</span><span class="sxs-lookup"><span data-stu-id="2eaca-224">It also requires that you separate the code that creates the assembly from the code that uses the regular expression.</span></span>

<span data-ttu-id="2eaca-225">Následující příklad znázorňuje způsob vytvoření sestavení, které obsahuje zkompilovaný regulární výraz.</span><span class="sxs-lookup"><span data-stu-id="2eaca-225">The following example shows how to create an assembly that contains a compiled regular expression.</span></span> <span data-ttu-id="2eaca-226">Vytvoří sestavení s `RegexLib.dll` názvem s jednou `SentencePattern`třídou regulárního výrazu , která obsahuje vzor regulárního výrazu odpovídající větě použitý v části [Interpretované vs. kompilované regulární výrazy.](#interpreted-vs-compiled-regular-expressions)</span><span class="sxs-lookup"><span data-stu-id="2eaca-226">It creates an assembly named `RegexLib.dll` with a single regular expression class, `SentencePattern`, that contains the sentence-matching regular expression pattern used in the [Interpreted vs. Compiled Regular Expressions](#interpreted-vs-compiled-regular-expressions) section.</span></span>

[!code-csharp[Conceptual.RegularExpressions.BestPractices#6](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/compile1.cs#6)]
[!code-vb[Conceptual.RegularExpressions.BestPractices#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/compile1.vb#6)]

<span data-ttu-id="2eaca-227">Když je příklad zkompilován do spustitelného souboru a spuštěn, vytvoří sestavení s názvem `RegexLib.dll`.</span><span class="sxs-lookup"><span data-stu-id="2eaca-227">When the example is compiled to an executable and run, it creates an assembly named `RegexLib.dll`.</span></span> <span data-ttu-id="2eaca-228">Regulární výraz je reprezentován třídou s názvem `Utilities.RegularExpressions.SentencePattern` , která je odvozena od . <xref:System.Text.RegularExpressions.Regex></span><span class="sxs-lookup"><span data-stu-id="2eaca-228">The regular expression is represented by a class named `Utilities.RegularExpressions.SentencePattern` that is derived from <xref:System.Text.RegularExpressions.Regex>.</span></span> <span data-ttu-id="2eaca-229">Následující příklad pak používá zkompilovaný regulární výraz k extrahování vět z textu Theodora Dreisera *The Financier*.</span><span class="sxs-lookup"><span data-stu-id="2eaca-229">The following example then uses the compiled regular expression to extract the sentences from the text of Theodore Dreiser's *The Financier*.</span></span>

[!code-csharp[Conceptual.RegularExpressions.BestPractices#7](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/compile2.cs#7)]
[!code-vb[Conceptual.RegularExpressions.BestPractices#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/compile2.vb#7)]

## <a name="take-charge-of-backtracking"></a><span data-ttu-id="2eaca-230">Převzít backtracking</span><span class="sxs-lookup"><span data-stu-id="2eaca-230">Take charge of backtracking</span></span>

<span data-ttu-id="2eaca-231">Pro posouvání ve vstupním řetězci a porovnání řetězce se vzorem regulárního výrazu používá regulární výraz většinou lineární posloupnost.</span><span class="sxs-lookup"><span data-stu-id="2eaca-231">Ordinarily, the regular expression engine uses linear progression to move through an input string and compare it to a regular expression pattern.</span></span> <span data-ttu-id="2eaca-232">Pokud se však neurčité kvantifikátory, například `*`, `+`a `?` používají ve vzoru regulárních výrazů, může se modul regulárních výrazů vzdát části úspěšných částečných shod a vrátit se do dříve uloženého stavu, aby vyhledal úspěšnou shodu pro celý vzorek.</span><span class="sxs-lookup"><span data-stu-id="2eaca-232">However, when indeterminate quantifiers such as `*`, `+`, and `?` are used in a regular expression pattern, the regular expression engine may give up a portion of successful partial matches and return to a previously saved state in order to search for a successful match for the entire pattern.</span></span> <span data-ttu-id="2eaca-233">Tento proces se označuje jako zpětné navracení.</span><span class="sxs-lookup"><span data-stu-id="2eaca-233">This process is known as backtracking.</span></span>

> [!NOTE]
> <span data-ttu-id="2eaca-234">Další informace o navracení naleznete [v tématu Podrobnosti o chování regulárních výrazů](../../../docs/standard/base-types/details-of-regular-expression-behavior.md) a [navracení](../../../docs/standard/base-types/backtracking-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="2eaca-234">For more information on backtracking, see [Details of Regular Expression Behavior](../../../docs/standard/base-types/details-of-regular-expression-behavior.md) and [Backtracking](../../../docs/standard/base-types/backtracking-in-regular-expressions.md).</span></span> <span data-ttu-id="2eaca-235">Podrobnou diskusi o navracení najdete v [tématu Optimalizace výkonu regulárních výrazů, část II: Převzetí zpětného navracení](https://docs.microsoft.com/archive/blogs/bclteam/optimizing-regular-expression-performance-part-ii-taking-charge-of-backtracking-ron-petrusha) v blogu týmu BCL.</span><span class="sxs-lookup"><span data-stu-id="2eaca-235">For a detailed discussion of backtracking, see [Optimizing Regular Expression Performance, Part II: Taking Charge of Backtracking](https://docs.microsoft.com/archive/blogs/bclteam/optimizing-regular-expression-performance-part-ii-taking-charge-of-backtracking-ron-petrusha) in the BCL Team blog.</span></span>

<span data-ttu-id="2eaca-236">Podpora zpětného navracení zajišťuje regulárním výrazům výkon a flexibilitu.</span><span class="sxs-lookup"><span data-stu-id="2eaca-236">Support for backtracking gives regular expressions power and flexibility.</span></span> <span data-ttu-id="2eaca-237">Zároveň přenáší odpovědnost za řízení provozu modulu regulárních výrazů do rukou vývojáře regulárních výrazů.</span><span class="sxs-lookup"><span data-stu-id="2eaca-237">It also places the responsibility for controlling the operation of the regular expression engine in the hands of regular expression developers.</span></span> <span data-ttu-id="2eaca-238">Vzhledem k tomu, že vývojáři si často tuto odpovědnost neuvědomují, jejich špatný způsob používání mechanismu navracení nebo přílišné používání tohoto mechanismu hraje nejdůležitější roli při snížení výkonu regulárních výrazů.</span><span class="sxs-lookup"><span data-stu-id="2eaca-238">Because developers are often not aware of this responsibility, their misuse of backtracking or reliance on excessive backtracking often plays the most significant role in degrading regular expression performance.</span></span> <span data-ttu-id="2eaca-239">V nejhorším případě se doba provádění může s každým dalším znakem ve vstupním řetězci zdvojnásobit.</span><span class="sxs-lookup"><span data-stu-id="2eaca-239">In a worst-case scenario, execution time can double for each additional character in the input string.</span></span> <span data-ttu-id="2eaca-240">Přílišným používáním mechanismu navracení je vlastně velmi snadné vytvořit programový ekvivalent nekonečné smyčky, pokud se vstup téměř shoduje se vzorem regulárního výrazů; modulu regulárních výrazů může trvat hodiny, nebo dokonce dny, než zpracuje relativně krátký vstupní řetězec.</span><span class="sxs-lookup"><span data-stu-id="2eaca-240">In fact, by using backtracking excessively, it is easy to create the programmatic equivalent of an endless loop if input nearly matches the regular expression pattern; the regular expression engine may take hours or even days to process a relatively short input string.</span></span>

<span data-ttu-id="2eaca-241">Aplikace často platí daň za snížený výkon při používání zpětného navracení navzdory skutečnosti, že mechanismus zpětného navracení není pro shodu klíčový.</span><span class="sxs-lookup"><span data-stu-id="2eaca-241">Often, applications pay a performance penalty for using backtracking despite the fact that backtracking is not essential for a match.</span></span> <span data-ttu-id="2eaca-242">Například regulární `\b\p{Lu}\w*\b` výraz odpovídá všem slovům, která začínají znakem velkých písmen, jak ukazuje následující tabulka.</span><span class="sxs-lookup"><span data-stu-id="2eaca-242">For example, the regular expression `\b\p{Lu}\w*\b` matches all words that begin with an uppercase character, as the following table shows.</span></span>

|<span data-ttu-id="2eaca-243">Vzor</span><span class="sxs-lookup"><span data-stu-id="2eaca-243">Pattern</span></span>|<span data-ttu-id="2eaca-244">Popis</span><span class="sxs-lookup"><span data-stu-id="2eaca-244">Description</span></span>|
|-|-|
|`\b`|<span data-ttu-id="2eaca-245">Začne porovnání na hranici slova.</span><span class="sxs-lookup"><span data-stu-id="2eaca-245">Begin the match at a word boundary.</span></span>|
|`\p{Lu}`|<span data-ttu-id="2eaca-246">Porovná znak velkého písmena.</span><span class="sxs-lookup"><span data-stu-id="2eaca-246">Match an uppercase character.</span></span>|
|`\w*`|<span data-ttu-id="2eaca-247">Porovná žádný nebo více znaků slova.</span><span class="sxs-lookup"><span data-stu-id="2eaca-247">Match zero or more word characters.</span></span>|
|`\b`|<span data-ttu-id="2eaca-248">Ukončí porovnání na hranici slova.</span><span class="sxs-lookup"><span data-stu-id="2eaca-248">End the match at a word boundary.</span></span>|

<span data-ttu-id="2eaca-249">Vzhledem k tomu, že hranice slova se neshoduje s hranicí znaku slova ani není jeho podmnožinou, nemá modul regulárních výrazů žádnou možnost při porovnávání znaků překročit hranici slova.</span><span class="sxs-lookup"><span data-stu-id="2eaca-249">Because a word boundary is not the same as, or a subset of, a word character, there is no possibility that the regular expression engine will cross a word boundary when matching word characters.</span></span> <span data-ttu-id="2eaca-250">To znamená, že pro tento regulární výraz nemůže mechanismus zpětného navracení nikdy přispět k celkovému úspěšnému vyhledání jakékoli shody – může pouze snížit výkon, protože modul regulárních výrazů je nucen uložit stav pro každou předběžně úspěšnou shodu znaku slova.</span><span class="sxs-lookup"><span data-stu-id="2eaca-250">This means that for this regular expression, backtracking can never contribute to the overall success of any match -- it can only degrade performance, because the regular expression engine is forced to save its state for each successful preliminary match of a word character.</span></span>

<span data-ttu-id="2eaca-251">Pokud zjistíte, že navracení není nutné, můžete `(?>subexpression)` jej zakázat pomocí elementu jazyka, známého jako atomická skupina.</span><span class="sxs-lookup"><span data-stu-id="2eaca-251">If you determine that backtracking is not necessary, you can disable it by using the `(?>subexpression)` language element, known as an atomic group.</span></span> <span data-ttu-id="2eaca-252">Následující příklad analyzuje vstupní řetězec pomocí dvou regulárních výrazů.</span><span class="sxs-lookup"><span data-stu-id="2eaca-252">The following example parses an input string by using two regular expressions.</span></span> <span data-ttu-id="2eaca-253">První , `\b\p{Lu}\w*\b`spoléhá na navracení.</span><span class="sxs-lookup"><span data-stu-id="2eaca-253">The first, `\b\p{Lu}\w*\b`, relies on backtracking.</span></span> <span data-ttu-id="2eaca-254">Druhý , `\b\p{Lu}(?>\w*)\b`zakáže navracení.</span><span class="sxs-lookup"><span data-stu-id="2eaca-254">The second, `\b\p{Lu}(?>\w*)\b`, disables backtracking.</span></span> <span data-ttu-id="2eaca-255">Jak znázorňuje výstup z příkladu, vytvoří oba výrazy stejný výsledek.</span><span class="sxs-lookup"><span data-stu-id="2eaca-255">As the output from the example shows, they both produce the same result.</span></span>

[!code-csharp[Conceptual.RegularExpressions.BestPractices#10](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/backtrack2.cs#10)]
[!code-vb[Conceptual.RegularExpressions.BestPractices#10](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/backtrack2.vb#10)]

<span data-ttu-id="2eaca-256">V mnoha případech je zpětné navracení pro porovnávání vzorů regulárních výrazů se vstupním textem nezbytné.</span><span class="sxs-lookup"><span data-stu-id="2eaca-256">In many cases, backtracking is essential for matching a regular expression pattern to input text.</span></span> <span data-ttu-id="2eaca-257">Přílišné používání mechanismu navracení však může zásadním způsobem snížit výkon a vytvořit dojem, že aplikace přestala odpovídat.</span><span class="sxs-lookup"><span data-stu-id="2eaca-257">However, excessive backtracking can severely degrade performance and create the impression that an application has stopped responding.</span></span> <span data-ttu-id="2eaca-258">K této situaci dochází především tehdy, pokud jsou kvalifikátory vnořené a text, který se shoduje s vnějším dílčím výrazem, je podmnožinou textu, který se shoduje s vnějším dílčím výrazem.</span><span class="sxs-lookup"><span data-stu-id="2eaca-258">In particular, this happens when quantifiers are nested and the text that matches the outer subexpression is a subset of the text that matches the inner subexpression.</span></span>

> [!WARNING]
> <span data-ttu-id="2eaca-259">Kromě toho, že byste mechanismus navracení neměli často používat, byste také měli použít funkci časového limitu, aby přílišné používání zpětného navracení nezpůsobovalo zásadní snížení výkonu regulárních výrazů.</span><span class="sxs-lookup"><span data-stu-id="2eaca-259">In addition to avoiding excessive backtracking, you should use the timeout feature to ensure that excessive backtracking does not severely degrade regular expression performance.</span></span> <span data-ttu-id="2eaca-260">Další informace naleznete v části [Použití hodnot časového času.](#use-time-out-values)</span><span class="sxs-lookup"><span data-stu-id="2eaca-260">For more information, see the [Use Time-out Values](#use-time-out-values) section.</span></span>

<span data-ttu-id="2eaca-261">Například vzor `^[0-9A-Z]([-.\w]*[0-9A-Z])*\$$` regulárního výrazu je určen tak, aby odpovídal číslu dílu, který se skládá alespoň z jednoho alfanumerického znaku.</span><span class="sxs-lookup"><span data-stu-id="2eaca-261">For example, the regular expression pattern `^[0-9A-Z]([-.\w]*[0-9A-Z])*\$$` is intended to match a part number that consists of at least one alphanumeric character.</span></span> <span data-ttu-id="2eaca-262">Mezi dalšími znaky může být alfanumerický znak, spojovník, podtržítko nebo tečka, poslední znak však musí být alfanumerický.</span><span class="sxs-lookup"><span data-stu-id="2eaca-262">Any additional characters can consist of an alphanumeric character, a hyphen, an underscore, or a period, though the last character must be alphanumeric.</span></span> <span data-ttu-id="2eaca-263">Znak dolaru ukončuje číslo součásti.</span><span class="sxs-lookup"><span data-stu-id="2eaca-263">A dollar sign terminates the part number.</span></span> <span data-ttu-id="2eaca-264">V některých případech může tento vzor regulárního výrazu vykazovat extrémně nízký `[0-9A-Z]` výkon, protože kvantifikátory jsou vnořeny a protože dílčí výraz je podmnožinou dílčího výrazu `[-.\w]*`.</span><span class="sxs-lookup"><span data-stu-id="2eaca-264">In some cases, this regular expression pattern can exhibit extremely poor performance because quantifiers are nested, and because the subexpression `[0-9A-Z]` is a subset of the subexpression `[-.\w]*`.</span></span>

<span data-ttu-id="2eaca-265">V těchto případech lze výkon regulárních výrazů optimalizovat odebráním vnořených kvantifikátorů a nahrazením vnějšího dílčího výrazu kontrolním výrazem dopředného nebo zpětného vyhledávání s nulovou šířkou.</span><span class="sxs-lookup"><span data-stu-id="2eaca-265">In these cases, you can optimize regular expression performance by removing the nested quantifiers and replacing the outer subexpression with a zero-width lookahead or lookbehind assertion.</span></span> <span data-ttu-id="2eaca-266">Kontrolní výrazy dopředného a zpětného vyhledávání fungují jako kotvy: neposouvají ukazatele ve vstupním řetězci, ale prohledávají směrem dopředu nebo dozadu a ověřují, zda byla splněna konkrétní podmínka.</span><span class="sxs-lookup"><span data-stu-id="2eaca-266">Lookahead and lookbehind assertions are anchors; they do not move the pointer in the input string, but instead look ahead or behind to check whether a specified condition is met.</span></span> <span data-ttu-id="2eaca-267">Regulární výraz číslo dílu lze `^[0-9A-Z][-.\w]*(?<=[0-9A-Z])\$$`například přepsat jako .</span><span class="sxs-lookup"><span data-stu-id="2eaca-267">For example, the part number regular expression can be rewritten as `^[0-9A-Z][-.\w]*(?<=[0-9A-Z])\$$`.</span></span> <span data-ttu-id="2eaca-268">Tento vzor regulárního výrazu je definován tak, jak je uvedeno v následující tabulce.</span><span class="sxs-lookup"><span data-stu-id="2eaca-268">This regular expression pattern is defined as shown in the following table.</span></span>

|<span data-ttu-id="2eaca-269">Vzor</span><span class="sxs-lookup"><span data-stu-id="2eaca-269">Pattern</span></span>|<span data-ttu-id="2eaca-270">Popis</span><span class="sxs-lookup"><span data-stu-id="2eaca-270">Description</span></span>|
|-------------|-----------------|
|`^`|<span data-ttu-id="2eaca-271">Zahájí porovnávání na začátku vstupního řetězce.</span><span class="sxs-lookup"><span data-stu-id="2eaca-271">Begin the match at the beginning of the input string.</span></span>|
|`[0-9A-Z]`|<span data-ttu-id="2eaca-272">Porovná alfanumerický znak.</span><span class="sxs-lookup"><span data-stu-id="2eaca-272">Match an alphanumeric character.</span></span> <span data-ttu-id="2eaca-273">Číslo součásti musí obsahovat alespoň tento znak.</span><span class="sxs-lookup"><span data-stu-id="2eaca-273">The part number must consist of at least this character.</span></span>|
|`[-.\w]*`|<span data-ttu-id="2eaca-274">Porovná žádný nebo více výskytů znaku slova, spojovníku nebo tečky.</span><span class="sxs-lookup"><span data-stu-id="2eaca-274">Match zero or more occurrences of any word character, hyphen, or period.</span></span>|
|`\$`|<span data-ttu-id="2eaca-275">Porovná znak dolaru.</span><span class="sxs-lookup"><span data-stu-id="2eaca-275">Match a dollar sign.</span></span>|
|`(?<=[0-9A-Z])`|<span data-ttu-id="2eaca-276">Vyhledá směrem dopředu znak dolaru a ověří, zda je předchozí znak alfanumerický.</span><span class="sxs-lookup"><span data-stu-id="2eaca-276">Look ahead of the ending dollar sign to ensure that the previous character is alphanumeric.</span></span>|
|`$`|<span data-ttu-id="2eaca-277">Ukončí porovnávání na konci vstupního řetězce.</span><span class="sxs-lookup"><span data-stu-id="2eaca-277">End the match at the end of the input string.</span></span>|

<span data-ttu-id="2eaca-278">Následující příklad znázorňuje používání tohoto regulárního výrazu pro porovnání pole obsahujícího pravděpodobná čísla součástí.</span><span class="sxs-lookup"><span data-stu-id="2eaca-278">The following example illustrates the use of this regular expression to match an array containing possible part numbers.</span></span>

[!code-csharp[Conceptual.RegularExpressions.BestPractices#11](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/backtrack4.cs#11)]
[!code-vb[Conceptual.RegularExpressions.BestPractices#11](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/backtrack4.vb#11)]

<span data-ttu-id="2eaca-279">Jazyk regulárních výrazů v rozhraní .NET obsahuje následující prvky jazyka, které můžete použít k odstranění vnořených kvantifikátorů.</span><span class="sxs-lookup"><span data-stu-id="2eaca-279">The regular expression language in .NET includes the following language elements that you can use to eliminate nested quantifiers.</span></span> <span data-ttu-id="2eaca-280">Další informace naleznete v [tématu Seskupování konstrukcí](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="2eaca-280">For more information, see [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span></span>

|<span data-ttu-id="2eaca-281">Prvek jazyka</span><span class="sxs-lookup"><span data-stu-id="2eaca-281">Language element</span></span>|<span data-ttu-id="2eaca-282">Popis</span><span class="sxs-lookup"><span data-stu-id="2eaca-282">Description</span></span>|
|----------------------|-----------------|
|<span data-ttu-id="2eaca-283">`(?=` `subexpression` `)`</span><span class="sxs-lookup"><span data-stu-id="2eaca-283">`(?=` `subexpression` `)`</span></span>|<span data-ttu-id="2eaca-284">Pozitivní dopředné vyhledávání s nulovou šířkou.</span><span class="sxs-lookup"><span data-stu-id="2eaca-284">Zero-width positive lookahead.</span></span> <span data-ttu-id="2eaca-285">Podívejte se před aktuální pozici `subexpression` k určení, zda odpovídá vstupní řetězec.</span><span class="sxs-lookup"><span data-stu-id="2eaca-285">Look ahead of the current position to determine whether `subexpression` matches the input string.</span></span>|
|<span data-ttu-id="2eaca-286">`(?!` `subexpression` `)`</span><span class="sxs-lookup"><span data-stu-id="2eaca-286">`(?!` `subexpression` `)`</span></span>|<span data-ttu-id="2eaca-287">Negativní dopředné vyhledávání s nulovou šířkou.</span><span class="sxs-lookup"><span data-stu-id="2eaca-287">Zero-width negative lookahead.</span></span> <span data-ttu-id="2eaca-288">Podívejte se dopředu aktuální pozici `subexpression` k určení, zda neodpovídá vstupní řetězec.</span><span class="sxs-lookup"><span data-stu-id="2eaca-288">Look ahead of the current position to determine whether `subexpression` does not match the input string.</span></span>|
|<span data-ttu-id="2eaca-289">`(?<=` `subexpression` `)`</span><span class="sxs-lookup"><span data-stu-id="2eaca-289">`(?<=` `subexpression` `)`</span></span>|<span data-ttu-id="2eaca-290">Pozitivní zpětné vyhledávání s nulovou šířkou.</span><span class="sxs-lookup"><span data-stu-id="2eaca-290">Zero-width positive lookbehind.</span></span> <span data-ttu-id="2eaca-291">Podívejte se za aktuální `subexpression` pozici k určení, zda odpovídá vstupní řetězec.</span><span class="sxs-lookup"><span data-stu-id="2eaca-291">Look behind the current position to determine whether `subexpression` matches the input string.</span></span>|
|<span data-ttu-id="2eaca-292">`(?<!` `subexpression` `)`</span><span class="sxs-lookup"><span data-stu-id="2eaca-292">`(?<!` `subexpression` `)`</span></span>|<span data-ttu-id="2eaca-293">Negativní zpětné vyhledávání s nulovou šířkou.</span><span class="sxs-lookup"><span data-stu-id="2eaca-293">Zero-width negative lookbehind.</span></span> <span data-ttu-id="2eaca-294">Podívejte se za aktuální `subexpression` pozici k určení, zda neodpovídá vstupní řetězec.</span><span class="sxs-lookup"><span data-stu-id="2eaca-294">Look behind the current position to determine whether `subexpression` does not match the input string.</span></span>|

## <a name="use-time-out-values"></a><span data-ttu-id="2eaca-295">Použití hodnot časového času</span><span class="sxs-lookup"><span data-stu-id="2eaca-295">Use time-out values</span></span>

<span data-ttu-id="2eaca-296">Pokud regulární výraz zpracovává vstup, který téměř odpovídá vzoru regulárního výrazu, může se často spoléhat na přílišné používání zpětného navracení, což má velký dopad na výkon.</span><span class="sxs-lookup"><span data-stu-id="2eaca-296">If your regular expressions processes input that nearly matches the regular expression pattern, it can often rely on excessive backtracking, which impacts its performance significantly.</span></span> <span data-ttu-id="2eaca-297">Kromě pečlivého zvážení používání mechanismu zpětného navracení a ověřování regulárního výrazu s téměř shodným vstupem byste měli nastavit hodnotu časového limitu, který minimalizuje vliv přílišného používání mechanismu zpětného navracení, pokud k němu dojde.</span><span class="sxs-lookup"><span data-stu-id="2eaca-297">In addition to carefully considering your use of backtracking and testing the regular expression against near-matching input, you should always set a time-out value to ensure that the impact of excessive backtracking, if it occurs, is minimized.</span></span>

<span data-ttu-id="2eaca-298">Časový interval regulárního výrazu definuje časové období, po které bude modul regulárních výrazů hledat jednu shodu před časovým intervalem. Výchozí časový limit je <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, což znamená, že regulární výraz nebude časový limit. Tuto hodnotu můžete přepsat a definovat interval časového intervalu následujícím způsobem:</span><span class="sxs-lookup"><span data-stu-id="2eaca-298">The regular expression time-out interval defines the period of time that the regular expression engine will look for a single match before it times out. The default time-out interval is <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, which means that the regular expression will not time out. You can override this value and define a time-out interval as follows:</span></span>

- <span data-ttu-id="2eaca-299">Poskytnutím hodnoty časového času při vytváření instancí objektu <xref:System.Text.RegularExpressions.Regex> voláním konstruktoru. <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="2eaca-299">By providing a time-out value when you instantiate a <xref:System.Text.RegularExpressions.Regex> object by calling the <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> constructor.</span></span>

- <span data-ttu-id="2eaca-300">Voláním statické metody porovnávání <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> vzorů, například nebo <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType>, která obsahuje `matchTimeout` parametr.</span><span class="sxs-lookup"><span data-stu-id="2eaca-300">By calling a static pattern matching method, such as <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> or <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType>, that includes a `matchTimeout` parameter.</span></span>

- <span data-ttu-id="2eaca-301">Pro zkompilované regulární výrazy, které jsou vytvořeny voláním <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A?displayProperty=nameWithType> metody <xref:System.TimeSpan>voláním konstruktoru, který má parametr typu .</span><span class="sxs-lookup"><span data-stu-id="2eaca-301">For compiled regular expressions that are created by calling the <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A?displayProperty=nameWithType> method, by calling the constructor that has a parameter of type <xref:System.TimeSpan>.</span></span>

<span data-ttu-id="2eaca-302">Pokud jste definovali časový interval a shoda nebyla nalezena na konci tohoto intervalu, metoda regulárního výrazu vyvolá výjimku. <xref:System.Text.RegularExpressions.RegexMatchTimeoutException></span><span class="sxs-lookup"><span data-stu-id="2eaca-302">If you have defined a time-out interval and a match is not found at the end of that interval, the regular expression method throws a <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exception.</span></span> <span data-ttu-id="2eaca-303">V obslužné rutině výjimek můžete zadat nové vyhledávání shody s delším intervalem časového limitu, zrušit pokus o vyhledání shody a předpokládat, že shoda neexistuje, nebo zrušit pokus o vyhledání shody a vytvořit protokol s informacemi o výjimce pro další analýzu.</span><span class="sxs-lookup"><span data-stu-id="2eaca-303">In your exception handler, you can choose to retry the match with a longer time-out interval, abandon the match attempt and assume that there is no match, or abandon the match attempt and log the exception information for future analysis.</span></span>

<span data-ttu-id="2eaca-304">Následující příklad definuje `GetWordData` metodu, která inkonaluje regulární výraz s časovým intervalem 350 milisekund pro výpočet počtu slov a průměrného počtu znaků ve slově v textovém dokumentu.</span><span class="sxs-lookup"><span data-stu-id="2eaca-304">The following example defines a `GetWordData` method that instantiates a regular expression with a time-out interval of 350 milliseconds to calculate the number of words and average number of characters in a word in a text document.</span></span> <span data-ttu-id="2eaca-305">Pokud časový interval odpovídající operace je časový interval zvýšen o 350 <xref:System.Text.RegularExpressions.Regex> milisekund a objekt je re-instanceed.</span><span class="sxs-lookup"><span data-stu-id="2eaca-305">If the matching operation times out, the time-out interval is increased by 350 milliseconds and the <xref:System.Text.RegularExpressions.Regex> object is re-instantiated.</span></span> <span data-ttu-id="2eaca-306">Pokud nový interval časového limitu překročí 1 sekundu, metoda opětovně vyvolá výjimku pro volajícího.</span><span class="sxs-lookup"><span data-stu-id="2eaca-306">If the new time-out interval exceeds 1 second, the method re-throws the exception to the caller.</span></span>

[!code-csharp[Conceptual.RegularExpressions.BestPractices#12](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/timeout1.cs#12)]
[!code-vb[Conceptual.RegularExpressions.BestPractices#12](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/timeout1.vb#12)]

## <a name="capture-only-when-necessary"></a><span data-ttu-id="2eaca-307">Zachyťte pouze v případě potřeby</span><span class="sxs-lookup"><span data-stu-id="2eaca-307">Capture only when necessary</span></span>

<span data-ttu-id="2eaca-308">Regulární výrazy v rozhraní .NET podporují řadu seskupovacích konstrukcí, které umožňují seskupit vzorek regulárního výrazu do jednoho nebo více podvýrazů.</span><span class="sxs-lookup"><span data-stu-id="2eaca-308">Regular expressions in .NET support a number of grouping constructs, which let you group a regular expression pattern into one or more subexpressions.</span></span> <span data-ttu-id="2eaca-309">Nejčastěji používané `(`seskupovací konstrukce v jazyce regulárních výrazů .NET jsou `(?<` *podvýraz*`)`, který definuje číslovanou zachytávající skupinu, a*podvýraz*`)` *názvu*`>`, který definuje pojmenovanou zachytávající skupinu.</span><span class="sxs-lookup"><span data-stu-id="2eaca-309">The most commonly used grouping constructs in .NET regular expression language are `(`*subexpression*`)`, which defines a numbered capturing group, and `(?<`*name*`>`*subexpression*`)`, which defines a named capturing group.</span></span> <span data-ttu-id="2eaca-310">Seskupovací konstrukce jsou nezbytné pro vytváření a definování dílčího výrazu, pro který je použit kvantifikátor.</span><span class="sxs-lookup"><span data-stu-id="2eaca-310">Grouping constructs are essential for creating backreferences and for defining a subexpression to which a quantifier is applied.</span></span>

<span data-ttu-id="2eaca-311">Používání těchto prvků jazyka však má svou cenu.</span><span class="sxs-lookup"><span data-stu-id="2eaca-311">However, the use of these language elements has a cost.</span></span> <span data-ttu-id="2eaca-312">Způsobí, <xref:System.Text.RegularExpressions.GroupCollection> že objekt <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> vrácený vlastností má být naplněn nejnovějšími nepojmenovanými nebo pojmenovanými zachyceními a pokud jedna konstrukce seskupení zachytila více podřetězců ve vstupním řetězci, naplní také <xref:System.Text.RegularExpressions.CaptureCollection> objekt vrácený <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> vlastností určité zachytávající skupiny více <xref:System.Text.RegularExpressions.Capture> objekty.</span><span class="sxs-lookup"><span data-stu-id="2eaca-312">They cause the <xref:System.Text.RegularExpressions.GroupCollection> object returned by the <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> property to be populated with the most recent unnamed or named captures, and if a single grouping construct has captured multiple substrings in the input string, they also populate the <xref:System.Text.RegularExpressions.CaptureCollection> object returned by the <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> property of a particular capturing group with multiple <xref:System.Text.RegularExpressions.Capture> objects.</span></span>

<span data-ttu-id="2eaca-313">Seskupovací konstrukce se v regulárních výrazech používají pouze proto, aby na ně mohly být aplikovány kvantifikátory a aby skupiny zachycené těmito dílčími výrazy nebyly poté používány.</span><span class="sxs-lookup"><span data-stu-id="2eaca-313">Often, grouping constructs are used in a regular expression only so that quantifiers can be applied to them, and the groups captured by these subexpressions are not subsequently used.</span></span> <span data-ttu-id="2eaca-314">Regulární výraz `\b(\w+[;,]?\s?)+[.?!]` je například určen k zachycení celé věty.</span><span class="sxs-lookup"><span data-stu-id="2eaca-314">For example, the regular expression `\b(\w+[;,]?\s?)+[.?!]` is designed to capture an entire sentence.</span></span> <span data-ttu-id="2eaca-315">Následující tabulka popisuje prvky jazyka v tomto vzoru <xref:System.Text.RegularExpressions.Match> regulárních <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> výrazů a jejich vliv na objekt a kolekce.</span><span class="sxs-lookup"><span data-stu-id="2eaca-315">The following table describes the language elements in this regular expression pattern and their effect on the <xref:System.Text.RegularExpressions.Match> object's <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> and <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> collections.</span></span>

|<span data-ttu-id="2eaca-316">Vzor</span><span class="sxs-lookup"><span data-stu-id="2eaca-316">Pattern</span></span>|<span data-ttu-id="2eaca-317">Popis</span><span class="sxs-lookup"><span data-stu-id="2eaca-317">Description</span></span>|
|-------------|-----------------|
|`\b`|<span data-ttu-id="2eaca-318">Začne porovnání na hranici slova.</span><span class="sxs-lookup"><span data-stu-id="2eaca-318">Begin the match at a word boundary.</span></span>|
|`\w+`|<span data-ttu-id="2eaca-319">Porovná jeden nebo více znaků slova.</span><span class="sxs-lookup"><span data-stu-id="2eaca-319">Match one or more word characters.</span></span>|
|`[;,]?`|<span data-ttu-id="2eaca-320">Porovná žádnou nebo jednu čárku či středník.</span><span class="sxs-lookup"><span data-stu-id="2eaca-320">Match zero or one comma or semicolon.</span></span>|
|`\s?`|<span data-ttu-id="2eaca-321">Porovná žádný nebo jeden prázdný znak.</span><span class="sxs-lookup"><span data-stu-id="2eaca-321">Match zero or one white-space character.</span></span>|
|`(\w+[;,]?\s?)+`|<span data-ttu-id="2eaca-322">Porovná jeden nebo několik výskytů znaků slova následovaných nepovinnou čárkou nebo středníkem, za kterými následuje nepovinný prázdný znak.</span><span class="sxs-lookup"><span data-stu-id="2eaca-322">Match one or more occurrences of one or more word characters followed by an optional comma or semicolon followed by an optional white-space character.</span></span> <span data-ttu-id="2eaca-323">Tím je definována první zachytávající skupina, která je nezbytná k tomu, aby kombinace více znaků slova (neboli slovo) následovaná nepovinným interpunkčním symbolem opakovala, dokud modul regulárních výrazů nedosáhne konce věty.</span><span class="sxs-lookup"><span data-stu-id="2eaca-323">This defines the first capturing group, which is necessary so that the combination of multiple word characters (that is, a word) followed by an optional punctuation symbol will be repeated until the regular expression engine reaches the end of a sentence.</span></span>|
|`[.?!]`|<span data-ttu-id="2eaca-324">Porovná tečku, otazník nebo vykřičník.</span><span class="sxs-lookup"><span data-stu-id="2eaca-324">Match a period, question mark, or exclamation point.</span></span>|

<span data-ttu-id="2eaca-325">Jak ukazuje následující příklad, při nalezení shody jsou <xref:System.Text.RegularExpressions.GroupCollection> objekty i <xref:System.Text.RegularExpressions.CaptureCollection> objekty naplněny zachyceními ze shody.</span><span class="sxs-lookup"><span data-stu-id="2eaca-325">As the following example shows, when a match is found, both the <xref:System.Text.RegularExpressions.GroupCollection> and <xref:System.Text.RegularExpressions.CaptureCollection> objects are populated with captures from the match.</span></span> <span data-ttu-id="2eaca-326">V tomto případě zachytávající skupina `(\w+[;,]?\s?)` `+` existuje tak, aby kvantifikátor mohl být použit na něj, což umožňuje, aby vzor regulárního výrazu odpovídal každému slovu ve větě.</span><span class="sxs-lookup"><span data-stu-id="2eaca-326">In this case, the capturing group `(\w+[;,]?\s?)` exists so that the `+` quantifier can be applied to it, which enables the regular expression pattern to match each word in a sentence.</span></span> <span data-ttu-id="2eaca-327">V opačném případě může odpovídat poslednímu slovu ve větě.</span><span class="sxs-lookup"><span data-stu-id="2eaca-327">Otherwise, it would match the last word in a sentence.</span></span>

[!code-csharp[Conceptual.RegularExpressions.BestPractices#8](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/group1.cs#8)]
[!code-vb[Conceptual.RegularExpressions.BestPractices#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/group1.vb#8)]

<span data-ttu-id="2eaca-328">Pokud použijete dílčí výrazy pouze proto, abyste mohli použít kvantifikátor a zachycený text pro vás není podstatný, měli byste skupinové zachytávání zakázat.</span><span class="sxs-lookup"><span data-stu-id="2eaca-328">When you use subexpressions only to apply quantifiers to them, and you are not interested in the captured text, you should disable group captures.</span></span> <span data-ttu-id="2eaca-329">Například element `(?:subexpression)` jazyka zabraňuje skupině, na kterou se vztahuje, zachytit odpovídající podřetězce.</span><span class="sxs-lookup"><span data-stu-id="2eaca-329">For example, the `(?:subexpression)` language element prevents the group to which it applies from capturing matched substrings.</span></span> <span data-ttu-id="2eaca-330">V následujícím příkladu se změní vzor regulárního výrazu z předchozího příkladu na `\b(?:\w+[;,]?\s?)+[.?!]`.</span><span class="sxs-lookup"><span data-stu-id="2eaca-330">In the following example, the regular expression pattern from the previous example is changed to `\b(?:\w+[;,]?\s?)+[.?!]`.</span></span> <span data-ttu-id="2eaca-331">Jak ukazuje výstup, zabrání modulu regulárních výrazů v vyplnění kolekce <xref:System.Text.RegularExpressions.GroupCollection> a. <xref:System.Text.RegularExpressions.CaptureCollection></span><span class="sxs-lookup"><span data-stu-id="2eaca-331">As the output shows, it prevents the regular expression engine from populating the <xref:System.Text.RegularExpressions.GroupCollection> and <xref:System.Text.RegularExpressions.CaptureCollection> collections.</span></span>

[!code-csharp[Conceptual.RegularExpressions.BestPractices#9](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/group2.cs#9)]
[!code-vb[Conceptual.RegularExpressions.BestPractices#9](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/group2.vb#9)]

<span data-ttu-id="2eaca-332">Zachytávání lze zakázat jedním z následujících způsobů:</span><span class="sxs-lookup"><span data-stu-id="2eaca-332">You can disable captures in one of the following ways:</span></span>

- <span data-ttu-id="2eaca-333">Použijte `(?:subexpression)` prvek jazyka.</span><span class="sxs-lookup"><span data-stu-id="2eaca-333">Use the `(?:subexpression)` language element.</span></span> <span data-ttu-id="2eaca-334">Tento prvek zabraňuje v zachytávání shodných podřetězců ve skupině, pro kterou se používá.</span><span class="sxs-lookup"><span data-stu-id="2eaca-334">This element prevents the capture of matched substrings in the group to which it applies.</span></span> <span data-ttu-id="2eaca-335">Nezakazuje zachytávání podřetězců v jakékoli vnořené skupině.</span><span class="sxs-lookup"><span data-stu-id="2eaca-335">It does not disable substring captures in any nested groups.</span></span>

- <span data-ttu-id="2eaca-336">Použijte <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture> tuto možnost.</span><span class="sxs-lookup"><span data-stu-id="2eaca-336">Use the <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture> option.</span></span> <span data-ttu-id="2eaca-337">Zakazuje všechna nepojmenovaná nebo implicitní zachycení ve vzoru regulárního výrazu.</span><span class="sxs-lookup"><span data-stu-id="2eaca-337">It disables all unnamed or implicit captures in the regular expression pattern.</span></span> <span data-ttu-id="2eaca-338">Při použití této možnosti lze zachytit pouze podřetězce, které odpovídají pojmenovaným skupinám definovaným s elementem `(?<name>subexpression)` jazyka.</span><span class="sxs-lookup"><span data-stu-id="2eaca-338">When you use this option, only substrings that match named groups defined with the `(?<name>subexpression)` language element can be captured.</span></span> <span data-ttu-id="2eaca-339">Příznak <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture> může být předán `options` parametru <xref:System.Text.RegularExpressions.Regex> konstruktoru třídy nebo <xref:System.Text.RegularExpressions.Regex> parametru `options` statické odpovídající metody.</span><span class="sxs-lookup"><span data-stu-id="2eaca-339">The <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture> flag can be passed to the `options` parameter of a <xref:System.Text.RegularExpressions.Regex> class constructor or to the `options` parameter of a <xref:System.Text.RegularExpressions.Regex> static matching method.</span></span>

- <span data-ttu-id="2eaca-340">Použijte `n` možnost v `(?imnsx)` elementu jazyka.</span><span class="sxs-lookup"><span data-stu-id="2eaca-340">Use the `n` option in the `(?imnsx)` language element.</span></span> <span data-ttu-id="2eaca-341">Tato možnost zakazuje všechna nepojmenovaná nebo implicitní zachycení z bodu ve vzoru regulárního výrazu, ve kterém se prvek objeví.</span><span class="sxs-lookup"><span data-stu-id="2eaca-341">This option disables all unnamed or implicit captures from the point in the regular expression pattern at which the element appears.</span></span> <span data-ttu-id="2eaca-342">Zachycení jsou zakázány buď do konce vzoru `(-n)` nebo dokud možnost povolí nepojmenované nebo implicitní zachycení.</span><span class="sxs-lookup"><span data-stu-id="2eaca-342">Captures are disabled either until the end of the pattern or until the `(-n)` option enables unnamed or implicit captures.</span></span> <span data-ttu-id="2eaca-343">Další informace naleznete v tématu [Různé konstrukce](../../../docs/standard/base-types/miscellaneous-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="2eaca-343">For more information, see [Miscellaneous Constructs](../../../docs/standard/base-types/miscellaneous-constructs-in-regular-expressions.md).</span></span>

- <span data-ttu-id="2eaca-344">Použijte `n` možnost v `(?imnsx:subexpression)` elementu jazyka.</span><span class="sxs-lookup"><span data-stu-id="2eaca-344">Use the `n` option in the `(?imnsx:subexpression)` language element.</span></span> <span data-ttu-id="2eaca-345">Tato možnost zakáže všechna nepojmenovaná nebo implicitní zachycení v programu `subexpression`.</span><span class="sxs-lookup"><span data-stu-id="2eaca-345">This option disables all unnamed or implicit captures in `subexpression`.</span></span> <span data-ttu-id="2eaca-346">Zachycení nepojmenovanou nebo implicitní vnořenou zachytávající skupinou jsou rovněž zakázána.</span><span class="sxs-lookup"><span data-stu-id="2eaca-346">Captures by any unnamed or implicit nested capturing groups are disabled as well.</span></span>

## <a name="related-topics"></a><span data-ttu-id="2eaca-347">Související témata</span><span class="sxs-lookup"><span data-stu-id="2eaca-347">Related topics</span></span>

|<span data-ttu-id="2eaca-348">Nadpis</span><span class="sxs-lookup"><span data-stu-id="2eaca-348">Title</span></span>|<span data-ttu-id="2eaca-349">Popis</span><span class="sxs-lookup"><span data-stu-id="2eaca-349">Description</span></span>|
|-----------|-----------------|
|[<span data-ttu-id="2eaca-350">Podrobnosti k chování regulárních výrazů</span><span class="sxs-lookup"><span data-stu-id="2eaca-350">Details of Regular Expression Behavior</span></span>](../../../docs/standard/base-types/details-of-regular-expression-behavior.md)|<span data-ttu-id="2eaca-351">Zkoumá implementaci modulu regulárních výrazů v rozhraní .NET.</span><span class="sxs-lookup"><span data-stu-id="2eaca-351">Examines the implementation of the regular expression engine in .NET.</span></span> <span data-ttu-id="2eaca-352">Téma se zaměřuje na flexibilitu regulárních výrazů a objasňuje odpovědnost vývojáře za zajištění efektivity a výkonnosti modulu regulárních výrazů.</span><span class="sxs-lookup"><span data-stu-id="2eaca-352">The topic focuses on the flexibility of regular expressions and explains the developer's responsibility for ensuring the efficient and robust operation of the regular expression engine.</span></span>|
|[<span data-ttu-id="2eaca-353">Zpětné navracení</span><span class="sxs-lookup"><span data-stu-id="2eaca-353">Backtracking</span></span>](../../../docs/standard/base-types/backtracking-in-regular-expressions.md)|<span data-ttu-id="2eaca-354">Vysvětluje princip zpětného navracení a vliv tohoto mechanismu na výkon regulárních výrazů a zkoumá prvky jazyka, které nabízí alternativu zpětného navracení.</span><span class="sxs-lookup"><span data-stu-id="2eaca-354">Explains what backtracking is and how it affects regular expression performance, and examines language elements that provide alternatives to backtracking.</span></span>|
|[<span data-ttu-id="2eaca-355">Jazyk regulárních výrazů – stručná referenční dokumentace</span><span class="sxs-lookup"><span data-stu-id="2eaca-355">Regular Expression Language - Quick Reference</span></span>](../../../docs/standard/base-types/regular-expression-language-quick-reference.md)|<span data-ttu-id="2eaca-356">Popisuje prvky jazyka regulárních výrazů v rozhraní .NET a obsahuje odkazy na podrobnou dokumentaci pro každý element jazyka.</span><span class="sxs-lookup"><span data-stu-id="2eaca-356">Describes the elements of the regular expression language in .NET and provides links to detailed documentation for each language element.</span></span>|
