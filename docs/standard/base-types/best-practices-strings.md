---
title: Doporučené postupy pro použití řetězců v rozhraní .NET
description: Naučte se efektivně používat řetězce v aplikacích .NET.
ms.date: 05/01/2019
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- strings [.NET Framework],searching
- best practices,string comparison and sorting
- strings [.NET Framework],best practices
- strings [.NET Framework],basic string operations
- sorting strings
- strings [.NET Framework],sorting
- string comparison [.NET Framework],best practices
- string sorting
- comparing strings
- strings [.NET Framework],comparing
ms.assetid: b9f0bf53-e2de-4116-8ce9-d4f91a1df4f7
ms.openlocfilehash: c88776ea9d8ba17d86767b704e8b0eaff5b6cb89
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 03/15/2020
ms.locfileid: "75711477"
---
# <a name="best-practices-for-using-strings-in-net"></a><span data-ttu-id="aeee2-103">Doporučené postupy pro použití řetězců v rozhraní .NET</span><span class="sxs-lookup"><span data-stu-id="aeee2-103">Best Practices for Using Strings in .NET</span></span>

<span data-ttu-id="aeee2-104">.NET poskytuje rozsáhlou podporu pro vývoj lokalizovaných a globalizovaných aplikací a usnadňuje použití konvencí aktuální jazykové verze nebo konkrétní jazykové verze při provádění běžných operací, jako je řazení a zobrazování řetězců.</span><span class="sxs-lookup"><span data-stu-id="aeee2-104">.NET provides extensive support for developing localized and globalized applications, and makes it easy to apply the conventions of either the current culture or a specific culture when performing common operations such as sorting and displaying strings.</span></span> <span data-ttu-id="aeee2-105">Ale řazení nebo porovnávání řetězců není vždy operace citlivá na jazykovou verzi.</span><span class="sxs-lookup"><span data-stu-id="aeee2-105">But sorting or comparing strings is not always a culture-sensitive operation.</span></span> <span data-ttu-id="aeee2-106">Například řetězce, které jsou používány interně aplikací obvykle by měly být zpracovány identicky ve všech kulturách.</span><span class="sxs-lookup"><span data-stu-id="aeee2-106">For example, strings that are used internally by an application typically should be handled identically across all cultures.</span></span> <span data-ttu-id="aeee2-107">Když jsou interpretována kulturně nezávislá řetězcová data, jako jsou značky XML, značky HTML, uživatelská jména, cesty k souborům a názvy systémových objektů, jako by byla citlivá na jazykovou verzi, kód aplikace může podléhat jemným chybám, nízkému výkonu a v některých případech bezpečnostních otázek.</span><span class="sxs-lookup"><span data-stu-id="aeee2-107">When culturally independent string data, such as XML tags, HTML tags, user names, file paths, and the names of system objects, are interpreted as if they were culture-sensitive, application code can be subject to subtle bugs, poor performance, and, in some cases, security issues.</span></span>

<span data-ttu-id="aeee2-108">Toto téma zkoumá metody řazení, porovnávání a pouzdře řetězce v rozhraní .NET, představuje doporučení pro výběr vhodné metody zpracování řetězců a poskytuje další informace o metodách zpracování řetězců.</span><span class="sxs-lookup"><span data-stu-id="aeee2-108">This topic examines the string sorting, comparison, and casing methods in .NET, presents recommendations for selecting an appropriate string-handling method, and provides additional information about string-handling methods.</span></span> <span data-ttu-id="aeee2-109">Zkoumá také, jak jsou formátovaná data, jako jsou číselná data a data a čas, zpracována pro zobrazení a pro ukládání.</span><span class="sxs-lookup"><span data-stu-id="aeee2-109">It also examines how formatted data, such as numeric data and date and time data, is handled for display and for storage.</span></span>

## <a name="recommendations-for-string-usage"></a><span data-ttu-id="aeee2-110">Doporučení pro použití řetězce</span><span class="sxs-lookup"><span data-stu-id="aeee2-110">Recommendations for string usage</span></span>

<span data-ttu-id="aeee2-111">Při vývoji s rozhraním .NET postupujte podle těchto jednoduchých doporučení při použití řetězců:</span><span class="sxs-lookup"><span data-stu-id="aeee2-111">When you develop with .NET, follow these simple recommendations when you use strings:</span></span>

- <span data-ttu-id="aeee2-112">Použijte přetížení, která explicitně určují pravidla porovnání řetězců pro operace řetězce.</span><span class="sxs-lookup"><span data-stu-id="aeee2-112">Use overloads that explicitly specify the string comparison rules for string operations.</span></span> <span data-ttu-id="aeee2-113">Obvykle to zahrnuje volání přetížení metody, která <xref:System.StringComparison>má parametr typu .</span><span class="sxs-lookup"><span data-stu-id="aeee2-113">Typically, this involves calling a method overload that has a parameter of type <xref:System.StringComparison>.</span></span>
- <span data-ttu-id="aeee2-114">Použití <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> nebo pro porovnání jako bezpečné výchozí pro porovnávání řetězců bez jazykové verze.</span><span class="sxs-lookup"><span data-stu-id="aeee2-114">Use <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> or <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> for comparisons as your safe default for culture-agnostic string matching.</span></span>
- <span data-ttu-id="aeee2-115">Použijte porovnání <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> s <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> nebo pro lepší výkon.</span><span class="sxs-lookup"><span data-stu-id="aeee2-115">Use comparisons with <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> or <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> for better performance.</span></span>
- <span data-ttu-id="aeee2-116">Použijte operace řetězce, <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType> které jsou založeny na při zobrazení výstupu pro uživatele.</span><span class="sxs-lookup"><span data-stu-id="aeee2-116">Use string operations that are based on <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType> when you display output to the user.</span></span>
- <span data-ttu-id="aeee2-117">Použijte nejazykové <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> nebo <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> hodnoty namísto řetězcových operací založených na <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> tom, kdy je porovnání jazykově irelevantní (například symbolické).</span><span class="sxs-lookup"><span data-stu-id="aeee2-117">Use the non-linguistic <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> or <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> values instead of string operations based on <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> when the comparison is linguistically irrelevant (symbolic, for example).</span></span>
- <span data-ttu-id="aeee2-118">Použijte <xref:System.String.ToUpperInvariant%2A?displayProperty=nameWithType> metodu namísto metody při <xref:System.String.ToLowerInvariant%2A?displayProperty=nameWithType> normalizaci řetězců pro porovnání.</span><span class="sxs-lookup"><span data-stu-id="aeee2-118">Use the <xref:System.String.ToUpperInvariant%2A?displayProperty=nameWithType> method instead of the <xref:System.String.ToLowerInvariant%2A?displayProperty=nameWithType> method when you normalize strings for comparison.</span></span>
- <span data-ttu-id="aeee2-119">Použijte přetížení <xref:System.String.Equals%2A?displayProperty=nameWithType> metody k testování, zda jsou dva řetězce stejné.</span><span class="sxs-lookup"><span data-stu-id="aeee2-119">Use an overload of the <xref:System.String.Equals%2A?displayProperty=nameWithType> method to test whether two strings are equal.</span></span>
- <span data-ttu-id="aeee2-120">Pomocí <xref:System.String.Compare%2A?displayProperty=nameWithType> metod <xref:System.String.CompareTo%2A?displayProperty=nameWithType> a můžete řadit řetězce, nikoli ke kontrole rovnosti.</span><span class="sxs-lookup"><span data-stu-id="aeee2-120">Use the <xref:System.String.Compare%2A?displayProperty=nameWithType> and <xref:System.String.CompareTo%2A?displayProperty=nameWithType> methods to sort strings, not to check for equality.</span></span>
- <span data-ttu-id="aeee2-121">Pomocí formátování závislého na jazykové verzi můžete v uživatelském rozhraní zobrazit data, která nejsou pod řetězec, například čísla a kalendářní data.</span><span class="sxs-lookup"><span data-stu-id="aeee2-121">Use culture-sensitive formatting to display non-string data, such as numbers and dates, in a user interface.</span></span> <span data-ttu-id="aeee2-122">Pomocí formátování s [invariantní jazykovou verzí](xref:System.Globalization.CultureInfo.InvariantCulture) zachovat non-string data v řetězcové formě.</span><span class="sxs-lookup"><span data-stu-id="aeee2-122">Use formatting with the [invariant culture](xref:System.Globalization.CultureInfo.InvariantCulture) to persist non-string data in string form.</span></span>

<span data-ttu-id="aeee2-123">Při použití řetězců se vyhněte následujícím postupům:</span><span class="sxs-lookup"><span data-stu-id="aeee2-123">Avoid the following practices when you use strings:</span></span>

- <span data-ttu-id="aeee2-124">Nepoužívejte přetížení, které explicitně nebo implicitně neurčují pravidla porovnání řetězců pro operace řetězce.</span><span class="sxs-lookup"><span data-stu-id="aeee2-124">Do not use overloads that do not explicitly or implicitly specify the string comparison rules for string operations.</span></span>
- <span data-ttu-id="aeee2-125">Ve většině případů nepoužívejte řetězcové operace založené na. <xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="aeee2-125">Do not use string operations based on <xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType> in most cases.</span></span> <span data-ttu-id="aeee2-126">Jednou z mála výjimek je, když jsou trvalé jazykově smysluplné, ale kulturně agnostik data.</span><span class="sxs-lookup"><span data-stu-id="aeee2-126">One of the few exceptions is when you are persisting linguistically meaningful but culturally agnostic data.</span></span>
- <span data-ttu-id="aeee2-127">Nepoužívejte přetížení <xref:System.String.Compare%2A?displayProperty=nameWithType> metody nebo <xref:System.String.CompareTo%2A> a otestujte vrácenou hodnotu nula k určení, zda jsou dva řetězce stejné.</span><span class="sxs-lookup"><span data-stu-id="aeee2-127">Do not use an overload of the <xref:System.String.Compare%2A?displayProperty=nameWithType> or <xref:System.String.CompareTo%2A> method and test for a return value of zero to determine whether two strings are equal.</span></span>
- <span data-ttu-id="aeee2-128">Nepoužívejte formátování citlivé na jazykovou verzi k uchování číselných dat nebo dat a dat a času v řetězcové podobě.</span><span class="sxs-lookup"><span data-stu-id="aeee2-128">Do not use culture-sensitive formatting to persist numeric data or date and time data in string form.</span></span>

## <a name="specifying-string-comparisons-explicitly"></a><span data-ttu-id="aeee2-129">Explicitní určení porovnání řetězců</span><span class="sxs-lookup"><span data-stu-id="aeee2-129">Specifying string comparisons explicitly</span></span>

<span data-ttu-id="aeee2-130">Většina metod manipulace s řetězci v rozhraní .NET je přetížena.</span><span class="sxs-lookup"><span data-stu-id="aeee2-130">Most of the string manipulation methods in .NET are overloaded.</span></span> <span data-ttu-id="aeee2-131">Obvykle jedno nebo více přetížení přijmout výchozí nastavení, zatímco jiné přijmout žádné výchozí hodnoty a místo toho definovat přesný způsob, jakým řetězce mají být porovnány nebo manipulovat.</span><span class="sxs-lookup"><span data-stu-id="aeee2-131">Typically, one or more overloads accept default settings, whereas others accept no defaults and instead define the precise way in which strings are to be compared or manipulated.</span></span> <span data-ttu-id="aeee2-132">Většina metod, které nejsou závislé na výchozí <xref:System.StringComparison>hodnoty patří parametr typu , což je výčet, který explicitně určuje pravidla pro porovnání řetězců podle jazykové verze a případ.</span><span class="sxs-lookup"><span data-stu-id="aeee2-132">Most of the methods that do not rely on defaults include a parameter of type <xref:System.StringComparison>, which is an enumeration that explicitly specifies rules for string comparison by culture and case.</span></span> <span data-ttu-id="aeee2-133">Následující tabulka popisuje <xref:System.StringComparison> členy výčtu.</span><span class="sxs-lookup"><span data-stu-id="aeee2-133">The following table describes the <xref:System.StringComparison> enumeration members.</span></span>

|<span data-ttu-id="aeee2-134">Člen StringComparison</span><span class="sxs-lookup"><span data-stu-id="aeee2-134">StringComparison member</span></span>|<span data-ttu-id="aeee2-135">Popis</span><span class="sxs-lookup"><span data-stu-id="aeee2-135">Description</span></span>|
|-----------------------------|-----------------|
|<xref:System.StringComparison.CurrentCulture>|<span data-ttu-id="aeee2-136">Provede porovnání rozlišování velkých a malých písmen pomocí aktuální jazykové verze.</span><span class="sxs-lookup"><span data-stu-id="aeee2-136">Performs a case-sensitive comparison using the current culture.</span></span>|
|<xref:System.StringComparison.CurrentCultureIgnoreCase>|<span data-ttu-id="aeee2-137">Provede porovnání bez rozlišování velkých a malých písmen pomocí aktuální jazykové verze.</span><span class="sxs-lookup"><span data-stu-id="aeee2-137">Performs a case-insensitive comparison using the current culture.</span></span>|
|<xref:System.StringComparison.InvariantCulture>|<span data-ttu-id="aeee2-138">Provede porovnání rozlišování velkých a malých písmen pomocí invariantní jazykové verze.</span><span class="sxs-lookup"><span data-stu-id="aeee2-138">Performs a case-sensitive comparison using the invariant culture.</span></span>|
|<xref:System.StringComparison.InvariantCultureIgnoreCase>|<span data-ttu-id="aeee2-139">Provede porovnání bez rozlišování velkých a malých písmen pomocí invariantní jazykové verze.</span><span class="sxs-lookup"><span data-stu-id="aeee2-139">Performs a case-insensitive comparison using the invariant culture.</span></span>|
|<xref:System.StringComparison.Ordinal>|<span data-ttu-id="aeee2-140">Provede pořazovační porovnání.</span><span class="sxs-lookup"><span data-stu-id="aeee2-140">Performs an ordinal comparison.</span></span>|
|<xref:System.StringComparison.OrdinalIgnoreCase>|<span data-ttu-id="aeee2-141">Provede řadové porovnání bez rozlišování velkých a malých písmen.</span><span class="sxs-lookup"><span data-stu-id="aeee2-141">Performs a case-insensitive ordinal comparison.</span></span>|

<span data-ttu-id="aeee2-142">Například <xref:System.String.IndexOf%2A> metoda, která vrací index podřetězce v <xref:System.String> objektu, který odpovídá znaku nebo řetězci, má devět přetížení:</span><span class="sxs-lookup"><span data-stu-id="aeee2-142">For example, the <xref:System.String.IndexOf%2A> method, which returns the index of a substring in a <xref:System.String> object that matches either a character or a string, has nine overloads:</span></span>

- <span data-ttu-id="aeee2-143"><xref:System.String.IndexOf%28System.Char%29>, <xref:System.String.IndexOf%28System.Char%2CSystem.Int32%29>a <xref:System.String.IndexOf%28System.Char%2CSystem.Int32%2CSystem.Int32%29>, které ve výchozím nastavení provádějí řadové (rozlišování velkých a nerozlišující malá a velká písmena) vyhledávají znak v řetězci.</span><span class="sxs-lookup"><span data-stu-id="aeee2-143"><xref:System.String.IndexOf%28System.Char%29>, <xref:System.String.IndexOf%28System.Char%2CSystem.Int32%29>, and <xref:System.String.IndexOf%28System.Char%2CSystem.Int32%2CSystem.Int32%29>, which by default perform an ordinal (case-sensitive and culture-insensitive) search for a character in the string.</span></span>
- <span data-ttu-id="aeee2-144"><xref:System.String.IndexOf%28System.String%29>, <xref:System.String.IndexOf%28System.String%2CSystem.Int32%29>, <xref:System.String.IndexOf%28System.String%2CSystem.Int32%2CSystem.Int32%29>a , které ve výchozím nastavení provádějí hledání dílčího řetězce v řetězci rozlišující malá a velká písmena a jazykovou verzi.</span><span class="sxs-lookup"><span data-stu-id="aeee2-144"><xref:System.String.IndexOf%28System.String%29>, <xref:System.String.IndexOf%28System.String%2CSystem.Int32%29>, and <xref:System.String.IndexOf%28System.String%2CSystem.Int32%2CSystem.Int32%29>, which by default perform a case-sensitive and culture-sensitive search for a substring in the string.</span></span>
- <span data-ttu-id="aeee2-145"><xref:System.String.IndexOf%28System.String%2CSystem.StringComparison%29>, <xref:System.String.IndexOf%28System.String%2CSystem.Int32%2CSystem.StringComparison%29>a <xref:System.String.IndexOf%28System.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29>, které obsahují <xref:System.StringComparison> parametr typu, který umožňuje zadat formu porovnání.</span><span class="sxs-lookup"><span data-stu-id="aeee2-145"><xref:System.String.IndexOf%28System.String%2CSystem.StringComparison%29>, <xref:System.String.IndexOf%28System.String%2CSystem.Int32%2CSystem.StringComparison%29>, and <xref:System.String.IndexOf%28System.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29>, which include a parameter of type <xref:System.StringComparison> that allows the form of the comparison to be specified.</span></span>

<span data-ttu-id="aeee2-146">Doporučujeme vybrat přetížení, které nepoužívá výchozí hodnoty, z následujících důvodů:</span><span class="sxs-lookup"><span data-stu-id="aeee2-146">We recommend that you select an overload that does not use default values, for the following reasons:</span></span>

- <span data-ttu-id="aeee2-147">Některá přetížení s výchozími parametry <xref:System.Char> (ty, které hledají instanci řetězce) provádějí řadové porovnání, zatímco jiné (ty, které hledají řetězec v instanci řetězce) jsou citlivé na jazykovou verzi.</span><span class="sxs-lookup"><span data-stu-id="aeee2-147">Some overloads with default parameters (those that search for a <xref:System.Char> in the string instance) perform an ordinal comparison, whereas others (those that search for a string in the string instance) are culture-sensitive.</span></span> <span data-ttu-id="aeee2-148">Je obtížné si vzpomenout, která metoda používá výchozí hodnotu a snadno zmást přetížení.</span><span class="sxs-lookup"><span data-stu-id="aeee2-148">It is difficult to remember which method uses which default value, and easy to confuse the overloads.</span></span>
- <span data-ttu-id="aeee2-149">Záměr kódu, který závisí na výchozí hodnoty pro volání metody není jasné.</span><span class="sxs-lookup"><span data-stu-id="aeee2-149">The intent of the code that relies on default values for method calls is not clear.</span></span> <span data-ttu-id="aeee2-150">V následujícím příkladu, který se opírá o výchozí hodnoty, je obtížné zjistit, zda vývojář skutečně zamýšlel řadové nebo jazykové porovnání dvou řetězců, nebo zda rozdíl v případu mezi `protocol` a "http" může způsobit návrat testu rovnosti `false`.</span><span class="sxs-lookup"><span data-stu-id="aeee2-150">In the following example, which relies on defaults, it is difficult to know whether the developer actually intended an ordinal or a linguistic comparison of two strings, or whether a case difference between `protocol` and "http" might cause the test for equality to return `false`.</span></span>

     [!code-csharp[Conceptual.Strings.BestPractices#1](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.strings.bestpractices/cs/explicitargs1.cs#1)]
     [!code-vb[Conceptual.Strings.BestPractices#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.strings.bestpractices/vb/explicitargs1.vb#1)]

<span data-ttu-id="aeee2-151">Obecně doporučujeme volat metodu, která není závislá na výchozí hodnoty, protože umožňuje záměr kódu jednoznačné.</span><span class="sxs-lookup"><span data-stu-id="aeee2-151">In general, we recommend that you call a method that does not rely on defaults, because it makes the intent of the code unambiguous.</span></span> <span data-ttu-id="aeee2-152">To zase dělá kód čitelnější a snadněji ladit a udržovat.</span><span class="sxs-lookup"><span data-stu-id="aeee2-152">This, in turn, makes the code more readable and easier to debug and maintain.</span></span> <span data-ttu-id="aeee2-153">Následující příklad řeší otázky vznesené v předchozím příkladu.</span><span class="sxs-lookup"><span data-stu-id="aeee2-153">The following example addresses the questions raised about the previous example.</span></span> <span data-ttu-id="aeee2-154">Je jasné, že se používá ordinální porovnání a že rozdíly v případě jsou ignorovány.</span><span class="sxs-lookup"><span data-stu-id="aeee2-154">It makes it clear that ordinal comparison is used and that differences in case are ignored.</span></span>

[!code-csharp[Conceptual.Strings.BestPractices#2](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.strings.bestpractices/cs/explicitargs1.cs#2)]
[!code-vb[Conceptual.Strings.BestPractices#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.strings.bestpractices/vb/explicitargs1.vb#2)]

## <a name="the-details-of-string-comparison"></a><span data-ttu-id="aeee2-155">Podrobnosti porovnání řetězců</span><span class="sxs-lookup"><span data-stu-id="aeee2-155">The details of string comparison</span></span>

<span data-ttu-id="aeee2-156">Porovnání řetězců je srdcem mnoha operací souvisejících s řetězci, zejména řazení a testování rovnosti.</span><span class="sxs-lookup"><span data-stu-id="aeee2-156">String comparison is the heart of many string-related operations, particularly sorting and testing for equality.</span></span> <span data-ttu-id="aeee2-157">Řetězce seřadí v určeném pořadí: Pokud se "my" zobrazí před "řetězce" v seřazeném seznamu řetězců, musí "my" porovnat méně než nebo rovno "řetězec".</span><span class="sxs-lookup"><span data-stu-id="aeee2-157">Strings sort in a determined order: If "my" appears before "string" in a sorted list of strings, "my" must compare less than or equal to "string".</span></span> <span data-ttu-id="aeee2-158">Navíc porovnání implicitně definuje rovnost.</span><span class="sxs-lookup"><span data-stu-id="aeee2-158">Additionally, comparison implicitly defines equality.</span></span> <span data-ttu-id="aeee2-159">Operace porovnání vrátí nulu pro řetězce, které považuje za rovné.</span><span class="sxs-lookup"><span data-stu-id="aeee2-159">The comparison operation returns zero for strings it deems equal.</span></span> <span data-ttu-id="aeee2-160">Dobrý výklad je, že ani řetězec je menší než ostatní.</span><span class="sxs-lookup"><span data-stu-id="aeee2-160">A good interpretation is that neither string is less than the other.</span></span> <span data-ttu-id="aeee2-161">Většina smysluplné operace zahrnující řetězce zahrnují jeden nebo oba tyto postupy: porovnání s jiným řetězcem a provádění dobře definované operace řazení.</span><span class="sxs-lookup"><span data-stu-id="aeee2-161">Most meaningful operations involving strings include one or both of these procedures: comparing with another string, and executing a well-defined sort operation.</span></span>

> [!NOTE]
> <span data-ttu-id="aeee2-162">Můžete si stáhnout [tabulku tloušťky řazení](https://www.microsoft.com/download/details.aspx?id=10921), sadu textových souborů, které obsahují informace o hmotnosti znaků používané při řazení a porovnávání operací pro operační systémy Windows, a [výchozí tabulku prvků řazení unicode](https://www.unicode.org/Public/UCA/latest/allkeys.txt), nejnovější verzi tabulky hmotnosti řazení pro Linux a macOS.</span><span class="sxs-lookup"><span data-stu-id="aeee2-162">You can download the [Sorting Weight Tables](https://www.microsoft.com/download/details.aspx?id=10921), a set of text files that contain information on the character weights used in sorting and comparison operations for Windows operating systems, and the [Default Unicode Collation Element Table](https://www.unicode.org/Public/UCA/latest/allkeys.txt), the latest version of the sort weight table for Linux and macOS.</span></span> <span data-ttu-id="aeee2-163">Konkrétní verze tabulky řazení hmotnosti na Linux a macOS závisí na verzi [mezinárodních komponent pro](http://site.icu-project.org/) knihovny Unicode nainstalované v systému.</span><span class="sxs-lookup"><span data-stu-id="aeee2-163">The specific version of the sort weight table on Linux and macOS depends on the version of the [International Components for Unicode](http://site.icu-project.org/) libraries installed on the system.</span></span> <span data-ttu-id="aeee2-164">Informace o verzích ICU a verzích Unicode, které implementují, naleznete [v tématu Stažení JIP](http://site.icu-project.org/download).</span><span class="sxs-lookup"><span data-stu-id="aeee2-164">For information on ICU versions and the Unicode versions that they implement, see [Downloading ICU](http://site.icu-project.org/download).</span></span>

<span data-ttu-id="aeee2-165">Vyhodnocení dvou řetězců pro rovnost nebo pořadí řazení však nepřináší jeden, správný výsledek; výsledek závisí na kritériích použitých k porovnání řetězců.</span><span class="sxs-lookup"><span data-stu-id="aeee2-165">However, evaluating two strings for equality or sort order does not yield a single, correct result; the outcome depends on the criteria used to compare the strings.</span></span> <span data-ttu-id="aeee2-166">Zejména porovnání řetězců, které jsou řadové nebo které jsou založeny na konvencích písmen a řazení aktuální jazykové verze nebo [invariantní jazykové verze](xref:System.Globalization.CultureInfo.InvariantCulture) (jazyková verze agnostik národního prostředí založená na anglickém jazyce) mohou vést k různým výsledkům.</span><span class="sxs-lookup"><span data-stu-id="aeee2-166">In particular, string comparisons that are ordinal or that are based on the casing and sorting conventions of the current culture or the [invariant culture](xref:System.Globalization.CultureInfo.InvariantCulture) (a locale-agnostic culture based on the English language) may produce different results.</span></span>

<span data-ttu-id="aeee2-167">Porovnání řetězců pomocí různých verzí rozhraní .NET nebo použití rozhraní .NET v různých operačních systémech nebo verzích operačního systému může navíc vracet různé výsledky.</span><span class="sxs-lookup"><span data-stu-id="aeee2-167">In addition, string comparisons using different versions of .NET or using .NET on different operating systems or operating system versions may return different results.</span></span> <span data-ttu-id="aeee2-168">Další informace naleznete [v tématu Řetězce a Unicode Standard](xref:System.String#Unicode).</span><span class="sxs-lookup"><span data-stu-id="aeee2-168">For more information, see [Strings and the Unicode Standard](xref:System.String#Unicode).</span></span>

### <a name="string-comparisons-that-use-the-current-culture"></a><span data-ttu-id="aeee2-169">Porovnání řetězců, které používají aktuální jazykovou verzi</span><span class="sxs-lookup"><span data-stu-id="aeee2-169">String comparisons that use the current culture</span></span>

<span data-ttu-id="aeee2-170">Jedním z kritérií zahrnuje použití konvencí aktuální jazykové verze při porovnávání řetězců.</span><span class="sxs-lookup"><span data-stu-id="aeee2-170">One criterion involves using the conventions of the current culture when comparing strings.</span></span> <span data-ttu-id="aeee2-171">Porovnání, které jsou založeny na aktuální jazykové verzi použít aktuální jazykovou verzi vlákna nebo národní prostředí.</span><span class="sxs-lookup"><span data-stu-id="aeee2-171">Comparisons that are based on the current culture use the thread's current culture or locale.</span></span> <span data-ttu-id="aeee2-172">Pokud jazyková verze není nastavena uživatelem, je výchozí nastavení v okně **Místní možnosti** v Ovládacích panelech.</span><span class="sxs-lookup"><span data-stu-id="aeee2-172">If the culture is not set by the user, it defaults to the setting in the **Regional Options** window in Control Panel.</span></span> <span data-ttu-id="aeee2-173">Vždy byste měli použít porovnání, které jsou založeny na aktuální jazykové verzi, když data jsou jazykově relevantní a když odráží interakci uživatele citlivou na jazykovou verzi.</span><span class="sxs-lookup"><span data-stu-id="aeee2-173">You should always use comparisons that are based on the current culture when data is linguistically relevant, and when it reflects culture-sensitive user interaction.</span></span>

<span data-ttu-id="aeee2-174">Však porovnání a caseing chování v rozhraní .NET změní při změně jazykové verze.</span><span class="sxs-lookup"><span data-stu-id="aeee2-174">However, comparison and casing behavior in .NET changes when the culture changes.</span></span> <span data-ttu-id="aeee2-175">K tomu dochází, když se aplikace spustí v počítači, který má jinou jazykovou verzi než počítač, ve kterém byla aplikace vyvinuta, nebo když vykonávající vlákno změní svou jazykovou verzi.</span><span class="sxs-lookup"><span data-stu-id="aeee2-175">This happens when an application executes on a computer that has a different culture than the computer on which the application was developed, or when the executing thread changes its culture.</span></span> <span data-ttu-id="aeee2-176">Toto chování je úmyslné, ale zůstává nezřejmé pro mnoho vývojářů.</span><span class="sxs-lookup"><span data-stu-id="aeee2-176">This behavior is intentional, but it remains non-obvious to many developers.</span></span> <span data-ttu-id="aeee2-177">Následující příklad ilustruje rozdíly v pořadí řazení mezi jazykovou verzí americké angličtiny ("en-US") a švédštiny ("sv-SE").</span><span class="sxs-lookup"><span data-stu-id="aeee2-177">The following example illustrates differences in sort order between the U.S. English ("en-US") and Swedish ("sv-SE") cultures.</span></span> <span data-ttu-id="aeee2-178">Všimněte si, že slova "ångström", "Windows" a "Visual Studio" se zobrazí v různých pozicích v seřazených polí řetězců.</span><span class="sxs-lookup"><span data-stu-id="aeee2-178">Note that the words "ångström", "Windows", and "Visual Studio" appear in different positions in the sorted string arrays.</span></span>

[!code-csharp[Conceptual.Strings.BestPractices#3](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.strings.bestpractices/cs/comparison1.cs#3)]
[!code-vb[Conceptual.Strings.BestPractices#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.strings.bestpractices/vb/comparison1.vb#3)]

<span data-ttu-id="aeee2-179">Porovnání bez rozlišování velkých a malých písmen, které používají aktuální jazykovou verzi jsou stejné jako porovnání zjištovaní jazykovou verzi, s tím rozdílem, že ignorují případ, jak je diktováno aktuální jazykovou verzí vlákna.</span><span class="sxs-lookup"><span data-stu-id="aeee2-179">Case-insensitive comparisons that use the current culture are the same as culture-sensitive comparisons, except that they ignore case as dictated by the thread's current culture.</span></span> <span data-ttu-id="aeee2-180">Toto chování se může projevit také v pořadí řazení.</span><span class="sxs-lookup"><span data-stu-id="aeee2-180">This behavior may manifest itself in sort orders as well.</span></span>

<span data-ttu-id="aeee2-181">Porovnání, které používají aktuální sémantiku kultury jsou výchozí pro následující metody:</span><span class="sxs-lookup"><span data-stu-id="aeee2-181">Comparisons that use current culture semantics are the default for the following methods:</span></span>

- <span data-ttu-id="aeee2-182"><xref:System.String.Compare%2A?displayProperty=nameWithType>přetížení, které neobsahují <xref:System.StringComparison> parametr.</span><span class="sxs-lookup"><span data-stu-id="aeee2-182"><xref:System.String.Compare%2A?displayProperty=nameWithType> overloads that do not include a <xref:System.StringComparison> parameter.</span></span>
- <span data-ttu-id="aeee2-183"><xref:System.String.CompareTo%2A?displayProperty=nameWithType>Přetížení.</span><span class="sxs-lookup"><span data-stu-id="aeee2-183"><xref:System.String.CompareTo%2A?displayProperty=nameWithType> overloads.</span></span>
- <span data-ttu-id="aeee2-184">Výchozí <xref:System.String.StartsWith%28System.String%29?displayProperty=nameWithType> metoda a <xref:System.String.StartsWith%28System.String%2CSystem.Boolean%2CSystem.Globalization.CultureInfo%29?displayProperty=nameWithType> metoda s `null` <xref:System.Globalization.CultureInfo> parametrem.</span><span class="sxs-lookup"><span data-stu-id="aeee2-184">The default <xref:System.String.StartsWith%28System.String%29?displayProperty=nameWithType> method, and the <xref:System.String.StartsWith%28System.String%2CSystem.Boolean%2CSystem.Globalization.CultureInfo%29?displayProperty=nameWithType> method with a `null`<xref:System.Globalization.CultureInfo> parameter.</span></span>
- <span data-ttu-id="aeee2-185">Výchozí <xref:System.String.EndsWith%28System.String%29?displayProperty=nameWithType> metoda a <xref:System.String.EndsWith%28System.String%2CSystem.Boolean%2CSystem.Globalization.CultureInfo%29?displayProperty=nameWithType> metoda s `null` <xref:System.Globalization.CultureInfo> parametrem.</span><span class="sxs-lookup"><span data-stu-id="aeee2-185">The default <xref:System.String.EndsWith%28System.String%29?displayProperty=nameWithType> method, and the <xref:System.String.EndsWith%28System.String%2CSystem.Boolean%2CSystem.Globalization.CultureInfo%29?displayProperty=nameWithType> method with a `null`<xref:System.Globalization.CultureInfo> parameter.</span></span>
- <span data-ttu-id="aeee2-186"><xref:System.String.IndexOf%2A?displayProperty=nameWithType>přetížení, které <xref:System.String> přijímají jako vyhledávací parametr a <xref:System.StringComparison> které nemají parametr.</span><span class="sxs-lookup"><span data-stu-id="aeee2-186"><xref:System.String.IndexOf%2A?displayProperty=nameWithType> overloads that accept a <xref:System.String> as a search parameter and that do not have a <xref:System.StringComparison> parameter.</span></span>
- <span data-ttu-id="aeee2-187"><xref:System.String.LastIndexOf%2A?displayProperty=nameWithType>přetížení, které <xref:System.String> přijímají jako vyhledávací parametr a <xref:System.StringComparison> které nemají parametr.</span><span class="sxs-lookup"><span data-stu-id="aeee2-187"><xref:System.String.LastIndexOf%2A?displayProperty=nameWithType> overloads that accept a <xref:System.String> as a search parameter and that do not have a <xref:System.StringComparison> parameter.</span></span>

<span data-ttu-id="aeee2-188">V každém případě doporučujeme volat přetížení, <xref:System.StringComparison> které má parametr, aby záměr volání metody jasné.</span><span class="sxs-lookup"><span data-stu-id="aeee2-188">In any case, we recommend that you call an overload that has a <xref:System.StringComparison> parameter to make the intent of the method call clear.</span></span>

<span data-ttu-id="aeee2-189">Subtilní a ne tak jemné chyby se mohou objevit, když jsou jazykově interpretována nejazykná řetězcová data nebo když jsou řetězcová data z určité jazykové verze interpretována pomocí konvencí jiné jazykové verze.</span><span class="sxs-lookup"><span data-stu-id="aeee2-189">Subtle and not so subtle bugs can emerge when non-linguistic string data is interpreted linguistically, or when string data from a particular culture is interpreted using the conventions of another culture.</span></span> <span data-ttu-id="aeee2-190">Kanonickým příkladem je problém Turecka a I.</span><span class="sxs-lookup"><span data-stu-id="aeee2-190">The canonical example is the Turkish-I problem.</span></span>

<span data-ttu-id="aeee2-191">Pro téměř všechny latinské abecedy, včetně americké angličtiny, znak "i" (\u0069) je malá verze znaku "I" (\u0049).</span><span class="sxs-lookup"><span data-stu-id="aeee2-191">For nearly all Latin alphabets, including U.S. English, the character "i" (\u0069) is the lowercase version of the character "I" (\u0049).</span></span> <span data-ttu-id="aeee2-192">Toto pravidlo krytu se rychle stane výchozím nastavením pro uživatele programování v takové jazykové verzi.</span><span class="sxs-lookup"><span data-stu-id="aeee2-192">This casing rule quickly becomes the default for someone programming in such a culture.</span></span> <span data-ttu-id="aeee2-193">Turecká abeceda ("tr-TR") však obsahuje znak "I s tečkou" "İ" (\u0130), což je hlavní verze "i".</span><span class="sxs-lookup"><span data-stu-id="aeee2-193">However, the Turkish ("tr-TR") alphabet includes an "I with a dot" character "İ" (\u0130), which is the capital version of "i".</span></span> <span data-ttu-id="aeee2-194">Turečtina také obsahuje malý znak "i bez tečky", "ı" (\u0131), který má velká písmena "I".</span><span class="sxs-lookup"><span data-stu-id="aeee2-194">Turkish also includes a lowercase "i without a dot" character, "ı" (\u0131), which capitalizes to "I".</span></span> <span data-ttu-id="aeee2-195">K tomuto chování dochází také v ázerbájdžánské jazykové verzi ("az").</span><span class="sxs-lookup"><span data-stu-id="aeee2-195">This behavior occurs in the Azerbaijani ("az") culture as well.</span></span>

<span data-ttu-id="aeee2-196">Proto předpoklady o svitek "i" nebo lowercasing "I" nejsou platné mezi všechny jazykové verze.</span><span class="sxs-lookup"><span data-stu-id="aeee2-196">Therefore, assumptions made about capitalizing "i" or lowercasing "I" are not valid among all cultures.</span></span> <span data-ttu-id="aeee2-197">Pokud použijete výchozí přetížení pro rutiny porovnání řetězců, budou podléhat odchylkám mezi jazyky.</span><span class="sxs-lookup"><span data-stu-id="aeee2-197">If you use the default overloads for string comparison routines, they will be subject to variance between cultures.</span></span> <span data-ttu-id="aeee2-198">Pokud data, která mají být porovnána, nejsou jazyková, může použití výchozího přetížení vést k nežádoucím výsledkům, jak dokládá následující pokus o porovnání řetězců "file" a "FILE" bez rozlišování velkých a malých písmen.</span><span class="sxs-lookup"><span data-stu-id="aeee2-198">If the data to be compared is non-linguistic, using the default overloads can produce undesirable results, as the following attempt to perform a case-insensitive comparison of the strings "file" and "FILE" illustrates.</span></span>

[!code-csharp[Conceptual.Strings.BestPractices#11](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.strings.bestpractices/cs/turkish1.cs#11)]
[!code-vb[Conceptual.Strings.BestPractices#11](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.strings.bestpractices/vb/turkish1.vb#11)]

<span data-ttu-id="aeee2-199">Toto porovnání může způsobit významné problémy, pokud je jazyková verze neúmyslně použita v nastavení citlivém na zabezpečení, jako v následujícím příkladu.</span><span class="sxs-lookup"><span data-stu-id="aeee2-199">This comparison could cause significant problems if the culture is inadvertently used in security-sensitive settings, as in the following example.</span></span> <span data-ttu-id="aeee2-200">Volání metody, `IsFileURI("file:")` například vrátí, `true` pokud aktuální jazyková `false` verze je angličtina USA, ale pokud aktuální jazyková verze je turečtina.</span><span class="sxs-lookup"><span data-stu-id="aeee2-200">A method call such as `IsFileURI("file:")` returns `true` if the current culture is U.S. English, but `false` if the current culture is Turkish.</span></span> <span data-ttu-id="aeee2-201">Tak, na turecké systémy, někdo mohl obejít bezpečnostní opatření, která blokují přístup k malá a velká písmena URI, které začínají "FILE:".</span><span class="sxs-lookup"><span data-stu-id="aeee2-201">Thus, on Turkish systems, someone could circumvent security measures that block access to case-insensitive URIs that begin with "FILE:".</span></span>

[!code-csharp[Conceptual.Strings.BestPractices#12](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.strings.bestpractices/cs/turkish1.cs#12)]
[!code-vb[Conceptual.Strings.BestPractices#12](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.strings.bestpractices/vb/turkish1.vb#12)]

<span data-ttu-id="aeee2-202">V tomto případě protože "file:" je určen k interpretovat jako nejazykové, jazyková jazyková verze necitlivý identifikátor, kód by měl být místo toho zapsán, jak je znázorněno v následujícím příkladu:</span><span class="sxs-lookup"><span data-stu-id="aeee2-202">In this case, because "file:" is meant to be interpreted as a non-linguistic, culture-insensitive identifier, the code should instead be written as shown in the following example:</span></span>

[!code-csharp[Conceptual.Strings.BestPractices#13](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.strings.bestpractices/cs/turkish1.cs#13)]
[!code-vb[Conceptual.Strings.BestPractices#13](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.strings.bestpractices/vb/turkish1.vb#13)]

### <a name="ordinal-string-operations"></a><span data-ttu-id="aeee2-203">Operace řadových řetězců</span><span class="sxs-lookup"><span data-stu-id="aeee2-203">Ordinal string operations</span></span>

<span data-ttu-id="aeee2-204">Zadání hodnoty <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> nebo v volání metody znamená nejazykové porovnání, ve kterém jsou ignorovány vlastnosti přirozených jazyků.</span><span class="sxs-lookup"><span data-stu-id="aeee2-204">Specifying the <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> or <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> value in a method call signifies a non-linguistic comparison in which the features of natural languages are ignored.</span></span> <span data-ttu-id="aeee2-205">Metody, které jsou <xref:System.StringComparison> vyvolány s těmito hodnotami rozhodnutí o operaci základního řetězce na jednoduché porovnání bajtů namísto velikosti písmen nebo tabulky ekvivalence, které jsou parametrizovány jazykovou verzí.</span><span class="sxs-lookup"><span data-stu-id="aeee2-205">Methods that are invoked with these <xref:System.StringComparison> values base string operation decisions on simple byte comparisons instead of casing or equivalence tables that are parameterized by culture.</span></span> <span data-ttu-id="aeee2-206">Ve většině případů tento přístup nejlépe vyhovuje zamýšlené interpretaci řetězců při vytváření kódu rychlejší a spolehlivější.</span><span class="sxs-lookup"><span data-stu-id="aeee2-206">In most cases, this approach best fits the intended interpretation of strings while making code faster and more reliable.</span></span>

<span data-ttu-id="aeee2-207">Ordinální porovnání jsou porovnání řetězců, ve kterých je každý bajt každého řetězce porovnán bez jazykové interpretace; například "windows" neodpovídá "Windows".</span><span class="sxs-lookup"><span data-stu-id="aeee2-207">Ordinal comparisons are string comparisons in which each byte of each string is compared without linguistic interpretation; for example, "windows" does not match "Windows".</span></span> <span data-ttu-id="aeee2-208">Toto je v podstatě `strcmp` volání funkce runtime C.</span><span class="sxs-lookup"><span data-stu-id="aeee2-208">This is essentially a call to the C runtime `strcmp` function.</span></span> <span data-ttu-id="aeee2-209">Toto porovnání použijte, pokud kontext určuje, že řetězce by měly být přesně spárovány nebo vyžaduje konzervativní zásady párování.</span><span class="sxs-lookup"><span data-stu-id="aeee2-209">Use this comparison when the context dictates that strings should be matched exactly or demands conservative matching policy.</span></span> <span data-ttu-id="aeee2-210">Kromě toho řadové porovnání je nejrychlejší porovnání operace, protože platí žádná jazyková pravidla při určování výsledku.</span><span class="sxs-lookup"><span data-stu-id="aeee2-210">Additionally, ordinal comparison is the fastest comparison operation because it applies no linguistic rules when determining a result.</span></span>

<span data-ttu-id="aeee2-211">Řetězce v rozhraní .NET mohou obsahovat vložené prázdné znaky.</span><span class="sxs-lookup"><span data-stu-id="aeee2-211">Strings in .NET can contain embedded null characters.</span></span> <span data-ttu-id="aeee2-212">Jeden z nejjasnějších rozdílů mezi řadovým a jazykovou verzí citlivé porovnání (včetně porovnání, které používají invariantní jazykovou verzi) se týká zpracování vložené prázdné znaky v řetězci.</span><span class="sxs-lookup"><span data-stu-id="aeee2-212">One of the clearest differences between ordinal and culture-sensitive comparison (including comparisons that use the invariant culture) concerns the handling of embedded null characters in a string.</span></span> <span data-ttu-id="aeee2-213">Tyto znaky jsou ignorovány <xref:System.String.Compare%2A?displayProperty=nameWithType> při <xref:System.String.Equals%2A?displayProperty=nameWithType> použití a metody k provádění porovnání zjitřující jazykovou verzi (včetně porovnání, které používají invariantní jazykovou verzi).</span><span class="sxs-lookup"><span data-stu-id="aeee2-213">These characters are ignored when you use the <xref:System.String.Compare%2A?displayProperty=nameWithType> and <xref:System.String.Equals%2A?displayProperty=nameWithType> methods to perform culture-sensitive comparisons (including comparisons that use the invariant culture).</span></span> <span data-ttu-id="aeee2-214">V důsledku toho v porovnání zjitřující jazykovou verzi řetězce, které obsahují vložené prázdné znaky lze považovat za rovna řetězce, které nejsou.</span><span class="sxs-lookup"><span data-stu-id="aeee2-214">As a result, in culture-sensitive comparisons, strings that contain embedded null characters can be considered equal to strings that do not.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="aeee2-215">Přestože metody porovnávání řetězců ignorují vložené <xref:System.String.EndsWith%2A?displayProperty=nameWithType> <xref:System.String.IndexOf%2A?displayProperty=nameWithType>prázdné <xref:System.String.LastIndexOf%2A?displayProperty=nameWithType>znaky, metody vyhledávání řetězců, například <xref:System.String.StartsWith%2A?displayProperty=nameWithType> <xref:System.String.Contains%2A?displayProperty=nameWithType>, , , a ne.</span><span class="sxs-lookup"><span data-stu-id="aeee2-215">Although string comparison methods disregard embedded null characters, string search methods such as <xref:System.String.Contains%2A?displayProperty=nameWithType>, <xref:System.String.EndsWith%2A?displayProperty=nameWithType>, <xref:System.String.IndexOf%2A?displayProperty=nameWithType>, <xref:System.String.LastIndexOf%2A?displayProperty=nameWithType>, and <xref:System.String.StartsWith%2A?displayProperty=nameWithType> do not.</span></span>

<span data-ttu-id="aeee2-216">Následující příklad provádí porovnání řetězce "Aa" citlivé na jazykovou verzi s podobným řetězcem, který obsahuje několik vložených prázdných znaků mezi "A" a "a" a ukazuje, jak jsou oba řetězce považovány za rovné:</span><span class="sxs-lookup"><span data-stu-id="aeee2-216">The following example performs a culture-sensitive comparison of the string "Aa" with a similar string that contains several embedded null characters between "A" and "a", and shows how the two strings are considered equal:</span></span>

[!code-csharp[Conceptual.Strings.BestPractices#19](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.strings.bestpractices/cs/embeddednulls1.cs#19)]
 [!code-vb[Conceptual.Strings.BestPractices#19](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.strings.bestpractices/vb/embeddednulls1.vb#19)]

<span data-ttu-id="aeee2-217">Řetězce se však nepovažují za rovné při použití řadového porovnání, jak ukazuje následující příklad:</span><span class="sxs-lookup"><span data-stu-id="aeee2-217">However, the strings are not considered equal when you use ordinal comparison, as the following example shows:</span></span>
  
[!code-csharp[Conceptual.Strings.BestPractices#20](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.strings.bestpractices/cs/embeddednulls2.cs#20)]
[!code-vb[Conceptual.Strings.BestPractices#20](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.strings.bestpractices/vb/embeddednulls2.vb#20)]

<span data-ttu-id="aeee2-218">Další nejkonzervativnější přístup jsou posvěcená případová písmena.</span><span class="sxs-lookup"><span data-stu-id="aeee2-218">Case-insensitive ordinal comparisons are the next most conservative approach.</span></span> <span data-ttu-id="aeee2-219">Tato porovnání ignorují většinu krytů; například "windows" odpovídá "Windows".</span><span class="sxs-lookup"><span data-stu-id="aeee2-219">These comparisons ignore most casing; for example, "windows" matches "Windows".</span></span> <span data-ttu-id="aeee2-220">Při práci s znaky ASCII je <xref:System.StringComparison.Ordinal?displayProperty=nameWithType>tato zásada ekvivalentní , s tím rozdílem, že ignoruje obvyklé ascii caseing.</span><span class="sxs-lookup"><span data-stu-id="aeee2-220">When dealing with ASCII characters, this policy is equivalent to <xref:System.StringComparison.Ordinal?displayProperty=nameWithType>, except that it ignores the usual ASCII casing.</span></span> <span data-ttu-id="aeee2-221">Proto libovolný znak v [A, Z] (\u0041-\u005A) odpovídá odpovídajícímu znaku v [a,z] (\u0061-\007A).</span><span class="sxs-lookup"><span data-stu-id="aeee2-221">Therefore, any character in [A, Z] (\u0041-\u005A) matches the corresponding character in [a,z] (\u0061-\007A).</span></span> <span data-ttu-id="aeee2-222">Caseing mimo rozsah ASCII používá tabulky invariantní jazykové verze.</span><span class="sxs-lookup"><span data-stu-id="aeee2-222">Casing outside the ASCII range uses the invariant culture's tables.</span></span> <span data-ttu-id="aeee2-223">Proto následující porovnání:</span><span class="sxs-lookup"><span data-stu-id="aeee2-223">Therefore, the following comparison:</span></span>

[!code-csharp[Conceptual.Strings.BestPractices#4](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.strings.bestpractices/cs/comparison2.cs#4)]
[!code-vb[Conceptual.Strings.BestPractices#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.strings.bestpractices/vb/comparison2.vb#4)]

<span data-ttu-id="aeee2-224">je ekvivalentní (ale rychlejší než) toto srovnání:</span><span class="sxs-lookup"><span data-stu-id="aeee2-224">is equivalent to (but faster than) this comparison:</span></span>

[!code-csharp[Conceptual.Strings.BestPractices#5](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.strings.bestpractices/cs/comparison2.cs#5)]
[!code-vb[Conceptual.Strings.BestPractices#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.strings.bestpractices/vb/comparison2.vb#5)]

<span data-ttu-id="aeee2-225">Tato srovnání jsou stále velmi rychlá.</span><span class="sxs-lookup"><span data-stu-id="aeee2-225">These comparisons are still very fast.</span></span>

> [!NOTE]
> <span data-ttu-id="aeee2-226">Chování řetězce systému souborů, klíčů a hodnot registru a proměnných prostředí je nejlépe reprezentováno <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="aeee2-226">The string behavior of the file system, registry keys and values, and environment variables is best represented by <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="aeee2-227">Oba <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> a používat binární hodnoty přímo a jsou nejvhodnější pro porovnávání.</span><span class="sxs-lookup"><span data-stu-id="aeee2-227">Both <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> and <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> use the binary values directly, and are best suited for matching.</span></span> <span data-ttu-id="aeee2-228">Pokud si nejste jisti nastavením porovnání, použijte jednu z těchto dvou hodnot.</span><span class="sxs-lookup"><span data-stu-id="aeee2-228">When you are not sure about your comparison settings, use one of these two values.</span></span> <span data-ttu-id="aeee2-229">Protože však provádějí porovnání bajtů po bajtu, neseřazují se podle jazykového pořadí řazení (například podle anglického slovníku), ale podle binárního pořadí řazení.</span><span class="sxs-lookup"><span data-stu-id="aeee2-229">However, because they perform a byte-by-byte comparison, they do not sort by a linguistic sort order (like an English dictionary) but by a binary sort order.</span></span> <span data-ttu-id="aeee2-230">Výsledky mohou vypadat liché ve většině kontextů, pokud jsou zobrazeny uživatelům.</span><span class="sxs-lookup"><span data-stu-id="aeee2-230">The results may look odd in most contexts if displayed to users.</span></span>

<span data-ttu-id="aeee2-231">Ordinální sémantiku jsou <xref:System.String.Equals%2A?displayProperty=nameWithType> výchozí pro přetížení, <xref:System.StringComparison> které neobsahují argument (včetně operátoru rovnosti).</span><span class="sxs-lookup"><span data-stu-id="aeee2-231">Ordinal semantics are the default for <xref:System.String.Equals%2A?displayProperty=nameWithType> overloads that do not include a <xref:System.StringComparison> argument (including the equality operator).</span></span> <span data-ttu-id="aeee2-232">V každém případě doporučujeme volat přetížení, <xref:System.StringComparison> které má parametr.</span><span class="sxs-lookup"><span data-stu-id="aeee2-232">In any case, we recommend that you call an overload that has a <xref:System.StringComparison> parameter.</span></span>

### <a name="string-operations-that-use-the-invariant-culture"></a><span data-ttu-id="aeee2-233">řetězcové operace, které používají invariantní jazykovou verzi</span><span class="sxs-lookup"><span data-stu-id="aeee2-233">string operations that use the invariant culture</span></span>

<span data-ttu-id="aeee2-234">Porovnání s invariantní jazykovou <xref:System.Globalization.CultureInfo.CompareInfo%2A> verzi použít <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> vlastnost vrácenou statickou vlastnost.</span><span class="sxs-lookup"><span data-stu-id="aeee2-234">Comparisons with the invariant culture use the <xref:System.Globalization.CultureInfo.CompareInfo%2A> property returned by the static <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="aeee2-235">Toto chování je stejné ve všech systémech; překládá všechny znaky mimo jeho rozsah do co se domnívá, že jsou ekvivalentní invariantní znaky.</span><span class="sxs-lookup"><span data-stu-id="aeee2-235">This behavior is the same on all systems; it translates any characters outside its range into what it believes are equivalent invariant characters.</span></span> <span data-ttu-id="aeee2-236">Tato zásada může být užitečná pro udržování jedné sady chování řetězce napříč jazyky, ale často poskytuje neočekávané výsledky.</span><span class="sxs-lookup"><span data-stu-id="aeee2-236">This policy can be useful for maintaining one set of string behavior across cultures, but it often provides unexpected results.</span></span>

<span data-ttu-id="aeee2-237">Porovnání bez rozlišování velkých a malých písmen s invariantní jazykovou verzí používá statickou <xref:System.Globalization.CultureInfo.CompareInfo%2A> vlastnost vrácenou statickou <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> vlastností také pro porovnání informací.</span><span class="sxs-lookup"><span data-stu-id="aeee2-237">Case-insensitive comparisons with the invariant culture use the static <xref:System.Globalization.CultureInfo.CompareInfo%2A> property returned by the static <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> property for comparison information as well.</span></span> <span data-ttu-id="aeee2-238">Všechny rozdíly mezi písmeny mezi těmito přeložené znaky jsou ignorovány.</span><span class="sxs-lookup"><span data-stu-id="aeee2-238">Any case differences among these translated characters are ignored.</span></span>

<span data-ttu-id="aeee2-239">Porovnání, které <xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType> <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> používají a pracují stejně na řetězce ASCII.</span><span class="sxs-lookup"><span data-stu-id="aeee2-239">Comparisons that use <xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType> and <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> work identically on ASCII strings.</span></span> <span data-ttu-id="aeee2-240">Však <xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType> dělá jazyková rozhodnutí, která nemusí být vhodné pro řetězce, které musí být interpretovány jako sada bajtů.</span><span class="sxs-lookup"><span data-stu-id="aeee2-240">However, <xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType> makes linguistic decisions that might not be appropriate for strings that have to be interpreted as a set of bytes.</span></span> <span data-ttu-id="aeee2-241">Objekt `CultureInfo.InvariantCulture.CompareInfo` umožňuje <xref:System.String.Compare%2A> metoda interpretovat určité sady znaků jako ekvivalentní.</span><span class="sxs-lookup"><span data-stu-id="aeee2-241">The `CultureInfo.InvariantCulture.CompareInfo` object makes the <xref:System.String.Compare%2A> method interpret certain sets of characters as equivalent.</span></span> <span data-ttu-id="aeee2-242">Například následující ekvivalence je platná pod invariantní jazykovou verzi:</span><span class="sxs-lookup"><span data-stu-id="aeee2-242">For example, the following equivalence is valid under the invariant culture:</span></span>

<span data-ttu-id="aeee2-243">InvariantCulture: a + ° = å</span><span class="sxs-lookup"><span data-stu-id="aeee2-243">InvariantCulture: a + ̊ = å</span></span>

<span data-ttu-id="aeee2-244">Malé písmeno latinky A znak "a" (\u0061), který je vedle znaku DIASTRÁL NAD ZNAKEM "+ " " " (\u030a), je interpretován jako malé písmeno latinky A s kroužkem nad znakem "å" (\u00e5).</span><span class="sxs-lookup"><span data-stu-id="aeee2-244">The LATIN SMALL LETTER A character "a"  (\u0061), when it is next to the COMBINING RING ABOVE character "+ " ̊" (\u030a), is interpreted as the LATIN SMALL LETTER A WITH RING ABOVE character "å" (\u00e5).</span></span> <span data-ttu-id="aeee2-245">Jak ukazuje následující příklad, toto chování se liší od ordinálního porovnání.</span><span class="sxs-lookup"><span data-stu-id="aeee2-245">As the following example shows, this behavior differs from ordinal comparison.</span></span>

[!code-csharp[Conceptual.Strings.BestPractices#15](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.strings.bestpractices/cs/comparison3.cs#15)]
[!code-vb[Conceptual.Strings.BestPractices#15](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.strings.bestpractices/vb/comparison3.vb#15)]

<span data-ttu-id="aeee2-246">Při interpretaci názvů souborů, souborů cookie nebo čehokoli jiného, kde se může zobrazit kombinace, jako je "å", nebodinální porovnání stále nabízejí nejtransparentnější a nejpříhodnější chování.</span><span class="sxs-lookup"><span data-stu-id="aeee2-246">When interpreting file names, cookies, or anything else where a combination such as "å" can appear, ordinal comparisons still offer the most transparent and fitting behavior.</span></span>

<span data-ttu-id="aeee2-247">Po zralé úvaze má invariantní jazyková verze velmi málo vlastností, které jsou užitečné pro porovnání.</span><span class="sxs-lookup"><span data-stu-id="aeee2-247">On balance, the invariant culture has very few properties that make it useful for comparison.</span></span> <span data-ttu-id="aeee2-248">Provádí porovnání jazykově relevantním způsobem, který mu brání zaručit úplnou symbolickou ekvivalenci, ale není to volba pro zobrazení v jakékoli jazykové verzi.</span><span class="sxs-lookup"><span data-stu-id="aeee2-248">It does comparison in a linguistically relevant manner, which prevents it from guaranteeing full symbolic equivalence, but it is not the choice for display in any culture.</span></span> <span data-ttu-id="aeee2-249">Jedním z mála důvodů, proč použít <xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType> pro porovnání je zachovat objednaná data pro mezikulturní identické zobrazení.</span><span class="sxs-lookup"><span data-stu-id="aeee2-249">One of the few reasons to use <xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType> for comparison is to persist ordered data for a cross-culturally identical display.</span></span> <span data-ttu-id="aeee2-250">Například pokud velký datový soubor, který obsahuje seznam seřazených identifikátorů pro zobrazení doprovází aplikace, přidání do tohoto seznamu by vyžadovalo vložení s invariantním stylem řazení.</span><span class="sxs-lookup"><span data-stu-id="aeee2-250">For example, if a large data file that contains a list of sorted identifiers for display accompanies an application, adding to this list would require an insertion with invariant-style sorting.</span></span>

## <a name="choosing-a-stringcomparison-member-for-your-method-call"></a><span data-ttu-id="aeee2-251">Výběr člena StringComparison pro volání metody</span><span class="sxs-lookup"><span data-stu-id="aeee2-251">Choosing a StringComparison member for your method call</span></span>

<span data-ttu-id="aeee2-252">Následující tabulka popisuje mapování z kontextu sémantického řetězce na člen výčtu: <xref:System.StringComparison></span><span class="sxs-lookup"><span data-stu-id="aeee2-252">The following table outlines the mapping from semantic string context to a <xref:System.StringComparison> enumeration member:</span></span>

|<span data-ttu-id="aeee2-253">Data</span><span class="sxs-lookup"><span data-stu-id="aeee2-253">Data</span></span>|<span data-ttu-id="aeee2-254">Chování</span><span class="sxs-lookup"><span data-stu-id="aeee2-254">Behavior</span></span>|<span data-ttu-id="aeee2-255">Odpovídající System.StringComparison</span><span class="sxs-lookup"><span data-stu-id="aeee2-255">Corresponding System.StringComparison</span></span><br /><br /> <span data-ttu-id="aeee2-256">hodnota</span><span class="sxs-lookup"><span data-stu-id="aeee2-256">value</span></span>|
|----------|--------------|-----------------------------------------------------|
|<span data-ttu-id="aeee2-257">Vnitřní identifikátory rozlišující malá a velká písmena.</span><span class="sxs-lookup"><span data-stu-id="aeee2-257">Case-sensitive internal identifiers.</span></span><br /><br /> <span data-ttu-id="aeee2-258">Identifikátory rozlišující malá a velká písmena ve standardech, jako je XML a HTTP.</span><span class="sxs-lookup"><span data-stu-id="aeee2-258">Case-sensitive identifiers in standards such as XML and HTTP.</span></span><br /><br /> <span data-ttu-id="aeee2-259">Nastavení související se zabezpečením rozlišují malá a velká písmena.</span><span class="sxs-lookup"><span data-stu-id="aeee2-259">Case-sensitive security-related settings.</span></span>|<span data-ttu-id="aeee2-260">Nejazykový identifikátor, kde se přesně shodují bajty.</span><span class="sxs-lookup"><span data-stu-id="aeee2-260">A non-linguistic identifier, where bytes match exactly.</span></span>|<xref:System.StringComparison.Ordinal>|
|<span data-ttu-id="aeee2-261">Vnitřní identifikátory bez rozlišování velkých a malých písmen.</span><span class="sxs-lookup"><span data-stu-id="aeee2-261">Case-insensitive internal identifiers.</span></span><br /><br /> <span data-ttu-id="aeee2-262">Identifikátory bez rozlišování velkých a malých písmen ve standardech, jako je XML a HTTP.</span><span class="sxs-lookup"><span data-stu-id="aeee2-262">Case-insensitive identifiers in standards such as XML and HTTP.</span></span><br /><br /> <span data-ttu-id="aeee2-263">Cesty k souborům.</span><span class="sxs-lookup"><span data-stu-id="aeee2-263">File paths.</span></span><br /><br /> <span data-ttu-id="aeee2-264">Klíče a hodnoty registru.</span><span class="sxs-lookup"><span data-stu-id="aeee2-264">Registry keys and values.</span></span><br /><br /> <span data-ttu-id="aeee2-265">Proměnné prostředí.</span><span class="sxs-lookup"><span data-stu-id="aeee2-265">Environment variables.</span></span><br /><br /> <span data-ttu-id="aeee2-266">Identifikátory prostředků (například názvy popisovačů).</span><span class="sxs-lookup"><span data-stu-id="aeee2-266">Resource identifiers (for example, handle names).</span></span><br /><br /> <span data-ttu-id="aeee2-267">Nastavení související se zabezpečením bez rozlišování velkých a malých písmen.</span><span class="sxs-lookup"><span data-stu-id="aeee2-267">Case-insensitive security-related settings.</span></span>|<span data-ttu-id="aeee2-268">Nejazykový identifikátor, pokud je případ irelevantní; zejména data uložená ve většině systémových služeb systému Windows.</span><span class="sxs-lookup"><span data-stu-id="aeee2-268">A non-linguistic identifier, where case is irrelevant; especially data stored in most Windows system services.</span></span>|<xref:System.StringComparison.OrdinalIgnoreCase>|
|<span data-ttu-id="aeee2-269">Některé trvalá, jazykově relevantní data.</span><span class="sxs-lookup"><span data-stu-id="aeee2-269">Some persisted, linguistically relevant data.</span></span><br /><br /> <span data-ttu-id="aeee2-270">Zobrazení jazykových dat, která vyžadují pevné pořadí řazení.</span><span class="sxs-lookup"><span data-stu-id="aeee2-270">Display of linguistic data that requires a fixed sort order.</span></span>|<span data-ttu-id="aeee2-271">Kulturně agnostik data, která je stále jazykově relevantní.</span><span class="sxs-lookup"><span data-stu-id="aeee2-271">Culturally agnostic data that still is linguistically relevant.</span></span>|<xref:System.StringComparison.InvariantCulture><br /><br /> <span data-ttu-id="aeee2-272">-nebo-</span><span class="sxs-lookup"><span data-stu-id="aeee2-272">-or-</span></span><br /><br /> <xref:System.StringComparison.InvariantCultureIgnoreCase>|
|<span data-ttu-id="aeee2-273">Data zobrazená uživateli.</span><span class="sxs-lookup"><span data-stu-id="aeee2-273">Data displayed to the user.</span></span><br /><br /> <span data-ttu-id="aeee2-274">Většina uživatelských vstupů.</span><span class="sxs-lookup"><span data-stu-id="aeee2-274">Most user input.</span></span>|<span data-ttu-id="aeee2-275">Data, která vyžadují místní jazykové zvyky.</span><span class="sxs-lookup"><span data-stu-id="aeee2-275">Data that requires local linguistic customs.</span></span>|<xref:System.StringComparison.CurrentCulture><br /><br /> <span data-ttu-id="aeee2-276">-nebo-</span><span class="sxs-lookup"><span data-stu-id="aeee2-276">-or-</span></span><br /><br /> <xref:System.StringComparison.CurrentCultureIgnoreCase>|

## <a name="common-string-comparison-methods-in-net"></a><span data-ttu-id="aeee2-277">Běžné metody porovnání řetězců v rozhraní .NET</span><span class="sxs-lookup"><span data-stu-id="aeee2-277">Common string comparison methods in .NET</span></span>

<span data-ttu-id="aeee2-278">Následující části popisují metody, které se nejčastěji používají pro porovnání řetězců.</span><span class="sxs-lookup"><span data-stu-id="aeee2-278">The following sections describe the methods that are most commonly used for string comparison.</span></span>

### <a name="stringcompare"></a><span data-ttu-id="aeee2-279">String.compare</span><span class="sxs-lookup"><span data-stu-id="aeee2-279">String.Compare</span></span>

<span data-ttu-id="aeee2-280">Výchozí interpretace: <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="aeee2-280">Default interpretation: <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="aeee2-281">Jako operace nejvíce centrální interpretace řetězce, všechny instance těchto volání metody by měly být zkoumány k určení, zda řetězce by měly být interpretovány podle aktuální jazykové verze nebo disociované od jazykové verze (symbolicky).</span><span class="sxs-lookup"><span data-stu-id="aeee2-281">As the operation most central to string interpretation, all instances of these method calls should be examined to determine whether strings should be interpreted according to the current culture, or dissociated from the culture (symbolically).</span></span> <span data-ttu-id="aeee2-282">Obvykle je to druhé a <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> místo toho by mělo být použito porovnání.</span><span class="sxs-lookup"><span data-stu-id="aeee2-282">Typically, it is the latter, and a <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> comparison should be used instead.</span></span>

<span data-ttu-id="aeee2-283">Třída, <xref:System.Globalization.CompareInfo?displayProperty=nameWithType> která je vrácena <xref:System.Globalization.CultureInfo.CompareInfo%2A?displayProperty=nameWithType> vlastností, <xref:System.Globalization.CompareInfo.Compare%2A> také obsahuje metodu, která poskytuje velký počet možností párování (řadové, ignorování prázdného místa, <xref:System.Globalization.CompareOptions> ignorování typu kana a tak dále) pomocí výčtu příznaku.</span><span class="sxs-lookup"><span data-stu-id="aeee2-283">The <xref:System.Globalization.CompareInfo?displayProperty=nameWithType> class, which is returned by the <xref:System.Globalization.CultureInfo.CompareInfo%2A?displayProperty=nameWithType> property, also includes a <xref:System.Globalization.CompareInfo.Compare%2A> method that provides a large number of matching options (ordinal, ignoring white space, ignoring kana type, and so on) by means of the <xref:System.Globalization.CompareOptions> flag enumeration.</span></span>

### <a name="stringcompareto"></a><span data-ttu-id="aeee2-284">String.CompareTo</span><span class="sxs-lookup"><span data-stu-id="aeee2-284">String.CompareTo</span></span>

<span data-ttu-id="aeee2-285">Výchozí interpretace: <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="aeee2-285">Default interpretation: <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="aeee2-286">Tato metoda aktuálně nenabízí přetížení, které <xref:System.StringComparison> určuje typ.</span><span class="sxs-lookup"><span data-stu-id="aeee2-286">This method does not currently offer an overload that specifies a <xref:System.StringComparison> type.</span></span> <span data-ttu-id="aeee2-287">Obvykle je možné převést tuto <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=nameWithType> metodu na doporučenou formu.</span><span class="sxs-lookup"><span data-stu-id="aeee2-287">It is usually possible to convert this method to the recommended <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=nameWithType> form.</span></span>

<span data-ttu-id="aeee2-288">Typy, které <xref:System.IComparable> <xref:System.IComparable%601> implementují a rozhraní implementovat tuto metodu.</span><span class="sxs-lookup"><span data-stu-id="aeee2-288">Types that implement the <xref:System.IComparable> and <xref:System.IComparable%601> interfaces implement this method.</span></span> <span data-ttu-id="aeee2-289">Vzhledem k tomu, že <xref:System.StringComparison> nenabízí možnost parametru, implementace <xref:System.StringComparer> typů často umožňují uživateli zadat v jejich konstruktoru.</span><span class="sxs-lookup"><span data-stu-id="aeee2-289">Because it does not offer the option of a <xref:System.StringComparison> parameter, implementing types often let the user specify a <xref:System.StringComparer> in their constructor.</span></span> <span data-ttu-id="aeee2-290">Následující příklad definuje `FileName` třídu, jejíž <xref:System.StringComparer> konstruktor třídy obsahuje parametr.</span><span class="sxs-lookup"><span data-stu-id="aeee2-290">The following example defines a `FileName` class whose class constructor includes a <xref:System.StringComparer> parameter.</span></span> <span data-ttu-id="aeee2-291">Tento <xref:System.StringComparer> objekt se pak `FileName.CompareTo` používá v metodě.</span><span class="sxs-lookup"><span data-stu-id="aeee2-291">This <xref:System.StringComparer> object is then used in the `FileName.CompareTo` method.</span></span>

[!code-csharp[Conceptual.Strings.BestPractices#6](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.strings.bestpractices/cs/api1.cs#6)]
[!code-vb[Conceptual.Strings.BestPractices#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.strings.bestpractices/vb/api1.vb#6)]

### <a name="stringequals"></a><span data-ttu-id="aeee2-292">String.Equals</span><span class="sxs-lookup"><span data-stu-id="aeee2-292">String.Equals</span></span>

<span data-ttu-id="aeee2-293">Výchozí interpretace: <xref:System.StringComparison.Ordinal?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="aeee2-293">Default interpretation: <xref:System.StringComparison.Ordinal?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="aeee2-294">Třída <xref:System.String> umožňuje testovat rovnost voláním přetížení statické metody <xref:System.String.Equals%2A> nebo instance nebo pomocí operátoru statické rovnosti.</span><span class="sxs-lookup"><span data-stu-id="aeee2-294">The <xref:System.String> class lets you test for equality by calling either the static or instance <xref:System.String.Equals%2A> method overloads, or by using the static equality operator.</span></span> <span data-ttu-id="aeee2-295">Přetížení a operátor použití ordinální porovnání ve výchozím nastavení.</span><span class="sxs-lookup"><span data-stu-id="aeee2-295">The overloads and operator use ordinal comparison by default.</span></span> <span data-ttu-id="aeee2-296">Však stále doporučujeme volat přetížení, které <xref:System.StringComparison> explicitně určuje typ i v případě, že chcete provést ordinální porovnání; To usnadňuje hledání kódu pro určitý řetězec interpretace.</span><span class="sxs-lookup"><span data-stu-id="aeee2-296">However, we still recommend that you call an overload that explicitly specifies the <xref:System.StringComparison> type even if you want to perform an ordinal comparison; this makes it easier to search code for a certain string interpretation.</span></span>

### <a name="stringtoupper-and-stringtolower"></a><span data-ttu-id="aeee2-297">String.ToUpper a String.ToLower</span><span class="sxs-lookup"><span data-stu-id="aeee2-297">String.ToUpper and String.ToLower</span></span>

<span data-ttu-id="aeee2-298">Výchozí interpretace: <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="aeee2-298">Default interpretation: <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="aeee2-299">Při použití těchto metod byste měli být opatrní, protože vynucení řetězce na velká nebo malá písmena se často používá jako malá normalizace pro porovnání řetězců bez ohledu na velká písmena.</span><span class="sxs-lookup"><span data-stu-id="aeee2-299">You should be careful when you use these methods, because forcing a string to a uppercase or lowercase is often used as a small normalization for comparing strings regardless of case.</span></span> <span data-ttu-id="aeee2-300">Pokud ano, zvažte použití porovnání bez rozlišování velkých a malých písmen.</span><span class="sxs-lookup"><span data-stu-id="aeee2-300">If so, consider using a case-insensitive comparison.</span></span>

<span data-ttu-id="aeee2-301">A <xref:System.String.ToUpperInvariant%2A?displayProperty=nameWithType> <xref:System.String.ToLowerInvariant%2A?displayProperty=nameWithType> metody jsou také k dispozici.</span><span class="sxs-lookup"><span data-stu-id="aeee2-301">The <xref:System.String.ToUpperInvariant%2A?displayProperty=nameWithType> and <xref:System.String.ToLowerInvariant%2A?displayProperty=nameWithType> methods are also available.</span></span> <span data-ttu-id="aeee2-302"><xref:System.String.ToUpperInvariant%2A>je standardní způsob normalizace případu.</span><span class="sxs-lookup"><span data-stu-id="aeee2-302"><xref:System.String.ToUpperInvariant%2A> is the standard way to normalize case.</span></span> <span data-ttu-id="aeee2-303">Porovnání provedené <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> pomocí jsou behaviorálně složení dvou <xref:System.String.ToUpperInvariant%2A> volání: volání na oba argumenty řetězce a provedení porovnání pomocí <xref:System.StringComparison.Ordinal?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="aeee2-303">Comparisons made using <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> are behaviorally the composition of two calls: calling <xref:System.String.ToUpperInvariant%2A> on both string arguments, and doing a comparison using <xref:System.StringComparison.Ordinal?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="aeee2-304">Přetížení jsou také k dispozici pro převod na velká a malá <xref:System.Globalization.CultureInfo> písmena v určité jazykové verzi předáním objektu, který představuje tuto jazykovou verzi metodě.</span><span class="sxs-lookup"><span data-stu-id="aeee2-304">Overloads are also available for converting to uppercase and lowercase in a specific culture, by passing a <xref:System.Globalization.CultureInfo> object that represents that culture to the method.</span></span>

### <a name="chartoupper-and-chartolower"></a><span data-ttu-id="aeee2-305">Char.ToUpper a Char.ToLower</span><span class="sxs-lookup"><span data-stu-id="aeee2-305">Char.ToUpper and Char.ToLower</span></span>

<span data-ttu-id="aeee2-306">Výchozí interpretace: <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="aeee2-306">Default interpretation: <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="aeee2-307">Tyto metody fungují podobně <xref:System.String.ToUpper%2A?displayProperty=nameWithType> <xref:System.String.ToLower%2A?displayProperty=nameWithType> jako metody a popsané v předchozí části.</span><span class="sxs-lookup"><span data-stu-id="aeee2-307">These methods work similarly to the <xref:System.String.ToUpper%2A?displayProperty=nameWithType> and <xref:System.String.ToLower%2A?displayProperty=nameWithType> methods described in the previous section.</span></span>

### <a name="stringstartswith-and-stringendswith"></a><span data-ttu-id="aeee2-308">String.StartsWith a String.EndsWith</span><span class="sxs-lookup"><span data-stu-id="aeee2-308">String.StartsWith and String.EndsWith</span></span>

<span data-ttu-id="aeee2-309">Výchozí interpretace: <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="aeee2-309">Default interpretation: <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="aeee2-310">Ve výchozím nastavení obě tyto metody provést porovnání zjitřující jazykovou verzi.</span><span class="sxs-lookup"><span data-stu-id="aeee2-310">By default, both of these methods perform a culture-sensitive comparison.</span></span>

### <a name="stringindexof-and-stringlastindexof"></a><span data-ttu-id="aeee2-311">String.IndexOf a String.LastIndexOf</span><span class="sxs-lookup"><span data-stu-id="aeee2-311">String.IndexOf and String.LastIndexOf</span></span>

<span data-ttu-id="aeee2-312">Výchozí interpretace: <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="aeee2-312">Default interpretation: <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="aeee2-313">Je nedostatek konzistence v jak výchozí přetížení těchto metod provádět porovnání.</span><span class="sxs-lookup"><span data-stu-id="aeee2-313">There is a lack of consistency in how the default overloads of these methods perform comparisons.</span></span> <span data-ttu-id="aeee2-314">Všechny <xref:System.String.IndexOf%2A?displayProperty=nameWithType> <xref:System.String.LastIndexOf%2A?displayProperty=nameWithType> a metody, <xref:System.Char> které obsahují parametr provést řadové <xref:System.String.IndexOf%2A?displayProperty=nameWithType> porovnání, ale výchozí a <xref:System.String.LastIndexOf%2A?displayProperty=nameWithType> metody, které obsahují <xref:System.String> parametr provést porovnání zdůvodu jazykové verze.</span><span class="sxs-lookup"><span data-stu-id="aeee2-314">All <xref:System.String.IndexOf%2A?displayProperty=nameWithType> and <xref:System.String.LastIndexOf%2A?displayProperty=nameWithType> methods that include a <xref:System.Char> parameter perform an ordinal comparison, but the default <xref:System.String.IndexOf%2A?displayProperty=nameWithType> and <xref:System.String.LastIndexOf%2A?displayProperty=nameWithType> methods that include a <xref:System.String> parameter perform a culture-sensitive comparison.</span></span>

<span data-ttu-id="aeee2-315">Pokud zavoláte <xref:System.String.IndexOf%28System.String%29?displayProperty=nameWithType> <xref:System.String.LastIndexOf%28System.String%29?displayProperty=nameWithType> metodu or a předáte ji řetězec, který se vykreslo v aktuální instanci, doporučujeme volat přetížení, které explicitně určuje <xref:System.StringComparison> typ.</span><span class="sxs-lookup"><span data-stu-id="aeee2-315">If you call the <xref:System.String.IndexOf%28System.String%29?displayProperty=nameWithType> or <xref:System.String.LastIndexOf%28System.String%29?displayProperty=nameWithType> method and pass it a string to locate in the current instance, we recommend that you call an overload that explicitly specifies the <xref:System.StringComparison> type.</span></span> <span data-ttu-id="aeee2-316">Přetížení, které obsahují <xref:System.Char> argument neumožňují zadat <xref:System.StringComparison> typ.</span><span class="sxs-lookup"><span data-stu-id="aeee2-316">The overloads that include a <xref:System.Char> argument do not allow you to specify a <xref:System.StringComparison> type.</span></span>

## <a name="methods-that-perform-string-comparison-indirectly"></a><span data-ttu-id="aeee2-317">Metody, které provádějí porovnání řetězců nepřímo</span><span class="sxs-lookup"><span data-stu-id="aeee2-317">Methods that perform string comparison indirectly</span></span>

<span data-ttu-id="aeee2-318">Některé metody bez řetězce, které mají porovnání <xref:System.StringComparer> řetězců jako centrální operace použít typ.</span><span class="sxs-lookup"><span data-stu-id="aeee2-318">Some non-string methods that have string comparison as a central operation use the <xref:System.StringComparer> type.</span></span> <span data-ttu-id="aeee2-319">Třída <xref:System.StringComparer> obsahuje šest statických <xref:System.StringComparer> vlastností, které vracejí instance, jejichž <xref:System.StringComparer.Compare%2A?displayProperty=nameWithType> metody provádějí následující typy porovnání řetězců:</span><span class="sxs-lookup"><span data-stu-id="aeee2-319">The <xref:System.StringComparer> class includes six static properties that return <xref:System.StringComparer> instances whose <xref:System.StringComparer.Compare%2A?displayProperty=nameWithType> methods perform the following types of string comparisons:</span></span>

- <span data-ttu-id="aeee2-320">Porovnání řetězců citlivých na jazykovou verzi pomocí aktuální jazykové verze.</span><span class="sxs-lookup"><span data-stu-id="aeee2-320">Culture-sensitive string comparisons using the current culture.</span></span> <span data-ttu-id="aeee2-321">Tento <xref:System.StringComparer> objekt je <xref:System.StringComparer.CurrentCulture%2A?displayProperty=nameWithType> vrácenvlastností.</span><span class="sxs-lookup"><span data-stu-id="aeee2-321">This <xref:System.StringComparer> object is returned by the <xref:System.StringComparer.CurrentCulture%2A?displayProperty=nameWithType> property.</span></span>
- <span data-ttu-id="aeee2-322">Porovnání bez rozlišování velkých a malých písmen pomocí aktuální jazykové verze.</span><span class="sxs-lookup"><span data-stu-id="aeee2-322">Case-insensitive comparisons using the current culture.</span></span> <span data-ttu-id="aeee2-323">Tento <xref:System.StringComparer> objekt je <xref:System.StringComparer.CurrentCultureIgnoreCase%2A?displayProperty=nameWithType> vrácenvlastností.</span><span class="sxs-lookup"><span data-stu-id="aeee2-323">This <xref:System.StringComparer> object is returned by the <xref:System.StringComparer.CurrentCultureIgnoreCase%2A?displayProperty=nameWithType> property.</span></span>
- <span data-ttu-id="aeee2-324">Porovnání necitlivé na jazykovou verzi pomocí pravidla porovnání slov invariantní jazykové verze.</span><span class="sxs-lookup"><span data-stu-id="aeee2-324">Culture-insensitive comparisons using the word comparison rules of the invariant culture.</span></span> <span data-ttu-id="aeee2-325">Tento <xref:System.StringComparer> objekt je <xref:System.StringComparer.InvariantCulture%2A?displayProperty=nameWithType> vrácenvlastností.</span><span class="sxs-lookup"><span data-stu-id="aeee2-325">This <xref:System.StringComparer> object is returned by the <xref:System.StringComparer.InvariantCulture%2A?displayProperty=nameWithType> property.</span></span>
- <span data-ttu-id="aeee2-326">Případ nerozlišující a necitlivé jazyky porovnání pomocí pravidla porovnání slov invariantní jazykové verze.</span><span class="sxs-lookup"><span data-stu-id="aeee2-326">Case-insensitive and culture-insensitive comparisons using the word comparison rules of the invariant culture.</span></span> <span data-ttu-id="aeee2-327">Tento <xref:System.StringComparer> objekt je <xref:System.StringComparer.InvariantCultureIgnoreCase%2A?displayProperty=nameWithType> vrácenvlastností.</span><span class="sxs-lookup"><span data-stu-id="aeee2-327">This <xref:System.StringComparer> object is returned by the <xref:System.StringComparer.InvariantCultureIgnoreCase%2A?displayProperty=nameWithType> property.</span></span>
- <span data-ttu-id="aeee2-328">Ordinální srovnání.</span><span class="sxs-lookup"><span data-stu-id="aeee2-328">Ordinal comparison.</span></span> <span data-ttu-id="aeee2-329">Tento <xref:System.StringComparer> objekt je <xref:System.StringComparer.Ordinal%2A?displayProperty=nameWithType> vrácenvlastností.</span><span class="sxs-lookup"><span data-stu-id="aeee2-329">This <xref:System.StringComparer> object is returned by the <xref:System.StringComparer.Ordinal%2A?displayProperty=nameWithType> property.</span></span>
- <span data-ttu-id="aeee2-330">Porovnání ordinálního porovnání bez rozlišování velkých a malých písmen.</span><span class="sxs-lookup"><span data-stu-id="aeee2-330">Case-insensitive ordinal comparison.</span></span> <span data-ttu-id="aeee2-331">Tento <xref:System.StringComparer> objekt je <xref:System.StringComparer.OrdinalIgnoreCase%2A?displayProperty=nameWithType> vrácenvlastností.</span><span class="sxs-lookup"><span data-stu-id="aeee2-331">This <xref:System.StringComparer> object is returned by the <xref:System.StringComparer.OrdinalIgnoreCase%2A?displayProperty=nameWithType> property.</span></span>

### <a name="arraysort-and-arraybinarysearch"></a><span data-ttu-id="aeee2-332">Array.Sort a Array.BinarySearch</span><span class="sxs-lookup"><span data-stu-id="aeee2-332">Array.Sort and Array.BinarySearch</span></span>

<span data-ttu-id="aeee2-333">Výchozí interpretace: <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="aeee2-333">Default interpretation: <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="aeee2-334">Při ukládání dat v kolekci nebo čtení trvalých dat ze souboru nebo databáze do kolekce, přepínání aktuální jazykové verze může zneplatnit invariants v kolekci.</span><span class="sxs-lookup"><span data-stu-id="aeee2-334">When you store any data in a collection, or read persisted data from a file or database into a collection, switching the current culture can invalidate the invariants in the collection.</span></span> <span data-ttu-id="aeee2-335">Metoda <xref:System.Array.BinarySearch%2A?displayProperty=nameWithType> předpokládá, že prvky v poli, které mají být prohledány jsou již seřazeny.</span><span class="sxs-lookup"><span data-stu-id="aeee2-335">The <xref:System.Array.BinarySearch%2A?displayProperty=nameWithType> method assumes that the elements in the array to be searched are already sorted.</span></span> <span data-ttu-id="aeee2-336">Chcete-li seřadit libovolný <xref:System.Array.Sort%2A?displayProperty=nameWithType> prvek řetězce <xref:System.String.Compare%2A?displayProperty=nameWithType> v poli, metoda volá metodu k objednání jednotlivých prvků.</span><span class="sxs-lookup"><span data-stu-id="aeee2-336">To sort any string element in the array, the <xref:System.Array.Sort%2A?displayProperty=nameWithType> method calls the <xref:System.String.Compare%2A?displayProperty=nameWithType> method to order individual elements.</span></span> <span data-ttu-id="aeee2-337">Použití porovnání citlivé na jazykovou verzi může být nebezpečné, pokud se změní jazyková verze mezi časem řazení pole a jeho obsahem.</span><span class="sxs-lookup"><span data-stu-id="aeee2-337">Using a culture-sensitive comparer can be dangerous if the culture changes between the time that the array is sorted and its contents are searched.</span></span> <span data-ttu-id="aeee2-338">Například v následujícím kódu úložiště a načítání pracovat na porovnávání, který `Thread.CurrentThread.CurrentCulture` je poskytován implicitně vlastnost.</span><span class="sxs-lookup"><span data-stu-id="aeee2-338">For example, in the following code, storage and retrieval operate on the comparer that is provided implicitly by the `Thread.CurrentThread.CurrentCulture` property.</span></span> <span data-ttu-id="aeee2-339">Pokud jazyková verze může `StoreNames` změnit `DoesNameExist`mezi volání a , a zejména pokud obsah pole jsou trvalé někde mezi dvěma volání metody, binární hledání může selhat.</span><span class="sxs-lookup"><span data-stu-id="aeee2-339">If the culture can change between the calls to `StoreNames` and `DoesNameExist`, and especially if the array contents are persisted somewhere between the two method calls, the binary search may fail.</span></span>

[!code-csharp[Conceptual.Strings.BestPractices#7](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.strings.bestpractices/cs/indirect1.cs#7)]
 [!code-vb[Conceptual.Strings.BestPractices#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.strings.bestpractices/vb/indirect1.vb#7)]

<span data-ttu-id="aeee2-340">Doporučená varianta se zobrazí v následujícím příkladu, který používá stejnou řadovou (necitlivou) metodu porovnání k řazení a vyhledávání pole.</span><span class="sxs-lookup"><span data-stu-id="aeee2-340">A recommended variation appears in the following example, which uses the same ordinal (culture-insensitive) comparison method both to sort and to search the array.</span></span> <span data-ttu-id="aeee2-341">Kód změny se projeví v `Line A` řádcích označených a `Line B` ve dvou příkladech.</span><span class="sxs-lookup"><span data-stu-id="aeee2-341">The change code is reflected in the lines labeled `Line A` and `Line B` in the two examples.</span></span>

[!code-csharp[Conceptual.Strings.BestPractices#8](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.strings.bestpractices/cs/indirect1.cs#8)]
[!code-vb[Conceptual.Strings.BestPractices#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.strings.bestpractices/vb/indirect1.vb#8)]

<span data-ttu-id="aeee2-342">Pokud tato data jsou trvalé a přesunuty napříč jazykovými verzemi a řazení se <xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType>používá k prezentaci těchto dat uživateli, můžete zvážit použití , který pracuje jazykově pro lepší výstup uživatele, ale není ovlivněn a změny v jazykové verzi.</span><span class="sxs-lookup"><span data-stu-id="aeee2-342">If this data is persisted and moved across cultures, and sorting is used to present this data to the user, you might consider using <xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType>, which operates linguistically for better user output but is unaffected by changes in culture.</span></span> <span data-ttu-id="aeee2-343">Následující příklad upravuje dva předchozí příklady pro použití invariantní jazykové verze pro řazení a vyhledávání pole.</span><span class="sxs-lookup"><span data-stu-id="aeee2-343">The following example modifies the two previous examples to use the invariant culture for sorting and searching the array.</span></span>

[!code-csharp[Conceptual.Strings.BestPractices#9](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.strings.bestpractices/cs/indirect1.cs#9)]
[!code-vb[Conceptual.Strings.BestPractices#9](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.strings.bestpractices/vb/indirect1.vb#9)]

### <a name="collections-example-hashtable-constructor"></a><span data-ttu-id="aeee2-344">Příklad kolekcí: Hashtable konstruktor</span><span class="sxs-lookup"><span data-stu-id="aeee2-344">Collections example: Hashtable constructor</span></span>

<span data-ttu-id="aeee2-345">Řetězce hash poskytuje druhý příklad operace, která je ovlivněna způsobem, ve kterém jsou porovnány řetězce.</span><span class="sxs-lookup"><span data-stu-id="aeee2-345">Hashing strings provides a second example of an operation that is affected by the way in which strings are compared.</span></span>

<span data-ttu-id="aeee2-346">Následující příklad inkoniuje <xref:System.Collections.Hashtable> objekt <xref:System.StringComparer> předáním objektu, <xref:System.StringComparer.OrdinalIgnoreCase%2A?displayProperty=nameWithType> který je vrácen vlastností.</span><span class="sxs-lookup"><span data-stu-id="aeee2-346">The following example instantiates a <xref:System.Collections.Hashtable> object by passing it the <xref:System.StringComparer> object that is returned by the <xref:System.StringComparer.OrdinalIgnoreCase%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="aeee2-347">Vzhledem <xref:System.StringComparer> k tomu, <xref:System.StringComparer> že třída, která je odvozena z implementuje <xref:System.Collections.IEqualityComparer> rozhraní, jeho <xref:System.Collections.IEqualityComparer.GetHashCode%2A> metoda se používá k výpočtu hash kód řetězců v tabulce hash.</span><span class="sxs-lookup"><span data-stu-id="aeee2-347">Because a class <xref:System.StringComparer> that is derived from <xref:System.StringComparer> implements the <xref:System.Collections.IEqualityComparer> interface, its <xref:System.Collections.IEqualityComparer.GetHashCode%2A> method is used to compute the hash code of strings in the hash table.</span></span>

[!code-csharp[Conceptual.Strings.BestPractices#10](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.strings.bestpractices/cs/indirect2.cs#10)]
[!code-vb[Conceptual.Strings.BestPractices#10](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.strings.bestpractices/vb/indirect2.vb#10)]

## <a name="displaying-and-persisting-formatted-data"></a><span data-ttu-id="aeee2-348">Zobrazení a zachování formátovaných dat</span><span class="sxs-lookup"><span data-stu-id="aeee2-348">Displaying and persisting formatted data</span></span>

<span data-ttu-id="aeee2-349">Pokud uživatelům zobrazíte neřetězcová data, jako jsou čísla a data a časy, naformátujte je pomocí kulturního nastavení uživatele.</span><span class="sxs-lookup"><span data-stu-id="aeee2-349">When you display non-string data such as numbers and dates and times to users, format them by using the user's cultural settings.</span></span> <span data-ttu-id="aeee2-350">Ve výchozím nastavení používají všichni následující jazyková verze aktuálního vlákna při operacích formátování:</span><span class="sxs-lookup"><span data-stu-id="aeee2-350">By default, the following all use the current thread culture in formatting operations:</span></span>

- <span data-ttu-id="aeee2-351">Interpolované řetězce podporované kompilátory [jazyka C#](../../csharp/language-reference/tokens/interpolated.md) a [Visual Basic.](../../visual-basic/programming-guide/language-features/strings/interpolated-strings.md)</span><span class="sxs-lookup"><span data-stu-id="aeee2-351">Interpolated strings supported by the [C#](../../csharp/language-reference/tokens/interpolated.md) and [Visual Basic](../../visual-basic/programming-guide/language-features/strings/interpolated-strings.md) compilers.</span></span>
- <span data-ttu-id="aeee2-352">Operace zřetězení řetězců, které používají operátory zřetězení <xref:System.String.Concat%2A?displayProperty=nameWithType> jazyka [C#](../../csharp/language-reference/operators/addition-operator.md#string-concatenation) nebo Visual [Basic](../../visual-basic/programming-guide/language-features/operators-and-expressions/concatenation-operators.md ) nebo které přímo volají metodu.</span><span class="sxs-lookup"><span data-stu-id="aeee2-352">String concatenation operations that use the [C#](../../csharp/language-reference/operators/addition-operator.md#string-concatenation) or [Visual Basic](../../visual-basic/programming-guide/language-features/operators-and-expressions/concatenation-operators.md ) concatenation operators or that call the <xref:System.String.Concat%2A?displayProperty=nameWithType> method directly.</span></span>
- <span data-ttu-id="aeee2-353">Metoda. <xref:System.String.Format%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="aeee2-353">The <xref:System.String.Format%2A?displayProperty=nameWithType> method.</span></span>
- <span data-ttu-id="aeee2-354">Metody `ToString` číselných typů a typy data a času.</span><span class="sxs-lookup"><span data-stu-id="aeee2-354">The `ToString` methods of the numeric types and the date and time types.</span></span>

<span data-ttu-id="aeee2-355">Chcete-li explicitně určit, že řetězec by měl být formátován pomocí konvencí určené jazykové verze nebo [invariantní jazykové verze](xref:System.Globalization.CultureInfo.InvariantCulture), můžete provést následující kroky:</span><span class="sxs-lookup"><span data-stu-id="aeee2-355">To explicitly specify that a string should be formatted by using the conventions of a designated culture or the [invariant culture](xref:System.Globalization.CultureInfo.InvariantCulture), you can do the following:</span></span>

- <span data-ttu-id="aeee2-356">Při použití <xref:System.String.Format%2A?displayProperty=nameWithType> `ToString` metody a, volání přetížení, který `provider` má parametr, jako <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> je <xref:System.Globalization.CultureInfo> například <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType> nebo <xref:System.DateTime.ToString%28System.IFormatProvider%29?displayProperty=nameWithType>, a <xref:System.Globalization.CultureInfo.InvariantCulture?displayProperty=nameWithType> předat vlastnost, instance, která představuje požadovanou jazykovou verzi nebo vlastnost.</span><span class="sxs-lookup"><span data-stu-id="aeee2-356">When using the <xref:System.String.Format%2A?displayProperty=nameWithType> and `ToString` methods, call an overload that has a `provider` parameter, such as <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType> or <xref:System.DateTime.ToString%28System.IFormatProvider%29?displayProperty=nameWithType>, and pass it the <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> property, a <xref:System.Globalization.CultureInfo> instance that represents the desired culture, or the <xref:System.Globalization.CultureInfo.InvariantCulture?displayProperty=nameWithType> property.</span></span>

- <span data-ttu-id="aeee2-357">Pro zřetězení řetězce nepovolte kompilátoru provádět žádné implicitní převody.</span><span class="sxs-lookup"><span data-stu-id="aeee2-357">For string concatenation, do not allow the compiler to perform any implicit conversions.</span></span> <span data-ttu-id="aeee2-358">Místo toho proveďte explicitní `ToString` převod voláním `provider` přetížení, které má parametr.</span><span class="sxs-lookup"><span data-stu-id="aeee2-358">Instead, perform an explicit conversion by calling a `ToString` overload that has a `provider` parameter.</span></span> <span data-ttu-id="aeee2-359">Například kompilátor implicitně používá aktuální jazykovou <xref:System.Double> verzi při převodu hodnoty na řetězec v následujícím kódu jazyka C#:</span><span class="sxs-lookup"><span data-stu-id="aeee2-359">For example, the compiler implicitly uses the current culture when converting a <xref:System.Double> value to a string in the following C# code:</span></span>

  [!code-csharp[Implicit String Conversion](~/samples/snippets/standard/base-types/string-practices/cs/tostring.cs#1)]

  <span data-ttu-id="aeee2-360">Místo toho můžete explicitně určit jazykovou verzi, jejíž formátování <xref:System.Double.ToString(System.IFormatProvider)?displayProperty=nameWithType> konvence se používají v převodu voláním metody, jako následující kód Jazyka C#:</span><span class="sxs-lookup"><span data-stu-id="aeee2-360">Instead, you can explicitly specify the culture whose formatting conventions are used in the conversion by calling the <xref:System.Double.ToString(System.IFormatProvider)?displayProperty=nameWithType> method, as the following C# code does:</span></span>

  [!code-csharp[Explicit String Conversion](~/samples/snippets/standard/base-types/string-practices/cs/tostring.cs#2)]

- <span data-ttu-id="aeee2-361">Pro interpolaci řetězců, nikoli přiřazení interpolovaného <xref:System.String> řetězce k instanci, přiřaďte ji k . <xref:System.FormattableString></span><span class="sxs-lookup"><span data-stu-id="aeee2-361">For string interpolation, rather than assigning an interpolated string to a <xref:System.String> instance, assign it to a <xref:System.FormattableString>.</span></span> <span data-ttu-id="aeee2-362">Potom můžete volat <xref:System.FormattableString.ToString?displayProperty=nameWithType> jeho metoda vytvořit výsledný řetězec, který odráží konvence aktuální jazykové <xref:System.FormattableString.ToString(System.IFormatProvider)?displayProperty=nameWithType> verze, nebo můžete volat metodu k vytvoření výsledný řetězec, který odráží konvence zadané jazykové verze.</span><span class="sxs-lookup"><span data-stu-id="aeee2-362">You can then call its <xref:System.FormattableString.ToString?displayProperty=nameWithType> method produce a result string that reflects the conventions of the current culture, or you can call the <xref:System.FormattableString.ToString(System.IFormatProvider)?displayProperty=nameWithType> method to produce a result string that reflects the conventions of a specified culture.</span></span> <span data-ttu-id="aeee2-363">Formátovatelný řetězec můžete také předat <xref:System.FormattableString.Invariant%2A?displayProperty=nameWithType> statické metodě a vytvořit výsledný řetězec, který odráží konvence invariantní jazykové verze.</span><span class="sxs-lookup"><span data-stu-id="aeee2-363">You can also pass the formattable string to the static <xref:System.FormattableString.Invariant%2A?displayProperty=nameWithType> method to produce a result string that reflects the conventions of the invariant culture.</span></span> <span data-ttu-id="aeee2-364">Tento postup znázorňuje následující příklad.</span><span class="sxs-lookup"><span data-stu-id="aeee2-364">The following example illustrates this approach.</span></span> <span data-ttu-id="aeee2-365">(Výstup z příkladu odráží aktuální jazykovou verzi en US.)</span><span class="sxs-lookup"><span data-stu-id="aeee2-365">(The output from the example reflects a current culture of en-US.)</span></span>

  [!code-csharp[String interpolation](~/samples/snippets/standard/base-types/string-practices/cs/formattable.cs)]
  [!code-vb[String interpolation](~/samples/snippets/standard/base-types/string-practices/vb/formattable.vb)]

<span data-ttu-id="aeee2-366">Můžete zachovat non-string data buď jako binární data nebo jako formátovaná data.</span><span class="sxs-lookup"><span data-stu-id="aeee2-366">You can persist non-string data either as binary data or as formatted data.</span></span> <span data-ttu-id="aeee2-367">Pokud se rozhodnete uložit jako formátovaná data, měli byste zavolat `provider` přetížení metody formátování, které obsahuje parametr, a předat mu <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> vlastnost.</span><span class="sxs-lookup"><span data-stu-id="aeee2-367">If you choose to save it as formatted data, you should call a formatting method overload that includes a `provider` parameter and pass it the <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="aeee2-368">Invariantní jazyková verze poskytuje konzistentní formát pro formátovaná data, která je nezávislá na jazykové verzi a počítači.</span><span class="sxs-lookup"><span data-stu-id="aeee2-368">The invariant culture provides a consistent format for formatted data that is independent of culture and machine.</span></span> <span data-ttu-id="aeee2-369">Naproti tomu trvalá data, která je formátována pomocí jazykové verze než invariantní jazykové verze má řadu omezení:</span><span class="sxs-lookup"><span data-stu-id="aeee2-369">In contrast, persisting data that is formatted by using cultures other than the invariant culture has a number of limitations:</span></span>

- <span data-ttu-id="aeee2-370">Data je pravděpodobně nepoužitelná, pokud je načtena v systému, který má jinou jazykovou verzi, nebo pokud uživatel aktuálního systému změní aktuální jazykovou verzi a pokusí se načíst data.</span><span class="sxs-lookup"><span data-stu-id="aeee2-370">The data is likely to be unusable if it is retrieved on a system that has a different culture, or if the user of the current system changes the current culture and tries to retrieve the data.</span></span>
- <span data-ttu-id="aeee2-371">Vlastnosti jazykové verze v určitém počítači se mohou lišit od standardních hodnot.</span><span class="sxs-lookup"><span data-stu-id="aeee2-371">The properties of a culture on a specific computer can differ from standard values.</span></span> <span data-ttu-id="aeee2-372">Uživatel může kdykoli přizpůsobit nastavení zobrazení zkoumaná jazykovou verzi.</span><span class="sxs-lookup"><span data-stu-id="aeee2-372">At any time, a user can customize culture-sensitive display settings.</span></span> <span data-ttu-id="aeee2-373">Z tohoto důvodu formátovaná data uložená v systému nemusí být čitelná poté, co uživatel přizpůsobí nastavení kultury.</span><span class="sxs-lookup"><span data-stu-id="aeee2-373">Because of this, formatted data that is saved on a system may not be readable after the user customizes cultural settings.</span></span> <span data-ttu-id="aeee2-374">Přenositelnost formátovaných dat mezi počítači bude pravděpodobně ještě omezenější.</span><span class="sxs-lookup"><span data-stu-id="aeee2-374">The portability of formatted data across computers is likely to be even more limited.</span></span>
- <span data-ttu-id="aeee2-375">Mezinárodní, regionální nebo národní standardy, které řídí formátování čísel nebo dat a časů, se v průběhu času mění a tyto změny jsou začleněny do aktualizací operačního systému Windows.</span><span class="sxs-lookup"><span data-stu-id="aeee2-375">International, regional, or national standards that govern the formatting of numbers or dates and times change over time, and these changes are incorporated into Windows operating system updates.</span></span> <span data-ttu-id="aeee2-376">Při změně formátování konvence, data, která byla formátována pomocí předchozích konvencí může stát nečitelný.</span><span class="sxs-lookup"><span data-stu-id="aeee2-376">When formatting conventions change, data that was formatted by using the previous conventions may become unreadable.</span></span>

<span data-ttu-id="aeee2-377">Následující příklad ilustruje omezenou přenositelnost, která je výsledkem použití formátování citlivé ho jazykové verze k uchování dat.</span><span class="sxs-lookup"><span data-stu-id="aeee2-377">The following example illustrates the limited portability that results from using culture-sensitive formatting to persist data.</span></span> <span data-ttu-id="aeee2-378">Příklad ukládá do souboru pole hodnot data a času.</span><span class="sxs-lookup"><span data-stu-id="aeee2-378">The example saves an array of date and time values to a file.</span></span> <span data-ttu-id="aeee2-379">Ty jsou formátovány pomocí konvencí jazykové verze Angličtina (Spojené státy).</span><span class="sxs-lookup"><span data-stu-id="aeee2-379">These are formatted by using the conventions of the English (United States) culture.</span></span> <span data-ttu-id="aeee2-380">Poté, co aplikace změní aktuální jazykovou verzi vlákna na francouzštinu (Švýcarsko), pokusí se číst uložené hodnoty pomocí konvencí formátování aktuální jazykové verze.</span><span class="sxs-lookup"><span data-stu-id="aeee2-380">After the application changes the current thread culture to French (Switzerland), it tries to read the saved values by using the formatting conventions of the current culture.</span></span> <span data-ttu-id="aeee2-381">Pokus o čtení dvou datových položek <xref:System.FormatException> vyvolá výjimku a pole dat nyní obsahuje <xref:System.DateTime.MinValue>dva nesprávné prvky, které se rovnají .</span><span class="sxs-lookup"><span data-stu-id="aeee2-381">The attempt to read two of the data items throws a <xref:System.FormatException> exception, and the array of dates now contains two incorrect elements that are equal to <xref:System.DateTime.MinValue>.</span></span>

[!code-csharp[Conceptual.Strings.BestPractices#21](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.strings.bestpractices/cs/persistence.cs#21)]
[!code-vb[Conceptual.Strings.BestPractices#21](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.strings.bestpractices/vb/persistence.vb#21)]

<span data-ttu-id="aeee2-382">Pokud však nahradíte <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> vlastnost ve <xref:System.DateTime.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> volání <xref:System.DateTime.Parse%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>do a , budou trvalá data data a času úspěšně obnovena, jak ukazuje následující výstup:</span><span class="sxs-lookup"><span data-stu-id="aeee2-382">However, if you replace the <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> property with <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> in the calls to <xref:System.DateTime.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> and <xref:System.DateTime.Parse%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>,   the persisted date and time data is successfully restored, as the following output shows:</span></span>

```console
06.05.1758 21:26
05.05.1818 07:19
22.04.1870 23:54
08.09.1890 06:47
18.02.1905 15:12
```

## <a name="see-also"></a><span data-ttu-id="aeee2-383">Viz také</span><span class="sxs-lookup"><span data-stu-id="aeee2-383">See also</span></span>

- [<span data-ttu-id="aeee2-384">Práce s řetězci</span><span class="sxs-lookup"><span data-stu-id="aeee2-384">Manipulating Strings</span></span>](manipulating-strings.md)
