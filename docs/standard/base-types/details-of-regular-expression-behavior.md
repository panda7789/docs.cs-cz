---
title: Chování regulárního výrazu
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- regular expressions, behavior
- .NET Framework regular expressions, behavior
ms.assetid: 0ee1a6b8-caac-41d2-917f-d35570021b10
ms.openlocfilehash: 288bf4256670d34c600e23618b62ad81866daadf
ms.sourcegitcommit: 79b0dd8bfc63f33a02137121dd23475887ecefda
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 04/01/2020
ms.locfileid: "80523841"
---
# <a name="details-of-regular-expression-behavior"></a><span data-ttu-id="546f2-102">Podrobnosti o chování regulárních výrazů</span><span class="sxs-lookup"><span data-stu-id="546f2-102">Details of regular expression behavior</span></span>

<span data-ttu-id="546f2-103">Modul regulárních výrazů rozhraní .NET Framework je backtrackingový matcher regulárních výrazů, který obsahuje tradiční modul NFA (Nondeterministic Finite Automaton), například modul používaný perlem, pythonem, emacsem a tcl.</span><span class="sxs-lookup"><span data-stu-id="546f2-103">The .NET Framework regular expression engine is a backtracking regular expression matcher that incorporates a traditional Nondeterministic Finite Automaton (NFA) engine such as that used by Perl, Python, Emacs, and Tcl.</span></span> <span data-ttu-id="546f2-104">Tím se odlišuje od rychlejší, ale omezenější, čistě regulární výraz Deterministický konečný automaton (DFA) motory, jako jsou ty, které se nacházejí v awk, egrep, nebo lex.</span><span class="sxs-lookup"><span data-stu-id="546f2-104">This distinguishes it from faster, but more limited, pure regular expression Deterministic Finite Automaton (DFA) engines such as those found in awk, egrep, or lex.</span></span> <span data-ttu-id="546f2-105">To také odlišuje od standardizované, ale pomalejší, POSIX NFAs.</span><span class="sxs-lookup"><span data-stu-id="546f2-105">This also distinguishes it from standardized, but slower, POSIX NFAs.</span></span> <span data-ttu-id="546f2-106">Následující část popisuje tři typy modulů regulárních výrazů a vysvětluje, proč jsou regulární výrazy v rozhraní .NET Framework implementovány pomocí tradičního modulu NFA.</span><span class="sxs-lookup"><span data-stu-id="546f2-106">The following section describes the three types of regular expression engines, and explains why regular expressions in the .NET Framework are implemented by using a traditional NFA engine.</span></span>

## <a name="benefits-of-the-nfa-engine"></a><span data-ttu-id="546f2-107">Výhody motoru NFA</span><span class="sxs-lookup"><span data-stu-id="546f2-107">Benefits of the NFA engine</span></span>

 <span data-ttu-id="546f2-108">Když moduly DFA provádět porovnávání vzorů, jejich pořadí zpracování je řízeno vstupní řetězec.</span><span class="sxs-lookup"><span data-stu-id="546f2-108">When DFA engines perform pattern matching, their processing order is driven by the input string.</span></span> <span data-ttu-id="546f2-109">Modul začíná na začátku vstupního řetězce a pokračuje postupně k určení, zda další znak odpovídá vzoru regulárního výrazu.</span><span class="sxs-lookup"><span data-stu-id="546f2-109">The engine begins at the beginning of the input string and proceeds sequentially to determine whether the next character matches the regular expression pattern.</span></span> <span data-ttu-id="546f2-110">Mohou zaručit, že budou odpovídat nejdelšímu možnému řetězci.</span><span class="sxs-lookup"><span data-stu-id="546f2-110">They can guarantee to match the longest string possible.</span></span> <span data-ttu-id="546f2-111">Protože nikdy testovat stejný znak dvakrát, DFA motory nepodporují navracení.</span><span class="sxs-lookup"><span data-stu-id="546f2-111">Because they never test the same character twice, DFA engines do not support backtracking.</span></span> <span data-ttu-id="546f2-112">Však vzhledem k tomu, že modul DFA obsahuje pouze konečný stav, nemůže odpovídat vzorek s backreferences a protože nevytváří explicitní rozšíření, nemůže zachytit podvýrazy.</span><span class="sxs-lookup"><span data-stu-id="546f2-112">However, because a DFA engine contains only finite state, it cannot match a pattern with backreferences, and because it does not construct an explicit expansion, it cannot capture subexpressions.</span></span>

 <span data-ttu-id="546f2-113">Na rozdíl od modulů DFA, když tradiční moduly NFA provádějí porovnávání vzorů, jejich pořadí zpracování je řízeno vzorem regulárního výrazu.</span><span class="sxs-lookup"><span data-stu-id="546f2-113">Unlike DFA engines, when traditional NFA engines perform pattern matching, their processing order is driven by the regular expression pattern.</span></span> <span data-ttu-id="546f2-114">Při zpracování určitého prvku jazyka používá modul chamtivé párování; to znamená, že odpovídá co nejvíce vstupního řetězce, jak je to možné.</span><span class="sxs-lookup"><span data-stu-id="546f2-114">As it processes a particular language element, the engine uses greedy matching; that is, it matches as much of the input string as it possibly can.</span></span> <span data-ttu-id="546f2-115">Ale také uloží jeho stav po úspěšném porovnání dílčího výrazu.</span><span class="sxs-lookup"><span data-stu-id="546f2-115">But it also saves its state after successfully matching a subexpression.</span></span> <span data-ttu-id="546f2-116">Pokud se shoda nakonec nezdaří, modul se může vrátit do uloženého stavu, aby mohl vyzkoušet další shody.</span><span class="sxs-lookup"><span data-stu-id="546f2-116">If a match eventually fails, the engine can return to a saved state so it can try additional matches.</span></span> <span data-ttu-id="546f2-117">Tento proces opuštění úspěšné shody podvýrazu tak, aby pozdější prvky jazyka v regulárním výrazu se také mohly shodovat, se označuje jako *backtracking*.</span><span class="sxs-lookup"><span data-stu-id="546f2-117">This process of abandoning a successful subexpression match so that later language elements in the regular expression can also match is known as *backtracking*.</span></span> <span data-ttu-id="546f2-118">Moduly NFA používají backtracking k testování všech možných rozšíření regulárního výrazu v určitém pořadí a přijmout první shodu.</span><span class="sxs-lookup"><span data-stu-id="546f2-118">NFA engines use backtracking to test all possible expansions of a regular expression in a specific order and accept the first match.</span></span> <span data-ttu-id="546f2-119">Vzhledem k tomu, že tradiční modul NFA vytvoří konkrétní rozšíření regulárního výrazu pro úspěšnou shodu, může zachytit shody podvýrazu a odpovídající zpětné odkazy.</span><span class="sxs-lookup"><span data-stu-id="546f2-119">Because a traditional NFA engine constructs a specific expansion of the regular expression for a successful match, it can capture subexpression matches and matching backreferences.</span></span> <span data-ttu-id="546f2-120">Však protože tradiční NFA backtracks, může navštívit stejný stav vícekrát, pokud dorazí do stavu přes různé cesty.</span><span class="sxs-lookup"><span data-stu-id="546f2-120">However, because a traditional NFA backtracks, it can visit the same state multiple times if it arrives at the state over different paths.</span></span> <span data-ttu-id="546f2-121">V důsledku toho může běžet exponenciálně pomalu v nejhorším případě.</span><span class="sxs-lookup"><span data-stu-id="546f2-121">As a result, it can run exponentially slowly in the worst case.</span></span> <span data-ttu-id="546f2-122">Vzhledem k tomu, že tradiční modul NFA přijímá první shodu, kterou najde, může také ponechat jiné (případně delší) shody neobjevené.</span><span class="sxs-lookup"><span data-stu-id="546f2-122">Because a traditional NFA engine accepts the first match it finds, it can also leave other (possibly longer) matches undiscovered.</span></span>

 <span data-ttu-id="546f2-123">POSIX NFA motory jsou jako tradiční NFA motory, kromě toho, že i nadále ustoupit, dokud mohou zaručit, že našli nejdelší možnou shodu.</span><span class="sxs-lookup"><span data-stu-id="546f2-123">POSIX NFA engines are like traditional NFA engines, except that they continue to backtrack until they can guarantee that they have found the longest match possible.</span></span> <span data-ttu-id="546f2-124">V důsledku toho posix NFA motor je pomalejší než tradiční modul NFA a při použití modulu POSIX NFA, nelze upřednostnit kratší shoda přes delší změnou pořadí backtracking vyhledávání.</span><span class="sxs-lookup"><span data-stu-id="546f2-124">As a result, a POSIX NFA engine is slower than a traditional NFA engine, and when you use a POSIX NFA engine, you cannot favor a shorter match over a longer one by changing the order of the backtracking search.</span></span>

 <span data-ttu-id="546f2-125">Tradiční moduly NFA jsou upřednostňovány programátory, protože nabízejí větší kontrolu nad porovnáváním řetězců než motory DFA nebo POSIX NFA.</span><span class="sxs-lookup"><span data-stu-id="546f2-125">Traditional NFA engines are favored by programmers because they offer greater control over string matching than either DFA or POSIX NFA engines.</span></span> <span data-ttu-id="546f2-126">I když v nejhorším případě mohou běžet pomalu, můžete je nasměrovat k nalezení shody v lineárním nebo polynomickém čase pomocí vzorů, které snižují nejasnosti a omezují backtracking.</span><span class="sxs-lookup"><span data-stu-id="546f2-126">Although, in the worst case, they can run slowly, you can steer them to find matches in linear or polynomial time by using patterns that reduce ambiguities and limit backtracking.</span></span> <span data-ttu-id="546f2-127">Jinými slovy, i když nfa motory obchodu výkon pro výkon a flexibilitu, ve většině případů nabízejí dobré přijatelné výkon, pokud regulární výraz je dobře napsaný a vyhýbá se případy, ve kterých backtracking snižuje výkon exponenciálně.</span><span class="sxs-lookup"><span data-stu-id="546f2-127">In other words, although NFA engines trade performance for power and flexibility, in most cases they offer good to acceptable performance if a regular expression is well written and avoids cases in which backtracking degrades performance exponentially.</span></span>

> [!NOTE]
> <span data-ttu-id="546f2-128">Informace o snížení výkonu způsobené nadměrným navracením a způsoby vytvoření regulárního výrazu k jejich obejít, naleznete v [tématu Backtracking](../../../docs/standard/base-types/backtracking-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="546f2-128">For information about the performance penalty caused by excessive backtracking and ways to craft a regular expression to work around them, see [Backtracking](../../../docs/standard/base-types/backtracking-in-regular-expressions.md).</span></span>

## <a name="net-framework-engine-capabilities"></a><span data-ttu-id="546f2-129">Možnosti modulu rozhraní .NET Framework</span><span class="sxs-lookup"><span data-stu-id="546f2-129">.NET Framework engine capabilities</span></span>

 <span data-ttu-id="546f2-130">Chcete-li využít výhod tradiční modul NFA, modul regulárních výrazů rozhraní .NET Framework obsahuje úplnou sadu konstrukcí, které umožňují programátorům řídit modul backtracking.</span><span class="sxs-lookup"><span data-stu-id="546f2-130">To take advantage of the benefits of a traditional NFA engine, the .NET Framework regular expression engine includes a complete set of constructs to enable programmers to steer the backtracking engine.</span></span> <span data-ttu-id="546f2-131">Tyto konstrukce lze použít k nalezení shody rychleji nebo upřednostnit konkrétní rozšíření nad ostatními.</span><span class="sxs-lookup"><span data-stu-id="546f2-131">These constructs can be used to find matches faster or to favor specific expansions over others.</span></span>

 <span data-ttu-id="546f2-132">Mezi další funkce modulu regulárních výrazů rozhraní .NET Framework patří následující:</span><span class="sxs-lookup"><span data-stu-id="546f2-132">Other features of the .NET Framework regular expression engine include the following:</span></span>

- <span data-ttu-id="546f2-133">`??`Opožděné kvantifikátory: , `*?`, `+?`, `{` *n*`,`*m*`}?`.</span><span class="sxs-lookup"><span data-stu-id="546f2-133">Lazy quantifiers: `??`, `*?`, `+?`, `{`*n*`,`*m*`}?`.</span></span> <span data-ttu-id="546f2-134">Tyto konstrukce sdělit backtracking motoru hledat minimální počet opakování jako první.</span><span class="sxs-lookup"><span data-stu-id="546f2-134">These constructs tell the backtracking engine to search the minimum number of repetitions first.</span></span> <span data-ttu-id="546f2-135">Naproti tomu obyčejné chamtivé kvantifikátory se nejprve snaží vyrovnat maximálnímu počtu opakování.</span><span class="sxs-lookup"><span data-stu-id="546f2-135">In contrast, ordinary greedy quantifiers try to match the maximum number of repetitions first.</span></span> <span data-ttu-id="546f2-136">Následující příklad ilustruje rozdíl mezi těmito dvěma.</span><span class="sxs-lookup"><span data-stu-id="546f2-136">The following example illustrates the difference between the two.</span></span> <span data-ttu-id="546f2-137">Regulární výraz odpovídá větě, která končí číslem, a zachytávající skupina je určena k extrahování tohoto čísla.</span><span class="sxs-lookup"><span data-stu-id="546f2-137">A regular expression matches a sentence that ends in a number, and a capturing group is intended to extract that number.</span></span> <span data-ttu-id="546f2-138">Regulární `.+(\d+)\.` výraz obsahuje nenasytný kvantifikátor `.+`, který způsobí, že modul regulárních výrazů zachytí pouze poslední číslici čísla.</span><span class="sxs-lookup"><span data-stu-id="546f2-138">The regular expression `.+(\d+)\.` includes the greedy quantifier `.+`, which causes the regular expression engine to capture only the last digit of the number.</span></span> <span data-ttu-id="546f2-139">Naproti tomu regulární výraz `.+?(\d+)\.` obsahuje `.+?`opožděný kvantifikátor , který způsobí, že modul regulárních výrazů zachytí celé číslo.</span><span class="sxs-lookup"><span data-stu-id="546f2-139">In contrast, the regular expression `.+?(\d+)\.` includes the lazy quantifier `.+?`, which causes the regular expression engine to capture the entire number.</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/lazy1.cs#1)]
     [!code-vb[Conceptual.RegularExpressions.Design#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/lazy1.vb#1)]

     <span data-ttu-id="546f2-140">Chamtivé a opožděné verze tohoto regulárního výrazu jsou definovány tak, jak je znázorněno v následující tabulce:</span><span class="sxs-lookup"><span data-stu-id="546f2-140">The greedy and lazy versions of this regular expression are defined as shown in the following table:</span></span>

    |<span data-ttu-id="546f2-141">Vzor</span><span class="sxs-lookup"><span data-stu-id="546f2-141">Pattern</span></span>|<span data-ttu-id="546f2-142">Popis</span><span class="sxs-lookup"><span data-stu-id="546f2-142">Description</span></span>|
    |-------------|-----------------|
    |<span data-ttu-id="546f2-143">`.+`(nenasytný kvantifikátor)</span><span class="sxs-lookup"><span data-stu-id="546f2-143">`.+` (greedy quantifier)</span></span>|<span data-ttu-id="546f2-144">Porovná alespoň jeden výskyt libovolného znaku.</span><span class="sxs-lookup"><span data-stu-id="546f2-144">Match at least one occurrence of any character.</span></span> <span data-ttu-id="546f2-145">To způsobí, že modul regulárních výrazů tak, aby odpovídaly celý řetězec a potom ustoupit podle potřeby tak, aby odpovídaly zbytek vzoru.</span><span class="sxs-lookup"><span data-stu-id="546f2-145">This causes the regular expression engine to match the entire string, and then to backtrack as needed to match the remainder of the pattern.</span></span>|
    |<span data-ttu-id="546f2-146">`.+?`(líný kvantifikátor)</span><span class="sxs-lookup"><span data-stu-id="546f2-146">`.+?` (lazy quantifier)</span></span>|<span data-ttu-id="546f2-147">Porovná alespoň jeden výskyt libovolného znaku, ale shoduje se co nejméně.</span><span class="sxs-lookup"><span data-stu-id="546f2-147">Match at least one occurrence of any character, but match as few as possible.</span></span>|
    |`(\d+)`|<span data-ttu-id="546f2-148">Porovná alespoň jeden číselný znak a přiřadí ho první zachytávající skupině.</span><span class="sxs-lookup"><span data-stu-id="546f2-148">Match at least one numeric character, and assign it to the first capturing group.</span></span>|
    |`\.`|<span data-ttu-id="546f2-149">Porovná tečku.</span><span class="sxs-lookup"><span data-stu-id="546f2-149">Match a period.</span></span>|

     <span data-ttu-id="546f2-150">Další informace o opožděných kvantifikárech naleznete [v tématu Kvantifikátory](../../../docs/standard/base-types/quantifiers-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="546f2-150">For more information about lazy quantifiers, see [Quantifiers](../../../docs/standard/base-types/quantifiers-in-regular-expressions.md).</span></span>

- <span data-ttu-id="546f2-151">Pozitivní dopředné vyhledávání: `(?=` *podvýraz*`)`.</span><span class="sxs-lookup"><span data-stu-id="546f2-151">Positive lookahead: `(?=`*subexpression*`)`.</span></span> <span data-ttu-id="546f2-152">Tato funkce umožňuje backtracking motoru vrátit na stejné místo v textu po odpovídající podvýraz.</span><span class="sxs-lookup"><span data-stu-id="546f2-152">This feature allows the backtracking engine to return to the same spot in the text after matching a subexpression.</span></span> <span data-ttu-id="546f2-153">Je užitečné pro vyhledávání v celém textu ověřením více vzorků, které začínají ze stejné pozice.</span><span class="sxs-lookup"><span data-stu-id="546f2-153">It is useful for searching throughout the text by verifying multiple patterns that start from the same position.</span></span> <span data-ttu-id="546f2-154">Také umožňuje modulu ověřit, že podřetězec existuje na konci shody bez zahrnutí podřetězce do odpovídajícího textu.</span><span class="sxs-lookup"><span data-stu-id="546f2-154">It also allows the engine to verify that a substring exists at the end of the match without including the substring in the matched text.</span></span> <span data-ttu-id="546f2-155">Následující příklad používá pozitivní dopředné vyhledávání extrahovat slova ve větě, které nejsou následovány interpunkční symboly.</span><span class="sxs-lookup"><span data-stu-id="546f2-155">The following example uses positive lookahead to extract the words in a sentence that are not followed by punctuation symbols.</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#2](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/lookahead1.cs#2)]
     [!code-vb[Conceptual.RegularExpressions.Design#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/lookahead1.vb#2)]

     <span data-ttu-id="546f2-156">Regulární `\b[A-Z]+\b(?=\P{P})` výraz je definován tak, jak je znázorněno v následující tabulce.</span><span class="sxs-lookup"><span data-stu-id="546f2-156">The regular expression `\b[A-Z]+\b(?=\P{P})` is defined as shown in the following table.</span></span>

    |<span data-ttu-id="546f2-157">Vzor</span><span class="sxs-lookup"><span data-stu-id="546f2-157">Pattern</span></span>|<span data-ttu-id="546f2-158">Popis</span><span class="sxs-lookup"><span data-stu-id="546f2-158">Description</span></span>|
    |-------------|-----------------|
    |`\b`|<span data-ttu-id="546f2-159">Začne porovnání na hranici slova.</span><span class="sxs-lookup"><span data-stu-id="546f2-159">Begin the match at a word boundary.</span></span>|
    |`[A-Z]+`|<span data-ttu-id="546f2-160">Porovná libovolný abecední znak jednou nebo vícekrát.</span><span class="sxs-lookup"><span data-stu-id="546f2-160">Match any alphabetic character one or more times.</span></span> <span data-ttu-id="546f2-161">Vzhledem <xref:System.Text.RegularExpressions.Regex.Matches%2A?displayProperty=nameWithType> k tomu, <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> že metoda je volána s možností, porovnání je malá a velká písmena.</span><span class="sxs-lookup"><span data-stu-id="546f2-161">Because the <xref:System.Text.RegularExpressions.Regex.Matches%2A?displayProperty=nameWithType> method is called with the <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> option, the comparison is case-insensitive.</span></span>|
    |`\b`|<span data-ttu-id="546f2-162">Ukončí porovnání na hranici slova.</span><span class="sxs-lookup"><span data-stu-id="546f2-162">End the match at a word boundary.</span></span>|
    |`(?=\P{P})`|<span data-ttu-id="546f2-163">Podívejte se dopředu a zjistěte, zda je dalším znakem symbol interpunkce.</span><span class="sxs-lookup"><span data-stu-id="546f2-163">Look ahead to determine whether the next character is a punctuation symbol.</span></span> <span data-ttu-id="546f2-164">Pokud tomu tak není, shoda proběhne úspěšně.</span><span class="sxs-lookup"><span data-stu-id="546f2-164">If it is not, the match succeeds.</span></span>|

     <span data-ttu-id="546f2-165">Další informace o kontrolních výrazech pozitivního dopředného vyhledávání naleznete v [tématu Seskupování konstrukcí](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="546f2-165">For more information about positive lookahead assertions, see [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span></span>

- <span data-ttu-id="546f2-166">Negativní dopředné vyhledávání: `(?!` *podvýraz*`)`.</span><span class="sxs-lookup"><span data-stu-id="546f2-166">Negative lookahead: `(?!`*subexpression*`)`.</span></span> <span data-ttu-id="546f2-167">Tato funkce přidává možnost odpovídat výrazu pouze v případě, že dílčí výraz neodpovídá.</span><span class="sxs-lookup"><span data-stu-id="546f2-167">This feature adds the ability to match an expression only if a subexpression fails to match.</span></span> <span data-ttu-id="546f2-168">To je obzvláště silný pro prořezávání hledání, protože je často jednodušší poskytnout výraz pro případ, který by měl být odstraněn, než výraz pro případy, které musí být zahrnuty.</span><span class="sxs-lookup"><span data-stu-id="546f2-168">This is particularly powerful for pruning a search, because it is often simpler to provide an expression for a case that should be eliminated than an expression for cases that must be included.</span></span> <span data-ttu-id="546f2-169">Například je obtížné napsat výraz pro slova, která nezačínají na "non".</span><span class="sxs-lookup"><span data-stu-id="546f2-169">For example, it is difficult to write an expression for words that do not begin with "non".</span></span> <span data-ttu-id="546f2-170">Následující příklad používá negativní dopředné vyhledávání k jejich vyloučení.</span><span class="sxs-lookup"><span data-stu-id="546f2-170">The following example uses negative lookahead to exclude them.</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#3](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/lookahead2.cs#3)]
     [!code-vb[Conceptual.RegularExpressions.Design#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/lookahead2.vb#3)]

     <span data-ttu-id="546f2-171">Vzor regulárního výrazu `\b(?!non)\w+\b` je definován tak, jak je znázorněno v následující tabulce.</span><span class="sxs-lookup"><span data-stu-id="546f2-171">The regular expression pattern `\b(?!non)\w+\b` is defined as shown in the following table.</span></span>

    |<span data-ttu-id="546f2-172">Vzor</span><span class="sxs-lookup"><span data-stu-id="546f2-172">Pattern</span></span>|<span data-ttu-id="546f2-173">Popis</span><span class="sxs-lookup"><span data-stu-id="546f2-173">Description</span></span>|
    |-------------|-----------------|
    |`\b`|<span data-ttu-id="546f2-174">Začne porovnání na hranici slova.</span><span class="sxs-lookup"><span data-stu-id="546f2-174">Begin the match at a word boundary.</span></span>|
    |`(?!non)`|<span data-ttu-id="546f2-175">Podívejte se dopředu, abyste zajistili, že aktuální řetězec nezačíná na "non".</span><span class="sxs-lookup"><span data-stu-id="546f2-175">Look ahead to ensure that the current string does not begin with "non".</span></span> <span data-ttu-id="546f2-176">Pokud ano, shoda se nezdaří.</span><span class="sxs-lookup"><span data-stu-id="546f2-176">If it does, the match fails.</span></span>|
    |`(\w+)`|<span data-ttu-id="546f2-177">Porovná jeden nebo více znaků slova.</span><span class="sxs-lookup"><span data-stu-id="546f2-177">Match one or more word characters.</span></span>|
    |`\b`|<span data-ttu-id="546f2-178">Ukončí porovnání na hranici slova.</span><span class="sxs-lookup"><span data-stu-id="546f2-178">End the match at a word boundary.</span></span>|

     <span data-ttu-id="546f2-179">Další informace o kontrolních výrazech negativního dopředného vyhledávání naleznete v [tématu Seskupování konstrukcí](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="546f2-179">For more information about negative lookahead assertions, see [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span></span>

- <span data-ttu-id="546f2-180">Podmíněné `(?(`vyhodnocení: *výraz*`)`*ano*`|`*ne* `)` a `(?(` *název*`)`*ano ne*`|`*no*`)`, kde *výraz* je podvýraz, který se má shodovat, *název* je název zachytávající skupiny, *ano* je řetězec, který odpovídá, pokud je *výraz* spárován nebo *název* je platná, neprázdná zachycená skupina a *ne* je dílčívýraz, který odpovídá, pokud *výraz* není spárován nebo *název* není platná, neprázdná zachycená skupina.</span><span class="sxs-lookup"><span data-stu-id="546f2-180">Conditional evaluation: `(?(`*expression*`)`*yes*`|`*no*`)` and `(?(`*name*`)`*yes*`|`*no*`)`, where *expression* is a subexpression to match, *name* is the name of a capturing group, *yes* is the string to match if *expression* is matched or *name* is a valid, non-empty captured group, and *no* is the subexpression to match if *expression* is not matched or *name* is not a valid, non-empty captured group.</span></span> <span data-ttu-id="546f2-181">Tato funkce umožňuje motoru prohledávat pomocí více než jeden alternativní vzorek, v závislosti na výsledku předchozí shody dílčího výrazu nebo výsledek kontrolnívýraz s nulovou šířkou.</span><span class="sxs-lookup"><span data-stu-id="546f2-181">This feature allows the engine to search by using more than one alternate pattern, depending on the result of a previous subexpression match or the result of a zero-width assertion.</span></span> <span data-ttu-id="546f2-182">To umožňuje výkonnější formu zpětného odkazu, který umožňuje například odpovídající podvýraz na základě toho, zda byl spárován předchozí dílčí výraz.</span><span class="sxs-lookup"><span data-stu-id="546f2-182">This allows a more powerful form of backreference that permits, for example, matching a subexpression based on whether a previous subexpression was matched.</span></span> <span data-ttu-id="546f2-183">Regulární výraz v následujícím příkladu odpovídá odstavcům, které jsou určeny pro veřejné i interní použití.</span><span class="sxs-lookup"><span data-stu-id="546f2-183">The regular expression in the following example matches paragraphs that are intended for both public and internal use.</span></span> <span data-ttu-id="546f2-184">Odstavce určené pouze pro vnitřní `<PRIVATE>` použití začínají tagem.</span><span class="sxs-lookup"><span data-stu-id="546f2-184">Paragraphs intended only for internal use begin with a `<PRIVATE>` tag.</span></span> <span data-ttu-id="546f2-185">Vzor regulárního výrazu `^(?<Pvt>\<PRIVATE\>\s)?(?(Pvt)((\w+\p{P}?\s)+)|((\w+\p{P}?\s)+))\r?$` používá podmíněné vyhodnocení k přiřazení obsahu odstavců určených pro veřejné a interní použití k oddělení zachytávacích skupin.</span><span class="sxs-lookup"><span data-stu-id="546f2-185">The regular expression pattern `^(?<Pvt>\<PRIVATE\>\s)?(?(Pvt)((\w+\p{P}?\s)+)|((\w+\p{P}?\s)+))\r?$` uses conditional evaluation to assign the contents of paragraphs intended for public and for internal use to separate capturing groups.</span></span> <span data-ttu-id="546f2-186">Tyto odstavce pak mohou být zpracovány odlišně.</span><span class="sxs-lookup"><span data-stu-id="546f2-186">These paragraphs can then be handled differently.</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#4](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/conditional1.cs#4)]
     [!code-vb[Conceptual.RegularExpressions.Design#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/conditional1.vb#4)]

     <span data-ttu-id="546f2-187">Vzor regulárního výrazu je definován tak, jak je znázorněno v následující tabulce.</span><span class="sxs-lookup"><span data-stu-id="546f2-187">The regular expression pattern is defined as shown in the following table.</span></span>

    |<span data-ttu-id="546f2-188">Vzor</span><span class="sxs-lookup"><span data-stu-id="546f2-188">Pattern</span></span>|<span data-ttu-id="546f2-189">Popis</span><span class="sxs-lookup"><span data-stu-id="546f2-189">Description</span></span>|
    |-------------|-----------------|
    |`^`|<span data-ttu-id="546f2-190">Začněte zápas na začátku řádku.</span><span class="sxs-lookup"><span data-stu-id="546f2-190">Begin the match at the beginning of a line.</span></span>|
    |`(?<Pvt>\<PRIVATE\>\s)?`|<span data-ttu-id="546f2-191">Porovná nula nebo jeden `<PRIVATE>` výskyt řetězce následovaný znakem prázdnémezery.</span><span class="sxs-lookup"><span data-stu-id="546f2-191">Match zero or one occurrence of the string `<PRIVATE>` followed by a white-space character.</span></span> <span data-ttu-id="546f2-192">Přiřaďte shodu `Pvt`zachytávající skupině s názvem .</span><span class="sxs-lookup"><span data-stu-id="546f2-192">Assign the match to a capturing group named `Pvt`.</span></span>|
    |`(?(Pvt)((\w+\p{P}?\s)+)`|<span data-ttu-id="546f2-193">Pokud `Pvt` zachytávající skupina existuje, porovnejte jeden nebo více výskytů jednoho nebo více znaků slova následovaných nulou nebo jedním oddělovačem interpunkce následovaným bílým znakem.</span><span class="sxs-lookup"><span data-stu-id="546f2-193">If the `Pvt` capturing group exists, match one or more occurrences of one or more word characters followed by zero or one punctuation separator followed by a white-space character.</span></span> <span data-ttu-id="546f2-194">Přiřaďte podřetězec k první zachytávající skupině.</span><span class="sxs-lookup"><span data-stu-id="546f2-194">Assign the substring to the first capturing group.</span></span>|
    |<code>&#124;((\w+\p{P}?\s)+))</code>|<span data-ttu-id="546f2-195">Pokud `Pvt` zachytávající skupina neexistuje, porovnejte jeden nebo více výskytů jednoho nebo více znaků slova následovaných nulou nebo jedním oddělovačem interpunkce následovaným znakem prázdného místa.</span><span class="sxs-lookup"><span data-stu-id="546f2-195">If the `Pvt` capturing group does not exist, match one or more occurrences of one or more word characters followed by zero or one punctuation separator followed by a white-space character.</span></span> <span data-ttu-id="546f2-196">Přiřaďte podřetězec třetí zachytávající skupině.</span><span class="sxs-lookup"><span data-stu-id="546f2-196">Assign the substring to the third capturing group.</span></span>|
    |`\r?$`|<span data-ttu-id="546f2-197">Porovná konec řádku nebo konec řetězce.</span><span class="sxs-lookup"><span data-stu-id="546f2-197">Match the end of a line or the end of the string.</span></span>|

     <span data-ttu-id="546f2-198">Další informace o podmíněném vyhodnocení naleznete v [tématu Alternation Constructs](../../../docs/standard/base-types/alternation-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="546f2-198">For more information about conditional evaluation, see [Alternation Constructs](../../../docs/standard/base-types/alternation-constructs-in-regular-expressions.md).</span></span>

- <span data-ttu-id="546f2-199">Definice vyrovnávacích `(?<`skupin: *podvýraz*`)` *name1*`-`*name2* `>` .</span><span class="sxs-lookup"><span data-stu-id="546f2-199">Balancing group definitions: `(?<`*name1*`-`*name2*`>` *subexpression*`)`.</span></span> <span data-ttu-id="546f2-200">Tato funkce umožňuje modulu regulárních výrazů sledovat vnořené konstrukce, jako jsou závorky nebo otevírací a uzavírací závorky.</span><span class="sxs-lookup"><span data-stu-id="546f2-200">This feature allows the regular expression engine to keep track of nested constructs such as parentheses or opening and closing brackets.</span></span> <span data-ttu-id="546f2-201">Příklad naleznete v [tématu Seskupení konstrukce](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="546f2-201">For an example, see [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span></span>

- <span data-ttu-id="546f2-202">Atomové `(?>`skupiny: *podvýraz*`)`.</span><span class="sxs-lookup"><span data-stu-id="546f2-202">Atomic groups: `(?>`*subexpression*`)`.</span></span> <span data-ttu-id="546f2-203">Tato funkce umožňuje backtracking motoru zaručit, že podvýraz odpovídá pouze první shodě nalezené pro tento dílčí výraz, jako kdyby výraz byl spuštěn nezávisle na jeho obsahující výraz.</span><span class="sxs-lookup"><span data-stu-id="546f2-203">This feature allows the backtracking engine to guarantee that a subexpression matches only the first match found for that subexpression, as if the expression were running independent of its containing expression.</span></span> <span data-ttu-id="546f2-204">Pokud tuto konstrukci nepoužijete, může zpětné navracení hledání z většího výrazu změnit chování dílčího výrazu.</span><span class="sxs-lookup"><span data-stu-id="546f2-204">If you do not use this construct, backtracking searches from the larger expression can change the behavior of a subexpression.</span></span> <span data-ttu-id="546f2-205">Například regulární `(a+)\w` výraz odpovídá jednomu nebo více znakům "a" spolu se znakem slova, který následuje za posloupností znaků "a" a přiřazuje posloupnost znaků "a" první zachytávající skupině.</span><span class="sxs-lookup"><span data-stu-id="546f2-205">For example, the regular expression `(a+)\w` matches one or more "a" characters, along with a word character that follows the sequence of "a" characters, and assigns the sequence of "a" characters to the first capturing group.</span></span> <span data-ttu-id="546f2-206">Pokud je však konečný znak vstupního řetězce také "a", `\w` je porovnán s elementem jazyka a není zahrnut do zachycené skupiny.</span><span class="sxs-lookup"><span data-stu-id="546f2-206">However, if the final character of the input string is also an "a", it is matched by the `\w` language element and is not included in the captured group.</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#7](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/nonbacktracking2.cs#7)]
     [!code-vb[Conceptual.RegularExpressions.Design#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/nonbacktracking2.vb#7)]

     <span data-ttu-id="546f2-207">Regulární `((?>a+))\w` výraz zabraňuje tomuto chování.</span><span class="sxs-lookup"><span data-stu-id="546f2-207">The regular expression `((?>a+))\w` prevents this behavior.</span></span> <span data-ttu-id="546f2-208">Vzhledem k tomu, že všechny po sobě jdoucí znaky "a" jsou spárovány bez zpětného navracení, první zachytávající skupina obsahuje všechny po sobě jdoucí znaky "a".</span><span class="sxs-lookup"><span data-stu-id="546f2-208">Because all consecutive "a" characters are matched without backtracking, the first capturing group includes all consecutive "a" characters.</span></span> <span data-ttu-id="546f2-209">Pokud znaky "a" nejsou následovány alespoň jeden další znak než "a", shoda se nezdaří.</span><span class="sxs-lookup"><span data-stu-id="546f2-209">If the "a" characters are not followed by at least one more character other than "a", the match fails.</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#8](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/nonbacktracking1.cs#8)]
     [!code-vb[Conceptual.RegularExpressions.Design#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/nonbacktracking1.vb#8)]

     <span data-ttu-id="546f2-210">Další informace o atomických skupinách naleznete [v tématu Seskupování konstrukcí](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="546f2-210">For more information about atomic groups, see [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span></span>

- <span data-ttu-id="546f2-211">Párování zprava doleva, které je <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType> určeno <xref:System.Text.RegularExpressions.Regex> zadáním možnosti konstruktoru třídy nebo statické metody párování instancí.</span><span class="sxs-lookup"><span data-stu-id="546f2-211">Right-to-left matching, which is specified by supplying the <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType> option to a <xref:System.Text.RegularExpressions.Regex> class constructor or static instance matching method.</span></span> <span data-ttu-id="546f2-212">Tato funkce je užitečná při hledání zprava doleva namísto zleva doprava nebo v případech, kdy je efektivnější začít shodu v pravé části vzoru namísto vlevo.</span><span class="sxs-lookup"><span data-stu-id="546f2-212">This feature is useful when searching from right to left instead of from left to right, or in cases where it is more efficient to begin a match at the right part of the pattern instead of the left.</span></span> <span data-ttu-id="546f2-213">Jak ukazuje následující příklad, použití porovnávání zprava doleva může změnit chování nenasytných kvantifikátorů.</span><span class="sxs-lookup"><span data-stu-id="546f2-213">As the following example illustrates, using right-to-left matching can change the behavior of greedy quantifiers.</span></span> <span data-ttu-id="546f2-214">Příklad provádí dvě hledání věty, která končí číslem.</span><span class="sxs-lookup"><span data-stu-id="546f2-214">The example conducts two searches for a sentence that ends in a number.</span></span> <span data-ttu-id="546f2-215">Hledání zleva doprava, které používá nenasytný kvantifikátor, `+` odpovídá jedné ze šesti číslic ve větě, zatímco hledání zprava doleva odpovídá všem šesti číslicím.</span><span class="sxs-lookup"><span data-stu-id="546f2-215">The left-to-right search that uses the greedy quantifier `+` matches one of the six digits in the sentence, whereas the right-to-left search matches all six digits.</span></span> <span data-ttu-id="546f2-216">Popis vzoru regulárního výrazu naleznete v příkladu, který ilustruje opožděné kvantifikátory dříve v této části.</span><span class="sxs-lookup"><span data-stu-id="546f2-216">For a description of the regular expression pattern, see the example that illustrates lazy quantifiers earlier in this section.</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#6](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/rtl1.cs#6)]
     [!code-vb[Conceptual.RegularExpressions.Design#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/rtl1.vb#6)]

     <span data-ttu-id="546f2-217">Další informace o porovnávání zprava doleva naleznete v [tématu Možnosti regulárního výrazu](../../../docs/standard/base-types/regular-expression-options.md).</span><span class="sxs-lookup"><span data-stu-id="546f2-217">For more information about right-to-left matching, see [Regular Expression Options](../../../docs/standard/base-types/regular-expression-options.md).</span></span>

- <span data-ttu-id="546f2-218">Pozitivní a negativní `(?<=`zpětné vyhledávání: *dílčí* `)` výraz `(?<!`pro pozitivní zpětné vyhledávání a *dílčí výraz* `)` pro negativní zpětné vyhledávání.</span><span class="sxs-lookup"><span data-stu-id="546f2-218">Positive and negative lookbehind: `(?<=`*subexpression*`)` for positive lookbehind, and `(?<!`*subexpression*`)` for negative lookbehind.</span></span> <span data-ttu-id="546f2-219">Tato funkce je podobná dopředné vyhledávání, která je popsána dříve v tomto tématu.</span><span class="sxs-lookup"><span data-stu-id="546f2-219">This feature is similar to lookahead, which is discussed earlier in this topic.</span></span> <span data-ttu-id="546f2-220">Vzhledem k tomu, že modul regulárních výrazů umožňuje kompletní párování zprava doleva, umožňují regulární výrazy neomezená vyhledávání.</span><span class="sxs-lookup"><span data-stu-id="546f2-220">Because the regular expression engine allows complete right-to-left matching, regular expressions allow unrestricted lookbehinds.</span></span> <span data-ttu-id="546f2-221">Pozitivní a negativní zpětné vyhledávání lze také použít k zabránění vnoření kvantifikátory, když vnořený podvýraz je nadmnožinou vnějšího výrazu.</span><span class="sxs-lookup"><span data-stu-id="546f2-221">Positive and negative lookbehind can also be used to avoid nesting quantifiers when the nested subexpression is a superset of an outer expression.</span></span> <span data-ttu-id="546f2-222">Regulární výrazy s takovými vnořenými kvantifikátory často nabízejí nízký výkon.</span><span class="sxs-lookup"><span data-stu-id="546f2-222">Regular expressions with such nested quantifiers often offer poor performance.</span></span> <span data-ttu-id="546f2-223">Například následující příklad ověří, zda řetězec začíná a končí alfanumerickým znakem a že jakýkoli jiný znak v řetězci je jedním z větší podmnožiny.</span><span class="sxs-lookup"><span data-stu-id="546f2-223">For example, the following example verifies that a string begins and ends with an alphanumeric character, and that any other character in the string is one of a larger subset.</span></span> <span data-ttu-id="546f2-224">Tvoří část regulárního výrazu používaného k ověření e-mailových adres; Další informace naleznete v [tématu Postup: Ověření, zda jsou řetězce v platném formátu e-mailu](../../../docs/standard/base-types/how-to-verify-that-strings-are-in-valid-email-format.md).</span><span class="sxs-lookup"><span data-stu-id="546f2-224">It forms a portion of the regular expression used to validate email addresses; for more information, see [How to: Verify that Strings Are in Valid Email Format](../../../docs/standard/base-types/how-to-verify-that-strings-are-in-valid-email-format.md).</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#5](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/lookbehind1.cs#5)]
     [!code-vb[Conceptual.RegularExpressions.Design#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/lookbehind1.vb#5)]

     <span data-ttu-id="546f2-225">Regulární ``^[A-Z0-9]([-!#$%&'.*+/=?^`{}|~\w])*(?<=[A-Z0-9])$`` výraz je definován tak, jak je znázorněno v následující tabulce.</span><span class="sxs-lookup"><span data-stu-id="546f2-225">The regular expression ``^[A-Z0-9]([-!#$%&'.*+/=?^`{}|~\w])*(?<=[A-Z0-9])$`` is defined as shown in the following table.</span></span>

    |<span data-ttu-id="546f2-226">Vzor</span><span class="sxs-lookup"><span data-stu-id="546f2-226">Pattern</span></span>|<span data-ttu-id="546f2-227">Popis</span><span class="sxs-lookup"><span data-stu-id="546f2-227">Description</span></span>|
    |-------------|-----------------|
    |`^`|<span data-ttu-id="546f2-228">Začněte zápas na začátku řetězce.</span><span class="sxs-lookup"><span data-stu-id="546f2-228">Begin the match at the beginning of the string.</span></span>|
    |`[A-Z0-9]`|<span data-ttu-id="546f2-229">Porovná libovolný číselný nebo alfanumerický znak.</span><span class="sxs-lookup"><span data-stu-id="546f2-229">Match any numeric or alphanumeric character.</span></span> <span data-ttu-id="546f2-230">(Porovnání nerozlišuje malá a velká písmena.)</span><span class="sxs-lookup"><span data-stu-id="546f2-230">(The comparison is case-insensitive.)</span></span>|
    |<code>([-!#$%&'.*+/=?^\`{}&#124;~\w])\*</code>|<span data-ttu-id="546f2-231">Shodovat nula nebo více výskytů libovolného znaku slova nebo některého z následujících znaků: -, !, #, $, %, &, ', ., \*, +, /, =, ^, &#96;, {, }, &#124; nebo ~.</span><span class="sxs-lookup"><span data-stu-id="546f2-231">Match zero or more occurrences of any word character, or any of the following characters:  -, !, #, $, %, &, ', ., \*, +, /, =, ?, ^, &#96;, {, }, &#124;, or ~.</span></span>|
    |`(?<=[A-Z0-9])`|<span data-ttu-id="546f2-232">Podívejte se za předchozí znak, který musí být číselný nebo alfanumerický.</span><span class="sxs-lookup"><span data-stu-id="546f2-232">Look behind to the previous character, which must be numeric or alphanumeric.</span></span> <span data-ttu-id="546f2-233">(Porovnání nerozlišuje malá a velká písmena.)</span><span class="sxs-lookup"><span data-stu-id="546f2-233">(The comparison is case-insensitive.)</span></span>|
    |`$`|<span data-ttu-id="546f2-234">Ukončite shodu na konci řetězce.</span><span class="sxs-lookup"><span data-stu-id="546f2-234">End the match at the end of the string.</span></span>|

     <span data-ttu-id="546f2-235">Další informace o pozitivní matné a záporné zpětné vyhledávání naleznete v [tématu seskupení konstrukce](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="546f2-235">For more information about positive and negative lookbehind, see [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span></span>

## <a name="related-articles"></a><span data-ttu-id="546f2-236">Související články</span><span class="sxs-lookup"><span data-stu-id="546f2-236">Related articles</span></span>

|<span data-ttu-id="546f2-237">Nadpis</span><span class="sxs-lookup"><span data-stu-id="546f2-237">Title</span></span>|<span data-ttu-id="546f2-238">Popis</span><span class="sxs-lookup"><span data-stu-id="546f2-238">Description</span></span>|
|-----------|-----------------|
|[<span data-ttu-id="546f2-239">Zpětné navracení</span><span class="sxs-lookup"><span data-stu-id="546f2-239">Backtracking</span></span>](../../../docs/standard/base-types/backtracking-in-regular-expressions.md)|<span data-ttu-id="546f2-240">Obsahuje informace o tom, jak regulární výraz backtracking větve najít alternativní shody.</span><span class="sxs-lookup"><span data-stu-id="546f2-240">Provides information about how regular expression backtracking branches to find alternative matches.</span></span>|
|[<span data-ttu-id="546f2-241">Kompilace a opětovné používání</span><span class="sxs-lookup"><span data-stu-id="546f2-241">Compilation and Reuse</span></span>](../../../docs/standard/base-types/compilation-and-reuse-in-regular-expressions.md)|<span data-ttu-id="546f2-242">Obsahuje informace o kompilaci a opakovaném použití regulárních výrazů pro zvýšení výkonu.</span><span class="sxs-lookup"><span data-stu-id="546f2-242">Provides information about compiling and reusing regular expressions to increase performance.</span></span>|
|[<span data-ttu-id="546f2-243">Bezpečnost vlákna</span><span class="sxs-lookup"><span data-stu-id="546f2-243">Thread Safety</span></span>](../../../docs/standard/base-types/thread-safety-in-regular-expressions.md)|<span data-ttu-id="546f2-244">Obsahuje informace o bezpečnosti podprocesu regulárních výrazů a vysvětluje, kdy byste měli synchronizovat přístup k objektům regulárních výrazů.</span><span class="sxs-lookup"><span data-stu-id="546f2-244">Provides information about regular expression thread safety and explains when you should synchronize access to regular expression objects.</span></span>|
|[<span data-ttu-id="546f2-245">.NET Framework – regulární výrazy</span><span class="sxs-lookup"><span data-stu-id="546f2-245">.NET Framework Regular Expressions</span></span>](../../../docs/standard/base-types/regular-expressions.md)|<span data-ttu-id="546f2-246">Poskytuje přehled aspektu programovacího jazyka regulárních výrazů.</span><span class="sxs-lookup"><span data-stu-id="546f2-246">Provides an overview of the programming language aspect of regular expressions.</span></span>|
|[<span data-ttu-id="546f2-247">Model objektu regulárního výrazu</span><span class="sxs-lookup"><span data-stu-id="546f2-247">The Regular Expression Object Model</span></span>](../../../docs/standard/base-types/the-regular-expression-object-model.md)|<span data-ttu-id="546f2-248">Obsahuje informace a příklady kódu znázorňující, jak používat třídy regulárních výrazů.</span><span class="sxs-lookup"><span data-stu-id="546f2-248">Provides information and code examples illustrating how to use the regular expression classes.</span></span>|
|[<span data-ttu-id="546f2-249">Jazyk regulárních výrazů – stručná referenční dokumentace</span><span class="sxs-lookup"><span data-stu-id="546f2-249">Regular Expression Language - Quick Reference</span></span>](../../../docs/standard/base-types/regular-expression-language-quick-reference.md)|<span data-ttu-id="546f2-250">Obsahuje informace o sadě znaků, operátorů a konstrukcí, které lze použít k definování regulárních výrazů.</span><span class="sxs-lookup"><span data-stu-id="546f2-250">Provides information about the set of characters, operators, and constructs that you can use to define regular expressions.</span></span>|

## <a name="reference"></a><span data-ttu-id="546f2-251">Odkaz</span><span class="sxs-lookup"><span data-stu-id="546f2-251">Reference</span></span>

- <xref:System.Text.RegularExpressions?displayProperty=nameWithType>
