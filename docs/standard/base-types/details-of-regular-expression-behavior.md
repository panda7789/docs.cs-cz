---
title: Chování regulárního výrazu
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- regular expressions, behavior
- .NET Framework regular expressions, behavior
ms.assetid: 0ee1a6b8-caac-41d2-917f-d35570021b10
ms.openlocfilehash: af812e1e42d57c349e94b5992b768636857d2a0c
ms.sourcegitcommit: 30a558d23e3ac5a52071121a52c305c85fe15726
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 12/25/2019
ms.locfileid: "75348272"
---
# <a name="details-of-regular-expression-behavior"></a><span data-ttu-id="f6e53-102">Podrobnosti o chování regulárních výrazů</span><span class="sxs-lookup"><span data-stu-id="f6e53-102">Details of regular expression behavior</span></span>

<span data-ttu-id="f6e53-103">.NET Framework modul regulárních výrazů je zpětné navýšení shody regulárních výrazů, která zahrnuje tradiční Nedeterministický NFA modul pro nedeterministické konečné Automation (), jako je například jazyk Perl, Python, (Emacs) a TCL.</span><span class="sxs-lookup"><span data-stu-id="f6e53-103">The .NET Framework regular expression engine is a backtracking regular expression matcher that incorporates a traditional Nondeterministic Finite Automaton (NFA) engine such as that used by Perl, Python, Emacs, and Tcl.</span></span> <span data-ttu-id="f6e53-104">Tím se odlišuje od rychlejšího, ale více omezených, čistě regulárního výrazu deterministického Automation (DFA) modulů, jako jsou ty, které se našly v AWK mají, egrep nebo Lex.</span><span class="sxs-lookup"><span data-stu-id="f6e53-104">This distinguishes it from faster, but more limited, pure regular expression Deterministic Finite Automaton (DFA) engines such as those found in awk, egrep, or lex.</span></span> <span data-ttu-id="f6e53-105">Tím se také odlišuje od standardizovaného, ale pomalejšího NFAsu POSIX.</span><span class="sxs-lookup"><span data-stu-id="f6e53-105">This also distinguishes it from standardized, but slower, POSIX NFAs.</span></span> <span data-ttu-id="f6e53-106">V následující části jsou popsány tři typy modulů regulárních výrazů a vysvětlení, proč jsou regulární výrazy v .NET Framework implementovány pomocí tradičního modulu NFA.</span><span class="sxs-lookup"><span data-stu-id="f6e53-106">The following section describes the three types of regular expression engines, and explains why regular expressions in the .NET Framework are implemented by using a traditional NFA engine.</span></span>

## <a name="benefits-of-the-nfa-engine"></a><span data-ttu-id="f6e53-107">Výhody modulu NFA</span><span class="sxs-lookup"><span data-stu-id="f6e53-107">Benefits of the NFA engine</span></span>

 <span data-ttu-id="f6e53-108">Pokud DFA moduly provádějí porovnávání vzorů, jejich pořadí zpracování je ovládáno vstupním řetězcem.</span><span class="sxs-lookup"><span data-stu-id="f6e53-108">When DFA engines perform pattern matching, their processing order is driven by the input string.</span></span> <span data-ttu-id="f6e53-109">Modul začíná na začátku vstupního řetězce a pokračuje sekvenčně a určí, zda se další znak shoduje se vzorem regulárního výrazu.</span><span class="sxs-lookup"><span data-stu-id="f6e53-109">The engine begins at the beginning of the input string and proceeds sequentially to determine whether the next character matches the regular expression pattern.</span></span> <span data-ttu-id="f6e53-110">Můžou zaručit, aby odpovídaly nejdelšímu možnému řetězci.</span><span class="sxs-lookup"><span data-stu-id="f6e53-110">They can guarantee to match the longest string possible.</span></span> <span data-ttu-id="f6e53-111">Vzhledem k tomu, že nikdy netestují stejný znak dvakrát, DFA moduly nepodporují navrácení.</span><span class="sxs-lookup"><span data-stu-id="f6e53-111">Because they never test the same character twice, DFA engines do not support backtracking.</span></span> <span data-ttu-id="f6e53-112">Vzhledem k tomu, že modul DFA obsahuje pouze omezený stav, nemůže odpovídat vzoru s zpětnými odkazy a protože nevytváří explicitní rozšíření, nemůže zachytit dílčí výrazy.</span><span class="sxs-lookup"><span data-stu-id="f6e53-112">However, because a DFA engine contains only finite state, it cannot match a pattern with backreferences, and because it does not construct an explicit expansion, it cannot capture subexpressions.</span></span>

 <span data-ttu-id="f6e53-113">Na rozdíl od DFA modulů, když tradiční moduly NFA provádějí porovnávání vzorů, jejich pořadí zpracování je založené na vzoru regulárního výrazu.</span><span class="sxs-lookup"><span data-stu-id="f6e53-113">Unlike DFA engines, when traditional NFA engines perform pattern matching, their processing order is driven by the regular expression pattern.</span></span> <span data-ttu-id="f6e53-114">Při zpracovávání konkrétního prvku jazyka používá modul hladový koshodě; To znamená, že odpovídá největšímu vstupnímu řetězci, což může být.</span><span class="sxs-lookup"><span data-stu-id="f6e53-114">As it processes a particular language element, the engine uses greedy matching; that is, it matches as much of the input string as it possibly can.</span></span> <span data-ttu-id="f6e53-115">Ale také uloží svůj stav po úspěšném porovnání dílčího výrazu.</span><span class="sxs-lookup"><span data-stu-id="f6e53-115">But it also saves its state after successfully matching a subexpression.</span></span> <span data-ttu-id="f6e53-116">Pokud se shoda nakonec nezdařila, může se modul vrátit do uloženého stavu, aby se mohl pokusit o další shody.</span><span class="sxs-lookup"><span data-stu-id="f6e53-116">If a match eventually fails, the engine can return to a saved state so it can try additional matches.</span></span> <span data-ttu-id="f6e53-117">Tento proces opuštění úspěšné shody dílčího výrazu, aby se pozdější prvky jazyka regulárního výrazu mohly také shodovat, se označují jako *zpětné navrácení*.</span><span class="sxs-lookup"><span data-stu-id="f6e53-117">This process of abandoning a successful subexpression match so that later language elements in the regular expression can also match is known as *backtracking*.</span></span> <span data-ttu-id="f6e53-118">NFA moduly používají navrácení se změnami k otestování všech možných rozšíření regulárního výrazu v určitém pořadí a přijímají první shodu.</span><span class="sxs-lookup"><span data-stu-id="f6e53-118">NFA engines use backtracking to test all possible expansions of a regular expression in a specific order and accept the first match.</span></span> <span data-ttu-id="f6e53-119">Vzhledem k tomu, že tradiční modul NFA sestaví konkrétní rozšíření regulárního výrazu pro úspěšnou shodu, může zachytit shody dílčího výrazu a porovnat zpětná reference.</span><span class="sxs-lookup"><span data-stu-id="f6e53-119">Because a traditional NFA engine constructs a specific expansion of the regular expression for a successful match, it can capture subexpression matches and matching backreferences.</span></span> <span data-ttu-id="f6e53-120">Vzhledem k tomu, že tradiční NFAé zpětné navrácení, může přejít stejný stav několikrát, pokud dorazí na stav prostřednictvím různých cest.</span><span class="sxs-lookup"><span data-stu-id="f6e53-120">However, because a traditional NFA backtracks, it can visit the same state multiple times if it arrives at the state over different paths.</span></span> <span data-ttu-id="f6e53-121">V důsledku toho může v nejhorším případě běžet exponenciálně pomalu.</span><span class="sxs-lookup"><span data-stu-id="f6e53-121">As a result, it can run exponentially slowly in the worst case.</span></span> <span data-ttu-id="f6e53-122">Vzhledem k tomu, že tradiční modul NFA akceptuje první nalezenou shodu, může také ponechávat jiné (pravděpodobně delší) shody, které se neobjevují.</span><span class="sxs-lookup"><span data-stu-id="f6e53-122">Because a traditional NFA engine accepts the first match it finds, it can also leave other (possibly longer) matches undiscovered.</span></span>

 <span data-ttu-id="f6e53-123">NFA moduly POSIX jsou podobné tradičním NFAm modulům, s tím rozdílem, že se budou i nadále přepracovat, dokud nebudou zárukou, že by zjistili nejdelší možný rozdíl.</span><span class="sxs-lookup"><span data-stu-id="f6e53-123">POSIX NFA engines are like traditional NFA engines, except that they continue to backtrack until they can guarantee that they have found the longest match possible.</span></span> <span data-ttu-id="f6e53-124">Výsledkem je, že NFA modul POSIX je pomalejší než tradiční modul NFA a když používáte modul NFA POSIX, nemůžete upřednostnit kratší porovnání po delším pořadí, protože se mění pořadí hledání zpětného navrácení.</span><span class="sxs-lookup"><span data-stu-id="f6e53-124">As a result, a POSIX NFA engine is slower than a traditional NFA engine, and when you use a POSIX NFA engine, you cannot favor a shorter match over a longer one by changing the order of the backtracking search.</span></span>

 <span data-ttu-id="f6e53-125">Tradiční moduly NFA se přidávají programátorům, protože nabízejí větší kontrolu nad řetězcovým porovnáním, než DFA nebo POSIX NFA Engines.</span><span class="sxs-lookup"><span data-stu-id="f6e53-125">Traditional NFA engines are favored by programmers because they offer greater control over string matching than either DFA or POSIX NFA engines.</span></span> <span data-ttu-id="f6e53-126">I když v nejhorším případě může běžet pomalu, můžete je pomocí vzorů, které snižují nejednoznačnosti a omezením zpětného navrácení, nařídit, aby vyhledaly shody lineární nebo polynom.</span><span class="sxs-lookup"><span data-stu-id="f6e53-126">Although, in the worst case, they can run slowly, you can steer them to find matches in linear or polynomial time by using patterns that reduce ambiguities and limit backtracking.</span></span> <span data-ttu-id="f6e53-127">Jinými slovy, i když NFA stroje v obchodním výkonu pro výkon a flexibilitu, ve většině případů nabízí dobrý výkon, pokud je regulární výraz dobře napsaný, a zabrání tak případům, kdy zpětné navrácení snižuje výkon exponenciálně.</span><span class="sxs-lookup"><span data-stu-id="f6e53-127">In other words, although NFA engines trade performance for power and flexibility, in most cases they offer good to acceptable performance if a regular expression is well written and avoids cases in which backtracking degrades performance exponentially.</span></span>

> [!NOTE]
> <span data-ttu-id="f6e53-128">Informace o penalizaci výkonu způsobené nadměrným navrácením a způsoby, jak vymezit regulární výrazy, najdete v tématu [navrácení](../../../docs/standard/base-types/backtracking-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="f6e53-128">For information about the performance penalty caused by excessive backtracking and ways to craft a regular expression to work around them, see [Backtracking](../../../docs/standard/base-types/backtracking-in-regular-expressions.md).</span></span>

## <a name="net-framework-engine-capabilities"></a><span data-ttu-id="f6e53-129">Možnosti modulu .NET Framework</span><span class="sxs-lookup"><span data-stu-id="f6e53-129">.NET Framework engine capabilities</span></span>

 <span data-ttu-id="f6e53-130">Aby bylo možné využít výhody tradičního stroje NFA, modul regulárních výrazů .NET Framework obsahuje kompletní sadu konstrukcí, která programátorům umožní řídit modul pro navrácení.</span><span class="sxs-lookup"><span data-stu-id="f6e53-130">To take advantage of the benefits of a traditional NFA engine, the .NET Framework regular expression engine includes a complete set of constructs to enable programmers to steer the backtracking engine.</span></span> <span data-ttu-id="f6e53-131">Tyto konstrukce lze použít k vyhledání shody rychleji nebo k upřednostnění konkrétního rozšíření přes jiné.</span><span class="sxs-lookup"><span data-stu-id="f6e53-131">These constructs can be used to find matches faster or to favor specific expansions over others.</span></span>

 <span data-ttu-id="f6e53-132">Mezi další funkce modulu .NET Framework regulárních výrazů patří následující:</span><span class="sxs-lookup"><span data-stu-id="f6e53-132">Other features of the .NET Framework regular expression engine include the following:</span></span>

- <span data-ttu-id="f6e53-133">Opožděné kvantifikátory: `??`, `*?`, `+?`, `{`*n*`,`*m*`}?`.</span><span class="sxs-lookup"><span data-stu-id="f6e53-133">Lazy quantifiers: `??`, `*?`, `+?`, `{`*n*`,`*m*`}?`.</span></span> <span data-ttu-id="f6e53-134">Tyto konstrukce instruují modul zpětného navrácení, aby nejdříve hledali minimální počet opakování.</span><span class="sxs-lookup"><span data-stu-id="f6e53-134">These constructs tell the backtracking engine to search the minimum number of repetitions first.</span></span> <span data-ttu-id="f6e53-135">Oproti tomu běžné hladové kvantifikátory se snaží vyhledat maximální počet opakování jako první.</span><span class="sxs-lookup"><span data-stu-id="f6e53-135">In contrast, ordinary greedy quantifiers try to match the maximum number of repetitions first.</span></span> <span data-ttu-id="f6e53-136">Následující příklad znázorňuje rozdíl mezi těmito dvěma.</span><span class="sxs-lookup"><span data-stu-id="f6e53-136">The following example illustrates the difference between the two.</span></span> <span data-ttu-id="f6e53-137">Regulární výraz odpovídá větě, která končí číslem, a zachytávající skupina je určena k extrakci daného čísla.</span><span class="sxs-lookup"><span data-stu-id="f6e53-137">A regular expression matches a sentence that ends in a number, and a capturing group is intended to extract that number.</span></span> <span data-ttu-id="f6e53-138">Regulární výraz `.+(\d+)\.` zahrnuje hladce `.+`, což způsobí, že modul regulárních výrazů zachytí pouze poslední číslici čísla.</span><span class="sxs-lookup"><span data-stu-id="f6e53-138">The regular expression `.+(\d+)\.` includes the greedy quantifier `.+`, which causes the regular expression engine to capture only the last digit of the number.</span></span> <span data-ttu-id="f6e53-139">Naopak regulární výraz `.+?(\d+)\.` zahrnuje opožděný kvantifikátor `.+?`, což způsobí, že modul regulárních výrazů zachytí celé číslo.</span><span class="sxs-lookup"><span data-stu-id="f6e53-139">In contrast, the regular expression `.+?(\d+)\.` includes the lazy quantifier `.+?`, which causes the regular expression engine to capture the entire number.</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/lazy1.cs#1)]
     [!code-vb[Conceptual.RegularExpressions.Design#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/lazy1.vb#1)]

     <span data-ttu-id="f6e53-140">Hladce a opožděné verze tohoto regulárního výrazu jsou definovány tak, jak je uvedeno v následující tabulce:</span><span class="sxs-lookup"><span data-stu-id="f6e53-140">The greedy and lazy versions of this regular expression are defined as shown in the following table:</span></span>

    |<span data-ttu-id="f6e53-141">Vzor</span><span class="sxs-lookup"><span data-stu-id="f6e53-141">Pattern</span></span>|<span data-ttu-id="f6e53-142">Popis</span><span class="sxs-lookup"><span data-stu-id="f6e53-142">Description</span></span>|
    |-------------|-----------------|
    |<span data-ttu-id="f6e53-143">`.+` (hladce kvantifikátor)</span><span class="sxs-lookup"><span data-stu-id="f6e53-143">`.+` (greedy quantifier)</span></span>|<span data-ttu-id="f6e53-144">Porovnává alespoň jeden výskyt libovolného znaku.</span><span class="sxs-lookup"><span data-stu-id="f6e53-144">Match at least one occurrence of any character.</span></span> <span data-ttu-id="f6e53-145">To způsobí, že modul regulárních výrazů bude odpovídat celému řetězci a následně k převrácení podle potřeby, aby odpovídal zbývajícímu vzoru.</span><span class="sxs-lookup"><span data-stu-id="f6e53-145">This causes the regular expression engine to match the entire string, and then to backtrack as needed to match the remainder of the pattern.</span></span>|
    |<span data-ttu-id="f6e53-146">`.+?` (opožděný kvantifikátor)</span><span class="sxs-lookup"><span data-stu-id="f6e53-146">`.+?` (lazy quantifier)</span></span>|<span data-ttu-id="f6e53-147">Porovnává alespoň jeden výskyt libovolného znaku, ale porovnává co nejvíce.</span><span class="sxs-lookup"><span data-stu-id="f6e53-147">Match at least one occurrence of any character, but match as few as possible.</span></span>|
    |`(\d+)`|<span data-ttu-id="f6e53-148">Porovnává alespoň jeden číselný znak a přiřadí ho první zachytávající skupině.</span><span class="sxs-lookup"><span data-stu-id="f6e53-148">Match at least one numeric character, and assign it to the first capturing group.</span></span>|
    |`\.`|<span data-ttu-id="f6e53-149">Odpovídá tečkě.</span><span class="sxs-lookup"><span data-stu-id="f6e53-149">Match a period.</span></span>|

     <span data-ttu-id="f6e53-150">Další informace o opožděných kvantifikátorech naleznete v tématu [kvantifikátory](../../../docs/standard/base-types/quantifiers-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="f6e53-150">For more information about lazy quantifiers, see [Quantifiers](../../../docs/standard/base-types/quantifiers-in-regular-expressions.md).</span></span>

- <span data-ttu-id="f6e53-151">Pozitivní dopředného vyhledávání:`)``(?=`dílčího *výrazu* .</span><span class="sxs-lookup"><span data-stu-id="f6e53-151">Positive lookahead: `(?=`*subexpression*`)`.</span></span> <span data-ttu-id="f6e53-152">Tato funkce umožňuje, aby se modul zpětného navracení vrátil na stejné místo v textu po porovnání dílčího výrazu.</span><span class="sxs-lookup"><span data-stu-id="f6e53-152">This feature allows the backtracking engine to return to the same spot in the text after matching a subexpression.</span></span> <span data-ttu-id="f6e53-153">Je užitečné Hledat v celém textu tím, že ověřuje více vzorů, které začínají na stejné pozici.</span><span class="sxs-lookup"><span data-stu-id="f6e53-153">It is useful for searching throughout the text by verifying multiple patterns that start from the same position.</span></span> <span data-ttu-id="f6e53-154">Umožňuje modulu také ověřit, zda podřetězec existuje na konci porovnávání bez zahrnutí podřetězce do odpovídajícího textu.</span><span class="sxs-lookup"><span data-stu-id="f6e53-154">It also allows the engine to verify that a substring exists at the end of the match without including the substring in the matched text.</span></span> <span data-ttu-id="f6e53-155">Následující příklad používá pozitivní dopředného vyhledávání k extrakci slov ve větě, která nejsou následována symboly interpunkce.</span><span class="sxs-lookup"><span data-stu-id="f6e53-155">The following example uses positive lookahead to extract the words in a sentence that are not followed by punctuation symbols.</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#2](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/lookahead1.cs#2)]
     [!code-vb[Conceptual.RegularExpressions.Design#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/lookahead1.vb#2)]

     <span data-ttu-id="f6e53-156">Regulární výraz `\b[A-Z]+\b(?=\P{P})` je definován tak, jak je uvedeno v následující tabulce.</span><span class="sxs-lookup"><span data-stu-id="f6e53-156">The regular expression `\b[A-Z]+\b(?=\P{P})` is defined as shown in the following table.</span></span>

    |<span data-ttu-id="f6e53-157">Vzor</span><span class="sxs-lookup"><span data-stu-id="f6e53-157">Pattern</span></span>|<span data-ttu-id="f6e53-158">Popis</span><span class="sxs-lookup"><span data-stu-id="f6e53-158">Description</span></span>|
    |-------------|-----------------|
    |`\b`|<span data-ttu-id="f6e53-159">Začne porovnání na hranici slova.</span><span class="sxs-lookup"><span data-stu-id="f6e53-159">Begin the match at a word boundary.</span></span>|
    |`[A-Z]+`|<span data-ttu-id="f6e53-160">Porovnává libovolný abecední znak jednou nebo vícekrát.</span><span class="sxs-lookup"><span data-stu-id="f6e53-160">Match any alphabetic character one or more times.</span></span> <span data-ttu-id="f6e53-161">Vzhledem k tomu, že metoda <xref:System.Text.RegularExpressions.Regex.Matches%2A?displayProperty=nameWithType> je volána s možností <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType>, porovnávání nerozlišuje malá a velká písmena.</span><span class="sxs-lookup"><span data-stu-id="f6e53-161">Because the <xref:System.Text.RegularExpressions.Regex.Matches%2A?displayProperty=nameWithType> method is called with the <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> option, the comparison is case-insensitive.</span></span>|
    |`\b`|<span data-ttu-id="f6e53-162">Ukončí porovnání na hranici slova.</span><span class="sxs-lookup"><span data-stu-id="f6e53-162">End the match at a word boundary.</span></span>|
    |`(?=\P{P})`|<span data-ttu-id="f6e53-163">Před zjištěním, zda je další znak symbol interpunkce, se podívejte dopředu.</span><span class="sxs-lookup"><span data-stu-id="f6e53-163">Look ahead to determine whether the next character is a punctuation symbol.</span></span> <span data-ttu-id="f6e53-164">Pokud tomu tak není, bude shoda úspěšná.</span><span class="sxs-lookup"><span data-stu-id="f6e53-164">If it is not, the match succeeds.</span></span>|

     <span data-ttu-id="f6e53-165">Další informace o kladném kontrolním výrazu dopředného vyhledávání naleznete v tématu [Grouping konstrukcís](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="f6e53-165">For more information about positive lookahead assertions, see [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span></span>

- <span data-ttu-id="f6e53-166">Negativní dopředného vyhledávání:`)``(?!`dílčího *výrazu* .</span><span class="sxs-lookup"><span data-stu-id="f6e53-166">Negative lookahead: `(?!`*subexpression*`)`.</span></span> <span data-ttu-id="f6e53-167">Tato funkce přidá schopnost vyhledat výraz pouze v případě, že se dílčí výraz neshoduje.</span><span class="sxs-lookup"><span data-stu-id="f6e53-167">This feature adds the ability to match an expression only if a subexpression fails to match.</span></span> <span data-ttu-id="f6e53-168">To je obzvláště výkonné pro vyřazení hledání, protože je často jednodušší poskytnout výraz pro případ, který by se měl vyloučit než výraz pro případy, které musí být zahrnuté.</span><span class="sxs-lookup"><span data-stu-id="f6e53-168">This is particularly powerful for pruning a search, because it is often simpler to provide an expression for a case that should be eliminated than an expression for cases that must be included.</span></span> <span data-ttu-id="f6e53-169">Například je obtížné napsat výraz pro slova, která nezačínají na "non".</span><span class="sxs-lookup"><span data-stu-id="f6e53-169">For example, it is difficult to write an expression for words that do not begin with "non".</span></span> <span data-ttu-id="f6e53-170">Následující příklad používá negativní dopředné vyhledávání k vyloučení.</span><span class="sxs-lookup"><span data-stu-id="f6e53-170">The following example uses negative lookahead to exclude them.</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#3](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/lookahead2.cs#3)]
     [!code-vb[Conceptual.RegularExpressions.Design#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/lookahead2.vb#3)]

     <span data-ttu-id="f6e53-171">Vzor regulárního výrazu `\b(?!non)\w+\b` je definován tak, jak je uvedeno v následující tabulce.</span><span class="sxs-lookup"><span data-stu-id="f6e53-171">The regular expression pattern `\b(?!non)\w+\b` is defined as shown in the following table.</span></span>

    |<span data-ttu-id="f6e53-172">Vzor</span><span class="sxs-lookup"><span data-stu-id="f6e53-172">Pattern</span></span>|<span data-ttu-id="f6e53-173">Popis</span><span class="sxs-lookup"><span data-stu-id="f6e53-173">Description</span></span>|
    |-------------|-----------------|
    |`\b`|<span data-ttu-id="f6e53-174">Začne porovnání na hranici slova.</span><span class="sxs-lookup"><span data-stu-id="f6e53-174">Begin the match at a word boundary.</span></span>|
    |`(?!non)`|<span data-ttu-id="f6e53-175">Prohlédněte si, abyste zajistili, že aktuální řetězec nezačíná na "non".</span><span class="sxs-lookup"><span data-stu-id="f6e53-175">Look ahead to ensure that the current string does not begin with "non".</span></span> <span data-ttu-id="f6e53-176">Pokud k tomu dojde, shoda se nezdařila.</span><span class="sxs-lookup"><span data-stu-id="f6e53-176">If it does, the match fails.</span></span>|
    |`(\w+)`|<span data-ttu-id="f6e53-177">Porovná jeden nebo více znaků slova.</span><span class="sxs-lookup"><span data-stu-id="f6e53-177">Match one or more word characters.</span></span>|
    |`\b`|<span data-ttu-id="f6e53-178">Ukončí porovnání na hranici slova.</span><span class="sxs-lookup"><span data-stu-id="f6e53-178">End the match at a word boundary.</span></span>|

     <span data-ttu-id="f6e53-179">Další informace o záporné kontrolní výrazy dopředného vyhledávání naleznete v tématu [Grouping konstrukcís](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="f6e53-179">For more information about negative lookahead assertions, see [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span></span>

- <span data-ttu-id="f6e53-180">Podmíněné vyhodnocení: `(?(`*výraz*`)`*yes*`|`*žádný*`)` a `(?(`*název*`)`*Yes*`|`*No*`)`, kde *Expression* je dílčí výraz, který se má shodovat, *název* je název zachytávající skupiny, *Ano* je řetězec, který se má shodovat, pokud je *výraz* shodný nebo je *název* platnou, neprázdnou zachycenou skupinou, a *ne* je dílčí výraz, který se má shodovat *s výrazem if* není shodná nebo *název* není platnou zachycenou skupinou, která není prázdná.</span><span class="sxs-lookup"><span data-stu-id="f6e53-180">Conditional evaluation: `(?(`*expression*`)`*yes*`|`*no*`)` and `(?(`*name*`)`*yes*`|`*no*`)`, where *expression* is a subexpression to match, *name* is the name of a capturing group, *yes* is the string to match if *expression* is matched or *name* is a valid, non-empty captured group, and *no* is the subexpression to match if *expression* is not matched or *name* is not a valid, non-empty captured group.</span></span> <span data-ttu-id="f6e53-181">Tato funkce umožňuje modulu vyhledávat pomocí více než jednoho alternativního vzoru, v závislosti na výsledku předchozího dílčího výrazu nebo výsledku kontrolního výrazu s nulovou šířkou.</span><span class="sxs-lookup"><span data-stu-id="f6e53-181">This feature allows the engine to search by using more than one alternate pattern, depending on the result of a previous subexpression match or the result of a zero-width assertion.</span></span> <span data-ttu-id="f6e53-182">To umožňuje výkonnější formu zpětného odkazování, které umožňuje například porovnání dílčího výrazu na základě toho, zda byl předchozí dílčí výraz spárován.</span><span class="sxs-lookup"><span data-stu-id="f6e53-182">This allows a more powerful form of backreference that permits, for example, matching a subexpression based on whether a previous subexpression was matched.</span></span> <span data-ttu-id="f6e53-183">Regulární výraz v následujícím příkladu odpovídá odstavcům, které jsou určeny pro veřejné i interní použití.</span><span class="sxs-lookup"><span data-stu-id="f6e53-183">The regular expression in the following example matches paragraphs that are intended for both public and internal use.</span></span> <span data-ttu-id="f6e53-184">Odstavce určené pouze pro interní použití začínají značkou `<PRIVATE>`.</span><span class="sxs-lookup"><span data-stu-id="f6e53-184">Paragraphs intended only for internal use begin with a `<PRIVATE>` tag.</span></span> <span data-ttu-id="f6e53-185">Vzor regulárního výrazu `^(?<Pvt>\<PRIVATE\>\s)?(?(Pvt)((\w+\p{P}?\s)+)|((\w+\p{P}?\s)+))\r?$` používá podmíněné vyhodnocení k přiřazení obsahu odstavců určených veřejnosti a k internímu použití pro oddělení zachycujících skupin.</span><span class="sxs-lookup"><span data-stu-id="f6e53-185">The regular expression pattern `^(?<Pvt>\<PRIVATE\>\s)?(?(Pvt)((\w+\p{P}?\s)+)|((\w+\p{P}?\s)+))\r?$` uses conditional evaluation to assign the contents of paragraphs intended for public and for internal use to separate capturing groups.</span></span> <span data-ttu-id="f6e53-186">Tyto odstavce pak můžete zpracovat odlišně.</span><span class="sxs-lookup"><span data-stu-id="f6e53-186">These paragraphs can then be handled differently.</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#4](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/conditional1.cs#4)]
     [!code-vb[Conceptual.RegularExpressions.Design#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/conditional1.vb#4)]

     <span data-ttu-id="f6e53-187">Vzor regulárního výrazu je definován tak, jak je uvedeno v následující tabulce.</span><span class="sxs-lookup"><span data-stu-id="f6e53-187">The regular expression pattern is defined as shown in the following table.</span></span>

    |<span data-ttu-id="f6e53-188">Vzor</span><span class="sxs-lookup"><span data-stu-id="f6e53-188">Pattern</span></span>|<span data-ttu-id="f6e53-189">Popis</span><span class="sxs-lookup"><span data-stu-id="f6e53-189">Description</span></span>|
    |-------------|-----------------|
    |`^`|<span data-ttu-id="f6e53-190">Zahájí porovnávání na začátku řádku.</span><span class="sxs-lookup"><span data-stu-id="f6e53-190">Begin the match at the beginning of a line.</span></span>|
    |`(?<Pvt>\<PRIVATE\>\s)?`|<span data-ttu-id="f6e53-191">Porovná žádný nebo jeden výskyt řetězce `<PRIVATE>` následovaný prázdným znakem.</span><span class="sxs-lookup"><span data-stu-id="f6e53-191">Match zero or one occurrence of the string `<PRIVATE>` followed by a white-space character.</span></span> <span data-ttu-id="f6e53-192">Přiřaďte shodu ke skupině zachycení s názvem `Pvt`.</span><span class="sxs-lookup"><span data-stu-id="f6e53-192">Assign the match to a capturing group named `Pvt`.</span></span>|
    |`(?(Pvt)((\w+\p{P}?\s)+)`|<span data-ttu-id="f6e53-193">Pokud `Pvt` zachytávající skupina existuje, porovná jeden nebo více výskytů jednoho nebo více znaků slova následovaných žádným nebo jedním oddělovačem interpunkce následovaným prázdným znakem.</span><span class="sxs-lookup"><span data-stu-id="f6e53-193">If the `Pvt` capturing group exists, match one or more occurrences of one or more word characters followed by zero or one punctuation separator followed by a white-space character.</span></span> <span data-ttu-id="f6e53-194">Přiřaďte dílčí řetězec k první zachytávající skupině.</span><span class="sxs-lookup"><span data-stu-id="f6e53-194">Assign the substring to the first capturing group.</span></span>|
    |<code>&#124;((\w+\p{P}?\s)+))</code>|<span data-ttu-id="f6e53-195">Pokud `Pvt` zachytávající skupina neexistuje, porovná jeden nebo více výskytů jednoho nebo více znaků slova následovaných žádným nebo jedním oddělovačem interpunkčních znamének následovaným prázdným znakem.</span><span class="sxs-lookup"><span data-stu-id="f6e53-195">If the `Pvt` capturing group does not exist, match one or more occurrences of one or more word characters followed by zero or one punctuation separator followed by a white-space character.</span></span> <span data-ttu-id="f6e53-196">Přiřaďte podřetězec třetí zachytávající skupině.</span><span class="sxs-lookup"><span data-stu-id="f6e53-196">Assign the substring to the third capturing group.</span></span>|
    |`\r?$`|<span data-ttu-id="f6e53-197">Odpovídá konci řádku nebo konci řetězce.</span><span class="sxs-lookup"><span data-stu-id="f6e53-197">Match the end of a line or the end of the string.</span></span>|

     <span data-ttu-id="f6e53-198">Další informace o podmíněném vyhodnocení naleznete v tématu [konstrukce alternace](../../../docs/standard/base-types/alternation-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="f6e53-198">For more information about conditional evaluation, see [Alternation Constructs](../../../docs/standard/base-types/alternation-constructs-in-regular-expressions.md).</span></span>

- <span data-ttu-id="f6e53-199">Definice vyrovnávání skupin: `(?<`*název1*`-`*název2*`>` dílčí *výraz*`)`.</span><span class="sxs-lookup"><span data-stu-id="f6e53-199">Balancing group definitions: `(?<`*name1*`-`*name2*`>` *subexpression*`)`.</span></span> <span data-ttu-id="f6e53-200">Tato funkce umožňuje modulu regulárních výrazů sledovat vnořené konstrukce, jako jsou závorky nebo levou a pravou hranaté závorky.</span><span class="sxs-lookup"><span data-stu-id="f6e53-200">This feature allows the regular expression engine to keep track of nested constructs such as parentheses or opening and closing brackets.</span></span> <span data-ttu-id="f6e53-201">Příklad naleznete v tématu [Grouping konstrukcís](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="f6e53-201">For an example, see [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span></span>

- <span data-ttu-id="f6e53-202">Dílčí výrazy bez mechanismu navracení (označované také jako hladové podvýrazy): `(?>`dílčí *výraz*`)`.</span><span class="sxs-lookup"><span data-stu-id="f6e53-202">Nonbacktracking subexpressions (also known as greedy subexpressions): `(?>`*subexpression*`)`.</span></span> <span data-ttu-id="f6e53-203">Tato funkce umožňuje modulu zpětného navrácení, aby se zaručilo, že dílčí výraz odpovídá pouze první shodě nalezené pro tento dílčí výraz, jako kdyby byl výraz spuštěn nezávisle na jeho obsahujícím výrazu.</span><span class="sxs-lookup"><span data-stu-id="f6e53-203">This feature allows the backtracking engine to guarantee that a subexpression matches only the first match found for that subexpression, as if the expression were running independent of its containing expression.</span></span> <span data-ttu-id="f6e53-204">Pokud nepoužijete tuto konstrukci, hledání zpětného navrácení z většího výrazu může změnit chování dílčího výrazu.</span><span class="sxs-lookup"><span data-stu-id="f6e53-204">If you do not use this construct, backtracking searches from the larger expression can change the behavior of a subexpression.</span></span> <span data-ttu-id="f6e53-205">Například regulární výraz `(a+)\w` odpovídá jednomu nebo více znakům "a", spolu se znakem slova, který následuje za sekvencí "a" a přiřadí sekvenci "a" do první zachytávající skupiny, pokud je však konečný znak vstupního řetězce také "a", odpovídá prvku `\w` jazyka a není součástí zachycené skupiny.</span><span class="sxs-lookup"><span data-stu-id="f6e53-205">For example, the regular expression `(a+)\w` matches one or more "a" characters, along with a word character that follows the sequence of "a" characters, and assigns the sequence of "a" characters to the first capturing group, However, if the final character of the input string is also an "a", it is matched by the `\w` language element and is not included in the captured group.</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#7](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/nonbacktracking2.cs#7)]
     [!code-vb[Conceptual.RegularExpressions.Design#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/nonbacktracking2.vb#7)]

     <span data-ttu-id="f6e53-206">Regulární výraz `((?>a+))\w` zabrání tomuto chování.</span><span class="sxs-lookup"><span data-stu-id="f6e53-206">The regular expression `((?>a+))\w` prevents this behavior.</span></span> <span data-ttu-id="f6e53-207">Vzhledem k tomu, že všechny po sobě jdoucí "a" znaky se shodují bez navrácení, první zachytávající skupina zahrnuje všechny po sobě jdoucí znaky "a".</span><span class="sxs-lookup"><span data-stu-id="f6e53-207">Because all consecutive "a" characters are matched without backtracking, the first capturing group includes all consecutive "a" characters.</span></span> <span data-ttu-id="f6e53-208">Pokud za znaky "a" nenásleduje aspoň jeden další znak jiný než "a", shoda se nezdařila.</span><span class="sxs-lookup"><span data-stu-id="f6e53-208">If the "a" characters are not followed by at least one more character other than "a", the match fails.</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#8](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/nonbacktracking1.cs#8)]
     [!code-vb[Conceptual.RegularExpressions.Design#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/nonbacktracking1.vb#8)]

     <span data-ttu-id="f6e53-209">Další informace o podvýrazech převracení naleznete v tématu [Grouping konstrukcís](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="f6e53-209">For more information about nonbacktracking subexpressions, see [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span></span>

- <span data-ttu-id="f6e53-210">Shoda zprava doleva, která je určena zadáním možnosti <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType> do konstruktoru <xref:System.Text.RegularExpressions.Regex> třídy nebo do metody pro porovnání statické instance.</span><span class="sxs-lookup"><span data-stu-id="f6e53-210">Right-to-left matching, which is specified by supplying the <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType> option to a <xref:System.Text.RegularExpressions.Regex> class constructor or static instance matching method.</span></span> <span data-ttu-id="f6e53-211">Tato funkce je užitečná při hledání zprava doleva, nikoli zleva doprava, nebo v případech, kdy je efektivnější zahájit shodu v pravé části vzoru namísto levého.</span><span class="sxs-lookup"><span data-stu-id="f6e53-211">This feature is useful when searching from right to left instead of from left to right, or in cases where it is more efficient to begin a match at the right part of the pattern instead of the left.</span></span> <span data-ttu-id="f6e53-212">Jak ukazuje následující příklad, použití spárování zprava doleva může změnit chování hladových kvantifikátorů.</span><span class="sxs-lookup"><span data-stu-id="f6e53-212">As the following example illustrates, using right-to-left matching can change the behavior of greedy quantifiers.</span></span> <span data-ttu-id="f6e53-213">V tomto příkladu se provádí dvě hledání věty, která končí číslem.</span><span class="sxs-lookup"><span data-stu-id="f6e53-213">The example conducts two searches for a sentence that ends in a number.</span></span> <span data-ttu-id="f6e53-214">Hledání zleva doprava, které používá hladce, `+` odpovídá jedné ze šesti číslic ve větě, zatímco hledání zprava doleva odpovídá všem šesti číslicím.</span><span class="sxs-lookup"><span data-stu-id="f6e53-214">The left-to-right search that uses the greedy quantifier `+` matches one of the six digits in the sentence, whereas the right-to-left search matches all six digits.</span></span> <span data-ttu-id="f6e53-215">Popis vzoru regulárního výrazu naleznete v příkladu, který ukazuje opožděné kvantifikátory dříve v této části.</span><span class="sxs-lookup"><span data-stu-id="f6e53-215">For a description of the regular expression pattern, see the example that illustrates lazy quantifiers earlier in this section.</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#6](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/rtl1.cs#6)]
     [!code-vb[Conceptual.RegularExpressions.Design#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/rtl1.vb#6)]

     <span data-ttu-id="f6e53-216">Další informace o porovnání zprava doleva naleznete v tématu [Možnosti regulárních výrazů](../../../docs/standard/base-types/regular-expression-options.md).</span><span class="sxs-lookup"><span data-stu-id="f6e53-216">For more information about right-to-left matching, see [Regular Expression Options](../../../docs/standard/base-types/regular-expression-options.md).</span></span>

- <span data-ttu-id="f6e53-217">Pozitivní a negativní zpětné vyhledávání: `(?<=`dílčí *výraz*`)` pro pozitivní zpětné vyhledávání a `(?<!`dílčí *výraz*`)` pro negativní zpětné vyhledávání.</span><span class="sxs-lookup"><span data-stu-id="f6e53-217">Positive and negative lookbehind: `(?<=`*subexpression*`)` for positive lookbehind, and `(?<!`*subexpression*`)` for negative lookbehind.</span></span> <span data-ttu-id="f6e53-218">Tato funkce se podobá dopřednému vyhledávání, který je popsaný výše v tomto tématu.</span><span class="sxs-lookup"><span data-stu-id="f6e53-218">This feature is similar to lookahead, which is discussed earlier in this topic.</span></span> <span data-ttu-id="f6e53-219">Vzhledem k tomu, že modul regulárních výrazů umožňuje úplné porovnání zprava doleva, regulární výrazy povolují neomezený lookbehinds.</span><span class="sxs-lookup"><span data-stu-id="f6e53-219">Because the regular expression engine allows complete right-to-left matching, regular expressions allow unrestricted lookbehinds.</span></span> <span data-ttu-id="f6e53-220">Kladné a záporné zpětné vyhledávání lze také použít k zamezení vnořování kvantifikátorů, je-li vnořený dílčí výraz nadmnožinou vnějšího výrazu.</span><span class="sxs-lookup"><span data-stu-id="f6e53-220">Positive and negative lookbehind can also be used to avoid nesting quantifiers when the nested subexpression is a superset of an outer expression.</span></span> <span data-ttu-id="f6e53-221">Regulární výrazy s takovými vnořenými kvantifikátory často nabízejí nízký výkon.</span><span class="sxs-lookup"><span data-stu-id="f6e53-221">Regular expressions with such nested quantifiers often offer poor performance.</span></span> <span data-ttu-id="f6e53-222">Například následující příklad ověřuje, že řetězec začíná a končí alfanumerickým znakem a že jakýkoli jiný znak v řetězci je jedna z větší podmnožiny.</span><span class="sxs-lookup"><span data-stu-id="f6e53-222">For example, the following example verifies that a string begins and ends with an alphanumeric character, and that any other character in the string is one of a larger subset.</span></span> <span data-ttu-id="f6e53-223">Tvoří část regulárního výrazu, který slouží k ověření e-mailových adres. Další informace najdete v tématu [: Ověřte, že jsou řetězce v platném formátu e-mailu](../../../docs/standard/base-types/how-to-verify-that-strings-are-in-valid-email-format.md).</span><span class="sxs-lookup"><span data-stu-id="f6e53-223">It forms a portion of the regular expression used to validate email addresses; for more information, see [How to: Verify that Strings Are in Valid Email Format](../../../docs/standard/base-types/how-to-verify-that-strings-are-in-valid-email-format.md).</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#5](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/lookbehind1.cs#5)]
     [!code-vb[Conceptual.RegularExpressions.Design#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/lookbehind1.vb#5)]

     <span data-ttu-id="f6e53-224">Regulární výraz ``^[A-Z0-9]([-!#$%&'.*+/=?^`{}|~\w])*(?<=[A-Z0-9])$`` je definován tak, jak je uvedeno v následující tabulce.</span><span class="sxs-lookup"><span data-stu-id="f6e53-224">The regular expression ``^[A-Z0-9]([-!#$%&'.*+/=?^`{}|~\w])*(?<=[A-Z0-9])$`` is defined as shown in the following table.</span></span>

    |<span data-ttu-id="f6e53-225">Vzor</span><span class="sxs-lookup"><span data-stu-id="f6e53-225">Pattern</span></span>|<span data-ttu-id="f6e53-226">Popis</span><span class="sxs-lookup"><span data-stu-id="f6e53-226">Description</span></span>|
    |-------------|-----------------|
    |`^`|<span data-ttu-id="f6e53-227">Zahajte shodu na začátku řetězce.</span><span class="sxs-lookup"><span data-stu-id="f6e53-227">Begin the match at the beginning of the string.</span></span>|
    |`[A-Z0-9]`|<span data-ttu-id="f6e53-228">Odpovídá jakémukoli číselnému nebo alfanumerickému znaku.</span><span class="sxs-lookup"><span data-stu-id="f6e53-228">Match any numeric or alphanumeric character.</span></span> <span data-ttu-id="f6e53-229">(Porovnání nerozlišuje malá a velká písmena.)</span><span class="sxs-lookup"><span data-stu-id="f6e53-229">(The comparison is case-insensitive.)</span></span>|
    |<code>([-!#$%&'.*+/=?^\`{}&#124;~\w])\*</code>|<span data-ttu-id="f6e53-230">Porovná žádný nebo více výskytů libovolného znaku slova nebo některý z následujících znaků:-,!, #, $,%, &, ',., \*, +,/, =,?, ^, &#96;, {,}, &#124;nebo ~.</span><span class="sxs-lookup"><span data-stu-id="f6e53-230">Match zero or more occurrences of any word character, or any of the following characters:  -, !, #, $, %, &, ', ., \*, +, /, =, ?, ^, &#96;, {, }, &#124;, or ~.</span></span>|
    |`(?<=[A-Z0-9])`|<span data-ttu-id="f6e53-231">Prohlédněte si předchozí znak, který musí být numerický nebo alfanumerický.</span><span class="sxs-lookup"><span data-stu-id="f6e53-231">Look behind to the previous character, which must be numeric or alphanumeric.</span></span> <span data-ttu-id="f6e53-232">(Porovnání nerozlišuje malá a velká písmena.)</span><span class="sxs-lookup"><span data-stu-id="f6e53-232">(The comparison is case-insensitive.)</span></span>|
    |`$`|<span data-ttu-id="f6e53-233">Ukončí porovnávání na konci řetězce.</span><span class="sxs-lookup"><span data-stu-id="f6e53-233">End the match at the end of the string.</span></span>|

     <span data-ttu-id="f6e53-234">Další informace o pozitivním a negativním zpětném vyhledávání najdete v tématu [seskupovací konstrukce](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="f6e53-234">For more information about positive and negative lookbehind, see [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span></span>

## <a name="related-articles"></a><span data-ttu-id="f6e53-235">Související články</span><span class="sxs-lookup"><span data-stu-id="f6e53-235">Related articles</span></span>

|<span data-ttu-id="f6e53-236">Titul</span><span class="sxs-lookup"><span data-stu-id="f6e53-236">Title</span></span>|<span data-ttu-id="f6e53-237">Popis</span><span class="sxs-lookup"><span data-stu-id="f6e53-237">Description</span></span>|
|-----------|-----------------|
|[<span data-ttu-id="f6e53-238">Zpětné navracení</span><span class="sxs-lookup"><span data-stu-id="f6e53-238">Backtracking</span></span>](../../../docs/standard/base-types/backtracking-in-regular-expressions.md)|<span data-ttu-id="f6e53-239">Poskytuje informace o tom, jak se ve výrazech zpětného navrácení větví regulárních výrazů hledají alternativní shody.</span><span class="sxs-lookup"><span data-stu-id="f6e53-239">Provides information about how regular expression backtracking branches to find alternative matches.</span></span>|
|[<span data-ttu-id="f6e53-240">Kompilace a opětovné používání</span><span class="sxs-lookup"><span data-stu-id="f6e53-240">Compilation and Reuse</span></span>](../../../docs/standard/base-types/compilation-and-reuse-in-regular-expressions.md)|<span data-ttu-id="f6e53-241">Poskytuje informace o kompilaci a opětovném použití regulárních výrazů ke zvýšení výkonu.</span><span class="sxs-lookup"><span data-stu-id="f6e53-241">Provides information about compiling and reusing regular expressions to increase performance.</span></span>|
|[<span data-ttu-id="f6e53-242">Bezpečnost vlákna</span><span class="sxs-lookup"><span data-stu-id="f6e53-242">Thread Safety</span></span>](../../../docs/standard/base-types/thread-safety-in-regular-expressions.md)|<span data-ttu-id="f6e53-243">Poskytuje informace o bezpečnosti vláken regulárních výrazů a vysvětluje, kdy byste měli synchronizovat přístup k objektům regulárních výrazů.</span><span class="sxs-lookup"><span data-stu-id="f6e53-243">Provides information about regular expression thread safety and explains when you should synchronize access to regular expression objects.</span></span>|
|[<span data-ttu-id="f6e53-244">.NET Framework regulární výrazy</span><span class="sxs-lookup"><span data-stu-id="f6e53-244">.NET Framework Regular Expressions</span></span>](../../../docs/standard/base-types/regular-expressions.md)|<span data-ttu-id="f6e53-245">Poskytuje přehled aspektů regulárních výrazů programovacího jazyka.</span><span class="sxs-lookup"><span data-stu-id="f6e53-245">Provides an overview of the programming language aspect of regular expressions.</span></span>|
|[<span data-ttu-id="f6e53-246">Model objektu regulárního výrazu</span><span class="sxs-lookup"><span data-stu-id="f6e53-246">The Regular Expression Object Model</span></span>](../../../docs/standard/base-types/the-regular-expression-object-model.md)|<span data-ttu-id="f6e53-247">Poskytuje informace a příklady kódu ilustrující použití tříd regulárních výrazů.</span><span class="sxs-lookup"><span data-stu-id="f6e53-247">Provides information and code examples illustrating how to use the regular expression classes.</span></span>|
|[<span data-ttu-id="f6e53-248">Příklady regulárních výrazů</span><span class="sxs-lookup"><span data-stu-id="f6e53-248">Regular Expression Examples</span></span>](../../../docs/standard/base-types/regular-expression-examples.md)|<span data-ttu-id="f6e53-249">Obsahuje příklady kódu, které ilustrují použití regulárních výrazů v běžných aplikacích.</span><span class="sxs-lookup"><span data-stu-id="f6e53-249">Contains code examples that illustrate the use of regular expressions in common applications.</span></span>|
|[<span data-ttu-id="f6e53-250">Jazyk regulárních výrazů – stručná referenční dokumentace</span><span class="sxs-lookup"><span data-stu-id="f6e53-250">Regular Expression Language - Quick Reference</span></span>](../../../docs/standard/base-types/regular-expression-language-quick-reference.md)|<span data-ttu-id="f6e53-251">Poskytuje informace o sadě znaků, operátorech a konstrukcích, které lze použít k definování regulárních výrazů.</span><span class="sxs-lookup"><span data-stu-id="f6e53-251">Provides information about the set of characters, operators, and constructs that you can use to define regular expressions.</span></span>|

## <a name="reference"></a><span data-ttu-id="f6e53-252">Reference</span><span class="sxs-lookup"><span data-stu-id="f6e53-252">Reference</span></span>

- <xref:System.Text.RegularExpressions?displayProperty=nameWithType>
