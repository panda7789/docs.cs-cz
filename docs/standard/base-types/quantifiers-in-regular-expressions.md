---
title: Kvantifikátory v regulárních výrazech
description: Přečtěte si o kvantifikátorech regulárních výrazů, které určují, kolik instancí znaku, skupiny nebo třídy znaků musí být ve vstupu přítomné, aby odpovídaly.
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- regular expressions, quantifiers
- metacharacters, quantifiers
- minimal matching quantifiers
- quantifiers in regular expressions
- .NET Framework regular expressions, quantifiers
- quantifiers
- lazy quantifiers
ms.assetid: 36b81212-6511-49ed-a8f1-ff080415312f
ms.openlocfilehash: 2fc47a834f8f5b18021aa4f321345b8d7e4e8459
ms.sourcegitcommit: 7137e12f54c4e83a94ae43ec320f8cf59c1772ea
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 06/10/2020
ms.locfileid: "84662885"
---
# <a name="quantifiers-in-regular-expressions"></a><span data-ttu-id="64d60-103">Kvantifikátory v regulárních výrazech</span><span class="sxs-lookup"><span data-stu-id="64d60-103">Quantifiers in Regular Expressions</span></span>
<span data-ttu-id="64d60-104">Kvantifikátory určují, kolik instancí znaku, skupiny nebo třídy znaků musí být přítomné ve vstupu pro nalezení shody.</span><span class="sxs-lookup"><span data-stu-id="64d60-104">Quantifiers specify how many instances of a character, group, or character class must be present in the input for a match to be found.</span></span>  <span data-ttu-id="64d60-105">V následující tabulce jsou uvedeny kvantifikátory podporované rozhraním .NET.</span><span class="sxs-lookup"><span data-stu-id="64d60-105">The following table lists the quantifiers supported by .NET.</span></span>  
  
|<span data-ttu-id="64d60-106">Hladový kvantifikátor</span><span class="sxs-lookup"><span data-stu-id="64d60-106">Greedy quantifier</span></span>|<span data-ttu-id="64d60-107">Opožděný kvantifikátor</span><span class="sxs-lookup"><span data-stu-id="64d60-107">Lazy quantifier</span></span>|<span data-ttu-id="64d60-108">Popis</span><span class="sxs-lookup"><span data-stu-id="64d60-108">Description</span></span>|  
|-----------------------|---------------------|-----------------|  
|`*`|`*?`|<span data-ttu-id="64d60-109">Porovná nula nebo vícekrát.</span><span class="sxs-lookup"><span data-stu-id="64d60-109">Match zero or more times.</span></span>|  
|`+`|`+?`|<span data-ttu-id="64d60-110">Porovnává jednou nebo vícekrát.</span><span class="sxs-lookup"><span data-stu-id="64d60-110">Match one or more times.</span></span>|  
|`?`|`??`|<span data-ttu-id="64d60-111">Porovná žádný nebo jeden čas.</span><span class="sxs-lookup"><span data-stu-id="64d60-111">Match zero or one time.</span></span>|  
|<span data-ttu-id="64d60-112">`{`*n*`}`</span><span class="sxs-lookup"><span data-stu-id="64d60-112">`{` *n* `}`</span></span>|<span data-ttu-id="64d60-113">`{`*n*`}?`</span><span class="sxs-lookup"><span data-stu-id="64d60-113">`{` *n* `}?`</span></span>|<span data-ttu-id="64d60-114">Porovná přesně *n* krát.</span><span class="sxs-lookup"><span data-stu-id="64d60-114">Match exactly *n* times.</span></span>|  
|<span data-ttu-id="64d60-115">`{`*n*`,}`</span><span class="sxs-lookup"><span data-stu-id="64d60-115">`{` *n* `,}`</span></span>|<span data-ttu-id="64d60-116">`{`*n*`,}?`</span><span class="sxs-lookup"><span data-stu-id="64d60-116">`{` *n* `,}?`</span></span>|<span data-ttu-id="64d60-117">Porovnává alespoň *n* krát.</span><span class="sxs-lookup"><span data-stu-id="64d60-117">Match at least *n* times.</span></span>|  
|<span data-ttu-id="64d60-118">`{`*n* `,` *m*`}`</span><span class="sxs-lookup"><span data-stu-id="64d60-118">`{` *n* `,` *m* `}`</span></span>|<span data-ttu-id="64d60-119">`{`*n* `,` *m*`}?`</span><span class="sxs-lookup"><span data-stu-id="64d60-119">`{` *n* `,` *m* `}?`</span></span>|<span data-ttu-id="64d60-120">Porovnává od *n* do *m* krát.</span><span class="sxs-lookup"><span data-stu-id="64d60-120">Match from *n* to *m* times.</span></span>|  
  
 <span data-ttu-id="64d60-121">Množství `n` a `m` jsou celočíselné konstanty.</span><span class="sxs-lookup"><span data-stu-id="64d60-121">The quantities `n` and `m` are integer constants.</span></span> <span data-ttu-id="64d60-122">Obvykle jsou kvantifikátory hladce; způsobují, že modul regulárních výrazů porovnává tolik výskytů určitých vzorů, jak je to možné.</span><span class="sxs-lookup"><span data-stu-id="64d60-122">Ordinarily, quantifiers are greedy; they cause the regular expression engine to match as many occurrences of particular patterns as possible.</span></span> <span data-ttu-id="64d60-123">Připojení `?` znaku k kvantifikátoru je opožděné. způsobí, že modul regulárních výrazů bude odpovídat co nejmenšímu výskytu.</span><span class="sxs-lookup"><span data-stu-id="64d60-123">Appending the `?` character to a quantifier makes it lazy; it causes the regular expression engine to match as few occurrences as possible.</span></span> <span data-ttu-id="64d60-124">Úplný popis rozdílu mezi hladce a opožděnými kvantifikátory naleznete v části [hladce a opožděné kvantifikátory](#Greedy) dále v tomto tématu.</span><span class="sxs-lookup"><span data-stu-id="64d60-124">For a complete description of the difference between greedy and lazy quantifiers, see the section [Greedy and Lazy Quantifiers](#Greedy) later in this topic.</span></span>  
  
> [!IMPORTANT]
> <span data-ttu-id="64d60-125">Vnořování kvantifikátorů (například jako vzor regulárního výrazu `(a*)*` ) může zvýšit počet porovnání, které musí modul regulárních výrazů provádět, jako exponenciální funkci počtu znaků ve vstupním řetězci.</span><span class="sxs-lookup"><span data-stu-id="64d60-125">Nesting quantifiers (for example, as the regular expression pattern `(a*)*` does) can increase the number of comparisons that the regular expression engine must perform, as an exponential function of the number of characters in the input string.</span></span> <span data-ttu-id="64d60-126">Další informace o tomto chování a jejich řešeních najdete v tématu [zpětné navrácení](backtracking-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="64d60-126">For more information about this behavior and its workarounds, see [Backtracking](backtracking-in-regular-expressions.md).</span></span>  
  
## <a name="regular-expression-quantifiers"></a><span data-ttu-id="64d60-127">Kvantifikátory regulárního výrazu</span><span class="sxs-lookup"><span data-stu-id="64d60-127">Regular Expression Quantifiers</span></span>  
 <span data-ttu-id="64d60-128">V následujících částech jsou uvedeny kvantifikátory podporované regulárními výrazy .NET.</span><span class="sxs-lookup"><span data-stu-id="64d60-128">The following sections list the quantifiers supported by .NET regular expressions.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="64d60-129">Pokud jsou ve vzoru regulárního výrazu zjištěny znaky \*, +,?, {a}, modul regulárních výrazů je interpretuje jako kvantifikátory nebo část konstrukcí kvantifikátoru, pokud nejsou zahrnuty ve [třídě znaků](character-classes-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="64d60-129">If the \*, +, ?, {, and } characters are encountered in a regular expression pattern, the regular expression engine interprets them as quantifiers or part of quantifier constructs unless they are included in a [character class](character-classes-in-regular-expressions.md).</span></span> <span data-ttu-id="64d60-130">Chcete-li je interpretovat jako literální znaky vně třídy znaků, je nutné je před pomocí zpětného lomítka řídicím znakem.</span><span class="sxs-lookup"><span data-stu-id="64d60-130">To interpret these as literal characters outside a character class, you must escape them by preceding them with a backslash.</span></span> <span data-ttu-id="64d60-131">Například řetězec `\*` ve vzoru regulárního výrazu je interpretován jako literální znak hvězdičky (" \* ").</span><span class="sxs-lookup"><span data-stu-id="64d60-131">For example, the string `\*` in a regular expression pattern is interpreted as a literal asterisk ("\*") character.</span></span>  
  
### <a name="match-zero-or-more-times-"></a><span data-ttu-id="64d60-132">Porovná nula nebo více časů: \*</span><span class="sxs-lookup"><span data-stu-id="64d60-132">Match Zero or More Times: \*</span></span>  
 <span data-ttu-id="64d60-133">`*`Kvantifikátor odpovídá předchozímu prvku nula nebo vícekrát.</span><span class="sxs-lookup"><span data-stu-id="64d60-133">The `*` quantifier matches the preceding element zero or more times.</span></span> <span data-ttu-id="64d60-134">Je ekvivalentní k `{0,}` kvantifikátoru.</span><span class="sxs-lookup"><span data-stu-id="64d60-134">It is equivalent to the `{0,}` quantifier.</span></span> <span data-ttu-id="64d60-135">`*`je hladový kvantifikátor, jehož opožděný ekvivalent je `*?` .</span><span class="sxs-lookup"><span data-stu-id="64d60-135">`*` is a greedy quantifier whose lazy equivalent is `*?`.</span></span>  
  
 <span data-ttu-id="64d60-136">Následující příklad ilustruje tento regulární výraz.</span><span class="sxs-lookup"><span data-stu-id="64d60-136">The following example illustrates this regular expression.</span></span> <span data-ttu-id="64d60-137">Z devíti číslic ve vstupním řetězci, pět se shoduje se vzorem a čtyřmi ( `95` ,, `929` `9219` a `9919` ) ne.</span><span class="sxs-lookup"><span data-stu-id="64d60-137">Of the nine digits in the input string, five match the pattern and four (`95`, `929`, `9219`, and `9919`) do not.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers#1](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#1)]
 [!code-vb[RegularExpressions.Quantifiers#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#1)]  
  
 <span data-ttu-id="64d60-138">Vzor regulárního výrazu je definován tak, jak je uvedeno v následující tabulce.</span><span class="sxs-lookup"><span data-stu-id="64d60-138">The regular expression pattern is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="64d60-139">Vzor</span><span class="sxs-lookup"><span data-stu-id="64d60-139">Pattern</span></span>|<span data-ttu-id="64d60-140">Popis</span><span class="sxs-lookup"><span data-stu-id="64d60-140">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="64d60-141">Začne na hranici slova.</span><span class="sxs-lookup"><span data-stu-id="64d60-141">Start at a word boundary.</span></span>|  
|`91*`|<span data-ttu-id="64d60-142">Porovná řetězec "9" následovaný žádným nebo více znaky "1".</span><span class="sxs-lookup"><span data-stu-id="64d60-142">Match a "9" followed by zero or more "1" characters.</span></span>|  
|`9*`|<span data-ttu-id="64d60-143">Porovná nula nebo více znaků "9".</span><span class="sxs-lookup"><span data-stu-id="64d60-143">Match zero or more "9" characters.</span></span>|  
|`\b`|<span data-ttu-id="64d60-144">Skončí na hranici slova.</span><span class="sxs-lookup"><span data-stu-id="64d60-144">End at a word boundary.</span></span>|  
  
### <a name="match-one-or-more-times-"></a><span data-ttu-id="64d60-145">Porovnává jednou nebo víckrát: +</span><span class="sxs-lookup"><span data-stu-id="64d60-145">Match One or More Times: +</span></span>  
 <span data-ttu-id="64d60-146">`+`Kvantifikátor Porovná předchozí prvek jednou nebo vícekrát.</span><span class="sxs-lookup"><span data-stu-id="64d60-146">The `+` quantifier matches the preceding element one or more times.</span></span> <span data-ttu-id="64d60-147">Je ekvivalentní `{1,}` .</span><span class="sxs-lookup"><span data-stu-id="64d60-147">It is equivalent to `{1,}`.</span></span> <span data-ttu-id="64d60-148">`+`je hladový kvantifikátor, jehož opožděný ekvivalent je `+?` .</span><span class="sxs-lookup"><span data-stu-id="64d60-148">`+` is a greedy quantifier whose lazy equivalent is `+?`.</span></span>  
  
 <span data-ttu-id="64d60-149">Například regulární výraz se `\ban+\w*?\b` pokusí vyhledat celá slova, která začínají písmenem `a` následovaným jednou nebo více instancemi písmena `n` .</span><span class="sxs-lookup"><span data-stu-id="64d60-149">For example, the regular expression `\ban+\w*?\b` tries to match entire words that begin with the letter `a` followed by one or more instances of the letter `n`.</span></span> <span data-ttu-id="64d60-150">Následující příklad ilustruje tento regulární výraz.</span><span class="sxs-lookup"><span data-stu-id="64d60-150">The following example illustrates this regular expression.</span></span> <span data-ttu-id="64d60-151">Regulární výraz odpovídá slovům `an` , `annual` , `announcement` a `antique` , a správně se neshodují `autumn` a `all` .</span><span class="sxs-lookup"><span data-stu-id="64d60-151">The regular expression matches the words `an`, `annual`, `announcement`, and `antique`, and correctly fails to match `autumn` and `all`.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers#2](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#2)]
 [!code-vb[RegularExpressions.Quantifiers#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#2)]  
  
 <span data-ttu-id="64d60-152">Vzor regulárního výrazu je definován tak, jak je uvedeno v následující tabulce.</span><span class="sxs-lookup"><span data-stu-id="64d60-152">The regular expression pattern is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="64d60-153">Vzor</span><span class="sxs-lookup"><span data-stu-id="64d60-153">Pattern</span></span>|<span data-ttu-id="64d60-154">Popis</span><span class="sxs-lookup"><span data-stu-id="64d60-154">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="64d60-155">Začne na hranici slova.</span><span class="sxs-lookup"><span data-stu-id="64d60-155">Start at a word boundary.</span></span>|  
|`an+`|<span data-ttu-id="64d60-156">Porovnává se znakem "a" následovaným jedním nebo více znaky "n".</span><span class="sxs-lookup"><span data-stu-id="64d60-156">Match an "a" followed by one or more "n" characters.</span></span>|  
|`\w*?`|<span data-ttu-id="64d60-157">Porovná znak slova nula nebo vícekrát, ale s co nejmenším možným počtem opakování.</span><span class="sxs-lookup"><span data-stu-id="64d60-157">Match a word character zero or more times, but as few times as possible.</span></span>|  
|`\b`|<span data-ttu-id="64d60-158">Skončí na hranici slova.</span><span class="sxs-lookup"><span data-stu-id="64d60-158">End at a word boundary.</span></span>|  
  
### <a name="match-zero-or-one-time-"></a><span data-ttu-id="64d60-159">Odpovídá žádnému nebo jednomu času:?</span><span class="sxs-lookup"><span data-stu-id="64d60-159">Match Zero or One Time: ?</span></span>  
 <span data-ttu-id="64d60-160">`?`Kvantifikátor odpovídá předchozímu prvku nula nebo jednou.</span><span class="sxs-lookup"><span data-stu-id="64d60-160">The `?` quantifier matches the preceding element zero or one time.</span></span> <span data-ttu-id="64d60-161">Je ekvivalentní `{0,1}` .</span><span class="sxs-lookup"><span data-stu-id="64d60-161">It is equivalent to `{0,1}`.</span></span> <span data-ttu-id="64d60-162">`?`je hladový kvantifikátor, jehož opožděný ekvivalent je `??` .</span><span class="sxs-lookup"><span data-stu-id="64d60-162">`?` is a greedy quantifier whose lazy equivalent is `??`.</span></span>  
  
 <span data-ttu-id="64d60-163">Například regulární výraz se `\ban?\b` pokusí vyhledat celá slova, která začínají písmenem `a` následovaným nulou nebo jednou instancí písmena `n` .</span><span class="sxs-lookup"><span data-stu-id="64d60-163">For example, the regular expression `\ban?\b` tries to match entire words that begin with the letter `a` followed by zero or one instances of the letter `n`.</span></span> <span data-ttu-id="64d60-164">Jinými slovy se pokusí porovnat slova `a` a `an` .</span><span class="sxs-lookup"><span data-stu-id="64d60-164">In other words, it tries to match the words `a` and `an`.</span></span> <span data-ttu-id="64d60-165">Následující příklad ilustruje tento regulární výraz.</span><span class="sxs-lookup"><span data-stu-id="64d60-165">The following example illustrates this regular expression.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers#3](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#3)]
 [!code-vb[RegularExpressions.Quantifiers#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#3)]  
  
 <span data-ttu-id="64d60-166">Vzor regulárního výrazu je definován tak, jak je uvedeno v následující tabulce.</span><span class="sxs-lookup"><span data-stu-id="64d60-166">The regular expression pattern is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="64d60-167">Vzor</span><span class="sxs-lookup"><span data-stu-id="64d60-167">Pattern</span></span>|<span data-ttu-id="64d60-168">Popis</span><span class="sxs-lookup"><span data-stu-id="64d60-168">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="64d60-169">Začne na hranici slova.</span><span class="sxs-lookup"><span data-stu-id="64d60-169">Start at a word boundary.</span></span>|  
|`an?`|<span data-ttu-id="64d60-170">Porovná znak "a" následovaný žádným nebo jedním znakem "n".</span><span class="sxs-lookup"><span data-stu-id="64d60-170">Match an "a" followed by zero or one "n" character.</span></span>|  
|`\b`|<span data-ttu-id="64d60-171">Skončí na hranici slova.</span><span class="sxs-lookup"><span data-stu-id="64d60-171">End at a word boundary.</span></span>|  
  
### <a name="match-exactly-n-times-n"></a><span data-ttu-id="64d60-172">Porovná přesně n krát: {n}</span><span class="sxs-lookup"><span data-stu-id="64d60-172">Match Exactly n Times: {n}</span></span>  
 <span data-ttu-id="64d60-173">Kvantifikátor `{` *n* `}` Porovná předchozí prvek přesně *n* krát, kde *n* je libovolné celé číslo.</span><span class="sxs-lookup"><span data-stu-id="64d60-173">The `{`*n*`}` quantifier matches the preceding element exactly *n* times, where *n* is any integer.</span></span> <span data-ttu-id="64d60-174">`{`*n* `}` je hladový kvantifikátor, jehož opožděný ekvivalent je `{` *n* `}?` .</span><span class="sxs-lookup"><span data-stu-id="64d60-174">`{`*n*`}` is a greedy quantifier whose lazy equivalent is `{`*n*`}?`.</span></span>  
  
 <span data-ttu-id="64d60-175">Například regulární výraz se `\b\d+\,\d{3}\b` pokusí porovnat hranici slova následovaný jednou nebo více desítkovými číslicemi následovanými třemi desítkovými číslicemi, za kterými následuje hranice slova.</span><span class="sxs-lookup"><span data-stu-id="64d60-175">For example, the regular expression `\b\d+\,\d{3}\b` tries to match a word boundary followed by one or more decimal digits followed by three decimal digits followed by a word boundary.</span></span> <span data-ttu-id="64d60-176">Následující příklad ilustruje tento regulární výraz.</span><span class="sxs-lookup"><span data-stu-id="64d60-176">The following example illustrates this regular expression.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers#4](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#4)]
 [!code-vb[RegularExpressions.Quantifiers#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#4)]  
  
 <span data-ttu-id="64d60-177">Vzor regulárního výrazu je definován tak, jak je uvedeno v následující tabulce.</span><span class="sxs-lookup"><span data-stu-id="64d60-177">The regular expression pattern is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="64d60-178">Vzor</span><span class="sxs-lookup"><span data-stu-id="64d60-178">Pattern</span></span>|<span data-ttu-id="64d60-179">Popis</span><span class="sxs-lookup"><span data-stu-id="64d60-179">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="64d60-180">Začne na hranici slova.</span><span class="sxs-lookup"><span data-stu-id="64d60-180">Start at a word boundary.</span></span>|  
|`\d+`|<span data-ttu-id="64d60-181">Porovná jednu nebo více desítkových číslic.</span><span class="sxs-lookup"><span data-stu-id="64d60-181">Match one or more decimal digits.</span></span>|  
|`\,`|<span data-ttu-id="64d60-182">Porovnává se znakem čárky.</span><span class="sxs-lookup"><span data-stu-id="64d60-182">Match a comma character.</span></span>|  
|`\d{3}`|<span data-ttu-id="64d60-183">Porovná tři desítkové číslice.</span><span class="sxs-lookup"><span data-stu-id="64d60-183">Match three decimal digits.</span></span>|  
|`\b`|<span data-ttu-id="64d60-184">Skončí na hranici slova.</span><span class="sxs-lookup"><span data-stu-id="64d60-184">End at a word boundary.</span></span>|  
  
### <a name="match-at-least-n-times-n"></a><span data-ttu-id="64d60-185">Porovnává alespoň n krát: {n,}</span><span class="sxs-lookup"><span data-stu-id="64d60-185">Match at Least n Times: {n,}</span></span>  
 <span data-ttu-id="64d60-186">Kvantifikátor `{` *n* `,}` Porovná předchozí prvek nejméně *n* krát, kde *n* je libovolné celé číslo.</span><span class="sxs-lookup"><span data-stu-id="64d60-186">The `{`*n*`,}` quantifier matches the preceding element at least *n* times, where *n* is any integer.</span></span> <span data-ttu-id="64d60-187">`{`*n* `,}` je hladový kvantifikátor, jehož opožděný ekvivalent je `{` *n* `,}?` .</span><span class="sxs-lookup"><span data-stu-id="64d60-187">`{`*n*`,}` is a greedy quantifier whose lazy equivalent is `{`*n*`,}?`.</span></span>  
  
 <span data-ttu-id="64d60-188">Například regulární výraz se `\b\d{2,}\b\D+` pokusí porovnat hranici slova následovaný alespoň dvěma číslicemi následovanými hranicí slova a znakem, který není číslice.</span><span class="sxs-lookup"><span data-stu-id="64d60-188">For example, the regular expression `\b\d{2,}\b\D+` tries to match a word boundary followed by at least two digits followed by a word boundary and a non-digit character.</span></span> <span data-ttu-id="64d60-189">Následující příklad ilustruje tento regulární výraz.</span><span class="sxs-lookup"><span data-stu-id="64d60-189">The following example illustrates this regular expression.</span></span> <span data-ttu-id="64d60-190">Regulárnímu výrazu se nepodaří spárovat frázi `"7 days"` , protože obsahuje pouze jednu desítkovou číslici, ale úspěšně odpovídá frázím `"10 weeks and 300 years"` .</span><span class="sxs-lookup"><span data-stu-id="64d60-190">The regular expression fails to match the phrase `"7 days"` because it contains just one decimal digit, but it successfully matches the phrases `"10 weeks and 300 years"`.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers#5](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#5)]
 [!code-vb[RegularExpressions.Quantifiers#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#5)]  
  
 <span data-ttu-id="64d60-191">Vzor regulárního výrazu je definován tak, jak je uvedeno v následující tabulce.</span><span class="sxs-lookup"><span data-stu-id="64d60-191">The regular expression pattern is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="64d60-192">Vzor</span><span class="sxs-lookup"><span data-stu-id="64d60-192">Pattern</span></span>|<span data-ttu-id="64d60-193">Popis</span><span class="sxs-lookup"><span data-stu-id="64d60-193">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="64d60-194">Začne na hranici slova.</span><span class="sxs-lookup"><span data-stu-id="64d60-194">Start at a word boundary.</span></span>|  
|`\d{2,}`|<span data-ttu-id="64d60-195">Porovnává alespoň dvě desítkové číslice.</span><span class="sxs-lookup"><span data-stu-id="64d60-195">Match at least two decimal digits.</span></span>|  
|`\b`|<span data-ttu-id="64d60-196">Porovná hranici slova.</span><span class="sxs-lookup"><span data-stu-id="64d60-196">Match a word boundary.</span></span>|  
|`\D+`|<span data-ttu-id="64d60-197">Porovnává alespoň jednu jinou než desítkovou číslici.</span><span class="sxs-lookup"><span data-stu-id="64d60-197">Match at least one non-decimal digit.</span></span>|  
  
### <a name="match-between-n-and-m-times-nm"></a><span data-ttu-id="64d60-198">Shoda mezi n a m časy: {n, m}</span><span class="sxs-lookup"><span data-stu-id="64d60-198">Match Between n and m Times: {n,m}</span></span>  
 <span data-ttu-id="64d60-199">Kvantifikátor `{` *n* `,` *m* `}` Porovná předchozí prvek nejméně *n* krát, ale ne více než *m* krát, kde *n* a *m* jsou celá čísla.</span><span class="sxs-lookup"><span data-stu-id="64d60-199">The `{`*n*`,`*m*`}` quantifier matches the preceding element at least *n* times, but no more than *m* times, where *n* and *m* are integers.</span></span> <span data-ttu-id="64d60-200">`{`*n* `,` *m* `}` je hladový kvantifikátor, jehož opožděný ekvivalent je `{` *n* `,` *m* `}?` .</span><span class="sxs-lookup"><span data-stu-id="64d60-200">`{`*n*`,`*m*`}` is a greedy quantifier whose lazy equivalent is `{`*n*`,`*m*`}?`.</span></span>  
  
 <span data-ttu-id="64d60-201">V následujícím příkladu regulární výraz se `(00\s){2,4}` pokusí porovnat dva a čtyři výskyty dvou číslic za nulu následovaných mezerou.</span><span class="sxs-lookup"><span data-stu-id="64d60-201">In the following example, the regular expression `(00\s){2,4}` tries to match between two and four occurrences of two zero digits followed by a space.</span></span> <span data-ttu-id="64d60-202">Všimněte si, že poslední část vstupního řetězce obsahuje tento vzor pětkrát, ne jako maximum čtyři.</span><span class="sxs-lookup"><span data-stu-id="64d60-202">Note that the final portion of the input string includes this pattern five times rather than the maximum of four.</span></span> <span data-ttu-id="64d60-203">Pouze počáteční část tohoto podřetězce (až do prostoru a páté dvojice nul) však odpovídá vzoru regulárního výrazu.</span><span class="sxs-lookup"><span data-stu-id="64d60-203">However, only the initial portion of this substring (up to the space and the fifth pair of zeros) matches the regular expression pattern.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers#6](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#6)]
 [!code-vb[RegularExpressions.Quantifiers#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#6)]  
  
### <a name="match-zero-or-more-times-lazy-match-"></a><span data-ttu-id="64d60-204">Porovná nula nebo více časů (opožděné porovnávání): \*?</span><span class="sxs-lookup"><span data-stu-id="64d60-204">Match Zero or More Times (Lazy Match): \*?</span></span>  
 <span data-ttu-id="64d60-205">`*?`Kvantifikátor odpovídá předchozímu prvku nula nebo vícekrát, ale s co nejmenším možným počtem opakování.</span><span class="sxs-lookup"><span data-stu-id="64d60-205">The `*?` quantifier matches the preceding element zero or more times, but as few times as possible.</span></span> <span data-ttu-id="64d60-206">Je opožděným protějškem hladového kvantifikátoru `*` .</span><span class="sxs-lookup"><span data-stu-id="64d60-206">It is the lazy counterpart of the greedy quantifier `*`.</span></span>  
  
 <span data-ttu-id="64d60-207">V následujícím příkladu regulární výraz `\b\w*?oo\w*?\b` odpovídá všem slovům, která obsahují řetězec `oo` .</span><span class="sxs-lookup"><span data-stu-id="64d60-207">In the following example, the regular expression `\b\w*?oo\w*?\b` matches all words that contain the string `oo`.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers#7](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#7)]
 [!code-vb[RegularExpressions.Quantifiers#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#7)]  
  
 <span data-ttu-id="64d60-208">Vzor regulárního výrazu je definován tak, jak je uvedeno v následující tabulce.</span><span class="sxs-lookup"><span data-stu-id="64d60-208">The regular expression pattern is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="64d60-209">Vzor</span><span class="sxs-lookup"><span data-stu-id="64d60-209">Pattern</span></span>|<span data-ttu-id="64d60-210">Popis</span><span class="sxs-lookup"><span data-stu-id="64d60-210">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="64d60-211">Začne na hranici slova.</span><span class="sxs-lookup"><span data-stu-id="64d60-211">Start at a word boundary.</span></span>|  
|`\w*?`|<span data-ttu-id="64d60-212">Porovná žádný nebo více znaků slova, ale co nejvíce znaků.</span><span class="sxs-lookup"><span data-stu-id="64d60-212">Match zero or more word characters, but as few characters as possible.</span></span>|  
|`oo`|<span data-ttu-id="64d60-213">Porovnává s řetězcem "ó".</span><span class="sxs-lookup"><span data-stu-id="64d60-213">Match the string "oo".</span></span>|  
|`\w*?`|<span data-ttu-id="64d60-214">Porovná žádný nebo více znaků slova, ale co nejvíce znaků.</span><span class="sxs-lookup"><span data-stu-id="64d60-214">Match zero or more word characters, but as few characters as possible.</span></span>|  
|`\b`|<span data-ttu-id="64d60-215">Ukončí hranici slova.</span><span class="sxs-lookup"><span data-stu-id="64d60-215">End on a word boundary.</span></span>|  
  
### <a name="match-one-or-more-times-lazy-match-"></a><span data-ttu-id="64d60-216">Odpovídá jednomu nebo více výskytům (opožděné porovnávání): +?</span><span class="sxs-lookup"><span data-stu-id="64d60-216">Match One or More Times (Lazy Match): +?</span></span>  
 <span data-ttu-id="64d60-217">`+?`Kvantifikátor Porovná předchozí prvek jednou nebo vícekrát, ale s co nejmenším možným počtem opakování.</span><span class="sxs-lookup"><span data-stu-id="64d60-217">The `+?` quantifier matches the preceding element one or more times, but as few times as possible.</span></span> <span data-ttu-id="64d60-218">Je opožděným protějškem hladového kvantifikátoru `+` .</span><span class="sxs-lookup"><span data-stu-id="64d60-218">It is the lazy counterpart of the greedy quantifier `+`.</span></span>  
  
 <span data-ttu-id="64d60-219">Například regulární výraz `\b\w+?\b` odpovídá jednomu nebo více znakům odděleným ohraničením slova.</span><span class="sxs-lookup"><span data-stu-id="64d60-219">For example, the regular expression `\b\w+?\b` matches one or more characters separated by word boundaries.</span></span> <span data-ttu-id="64d60-220">Následující příklad ilustruje tento regulární výraz.</span><span class="sxs-lookup"><span data-stu-id="64d60-220">The following example illustrates this regular expression.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers#8](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#8)]
 [!code-vb[RegularExpressions.Quantifiers#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#8)]  
  
### <a name="match-zero-or-one-time-lazy-match-"></a><span data-ttu-id="64d60-221">Odpovídá žádnému nebo jednomu času (opožděné porovnávání):??</span><span class="sxs-lookup"><span data-stu-id="64d60-221">Match Zero or One Time (Lazy Match): ??</span></span>  
 <span data-ttu-id="64d60-222">`??`Kvantifikátor odpovídá předchozímu prvku nula nebo jednou, ale s co nejmenším možným počtem opakování.</span><span class="sxs-lookup"><span data-stu-id="64d60-222">The `??` quantifier matches the preceding element zero or one time, but as few times as possible.</span></span> <span data-ttu-id="64d60-223">Je opožděným protějškem hladového kvantifikátoru `?` .</span><span class="sxs-lookup"><span data-stu-id="64d60-223">It is the lazy counterpart of the greedy quantifier `?`.</span></span>  
  
 <span data-ttu-id="64d60-224">Například regulární výraz se `^\s*(System.)??Console.Write(Line)??\(??` pokusí porovnat řetězce "Console. Write" nebo "Console. WriteLine".</span><span class="sxs-lookup"><span data-stu-id="64d60-224">For example, the regular expression `^\s*(System.)??Console.Write(Line)??\(??` attempts to match the strings "Console.Write" or "Console.WriteLine".</span></span> <span data-ttu-id="64d60-225">Řetězec může obsahovat také "System."</span><span class="sxs-lookup"><span data-stu-id="64d60-225">The string can also include "System."</span></span> <span data-ttu-id="64d60-226">před "Console" a za ní může následovat levá závorka.</span><span class="sxs-lookup"><span data-stu-id="64d60-226">before "Console", and it can be followed by an opening parenthesis.</span></span> <span data-ttu-id="64d60-227">Řetězec musí být na začátku řádku, i když může předcházet prázdné znaky.</span><span class="sxs-lookup"><span data-stu-id="64d60-227">The string must be at the beginning of a line, although it can be preceded by white space.</span></span> <span data-ttu-id="64d60-228">Následující příklad ilustruje tento regulární výraz.</span><span class="sxs-lookup"><span data-stu-id="64d60-228">The following example illustrates this regular expression.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers#9](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#9)]
 [!code-vb[RegularExpressions.Quantifiers#9](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#9)]  
  
 <span data-ttu-id="64d60-229">Vzor regulárního výrazu je definován tak, jak je uvedeno v následující tabulce.</span><span class="sxs-lookup"><span data-stu-id="64d60-229">The regular expression pattern is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="64d60-230">Vzor</span><span class="sxs-lookup"><span data-stu-id="64d60-230">Pattern</span></span>|<span data-ttu-id="64d60-231">Popis</span><span class="sxs-lookup"><span data-stu-id="64d60-231">Description</span></span>|  
|-------------|-----------------|  
|`^`|<span data-ttu-id="64d60-232">Odpovídá začátku vstupního datového proudu.</span><span class="sxs-lookup"><span data-stu-id="64d60-232">Match the start of the input stream.</span></span>|  
|`\s*`|<span data-ttu-id="64d60-233">Porovná žádný nebo více prázdných znaků.</span><span class="sxs-lookup"><span data-stu-id="64d60-233">Match zero or more white-space characters.</span></span>|  
|`(System.)??`|<span data-ttu-id="64d60-234">Porovná žádný nebo jeden výskyt řetězce "System.".</span><span class="sxs-lookup"><span data-stu-id="64d60-234">Match zero or one occurrence of the string "System.".</span></span>|  
|`Console.Write`|<span data-ttu-id="64d60-235">Porovnává s řetězcem "Console. Write".</span><span class="sxs-lookup"><span data-stu-id="64d60-235">Match the string "Console.Write".</span></span>|  
|`(Line)??`|<span data-ttu-id="64d60-236">Porovná žádný nebo jeden výskyt řetězce "line".</span><span class="sxs-lookup"><span data-stu-id="64d60-236">Match zero or one occurrence of the string "Line".</span></span>|  
|`\(??`|<span data-ttu-id="64d60-237">Porovná žádný nebo jeden výskyt levé závorky.</span><span class="sxs-lookup"><span data-stu-id="64d60-237">Match zero or one occurrence of the opening parenthesis.</span></span>|  
  
### <a name="match-exactly-n-times-lazy-match-n"></a><span data-ttu-id="64d60-238">Porovná přesně n krát (opožděná shoda): {n}?</span><span class="sxs-lookup"><span data-stu-id="64d60-238">Match Exactly n Times (Lazy Match): {n}?</span></span>  
 <span data-ttu-id="64d60-239">Kvantifikátor `{` *n* `}?` Porovná předchozí prvek přesně `n` krát, kde *n* je libovolné celé číslo.</span><span class="sxs-lookup"><span data-stu-id="64d60-239">The `{`*n*`}?` quantifier matches the preceding element exactly `n` times, where *n* is any integer.</span></span> <span data-ttu-id="64d60-240">Je opožděným protějškem hladového kvantifikátoru `{` *n* `}` .</span><span class="sxs-lookup"><span data-stu-id="64d60-240">It is the lazy counterpart of the greedy quantifier `{`*n*`}`.</span></span>  
  
 <span data-ttu-id="64d60-241">V následujícím příkladu je regulární výraz `\b(\w{3,}?\.){2}?\w{3,}?\b` použit k identifikaci adresy webu.</span><span class="sxs-lookup"><span data-stu-id="64d60-241">In the following example, the regular expression `\b(\w{3,}?\.){2}?\w{3,}?\b` is used to identify a Web site address.</span></span> <span data-ttu-id="64d60-242">Všimněte si, že odpovídá "www.microsoft.com" a "msdn.microsoft.com", ale neodpovídá "mywebsite" nebo "mycompany.com".</span><span class="sxs-lookup"><span data-stu-id="64d60-242">Note that it matches "www.microsoft.com" and "msdn.microsoft.com", but does not match "mywebsite" or "mycompany.com".</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers#10](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#10)]
 [!code-vb[RegularExpressions.Quantifiers#10](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#10)]  
  
 <span data-ttu-id="64d60-243">Vzor regulárního výrazu je definován tak, jak je uvedeno v následující tabulce.</span><span class="sxs-lookup"><span data-stu-id="64d60-243">The regular expression pattern is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="64d60-244">Vzor</span><span class="sxs-lookup"><span data-stu-id="64d60-244">Pattern</span></span>|<span data-ttu-id="64d60-245">Popis</span><span class="sxs-lookup"><span data-stu-id="64d60-245">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="64d60-246">Začne na hranici slova.</span><span class="sxs-lookup"><span data-stu-id="64d60-246">Start at a word boundary.</span></span>|  
|`(\w{3,}?\.)`|<span data-ttu-id="64d60-247">Porovnává alespoň 3 znaky slova, ale co nejvíce znaků a znak tečky nebo tečky.</span><span class="sxs-lookup"><span data-stu-id="64d60-247">Match at least 3 word characters, but as few characters as possible, followed by a dot or period character.</span></span> <span data-ttu-id="64d60-248">Toto je první zachytávající skupina.</span><span class="sxs-lookup"><span data-stu-id="64d60-248">This is the first capturing group.</span></span>|  
|`(\w{3,}?\.){2}?`|<span data-ttu-id="64d60-249">Porovnává vzor v první skupině dvakrát, ale s co nejmenším možným počtem opakování.</span><span class="sxs-lookup"><span data-stu-id="64d60-249">Match the pattern in the first group two times, but as few times as possible.</span></span>|  
|`\b`|<span data-ttu-id="64d60-250">Ukončí porovnávání na hranici slova.</span><span class="sxs-lookup"><span data-stu-id="64d60-250">End the match on a word boundary.</span></span>|  
  
### <a name="match-at-least-n-times-lazy-match-n"></a><span data-ttu-id="64d60-251">Porovnává alespoň n krát (opožděná shoda): {n,}?</span><span class="sxs-lookup"><span data-stu-id="64d60-251">Match at Least n Times (Lazy Match): {n,}?</span></span>  
 <span data-ttu-id="64d60-252">Kvantifikátor `{` *n* `,}?` Porovná předchozí prvek nejméně `n` krát, kde *n* je libovolné celé číslo, ale co nejmenším možným způsobem.</span><span class="sxs-lookup"><span data-stu-id="64d60-252">The `{`*n*`,}?` quantifier matches the preceding element at least `n` times, where *n* is any integer, but as few times as possible.</span></span> <span data-ttu-id="64d60-253">Je opožděným protějškem hladového kvantifikátoru `{` *n* `,}` .</span><span class="sxs-lookup"><span data-stu-id="64d60-253">It is the lazy counterpart of the greedy quantifier `{`*n*`,}`.</span></span>  
  
 <span data-ttu-id="64d60-254">Ukázku najdete v příkladu pro `{` kvantifikátor *n* `}?` v předchozí části.</span><span class="sxs-lookup"><span data-stu-id="64d60-254">See the example for the `{`*n*`}?` quantifier in the previous section for an illustration.</span></span> <span data-ttu-id="64d60-255">Regulární výraz v tomto příkladu používá `{` *n* `,}` Kvantifikátor n pro spárování řetězce, který má alespoň tři znaky následované tečkou.</span><span class="sxs-lookup"><span data-stu-id="64d60-255">The regular expression in that example uses the `{`*n*`,}` quantifier to match a string that has at least three characters followed by a period.</span></span>  
  
### <a name="match-between-n-and-m-times-lazy-match-nm"></a><span data-ttu-id="64d60-256">Rozlišovat mezi n a m krátkou (opožděné porovnávání): {n, m}?</span><span class="sxs-lookup"><span data-stu-id="64d60-256">Match Between n and m Times (Lazy Match): {n,m}?</span></span>  
 <span data-ttu-id="64d60-257">Kvantifikátor `{` *n* `,` *m* `}?` odpovídá předchozímu prvku mezi `n` a `m` časy, kde *n* a *m* jsou celá čísla, ale s co nejmenším možným počtem opakování.</span><span class="sxs-lookup"><span data-stu-id="64d60-257">The `{`*n*`,`*m*`}?` quantifier matches the preceding element between `n` and `m` times, where *n* and *m* are integers, but as few times as possible.</span></span> <span data-ttu-id="64d60-258">Je opožděným protějškem hladového kvantifikátoru `{` *n* `,` *m* `}` .</span><span class="sxs-lookup"><span data-stu-id="64d60-258">It is the lazy counterpart of the greedy quantifier `{`*n*`,`*m*`}`.</span></span>  
  
 <span data-ttu-id="64d60-259">V následujícím příkladu regulární výraz `\b[A-Z](\w*?\s*?){1,10}[.!?]` odpovídá vět, které obsahují jedno a deset slov.</span><span class="sxs-lookup"><span data-stu-id="64d60-259">In the following example, the regular expression `\b[A-Z](\w*?\s*?){1,10}[.!?]` matches sentences that contain between one and ten words.</span></span> <span data-ttu-id="64d60-260">Odpovídá všem větuem ve vstupním řetězci s výjimkou jedné věty, která obsahuje 18 slov.</span><span class="sxs-lookup"><span data-stu-id="64d60-260">It matches all the sentences in the input string except for one sentence that contains 18 words.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers#12](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#12)]
 [!code-vb[RegularExpressions.Quantifiers#12](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#12)]  
  
 <span data-ttu-id="64d60-261">Vzor regulárního výrazu je definován tak, jak je uvedeno v následující tabulce.</span><span class="sxs-lookup"><span data-stu-id="64d60-261">The regular expression pattern is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="64d60-262">Vzor</span><span class="sxs-lookup"><span data-stu-id="64d60-262">Pattern</span></span>|<span data-ttu-id="64d60-263">Popis</span><span class="sxs-lookup"><span data-stu-id="64d60-263">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="64d60-264">Začne na hranici slova.</span><span class="sxs-lookup"><span data-stu-id="64d60-264">Start at a word boundary.</span></span>|  
|`[A-Z]`|<span data-ttu-id="64d60-265">Porovnává velké písmeno od A do Z.</span><span class="sxs-lookup"><span data-stu-id="64d60-265">Match an uppercase character from A to Z.</span></span>|  
|`(\w*?\s*?)`|<span data-ttu-id="64d60-266">Porovná žádný nebo více slovních znaků následovaných jedním nebo více prázdnými znaky, ale co nejmenším možným počtem opakování.</span><span class="sxs-lookup"><span data-stu-id="64d60-266">Match zero or more word characters, followed by one or more white-space characters, but as few times as possible.</span></span> <span data-ttu-id="64d60-267">Toto je první skupina zachycení.</span><span class="sxs-lookup"><span data-stu-id="64d60-267">This is the first capture group.</span></span>|  
|`{1,10}`|<span data-ttu-id="64d60-268">Porovnává s předchozím vzorem mezi 1 a 10krát.</span><span class="sxs-lookup"><span data-stu-id="64d60-268">Match the previous pattern between 1 and 10 times.</span></span>|  
|`[.!?]`|<span data-ttu-id="64d60-269">Porovnává s libovolným znakem interpunkce ".", "!" nebo "?".</span><span class="sxs-lookup"><span data-stu-id="64d60-269">Match any one of the punctuation characters ".", "!", or "?".</span></span>|  
  
<a name="Greedy"></a>
## <a name="greedy-and-lazy-quantifiers"></a><span data-ttu-id="64d60-270">Hladce a opožděné kvantifikátory</span><span class="sxs-lookup"><span data-stu-id="64d60-270">Greedy and Lazy Quantifiers</span></span>  
 <span data-ttu-id="64d60-271">Počet kvantifikátorů má dvě verze:</span><span class="sxs-lookup"><span data-stu-id="64d60-271">A number of the quantifiers have two versions:</span></span>  
  
- <span data-ttu-id="64d60-272">Hladec – verze</span><span class="sxs-lookup"><span data-stu-id="64d60-272">A greedy version.</span></span>  
  
     <span data-ttu-id="64d60-273">Hladový kvantifikátor se snaží porovnat prvek tolikrát, kolikrát je to možné.</span><span class="sxs-lookup"><span data-stu-id="64d60-273">A greedy quantifier tries to match an element as many times as possible.</span></span>  
  
- <span data-ttu-id="64d60-274">Nehladec (nebo opožděná) verze.</span><span class="sxs-lookup"><span data-stu-id="64d60-274">A non-greedy (or lazy) version.</span></span>  
  
     <span data-ttu-id="64d60-275">Nehladý kvantifikátor se snaží porovnat element co nejmenším možným počtem opakování.</span><span class="sxs-lookup"><span data-stu-id="64d60-275">A non-greedy quantifier tries to match an element as few times as possible.</span></span> <span data-ttu-id="64d60-276">Hladový kvantifikátor můžete převést na opožděný kvantifikátor pouhým přidáním `?` .</span><span class="sxs-lookup"><span data-stu-id="64d60-276">You can turn a greedy quantifier into a lazy quantifier by simply adding a `?`.</span></span>  
  
 <span data-ttu-id="64d60-277">Vezměte v úvahu jednoduchý regulární výraz, který je určen k extrakci posledních čtyř číslic z řetězce čísel, jako je číslo platební karty.</span><span class="sxs-lookup"><span data-stu-id="64d60-277">Consider a simple regular expression that is intended to extract the last four digits from a string of numbers such as a credit card number.</span></span> <span data-ttu-id="64d60-278">Verze regulárního výrazu, který používá `*` hladce kvantifikátor je `\b.*([0-9]{4})\b` .</span><span class="sxs-lookup"><span data-stu-id="64d60-278">The version of the regular expression that uses the `*` greedy quantifier is `\b.*([0-9]{4})\b`.</span></span> <span data-ttu-id="64d60-279">Nicméně pokud řetězec obsahuje dvě čísla, tento regulární výraz odpovídá posledním čtyřm číslicím druhé číslo, jak ukazuje následující příklad.</span><span class="sxs-lookup"><span data-stu-id="64d60-279">However, if a string contains two numbers, this regular expression matches the last four digits of the second number only, as the following example shows.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers.Greedy#1](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers.Greedy/cs/Greedy.cs#1)]
 [!code-vb[RegularExpressions.Quantifiers.Greedy#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers.Greedy/vb/Greedy.vb#1)]  
  
 <span data-ttu-id="64d60-280">Regulární výraz neshoduje s prvním číslem `*` , protože kvantifikátor se pokusí porovnat předchozí prvek v celém řetězci tolikrát, kolikrát je to možné, a tak najde shodu na konci řetězce.</span><span class="sxs-lookup"><span data-stu-id="64d60-280">The regular expression fails to match the first number because the `*` quantifier tries to match the previous element as many times as possible in the entire string, and so it finds its match at the end of the string.</span></span>  
  
 <span data-ttu-id="64d60-281">Nejedná se o požadované chování.</span><span class="sxs-lookup"><span data-stu-id="64d60-281">This is not the desired behavior.</span></span> <span data-ttu-id="64d60-282">Místo toho můžete použít `*?` opožděný kvantifikátor k extrakci číslic z obou čísel, jak ukazuje následující příklad.</span><span class="sxs-lookup"><span data-stu-id="64d60-282">Instead, you can use the `*?`lazy quantifier to extract digits from both numbers, as the following example shows.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers.Greedy#2](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers.Greedy/cs/Greedy.cs#2)]
 [!code-vb[RegularExpressions.Quantifiers.Greedy#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers.Greedy/vb/Greedy.vb#2)]  
  
 <span data-ttu-id="64d60-283">Ve většině případů regulární výrazy s hladkou a opožděným kvantifikátorem vracejí stejné shody.</span><span class="sxs-lookup"><span data-stu-id="64d60-283">In most cases, regular expressions with greedy and lazy quantifiers return the same matches.</span></span> <span data-ttu-id="64d60-284">Nejčastěji vracejí různé výsledky při použití se metaznakem zástupného znaku ( `.` ), který odpovídá jakémukoli znaku.</span><span class="sxs-lookup"><span data-stu-id="64d60-284">They most commonly return different results when they are used with the wildcard (`.`) metacharacter, which matches any character.</span></span>  
  
## <a name="quantifiers-and-empty-matches"></a><span data-ttu-id="64d60-285">Kvantifikátory a prázdné shody</span><span class="sxs-lookup"><span data-stu-id="64d60-285">Quantifiers and Empty Matches</span></span>  
 <span data-ttu-id="64d60-286">Kvantifikátory `*` , `+` a `{` *n* `,` *m* `}` a jejich opožděné protějšky se nikdy neopakují po prázdné shodě, pokud byl nalezen minimální počet zachycení.</span><span class="sxs-lookup"><span data-stu-id="64d60-286">The quantifiers `*`, `+`, and `{`*n*`,`*m*`}` and their lazy counterparts never repeat after an empty match when the minimum number of captures has been found.</span></span> <span data-ttu-id="64d60-287">Toto pravidlo brání kvantifikátorům v zadávání nekonečných smyček u prázdných dílčích výrazů, pokud je maximální počet možných zachycení skupin nekonečný nebo je blízko nekonečné.</span><span class="sxs-lookup"><span data-stu-id="64d60-287">This rule prevents quantifiers from entering infinite loops on empty subexpression matches when the maximum number of possible group captures is infinite or near infinite.</span></span>  
  
 <span data-ttu-id="64d60-288">Například následující kód ukazuje výsledek volání <xref:System.Text.RegularExpressions.Regex.Match%2A?displayProperty=nameWithType> metody se vzorem regulárního výrazu `(a?)*` , který odpovídá žádnému nebo jednomu znaku "a" nula nebo vícekrát.</span><span class="sxs-lookup"><span data-stu-id="64d60-288">For example, the following code shows the result of a call to the <xref:System.Text.RegularExpressions.Regex.Match%2A?displayProperty=nameWithType> method with the regular expression pattern `(a?)*`, which matches zero or one "a" character zero or more times.</span></span> <span data-ttu-id="64d60-289">Všimněte si, že jedna zachytávající skupina zachycuje každou "a" <xref:System.String.Empty?displayProperty=nameWithType> , ale neexistuje žádná druhá prázdná shoda, protože první prázdná shoda způsobí, že kvantifikátor přestane opakovat.</span><span class="sxs-lookup"><span data-stu-id="64d60-289">Note that the single capturing group captures each "a" as well as <xref:System.String.Empty?displayProperty=nameWithType>, but that there is no second empty match, because the first empty match causes the quantifier to stop repeating.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers.EmptyMatch#1](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.quantifiers.emptymatch/cs/emptymatch1.cs#1)]
 [!code-vb[RegularExpressions.Quantifiers.EmptyMatch#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.quantifiers.emptymatch/vb/emptymatch1.vb#1)]  
  
 <span data-ttu-id="64d60-290">Chcete-li zobrazit praktický rozdíl mezi zachytávající skupinou definující minimální a maximální počet zachycení a jednu, která definuje pevný počet zachycení, zvažte vzory regulárních výrazů `(a\1|(?(1)\1)){0,2}` a `(a\1|(?(1)\1)){2}` .</span><span class="sxs-lookup"><span data-stu-id="64d60-290">To see the practical difference between a capturing group that defines a minimum and a maximum number of captures and one that defines a fixed number of captures, consider the regular expression patterns `(a\1|(?(1)\1)){0,2}` and `(a\1|(?(1)\1)){2}`.</span></span> <span data-ttu-id="64d60-291">Oba regulární výrazy se skládají z jedné zachytávající skupiny, která je definována tak, jak je uvedeno v následující tabulce.</span><span class="sxs-lookup"><span data-stu-id="64d60-291">Both regular expressions consist of a single capturing group, which is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="64d60-292">Vzor</span><span class="sxs-lookup"><span data-stu-id="64d60-292">Pattern</span></span>|<span data-ttu-id="64d60-293">Popis</span><span class="sxs-lookup"><span data-stu-id="64d60-293">Description</span></span>|  
|-------------|-----------------|  
|`(a\1`|<span data-ttu-id="64d60-294">Buď porovnává "a" spolu s hodnotou první zachycené skupiny...</span><span class="sxs-lookup"><span data-stu-id="64d60-294">Either match "a" along with the value of the first captured group …</span></span>|  
|<code>&#124;(?(1)</code>|<span data-ttu-id="64d60-295">…</span><span class="sxs-lookup"><span data-stu-id="64d60-295">…</span></span> <span data-ttu-id="64d60-296">nebo testujte, zda byla definována první zachycená skupina.</span><span class="sxs-lookup"><span data-stu-id="64d60-296">or test whether the first captured group has been defined.</span></span> <span data-ttu-id="64d60-297">(Všimněte si, že `(?(1)` konstrukce nedefinuje zachytávající skupinu.)</span><span class="sxs-lookup"><span data-stu-id="64d60-297">(Note that the `(?(1)` construct does not define a capturing group.)</span></span>|  
|`\1))`|<span data-ttu-id="64d60-298">Pokud existuje první zachycená skupina, odpovídá její hodnotě.</span><span class="sxs-lookup"><span data-stu-id="64d60-298">If the first captured group exists, match its value.</span></span> <span data-ttu-id="64d60-299">Pokud skupina neexistuje, bude skupina odpovídat <xref:System.String.Empty?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="64d60-299">If the group does not exist, the group will match <xref:System.String.Empty?displayProperty=nameWithType>.</span></span>|  
  
 <span data-ttu-id="64d60-300">První regulární výraz se pokusí porovnat tento vzor mezi nulou a dvakrát. druhý, přesně dvakrát.</span><span class="sxs-lookup"><span data-stu-id="64d60-300">The first regular expression tries to match this pattern between zero and two times; the second, exactly two times.</span></span> <span data-ttu-id="64d60-301">Vzhledem k tomu, že první vzor dosáhne svého minimálního počtu zachycení s jeho prvním zachycením <xref:System.String.Empty?displayProperty=nameWithType> , se nikdy neopakuje pokus o porovnání `a\1` . `{0,2}` kvantifikátor povoluje v poslední iteraci pouze prázdné shody.</span><span class="sxs-lookup"><span data-stu-id="64d60-301">Because the first pattern reaches its minimum number of captures with its first capture of <xref:System.String.Empty?displayProperty=nameWithType>, it never repeats to try to match `a\1`; the `{0,2}` quantifier allows only empty matches in the last iteration.</span></span> <span data-ttu-id="64d60-302">Naopak druhý regulární výraz odpovídá "a", protože vyhodnocuje `a\1` druhý čas. minimální počet iterací, 2, vynutí, aby se modul opakoval po prázdné shodě.</span><span class="sxs-lookup"><span data-stu-id="64d60-302">In contrast, the second regular expression does match "a" because it evaluates `a\1` a second time; the minimum number of iterations, 2, forces the engine to repeat after an empty match.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers.EmptyMatch#2](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.quantifiers.emptymatch/cs/emptymatch4.cs#2)]
 [!code-vb[RegularExpressions.Quantifiers.EmptyMatch#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.quantifiers.emptymatch/vb/emptymatch4.vb#2)]  
  
## <a name="see-also"></a><span data-ttu-id="64d60-303">Viz také</span><span class="sxs-lookup"><span data-stu-id="64d60-303">See also</span></span>

- [<span data-ttu-id="64d60-304">Jazyk regulárních výrazů – stručná referenční dokumentace</span><span class="sxs-lookup"><span data-stu-id="64d60-304">Regular Expression Language - Quick Reference</span></span>](regular-expression-language-quick-reference.md)
- [<span data-ttu-id="64d60-305">Zpětné navracení</span><span class="sxs-lookup"><span data-stu-id="64d60-305">Backtracking</span></span>](backtracking-in-regular-expressions.md)
