---
title: Vyvolání platformy (volání nespravovaného objektu)
description: Naučte se volat nativní funkce prostřednictvím volání nespravovaného kódu v .NET.
author: jkoritzinsky
ms.author: jekoritz
ms.date: 01/18/2019
ms.openlocfilehash: cda738a173cbe61cf49f79ceef78c533a5a879d9
ms.sourcegitcommit: 6f28b709592503d27077b16fff2e2eacca569992
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 08/28/2019
ms.locfileid: "70106788"
---
# <a name="platform-invoke-pinvoke"></a><span data-ttu-id="1fa39-103">Vyvolání platformy (volání nespravovaného objektu)</span><span class="sxs-lookup"><span data-stu-id="1fa39-103">Platform Invoke (P/Invoke)</span></span>

<span data-ttu-id="1fa39-104">Volání nespravovaného kódu je technologie, která umožňuje přístup ke strukturám, zpětným voláním a funkcím v nespravovaných knihovnách ze spravovaného kódu.</span><span class="sxs-lookup"><span data-stu-id="1fa39-104">P/Invoke is a technology that allows you to access structs, callbacks, and functions in unmanaged libraries from your managed code.</span></span> <span data-ttu-id="1fa39-105">Většina rozhraní API pro volání nespravovaného systému je obsažena ve `System` dvou `System.Runtime.InteropServices`oborech názvů: a.</span><span class="sxs-lookup"><span data-stu-id="1fa39-105">Most of the P/Invoke API is contained in two namespaces: `System` and `System.Runtime.InteropServices`.</span></span> <span data-ttu-id="1fa39-106">Pomocí těchto dvou oborů názvů získáte nástroje pro popis toho, jak chcete komunikovat s nativní součástí.</span><span class="sxs-lookup"><span data-stu-id="1fa39-106">Using these two namespaces give you the tools to describe how you want to communicate with the native component.</span></span>

<span data-ttu-id="1fa39-107">Pojďme začít z nejběžnějšího příkladu a volat nespravované funkce ve spravovaném kódu.</span><span class="sxs-lookup"><span data-stu-id="1fa39-107">Let’s start from the most common example, and that is calling unmanaged functions in your managed code.</span></span> <span data-ttu-id="1fa39-108">Pojďme zobrazit okno se zprávou z aplikace příkazového řádku:</span><span class="sxs-lookup"><span data-stu-id="1fa39-108">Let’s show a message box from a command-line application:</span></span>

[!code-csharp[MessageBox](~/samples/snippets/standard/interop/pinvoke/messagebox.cs)]

<span data-ttu-id="1fa39-109">Předchozí příklad je jednoduchý, ale ukazuje, co je potřeba k vyvolání nespravovaných funkcí ze spravovaného kódu.</span><span class="sxs-lookup"><span data-stu-id="1fa39-109">The previous example is simple, but it does show off what's needed to invoke unmanaged functions from managed code.</span></span> <span data-ttu-id="1fa39-110">Podíváme se na příklad:</span><span class="sxs-lookup"><span data-stu-id="1fa39-110">Let’s step through the example:</span></span>

- <span data-ttu-id="1fa39-111">Řádková #1 zobrazuje příkaz using pro `System.Runtime.InteropServices` obor názvů, který obsahuje všechny potřebné položky.</span><span class="sxs-lookup"><span data-stu-id="1fa39-111">Line #1 shows the using statement for the `System.Runtime.InteropServices` namespace that holds all the items needed.</span></span>
- <span data-ttu-id="1fa39-112">Řádek #7 zavádí `DllImport` atribut.</span><span class="sxs-lookup"><span data-stu-id="1fa39-112">Line #7 introduces the `DllImport` attribute.</span></span> <span data-ttu-id="1fa39-113">Tento atribut je rozhodující, protože říká modulu runtime, že by měl načíst nespravovanou knihovnu DLL.</span><span class="sxs-lookup"><span data-stu-id="1fa39-113">This attribute is crucial, as it tells the runtime that it should load the unmanaged DLL.</span></span> <span data-ttu-id="1fa39-114">Předaný řetězec je naším cílovou funkcí knihovny DLL.</span><span class="sxs-lookup"><span data-stu-id="1fa39-114">The string passed in is the DLL our target function is in.</span></span> <span data-ttu-id="1fa39-115">Kromě toho určuje, která [znaková sada](./charset.md) se má použít pro zařazování řetězců.</span><span class="sxs-lookup"><span data-stu-id="1fa39-115">Additionally, it specifies which [character set](./charset.md) to use for marshalling the strings.</span></span> <span data-ttu-id="1fa39-116">Nakonec určuje, že tato funkce volá [SetLastError](/windows/desktop/api/errhandlingapi/nf-errhandlingapi-setlasterror) a že má modul runtime zachytit kód chyby, aby ho uživatel mohl načíst prostřednictvím <xref:System.Runtime.InteropServices.Marshal.GetLastWin32Error?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="1fa39-116">Finally, it specifies that this function calls [SetLastError](/windows/desktop/api/errhandlingapi/nf-errhandlingapi-setlasterror) and that the runtime should capture that error code so the user can retrieve it via <xref:System.Runtime.InteropServices.Marshal.GetLastWin32Error?displayProperty=nameWithType>.</span></span>
- <span data-ttu-id="1fa39-117">Řádková #8 je Crux práce P/Invoke.</span><span class="sxs-lookup"><span data-stu-id="1fa39-117">Line #8 is the crux of the P/Invoke work.</span></span> <span data-ttu-id="1fa39-118">Definuje spravovanou metodu, která má **přesně stejný podpis** jako nespravovaný.</span><span class="sxs-lookup"><span data-stu-id="1fa39-118">It defines a managed method that has the **exact same signature** as the unmanaged one.</span></span> <span data-ttu-id="1fa39-119">Deklarace má nové klíčové slovo, které si můžete všimnout, `extern`a který oznamuje modulu runtime, že se jedná o externí metodu a že když ji vyvoláte, modul runtime ji by měl najít v knihovně `DllImport` DLL určené v atributu.</span><span class="sxs-lookup"><span data-stu-id="1fa39-119">The declaration has a new keyword that you can notice, `extern`, which tells the runtime this is an external method, and that when you invoke it, the runtime should find it in the DLL specified in `DllImport` attribute.</span></span>

<span data-ttu-id="1fa39-120">Zbytek příkladu je pouze volání metody, stejně jako u jakékoli jiné spravované metody.</span><span class="sxs-lookup"><span data-stu-id="1fa39-120">The rest of the example is just invoking the method as you would any other managed method.</span></span>

<span data-ttu-id="1fa39-121">Ukázka je podobná pro macOS.</span><span class="sxs-lookup"><span data-stu-id="1fa39-121">The sample is similar for macOS.</span></span> <span data-ttu-id="1fa39-122">Název knihovny v `DllImport` atributu musí být změněn, protože MacOS má jiné schéma pojmenování dynamických knihoven.</span><span class="sxs-lookup"><span data-stu-id="1fa39-122">The name of the library in the `DllImport` attribute needs to change since macOS has a different scheme of naming dynamic libraries.</span></span> <span data-ttu-id="1fa39-123">Následující příklad používá `getpid(2)` funkci k získání ID procesu aplikace a jejím tisku do konzoly:</span><span class="sxs-lookup"><span data-stu-id="1fa39-123">The following sample uses the `getpid(2)` function to get the process ID of the application and print it out to the console:</span></span>

[!code-csharp[getpid macOS](~/samples/snippets/standard/interop/pinvoke/getpid-macos.cs)]

<span data-ttu-id="1fa39-124">Je to také podobné na Linux.</span><span class="sxs-lookup"><span data-stu-id="1fa39-124">It is also similar on Linux.</span></span> <span data-ttu-id="1fa39-125">Název funkce je stejný, protože `getpid(2)` se jedná o standardní systémové volání [POSIX](https://en.wikipedia.org/wiki/POSIX) .</span><span class="sxs-lookup"><span data-stu-id="1fa39-125">The function name is the same, since `getpid(2)` is a standard [POSIX](https://en.wikipedia.org/wiki/POSIX) system call.</span></span>

[!code-csharp[getpid Linux](~/samples/snippets/standard/interop/pinvoke/getpid-linux.cs)]

## <a name="invoking-managed-code-from-unmanaged-code"></a><span data-ttu-id="1fa39-126">Vyvolání spravovaného kódu z nespravovaného kódu</span><span class="sxs-lookup"><span data-stu-id="1fa39-126">Invoking managed code from unmanaged code</span></span>

<span data-ttu-id="1fa39-127">Modul runtime umožňuje komunikaci s tokem v obou směrech, takže můžete volat zpět do spravovaného kódu z nativních funkcí pomocí ukazatelů na funkce.</span><span class="sxs-lookup"><span data-stu-id="1fa39-127">The runtime allows communication to flow in both directions, enabling you to call back into managed code from native functions by using function pointers.</span></span> <span data-ttu-id="1fa39-128">Nejbližší odkaz na ukazatel na funkci ve spravovaném kódu je **delegát**, takže to je to, co se používá k povolení zpětných volání z nativního kódu do spravovaného kódu.</span><span class="sxs-lookup"><span data-stu-id="1fa39-128">The closest thing to a function pointer in managed code is a **delegate**, so this is what is used to allow callbacks from native code into managed code.</span></span>

<span data-ttu-id="1fa39-129">Způsob použití této funkce je podobný jako dříve popsaný proces spravovaný k nativnímu procesu.</span><span class="sxs-lookup"><span data-stu-id="1fa39-129">The way to use this feature is similar to the managed to native process previously described.</span></span> <span data-ttu-id="1fa39-130">Pro dané zpětné volání definujete delegáta, který odpovídá podpisu a předává ho do externí metody.</span><span class="sxs-lookup"><span data-stu-id="1fa39-130">For a given callback, you define a delegate that matches the signature and pass that into the external method.</span></span> <span data-ttu-id="1fa39-131">Modul runtime se postará o všechno ostatní.</span><span class="sxs-lookup"><span data-stu-id="1fa39-131">The runtime will take care of everything else.</span></span>

[!code-csharp[EnumWindows](~/samples/snippets/standard/interop/pinvoke/enumwindows.cs)]

<span data-ttu-id="1fa39-132">Než projdete příklad, je dobré zkontrolovat signatury nespravovaných funkcí, se kterými potřebujete pracovat.</span><span class="sxs-lookup"><span data-stu-id="1fa39-132">Before walking through the example, it's good to review the signatures of the unmanaged functions you need to work with.</span></span> <span data-ttu-id="1fa39-133">Funkce, která se má volat pro zobrazení výčtu všech oken, má následující signaturu:`BOOL EnumWindows (WNDENUMPROC lpEnumFunc, LPARAM lParam);`</span><span class="sxs-lookup"><span data-stu-id="1fa39-133">The function to be called to enumerate all of the windows has the following signature: `BOOL EnumWindows (WNDENUMPROC lpEnumFunc, LPARAM lParam);`</span></span>

<span data-ttu-id="1fa39-134">První parametr je zpětné volání.</span><span class="sxs-lookup"><span data-stu-id="1fa39-134">The first parameter is a callback.</span></span> <span data-ttu-id="1fa39-135">Uvedené zpětné volání má následující signaturu:`BOOL CALLBACK EnumWindowsProc (HWND hwnd, LPARAM lParam);`</span><span class="sxs-lookup"><span data-stu-id="1fa39-135">The said callback has the following signature: `BOOL CALLBACK EnumWindowsProc (HWND hwnd, LPARAM lParam);`</span></span>

<span data-ttu-id="1fa39-136">Teď projdeme příkladem:</span><span class="sxs-lookup"><span data-stu-id="1fa39-136">Now, let’s walk through the example:</span></span>

- <span data-ttu-id="1fa39-137">Řádek #9 v příkladu definuje delegáta, který odpovídá podpisu zpětného volání z nespravovaného kódu.</span><span class="sxs-lookup"><span data-stu-id="1fa39-137">Line #9 in the example defines a delegate that matches the signature of the callback from unmanaged code.</span></span> <span data-ttu-id="1fa39-138">Všimněte si, jak jsou typy lParam a HWND reprezentovány pomocí `IntPtr` spravovaného kódu.</span><span class="sxs-lookup"><span data-stu-id="1fa39-138">Notice how the LPARAM and HWND types are represented using `IntPtr` in the managed code.</span></span>
- <span data-ttu-id="1fa39-139">Řádky #13 a #14 zavádějí `EnumWindows` funkci z knihovny User32. dll.</span><span class="sxs-lookup"><span data-stu-id="1fa39-139">Lines #13 and #14 introduce the `EnumWindows` function from the user32.dll library.</span></span>
- <span data-ttu-id="1fa39-140">Řádky #17-20 implementujte delegáta.</span><span class="sxs-lookup"><span data-stu-id="1fa39-140">Lines #17 - 20 implement the delegate.</span></span> <span data-ttu-id="1fa39-141">V tomto jednoduchém příkladu chceme pouze výstup tohoto popisovače do konzoly.</span><span class="sxs-lookup"><span data-stu-id="1fa39-141">For this simple example, we just want to output the handle to the console.</span></span>
- <span data-ttu-id="1fa39-142">Nakonec na řádku #24 je externí metoda volána a předána delegátovi.</span><span class="sxs-lookup"><span data-stu-id="1fa39-142">Finally, in line #24, the external method is called and passed in the delegate.</span></span>

<span data-ttu-id="1fa39-143">Příklady pro Linux a macOS jsou uvedené níže.</span><span class="sxs-lookup"><span data-stu-id="1fa39-143">The Linux and macOS examples are shown below.</span></span> <span data-ttu-id="1fa39-144">Pro tyto `ftw` funkce používáme funkci, kterou lze najít v `libc`knihovně jazyka C.</span><span class="sxs-lookup"><span data-stu-id="1fa39-144">For them, we use the `ftw` function that can be found in `libc`, the C library.</span></span> <span data-ttu-id="1fa39-145">Tato funkce se používá k procházení hierarchií adresářů a přebírá ukazatel na funkci jako jeden z jeho parametrů.</span><span class="sxs-lookup"><span data-stu-id="1fa39-145">This function is used to traverse directory hierarchies and it takes a pointer to a function as one of its parameters.</span></span> <span data-ttu-id="1fa39-146">Tato funkce má následující signaturu: `int (*fn) (const char *fpath, const struct stat *sb, int typeflag)`.</span><span class="sxs-lookup"><span data-stu-id="1fa39-146">The said function has the following signature: `int (*fn) (const char *fpath, const struct stat *sb, int typeflag)`.</span></span>

[!code-csharp[ftw Linux](~/samples/snippets/standard/interop/pinvoke/ftw-linux.cs)]

<span data-ttu-id="1fa39-147">MacOS příklad používá stejnou funkci a jediným rozdílem je argument `DllImport` atributu, protože MacOS uchovává `libc` na jiném místě.</span><span class="sxs-lookup"><span data-stu-id="1fa39-147">macOS example uses the same function, and the only difference is the argument to the `DllImport` attribute, as macOS keeps `libc` in a different place.</span></span>

[!code-csharp[ftw macOS](~/samples/snippets/standard/interop/pinvoke/ftw-macos.cs)]

<span data-ttu-id="1fa39-148">Oba předchozí příklady závisí na parametrech a v obou případech jsou parametry zadány jako spravované typy.</span><span class="sxs-lookup"><span data-stu-id="1fa39-148">Both of the previous examples depend on parameters, and in both cases, the parameters are given as managed types.</span></span> <span data-ttu-id="1fa39-149">Modul runtime provádí "správnou věc" a zpracovává je na druhé straně.</span><span class="sxs-lookup"><span data-stu-id="1fa39-149">Runtime does the "right thing" and processes these into its equivalents on the other side.</span></span> <span data-ttu-id="1fa39-150">Přečtěte si informace o tom, jak jsou typy zařazeny do nativního kódu na naší stránce při [zařazování typů](type-marshaling.md).</span><span class="sxs-lookup"><span data-stu-id="1fa39-150">Learn about how types are marshaled to native code in our page on [Type marshaling](type-marshaling.md).</span></span>

## <a name="more-resources"></a><span data-ttu-id="1fa39-151">Další materiály</span><span class="sxs-lookup"><span data-stu-id="1fa39-151">More resources</span></span>

- <span data-ttu-id="1fa39-152">[PInvoke.NET wiki](https://www.pinvoke.net/) skvělý wikiweb s informacemi o běžných rozhraních API pro Windows a o tom, jak je volat.</span><span class="sxs-lookup"><span data-stu-id="1fa39-152">[PInvoke.net wiki](https://www.pinvoke.net/) an excellent Wiki with information on common Windows APIs and how to call them.</span></span>
- [<span data-ttu-id="1fa39-153">P/Invoke v C++/CLI</span><span class="sxs-lookup"><span data-stu-id="1fa39-153">P/Invoke in C++/CLI</span></span>](/cpp/dotnet/native-and-dotnet-interoperability)
- [<span data-ttu-id="1fa39-154">Dokumentace mono pro volání nespravovaného volání</span><span class="sxs-lookup"><span data-stu-id="1fa39-154">Mono documentation on P/Invoke</span></span>](https://www.mono-project.com/docs/advanced/pinvoke/)
