---
title: Vzory odolnosti aplikací
description: Architekt cloudových nativních aplikací .NET pro Azure | Vzory odolnosti aplikací
author: robvet
ms.date: 05/13/2020
ms.openlocfilehash: bb72e47704c833a2ce86f103a66b0414ce3a37ff
ms.sourcegitcommit: 27db07ffb26f76912feefba7b884313547410db5
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 05/19/2020
ms.locfileid: "83614318"
---
# <a name="application-resiliency-patterns"></a><span data-ttu-id="77f28-103">Vzory odolnosti aplikací</span><span class="sxs-lookup"><span data-stu-id="77f28-103">Application resiliency patterns</span></span>

<span data-ttu-id="77f28-104">První linií obrany je odolnost aplikací.</span><span class="sxs-lookup"><span data-stu-id="77f28-104">The first line of defense is application resiliency.</span></span>

<span data-ttu-id="77f28-105">I když můžete investovat do svého vlastního rozhraní odolného proti chybám, takové produkty už existují.</span><span class="sxs-lookup"><span data-stu-id="77f28-105">While you could invest considerable time writing your own resiliency framework, such products already exist.</span></span> <span data-ttu-id="77f28-106">[Polly](http://www.thepollyproject.org/) je komplexní odolnost proti chybám rozhraní .NET a knihovna pro plynulé zpracování chyb, která umožňuje vývojářům vyjádřit zásady odolnosti proti chybám v rámci Fluent a bezpečných vláken.</span><span class="sxs-lookup"><span data-stu-id="77f28-106">[Polly](http://www.thepollyproject.org/) is a comprehensive .NET resilience and transient-fault-handling library that allows developers to express resiliency policies in a fluent and thread-safe manner.</span></span> <span data-ttu-id="77f28-107">Polly cílí na aplikace sestavené buď pomocí .NET Framework nebo .NET Core.</span><span class="sxs-lookup"><span data-stu-id="77f28-107">Polly targets applications built with either the .NET Framework or .NET Core.</span></span> <span data-ttu-id="77f28-108">Následující tabulka popisuje funkce odolné proti chybám, `policies` které jsou v knihovně Polly k dispozici.</span><span class="sxs-lookup"><span data-stu-id="77f28-108">The following table describes the resiliency features, called `policies`, available in the Polly Library.</span></span> <span data-ttu-id="77f28-109">Je možné je použít individuálně nebo seskupit dohromady.</span><span class="sxs-lookup"><span data-stu-id="77f28-109">They can be applied individually or grouped together.</span></span>

| <span data-ttu-id="77f28-110">Zásada</span><span class="sxs-lookup"><span data-stu-id="77f28-110">Policy</span></span> | <span data-ttu-id="77f28-111">Prostředí</span><span class="sxs-lookup"><span data-stu-id="77f28-111">Experience</span></span> |
| :-------- | :-------- |
| <span data-ttu-id="77f28-112">Zkusit znovu</span><span class="sxs-lookup"><span data-stu-id="77f28-112">Retry</span></span> | <span data-ttu-id="77f28-113">Nakonfiguruje operace opakování u určených operací.</span><span class="sxs-lookup"><span data-stu-id="77f28-113">Configures retry operations on designated operations.</span></span> |
| <span data-ttu-id="77f28-114">Circuit Breaker</span><span class="sxs-lookup"><span data-stu-id="77f28-114">Circuit Breaker</span></span> | <span data-ttu-id="77f28-115">Blokuje požadované operace v případě, že chyby překračují nakonfigurovanou prahovou hodnotu.</span><span class="sxs-lookup"><span data-stu-id="77f28-115">Blocks requested operations for a predefined period when faults exceed a configured threshold</span></span> |
| <span data-ttu-id="77f28-116">Časový limit</span><span class="sxs-lookup"><span data-stu-id="77f28-116">Timeout</span></span> | <span data-ttu-id="77f28-117">Míst omezuje dobu trvání, pro kterou volající může čekat na odpověď.</span><span class="sxs-lookup"><span data-stu-id="77f28-117">Places limit on the duration for which a caller can wait for a response.</span></span> |
| <span data-ttu-id="77f28-118">Bulkhead</span><span class="sxs-lookup"><span data-stu-id="77f28-118">Bulkhead</span></span> | <span data-ttu-id="77f28-119">Omezí akce na fond zdrojů s pevnou velikostí, aby nedocházelo k selhání volání z swamping prostředku.</span><span class="sxs-lookup"><span data-stu-id="77f28-119">Constrains actions to fixed-size resource pool to prevent failing calls from swamping a resource.</span></span> |
| <span data-ttu-id="77f28-120">Mezipaměť</span><span class="sxs-lookup"><span data-stu-id="77f28-120">Cache</span></span> | <span data-ttu-id="77f28-121">Automaticky ukládá odpovědi.</span><span class="sxs-lookup"><span data-stu-id="77f28-121">Stores responses automatically.</span></span> |
| <span data-ttu-id="77f28-122">Záložní volba</span><span class="sxs-lookup"><span data-stu-id="77f28-122">Fallback</span></span> | <span data-ttu-id="77f28-123">Definuje strukturované chování při selhání.</span><span class="sxs-lookup"><span data-stu-id="77f28-123">Defines structured behavior upon a failure.</span></span> |

<span data-ttu-id="77f28-124">Všimněte si, jak je uvedeno výše v předchozím obrázku zásady odolnosti platí pro zprávy s požadavkem, ať už přicházejí z externího klienta nebo back-endové služby.</span><span class="sxs-lookup"><span data-stu-id="77f28-124">Note how in the previous figure the resiliency policies apply to request messages, whether coming from an external client or back-end service.</span></span> <span data-ttu-id="77f28-125">Cílem je kompenzovat žádost o službu, která může být v nedostupném případě.</span><span class="sxs-lookup"><span data-stu-id="77f28-125">The goal is to compensate the request for a service that might be momentarily unavailable.</span></span> <span data-ttu-id="77f28-126">Tato krátkodobá přerušení obvykle společně využívají stavové kódy HTTP uvedené v následující tabulce.</span><span class="sxs-lookup"><span data-stu-id="77f28-126">These short-lived interruptions typically manifest themselves with the HTTP status codes shown in the following table.</span></span>

| <span data-ttu-id="77f28-127">Stavový kód HTTP</span><span class="sxs-lookup"><span data-stu-id="77f28-127">HTTP Status Code</span></span>| <span data-ttu-id="77f28-128">Příčina</span><span class="sxs-lookup"><span data-stu-id="77f28-128">Cause</span></span> |
| :-------- | :-------- |
| <span data-ttu-id="77f28-129">404</span><span class="sxs-lookup"><span data-stu-id="77f28-129">404</span></span> | <span data-ttu-id="77f28-130">Nenalezeno</span><span class="sxs-lookup"><span data-stu-id="77f28-130">Not Found</span></span> |
| <span data-ttu-id="77f28-131">408</span><span class="sxs-lookup"><span data-stu-id="77f28-131">408</span></span> | <span data-ttu-id="77f28-132">Časový limit žádosti</span><span class="sxs-lookup"><span data-stu-id="77f28-132">Request timeout</span></span> |
| <span data-ttu-id="77f28-133">429</span><span class="sxs-lookup"><span data-stu-id="77f28-133">429</span></span> | <span data-ttu-id="77f28-134">Příliš mnoho požadavků (pravděpodobně bylo omezeno)</span><span class="sxs-lookup"><span data-stu-id="77f28-134">Too many requests (you've most likely been throttled)</span></span> |
| <span data-ttu-id="77f28-135">502</span><span class="sxs-lookup"><span data-stu-id="77f28-135">502</span></span> | <span data-ttu-id="77f28-136">Chybná brána</span><span class="sxs-lookup"><span data-stu-id="77f28-136">Bad gateway</span></span> |
| <span data-ttu-id="77f28-137">503</span><span class="sxs-lookup"><span data-stu-id="77f28-137">503</span></span> | <span data-ttu-id="77f28-138">Služba není k dispozici</span><span class="sxs-lookup"><span data-stu-id="77f28-138">Service unavailable</span></span> |
| <span data-ttu-id="77f28-139">504</span><span class="sxs-lookup"><span data-stu-id="77f28-139">504</span></span> | <span data-ttu-id="77f28-140">Časový limit brány</span><span class="sxs-lookup"><span data-stu-id="77f28-140">Gateway timeout</span></span> |

<span data-ttu-id="77f28-141">Otázka: budete opakovat kód stavu HTTP 403 – zakázáno?</span><span class="sxs-lookup"><span data-stu-id="77f28-141">Question: Would you retry an HTTP Status Code of 403 - Forbidden?</span></span> <span data-ttu-id="77f28-142">Ne.</span><span class="sxs-lookup"><span data-stu-id="77f28-142">No.</span></span> <span data-ttu-id="77f28-143">V tomto případě systém pracuje správně, ale informuje volajícího, že nemá oprávnění k provedení požadované operace.</span><span class="sxs-lookup"><span data-stu-id="77f28-143">Here, the system is functioning properly, but informing the caller that they aren't authorized to perform the requested operation.</span></span> <span data-ttu-id="77f28-144">Je nutné vzít v potaz pouze operace způsobené chybami.</span><span class="sxs-lookup"><span data-stu-id="77f28-144">Care must be taken to retry only those operations caused by failures.</span></span>

<span data-ttu-id="77f28-145">Jak je to doporučeno v kapitole 1, vývojáři Microsoftu vytvářejí cloudové nativní aplikace, které by měly cílit na platformu .NET Core.</span><span class="sxs-lookup"><span data-stu-id="77f28-145">As recommended in Chapter 1, Microsoft developers constructing cloud-native applications should target the .NET Core platform.</span></span> <span data-ttu-id="77f28-146">Verze 2,1 zavedla knihovnu [HTTPClientFactory](https://www.stevejgordon.co.uk/introduction-to-httpclientfactory-aspnetcore) pro vytváření instancí klienta http pro interakci s prostředky založenými na adrese URL.</span><span class="sxs-lookup"><span data-stu-id="77f28-146">Version 2.1 introduced the [HTTPClientFactory](https://www.stevejgordon.co.uk/introduction-to-httpclientfactory-aspnetcore) library for creating HTTP Client instances for interacting with URL-based resources.</span></span> <span data-ttu-id="77f28-147">Nahrazení původní třídy HTTPClient, třída Factory podporuje mnoho rozšířených funkcí, jedna z nich je [těsná integrace](../microservices/implement-resilient-applications/implement-http-call-retries-exponential-backoff-polly.md) s knihovnou odolnosti Polly.</span><span class="sxs-lookup"><span data-stu-id="77f28-147">Superseding the original HTTPClient class, the factory class supports many enhanced features, one of which is [tight integration](../microservices/implement-resilient-applications/implement-http-call-retries-exponential-backoff-polly.md) with the Polly resiliency library.</span></span> <span data-ttu-id="77f28-148">Díky tomu můžete snadno definovat zásady odolnosti ve třídě spuštění aplikace, aby se mohla zpracovávat částečná selhání a problémy s připojením.</span><span class="sxs-lookup"><span data-stu-id="77f28-148">With it, you can easily define resiliency policies in the application Startup class to handle partial failures and connectivity issues.</span></span>

<span data-ttu-id="77f28-149">Teď se podíváme na vzory pokusů o opakování a okruhu.</span><span class="sxs-lookup"><span data-stu-id="77f28-149">Next, let's expand on retry and circuit breaker patterns.</span></span>

### <a name="retry-pattern"></a><span data-ttu-id="77f28-150">Model Opakování</span><span class="sxs-lookup"><span data-stu-id="77f28-150">Retry pattern</span></span>

<span data-ttu-id="77f28-151">V distribuovaném cloudovém nativním prostředí můžou volání služeb a cloudových prostředků selhat kvůli přechodným (krátkodobým) chybám, které se obvykle po krátké době vyřeší.</span><span class="sxs-lookup"><span data-stu-id="77f28-151">In a distributed cloud-native environment, calls to services and cloud resources can fail because of transient (short-lived) failures, which typically correct themselves after a brief period of time.</span></span> <span data-ttu-id="77f28-152">Implementace strategie opakování pomáhá cloudovým nativním službám zmírnit tyto scénáře.</span><span class="sxs-lookup"><span data-stu-id="77f28-152">Implementing a retry strategy helps a cloud-native service mitigate these scenarios.</span></span>

<span data-ttu-id="77f28-153">[Vzor opakování](https://docs.microsoft.com/azure/architecture/patterns/retry) umožňuje službě opakovat operaci neúspěšné žádosti a (konfigurovatelný) kolikrát s exponenciálně rostoucí čekací dobou.</span><span class="sxs-lookup"><span data-stu-id="77f28-153">The [Retry pattern](https://docs.microsoft.com/azure/architecture/patterns/retry) enables a service to retry a failed request operation a (configurable) number of times with an exponentially increasing wait time.</span></span> <span data-ttu-id="77f28-154">Obrázek 6-2 ukazuje opakování v akci.</span><span class="sxs-lookup"><span data-stu-id="77f28-154">Figure 6-2 shows a retry in action.</span></span>

![Vzor opakování v akci](./media/retry-pattern.png)

<span data-ttu-id="77f28-156">**Obrázek 6-2**.</span><span class="sxs-lookup"><span data-stu-id="77f28-156">**Figure 6-2**.</span></span> <span data-ttu-id="77f28-157">Vzor opakování v akci</span><span class="sxs-lookup"><span data-stu-id="77f28-157">Retry pattern in action</span></span>

<span data-ttu-id="77f28-158">Na předchozím obrázku byl pro operaci požadavku implementován vzor opakování.</span><span class="sxs-lookup"><span data-stu-id="77f28-158">In the previous figure, a retry pattern has been implemented for a request operation.</span></span> <span data-ttu-id="77f28-159">Je nakonfigurovaná tak, aby umožňovala až čtyři opakované pokusy, před selháním s intervalem omezení rychlosti (čekací doba) od 2 sekund, který exponenciálně zdvojnásobuje při každém dalším pokusu.</span><span class="sxs-lookup"><span data-stu-id="77f28-159">It's configured to allow up to four retries before failing with a backoff interval (wait time) starting at two seconds, which exponentially doubles for each subsequent attempt.</span></span>

- <span data-ttu-id="77f28-160">První vyvolání se nezdařilo a vrátí stavový kód HTTP 500.</span><span class="sxs-lookup"><span data-stu-id="77f28-160">The first invocation fails and returns an HTTP status code of 500.</span></span> <span data-ttu-id="77f28-161">Aplikace počká po dobu dvou sekund a zopakuje volání.</span><span class="sxs-lookup"><span data-stu-id="77f28-161">The application waits for two seconds and retries the call.</span></span>
- <span data-ttu-id="77f28-162">Druhé vyvolání také nefunguje a vrátí stavový kód HTTP 500.</span><span class="sxs-lookup"><span data-stu-id="77f28-162">The second invocation also fails and returns an HTTP status code of 500.</span></span> <span data-ttu-id="77f28-163">Aplikace nyní zdvojnásobí omezení rychlosti interval na čtyři sekundy a zopakuje volání.</span><span class="sxs-lookup"><span data-stu-id="77f28-163">The application now doubles the backoff interval to four seconds and retries the call.</span></span>
- <span data-ttu-id="77f28-164">Nakonec se třetí volání zdaří.</span><span class="sxs-lookup"><span data-stu-id="77f28-164">Finally, the third call succeeds.</span></span>
- <span data-ttu-id="77f28-165">V tomto scénáři by se pokus o operaci opakování při zdvojnásobení omezení rychlosti doby před selháním tohoto volání pokusil o čtyři opakované pokusy.</span><span class="sxs-lookup"><span data-stu-id="77f28-165">In this scenario, the retry operation would have attempted up to four retries while doubling the backoff duration before failing the call.</span></span>
- <span data-ttu-id="77f28-166">Došlo k chybě 4. pokus o ověření se nezdařil, pro řádné zpracování problému se vyvolala záložní zásada.</span><span class="sxs-lookup"><span data-stu-id="77f28-166">Had the 4th retry attempt failed, a fallback policy would be invoked to gracefully handle the problem.</span></span>

<span data-ttu-id="77f28-167">Je důležité zvýšit omezení rychlosti období před opakovaným pokusem o volání, aby bylo možné čas služby samočinně opravovat.</span><span class="sxs-lookup"><span data-stu-id="77f28-167">It's important to increase the backoff period before retrying the call to allow the service time to self-correct.</span></span> <span data-ttu-id="77f28-168">Osvědčeným postupem je implementovat exponenciálně rostoucí omezení rychlosti (zdvojnásobit periodu při každém opakování), aby se povolila adekvátní doba opravy.</span><span class="sxs-lookup"><span data-stu-id="77f28-168">It's a best practice to implement an exponentially increasing backoff (doubling the period on each retry) to allow adequate correction time.</span></span>

## <a name="circuit-breaker-pattern"></a><span data-ttu-id="77f28-169">Vzorek pro přerušení okruhu</span><span class="sxs-lookup"><span data-stu-id="77f28-169">Circuit breaker pattern</span></span>

<span data-ttu-id="77f28-170">I když vzor opakování může přispět k vyřazení žádosti entangled v částečném selhání, existují situace, kdy selhání může být způsobeno neočekávanými událostmi, které budou vyžadovat přeložení delší dobu.</span><span class="sxs-lookup"><span data-stu-id="77f28-170">While the retry pattern can help salvage a request entangled in a partial failure, there are situations where failures can be caused by unanticipated events that will require longer periods of time to resolve.</span></span> <span data-ttu-id="77f28-171">Tyto chyby můžou být různě závažné, od částečného výpadku připojení až po úplné selhání služby.</span><span class="sxs-lookup"><span data-stu-id="77f28-171">These faults can range in severity from a partial loss of connectivity to the complete failure of a service.</span></span> <span data-ttu-id="77f28-172">V těchto situacích je bezúčelné pro aplikaci, aby se nepřetržitě opakovala operace, která není pravděpodobně úspěšná.</span><span class="sxs-lookup"><span data-stu-id="77f28-172">In these situations, it's pointless for an application to continually retry an operation that is unlikely to succeed.</span></span>

<span data-ttu-id="77f28-173">Kvůli horšímu provádění operací nepřetržitého opakování při opakovaném pokusu o nereagující službu vás může přejít na scénář útoku na nereagující službu, kde jste službu zaplavi pomocí nepřetržitých volání vyčerpání prostředků, jako jsou paměť, vlákna a databázová připojení, což způsobuje selhání nesouvisejících částí systému, které používají stejné prostředky.</span><span class="sxs-lookup"><span data-stu-id="77f28-173">To make things worse, executing continual retry operations on a non-responsive service can move you into a self-imposed denial of service scenario where you flood your service with continual calls exhausting resources such as memory, threads and database connections, causing failure in unrelated parts of the system that use the same resources.</span></span>

<span data-ttu-id="77f28-174">V těchto situacích by bylo vhodnější, že operace selže okamžitě a pokusí se o vyvolání služby pouze v případě, že je pravděpodobně úspěšná.</span><span class="sxs-lookup"><span data-stu-id="77f28-174">In these situations, it would be preferable for the operation to fail immediately and only attempt to invoke the service if it's likely to succeed.</span></span>

<span data-ttu-id="77f28-175">[Vzor přerušení okruhu](https://docs.microsoft.com/azure/architecture/patterns/circuit-breaker) může aplikaci zabránit v opakovaném pokusu o provedení operace, která pravděpodobně selže.</span><span class="sxs-lookup"><span data-stu-id="77f28-175">The [Circuit Breaker pattern](https://docs.microsoft.com/azure/architecture/patterns/circuit-breaker) can prevent an application from repeatedly trying to execute an operation that's likely to fail.</span></span> <span data-ttu-id="77f28-176">Po předem definovaném počtu neúspěšných volání blokuje veškerý provoz do služby.</span><span class="sxs-lookup"><span data-stu-id="77f28-176">After a pre-defined number of failed calls, it blocks all traffic to the service.</span></span> <span data-ttu-id="77f28-177">Pravidelně to umožní zkušebnímu volání zjistit, jestli se chyba vyřešila.</span><span class="sxs-lookup"><span data-stu-id="77f28-177">Periodically, it will allow a trial call to determine whether the fault has resolved.</span></span> <span data-ttu-id="77f28-178">Obrázek 6-3 ukazuje vzor přerušení okruhu v akci.</span><span class="sxs-lookup"><span data-stu-id="77f28-178">Figure 6-3 shows the Circuit Breaker pattern in action.</span></span>

![Vzor přerušení okruhu v akci](./media/circuit-breaker-pattern.png)

<span data-ttu-id="77f28-180">**Obrázek 6-3**.</span><span class="sxs-lookup"><span data-stu-id="77f28-180">**Figure 6-3**.</span></span> <span data-ttu-id="77f28-181">Vzor přerušení okruhu v akci</span><span class="sxs-lookup"><span data-stu-id="77f28-181">Circuit breaker pattern in action</span></span>

<span data-ttu-id="77f28-182">Na předchozím obrázku byl do původního vzoru opakování přidán vzorek pro přerušení okruhu.</span><span class="sxs-lookup"><span data-stu-id="77f28-182">In the previous figure, a Circuit Breaker pattern has been added to the original retry pattern.</span></span> <span data-ttu-id="77f28-183">Všimněte si, že po 100 neúspěšných žádostech se vypínače okruhu otevře a už neumožňuje volání služby.</span><span class="sxs-lookup"><span data-stu-id="77f28-183">Note how after 100 failed requests, the circuit breakers opens and no longer allows calls to the service.</span></span> <span data-ttu-id="77f28-184">Hodnota CheckCircuit, nastavená na 30 sekund, určuje, jak často bude knihovna umožňovat, aby služba pokračovala v jednom požadavku.</span><span class="sxs-lookup"><span data-stu-id="77f28-184">The CheckCircuit value, set at 30 seconds, specifies how often the library allows one request to proceed to the service.</span></span> <span data-ttu-id="77f28-185">Pokud je toto volání úspěšné, okruh se zavře a služba bude znovu k dispozici pro provoz.</span><span class="sxs-lookup"><span data-stu-id="77f28-185">If that call succeeds, the circuit closes and the service is once again available to traffic.</span></span>

<span data-ttu-id="77f28-186">Mějte na paměti, že záměr vzorce pro dělení na okruhy se *liší* od vzoru opakování.</span><span class="sxs-lookup"><span data-stu-id="77f28-186">Keep in mind that the intent of the Circuit Breaker pattern is *different* than that of the Retry pattern.</span></span> <span data-ttu-id="77f28-187">Vzor opakování umožňuje aplikaci opakovat operaci v očekávaném případě, že bude úspěšná.</span><span class="sxs-lookup"><span data-stu-id="77f28-187">The Retry pattern enables an application to retry an operation in the expectation that it will succeed.</span></span> <span data-ttu-id="77f28-188">Vzorek přerušení okruhu brání aplikaci v provedení operace, která pravděpodobně selže.</span><span class="sxs-lookup"><span data-stu-id="77f28-188">The Circuit Breaker pattern prevents an application from doing an operation that is likely to fail.</span></span> <span data-ttu-id="77f28-189">Aplikace obvykle *zkombinuje* tyto dva vzory pomocí vzoru opakování pro vyvolání operace prostřednictvím přerušení okruhu.</span><span class="sxs-lookup"><span data-stu-id="77f28-189">Typically, an application will *combine* these two patterns by using the Retry pattern to invoke an operation through a circuit breaker.</span></span>

## <a name="testing-for-resiliency"></a><span data-ttu-id="77f28-190">Testování odolnosti proti chybám</span><span class="sxs-lookup"><span data-stu-id="77f28-190">Testing for resiliency</span></span>

<span data-ttu-id="77f28-191">Testování odolnosti proti chybám nelze vždy provést stejným způsobem, jakým testujete funkčnost aplikace (spuštěním testů jednotek, integračních testů atd.).</span><span class="sxs-lookup"><span data-stu-id="77f28-191">Testing for resiliency cannot always be done the same way that you test application functionality (by running unit tests, integration tests and so on).</span></span> <span data-ttu-id="77f28-192">Místo toho musíte otestovat, jak se bude celá úloha v celém rozsahu chovat, když dojde k selhání, třeba i přerušovanému.</span><span class="sxs-lookup"><span data-stu-id="77f28-192">Instead, you must test how the end-to-end workload performs under failure conditions which only occur intermittently.</span></span> <span data-ttu-id="77f28-193">Například: vložení chyb na základě selhání procesů, certifikátů s vypršenou platností, nedostupnost závislých služeb atd. Pro takové testování chaos lze použít rozhraní, jako je [chaos-opice](https://github.com/Netflix/chaosmonkey) .</span><span class="sxs-lookup"><span data-stu-id="77f28-193">For example: inject failures by crashing processes, expired certificates, make dependent services unavailable etc. Frameworks like [chaos-monkey](https://github.com/Netflix/chaosmonkey) can be used for such chaos testing.</span></span>

<span data-ttu-id="77f28-194">Odolnost aplikace je potřeba ke zpracování problematických operací.</span><span class="sxs-lookup"><span data-stu-id="77f28-194">Application resiliency is a must for handling problematic requested operations.</span></span> <span data-ttu-id="77f28-195">Ale jde jenom o polovinu tohoto článku.</span><span class="sxs-lookup"><span data-stu-id="77f28-195">But, it's only half of the story.</span></span> <span data-ttu-id="77f28-196">V dalším kroku pokrýváme funkce odolnosti dostupné v cloudu Azure.</span><span class="sxs-lookup"><span data-stu-id="77f28-196">Next, we cover resiliency features available in the Azure cloud.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="77f28-197">[Předchozí](resiliency.md) 
> [Další](infrastructure-resiliency-azure.md)</span><span class="sxs-lookup"><span data-stu-id="77f28-197">[Previous](resiliency.md)
[Next](infrastructure-resiliency-azure.md)</span></span>
