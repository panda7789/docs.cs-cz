---
title: Vzorky dat nativní pro cloud
description: Architekt cloudových nativních aplikací .NET pro Azure | Modely nativních dat v cloudu
ms.date: 06/30/2019
ms.openlocfilehash: 0d251f3046fcd3f3a2f5d856a123a35d3f7ecff2
ms.sourcegitcommit: 559fcfbe4871636494870a8b716bf7325df34ac5
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 10/30/2019
ms.locfileid: "73087700"
---
# <a name="cloud-native-data-patterns"></a><span data-ttu-id="de501-103">Vzorky dat nativní pro cloud</span><span class="sxs-lookup"><span data-stu-id="de501-103">Cloud-native data patterns</span></span>

[!INCLUDE [book-preview](../../../includes/book-preview.md)]

<span data-ttu-id="de501-104">I když decentralizovaná data mohou vést k lepšímu výkonu, škálovatelnosti a úsporám nákladů, prezentují i mnoho výzev.</span><span class="sxs-lookup"><span data-stu-id="de501-104">While decentralized data can lead to improved performance, scalability, and cost savings, it also presents many challenges.</span></span> <span data-ttu-id="de501-105">Dotazování na data napříč mikroslužbami je složité.</span><span class="sxs-lookup"><span data-stu-id="de501-105">Querying for data across microservices is complex.</span></span> <span data-ttu-id="de501-106">Transakce, která zahrnuje mikroslužby, musí být spravovaná programově, protože distribuované transakce nejsou podporované v cloudových nativních aplikacích.</span><span class="sxs-lookup"><span data-stu-id="de501-106">A transaction that spans microservices must be managed programmatically as distributed transactions aren't supported in cloud-native applications.</span></span> <span data-ttu-id="de501-107">Přesunete se z světa *bezprostřední konzistence* na konečnou *konzistenci*.</span><span class="sxs-lookup"><span data-stu-id="de501-107">You  move from a world of *immediate consistency* to *eventual consistency*.</span></span>

<span data-ttu-id="de501-108">Tyto výzvy teď probereme.</span><span class="sxs-lookup"><span data-stu-id="de501-108">We discuss these challenges now.</span></span>

## <a name="cross-service-queries"></a><span data-ttu-id="de501-109">Dotazy na více služeb</span><span class="sxs-lookup"><span data-stu-id="de501-109">Cross-service queries</span></span>

<span data-ttu-id="de501-110">Jak aplikace dotazuje data, která jsou rozložená napříč mnoha nezávislými mikroslužbami?</span><span class="sxs-lookup"><span data-stu-id="de501-110">How does an application query data that is spread across many independent microservices?</span></span>

<span data-ttu-id="de501-111">Obrázek 5-4 ukazuje tento scénář.</span><span class="sxs-lookup"><span data-stu-id="de501-111">Figure 5-4 shows this scenario.</span></span>

![Dotazování napříč mikroslužbami](./media/cross-service-query.png)

<span data-ttu-id="de501-113">**Obrázek 5-4**.</span><span class="sxs-lookup"><span data-stu-id="de501-113">**Figure 5-4**.</span></span> <span data-ttu-id="de501-114">Dotazování napříč mikroslužbami</span><span class="sxs-lookup"><span data-stu-id="de501-114">Querying across microservices</span></span>

<span data-ttu-id="de501-115">Všimněte si, jak vidíte na předchozím obrázku mikroslužbu nákupního košíku, která přidá položku do nákupního košíku uživatele.</span><span class="sxs-lookup"><span data-stu-id="de501-115">Note how in the previous figure we see a shopping basket microservice that adds an item to a user's shopping cart.</span></span> <span data-ttu-id="de501-116">I když úložiště dat nákupního košíku obsahuje košík a tabulku lineItem, neobsahuje data o produktech ani cenách, protože tyto položky se nacházejí v produktech a cenách mikroslužeb.</span><span class="sxs-lookup"><span data-stu-id="de501-116">While the shopping basket's data store contains a basket and lineItem table, it doesn't contain product or pricing data as those items are found in the product and price microservices.</span></span> <span data-ttu-id="de501-117">Aby bylo možné přidat položku, potřebuje mikroslužba nákupního košíku data produktu a data o cenách.</span><span class="sxs-lookup"><span data-stu-id="de501-117">To add an item, the shopping basket microservice needs product data and pricing data.</span></span> <span data-ttu-id="de501-118">Jaké jsou možnosti získání údajů o produktu a cenách?</span><span class="sxs-lookup"><span data-stu-id="de501-118">What are options to obtain the product and pricing data?</span></span>

<span data-ttu-id="de501-119">Obrázek 5-5 ukazuje mikroslužbu nákupního košíku, která provádí přímé volání HTTP do katalogu produktů i cenové služby.</span><span class="sxs-lookup"><span data-stu-id="de501-119">Figure 5-5 shows the shopping basket microservice making a direct HTTP call to both the product catalog and pricing microservices.</span></span>

![Přímá komunikace http](./media/direct-http-communication.png)

<span data-ttu-id="de501-121">**Obrázek 5-5**.</span><span class="sxs-lookup"><span data-stu-id="de501-121">**Figure 5-5**.</span></span> <span data-ttu-id="de501-122">Přímá komunikace HTTP</span><span class="sxs-lookup"><span data-stu-id="de501-122">Direct HTTP communication</span></span>

<span data-ttu-id="de501-123">V kapitole 4 je sice možné implementovat, a proto jsme probrali, jak Přímá volání HTTP napříč mikroslužbami pojednávají systém a nepovažují se za dobrý postup.</span><span class="sxs-lookup"><span data-stu-id="de501-123">While feasible to implement, in chapter 4 we discussed how direct HTTP calls across microservices couple the system and aren't considered a good practice.</span></span>

<span data-ttu-id="de501-124">Můžeme implementovat mikroslužbu Agregátoru znázorněnou na obrázku 5-6.</span><span class="sxs-lookup"><span data-stu-id="de501-124">We could implement an aggregator microservice shown in Figure 5-6.</span></span>

![Mikroslužba Agregátoru](./media/aggregator-microservice.png)

<span data-ttu-id="de501-126">**Obrázek 5-6.**</span><span class="sxs-lookup"><span data-stu-id="de501-126">**Figure 5-6.**</span></span> <span data-ttu-id="de501-127">Mikroslužba Agregátoru</span><span class="sxs-lookup"><span data-stu-id="de501-127">Aggregator microservice</span></span>

<span data-ttu-id="de501-128">I když tento přístup zapouzdřuje pracovní postup obchodní operace v rámci jednotlivých mikroslužeb, zvyšuje složitost a pořád má za následek Přímá volání HTTP.</span><span class="sxs-lookup"><span data-stu-id="de501-128">While this approach encapsulates the business operation workflow in an individual microservice, it adds complexity and still results in direct HTTP calls.</span></span>

<span data-ttu-id="de501-129">Běžným přístupem ke spouštění dotazů mezi službami se používá [model materializované zobrazení](https://docs.microsoft.com/azure/architecture/patterns/materialized-view), který je znázorněný na obrázku 5-7.</span><span class="sxs-lookup"><span data-stu-id="de501-129">A common approach for executing cross-service queries uses the [Materialized View Pattern](https://docs.microsoft.com/azure/architecture/patterns/materialized-view), shown in Figure 5-7.</span></span>

![Model materializované zobrazení](./media/materialized-view-pattern.png)

<span data-ttu-id="de501-131">**Figure5-7**.</span><span class="sxs-lookup"><span data-stu-id="de501-131">**Figure5-7**.</span></span> <span data-ttu-id="de501-132">Model materializované zobrazení</span><span class="sxs-lookup"><span data-stu-id="de501-132">Materialized View Pattern</span></span>

<span data-ttu-id="de501-133">V tomto modelu přímo umístíte místní tabulku (označovanou jako *model čtení*) do služby nákupního košíku, která obsahuje denormalizovanou kopii dat, která je potřeba od produktových a cenových mikroslužeb.</span><span class="sxs-lookup"><span data-stu-id="de501-133">With this pattern, you directly place a local table (known as a *read model*) in the shopping basket service that contains a denormalized copy of the data that is needed from the product and pricing microservices.</span></span> <span data-ttu-id="de501-134">Umístění těchto dat uvnitř nákupního košíku mikroslužba eliminuje nutnost vyvolání nákladných volání mezi službami.</span><span class="sxs-lookup"><span data-stu-id="de501-134">Placing that data inside the shopping basket microservice eliminates the need for invoking expensive cross-service calls.</span></span> <span data-ttu-id="de501-135">S daty, která jsou místní pro službu, můžete zlepšit dobu odezvy a jejich spolehlivost.</span><span class="sxs-lookup"><span data-stu-id="de501-135">With the data local to the service, you improve response time and reliability.</span></span>

<span data-ttu-id="de501-136">S tímto přístupem teď máte v systému duplicitní data.</span><span class="sxs-lookup"><span data-stu-id="de501-136">The catch with this approach is you now have duplicate data in your system.</span></span> <span data-ttu-id="de501-137">V nativních systémech cloudu se duplicitní data nepovažují za [antipattern](https://en.wikipedia.org/wiki/Anti-pattern) a obvykle se implementují v nativních systémech cloudu.</span><span class="sxs-lookup"><span data-stu-id="de501-137">In cloud-native systems, duplicate data isn't considered an [anti-pattern](https://en.wikipedia.org/wiki/Anti-pattern) and is commonly implemented in cloud-native systems.</span></span> <span data-ttu-id="de501-138">Jeden a jenom jeden systém může být vlastníkem libovolné datové sady a vy budete muset implementovat mechanismus synchronizace pro záznam systému, aby se aktualizovaly všechny přidružené modely čtení, když dojde ke změně podkladových dat.</span><span class="sxs-lookup"><span data-stu-id="de501-138">However, one and only one system can be the owner of any dataset, and you'll need to implement a synchronization mechanism for the system of record to update all of the associated read models, whenever a change to its underlying data occurs.</span></span>

## <a name="transactional-support"></a><span data-ttu-id="de501-139">Podpora transakcí</span><span class="sxs-lookup"><span data-stu-id="de501-139">Transactional support</span></span>

<span data-ttu-id="de501-140">I když dotazy napříč mikroslužbami jsou náročné, implementace transakce napříč mikroslužbami může být složitá.</span><span class="sxs-lookup"><span data-stu-id="de501-140">While queries across microservices are challenging, implementing a transaction across microservices can be complex.</span></span> <span data-ttu-id="de501-141">Základní výzvou k udržení konzistence dat napříč zdroji dat, které se nacházejí v různých mikroslužbách, nelze podléhat podstatě.</span><span class="sxs-lookup"><span data-stu-id="de501-141">The inherent challenge of maintaining data consistency across data sources that reside in different microservices can't be understated.</span></span> <span data-ttu-id="de501-142">Obrázek 5-8 ukazuje problém.</span><span class="sxs-lookup"><span data-stu-id="de501-142">Figure 5-8 shows the problem.</span></span>

![Transakce ve vzoru Saga](./media/saga-transaction-operation.png)

<span data-ttu-id="de501-144">**Obrázek 5-8**.</span><span class="sxs-lookup"><span data-stu-id="de501-144">**Figure 5-8**.</span></span> <span data-ttu-id="de501-145">Implementace transakce napříč mikroslužbami</span><span class="sxs-lookup"><span data-stu-id="de501-145">Implementing a transaction across microservices</span></span>

<span data-ttu-id="de501-146">Všimněte si, jak na předchozím obrázku pět nezávislých mikroslužeb se účastní transakce distribuovaného *vytvoření objednávky* .</span><span class="sxs-lookup"><span data-stu-id="de501-146">Note how in the previous figure five independent microservices all participate in a distributed *Create Order* transaction.</span></span> <span data-ttu-id="de501-147">Nicméně transakce pro každý z pěti jednotlivých mikroslužeb musí být úspěšná, nebo všechny musí operaci přerušit a vrátit zpět.</span><span class="sxs-lookup"><span data-stu-id="de501-147">However, the transaction for each of the five individual microservices must succeed, or all must abort and roll-back the operation.</span></span> <span data-ttu-id="de501-148">I když je integrovaná transakční podpora k dispozici v rámci každé mikroslužby, není podpora distribuované transakce napříč všemi pěti službami podporovaná.</span><span class="sxs-lookup"><span data-stu-id="de501-148">While built-in transactional support is available inside each of the microservices, there's no support for a distributed transaction across all five services.</span></span>

<span data-ttu-id="de501-149">Vzhledem k tomu, že je transakční podpora pro tuto operaci zásadní pro zachování konzistence dat v jednotlivých mikroslužbách, je nutné programově sestavit distribuovanou transakci.</span><span class="sxs-lookup"><span data-stu-id="de501-149">Since transactional support is essential for this operation to keep the data consistent in each of the microservices, you have to programmatically construct a distributed transaction.</span></span>

<span data-ttu-id="de501-150">Oblíbeným vzorem pro programové přidávání transakcí je [Saga vzor](https://blog.couchbase.com/saga-pattern-implement-business-transactions-using-microservices-part/).</span><span class="sxs-lookup"><span data-stu-id="de501-150">A popular pattern for programmatically adding transactional support is the [Saga pattern](https://blog.couchbase.com/saga-pattern-implement-business-transactions-using-microservices-part/).</span></span> <span data-ttu-id="de501-151">Je implementováno seskupením místních transakcí společně a sekvenčním vyvoláním každého z nich.</span><span class="sxs-lookup"><span data-stu-id="de501-151">It's implemented by grouping local transactions together and sequentially invoking each one.</span></span> <span data-ttu-id="de501-152">Pokud místní transakce dojde k chybě, Saga přeruší operaci a vyvolá sadu [kompenzačních transakcí](https://docs.microsoft.com/azure/architecture/patterns/compensating-transaction) pro vrácení změn provedených předchozími místními transakcemi.</span><span class="sxs-lookup"><span data-stu-id="de501-152">If a local transaction fails, the Saga aborts the operation and invokes a set of [compensating transactions](https://docs.microsoft.com/azure/architecture/patterns/compensating-transaction) to undo the changes made by the preceding local transactions.</span></span> <span data-ttu-id="de501-153">Obrázek 5-9 ukazuje neúspěšnou transakci se vzorem Saga.</span><span class="sxs-lookup"><span data-stu-id="de501-153">Figure 5-9 shows a failed transaction with the Saga pattern.</span></span>

![Vrácení zpět ve vzoru Saga](./media/saga-rollback-operation.png)

<span data-ttu-id="de501-155">**Obrázek 5-9**.</span><span class="sxs-lookup"><span data-stu-id="de501-155">**Figure 5-9**.</span></span> <span data-ttu-id="de501-156">Vrácení transakce zpět</span><span class="sxs-lookup"><span data-stu-id="de501-156">Rolling back a transaction</span></span>

<span data-ttu-id="de501-157">Všimněte si, jak na předchozím obrázku se operace *GenerateContent* v mikroslužbě hudba nezdařila.</span><span class="sxs-lookup"><span data-stu-id="de501-157">Note how in the previous figure the *GenerateContent* operation has failed in the music microservice.</span></span> <span data-ttu-id="de501-158">Saga vyvolá kompenzační transakce (červeně) k odebrání obsahu, zrušení platby a zrušení objednávky a vrátí data pro každou mikroslužbu zpět do konzistentního stavu.</span><span class="sxs-lookup"><span data-stu-id="de501-158">The Saga invokes compensating transactions (in red) to remove the content, cancel the payment, and cancel the order, returning the data for each microservice back to a consistent state.</span></span>

<span data-ttu-id="de501-159">Saga vzory jsou obvykle choreographed jako série souvisejících událostí nebo Orchestrované jako sada souvisejících příkazů.</span><span class="sxs-lookup"><span data-stu-id="de501-159">Saga patterns are typically choreographed as a series of related events or orchestrated as a set of related commands.</span></span>

## <a name="cqrs-pattern"></a><span data-ttu-id="de501-160">Vzor CQRS</span><span class="sxs-lookup"><span data-stu-id="de501-160">CQRS pattern</span></span>

<span data-ttu-id="de501-161">CQRS nebo [CQRS (Command and Query Responsibility segregation)](https://docs.microsoft.com/azure/architecture/patterns/cqrs)je model architektury, který odděluje operace, které čtou data z těch, které zapisují data.</span><span class="sxs-lookup"><span data-stu-id="de501-161">CQRS, or [Command and Query Responsibility Segregation](https://docs.microsoft.com/azure/architecture/patterns/cqrs), is an architectural pattern that separate operations that read data from those that write data.</span></span> <span data-ttu-id="de501-162">Tento model může přispět k maximalizaci výkonu, škálovatelnosti a zabezpečení.</span><span class="sxs-lookup"><span data-stu-id="de501-162">This pattern can help maximize performance, scalability, and security.</span></span>

<span data-ttu-id="de501-163">Při normálních scénářích přístupu k datům implementujete jeden model (objekt entity a úložiště), *který provádí operace čtení i zápisu* dat.</span><span class="sxs-lookup"><span data-stu-id="de501-163">In normal data access scenarios, you implement a single model (entity and repository object) that perform *both* read and write data operations.</span></span>

<span data-ttu-id="de501-164">Pokročilejší scénář přístupu k datům ale může využívat samostatné modely a tabulky dat pro čtení a zápisy.</span><span class="sxs-lookup"><span data-stu-id="de501-164">However, a more advanced data access scenario might benefit from separate models and data tables for reads and writes.</span></span> <span data-ttu-id="de501-165">Aby bylo možné zvýšit výkon, operace čtení známá jako *dotaz*se může dotazovat na vysoce denormalizovanou reprezentaci dat, aby nedocházelo k nákladným opakovaným spojením tabulek.</span><span class="sxs-lookup"><span data-stu-id="de501-165">To improve performance, the read operation, known as a *query*, might query against a highly denormalized representation of the data to avoid expensive repetitive table joins.</span></span> <span data-ttu-id="de501-166">Vzhledem k tomu, že operace *zápisu* , která se označuje jako *příkaz*, se může aktualizovat proti plně normalizované reprezentaci dat.</span><span class="sxs-lookup"><span data-stu-id="de501-166">Whereas the *write* operation, known as a *command*, might update against a fully normalized representation of the data.</span></span> <span data-ttu-id="de501-167">Pak byste museli implementovat mechanismus, aby obě reprezentace zůstala synchronizovaná. Obvykle při každé změně tabulky pro zápis vyvolá událost, která replikuje úpravu dat do tabulky pro čtení.</span><span class="sxs-lookup"><span data-stu-id="de501-167">You would then need to implement a mechanism to keep both representations in sync. Typically, whenever the write table is modified, it raises an event that replicates the data modification to the read table.</span></span>

<span data-ttu-id="de501-168">Obrázek 5-10 ukazuje implementaci CQRS vzoru.</span><span class="sxs-lookup"><span data-stu-id="de501-168">Figure 5-10 shows an implementation of the CQRS pattern.</span></span>

![Implementace CQRS](./media/cqrs-implementation.png)

<span data-ttu-id="de501-170">**Obrázek 5-10**.</span><span class="sxs-lookup"><span data-stu-id="de501-170">**Figure 5-10**.</span></span> <span data-ttu-id="de501-171">Implementace CQRS</span><span class="sxs-lookup"><span data-stu-id="de501-171">CQRS implementation</span></span>

<span data-ttu-id="de501-172">Všimněte si, jak na předchozím obrázku jsou implementovány samostatné příkazy a modely dotazů.</span><span class="sxs-lookup"><span data-stu-id="de501-172">Note how in the previous figure separate command and query models are implemented.</span></span> <span data-ttu-id="de501-173">Každá operace zápisu dat se navíc ukládá do úložiště pro zápis a pak se šíří do úložiště pro čtení.</span><span class="sxs-lookup"><span data-stu-id="de501-173">Moreover, each data write operation is saved to the write store and then propagated to the read store.</span></span> <span data-ttu-id="de501-174">Věnujte velkou pozornost tomu, jak proces šíření funguje na principu konečné [konzistence](https://www.cloudcomputingpatterns.org/eventual_consistency/), zatímco model čtení se nakonec synchronizuje s modelem zápisu, ale v procesu může dojít k prodlevě.</span><span class="sxs-lookup"><span data-stu-id="de501-174">Pay close attention to how the propagation process operates on the principle of [eventual consistency](https://www.cloudcomputingpatterns.org/eventual_consistency/), whereas the read model eventually synchronizes with the write model, but there may be some lag in the process.</span></span>

<span data-ttu-id="de501-175">Implementací oddělení máte možnost škálovat čtení a zápisy samostatně.</span><span class="sxs-lookup"><span data-stu-id="de501-175">By implementing separation, you have the ability to scale reads and writes separately.</span></span> <span data-ttu-id="de501-176">Také je možné, že budete mít větší zabezpečení při operacích zápisu než v souvislosti s čtením.</span><span class="sxs-lookup"><span data-stu-id="de501-176">As well, you might impose tighter security on write operations than those concerning reads.</span></span>

<span data-ttu-id="de501-177">CQRS vzory se obvykle aplikují na omezené části systému na základě konkrétních potřeb.</span><span class="sxs-lookup"><span data-stu-id="de501-177">Typically, CQRS patterns are applied to limited sections of your system based upon specific needs.</span></span>

## <a name="relational-vs-nosql"></a><span data-ttu-id="de501-178">Relační vs NoSQL</span><span class="sxs-lookup"><span data-stu-id="de501-178">Relational vs NoSQL</span></span>

<span data-ttu-id="de501-179">Dopad [NoSQL](https://www.geeksforgeeks.org/introduction-to-nosql/) technologií nemůžete přestavovat, zejména u distribuovaných systémů nativních pro Cloud.</span><span class="sxs-lookup"><span data-stu-id="de501-179">The impact of [NoSQL](https://www.geeksforgeeks.org/introduction-to-nosql/) technologies can't be overstated, especially for distributed cloud-native systems.</span></span> <span data-ttu-id="de501-180">Navýšení nových datových technologií v tomto prostoru má přerušená řešení, která se po vás exkluzivně spoléhala na relační databáze.</span><span class="sxs-lookup"><span data-stu-id="de501-180">The proliferation of new data technologies in this space has disrupted solutions that once exclusively relied on relational databases.</span></span>

<span data-ttu-id="de501-181">Na jedné straně byly relační databáze převládají na více než desetiletí.</span><span class="sxs-lookup"><span data-stu-id="de501-181">On the one side, relational databases have been a prevalent technology for decades.</span></span> <span data-ttu-id="de501-182">Jsou vyspělé, prověřené a široce implementované.</span><span class="sxs-lookup"><span data-stu-id="de501-182">They're mature, proven, and widely implemented.</span></span> <span data-ttu-id="de501-183">Konkurenční databázové produkty, odborné znalosti a abounds nástrojů.</span><span class="sxs-lookup"><span data-stu-id="de501-183">Competing database products, expertise and tooling abounds.</span></span> <span data-ttu-id="de501-184">Relační databáze poskytují úložiště souvisejících tabulek dat.</span><span class="sxs-lookup"><span data-stu-id="de501-184">Relational databases provide a store of related data tables.</span></span> <span data-ttu-id="de501-185">Tyto tabulky mají pevné schéma, pomocí SQL (jazyk SQL (Structured Query Language)) můžete spravovat data a mít k dispozici [kyselinu](https://www.geeksforgeeks.org/acid-properties-in-dbms/) (také známou jako atomická, konzistence, izolace a odolnost).</span><span class="sxs-lookup"><span data-stu-id="de501-185">These tables have a fixed schema, use SQL (Structured Query Language) to manage data and have [ACID](https://www.geeksforgeeks.org/acid-properties-in-dbms/) (also known as Atomicity, Consistency, Isolation, and Durability) guarantees.</span></span>

<span data-ttu-id="de501-186">Žádné databáze SQL na druhé straně odkazují na vysoce výkonná úložiště dat, která nejsou relační.</span><span class="sxs-lookup"><span data-stu-id="de501-186">No-SQL databases, on the other side, refer to high-performance, non-relational data stores.</span></span> <span data-ttu-id="de501-187">Jsou v Excelu ve vlastnostech snadného použití, škálovatelnosti, odolnosti a dostupnosti.</span><span class="sxs-lookup"><span data-stu-id="de501-187">They excel in their ease-of-use, scalability, resilience, and availability characteristics.</span></span> <span data-ttu-id="de501-188">Namísto spojování tabulek normalizovaných dat ukládá NoSQL data, která jsou v dokumentu JSON (bez schématu), obvykle.</span><span class="sxs-lookup"><span data-stu-id="de501-188">Instead of joining tables of normalized data, NoSQL stores self-describing (schemaless) data typically in JSON documents.</span></span> <span data-ttu-id="de501-189">Nenabízejí záruky na [kyselinu](https://www.geeksforgeeks.org/acid-properties-in-dbms/) .</span><span class="sxs-lookup"><span data-stu-id="de501-189">They don't offer [ACID](https://www.geeksforgeeks.org/acid-properties-in-dbms/) guarantees.</span></span>

<span data-ttu-id="de501-190">Způsob, jak pochopit rozdíly mezi těmito typy databází, najdete v [věta Cap](https://towardsdatascience.com/cap-theorem-and-distributed-database-management-systems-5c2be977950e), což je sada zásad, které se dají použít pro distribuované systémy, které stav ukládá.</span><span class="sxs-lookup"><span data-stu-id="de501-190">A way to understand the differences between these types of databases can be found in the [CAP theorem](https://towardsdatascience.com/cap-theorem-and-distributed-database-management-systems-5c2be977950e), a set of principles that can be applied to distributed systems that store state.</span></span> <span data-ttu-id="de501-191">Obrázek 5-11 ukazuje tři vlastnosti ZAKONČENí věta.</span><span class="sxs-lookup"><span data-stu-id="de501-191">Figure 5-11 shows the three properties of the CAP theorem.</span></span>

![CAP věta](./media/cap-theorem.png)

<span data-ttu-id="de501-193">**Obrázek 5-11**.</span><span class="sxs-lookup"><span data-stu-id="de501-193">**Figure 5-11**.</span></span> <span data-ttu-id="de501-194">Věta CAP</span><span class="sxs-lookup"><span data-stu-id="de501-194">The CAP theorem</span></span>

<span data-ttu-id="de501-195">Věta uvádí, že jakýkoli distribuovaný datový systém bude nabízet kompromis mezi konzistencí, dostupností a tolerancí oddílů a že každá databáze může zaručit pouze dvě ze tří vlastností:</span><span class="sxs-lookup"><span data-stu-id="de501-195">The theorem states that any distributed data system will offer a trade-off between consistency, availability, and partition tolerance, and that any database can only guarantee two of the three properties:</span></span>

- <span data-ttu-id="de501-196">*Konzistence*: každý uzel v clusteru bude reagovat s nejnovějšími daty, a to i v případě, že vyžaduje blokování požadavku, dokud nebudou všechny repliky správně aktualizovány.</span><span class="sxs-lookup"><span data-stu-id="de501-196">*Consistency*: every node in the cluster will respond with the most recent data, even if it requires blocking a request until all replicas are correctly updated.</span></span>

- <span data-ttu-id="de501-197">*Dostupnost*: každý uzel vrátí odpověď v rozumné době, i když tato odpověď není nejaktuálnější data.</span><span class="sxs-lookup"><span data-stu-id="de501-197">*Availability*: every node will return a response in a reasonable amount of time, even if that response isn't the most recent data.</span></span>

- <span data-ttu-id="de501-198">*Tolerance oddílu*: garantuje, že systém bude pokračovat v provozu, pokud uzel selže nebo ztratí spojení s jiným.</span><span class="sxs-lookup"><span data-stu-id="de501-198">*Partition Tolerance*: guarantees that the system will continue operating if a node fails or loses connectivity with another.</span></span>

<span data-ttu-id="de501-199">Relační databáze vykazují konzistenci a dostupnost, ale ne toleranci oddílů.</span><span class="sxs-lookup"><span data-stu-id="de501-199">Relational databases exhibit consistency and availability, but not partition tolerance.</span></span> <span data-ttu-id="de501-200">Rozdělení relační databáze, jako je například horizontálního dělení, je obtížné a může mít vliv na výkon.</span><span class="sxs-lookup"><span data-stu-id="de501-200">Partitioning a relational database, such as sharding, is difficult and can impact performance.</span></span>

<span data-ttu-id="de501-201">Na druhé straně databáze NoSQL obvykle vykazují toleranci oddílu, označovanou jako horizontální škálovatelnost a vysoká dostupnost.</span><span class="sxs-lookup"><span data-stu-id="de501-201">On the other hand, NoSQL databases typically exhibit partition tolerance, known as horizontal scalability, and high availability.</span></span> <span data-ttu-id="de501-202">Když věta CAP určuje, můžete mít jenom dva ze tří principů a ztratíte vlastnost konzistence.</span><span class="sxs-lookup"><span data-stu-id="de501-202">As the CAP theorem specifies, you can only have two of the three principles, and you lose the  consistency property.</span></span>

<span data-ttu-id="de501-203">Databáze NoSQL jsou distribuované a běžně se škálují napříč komoditních serverů.</span><span class="sxs-lookup"><span data-stu-id="de501-203">NoSQL databases are distributed and commonly scaled out across commodity servers.</span></span> <span data-ttu-id="de501-204">Díky tomu může dojišťovat skvělou dostupnost v rámci i napříč geografickými oblastmi s nižšími náklady.</span><span class="sxs-lookup"><span data-stu-id="de501-204">Doing so can provide great availability, both within and across geographical regions at a reduced cost.</span></span> <span data-ttu-id="de501-205">Data je možné rozdělit do oddílů a replikovat na těchto počítačích nebo v uzlech, které zajišťují redundanci a odolnost proti chybám.</span><span class="sxs-lookup"><span data-stu-id="de501-205">Data can be partitioned and replicated across these machines, or nodes, providing redundancy and fault tolerance.</span></span> <span data-ttu-id="de501-206">Nevýhodou je konzistence.</span><span class="sxs-lookup"><span data-stu-id="de501-206">The downside is consistency.</span></span> <span data-ttu-id="de501-207">Změna dat v jednom uzlu NoSQL může trvat delší dobu, než se rozšíří do jiných uzlů.</span><span class="sxs-lookup"><span data-stu-id="de501-207">A change to data on one NoSQL node can take some time to propagate to other nodes.</span></span> <span data-ttu-id="de501-208">Obvykle uzel databáze NoSQL poskytne okamžitou odezvu na dotaz, i když data, která prezentují, jsou zastaralá a zatím se neaktualizovala.</span><span class="sxs-lookup"><span data-stu-id="de501-208">Typically, a NoSQL database node will provide an immediate response to a query, even if the data that it is presenting is stale and has not been updated yet.</span></span>

<span data-ttu-id="de501-209">Jedná se o konečnou [konzistenci](https://www.cloudcomputingpatterns.org/eventual_consistency/), která je charakteristická pro distribuované datové systémy, kde se nepodporují nepodporované transakce kyseliny.</span><span class="sxs-lookup"><span data-stu-id="de501-209">This is known [eventual consistency](https://www.cloudcomputingpatterns.org/eventual_consistency/), a characteristic of distributed data systems where ACID transactions aren't supported.</span></span> <span data-ttu-id="de501-210">Jedná se o krátké zpoždění mezi aktualizací datové položky a časem potřebným k rozšíření této aktualizace na každý uzel repliky.</span><span class="sxs-lookup"><span data-stu-id="de501-210">It's a brief delay between the update of a data item and time that it takes to propagate that update to each of the replica nodes.</span></span> <span data-ttu-id="de501-211">Pokud aktualizujete položku produktu v NoSQL databázi v USA, ale současně se dotazuje na stejnou datovou položku z uzlu repliky v Evropě, můžete načíst předchozí informace o produktu – dokud se neaktualizuje Evropský uzel o změnu produktu.</span><span class="sxs-lookup"><span data-stu-id="de501-211">If you update a product item in a NoSQL database in the United States, but at same time query that same data item from a replica node in Europe, you might retrieve the earlier product information - until the European node has been updated with product change.</span></span> <span data-ttu-id="de501-212">Je možné, že při zajištění [vysoké konzistence](https://en.wikipedia.org/wiki/Strong_consistency)čeká na aktualizaci všech uzlů repliky, než se vrátí výsledek dotazu, můžete podporovat obrovský objem škálování a provozu, ale s možností prezentace starších dat.</span><span class="sxs-lookup"><span data-stu-id="de501-212">The trade-off is that by giving up [strong consistency](https://en.wikipedia.org/wiki/Strong_consistency),  waiting for all replica nodes to update before returning a query result, you can support enormous scale and traffic volume, but with the possibility of presenting older data.</span></span>

<span data-ttu-id="de501-213">Databáze NoSQL je možné rozdělit do kategorií podle následujících čtyř modelů:</span><span class="sxs-lookup"><span data-stu-id="de501-213">NoSQL databases can be categorized by the following four models:</span></span>

- <span data-ttu-id="de501-214">*Úložiště dokumentů* (MongoDB, CouchDB, Couchbase): data (a odpovídající metadata) se ukládají nevztahně do denormalizovaných dokumentů založených na JSON v rámci databáze.</span><span class="sxs-lookup"><span data-stu-id="de501-214">*Document Store* (MongoDB, CouchDB, Couchbase): data (and corresponding metadata) is stored non-relationally in denormalized JSON-based documents inside the database.</span></span>

- <span data-ttu-id="de501-215">*Úložiště klíč/hodnota* (Redis, Riak, memcached): data jsou uložená v jednoduchých dvojicích klíč-hodnota se systémovými operacemi provedenými u jedinečného přístupového klíče, který je namapovaný na hodnotu uživatelských dat.</span><span class="sxs-lookup"><span data-stu-id="de501-215">*Key/Value Store* (Redis, Riak, memcached): data is stored in simple key-value pairs with system operations performed against a unique access key that is mapped to a value of user data.</span></span>

- <span data-ttu-id="de501-216">*Úložiště* se sjednocenými sloupci (HBA, Cassandra): související data jsou uložená ve sloupcovém formátu jako množina párů s vnořenými klíči a hodnotami v jednom sloupci, kde se data obvykle načítají jako jedna jednotka, aniž by bylo nutné spojit více tabulek dohromady.</span><span class="sxs-lookup"><span data-stu-id="de501-216">*Wide-Column Store* (HBase, Cassandra): related Data is stored in a columnar format as a set of nested-key/value pairs within a single column with data typically retrieved as a single unit without having to join multiple tables together.</span></span>

- <span data-ttu-id="de501-217">*Úložiště grafů* (NEO4J, Titan): data jsou uložená jako grafická reprezentace v rámci uzlu spolu s hranami, které určují vztah mezi uzly.</span><span class="sxs-lookup"><span data-stu-id="de501-217">*Graph stores* (neo4j, titan): data is stored as a graphical representation within a node along with edges that specify the relationship between the nodes.</span></span>

<span data-ttu-id="de501-218">Databáze NoSQL můžou být optimalizované tak, aby se zabývat velkými objemy dat, hlavně když jsou data relativně jednoduchá.</span><span class="sxs-lookup"><span data-stu-id="de501-218">NoSQL databases can be optimized to deal with large-scale data, especially when the data is relatively simple.</span></span> <span data-ttu-id="de501-219">Vezměte v úvahu databázi NoSQL v těchto případech:</span><span class="sxs-lookup"><span data-stu-id="de501-219">Consider a NoSQL database when:</span></span>

- <span data-ttu-id="de501-220">Vaše úloha vyžaduje velké a vysoké souběžnosti.</span><span class="sxs-lookup"><span data-stu-id="de501-220">Your workload requires large-scale and high-concurrency.</span></span>
- <span data-ttu-id="de501-221">Máte velký počet uživatelů.</span><span class="sxs-lookup"><span data-stu-id="de501-221">You have large numbers of users.</span></span>
- <span data-ttu-id="de501-222">Data je možné vyjádřit jednoduše bez relací.</span><span class="sxs-lookup"><span data-stu-id="de501-222">Your data can be expressed simply without relationships.</span></span>
- <span data-ttu-id="de501-223">Budete potřebovat geograficky distribuovat data.</span><span class="sxs-lookup"><span data-stu-id="de501-223">You need to geographically distribute your data.</span></span>
- <span data-ttu-id="de501-224">Nepotřebujete záruky KYSELosti.</span><span class="sxs-lookup"><span data-stu-id="de501-224">You don't need ACID guarantees.</span></span>
- <span data-ttu-id="de501-225">Bude nasazena do komoditního hardwaru.</span><span class="sxs-lookup"><span data-stu-id="de501-225">Will be deployed to commodity hardware.</span></span>

<span data-ttu-id="de501-226">Pak vezměte v úvahu relační databázi v těchto případech:</span><span class="sxs-lookup"><span data-stu-id="de501-226">Then, consider a relational database when:</span></span>

- <span data-ttu-id="de501-227">Vaše úlohy vyžadují střední až velké měřítko.</span><span class="sxs-lookup"><span data-stu-id="de501-227">Your workloads require medium to large scale.</span></span>
- <span data-ttu-id="de501-228">Souběžnost není Zásadním problémem.</span><span class="sxs-lookup"><span data-stu-id="de501-228">Concurrency isn't a major concern.</span></span>
- <span data-ttu-id="de501-229">Jsou potřeba záruky KYSELosti.</span><span class="sxs-lookup"><span data-stu-id="de501-229">ACID guarantees are needed.</span></span>
- <span data-ttu-id="de501-230">Data jsou nejlépe vyjádřena jako poměrná.</span><span class="sxs-lookup"><span data-stu-id="de501-230">Data is best expressed relationally.</span></span>
- <span data-ttu-id="de501-231">Vaše aplikace bude nasazena na rozsáhlý a vysoce koncový hardware.</span><span class="sxs-lookup"><span data-stu-id="de501-231">Your application will be deployed to large, high-end hardware.</span></span>

<span data-ttu-id="de501-232">V dalším kroku se podíváme na úložiště dat v cloudu Azure.</span><span class="sxs-lookup"><span data-stu-id="de501-232">Next, we look at data storage in the Azure cloud.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="de501-233">[Předchozí](distributed-data.md)
>[Další](azure-data-storage.md)</span><span class="sxs-lookup"><span data-stu-id="de501-233">[Previous](distributed-data.md)
[Next](azure-data-storage.md)</span></span>
