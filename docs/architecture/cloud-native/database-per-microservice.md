---
title: Samostatná databáze pro každou mikroslužbu
description: Kontrastní ukládání dat v monolitických a cloudově nativních aplikacích.
author: robvet
ms.date: 01/22/2020
ms.openlocfilehash: c0c5611fa866d70f155e4bdad2eee1181b13c065
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 03/12/2020
ms.locfileid: "79141442"
---
# <a name="database-per-microservice"></a><span data-ttu-id="e43ca-103">Samostatná databáze pro každou mikroslužbu</span><span class="sxs-lookup"><span data-stu-id="e43ca-103">Database-per-microservice</span></span>

[!INCLUDE [book-preview](../../../includes/book-preview.md)]

<span data-ttu-id="e43ca-104">Jak jsme viděli v této knize, přístup nativní pro cloud mění způsob, jakým navrhujete, nasadíte a spravujete aplikace.</span><span class="sxs-lookup"><span data-stu-id="e43ca-104">As we've seen throughout this book, a cloud-native approach changes the way you design, deploy, and manage applications.</span></span> <span data-ttu-id="e43ca-105">Změní také způsob správy a ukládání dat.</span><span class="sxs-lookup"><span data-stu-id="e43ca-105">It also changes the way you manage and store data.</span></span>

<span data-ttu-id="e43ca-106">Obrázek 5-1 kontrastuje rozdíly.</span><span class="sxs-lookup"><span data-stu-id="e43ca-106">Figure 5-1 contrasts the differences.</span></span>

![Úložiště dat v cloudových aplikacích](./media/distributed-data.png)

<span data-ttu-id="e43ca-108">**Obrázek 5-1**.</span><span class="sxs-lookup"><span data-stu-id="e43ca-108">**Figure 5-1**.</span></span> <span data-ttu-id="e43ca-109">Správa dat v cloudových nativních aplikacích</span><span class="sxs-lookup"><span data-stu-id="e43ca-109">Data management in cloud-native applications</span></span>

<span data-ttu-id="e43ca-110">Zkušení vývojáři snadno rozpoznají architekturu na levé straně obrázku 5-1.</span><span class="sxs-lookup"><span data-stu-id="e43ca-110">Experienced developers will easily recognize the architecture on the left-side of figure 5-1.</span></span> <span data-ttu-id="e43ca-111">V této *monolitické aplikaci*se komponenty obchodní ch odpovědny společně nacházejí ve vrstvě sdílených služeb a sdílejí data z jedné relační databáze.</span><span class="sxs-lookup"><span data-stu-id="e43ca-111">In this *monolithic application*, business service components collocate together in a shared services tier, sharing data from a single relational database.</span></span>

<span data-ttu-id="e43ca-112">V mnoha ohledech, jedna databáze udržuje správu dat jednoduché.</span><span class="sxs-lookup"><span data-stu-id="e43ca-112">In many ways, a single database keeps data management simple.</span></span> <span data-ttu-id="e43ca-113">Dotazování dat ve více tabulkách je jednoduché.</span><span class="sxs-lookup"><span data-stu-id="e43ca-113">Querying data across multiple tables is straightforward.</span></span> <span data-ttu-id="e43ca-114">Změny dat aktualizovat společně nebo všechny vrácení zpět.</span><span class="sxs-lookup"><span data-stu-id="e43ca-114">Changes to data update together or they all rollback.</span></span> <span data-ttu-id="e43ca-115">[Transakce ACID](https://docs.microsoft.com/windows/desktop/cossdk/acid-properties) zaručují silnou a okamžitou konzistenci.</span><span class="sxs-lookup"><span data-stu-id="e43ca-115">[ACID transactions](https://docs.microsoft.com/windows/desktop/cossdk/acid-properties) guarantee strong and immediate consistency.</span></span>

<span data-ttu-id="e43ca-116">Navrhování pro cloud nativní, bereme jiný přístup.</span><span class="sxs-lookup"><span data-stu-id="e43ca-116">Designing for cloud-native, we take a different approach.</span></span> <span data-ttu-id="e43ca-117">Na pravé straně obrázku 5-1 si všimněte, jak se obchodní funkce odděluje do malých, nezávislých mikroslužeb.</span><span class="sxs-lookup"><span data-stu-id="e43ca-117">On the right-side of Figure 5-1, note how business functionality segregates into small, independent microservices.</span></span> <span data-ttu-id="e43ca-118">Každá mikroslužba zapouzdřuje konkrétní obchodní schopnosti a vlastní data.</span><span class="sxs-lookup"><span data-stu-id="e43ca-118">Each microservice encapsulates a specific business capability and its own data.</span></span> <span data-ttu-id="e43ca-119">Monolitické databáze se rozkládá do distribuovaného datového modelu s mnoha menších databází, z nichž každý zarovnání s mikroslužeb.</span><span class="sxs-lookup"><span data-stu-id="e43ca-119">The monolithic database decomposes into a distributed data model with many smaller databases, each aligning with a microservice.</span></span> <span data-ttu-id="e43ca-120">Když se kouř vyčistí, objevíme se s návrhem, který zveřejňuje *databázi na mikroslužbu*.</span><span class="sxs-lookup"><span data-stu-id="e43ca-120">When the smoke clears, we emerge with a design that exposes a *database per microservice*.</span></span>

## <a name="why"></a><span data-ttu-id="e43ca-121">Proč?</span><span class="sxs-lookup"><span data-stu-id="e43ca-121">Why?</span></span>

<span data-ttu-id="e43ca-122">Tato databáze na mikroslužbu poskytuje mnoho výhod, zejména pro systémy, které se musí rychle vyvíjet a podporovat masivní škálování.</span><span class="sxs-lookup"><span data-stu-id="e43ca-122">This database per microservice provides many benefits, especially for systems that must evolve rapidly and support massive scale.</span></span> <span data-ttu-id="e43ca-123">S tímto modelem...</span><span class="sxs-lookup"><span data-stu-id="e43ca-123">With this model...</span></span>

- <span data-ttu-id="e43ca-124">Data domény jsou zapouzdřena v rámci služby.</span><span class="sxs-lookup"><span data-stu-id="e43ca-124">Domain data is encapsulated within the service</span></span>
- <span data-ttu-id="e43ca-125">Schéma dat se může vyvíjet bez přímého dopadu na další služby</span><span class="sxs-lookup"><span data-stu-id="e43ca-125">Data schema can evolve without directly impacting other services</span></span>
- <span data-ttu-id="e43ca-126">Každé úložiště dat může nezávisle škálovat</span><span class="sxs-lookup"><span data-stu-id="e43ca-126">Each data store can independently scale</span></span>
- <span data-ttu-id="e43ca-127">Selhání úložiště dat v jedné službě nebude mít přímý dopad na jiné služby</span><span class="sxs-lookup"><span data-stu-id="e43ca-127">A data store failure in one service won't directly impact other services</span></span>

<span data-ttu-id="e43ca-128">Oddělení dat také umožňuje každé mikroslužeb implementovat typ úložiště dat, který je nejlépe optimalizován pro jeho zatížení, potřeby úložiště a čtení a zápis u vzorců.</span><span class="sxs-lookup"><span data-stu-id="e43ca-128">Segregating data also enables each microservice to implement the data store type that is best optimized for its workload, storage needs, and read/write patterns.</span></span> <span data-ttu-id="e43ca-129">Volby zahrnují relační, dokument, klíč-hodnota, a dokonce i graf-založené úložiště dat.</span><span class="sxs-lookup"><span data-stu-id="e43ca-129">Choices include relational, document, key-value, and even graph-based data stores.</span></span>

<span data-ttu-id="e43ca-130">Obrázek 5-2 představuje princip perzistence polyglotu v cloudově nativním systému.</span><span class="sxs-lookup"><span data-stu-id="e43ca-130">Figure 5-2 presents the principle of polyglot persistence in a cloud-native system.</span></span>

![Trvalosti dat polyglotu](./media/polyglot-data-persistence.png)

<span data-ttu-id="e43ca-132">**Obrázek 5-2**.</span><span class="sxs-lookup"><span data-stu-id="e43ca-132">**Figure 5-2**.</span></span> <span data-ttu-id="e43ca-133">Trvalosti dat polyglotu</span><span class="sxs-lookup"><span data-stu-id="e43ca-133">Polyglot data persistence</span></span>

<span data-ttu-id="e43ca-134">Všimněte si na předchozím obrázku, jak každá mikroslužba podporuje jiný typ úložiště dat.</span><span class="sxs-lookup"><span data-stu-id="e43ca-134">Note in the previous figure how each microservice supports a different type of data store.</span></span>

- <span data-ttu-id="e43ca-135">Mikroslužba katalogu produktů spotřebovává relační databázi tak, aby vyhovovala bohaté relační struktuře podkladových dat.</span><span class="sxs-lookup"><span data-stu-id="e43ca-135">The product catalog microservice consumes a relational database to accommodate the rich relational structure of its underlying data.</span></span>
- <span data-ttu-id="e43ca-136">Mikroslužba nákupního košíku spotřebovává distribuovanou mezipaměť, která podporuje jeho jednoduché úložiště dat klíč-hodnota.</span><span class="sxs-lookup"><span data-stu-id="e43ca-136">The shopping cart microservice consumes a distributed cache that supports its simple, key-value data store.</span></span>
- <span data-ttu-id="e43ca-137">Řazení mikroslužby spotřebovává jak databáze dokumentů NoSql pro operace zápisu spolu s vysoce nenormalizované úložiště klíč/hodnota pro umístění velké objemy operací čtení.</span><span class="sxs-lookup"><span data-stu-id="e43ca-137">The ordering microservice consumes both a NoSql document database for write operations along with a highly denormalized key/value store to accommodate high-volumes of read operations.</span></span>
  
<span data-ttu-id="e43ca-138">Zatímco relační databáze zůstávají relevantní pro mikroslužby se složitými daty, NoSQL databáze získaly značnou popularitu.</span><span class="sxs-lookup"><span data-stu-id="e43ca-138">While relational databases remain relevant for microservices with complex data, NoSQL databases have gained considerable popularity.</span></span> <span data-ttu-id="e43ca-139">Poskytují masivní rozsah a vysokou dostupnost.</span><span class="sxs-lookup"><span data-stu-id="e43ca-139">They provide massive scale and high availability.</span></span> <span data-ttu-id="e43ca-140">Jejich bezschématová povaha umožňuje vývojářům přejít od architektury zadaných datových tříd a ORMů, které usnadňují změny a jsou časově náročné.</span><span class="sxs-lookup"><span data-stu-id="e43ca-140">Their schemaless nature allows developers to move away from an architecture of typed data classes and ORMs that make change expensive and time-consuming.</span></span> <span data-ttu-id="e43ca-141">NoSQL databáze pokrýváme dále v této kapitole.</span><span class="sxs-lookup"><span data-stu-id="e43ca-141">We cover NoSQL databases later in this chapter.</span></span>

 <span data-ttu-id="e43ca-142">Zatímco zapouzdření dat do samostatných mikroslužeb může zvýšit agilitu, výkon a škálovatelnost, představuje také mnoho výzev.</span><span class="sxs-lookup"><span data-stu-id="e43ca-142">While encapsulating  data into separate microservices can increase agility, performance, and scalability, it also presents many challenges.</span></span> <span data-ttu-id="e43ca-143">V další části diskutujeme o těchto výzvách spolu se vzory a postupy, které jim pomohou je překonat.</span><span class="sxs-lookup"><span data-stu-id="e43ca-143">In the next section, we discuss these challenges along with patterns and practices to help overcome them.</span></span>  

## <a name="cross-service-queries"></a><span data-ttu-id="e43ca-144">Dotazy mezi službami</span><span class="sxs-lookup"><span data-stu-id="e43ca-144">Cross-service queries</span></span>

<span data-ttu-id="e43ca-145">Zatímco mikroslužby jsou nezávislé a zaměřují se na konkrétní funkční funkce, jako je inventář, expedice nebo objednávání, často vyžadují integraci s jinými mikroslužbami.</span><span class="sxs-lookup"><span data-stu-id="e43ca-145">While microservices are independent and focus on specific functional capabilities, like inventory, shipping, or ordering, they frequently require integration with other microservices.</span></span> <span data-ttu-id="e43ca-146">Často integrace zahrnuje jednu *mikroslužbu dotazování* jiné pro data.</span><span class="sxs-lookup"><span data-stu-id="e43ca-146">Often the integration involves one microservice *querying* another for data.</span></span> <span data-ttu-id="e43ca-147">Obrázek 5-3 ukazuje scénář.</span><span class="sxs-lookup"><span data-stu-id="e43ca-147">Figure 5-3 shows the scenario.</span></span>

![Dotazování napříč mikroslužbami](./media/cross-service-query.png)

<span data-ttu-id="e43ca-149">**Obrázek 5-3**.</span><span class="sxs-lookup"><span data-stu-id="e43ca-149">**Figure 5-3**.</span></span> <span data-ttu-id="e43ca-150">Dotazování napříč mikroslužbami</span><span class="sxs-lookup"><span data-stu-id="e43ca-150">Querying across microservices</span></span>

<span data-ttu-id="e43ca-151">Na předchozím obrázku vidíme mikroslužbu nákupního košíku, která přidá položku do nákupního košíku uživatele.</span><span class="sxs-lookup"><span data-stu-id="e43ca-151">In the preceding figure, we see a shopping basket microservice that adds an item to a user's shopping basket.</span></span> <span data-ttu-id="e43ca-152">Zatímco úložiště dat pro tuto mikroslužbu obsahuje data košíku a řádkové položky, neudržuje data o produktech nebo cenách.</span><span class="sxs-lookup"><span data-stu-id="e43ca-152">While the data store for this microservice contains basket and line item data, it doesn't maintain product or pricing data.</span></span> <span data-ttu-id="e43ca-153">Místo toho jsou tyto datové položky vlastněny katalogu a ceny mikroslužeb.</span><span class="sxs-lookup"><span data-stu-id="e43ca-153">Instead, those data items are owned by the catalog and pricing microservices.</span></span> <span data-ttu-id="e43ca-154">To představuje problém.</span><span class="sxs-lookup"><span data-stu-id="e43ca-154">This presents a problem.</span></span> <span data-ttu-id="e43ca-155">Jak může mikroslužba nákupního košíku přidat produkt do nákupního košíku uživatele, když nemá produkt ani údaje o cenách ve své databázi?</span><span class="sxs-lookup"><span data-stu-id="e43ca-155">How can the shopping basket microservice add a product to the user's shopping basket when it doesn't have product nor pricing data in its database?</span></span>

<span data-ttu-id="e43ca-156">Jednou z možností popsaných v kapitole 4 je [přímé volání HTTP](service-to-service-communication.md#queries) z nákupního košíku do katalogu a stanovení cen mikroslužeb.</span><span class="sxs-lookup"><span data-stu-id="e43ca-156">One option discussed in Chapter 4 is a [direct HTTP call](service-to-service-communication.md#queries) from the shopping basket to the catalog and pricing microservices.</span></span> <span data-ttu-id="e43ca-157">V kapitole 4 jsme však řekli, že synchronní volání HTTP *spojuje pár* mikroslužeb, čímž snižuje jejich autonomii a snižuje jejich architektonické výhody.</span><span class="sxs-lookup"><span data-stu-id="e43ca-157">However, in chapter 4, we said synchronous HTTP calls *couple* microservices together, reducing their autonomy and diminishing their architectural benefits.</span></span>

<span data-ttu-id="e43ca-158">Můžeme také implementovat vzor požadavek odpověď se samostatnými příchozía odchozí fronty pro každou službu.</span><span class="sxs-lookup"><span data-stu-id="e43ca-158">We could also implement a request-reply pattern with separate inbound and outbound queues for each service.</span></span> <span data-ttu-id="e43ca-159">Tento vzor je však složité a vyžaduje instalatérství korelovat požadavky a odpovědi zprávy.</span><span class="sxs-lookup"><span data-stu-id="e43ca-159">However, this pattern is complicated and requires plumbing to correlate request and response messages.</span></span>
<span data-ttu-id="e43ca-160">Zatímco to odpojit volání back-endu mikroslužby, volání služby musí stále synchronně čekat na dokončení volání.</span><span class="sxs-lookup"><span data-stu-id="e43ca-160">While it does decouple the backend microservice calls, the calling service must still synchronously wait for the call to complete.</span></span> <span data-ttu-id="e43ca-161">Zahlcení sítě, přechodné chyby nebo přetížené mikroslužby a může mít za následek dlouhotrvající a dokonce i neúspěšné operace.</span><span class="sxs-lookup"><span data-stu-id="e43ca-161">Network congestion, transient faults, or an overloaded microservice and can result in long-running and even failed operations.</span></span>

<span data-ttu-id="e43ca-162">Místo toho široce přijímaný vzor pro odstranění závislostí mezi službami je [materiální vzorek zobrazení](https://docs.microsoft.com/azure/architecture/patterns/materialized-view), znázorněný na obrázku 5-4.</span><span class="sxs-lookup"><span data-stu-id="e43ca-162">Instead, a widely accepted pattern for removing cross-service dependencies is the [Materialized View Pattern](https://docs.microsoft.com/azure/architecture/patterns/materialized-view), shown in Figure 5-4.</span></span>

![Zhmotněný řez](./media/materialized-view-pattern.png)

<span data-ttu-id="e43ca-164">**Obrázek 5-4**.</span><span class="sxs-lookup"><span data-stu-id="e43ca-164">**Figure 5-4**.</span></span> <span data-ttu-id="e43ca-165">Model materializovaného zobrazení</span><span class="sxs-lookup"><span data-stu-id="e43ca-165">Materialized View Pattern</span></span>

<span data-ttu-id="e43ca-166">Pomocí tohoto vzoru umístíte do služby nákupního košíku místní tabulku dat (označovanou jako *model pro čtení).*</span><span class="sxs-lookup"><span data-stu-id="e43ca-166">With this pattern, you place a local data table (known as a *read model*) in the shopping basket service.</span></span> <span data-ttu-id="e43ca-167">Tato tabulka obsahuje nenormalizovanou kopii dat potřebných z mikroslužeb produktu a cen.</span><span class="sxs-lookup"><span data-stu-id="e43ca-167">This table contains a denormalized copy of the data needed from the product and pricing microservices.</span></span> <span data-ttu-id="e43ca-168">Kopírování dat přímo do mikroslužby nákupního košíku eliminuje potřebu nákladných volání mezi službami.</span><span class="sxs-lookup"><span data-stu-id="e43ca-168">Copying the data directly into the shopping basket microservice eliminates the need for expensive cross-service calls.</span></span> <span data-ttu-id="e43ca-169">S místními daty pro službu můžete zlepšit dobu odezvy a spolehlivost služby.</span><span class="sxs-lookup"><span data-stu-id="e43ca-169">With the data local to the service, you improve the service's response time and reliability.</span></span> <span data-ttu-id="e43ca-170">Navíc s vlastní kopii dat je služba nákupního košíku odolnější.</span><span class="sxs-lookup"><span data-stu-id="e43ca-170">Additionally, having its own copy of the data makes the shopping basket service more resilient.</span></span> <span data-ttu-id="e43ca-171">Pokud by služba katalogu přestala být dostupná, neměla by přímý vliv na službu nákupního košíku.</span><span class="sxs-lookup"><span data-stu-id="e43ca-171">If the catalog service should become unavailable, it wouldn't directly impact the shopping basket service.</span></span> <span data-ttu-id="e43ca-172">Nákupní košík může pokračovat v provozu s daty z vlastního obchodu.</span><span class="sxs-lookup"><span data-stu-id="e43ca-172">The shopping basket can continue operating with the data from its own store.</span></span>

<span data-ttu-id="e43ca-173">Úlovek s tímto přístupem je, že nyní máte duplicitní data ve vašem systému.</span><span class="sxs-lookup"><span data-stu-id="e43ca-173">The catch with this approach is that you now have duplicate data in your system.</span></span> <span data-ttu-id="e43ca-174">*Strategicky* duplikace dat v cloudnativních systémech je však zavedenou praxí a není považována za anti-pattern nebo špatnou praxi.</span><span class="sxs-lookup"><span data-stu-id="e43ca-174">However, *strategically* duplicating data in cloud-native systems is an established practice and not considered an anti-pattern, or bad practice.</span></span> <span data-ttu-id="e43ca-175">Mějte na paměti, že *jedna a jediná služba* může vlastnit sadu dat a mít nad ní oprávnění.</span><span class="sxs-lookup"><span data-stu-id="e43ca-175">Keep in mind that *one and only one service* can own a data set and have authority over it.</span></span> <span data-ttu-id="e43ca-176">Při aktualizaci systému záznamu budete muset synchronizovat modely čtení.</span><span class="sxs-lookup"><span data-stu-id="e43ca-176">You'll need to synchronize the read models when the system of record is updated.</span></span> <span data-ttu-id="e43ca-177">Synchronizace je obvykle implementována prostřednictvím asynchronního zasílání zpráv se [vzorem publikování/odběru](service-to-service-communication.md#events), jak je znázorněno na obrázku 5.4.</span><span class="sxs-lookup"><span data-stu-id="e43ca-177">Synchronization is typically implemented via asynchronous messaging with a [publish/subscribe pattern](service-to-service-communication.md#events), as shown in Figure 5.4.</span></span>

## <a name="distributed-transactions"></a><span data-ttu-id="e43ca-178">Distribuované transakce</span><span class="sxs-lookup"><span data-stu-id="e43ca-178">Distributed transactions</span></span>

<span data-ttu-id="e43ca-179">Zatímco dotazování dat napříč mikroslužbami je obtížné, implementace transakce napříč několika mikroslužeb je ještě složitější.</span><span class="sxs-lookup"><span data-stu-id="e43ca-179">While querying data across microservices is difficult, implementing a transaction across several microservices is even more complex.</span></span> <span data-ttu-id="e43ca-180">Inherentní výzvu zachování konzistence dat napříč nezávislými zdroji dat v různých mikroslužeb nelze podceňovat.</span><span class="sxs-lookup"><span data-stu-id="e43ca-180">The inherent challenge of maintaining data consistency across independent data sources in different microservices can't be understated.</span></span> <span data-ttu-id="e43ca-181">Nedostatek distribuovaných transakcí v aplikacích nativních pro cloud znamená, že je nutné spravovat distribuované transakce programově.</span><span class="sxs-lookup"><span data-stu-id="e43ca-181">The lack of distributed transactions in cloud-native applications means that you must manage distributed transactions programmatically.</span></span> <span data-ttu-id="e43ca-182">Přesunete se ze světa *okamžité konzistence* do světa *případné konzistence*.</span><span class="sxs-lookup"><span data-stu-id="e43ca-182">You move from a world of *immediate consistency* to that of *eventual consistency*.</span></span>

<span data-ttu-id="e43ca-183">Obrázek 5-5 ukazuje problém.</span><span class="sxs-lookup"><span data-stu-id="e43ca-183">Figure 5-5 shows the problem.</span></span>

![Transakce ve vzoru ságy](./media/saga-transaction-operation.png)

<span data-ttu-id="e43ca-185">**Obrázek 5-5**.</span><span class="sxs-lookup"><span data-stu-id="e43ca-185">**Figure 5-5**.</span></span> <span data-ttu-id="e43ca-186">Implementace transakce mezi mikroslužbami</span><span class="sxs-lookup"><span data-stu-id="e43ca-186">Implementing a transaction across microservices</span></span>

<span data-ttu-id="e43ca-187">Na předchozím obrázku pět nezávislých mikroslužeb účastnit distribuované transakce, která vytvoří objednávku.</span><span class="sxs-lookup"><span data-stu-id="e43ca-187">In the preceding figure, five independent microservices participate in a distributed transaction that creates an order.</span></span> <span data-ttu-id="e43ca-188">Každá mikroslužba udržuje své vlastní úložiště dat a implementuje místní transakce pro své úložiště.</span><span class="sxs-lookup"><span data-stu-id="e43ca-188">Each microservice maintains its own data store and implements a local transaction for its store.</span></span> <span data-ttu-id="e43ca-189">Chcete-li vytvořit pořadí, musí být úspěšná místní transakce pro *každou* jednotlivou mikroslužbu, nebo *musí všechny* přerušit a vrátit zpět operaci.</span><span class="sxs-lookup"><span data-stu-id="e43ca-189">To create the order, the local transaction for *each* individual microservice must succeed, or *all* must abort and roll back the operation.</span></span> <span data-ttu-id="e43ca-190">Zatímco integrovaná transakční podpora je k dispozici v rámci každé mikroslužeb, neexistuje žádná podpora pro distribuované transakce, která by se rozprostírala napříč všemi pěti službami, aby byla data konzistentní.</span><span class="sxs-lookup"><span data-stu-id="e43ca-190">While built-in transactional support is available inside each of the microservices, there's no support for a distributed transaction that would span across all five services to keep data consistent.</span></span>

<span data-ttu-id="e43ca-191">Místo toho je nutné vytvořit tuto distribuovanou transakci *programově*.</span><span class="sxs-lookup"><span data-stu-id="e43ca-191">Instead, you must construct this distributed transaction *programmatically*.</span></span>

<span data-ttu-id="e43ca-192">Populární vzor pro přidání distribuované transakční podporu je vzor Saga.</span><span class="sxs-lookup"><span data-stu-id="e43ca-192">A popular pattern for adding distributed transactional support is the Saga pattern.</span></span> <span data-ttu-id="e43ca-193">Je implementována seskupením místních transakcí dohromady programově a postupně s oprávněním ke každému z nich.</span><span class="sxs-lookup"><span data-stu-id="e43ca-193">It's implemented by grouping local transactions together programmatically and sequentially invoking each one.</span></span> <span data-ttu-id="e43ca-194">Pokud některá z místních transakcí nezdaří, Saga přeruší operaci a vyvolá sadu [vyrovnávacítransakce](https://docs.microsoft.com/azure/architecture/patterns/compensating-transaction).</span><span class="sxs-lookup"><span data-stu-id="e43ca-194">If any of the local transactions fail, the Saga aborts the operation and invokes a set of [compensating transactions](https://docs.microsoft.com/azure/architecture/patterns/compensating-transaction).</span></span> <span data-ttu-id="e43ca-195">Kompenzační transakce vrátit zpět změny provedené předchozí místní transakce a obnovit konzistenci dat.</span><span class="sxs-lookup"><span data-stu-id="e43ca-195">The compensating transactions undo the changes made by the preceding local transactions and restore data consistency.</span></span> <span data-ttu-id="e43ca-196">Obrázek 5-6 ukazuje neúspěšnou transakci se vzorem Saga.</span><span class="sxs-lookup"><span data-stu-id="e43ca-196">Figure 5-6 shows a failed transaction with the Saga pattern.</span></span>

![Vrátit se zpět do vzoru ságy](./media/saga-rollback-operation.png)

<span data-ttu-id="e43ca-198">**Obrázek 5-6**.</span><span class="sxs-lookup"><span data-stu-id="e43ca-198">**Figure 5-6**.</span></span> <span data-ttu-id="e43ca-199">Vrácení transakce zpět</span><span class="sxs-lookup"><span data-stu-id="e43ca-199">Rolling back a transaction</span></span>

<span data-ttu-id="e43ca-200">Na předchozím obrázku *operace Aktualizovat zásoby* selhala v mikroslužbě Zásoby.</span><span class="sxs-lookup"><span data-stu-id="e43ca-200">In the previous figure, the *Update Inventory* operation has failed in the Inventory microservice.</span></span> <span data-ttu-id="e43ca-201">Saga vyvolá sadu vyrovnávacích transakcí (červeně) upravit počty zásob, zrušit platbu a objednávku a vrátit data pro každou mikroslužbu zpět do konzistentního stavu.</span><span class="sxs-lookup"><span data-stu-id="e43ca-201">The Saga invokes a set of compensating transactions (in red) to adjust the inventory counts, cancel the payment and the order, and return the data for each microservice back to a consistent state.</span></span>

<span data-ttu-id="e43ca-202">Vzorce ságy jsou obvykle choreografovány jako série souvisejících událostí nebo orchestrovány jako sada souvisejících příkazů.</span><span class="sxs-lookup"><span data-stu-id="e43ca-202">Saga patterns are typically choreographed as a series of related events, or orchestrated as a set of related commands.</span></span> <span data-ttu-id="e43ca-203">V kapitole 4 jsme diskutovali o agregátoru služeb vzor, který by byl základem pro řízené ságy provádění.</span><span class="sxs-lookup"><span data-stu-id="e43ca-203">In Chapter 4, we discussed the service aggregator pattern that would be the foundation for an orchestrated saga implementation.</span></span> <span data-ttu-id="e43ca-204">Také jsme diskutovali o událostech spolu s tématy Azure Service Bus a Azure Event Grid, které by byly základem pro choreografickou implementaci ságy.</span><span class="sxs-lookup"><span data-stu-id="e43ca-204">We also discussed eventing along with Azure Service Bus and Azure Event Grid topics that would be a foundation for a choreographed saga implementation.</span></span>

## <a name="high-volume-data"></a><span data-ttu-id="e43ca-205">Velkoobjemová data</span><span class="sxs-lookup"><span data-stu-id="e43ca-205">High volume data</span></span>

<span data-ttu-id="e43ca-206">Velké aplikace nativní pro cloud často podporují požadavky na velkoobjemová data.</span><span class="sxs-lookup"><span data-stu-id="e43ca-206">Large cloud-native applications often support high-volume data requirements.</span></span> <span data-ttu-id="e43ca-207">V těchto scénářích tradiční techniky ukládání dat může způsobit kritické body.</span><span class="sxs-lookup"><span data-stu-id="e43ca-207">In these scenarios, traditional data storage techniques can cause bottlenecks.</span></span> <span data-ttu-id="e43ca-208">U složitých systémů, které se nasazují ve velkém měřítku, může oddělení odpovědnosti příkazů i dotazů (CQRS) i získávání událostí zlepšit výkon aplikací.</span><span class="sxs-lookup"><span data-stu-id="e43ca-208">For complex systems that deploy on a large scale, both Command and Query Responsibility Segregation (CQRS) and Event Sourcing may improve application performance.</span></span>  

### <a name="cqrs"></a><span data-ttu-id="e43ca-209">CQRS</span><span class="sxs-lookup"><span data-stu-id="e43ca-209">CQRS</span></span>

<span data-ttu-id="e43ca-210">[CQRS](https://docs.microsoft.com/azure/architecture/patterns/cqrs), je architektonický vzor, který může pomoci maximalizovat výkon, škálovatelnost a zabezpečení.</span><span class="sxs-lookup"><span data-stu-id="e43ca-210">[CQRS](https://docs.microsoft.com/azure/architecture/patterns/cqrs), is an architectural pattern that can help maximize performance, scalability, and security.</span></span> <span data-ttu-id="e43ca-211">Vzor odděluje operace, které čtou data z těchto operací, které zapisují data.</span><span class="sxs-lookup"><span data-stu-id="e43ca-211">The pattern separates operations that read data from those operations that write data.</span></span>

<span data-ttu-id="e43ca-212">Pro normální scénáře se stejný model entity a objekt úložiště dat používají pro operace čtení *i* zápisu.</span><span class="sxs-lookup"><span data-stu-id="e43ca-212">For normal scenarios, the same entity model and data repository object are used for *both* read and write operations.</span></span>

<span data-ttu-id="e43ca-213">Scénář dat s velkým objemem však může těžit ze samostatných modelů a tabulek dat pro čtení a zápisy.</span><span class="sxs-lookup"><span data-stu-id="e43ca-213">However, a high volume data scenario can benefit from separate models and data tables for reads and writes.</span></span> <span data-ttu-id="e43ca-214">Chcete-li zlepšit výkon operace čtení může dotaz proti vysoce nenormalizované reprezentace dat, aby se zabránilo nákladné opakující se tabulka spojení a tabulka zámky.</span><span class="sxs-lookup"><span data-stu-id="e43ca-214">To improve performance, the read operation could query against a highly denormalized representation of the data to avoid expensive repetitive table joins and table locks.</span></span> <span data-ttu-id="e43ca-215">Operace *zápisu,* označovaná jako *příkaz*, by se aktualizovala proti plně normalizované reprezentaci dat, která by zaručila konzistenci.</span><span class="sxs-lookup"><span data-stu-id="e43ca-215">The *write* operation, known as a *command*, would update against a fully normalized representation of the data that would guarantee consistency.</span></span> <span data-ttu-id="e43ca-216">Potom je třeba implementovat mechanismus zachovat obě reprezentace v synchronizaci. Obvykle při každé změně tabulky zápisu publikuje událost, která replikuje změny tabulky pro čtení.</span><span class="sxs-lookup"><span data-stu-id="e43ca-216">You then need to implement a mechanism to keep both representations in sync. Typically, whenever the write table is modified, it publishes an event that replicates the modification to the read table.</span></span>

<span data-ttu-id="e43ca-217">Obrázek 5-7 ukazuje implementaci cqrs vzor.</span><span class="sxs-lookup"><span data-stu-id="e43ca-217">Figure 5-7 shows an implementation of the CQRS pattern.</span></span>

![Oddělení odpovědnosti příkazů a dotazů](./media/cqrs-implementation.png)

<span data-ttu-id="e43ca-219">**Obrázek 5-7**.</span><span class="sxs-lookup"><span data-stu-id="e43ca-219">**Figure 5-7**.</span></span> <span data-ttu-id="e43ca-220">Implementace CQRS</span><span class="sxs-lookup"><span data-stu-id="e43ca-220">CQRS implementation</span></span>

<span data-ttu-id="e43ca-221">Na předchozím obrázku jsou implementovány samostatné modely příkazů a dotazů.</span><span class="sxs-lookup"><span data-stu-id="e43ca-221">In the previous figure, separate command and query models are implemented.</span></span> <span data-ttu-id="e43ca-222">Každá operace zápisu dat je uložena do úložiště zápisu a poté rozšířena do úložiště pro čtení.</span><span class="sxs-lookup"><span data-stu-id="e43ca-222">Each data write operation is saved to the write store and then propagated to the read store.</span></span> <span data-ttu-id="e43ca-223">Věnujte velkou pozornost tomu, jak proces šíření dat funguje na principu [případné konzistence](http://www.cloudcomputingpatterns.org/eventual_consistency/).</span><span class="sxs-lookup"><span data-stu-id="e43ca-223">Pay close attention to how the data propagation process operates on the principle of [eventual consistency](http://www.cloudcomputingpatterns.org/eventual_consistency/).</span></span> <span data-ttu-id="e43ca-224">Čtení modelu nakonec synchronizuje s modelem zápisu, ale může být určité zpoždění v procesu.</span><span class="sxs-lookup"><span data-stu-id="e43ca-224">The read model eventually synchronizes with the write model, but there may be some lag in the process.</span></span> <span data-ttu-id="e43ca-225">V další části diskutujeme o případné konzistenci.</span><span class="sxs-lookup"><span data-stu-id="e43ca-225">We discuss eventual consistency in the next section.</span></span>

<span data-ttu-id="e43ca-226">Toto oddělení umožňuje čtení a zápisy škálovat nezávisle.</span><span class="sxs-lookup"><span data-stu-id="e43ca-226">This separation enables reads and writes to scale independently.</span></span> <span data-ttu-id="e43ca-227">Operace čtení používají schéma optimalizované pro dotazy, zatímco zápisy používají schéma optimalizované pro aktualizace.</span><span class="sxs-lookup"><span data-stu-id="e43ca-227">Read operations use a schema optimized for queries, while the writes use a schema optimized for updates.</span></span> <span data-ttu-id="e43ca-228">Dotazy pro čtení jdou proti nenormalizovaným datům, zatímco komplexní obchodní logiku lze použít pro model zápisu.</span><span class="sxs-lookup"><span data-stu-id="e43ca-228">Read queries go against denormalized data, while complex business logic can be applied to the write model.</span></span> <span data-ttu-id="e43ca-229">Stejně tak můžete uložit přísnější zabezpečení pro operace zápisu, než ty, které odhalují čtení.</span><span class="sxs-lookup"><span data-stu-id="e43ca-229">As well, you might impose tighter security on write operations than those exposing reads.</span></span>

<span data-ttu-id="e43ca-230">Implementace CQRS může zlepšit výkon aplikací pro cloudové nativní služby.</span><span class="sxs-lookup"><span data-stu-id="e43ca-230">Implementing CQRS can improve application performance for cloud-native services.</span></span> <span data-ttu-id="e43ca-231">Výsledkem však je složitější návrh.</span><span class="sxs-lookup"><span data-stu-id="e43ca-231">However, it does result in a more complex design.</span></span> <span data-ttu-id="e43ca-232">Tento princip používejte pečlivě a strategicky na ty části aplikace nativní pro cloud, které z něj budou mít prospěch.</span><span class="sxs-lookup"><span data-stu-id="e43ca-232">Apply this principle carefully and strategically to those sections of your cloud-native application that will benefit from it.</span></span> <span data-ttu-id="e43ca-233">Další informace o CQRS naleznete v knize Microsoft [Book .NET Microservices: Architecture for Containerized .NET Applications](https://docs.microsoft.com/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/apply-simplified-microservice-cqrs-ddd-patterns).</span><span class="sxs-lookup"><span data-stu-id="e43ca-233">For more on CQRS, see the Microsoft book [.NET Microservices: Architecture for Containerized .NET Applications](https://docs.microsoft.com/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/apply-simplified-microservice-cqrs-ddd-patterns).</span></span>

### <a name="event-sourcing"></a><span data-ttu-id="e43ca-234">Získávání událostí</span><span class="sxs-lookup"><span data-stu-id="e43ca-234">Event sourcing</span></span>

<span data-ttu-id="e43ca-235">Další přístup k optimalizaci scénářů velkoobjemových dat zahrnuje [získávání událostí](https://docs.microsoft.com/azure/architecture/patterns/event-sourcing).</span><span class="sxs-lookup"><span data-stu-id="e43ca-235">Another approach to optimizing high volume data scenarios involves [Event Sourcing](https://docs.microsoft.com/azure/architecture/patterns/event-sourcing).</span></span>

<span data-ttu-id="e43ca-236">Systém obvykle ukládá aktuální stav datové entity.</span><span class="sxs-lookup"><span data-stu-id="e43ca-236">A system typically stores the current state of a data entity.</span></span> <span data-ttu-id="e43ca-237">Pokud například uživatel změní své telefonní číslo, záznam zákazníka se aktualizuje o nové číslo.</span><span class="sxs-lookup"><span data-stu-id="e43ca-237">If a user changes their phone number, for example, the customer record is updated with the new number.</span></span> <span data-ttu-id="e43ca-238">Vždy známe aktuální stav datové entity, ale každá aktualizace přepíše předchozí stav.</span><span class="sxs-lookup"><span data-stu-id="e43ca-238">We always know the current state of a data entity, but each update overwrites the previous state.</span></span>

<span data-ttu-id="e43ca-239">Ve většině případů tento model funguje dobře.</span><span class="sxs-lookup"><span data-stu-id="e43ca-239">In most cases, this model works fine.</span></span> <span data-ttu-id="e43ca-240">V systémech s vysokou objemem však režie z transakčního uzamčení a častých operací aktualizace může ovlivnit výkon databáze, odezvu a omezit škálovatelnost.</span><span class="sxs-lookup"><span data-stu-id="e43ca-240">In high volume systems, however, overhead from transactional locking and frequent update operations can impact database performance, responsiveness, and limit scalability.</span></span>

<span data-ttu-id="e43ca-241">Event Sourcing má jiný přístup k zachycení dat.</span><span class="sxs-lookup"><span data-stu-id="e43ca-241">Event Sourcing takes a different approach to capturing data.</span></span> <span data-ttu-id="e43ca-242">Každá operace, která ovlivňuje data, je v úložišti událostí zachována.</span><span class="sxs-lookup"><span data-stu-id="e43ca-242">Each operation that affects data is persisted to an event store.</span></span> <span data-ttu-id="e43ca-243">Namísto aktualizace stavu datového záznamu připojíme každou změnu do sekvenčního seznamu minulých událostí - podobně jako účetní knihy.</span><span class="sxs-lookup"><span data-stu-id="e43ca-243">Instead of updating the state of a data record, we append each change to a sequential list of past events - similar to an accountant's ledger.</span></span> <span data-ttu-id="e43ca-244">Úložiště událostí se stane systémem záznamu pro data.</span><span class="sxs-lookup"><span data-stu-id="e43ca-244">The Event Store becomes the system of record for the data.</span></span> <span data-ttu-id="e43ca-245">Používá se k šíření různých zhmotněných zobrazení v rámci ohraničené kontextu mikroslužeb.</span><span class="sxs-lookup"><span data-stu-id="e43ca-245">It's used to propagate various materialized views within the bounded context of a microservice.</span></span> <span data-ttu-id="e43ca-246">Obrázek 5.8 ukazuje vzorek.</span><span class="sxs-lookup"><span data-stu-id="e43ca-246">Figure 5.8 shows the pattern.</span></span>

![Event Sourcing](./media/event-sourcing.png)

<span data-ttu-id="e43ca-248">**Obrázek 5-8**.</span><span class="sxs-lookup"><span data-stu-id="e43ca-248">**Figure 5-8**.</span></span> <span data-ttu-id="e43ca-249">Event Sourcing</span><span class="sxs-lookup"><span data-stu-id="e43ca-249">Event Sourcing</span></span>

<span data-ttu-id="e43ca-250">Na předchozím obrázku si všimněte, jak je každá položka (modře) pro nákupní košík uživatele připojena k podkladovému úložišti událostí.</span><span class="sxs-lookup"><span data-stu-id="e43ca-250">In the previous figure, note how each entry (in blue) for a user's shopping cart is appended to an underlying event store.</span></span> <span data-ttu-id="e43ca-251">V přilehlém zhmotněným zobrazení systém promítá aktuální stav přehráním všech událostí přidružených ke každému nákupnímu košíku.</span><span class="sxs-lookup"><span data-stu-id="e43ca-251">In the adjoining materialized view, the system projects the current state by replaying all the events associated with each shopping cart.</span></span> <span data-ttu-id="e43ca-252">Tento pohled nebo čtení modelu je pak vystavena zpět do ui.</span><span class="sxs-lookup"><span data-stu-id="e43ca-252">This view, or read model, is then exposed back to the UI.</span></span> <span data-ttu-id="e43ca-253">Události lze také integrovat s externími systémy a aplikacemi nebo dotazovány k určení aktuálního stavu entity.</span><span class="sxs-lookup"><span data-stu-id="e43ca-253">Events can also be integrated with external systems and applications or queried to determine the current state of an entity.</span></span> <span data-ttu-id="e43ca-254">S tímto přístupem, budete udržovat historii.</span><span class="sxs-lookup"><span data-stu-id="e43ca-254">With this approach, you maintain history.</span></span> <span data-ttu-id="e43ca-255">Znáte nejen aktuální stav entity, ale také to, jak jste k tomuto stavu dosáhli.</span><span class="sxs-lookup"><span data-stu-id="e43ca-255">You know not only the current state of an entity, but also how you reached this state.</span></span>

<span data-ttu-id="e43ca-256">Mechanicky řečeno, získávání událostí zjednodušuje model zápisu.</span><span class="sxs-lookup"><span data-stu-id="e43ca-256">Mechanically speaking, event sourcing simplifies the write model.</span></span> <span data-ttu-id="e43ca-257">Neexistují žádné aktualizace nebo odstranění.</span><span class="sxs-lookup"><span data-stu-id="e43ca-257">There are no updates or deletes.</span></span> <span data-ttu-id="e43ca-258">Připojení každé položky dat jako neměnné události minimalizuje konflikty konfliktů kolizí, uzamčení a souběžnosti přidružené k relačním databázím.</span><span class="sxs-lookup"><span data-stu-id="e43ca-258">Appending each data entry as an immutable event minimizes contention, locking, and concurrency conflicts associated with relational databases.</span></span> <span data-ttu-id="e43ca-259">Vytváření modelů čtení s materiálním vzorem zobrazení umožňuje oddělit zobrazení od modelu zápisu a zvolit nejlepší úložiště dat pro optimalizaci potřeb vašeho aplikačního uj.</span><span class="sxs-lookup"><span data-stu-id="e43ca-259">Building read models with the materialized view pattern enables you to decouple the view from the write model and choose the best data store to optimize the needs of your application UI.</span></span>

<span data-ttu-id="e43ca-260">Pro tento vzor zvažte úložiště dat, které přímo podporuje získávání událostí.</span><span class="sxs-lookup"><span data-stu-id="e43ca-260">For this pattern, consider a data store that directly supports event sourcing.</span></span> <span data-ttu-id="e43ca-261">Azure Cosmos DB, MongoDB, Cassandra, CouchDB a RavenDB jsou dobří kandidáti.</span><span class="sxs-lookup"><span data-stu-id="e43ca-261">Azure Cosmos DB, MongoDB, Cassandra, CouchDB, and RavenDB are good candidates.</span></span>

<span data-ttu-id="e43ca-262">Stejně jako u všech vzorů a technologií, realizovat strategicky a v případě potřeby.</span><span class="sxs-lookup"><span data-stu-id="e43ca-262">As with all patterns and technologies, implement strategically and when needed.</span></span> <span data-ttu-id="e43ca-263">Zatímco získávání událostí může poskytovat vyšší výkon a škálovatelnost, přichází na úkor složitosti a křivky učení.</span><span class="sxs-lookup"><span data-stu-id="e43ca-263">While event sourcing can provide increased performance and scalability, it comes at the expense of complexity and a learning curve.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="e43ca-264">[Předchozí](service-mesh-communication-infrastructure.md)
>[další](relational-vs-nosql-data.md)</span><span class="sxs-lookup"><span data-stu-id="e43ca-264">[Previous](service-mesh-communication-infrastructure.md)
[Next](relational-vs-nosql-data.md)</span></span>
