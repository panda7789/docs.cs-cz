---
title: Databáze na mikroslužby
description: Kontrastování datových úložišť v monolitické a cloudových nativních aplikacích.
author: robvet
ms.date: 01/22/2020
ms.openlocfilehash: e472309d3dc815070fc2d2c220bf4fe00b8c29ae
ms.sourcegitcommit: 13e79efdbd589cad6b1de634f5d6b1262b12ab01
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 01/28/2020
ms.locfileid: "76794903"
---
# <a name="database-per-microservice"></a><span data-ttu-id="821c8-103">Databáze na mikroslužby</span><span class="sxs-lookup"><span data-stu-id="821c8-103">Database-per-microservice</span></span>

[!INCLUDE [book-preview](../../../includes/book-preview.md)]

<span data-ttu-id="821c8-104">Jak jsme viděli v této příručce, cloudový nativní přístup mění způsob, jakým navrhujete, nasazujete a spravujete aplikace.</span><span class="sxs-lookup"><span data-stu-id="821c8-104">As we've seen throughout this book, a cloud-native approach changes the way you design, deploy, and manage applications.</span></span> <span data-ttu-id="821c8-105">Také mění způsob, jakým spravujete a ukládáte data.</span><span class="sxs-lookup"><span data-stu-id="821c8-105">It also changes the way you manage and store data.</span></span>

<span data-ttu-id="821c8-106">Obrázek 5-1 kontrastuje rozdíly.</span><span class="sxs-lookup"><span data-stu-id="821c8-106">Figure 5-1 contrasts the differences.</span></span>

![Úložiště dat v nativních aplikacích cloudu](./media/distributed-data.png)

<span data-ttu-id="821c8-108">**Obrázek 5-1**.</span><span class="sxs-lookup"><span data-stu-id="821c8-108">**Figure 5-1**.</span></span> <span data-ttu-id="821c8-109">Správa dat v cloudových nativních aplikacích</span><span class="sxs-lookup"><span data-stu-id="821c8-109">Data management in cloud-native applications</span></span>

<span data-ttu-id="821c8-110">Zkušení vývojáři budou snadno rozpoznávat architekturu na levé straně obrázku 5-1.</span><span class="sxs-lookup"><span data-stu-id="821c8-110">Experienced developers will easily recognize the architecture on the left-side of figure 5-1.</span></span> <span data-ttu-id="821c8-111">V této *aplikaci monolitické*se komponenty Business Service společné umístění společně na úrovni sdílených služeb a sdílejí data z jedné relační databáze.</span><span class="sxs-lookup"><span data-stu-id="821c8-111">In this *monolithic application*, business service components collocate together in a shared services tier, sharing data from a single relational database.</span></span>

<span data-ttu-id="821c8-112">V mnoha různých způsobech udržuje jedna databáze jednoduché správy dat.</span><span class="sxs-lookup"><span data-stu-id="821c8-112">In many ways, a single database keeps data management simple.</span></span> <span data-ttu-id="821c8-113">Dotazování dat napříč více tabulkami je jednoduché.</span><span class="sxs-lookup"><span data-stu-id="821c8-113">Querying data across multiple tables is straightforward.</span></span> <span data-ttu-id="821c8-114">Změny dat se aktualizují nebo se vrátí zpět.</span><span class="sxs-lookup"><span data-stu-id="821c8-114">Changes to data update together or they all rollback.</span></span> <span data-ttu-id="821c8-115">[Kyselé transakce](https://docs.microsoft.com/windows/desktop/cossdk/acid-properties) zaručují silnou a okamžitou konzistenci.</span><span class="sxs-lookup"><span data-stu-id="821c8-115">[ACID transactions](https://docs.microsoft.com/windows/desktop/cossdk/acid-properties) guarantee strong and immediate consistency.</span></span>

<span data-ttu-id="821c8-116">Návrh pro cloudový nativní režim nabízí jiný přístup.</span><span class="sxs-lookup"><span data-stu-id="821c8-116">Designing for cloud-native, we take a different approach.</span></span> <span data-ttu-id="821c8-117">Na pravé straně obrázku 5-1 si všimněte, jak se firemní funkce odvíjí do malých nezávislých mikroslužeb.</span><span class="sxs-lookup"><span data-stu-id="821c8-117">On the right-side of Figure 5-1, note how business functionality segregates into small, independent microservices.</span></span> <span data-ttu-id="821c8-118">Každá mikroslužba zapouzdřuje konkrétní obchodní schopnost a její vlastní data.</span><span class="sxs-lookup"><span data-stu-id="821c8-118">Each microservice encapsulates a specific business capability and its own data.</span></span> <span data-ttu-id="821c8-119">Databáze monolitické je rozdělená do distribuovaného datového modelu s mnoha menšími databázemi, a to z každého v souladu s mikroslužbou.</span><span class="sxs-lookup"><span data-stu-id="821c8-119">The monolithic database decomposes into a distributed data model with many smaller databases, each aligning with a microservice.</span></span> <span data-ttu-id="821c8-120">Když se kouř nevymaže, ukážeme vám návrh, který zveřejňuje *databázi na mikroslužbu*.</span><span class="sxs-lookup"><span data-stu-id="821c8-120">When the smoke clears, we emerge with a design that exposes a *database per microservice*.</span></span>

## <a name="why"></a><span data-ttu-id="821c8-121">Proč?</span><span class="sxs-lookup"><span data-stu-id="821c8-121">Why?</span></span>

<span data-ttu-id="821c8-122">Tato databáze na mikroslužbu poskytuje mnoho výhod, zejména pro systémy, které se musí rychle vyvíjet a podporují rozsáhlé škálování.</span><span class="sxs-lookup"><span data-stu-id="821c8-122">This database per microservice provides many benefits, especially for systems that must evolve rapidly and support massive scale.</span></span> <span data-ttu-id="821c8-123">S tímto modelem...</span><span class="sxs-lookup"><span data-stu-id="821c8-123">With this model...</span></span>

- <span data-ttu-id="821c8-124">Data domény jsou zapouzdřena v rámci služby.</span><span class="sxs-lookup"><span data-stu-id="821c8-124">Domain data is encapsulated within the service</span></span>
- <span data-ttu-id="821c8-125">Schéma dat se může vyvíjet bez přímého dopadu na jiné služby.</span><span class="sxs-lookup"><span data-stu-id="821c8-125">Data schema can evolve without directly impacting other services</span></span>
- <span data-ttu-id="821c8-126">Každé úložiště dat může nezávisle škálovat</span><span class="sxs-lookup"><span data-stu-id="821c8-126">Each data store can independently scale</span></span>
- <span data-ttu-id="821c8-127">Selhání úložiště dat v jedné službě nebude mít přímý vliv na jiné služby.</span><span class="sxs-lookup"><span data-stu-id="821c8-127">A data store failure in one service won't directly impact other services</span></span>

<span data-ttu-id="821c8-128">Oddělení dat také umožňuje, aby každá mikroslužba implementovala typ úložiště dat, který je nejlépe optimalizovaný pro své úlohy, potřeby úložiště a vzory čtení a zápisu.</span><span class="sxs-lookup"><span data-stu-id="821c8-128">Segregating data also enables each microservice to implement the data store type that is best optimized for its workload, storage needs, and read/write patterns.</span></span> <span data-ttu-id="821c8-129">Mezi možnosti patří relační úložiště dat, dokument, klíč-hodnota a dokonce i datové obchody založené na grafu.</span><span class="sxs-lookup"><span data-stu-id="821c8-129">Choices include relational, document, key-value, and even graph-based data stores.</span></span>

<span data-ttu-id="821c8-130">Obrázek 5-2 prezentuje princip Polyglot Persistence v systému nativním pro Cloud.</span><span class="sxs-lookup"><span data-stu-id="821c8-130">Figure 5-2 presents the principle of polyglot persistence in a cloud-native system.</span></span>

![Trvalost dat Polyglot](./media/polyglot-data-persistence.png)

<span data-ttu-id="821c8-132">**Obrázek 5-2**.</span><span class="sxs-lookup"><span data-stu-id="821c8-132">**Figure 5-2**.</span></span> <span data-ttu-id="821c8-133">Trvalost dat Polyglot</span><span class="sxs-lookup"><span data-stu-id="821c8-133">Polyglot data persistence</span></span>

<span data-ttu-id="821c8-134">Všimněte si na předchozím obrázku, jak každá mikroslužba podporuje jiný typ úložiště dat.</span><span class="sxs-lookup"><span data-stu-id="821c8-134">Note in the previous figure how each microservice supports a different type of data store.</span></span>

- <span data-ttu-id="821c8-135">Mikroslužba katalogu produktů využívá relační databázi pro přizpůsobení komplexní relační struktury svých podkladových dat.</span><span class="sxs-lookup"><span data-stu-id="821c8-135">The product catalog microservice consumes a relational database to accommodate the rich relational structure of its underlying data.</span></span>
- <span data-ttu-id="821c8-136">Mikroslužba nákupního košíku spotřebovává distribuovanou mezipaměť, která podporuje své jednoduché úložiště dat klíč-hodnota.</span><span class="sxs-lookup"><span data-stu-id="821c8-136">The shopping cart microservice consumes a distributed cache that supports its simple, key-value data store.</span></span>
- <span data-ttu-id="821c8-137">Pro objednávání mikroslužeb se využívá databáze NoSql dokumentů pro operace zápisu společně s vysoce denormalizovaným úložištěm klíč/hodnota, aby se vešly velké objemy operací čtení.</span><span class="sxs-lookup"><span data-stu-id="821c8-137">The ordering microservice consumes both a NoSql document database for write operations along with a highly denormalized key/value store to accommodate high-volumes of read operations.</span></span>
  
<span data-ttu-id="821c8-138">I když budou relační databáze relevantní pro mikroslužby se složitými daty, databáze NoSQL získaly značnou oblíbenou.</span><span class="sxs-lookup"><span data-stu-id="821c8-138">While relational databases remain relevant for microservices with complex data, NoSQL databases have gained considerable popularity.</span></span> <span data-ttu-id="821c8-139">Poskytují ohromnou škálu a vysokou dostupnost.</span><span class="sxs-lookup"><span data-stu-id="821c8-139">They provide massive scale and high availability.</span></span> <span data-ttu-id="821c8-140">Bez jejich schématu umožňuje vývojářům přesunout se od architektury typových datových tříd a ORMs, které vedou ke změně nákladného a časově náročného.</span><span class="sxs-lookup"><span data-stu-id="821c8-140">Their schemaless nature allows developers to move away from an architecture of typed data classes and ORMs that make change expensive and time-consuming.</span></span> <span data-ttu-id="821c8-141">V této kapitole se zabýváme databázemi NoSQL dále.</span><span class="sxs-lookup"><span data-stu-id="821c8-141">We cover NoSQL databases later in this chapter.</span></span>

 <span data-ttu-id="821c8-142">I když zapouzdření dat do samostatných mikroslužeb může zvýšit flexibilitu, výkon a škálovatelnost, prezentuje i mnoho výzev.</span><span class="sxs-lookup"><span data-stu-id="821c8-142">While encapsulating  data into separate microservices can increase agility, performance, and scalability, it also presents many challenges.</span></span> <span data-ttu-id="821c8-143">V další části se podíváme na tyto výzvy spolu se vzory a postupy, které vám pomůžou je překonat.</span><span class="sxs-lookup"><span data-stu-id="821c8-143">In the next section, we discuss these challenges along with patterns and practices to help overcome them.</span></span>  

## <a name="cross-service-queries"></a><span data-ttu-id="821c8-144">Dotazy na více služeb</span><span class="sxs-lookup"><span data-stu-id="821c8-144">Cross-service queries</span></span>

<span data-ttu-id="821c8-145">I když jsou mikroslužby nezávislé a zaměřují se na konkrétní funkční možnosti, jako je inventarizace, přeprava nebo objednávání, často vyžadují integraci s dalšími mikroslužbami.</span><span class="sxs-lookup"><span data-stu-id="821c8-145">While microservices are independent and focus on specific functional capabilities, like inventory, shipping, or ordering, they frequently require integration with other microservices.</span></span> <span data-ttu-id="821c8-146">Integrace často zahrnuje jednu mikroslužbu, která pro data obsahuje *dotazování* druhé.</span><span class="sxs-lookup"><span data-stu-id="821c8-146">Often the integration involves one microservice *querying* another for data.</span></span> <span data-ttu-id="821c8-147">Obrázek 5-3 ukazuje scénář.</span><span class="sxs-lookup"><span data-stu-id="821c8-147">Figure 5-3 shows the scenario.</span></span>

![Dotazování napříč mikroslužbami](./media/cross-service-query.png)

<span data-ttu-id="821c8-149">**Obrázek 5-3**.</span><span class="sxs-lookup"><span data-stu-id="821c8-149">**Figure 5-3**.</span></span> <span data-ttu-id="821c8-150">Dotazování napříč mikroslužbami</span><span class="sxs-lookup"><span data-stu-id="821c8-150">Querying across microservices</span></span>

<span data-ttu-id="821c8-151">Na předchozím obrázku se uvidí mikroslužba nákupního košíku, která přidá položku do nákupního košíku uživatele.</span><span class="sxs-lookup"><span data-stu-id="821c8-151">In the preceding figure, we see a shopping basket microservice that adds an item to a user's shopping basket.</span></span> <span data-ttu-id="821c8-152">I když úložiště dat pro tuto mikroslužbu obsahuje data koše a položky řádku, neudržuje data o produktech ani cenách.</span><span class="sxs-lookup"><span data-stu-id="821c8-152">While the data store for this microservice contains basket and line item data, it doesn't maintain product or pricing data.</span></span> <span data-ttu-id="821c8-153">Místo toho tyto datové položky vlastní katalog a cenové služby.</span><span class="sxs-lookup"><span data-stu-id="821c8-153">Instead, those data items are owned by the catalog and pricing microservices.</span></span> <span data-ttu-id="821c8-154">To představuje problém.</span><span class="sxs-lookup"><span data-stu-id="821c8-154">This presents a problem.</span></span> <span data-ttu-id="821c8-155">Jak může mikroslužba nákupního košíku přidat produkt do nákupního košíku uživatele, pokud nemá v databázi ani data o produktech ani ceny?</span><span class="sxs-lookup"><span data-stu-id="821c8-155">How can the shopping basket microservice add a product to the user's shopping basket when it doesn't have product nor pricing data in its database?</span></span>

<span data-ttu-id="821c8-156">Jedna z možností popsaná v části kapitola 4 je [přímé volání http](service-to-service-communication.md#queries) od nákupního košíku ke službě Catalog and Price.</span><span class="sxs-lookup"><span data-stu-id="821c8-156">One option discussed in Chapter 4 is a [direct HTTP call](service-to-service-communication.md#queries) from the shopping basket to the catalog and pricing microservices.</span></span> <span data-ttu-id="821c8-157">V kapitole 4 se však říká *synchronní volání http* , které spojuje mikroslužby, což snižuje autonomii a zmenšuje jejich výhody architektury.</span><span class="sxs-lookup"><span data-stu-id="821c8-157">However, in chapter 4, we said synchronous HTTP calls *couple* microservices together, reducing their autonomy and diminishing their architectural benefits.</span></span>

<span data-ttu-id="821c8-158">Pro každou službu můžeme také implementovat vzor požadavek-odpověď s oddělenými příchozími a odchozími frontami.</span><span class="sxs-lookup"><span data-stu-id="821c8-158">We could also implement a request-reply pattern with separate inbound and outbound queues for each service.</span></span> <span data-ttu-id="821c8-159">Tento model je však složitý a vyžaduje k tomu, aby bylo možné korelovat zprávy žádosti a odpovědi.</span><span class="sxs-lookup"><span data-stu-id="821c8-159">However, this pattern is complicated and requires plumbing to correlate request and response messages.</span></span>
<span data-ttu-id="821c8-160">I když oddělí volání mikroslužby back-end, volající služba musí stále synchronně čekat na dokončení volání.</span><span class="sxs-lookup"><span data-stu-id="821c8-160">While it does decouple the backend microservice calls, the calling service must still synchronously wait for the call to complete.</span></span> <span data-ttu-id="821c8-161">Zahlcení sítě, přechodné chyby nebo přetížená mikroslužba a výsledkem může být dlouhotrvající a dokonce neúspěšné operace.</span><span class="sxs-lookup"><span data-stu-id="821c8-161">Network congestion, transient faults, or an overloaded microservice and can result in long-running and even failed operations.</span></span>

<span data-ttu-id="821c8-162">Místo toho je široce přijatý vzor pro odebrání závislostí mezi službami, což je [vzor materializované zobrazení](https://docs.microsoft.com/azure/architecture/patterns/materialized-view)znázorněný na obrázku 5-4.</span><span class="sxs-lookup"><span data-stu-id="821c8-162">Instead, a widely accepted pattern for removing cross-service dependencies is the [Materialized View Pattern](https://docs.microsoft.com/azure/architecture/patterns/materialized-view), shown in Figure 5-4.</span></span>

![Model materializované zobrazení](./media/materialized-view-pattern.png)

<span data-ttu-id="821c8-164">**Obrázek 5-4**.</span><span class="sxs-lookup"><span data-stu-id="821c8-164">**Figure 5-4**.</span></span> <span data-ttu-id="821c8-165">Model materializované zobrazení</span><span class="sxs-lookup"><span data-stu-id="821c8-165">Materialized View Pattern</span></span>

<span data-ttu-id="821c8-166">V tomto vzoru umístíte do služby nákupního košíku místní datovou tabulku (označovanou jako *model pro čtení*).</span><span class="sxs-lookup"><span data-stu-id="821c8-166">With this pattern, you place a local data table (known as a *read model*) in the shopping basket service.</span></span> <span data-ttu-id="821c8-167">Tato tabulka obsahuje denormalizovanou kopii dat potřebných z produktových a cenových mikroslužeb.</span><span class="sxs-lookup"><span data-stu-id="821c8-167">This table contains a denormalized copy of the data needed from the product and pricing microservices.</span></span> <span data-ttu-id="821c8-168">Kopírování dat přímo do nákupního košíku mikroslužba eliminuje nutnost nákladných hovorů mezi službami.</span><span class="sxs-lookup"><span data-stu-id="821c8-168">Copying the data directly into the shopping basket microservice eliminates the need for expensive cross-service calls.</span></span> <span data-ttu-id="821c8-169">S daty, která jsou místní pro službu, můžete zlepšit dobu a spolehlivost odezvy služby.</span><span class="sxs-lookup"><span data-stu-id="821c8-169">With the data local to the service, you improve the service's response time and reliability.</span></span> <span data-ttu-id="821c8-170">Navíc s vlastní kopií dat je služba nákupního košíku pružnější.</span><span class="sxs-lookup"><span data-stu-id="821c8-170">Additionally, having its own copy of the data makes the shopping basket service more resilient.</span></span> <span data-ttu-id="821c8-171">Pokud by služba katalogu neměla být k dispozici, měla by přímo ovlivnit službu nákupního košíku.</span><span class="sxs-lookup"><span data-stu-id="821c8-171">If the catalog service should become unavailable, it wouldn't directly impact the shopping basket service.</span></span> <span data-ttu-id="821c8-172">Nákupní košík může pokračovat v práci s daty z vlastního úložiště.</span><span class="sxs-lookup"><span data-stu-id="821c8-172">The shopping basket can continue operating with the data from its own store.</span></span> 

<span data-ttu-id="821c8-173">Tento přístup znamená, že v systému teď máte duplicitní data.</span><span class="sxs-lookup"><span data-stu-id="821c8-173">The catch with this approach is that you now have duplicate data in your system.</span></span> <span data-ttu-id="821c8-174">*Strategická* duplikace dat v systémech nativních pro Cloud je ale stanovený postup a nepovažuje se za antipattern nebo špatný postup.</span><span class="sxs-lookup"><span data-stu-id="821c8-174">However, *strategically* duplicating data in cloud-native systems is an established practice and not considered an anti-pattern, or bad practice.</span></span> <span data-ttu-id="821c8-175">Mějte na paměti, že *jedna a jenom jedna služba* může vlastnit sadu dat a mít nad ní oprávnění.</span><span class="sxs-lookup"><span data-stu-id="821c8-175">Keep in mind that *one and only one service* can own a data set and have authority over it.</span></span> <span data-ttu-id="821c8-176">Pokud aktualizujete systém záznamu, bude nutné synchronizovat modely čtení.</span><span class="sxs-lookup"><span data-stu-id="821c8-176">You'll need to synchronize the read models when the system of record is updated.</span></span> <span data-ttu-id="821c8-177">Synchronizace je obvykle implementována prostřednictvím asynchronního zasílání zpráv pomocí [vzoru pro publikování a odběr](service-to-service-communication.md#events), jak je znázorněno na obrázku 5,4.</span><span class="sxs-lookup"><span data-stu-id="821c8-177">Synchronization is typically implemented via asynchronous messaging with a [publish/subscribe pattern](service-to-service-communication.md#events), as shown in Figure 5.4.</span></span>

## <a name="distributed-transactions"></a><span data-ttu-id="821c8-178">Distribuované transakce</span><span class="sxs-lookup"><span data-stu-id="821c8-178">Distributed transactions</span></span>

<span data-ttu-id="821c8-179">Dotazování na data napříč mikroslužbami je obtížné a implementace transakce napříč několika mikroslužbami je ještě složitější.</span><span class="sxs-lookup"><span data-stu-id="821c8-179">While querying data across microservices is difficult, implementing a transaction across several microservices is even more complex.</span></span> <span data-ttu-id="821c8-180">Podstata zachování konzistence dat napříč nezávislými zdroji dat v různých mikroslužbách nemůže být podstavová.</span><span class="sxs-lookup"><span data-stu-id="821c8-180">The inherent challenge of maintaining data consistency across independent data sources in different microservices can't be understated.</span></span> <span data-ttu-id="821c8-181">Chybějící distribuované transakce v cloudových nativních aplikacích znamená, že je nutné spravovat distribuované transakce programově.</span><span class="sxs-lookup"><span data-stu-id="821c8-181">The lack of distributed transactions in cloud-native applications means that you must manage distributed transactions programmatically.</span></span> <span data-ttu-id="821c8-182">Přesunete se od světa *bezprostřední konzistence* s konečnou *konzistencí*.</span><span class="sxs-lookup"><span data-stu-id="821c8-182">You move from a world of *immediate consistency* to that of *eventual consistency*.</span></span>

<span data-ttu-id="821c8-183">Obrázek 5-5 ukazuje problém.</span><span class="sxs-lookup"><span data-stu-id="821c8-183">Figure 5-5 shows the problem.</span></span>

![Transakce ve vzoru Saga](./media/saga-transaction-operation.png)

<span data-ttu-id="821c8-185">**Obrázek 5-5**.</span><span class="sxs-lookup"><span data-stu-id="821c8-185">**Figure 5-5**.</span></span> <span data-ttu-id="821c8-186">Implementace transakce napříč mikroslužbami</span><span class="sxs-lookup"><span data-stu-id="821c8-186">Implementing a transaction across microservices</span></span>

<span data-ttu-id="821c8-187">Na předchozím obrázku se pět nezávislých mikroslužeb účastní v distribuované transakci, která vytváří objednávku.</span><span class="sxs-lookup"><span data-stu-id="821c8-187">In the preceding figure, five independent microservices participate in a distributed transaction that creates an order.</span></span> <span data-ttu-id="821c8-188">Každá mikroslužba udržuje své vlastní úložiště dat a implementuje místní transakci pro své úložiště.</span><span class="sxs-lookup"><span data-stu-id="821c8-188">Each microservice maintains its own data store and implements a local transaction for its store.</span></span> <span data-ttu-id="821c8-189">Chcete-li vytvořit objednávku, místní transakce pro *každou* jednotlivou mikroslužbu musí být úspěšná, nebo *všechny* musí přerušit a vrátit zpět operaci.</span><span class="sxs-lookup"><span data-stu-id="821c8-189">To create the order, the local transaction for *each* individual microservice must succeed, or *all* must abort and roll back the operation.</span></span> <span data-ttu-id="821c8-190">I když je integrovaná transakční podpora k dispozici v rámci každé mikroslužby, neexistuje žádná podpora distribuované transakce, která by byla rozložená do všech pěti služeb za účelem zachování konzistence dat.</span><span class="sxs-lookup"><span data-stu-id="821c8-190">While built-in transactional support is available inside each of the microservices, there's no support for a distributed transaction that would span across all five services to keep data consistent.</span></span>

<span data-ttu-id="821c8-191">Místo toho je nutné tuto distribuovanou transakci sestavit *programově*.</span><span class="sxs-lookup"><span data-stu-id="821c8-191">Instead, you must construct this distributed transaction *programmatically*.</span></span>

<span data-ttu-id="821c8-192">Oblíbeným vzorem pro přidání podpory distribuovaných transakcí je SAGA vzor.</span><span class="sxs-lookup"><span data-stu-id="821c8-192">A popular pattern for adding distributed transactional support is the Saga pattern.</span></span> <span data-ttu-id="821c8-193">Je implementováno seskupením místních transakcí společně a následným vyvoláním každého z nich.</span><span class="sxs-lookup"><span data-stu-id="821c8-193">It's implemented by grouping local transactions together programmatically and sequentially invoking each one.</span></span> <span data-ttu-id="821c8-194">Pokud některá z místních transakcí selže, Saga přeruší operaci a vyvolá sadu [kompenzačních transakcí](https://docs.microsoft.com/azure/architecture/patterns/compensating-transaction).</span><span class="sxs-lookup"><span data-stu-id="821c8-194">If any of the local transactions fail, the Saga aborts the operation and invokes a set of [compensating transactions](https://docs.microsoft.com/azure/architecture/patterns/compensating-transaction).</span></span> <span data-ttu-id="821c8-195">Kompenzační transakce vrátí zpět změny provedené předchozími místními transakcemi a obnoví konzistenci dat.</span><span class="sxs-lookup"><span data-stu-id="821c8-195">The compensating transactions undo the changes made by the preceding local transactions and restore data consistency.</span></span> <span data-ttu-id="821c8-196">Obrázek 5-6 ukazuje neúspěšnou transakci se vzorem Saga.</span><span class="sxs-lookup"><span data-stu-id="821c8-196">Figure 5-6 shows a failed transaction with the Saga pattern.</span></span>

![Vracení zpět ve vzoru Saga](./media/saga-rollback-operation.png)

<span data-ttu-id="821c8-198">**Obrázek 5-6**.</span><span class="sxs-lookup"><span data-stu-id="821c8-198">**Figure 5-6**.</span></span> <span data-ttu-id="821c8-199">Vrácení transakce zpět</span><span class="sxs-lookup"><span data-stu-id="821c8-199">Rolling back a transaction</span></span>

<span data-ttu-id="821c8-200">V předchozím obrázku se v mikroslužbě inventáře nezdařila operace *inventarizace aktualizací* .</span><span class="sxs-lookup"><span data-stu-id="821c8-200">In the previous figure, the *Update Inventory* operation has failed in the Inventory microservice.</span></span> <span data-ttu-id="821c8-201">Saga vyvolá sadu kompenzačních transakcí (červeně) pro úpravu inventury, zrušení platby a objednávky a vrátí data pro každou mikroslužbu zpět do konzistentního stavu.</span><span class="sxs-lookup"><span data-stu-id="821c8-201">The Saga invokes a set of compensating transactions (in red) to adjust the inventory counts, cancel the payment and the order, and return the data for each microservice back to a consistent state.</span></span>

<span data-ttu-id="821c8-202">Vzorce Saga jsou obvykle choreographed jako série souvisejících událostí nebo Orchestrované jako sada souvisejících příkazů.</span><span class="sxs-lookup"><span data-stu-id="821c8-202">Saga patterns are typically choreographed as a series of related events, or orchestrated as a set of related commands.</span></span> <span data-ttu-id="821c8-203">V kapitole 4 jsme probrali model Agregátoru služby, který by byl základem pro orchestraci Saga implementace.</span><span class="sxs-lookup"><span data-stu-id="821c8-203">In Chapter 4, we discussed the service aggregator pattern that would be the foundation for an orchestrated saga implementation.</span></span> <span data-ttu-id="821c8-204">Provedli jsme také vytváření událostí společně s Azure Service Bus a Azure Event Grid témata, která by byla základem pro implementaci choreographed Saga.</span><span class="sxs-lookup"><span data-stu-id="821c8-204">We also discussed eventing along with Azure Service Bus and Azure Event Grid topics that would be a foundation for a choreographed saga implementation.</span></span>

## <a name="high-volume-data"></a><span data-ttu-id="821c8-205">Velké objemy dat</span><span class="sxs-lookup"><span data-stu-id="821c8-205">High volume data</span></span>

<span data-ttu-id="821c8-206">Rozsáhlé aplikace pro nativní Cloud často podporují požadavky na velké objemy dat.</span><span class="sxs-lookup"><span data-stu-id="821c8-206">Large cloud-native applications often support high-volume data requirements.</span></span> <span data-ttu-id="821c8-207">V těchto scénářích můžou tradiční techniky úložiště dat způsobovat problémová místa.</span><span class="sxs-lookup"><span data-stu-id="821c8-207">In these scenarios, traditional data storage techniques can cause bottlenecks.</span></span> <span data-ttu-id="821c8-208">U složitých systémů, které se nasazují ve velkém měřítku, může výkon aplikace zvýšit jak CQRS (Command and Query Responsibility Segregation) (CQRS), tak i zdroje událostí.</span><span class="sxs-lookup"><span data-stu-id="821c8-208">For complex systems that deploy on a large scale, both Command and Query Responsibility Segregation (CQRS) and Event Sourcing may improve application performance.</span></span>  

### <a name="cqrs"></a><span data-ttu-id="821c8-209">CQRS</span><span class="sxs-lookup"><span data-stu-id="821c8-209">CQRS</span></span>

<span data-ttu-id="821c8-210">[CQRS](https://docs.microsoft.com/azure/architecture/patterns/cqrs)je model architektury, který může přispět k maximalizaci výkonu, škálovatelnosti a zabezpečení.</span><span class="sxs-lookup"><span data-stu-id="821c8-210">[CQRS](https://docs.microsoft.com/azure/architecture/patterns/cqrs), is an architectural pattern that can help maximize performance, scalability, and security.</span></span> <span data-ttu-id="821c8-211">Vzor odděluje operace, které čtou data z operací, které zapisují data.</span><span class="sxs-lookup"><span data-stu-id="821c8-211">The pattern separates operations that read data from those operations that write data.</span></span> 

<span data-ttu-id="821c8-212">V případě normálních scénářů se stejný model entity a objekt úložiště dat používají pro *operace čtení i* zápisu.</span><span class="sxs-lookup"><span data-stu-id="821c8-212">For normal scenarios, the same entity model and data repository object are used for *both* read and write operations.</span></span>

<span data-ttu-id="821c8-213">Scénář s vysokými objemy dat ale může využívat samostatné modely a tabulky dat pro čtení a zápis.</span><span class="sxs-lookup"><span data-stu-id="821c8-213">However, a high volume data scenario can benefit from separate models and data tables for reads and writes.</span></span> <span data-ttu-id="821c8-214">Aby bylo možné zvýšit výkon, operace čtení se může dotazovat na vysoce denormalizovanou reprezentaci dat, aby nedocházelo k nákladným opakovaným spojením tabulek a zámkům tabulek.</span><span class="sxs-lookup"><span data-stu-id="821c8-214">To improve performance, the read operation could query against a highly denormalized representation of the data to avoid expensive repetitive table joins and table locks.</span></span> <span data-ttu-id="821c8-215">Operace *zápisu* , která se označuje jako *příkaz*, by se aktualizovala na plně normalizovanou reprezentaci dat, která by zajistila konzistenci.</span><span class="sxs-lookup"><span data-stu-id="821c8-215">The *write* operation, known as a *command*, would update against a fully normalized representation of the data that would guarantee consistency.</span></span> <span data-ttu-id="821c8-216">Pak je nutné implementovat mechanismus, aby obě reprezentace zůstala synchronizovaná. Obvykle při každé změně tabulky zápisu publikuje událost, která replikuje úpravu do tabulky pro čtení.</span><span class="sxs-lookup"><span data-stu-id="821c8-216">You then need to implement a mechanism to keep both representations in sync. Typically, whenever the write table is modified, it publishes an event that replicates the modification to the read table.</span></span>

<span data-ttu-id="821c8-217">Obrázek 5-7 ukazuje implementaci CQRS vzoru.</span><span class="sxs-lookup"><span data-stu-id="821c8-217">Figure 5-7 shows an implementation of the CQRS pattern.</span></span>

![CQRS (Command and Query Responsibility Segregation)](./media/cqrs-implementation.png)

<span data-ttu-id="821c8-219">**Obrázek 5-7**.</span><span class="sxs-lookup"><span data-stu-id="821c8-219">**Figure 5-7**.</span></span> <span data-ttu-id="821c8-220">Implementace CQRS</span><span class="sxs-lookup"><span data-stu-id="821c8-220">CQRS implementation</span></span>

<span data-ttu-id="821c8-221">Na předchozím obrázku jsou implementované samostatné modely příkazů a dotazů.</span><span class="sxs-lookup"><span data-stu-id="821c8-221">In the previous figure, separate command and query models are implemented.</span></span> <span data-ttu-id="821c8-222">Každá operace zápisu dat je uložena do úložiště pro zápis a následně šířena do úložiště pro čtení.</span><span class="sxs-lookup"><span data-stu-id="821c8-222">Each data write operation is saved to the write store and then propagated to the read store.</span></span> <span data-ttu-id="821c8-223">Věnujte velkou pozornost tomu, jak proces šíření dat funguje na principu konečné [konzistence](http://www.cloudcomputingpatterns.org/eventual_consistency/).</span><span class="sxs-lookup"><span data-stu-id="821c8-223">Pay close attention to how the data propagation process operates on the principle of [eventual consistency](http://www.cloudcomputingpatterns.org/eventual_consistency/).</span></span> <span data-ttu-id="821c8-224">Model čtení se nakonec synchronizuje s modelem zápisu, ale v procesu může dojít k prodlevě.</span><span class="sxs-lookup"><span data-stu-id="821c8-224">The read model eventually synchronizes with the write model, but there may be some lag in the process.</span></span> <span data-ttu-id="821c8-225">V další části se podíváme na konečnou konzistenci.</span><span class="sxs-lookup"><span data-stu-id="821c8-225">We discuss eventual consistency in the next section.</span></span>

<span data-ttu-id="821c8-226">Toto oddělení umožňuje čtení a zápisy nezávisle na velikosti.</span><span class="sxs-lookup"><span data-stu-id="821c8-226">This separation enables reads and writes to scale independently.</span></span> <span data-ttu-id="821c8-227">Operace čtení používají schéma optimalizované pro dotazy, zatímco zápisy používají schéma optimalizované pro aktualizace.</span><span class="sxs-lookup"><span data-stu-id="821c8-227">Read operations use a schema optimized for queries, while the writes use a schema optimized for updates.</span></span> <span data-ttu-id="821c8-228">Čtení dotazů přechází na Denormalizovaná data, zatímco složitá obchodní logika může být použita na model zápisu.</span><span class="sxs-lookup"><span data-stu-id="821c8-228">Read queries go against denormalized data, while complex business logic can be applied to the write model.</span></span> <span data-ttu-id="821c8-229">Také můžete způsobit zvýšení zabezpečení při operacích zápisu než čtení, které zveřejňuje.</span><span class="sxs-lookup"><span data-stu-id="821c8-229">As well, you might impose tighter security on write operations than those exposing reads.</span></span>

<span data-ttu-id="821c8-230">Implementace CQRS může zlepšit výkon aplikace pro cloudové nativní služby.</span><span class="sxs-lookup"><span data-stu-id="821c8-230">Implementing CQRS can improve application performance for cloud-native services.</span></span> <span data-ttu-id="821c8-231">Výsledkem ale je složitější návrh.</span><span class="sxs-lookup"><span data-stu-id="821c8-231">However, it does result in a more complex design.</span></span> <span data-ttu-id="821c8-232">Aplikujte tento princip pečlivě a strategicky na tyto části vaší cloudové aplikace, která z nich bude výhodná.</span><span class="sxs-lookup"><span data-stu-id="821c8-232">Apply this principle carefully and strategically to those sections of your cloud-native application that will benefit from it.</span></span> <span data-ttu-id="821c8-233">Další informace o CQRS naleznete v části [mikroslužby Microsoft Book .NET: architektura pro kontejnerové aplikace .NET](https://docs.microsoft.com/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/apply-simplified-microservice-cqrs-ddd-patterns).</span><span class="sxs-lookup"><span data-stu-id="821c8-233">For more on CQRS, see the Microsoft book [.NET Microservices: Architecture for Containerized .NET Applications](https://docs.microsoft.com/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/apply-simplified-microservice-cqrs-ddd-patterns).</span></span>

### <a name="event-sourcing"></a><span data-ttu-id="821c8-234">Původ události</span><span class="sxs-lookup"><span data-stu-id="821c8-234">Event sourcing</span></span>

<span data-ttu-id="821c8-235">Dalším přístupem k optimalizaci scénářů s velkými objemy dat je využití [zdrojů událostí](https://docs.microsoft.com/azure/architecture/patterns/event-sourcing).</span><span class="sxs-lookup"><span data-stu-id="821c8-235">Another approach to optimizing high volume data scenarios involves [Event Sourcing](https://docs.microsoft.com/azure/architecture/patterns/event-sourcing).</span></span>

<span data-ttu-id="821c8-236">Systém obvykle ukládá aktuální stav datové entity.</span><span class="sxs-lookup"><span data-stu-id="821c8-236">A system typically stores the current state of a data entity.</span></span> <span data-ttu-id="821c8-237">Pokud uživatel změní své telefonní číslo, například záznam zákazníka se aktualizuje o nové číslo.</span><span class="sxs-lookup"><span data-stu-id="821c8-237">If a user changes their phone number, for example, the customer record is updated with the new number.</span></span> <span data-ttu-id="821c8-238">Vždycky ví, že aktuální stav entity dat je, ale každá aktualizace Přepisuje předchozí stav.</span><span class="sxs-lookup"><span data-stu-id="821c8-238">We always know the current state of a data entity, but each update overwrites the previous state.</span></span> 

<span data-ttu-id="821c8-239">Ve většině případů tento model funguje dobře.</span><span class="sxs-lookup"><span data-stu-id="821c8-239">In most cases, this model works fine.</span></span> <span data-ttu-id="821c8-240">V systémech s vysokým objemem ale režie z transakčního uzamykání a častých operací aktualizace může ovlivnit výkon databáze, rychlost odezvy a omezení škálovatelnosti.</span><span class="sxs-lookup"><span data-stu-id="821c8-240">In high volume systems, however, overhead from transactional locking and frequent update operations can impact database performance, responsiveness, and limit scalability.</span></span>

<span data-ttu-id="821c8-241">Pro zachytávání dat má navýšení zdroje událostí jiný přístup.</span><span class="sxs-lookup"><span data-stu-id="821c8-241">Event Sourcing takes a different approach to capturing data.</span></span> <span data-ttu-id="821c8-242">Všechny operace, které mají vliv na data, jsou uchovávány v úložišti událostí.</span><span class="sxs-lookup"><span data-stu-id="821c8-242">Each operation that affects data is persisted to an event store.</span></span> <span data-ttu-id="821c8-243">Místo aktualizace stavu datového záznamu připojíme každou změnu do sekvenčního seznamu minulých událostí – podobně jako v hlavní knize účetní knihy.</span><span class="sxs-lookup"><span data-stu-id="821c8-243">Instead of updating the state of a data record, we append each change to a sequential list of past events - similar to an accountant's ledger.</span></span> <span data-ttu-id="821c8-244">Úložiště událostí se v systému zaznamená pro data.</span><span class="sxs-lookup"><span data-stu-id="821c8-244">The Event Store becomes the system of record for the data.</span></span> <span data-ttu-id="821c8-245">Slouží k rozšíření různých vyhodnocených zobrazení v rámci ohraničeného kontextu mikroslužby.</span><span class="sxs-lookup"><span data-stu-id="821c8-245">It's used to propagate various materialized views within the bounded context of a microservice.</span></span> <span data-ttu-id="821c8-246">Obrázek 5,8 ukazuje vzor.</span><span class="sxs-lookup"><span data-stu-id="821c8-246">Figure 5.8 shows the pattern.</span></span>

![Původ události](./media/event-sourcing.png)

<span data-ttu-id="821c8-248">**Obrázek 5-8**.</span><span class="sxs-lookup"><span data-stu-id="821c8-248">**Figure 5-8**.</span></span> <span data-ttu-id="821c8-249">Původ události</span><span class="sxs-lookup"><span data-stu-id="821c8-249">Event Sourcing</span></span>

<span data-ttu-id="821c8-250">Na předchozím obrázku si všimněte, že každá položka (modře) pro nákupní košík uživatele je připojená k základnímu úložišti událostí.</span><span class="sxs-lookup"><span data-stu-id="821c8-250">In the previous figure, note how each entry (in blue) for a user's shopping cart is appended to an underlying event store.</span></span> <span data-ttu-id="821c8-251">V sousedícím materializovém zobrazení systém projektuje aktuální stav přehráním všech událostí spojených s každým nákupním košíkem.</span><span class="sxs-lookup"><span data-stu-id="821c8-251">In the adjoining materialized view, the system projects the current state by replaying all the events associated with each shopping cart.</span></span> <span data-ttu-id="821c8-252">Toto zobrazení nebo model čtení je pak zpřístupněno zpět do uživatelského rozhraní.</span><span class="sxs-lookup"><span data-stu-id="821c8-252">This view, or read model, is then exposed back to the UI.</span></span> <span data-ttu-id="821c8-253">Události je také možné integrovat s externími systémy a aplikacemi nebo s dotazem, abyste zjistili aktuální stav entity.</span><span class="sxs-lookup"><span data-stu-id="821c8-253">Events can also be integrated with external systems and applications or queried to determine the current state of an entity.</span></span> <span data-ttu-id="821c8-254">S tímto přístupem zachováte historii.</span><span class="sxs-lookup"><span data-stu-id="821c8-254">With this approach, you maintain history.</span></span> <span data-ttu-id="821c8-255">Znáte nejen aktuální stav entity, ale také to, jak jste dosáhli tohoto stavu.</span><span class="sxs-lookup"><span data-stu-id="821c8-255">You know not only the current state of an entity, but also how you reached this state.</span></span>

<span data-ttu-id="821c8-256">Naproti mechanickému nahlasování se u zdroje událostí zjednoduší model zápisu.</span><span class="sxs-lookup"><span data-stu-id="821c8-256">Mechanically speaking, event sourcing simplifies the write model.</span></span> <span data-ttu-id="821c8-257">Neexistují žádné aktualizace ani odstranění.</span><span class="sxs-lookup"><span data-stu-id="821c8-257">There are no updates or deletes.</span></span> <span data-ttu-id="821c8-258">Připojení každé datové položky jako neproměnlivá událost minimalizuje konflikty kolizí, uzamykání a souběžnosti spojené s relačními databázemi.</span><span class="sxs-lookup"><span data-stu-id="821c8-258">Appending each data entry as an immutable event minimizes contention, locking, and concurrency conflicts associated with relational databases.</span></span> <span data-ttu-id="821c8-259">Sestavování modelů čtení pomocí vzoru materializované zobrazení umožňuje oddělit zobrazení od modelu zápisu a zvolit nejvhodnější úložiště dat pro optimalizaci potřeb uživatelského rozhraní aplikace.</span><span class="sxs-lookup"><span data-stu-id="821c8-259">Building read models with the materialized view pattern enables you to decouple the view from the write model and choose the best data store to optimize the needs of your application UI.</span></span>

<span data-ttu-id="821c8-260">Pro tento model Vezměte v úvahu úložiště dat, které přímo podporuje zdrojové události.</span><span class="sxs-lookup"><span data-stu-id="821c8-260">For this pattern, consider a data store that directly supports event sourcing.</span></span> <span data-ttu-id="821c8-261">Azure Cosmos DB, MongoDB, Cassandra, CouchDB a RavenDB jsou vhodné kandidáty.</span><span class="sxs-lookup"><span data-stu-id="821c8-261">Azure Cosmos DB, MongoDB, Cassandra, CouchDB, and RavenDB are good candidates.</span></span>

<span data-ttu-id="821c8-262">Stejně jako u všech vzorů a technologií implementujte strategické a v případě potřeby.</span><span class="sxs-lookup"><span data-stu-id="821c8-262">As with all patterns and technologies, implement strategically and when needed.</span></span> <span data-ttu-id="821c8-263">I když může poskytovat zvýšení výkonu a škálovatelnosti, přináší se vám náklady na složitost a výuková křivka.</span><span class="sxs-lookup"><span data-stu-id="821c8-263">While event sourcing can provide increased performance and scalability, it comes at the expense of complexity and a learning curve.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="821c8-264">[Předchozí](service-mesh-communication-infrastructure.md)
>[Další](relational-vs-nosql-data.md)</span><span class="sxs-lookup"><span data-stu-id="821c8-264">[Previous](service-mesh-communication-infrastructure.md)
[Next](relational-vs-nosql-data.md)</span></span>
