---
title: Řízení stavu
description: Naučte se různé přístupy ke správě stavu ve webových formulářích ASP.NET a Blazor.
author: csharpfritz
ms.author: jefritz
ms.date: 05/15/2020
ms.openlocfilehash: bac2f00330113725f09259ca31bdf857a8769f24
ms.sourcegitcommit: 7476c20d2f911a834a00b8a7f5e8926bae6804d9
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 08/11/2020
ms.locfileid: "88062337"
---
# <a name="state-management"></a><span data-ttu-id="21578-103">Řízení stavu</span><span class="sxs-lookup"><span data-stu-id="21578-103">State management</span></span>

[!INCLUDE [book-preview](../../../includes/book-preview.md)]

<span data-ttu-id="21578-104">Správa stavu je klíčovým konceptem aplikací webových formulářů, které usnadňují funkce zobrazení stav, stav relace, stav aplikace a zpětné odeslání.</span><span class="sxs-lookup"><span data-stu-id="21578-104">State management is a key concept of Web Forms applications, facilitated through View State, Session State, Application State, and Postback features.</span></span> <span data-ttu-id="21578-105">Tyto stavové funkce rozhraní pomáhající za účelem skrytí správy stavu požadované pro aplikaci a umožnění vývojářům aplikací soustředit se na poskytování jejich funkcí.</span><span class="sxs-lookup"><span data-stu-id="21578-105">These stateful features of the framework helped to hide the state management required for an application and allow application developers to focus on delivering their functionality.</span></span> <span data-ttu-id="21578-106">Při ASP.NET Core a Blazor byly některé z těchto funkcí přemístěné a některé z nich byly zcela odebrány.</span><span class="sxs-lookup"><span data-stu-id="21578-106">With ASP.NET Core and Blazor, some of these features have been relocated and some have been removed altogether.</span></span> <span data-ttu-id="21578-107">Tato kapitola si přečte, jak udržovat stav a doručovat stejné funkce s novými funkcemi v Blazor.</span><span class="sxs-lookup"><span data-stu-id="21578-107">This chapter reviews how to maintain state and deliver the same functionality with the new features in Blazor.</span></span>

## <a name="request-state-management-with-viewstate"></a><span data-ttu-id="21578-108">Správa stavu požadavku pomocí vlastnosti ViewState</span><span class="sxs-lookup"><span data-stu-id="21578-108">Request state management with ViewState</span></span>

<span data-ttu-id="21578-109">Při diskusích o správě stavů v aplikaci webových formulářů se vám bude zdát, že mnoho vývojářů bude okamžitě považovat stav ViewState.</span><span class="sxs-lookup"><span data-stu-id="21578-109">When discussing state management in Web Forms application, many developers will immediately think of ViewState.</span></span> <span data-ttu-id="21578-110">Ve webových formulářích vlastnost ViewState spravuje stav obsahu mezi požadavky HTTP tím, že do prohlížeče odesílá velký kódovaný blok textu zpátky a zpátky.</span><span class="sxs-lookup"><span data-stu-id="21578-110">In Web Forms, ViewState manages the state of the content between HTTP requests by sending a large encoded block of text back and forth to the browser.</span></span> <span data-ttu-id="21578-111">Pole ViewState by mohlo být zahlceno obsahem ze stránky obsahující mnoho prvků, což může být zvětšení na více megabajtů.</span><span class="sxs-lookup"><span data-stu-id="21578-111">The ViewState field could be overwhelmed with content from a page containing many elements, potentially expanding to several megabytes in size.</span></span>

<span data-ttu-id="21578-112">S Blazor serverem aplikace udržuje průběžné připojení k serveru.</span><span class="sxs-lookup"><span data-stu-id="21578-112">With Blazor Server, the app maintains an ongoing connection with the server.</span></span> <span data-ttu-id="21578-113">Stav aplikace nazvaný *okruh*se uchovává v paměti serveru, zatímco připojení je považováno za aktivní.</span><span class="sxs-lookup"><span data-stu-id="21578-113">The app's state, called a *circuit*, is held in server memory while the connection is considered active.</span></span> <span data-ttu-id="21578-114">Stav se odstraní jenom v případě, že uživatel přejde pryč z aplikace nebo konkrétní stránky v aplikaci.</span><span class="sxs-lookup"><span data-stu-id="21578-114">State will only be disposed when the user navigates away from the app or a particular page in the app.</span></span> <span data-ttu-id="21578-115">Všichni členové aktivních komponent jsou k dispozici mezi interakcemi se serverem.</span><span class="sxs-lookup"><span data-stu-id="21578-115">All members of the active components are available between interactions with the server.</span></span>

<span data-ttu-id="21578-116">Tato funkce má několik výhod:</span><span class="sxs-lookup"><span data-stu-id="21578-116">There are several advantages of this feature:</span></span>

- <span data-ttu-id="21578-117">Stav součásti je snadno dostupný a není mezi interakcemi znovu sestaven.</span><span class="sxs-lookup"><span data-stu-id="21578-117">Component state is readily available and not rebuilt between interactions.</span></span>
- <span data-ttu-id="21578-118">Stav není přenesen do prohlížeče.</span><span class="sxs-lookup"><span data-stu-id="21578-118">State isn't transmitted to the browser.</span></span>

<span data-ttu-id="21578-119">Existují však nevýhody trvalého uchovávání stavu součástí v paměti, které je třeba znát:</span><span class="sxs-lookup"><span data-stu-id="21578-119">However, there are some disadvantages to in-memory component state persistence to be aware of:</span></span>

- <span data-ttu-id="21578-120">Pokud se server restartuje mezi požadavky, ztratí se stav.</span><span class="sxs-lookup"><span data-stu-id="21578-120">If the server restarts between request, state is lost.</span></span>
- <span data-ttu-id="21578-121">Řešení vyrovnávání zatížení webového serveru aplikace musí zahrnovat rychlé relace, aby se zajistilo, že všechny požadavky ze stejného prohlížeče vrátí na stejný server.</span><span class="sxs-lookup"><span data-stu-id="21578-121">Your application web server load-balancing solution must include sticky sessions to ensure that all requests from the same browser return to the same server.</span></span> <span data-ttu-id="21578-122">Pokud požadavek přejde na jiný server, stav se ztratí.</span><span class="sxs-lookup"><span data-stu-id="21578-122">If a request goes to a different server, state will be lost.</span></span>
- <span data-ttu-id="21578-123">Persistence stavu součásti na serveru může způsobit tlak na paměť na webovém serveru.</span><span class="sxs-lookup"><span data-stu-id="21578-123">Persistence of component state on the server can lead to memory pressure on the web server.</span></span>

<span data-ttu-id="21578-124">Z předchozích důvodů nespoléhejte na to, že pouze stav komponenty se nachází v paměti na serveru.</span><span class="sxs-lookup"><span data-stu-id="21578-124">For the preceding reasons, don't rely on just the state of the component to reside in-memory on the server.</span></span> <span data-ttu-id="21578-125">Vaše aplikace by měla také zahrnovat některé záložní úložiště dat pro data mezi požadavky.</span><span class="sxs-lookup"><span data-stu-id="21578-125">Your application should also include some backing data store for data between requests.</span></span> <span data-ttu-id="21578-126">Některé jednoduché příklady této strategie:</span><span class="sxs-lookup"><span data-stu-id="21578-126">Some simple examples of this strategy:</span></span>

- <span data-ttu-id="21578-127">V aplikaci nákupního košíku trvale zachovejte obsah nových položek přidaných do košíku v záznamu databáze.</span><span class="sxs-lookup"><span data-stu-id="21578-127">In a shopping cart application, persist the content of new items added to the cart in a database record.</span></span> <span data-ttu-id="21578-128">Pokud dojde ke ztrátě stavu na serveru, můžete ho ze záznamů databáze znovu vytvořit.</span><span class="sxs-lookup"><span data-stu-id="21578-128">If the state on the server is lost, you can reconstitute it from the database records.</span></span>
- <span data-ttu-id="21578-129">Ve webovém formuláři s více částmi budou uživatelé očekávat, že vaše aplikace bude pamatovat hodnoty mezi jednotlivými požadavky.</span><span class="sxs-lookup"><span data-stu-id="21578-129">In a multi-part web form, your users will expect your application to remember values between each request.</span></span> <span data-ttu-id="21578-130">Zapište data mezi příspěvky vašeho uživatele do úložiště dat, aby je bylo možné načíst a sestavit do konečné struktury odpovědí na formuláři po dokončení formuláře s více částmi.</span><span class="sxs-lookup"><span data-stu-id="21578-130">Write the data between each of your user's posts to a data store so that they can be fetched and assembled into the final form response structure when the multi-part form is completed.</span></span>

<span data-ttu-id="21578-131">Další podrobnosti o správě stavu v aplikacích Blazor naleznete v tématu [ASP.NET Core Blazor State Management](/aspnet/core/blazor/state-management).</span><span class="sxs-lookup"><span data-stu-id="21578-131">For additional details on managing state in Blazor apps, see [ASP.NET Core Blazor state management](/aspnet/core/blazor/state-management).</span></span>

## <a name="maintain-state-with-session"></a><span data-ttu-id="21578-132">Udržovat stav s relací</span><span class="sxs-lookup"><span data-stu-id="21578-132">Maintain state with Session</span></span>

<span data-ttu-id="21578-133">Vývojáři webových formulářů mohou spravovat informace o aktuálně fungujícím uživateli pomocí <xref:Microsoft.AspNetCore.Http.ISession?displayProperty=nameWithType> objektu Dictionary.</span><span class="sxs-lookup"><span data-stu-id="21578-133">Web Forms developers could maintain information about the currently acting user with the <xref:Microsoft.AspNetCore.Http.ISession?displayProperty=nameWithType> dictionary object.</span></span> <span data-ttu-id="21578-134">Je dostatečně snadné přidat objekt s klíčem řetězce do objektu `Session` a tento objekt bude k dispozici později během interakce uživatele s aplikací.</span><span class="sxs-lookup"><span data-stu-id="21578-134">It's easy enough to add an object with a string key to the `Session`, and that object would be available at a later time during the user's interactions with the application.</span></span> <span data-ttu-id="21578-135">Při pokusu o odstranění správy interakce s protokolem HTTP `Session` objekt usnadňuje udržování stavu.</span><span class="sxs-lookup"><span data-stu-id="21578-135">In an attempt to eliminate managing interacting with HTTP, the `Session` object made it easy to maintain state.</span></span>

<span data-ttu-id="21578-136">Podpis `Session` objektu .NET Framework není stejný jako `Session` objekt ASP.NET Core.</span><span class="sxs-lookup"><span data-stu-id="21578-136">The signature of the .NET Framework `Session` object isn't the same as the ASP.NET Core `Session` object.</span></span> <span data-ttu-id="21578-137">Před rozhodnutím o migraci a používání nové funkce stavu relace zvažte, jestli je [v dokumentaci k nové relaci ASP.NET Core](/dotnet/api/microsoft.aspnetcore.http.isession) .</span><span class="sxs-lookup"><span data-stu-id="21578-137">Consider [the documentation for the new ASP.NET Core Session](/dotnet/api/microsoft.aspnetcore.http.isession) before deciding to migrate and use the new session state feature.</span></span>

<span data-ttu-id="21578-138">Relace je dostupná na serveru ASP.NET Core a Blazor, ale nedoporučuje se používat jako vhodným způsobem ukládat data do úložiště dat.</span><span class="sxs-lookup"><span data-stu-id="21578-138">Session is available in ASP.NET Core and Blazor Server, but is discouraged from use in favor of storing data in a data repository appropriately.</span></span> <span data-ttu-id="21578-139">Stav relace není funkční ani v případě, že Návštěvníci odmítnou v aplikaci používat soubory cookie protokolu HTTP, protože se týkají ochrany osobních údajů.</span><span class="sxs-lookup"><span data-stu-id="21578-139">Session state is also not functional if visitors decline the use HTTP cookies in your application due to privacy concerns.</span></span>

<span data-ttu-id="21578-140">Konfigurace pro ASP.NET Core a stav relace je k dispozici v části [relace a Správa stavu v ASP.NET Core článku](/aspnet/core/fundamentals/app-state#session-state).</span><span class="sxs-lookup"><span data-stu-id="21578-140">Configuration for ASP.NET Core and Session state is available in the [Session and state management in ASP.NET Core article](/aspnet/core/fundamentals/app-state#session-state).</span></span>

## <a name="application-state"></a><span data-ttu-id="21578-141">Stav aplikace</span><span class="sxs-lookup"><span data-stu-id="21578-141">Application state</span></span>

<span data-ttu-id="21578-142">`Application`Objekt v rozhraní Web Forms Framework poskytuje hromadné úložiště mezi požadavky pro interakci s konfigurací a stavem oboru aplikace.</span><span class="sxs-lookup"><span data-stu-id="21578-142">The `Application` object in the Web Forms framework provides a massive, cross-request repository for interacting with application-scope configuration and state.</span></span> <span data-ttu-id="21578-143">Stav aplikace byl ideálním místem pro uložení různých vlastností konfigurace aplikace, na které by se měly odkazovat všechny požadavky bez ohledu na to, jakou uživatel požadavek odeslal.</span><span class="sxs-lookup"><span data-stu-id="21578-143">Application state was an ideal place to store various application configuration properties that would be referenced by all requests, regardless of the user making the request.</span></span> <span data-ttu-id="21578-144">Došlo k problému s `Application` objektem, protože data nebyla na více serverech trvalá.</span><span class="sxs-lookup"><span data-stu-id="21578-144">The problem with the `Application` object was that data didn't persist across multiple servers.</span></span> <span data-ttu-id="21578-145">Došlo ke ztrátě stavu objektu aplikace mezi restarty.</span><span class="sxs-lookup"><span data-stu-id="21578-145">The state of the application object was lost between restarts.</span></span>

<span data-ttu-id="21578-146">Stejně jako u nástroje `Session` doporučujeme, aby se data přesunula do trvalého záložního úložiště, ke kterému by bylo možné přibrat více instancí serveru.</span><span class="sxs-lookup"><span data-stu-id="21578-146">As with `Session`, it's recommended that data move to a persistent backing store that could be accessed by multiple server instances.</span></span> <span data-ttu-id="21578-147">Pokud jsou k dispozici Nestálá data, ke kterým byste měli mít přístup přes žádosti a uživatele, můžete ji snadno uložit ve službě s jedním prvkem, která může být vložena do součástí, které tyto informace nebo interakce vyžadují.</span><span class="sxs-lookup"><span data-stu-id="21578-147">If there is volatile data that you would like to be able to access across requests and users, you could easily store it in a singleton service that can be injected into components that require this information or interaction.</span></span>

<span data-ttu-id="21578-148">Konstrukce objektu pro udržení stavu aplikace a jeho spotřeby by mohla vypadat jako následující implementace:</span><span class="sxs-lookup"><span data-stu-id="21578-148">The construction of an object to maintain application state and its consumption could resemble the following implementation:</span></span>

```csharp
public class MyApplicationState
{
    public int VisitorCounter { get; private set; } = 0;

    public void IncrementCounter() => VisitorCounter += 1;
}
```

```csharp
app.AddSingleton<MyApplicationState>();
```

```razor
@inject MyApplicationState AppState

<label>Total Visitors: @AppState.VisitorCounter</label>
```

<span data-ttu-id="21578-149">`MyApplicationState`Objekt je vytvořen pouze jednou na serveru a hodnota `VisitorCounter` je načtena a výstupem v popisku komponenty.</span><span class="sxs-lookup"><span data-stu-id="21578-149">The `MyApplicationState` object is created only once on the server, and the value `VisitorCounter` is fetched and output in the component's label.</span></span> <span data-ttu-id="21578-150">`VisitorCounter`Hodnota by měla být trvalá a načtena ze záložního úložiště dat pro zajištění odolnosti a škálovatelnosti.</span><span class="sxs-lookup"><span data-stu-id="21578-150">The `VisitorCounter` value should be persisted and retrieved from a backing data store for durability and scalability.</span></span>

## <a name="in-the-browser"></a><span data-ttu-id="21578-151">V prohlížeči</span><span class="sxs-lookup"><span data-stu-id="21578-151">In the browser</span></span>

<span data-ttu-id="21578-152">Data aplikací můžete také uložit na straně klienta na zařízení uživatele, která jsou k dispozici později.</span><span class="sxs-lookup"><span data-stu-id="21578-152">Application data can also be stored client-side on the user's device so that is available later.</span></span> <span data-ttu-id="21578-153">Existují dvě funkce prohlížeče, které umožňují trvalá data v různých oborech prohlížeče uživatele:</span><span class="sxs-lookup"><span data-stu-id="21578-153">There are two browser features that allow for persistence of data in different scopes of the user's browser:</span></span>

- <span data-ttu-id="21578-154">`localStorage`– vymezen pro celý prohlížeč uživatele.</span><span class="sxs-lookup"><span data-stu-id="21578-154">`localStorage` - scoped to the user's entire browser.</span></span> <span data-ttu-id="21578-155">Pokud je stránka znovu načtena, prohlížeč je zavřen a znovu otevřen nebo je otevřena jiná karta se stejnou adresou URL, a `localStorage` to v prohlížeči.</span><span class="sxs-lookup"><span data-stu-id="21578-155">If the page is reloaded, the browser is closed and reopened, or another tab is opened with the same URL then the same `localStorage` is provided by the browser</span></span>
- <span data-ttu-id="21578-156">`sessionStorage`-vymezeno na aktuální kartu prohlížeče uživatele. Pokud se karta znovu načte, stav přetrvává.</span><span class="sxs-lookup"><span data-stu-id="21578-156">`sessionStorage` - scoped to the user's current browser tab. If the tab is reloaded, the state persists.</span></span> <span data-ttu-id="21578-157">Pokud však uživatel otevře jinou kartu pro aplikaci nebo zavře a znovu otevře prohlížeč, dojde ke ztrátě stavu.</span><span class="sxs-lookup"><span data-stu-id="21578-157">However, if the user opens another tab to your application or closes and reopens the browser the state is lost.</span></span>

<span data-ttu-id="21578-158">Můžete napsat nějaký vlastní kód JavaScriptu pro interakci s těmito funkcemi, nebo můžete použít několik balíčků NuGet, které tuto funkci poskytují.</span><span class="sxs-lookup"><span data-stu-id="21578-158">You can write some custom JavaScript code to interact with these features, or there are a number of NuGet packages that you can use that provide this functionality.</span></span> <span data-ttu-id="21578-159">Jedním z těchto balíčků je [Microsoft. AspNetCore. ProtectedBrowserStorage](https://www.nuget.org/packages/Microsoft.AspNetCore.ProtectedBrowserStorage).</span><span class="sxs-lookup"><span data-stu-id="21578-159">One such package is [Microsoft.AspNetCore.ProtectedBrowserStorage](https://www.nuget.org/packages/Microsoft.AspNetCore.ProtectedBrowserStorage).</span></span>

<span data-ttu-id="21578-160">Pokyny k použití tohoto balíčku k interakci s `localStorage` a naleznete v `sessionStorage` článku [Správa stavů Blazor](/aspnet/core/blazor/state-management#protected-browser-storage-experimental-package) .</span><span class="sxs-lookup"><span data-stu-id="21578-160">For instructions on utilizing this package to interact with `localStorage` and `sessionStorage`, see the [Blazor State Management](/aspnet/core/blazor/state-management#protected-browser-storage-experimental-package) article.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="21578-161">[Předchozí](pages-routing-layouts.md) 
> [Další](forms-validation.md)</span><span class="sxs-lookup"><span data-stu-id="21578-161">[Previous](pages-routing-layouts.md)
[Next](forms-validation.md)</span></span>
