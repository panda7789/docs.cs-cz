---
title: Zásady architektury
description: Architekt moderních webových aplikací pomocí ASP.NET Core a Azure | Principy architektury
author: ardalis
ms.author: wiwagn
ms.date: 12/04/2019
ms.openlocfilehash: a3444071abae89780304a9687e486f3842283a33
ms.sourcegitcommit: 046a9c22487551360e20ec39fc21eef99820a254
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 05/14/2020
ms.locfileid: "83396249"
---
# <a name="architectural-principles"></a><span data-ttu-id="f1a16-103">Zásady architektury</span><span class="sxs-lookup"><span data-stu-id="f1a16-103">Architectural principles</span></span>

> <span data-ttu-id="f1a16-104">"Pokud si tvůrci vytvořili budovy způsob, jakým programátoři zapsali programy, pak první Woodpecker, která byla vytvořena společně, by Civilization zničit."</span><span class="sxs-lookup"><span data-stu-id="f1a16-104">"If builders built buildings the way programmers wrote programs, then the first woodpecker that came along would destroy civilization."</span></span>  
> <span data-ttu-id="f1a16-105">_\-Gerald Weinberg_</span><span class="sxs-lookup"><span data-stu-id="f1a16-105">_\- Gerald Weinberg_</span></span>

<span data-ttu-id="f1a16-106">Měli byste vytvářet architekta a navrhovat softwarová řešení s ohledem na udržovatelnost.</span><span class="sxs-lookup"><span data-stu-id="f1a16-106">You should architect and design software solutions with maintainability in mind.</span></span> <span data-ttu-id="f1a16-107">Zásady uvedené v této části vám pomohou při rozhodování o architektuře, které budou mít za následek čisté a udržovatelnější aplikace.</span><span class="sxs-lookup"><span data-stu-id="f1a16-107">The principles outlined in this section can help guide you toward architectural decisions that will result in clean, maintainable applications.</span></span> <span data-ttu-id="f1a16-108">Obecně platí, že tyto zásady vám pomohou sestavovat aplikace z diskrétních komponent, které nejsou pevně spojené s ostatními částmi aplikace, ale budou komunikovat přes explicitní rozhraní nebo systémy zasílání zpráv.</span><span class="sxs-lookup"><span data-stu-id="f1a16-108">Generally, these principles will guide you toward building applications out of discrete components that are not tightly coupled to other parts of your application, but rather communicate through explicit interfaces or messaging systems.</span></span>

## <a name="common-design-principles"></a><span data-ttu-id="f1a16-109">Obecné principy návrhu</span><span class="sxs-lookup"><span data-stu-id="f1a16-109">Common design principles</span></span>

### <a name="separation-of-concerns"></a><span data-ttu-id="f1a16-110">Oddělení obav</span><span class="sxs-lookup"><span data-stu-id="f1a16-110">Separation of concerns</span></span>

<span data-ttu-id="f1a16-111">Princip identifikátoru GUID při vývoji je **oddělením otázek**.</span><span class="sxs-lookup"><span data-stu-id="f1a16-111">A guiding principle when developing is **Separation of Concerns**.</span></span> <span data-ttu-id="f1a16-112">Tento princip vyhodnotí, že software by měl být oddělený podle druhu práce, kterou provádí.</span><span class="sxs-lookup"><span data-stu-id="f1a16-112">This principle asserts that software should be separated based on the kinds of work it performs.</span></span> <span data-ttu-id="f1a16-113">Představte si například aplikaci, která obsahuje logiku pro identifikaci zajímavostich položek, které se mají zobrazit uživateli, a které formátuje tyto položky určitým způsobem, aby je bylo možné posuzovat.</span><span class="sxs-lookup"><span data-stu-id="f1a16-113">For instance, consider an application that includes logic for identifying noteworthy items to display to the user, and which formats such items in a particular way to make them more noticeable.</span></span> <span data-ttu-id="f1a16-114">Chování zodpovědné za výběr položek, které mají být naformátované, by mělo být oddělené od chování zodpovědného za formátování položek, protože toto chování je samostatné, které se týkají pouze koincidentů, které souvisejí s sebou.</span><span class="sxs-lookup"><span data-stu-id="f1a16-114">The behavior responsible for choosing which items to format should be kept separate from the behavior responsible for formatting the items, since these behaviors are separate concerns that are only coincidentally related to one another.</span></span>

<span data-ttu-id="f1a16-115">Aplikace může být logicky sestavena tak, aby se dostupovala podle tohoto principu tím, že se oddělí základní obchodní chování z infrastruktury a logiky uživatelského rozhraní.</span><span class="sxs-lookup"><span data-stu-id="f1a16-115">Architecturally, applications can be logically built to follow this principle by separating core business behavior from infrastructure and user-interface logic.</span></span> <span data-ttu-id="f1a16-116">V ideálním případě by se obchodní pravidla a logika měla nacházet v samostatném projektu, který by neměl záviset na jiných projektech v aplikaci.</span><span class="sxs-lookup"><span data-stu-id="f1a16-116">Ideally, business rules and logic should reside in a separate project, which should not depend on other projects in the application.</span></span> <span data-ttu-id="f1a16-117">Toto oddělení pomáhá zajistit, aby byl obchodní model snadno testován a mohl se vyvíjet bez úzce se nespojit s podrobnostmi implementace nízké úrovně.</span><span class="sxs-lookup"><span data-stu-id="f1a16-117">This separation helps ensure that the business model is easy to test and can evolve without being tightly coupled to low-level implementation details.</span></span> <span data-ttu-id="f1a16-118">Oddělení obav je klíčové hledisko za použití vrstev v architekturách aplikací.</span><span class="sxs-lookup"><span data-stu-id="f1a16-118">Separation of concerns is a key consideration behind the use of layers in application architectures.</span></span>

### <a name="encapsulation"></a><span data-ttu-id="f1a16-119">Zapouzdření</span><span class="sxs-lookup"><span data-stu-id="f1a16-119">Encapsulation</span></span>

<span data-ttu-id="f1a16-120">Různé části aplikace by měly používat **zapouzdření** k izolaci z jiných částí aplikace.</span><span class="sxs-lookup"><span data-stu-id="f1a16-120">Different parts of an application should use **encapsulation** to insulate them from other parts of the application.</span></span> <span data-ttu-id="f1a16-121">Komponenty a vrstvy aplikace by měly být schopné upravit svou interní implementaci bez nutnosti přerušit své spolupracovníky, pokud nedošlo k porušení vnějších smluv.</span><span class="sxs-lookup"><span data-stu-id="f1a16-121">Application components and layers should be able to adjust their internal implementation without breaking their collaborators as long as external contracts are not violated.</span></span> <span data-ttu-id="f1a16-122">Správné použití zapouzdření pomáhá dosáhnout volného propojení a modularity v návrzích aplikací, protože objekty a balíčky lze nahradit alternativními implementacemi, pokud je stejné rozhraní zachováno.</span><span class="sxs-lookup"><span data-stu-id="f1a16-122">Proper use of encapsulation helps achieve loose coupling and modularity in application designs, since objects and packages can be replaced with alternative implementations so long as the same interface is maintained.</span></span>

<span data-ttu-id="f1a16-123">Ve třídách je zapouzdření dosaženo omezením přístupu mimo přístup k vnitřnímu stavu třídy.</span><span class="sxs-lookup"><span data-stu-id="f1a16-123">In classes, encapsulation is achieved by limiting outside access to the class's internal state.</span></span> <span data-ttu-id="f1a16-124">Pokud externí objekt actor chce manipulovat se stavem objektu, měl by tak učinit prostřednictvím dobře definované funkce (nebo metody setter) místo přímého přístupu k privátnímu stavu objektu.</span><span class="sxs-lookup"><span data-stu-id="f1a16-124">If an outside actor wants to manipulate the state of the object, it should do so through a well-defined function (or property setter), rather than having direct access to the private state of the object.</span></span> <span data-ttu-id="f1a16-125">Stejně tak by komponenty aplikace a aplikace samy měly vystavovat dobře definovaná rozhraní pro své spolupracovníky, aby je bylo možné použít, místo aby bylo možné jejich stav upravovat přímo.</span><span class="sxs-lookup"><span data-stu-id="f1a16-125">Likewise, application components and applications themselves should expose well-defined interfaces for their collaborators to use, rather than allowing their state to be modified directly.</span></span> <span data-ttu-id="f1a16-126">Tím se uvolní interní návrh aplikace v průběhu času, aniž by to mělo starosti s tím, že spolupracuje spolupracovníci, pokud se zachovají veřejné smlouvy.</span><span class="sxs-lookup"><span data-stu-id="f1a16-126">This frees the application's internal design to evolve over time without worrying that doing so will break collaborators, so long as the public contracts are maintained.</span></span>

### <a name="dependency-inversion"></a><span data-ttu-id="f1a16-127">Inverze závislosti</span><span class="sxs-lookup"><span data-stu-id="f1a16-127">Dependency inversion</span></span>

<span data-ttu-id="f1a16-128">Směr závislosti v rámci aplikace by měl být ve směru abstrakce, nikoli v podrobnostech implementace.</span><span class="sxs-lookup"><span data-stu-id="f1a16-128">The direction of dependency within the application should be in the direction of abstraction, not implementation details.</span></span> <span data-ttu-id="f1a16-129">Většina aplikací je zapsána tak, aby toky závislosti v době kompilace byly ve směru spouštění za běhu a vytvořily přímý graf závislosti.</span><span class="sxs-lookup"><span data-stu-id="f1a16-129">Most applications are written such that compile-time dependency flows in the direction of runtime execution, producing a direct dependency graph.</span></span> <span data-ttu-id="f1a16-130">To znamená, že pokud modul A zavolá funkci v modulu B, která volá funkci v modulu C, pak v době kompilace bude záviset na B, která bude záviset na C, jak je znázorněno na obrázku 4-1.</span><span class="sxs-lookup"><span data-stu-id="f1a16-130">That is, if module A calls a function in module B, which calls a function in module C, then at compile time A will depend on B, which will depend on C, as shown in Figure 4-1.</span></span>

![Graf přímého závislosti](./media/image4-1.png)

<span data-ttu-id="f1a16-132">**Obrázek 4-1.**</span><span class="sxs-lookup"><span data-stu-id="f1a16-132">**Figure 4-1.**</span></span> <span data-ttu-id="f1a16-133">Graf přímého závislosti</span><span class="sxs-lookup"><span data-stu-id="f1a16-133">Direct dependency graph.</span></span>

<span data-ttu-id="f1a16-134">Použití principu pro inverze závislostí umožňuje volat metody na abstrakci, kterou B implementuje, aby bylo možné volat B za běhu, ale v případě B na rozhraní, které je řízeno v době kompilace (tedy *Invertuje* typickou závislost v době kompilace).</span><span class="sxs-lookup"><span data-stu-id="f1a16-134">Applying the dependency inversion principle allows A to call methods on an abstraction that B implements, making it possible for A to call B at runtime, but for B to depend on an interface controlled by A at compile time (thus, *inverting* the typical compile-time dependency).</span></span> <span data-ttu-id="f1a16-135">V době běhu zůstává tok spuštění programu nezměněný, ale zavedení rozhraní znamená, že je možné snadno zapojit různé implementace těchto rozhraní.</span><span class="sxs-lookup"><span data-stu-id="f1a16-135">At run time, the flow of program execution remains unchanged, but the introduction of interfaces means that different implementations of these interfaces can easily be plugged in.</span></span>

![Graf obrácené závislosti](./media/image4-2.png)

<span data-ttu-id="f1a16-137">**Obrázek 4-2.**</span><span class="sxs-lookup"><span data-stu-id="f1a16-137">**Figure 4-2.**</span></span> <span data-ttu-id="f1a16-138">Graf nevrácené závislosti</span><span class="sxs-lookup"><span data-stu-id="f1a16-138">Inverted dependency graph.</span></span>

<span data-ttu-id="f1a16-139">**Inverze závislosti** je klíčovou součástí vytváření volně vázaných aplikací, protože podrobnosti implementace mohou být zapsány do záviset na a implementovat abstrakce na vyšší úrovni, nikoli jiným způsobem.</span><span class="sxs-lookup"><span data-stu-id="f1a16-139">**Dependency inversion** is a key part of building loosely coupled applications, since implementation details can be written to depend on and implement higher-level abstractions, rather than the other way around.</span></span> <span data-ttu-id="f1a16-140">Výsledné aplikace jsou ve výsledku testovatelné, modulární a udržovatelnější.</span><span class="sxs-lookup"><span data-stu-id="f1a16-140">The resulting applications are more testable, modular, and maintainable as a result.</span></span> <span data-ttu-id="f1a16-141">Postup *Injektáže závislosti* je možný pomocí principu inverze závislosti.</span><span class="sxs-lookup"><span data-stu-id="f1a16-141">The practice of *dependency injection* is made possible by following the dependency inversion principle.</span></span>

### <a name="explicit-dependencies"></a><span data-ttu-id="f1a16-142">Explicitní závislosti</span><span class="sxs-lookup"><span data-stu-id="f1a16-142">Explicit dependencies</span></span>

<span data-ttu-id="f1a16-143">**Metody a třídy by měly explicitně vyžadovat všechny objekty spolupráce, které potřebují, aby fungovaly správně.**</span><span class="sxs-lookup"><span data-stu-id="f1a16-143">**Methods and classes should explicitly require any collaborating objects they need in order to function correctly.**</span></span> <span data-ttu-id="f1a16-144">Konstruktory třídy poskytují příležitost pro třídy k identifikaci potřebných věcí, aby byly v platném stavu a fungovaly správně.</span><span class="sxs-lookup"><span data-stu-id="f1a16-144">Class constructors provide an opportunity for classes to identify the things they need in order to be in a valid state and to function properly.</span></span> <span data-ttu-id="f1a16-145">Pokud definujete třídy, které mohou být vytvořeny a volány, ale budou správně fungovat pouze v případě, že jsou vytvořeny určité globální nebo infrastrukturní komponenty, tyto třídy jsou pro *klienty bez problémů* .</span><span class="sxs-lookup"><span data-stu-id="f1a16-145">If you define classes that can be constructed and called, but that will only function properly if certain global or infrastructure components are in place, these classes are being *dishonest* with their clients.</span></span> <span data-ttu-id="f1a16-146">Kontrakt konstruktoru oznamuje klientovi, že potřebuje jenom zadané věci (možná nic, když třída používá jenom parametr bez parametrů), ale pak za běhu vypíná objekt, který skutečně potřebuje něco jiného.</span><span class="sxs-lookup"><span data-stu-id="f1a16-146">The constructor contract is telling the client that it only needs the things specified (possibly nothing if the class is just using a parameterless constructor), but then at runtime it turns out the object really did need something else.</span></span>

<span data-ttu-id="f1a16-147">Pomocí principu explicitních závislostí jsou vaše třídy a metody od klientů od jejich klientů bezvýznamné, aby fungovaly.</span><span class="sxs-lookup"><span data-stu-id="f1a16-147">By following the explicit dependencies principle, your classes and methods are being honest with their clients about what they need in order to function.</span></span> <span data-ttu-id="f1a16-148">V souladu s principem je váš kód více uživatelsky přívětivým dokumentování a vaše kontrakty kódu jsou uživatelsky přívětivé, protože uživatelé budou mít důvěru, že pokud jsou požadovány ve formě parametrů metody nebo konstruktoru, objekty, se kterými pracují, se budou chovat správně v době běhu.</span><span class="sxs-lookup"><span data-stu-id="f1a16-148">Following the principle makes your code more self-documenting and your coding contracts more user-friendly, since users will come to trust that as long as they provide what's required in the form of method or constructor parameters, the objects they're working with will behave correctly at run time.</span></span>

### <a name="single-responsibility"></a><span data-ttu-id="f1a16-149">Jediná odpovědnost</span><span class="sxs-lookup"><span data-stu-id="f1a16-149">Single responsibility</span></span>

<span data-ttu-id="f1a16-150">Princip jedné zodpovědnosti se vztahuje na objektově orientovaný návrh, ale je možné ho také považovat za Princip architektury, který se podobá oddělení obav.</span><span class="sxs-lookup"><span data-stu-id="f1a16-150">The single responsibility principle applies to object-oriented design, but can also be considered as an architectural principle similar to separation of concerns.</span></span> <span data-ttu-id="f1a16-151">Uvádí, že by měly mít objekty jenom jednu zodpovědnost a že by měly mít jenom jeden důvod, aby se změnila.</span><span class="sxs-lookup"><span data-stu-id="f1a16-151">It states that objects should have only one responsibility and that they should have only one reason to change.</span></span> <span data-ttu-id="f1a16-152">Konkrétně jediná situace, kdy se má objekt změnit, je třeba aktualizovat způsob, jakým má být proveden jeho jedna zodpovědnost.</span><span class="sxs-lookup"><span data-stu-id="f1a16-152">Specifically, the only situation in which the object should change is if the manner in which it performs its one responsibility must be updated.</span></span> <span data-ttu-id="f1a16-153">V rámci tohoto principu je usnadněno vytvoření více volně propojených a modulárních systémů, protože mnoho druhů nového chování může být implementováno jako nové třídy, nikoli přidáním další zodpovědnosti existující třídy.</span><span class="sxs-lookup"><span data-stu-id="f1a16-153">Following this principle helps to produce more loosely coupled and modular systems, since many kinds of new behavior can be implemented as new classes, rather than by adding additional responsibility to existing classes.</span></span> <span data-ttu-id="f1a16-154">Přidávání nových tříd je vždy bezpečnější než změna stávajících tříd, protože žádný kód ještě nezávisí na nových třídách.</span><span class="sxs-lookup"><span data-stu-id="f1a16-154">Adding new classes is always safer than changing existing classes, since no code yet depends on the new classes.</span></span>

<span data-ttu-id="f1a16-155">V aplikaci monolitické můžeme uplatnit zásadu jedné zodpovědnosti na vysokou úroveň na vrstvy v aplikaci.</span><span class="sxs-lookup"><span data-stu-id="f1a16-155">In a monolithic application, we can apply the single responsibility principle at a high level to the layers in the application.</span></span> <span data-ttu-id="f1a16-156">Odpovědnost za prezentaci by měla zůstat v projektu uživatelského rozhraní, zatímco odpovědnost za přístup k datům by měla být zachována v rámci projektu infrastruktury.</span><span class="sxs-lookup"><span data-stu-id="f1a16-156">Presentation responsibility should remain in the UI project, while data access responsibility should be kept within an infrastructure project.</span></span> <span data-ttu-id="f1a16-157">Obchodní logika by měla být zachována v projektu základního aplikace, kde ji lze snadno otestovat a lze ji vyvíjet nezávisle na jiných odpovědnostech.</span><span class="sxs-lookup"><span data-stu-id="f1a16-157">Business logic should be kept in the application core project, where it can be easily tested and can evolve independently from other responsibilities.</span></span>

<span data-ttu-id="f1a16-158">Pokud se tento princip aplikuje na architekturu aplikace a převezme se na jeho logický koncový bod, získáte mikroslužby.</span><span class="sxs-lookup"><span data-stu-id="f1a16-158">When this principle is applied to application architecture and taken to its logical endpoint, you get microservices.</span></span> <span data-ttu-id="f1a16-159">Daná mikroslužba by měla mít jednu zodpovědnost.</span><span class="sxs-lookup"><span data-stu-id="f1a16-159">A given microservice should have a single responsibility.</span></span> <span data-ttu-id="f1a16-160">Pokud potřebujete rozšířit chování systému, je obvykle lepší to udělat přidáním dalších mikroslužeb, nikoli přidáním zodpovědnosti do existující.</span><span class="sxs-lookup"><span data-stu-id="f1a16-160">If you need to extend the behavior of a system, it's usually better to do it by adding additional microservices, rather than by adding responsibility to an existing one.</span></span>

[<span data-ttu-id="f1a16-161">Další informace o architektuře mikroslužeb</span><span class="sxs-lookup"><span data-stu-id="f1a16-161">Learn more about microservices architecture</span></span>](https://aka.ms/MicroservicesEbook)

### <a name="dont-repeat-yourself-dry"></a><span data-ttu-id="f1a16-162">Neopakuje se sami (SUCHá)</span><span class="sxs-lookup"><span data-stu-id="f1a16-162">Don't repeat yourself (DRY)</span></span>

<span data-ttu-id="f1a16-163">Aplikace by se neměla zacházet s určením chování týkajícího se konkrétního konceptu na více místech, protože tento postup je často zdrojem chyb.</span><span class="sxs-lookup"><span data-stu-id="f1a16-163">The application should avoid specifying behavior related to a particular concept in multiple places as this practice is a frequent source of errors.</span></span> <span data-ttu-id="f1a16-164">V určitém okamžiku bude změna požadavků vyžadovat změnu tohoto chování.</span><span class="sxs-lookup"><span data-stu-id="f1a16-164">At some point, a change in requirements will require changing this behavior.</span></span> <span data-ttu-id="f1a16-165">Je možné, že se nepodaří aktualizovat aspoň jednu instanci chování a systém se bude chovat nekonzistentně.</span><span class="sxs-lookup"><span data-stu-id="f1a16-165">It's likely that at least one instance of the behavior will fail to be updated, and the system will behave inconsistently.</span></span>

<span data-ttu-id="f1a16-166">Místo duplikace logiky je zapouzdřovat v programovacím konstruktoru.</span><span class="sxs-lookup"><span data-stu-id="f1a16-166">Rather than duplicating logic, encapsulate it in a programming construct.</span></span> <span data-ttu-id="f1a16-167">Tuto konstrukci udělejte od tohoto chování jediným orgánem a všechny ostatní části aplikace, které vyžadují toto chování, používají novou konstrukci.</span><span class="sxs-lookup"><span data-stu-id="f1a16-167">Make this construct the single authority over this behavior, and have any other part of the application that requires this behavior use the new construct.</span></span>

> [!NOTE]
> <span data-ttu-id="f1a16-168">Vyhněte se vazbě chování, které se provádí pouze při incidentech.</span><span class="sxs-lookup"><span data-stu-id="f1a16-168">Avoid binding together behavior that is only coincidentally repetitive.</span></span> <span data-ttu-id="f1a16-169">Například vzhledem k tomu, že dvě různé konstanty mají stejnou hodnotu, to neznamená, že byste měli mít pouze jednu konstantu, pokud koncepčně odkazuje na různé věci.</span><span class="sxs-lookup"><span data-stu-id="f1a16-169">For example, just because two different constants both have the same value, that doesn't mean you should have only one constant, if conceptually they're referring to different things.</span></span>

### <a name="persistence-ignorance"></a><span data-ttu-id="f1a16-170">Ignorování trvalosti</span><span class="sxs-lookup"><span data-stu-id="f1a16-170">Persistence ignorance</span></span>

<span data-ttu-id="f1a16-171">**Ignorování trvalosti** (pi) odkazuje na typy, které je nutné zachovat, ale jejichž kód není ovlivněn volbou technologie trvalosti.</span><span class="sxs-lookup"><span data-stu-id="f1a16-171">**Persistence ignorance** (PI) refers to types that need to be persisted, but whose code is unaffected by the choice of persistence technology.</span></span> <span data-ttu-id="f1a16-172">Tyto typy v rozhraní .NET jsou někdy označovány jako prosté staré objekty CLR (POCOs), protože nejsou nutné dědit z konkrétní základní třídy nebo implementovat konkrétní rozhraní.</span><span class="sxs-lookup"><span data-stu-id="f1a16-172">Such types in .NET are sometimes referred to as Plain Old CLR Objects (POCOs), because they do not need to inherit from a particular base class or implement a particular interface.</span></span> <span data-ttu-id="f1a16-173">Ignorování trvalosti je užitečné, protože umožňuje, aby byl stejný obchodní model trvalý více způsoby, a nabízí tak aplikaci větší flexibilitu.</span><span class="sxs-lookup"><span data-stu-id="f1a16-173">Persistence ignorance is valuable because it allows the same business model to be persisted in multiple ways, offering additional flexibility to the application.</span></span> <span data-ttu-id="f1a16-174">Volby trvalosti se můžou v průběhu času měnit, od jedné databázové technologie až po jinou, ale kromě toho, že je aplikace spuštěná (například pomocí Redis Cache nebo Azure Cosmos DB kromě relační databáze), se může vyžadovat i další forma trvalosti.</span><span class="sxs-lookup"><span data-stu-id="f1a16-174">Persistence choices might change over time, from one database technology to another, or additional forms of persistence might be required in addition to whatever the application started with (for example, using a Redis cache or Azure Cosmos DB in addition to a relational database).</span></span>

<span data-ttu-id="f1a16-175">Mezi příklady porušení tohoto principu patří:</span><span class="sxs-lookup"><span data-stu-id="f1a16-175">Some examples of violations of this principle include:</span></span>

- <span data-ttu-id="f1a16-176">Požadovaná základní třída.</span><span class="sxs-lookup"><span data-stu-id="f1a16-176">A required base class.</span></span>

- <span data-ttu-id="f1a16-177">Požadovaná implementace rozhraní.</span><span class="sxs-lookup"><span data-stu-id="f1a16-177">A required interface implementation.</span></span>

- <span data-ttu-id="f1a16-178">Třídy zodpovědné za uložení samotných (například modelu aktivního záznamu).</span><span class="sxs-lookup"><span data-stu-id="f1a16-178">Classes responsible for saving themselves (such as the Active Record pattern).</span></span>

- <span data-ttu-id="f1a16-179">Požadovaný konstruktor bez parametrů.</span><span class="sxs-lookup"><span data-stu-id="f1a16-179">Required parameterless constructor.</span></span>

- <span data-ttu-id="f1a16-180">Vlastnosti vyžadující klíčové slovo Virtual</span><span class="sxs-lookup"><span data-stu-id="f1a16-180">Properties requiring virtual keyword.</span></span>

- <span data-ttu-id="f1a16-181">Požadované atributy trvalého uložení.</span><span class="sxs-lookup"><span data-stu-id="f1a16-181">Persistence-specific required attributes.</span></span>

<span data-ttu-id="f1a16-182">Požadavek, aby třídy měly některé z výše uvedených funkcí nebo chování, přidává propojení mezi typy, které se mají zachovat, a volba technologie trvalosti, díky čemuž je obtížnější v budoucnu přijmout nové strategie přístupu k datům.</span><span class="sxs-lookup"><span data-stu-id="f1a16-182">The requirement that classes have any of the above features or behaviors adds coupling between the types to be persisted and the choice of persistence technology, making it more difficult to adopt new data access strategies in the future.</span></span>

### <a name="bounded-contexts"></a><span data-ttu-id="f1a16-183">Ohraničené kontexty</span><span class="sxs-lookup"><span data-stu-id="f1a16-183">Bounded contexts</span></span>

<span data-ttu-id="f1a16-184">**Ohraničené** kontexty jsou centrálním vzorem v návrhu založeném na doméně.</span><span class="sxs-lookup"><span data-stu-id="f1a16-184">**Bounded contexts** are a central pattern in Domain-Driven Design.</span></span> <span data-ttu-id="f1a16-185">Poskytují způsob, jak vypořádat složitost ve velkých aplikacích nebo organizacích tím, že je rozbalíte do samostatných koncepčních modulů.</span><span class="sxs-lookup"><span data-stu-id="f1a16-185">They provide a way of tackling complexity in large applications or organizations by breaking it up into separate conceptual modules.</span></span> <span data-ttu-id="f1a16-186">Každý koncepční modul pak představuje kontext, který je oddělený od jiných kontextů (proto, vázaný) a může se vyvíjet nezávisle.</span><span class="sxs-lookup"><span data-stu-id="f1a16-186">Each conceptual module then represents a context that is separated from other contexts (hence, bounded), and can evolve independently.</span></span> <span data-ttu-id="f1a16-187">Každý ohraničený kontext by měl být v ideálním případě bezplatný pro výběr jeho vlastních názvů a měl by mít výhradní přístup k vlastnímu úložišti trvalosti.</span><span class="sxs-lookup"><span data-stu-id="f1a16-187">Each bounded context should ideally be free to choose its own names for concepts within it, and should have exclusive access to its own persistence store.</span></span>

<span data-ttu-id="f1a16-188">Minimálně jednotlivé webové aplikace by měly být zaměřené na vlastní ohraničený kontext s vlastním úložištěm trvalého využití pro svůj obchodní model místo sdílení databáze s jinými aplikacemi.</span><span class="sxs-lookup"><span data-stu-id="f1a16-188">At a minimum, individual web applications should strive to be their own bounded context, with their own persistence store for their business model, rather than sharing a database with other applications.</span></span> <span data-ttu-id="f1a16-189">Komunikace mezi ohraničenými kontexty probíhá prostřednictvím programových rozhraní, nikoli přes sdílenou databázi, která umožňuje, aby obchodní logika a události byly provedeny v reakci na změny, které probíhají.</span><span class="sxs-lookup"><span data-stu-id="f1a16-189">Communication between bounded contexts occurs through programmatic interfaces, rather than through a shared database, which allows for business logic and events to take place in response to changes that take place.</span></span> <span data-ttu-id="f1a16-190">Ohraničené kontexty jsou úzce namapovány na mikroslužby, které jsou také ideálním způsobem implementovány jako vlastní jednotlivé ohraničené kontexty.</span><span class="sxs-lookup"><span data-stu-id="f1a16-190">Bounded contexts map closely to microservices, which also are ideally implemented as their own individual bounded contexts.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="f1a16-191">Další zdroje</span><span class="sxs-lookup"><span data-stu-id="f1a16-191">Additional resources</span></span>

- [<span data-ttu-id="f1a16-192">Vzory návrhu JAVA: principy</span><span class="sxs-lookup"><span data-stu-id="f1a16-192">JAVA Design Patterns: Principles</span></span>](https://java-design-patterns.com/principles/)
- [<span data-ttu-id="f1a16-193">Ohraničený kontext</span><span class="sxs-lookup"><span data-stu-id="f1a16-193">Bounded Context</span></span>](https://martinfowler.com/bliki/BoundedContext.html)

>[!div class="step-by-step"]
><span data-ttu-id="f1a16-194">[Předchozí](choose-between-traditional-web-and-single-page-apps.md) 
> [Další](common-web-application-architectures.md)</span><span class="sxs-lookup"><span data-stu-id="f1a16-194">[Previous](choose-between-traditional-web-and-single-page-apps.md)
[Next](common-web-application-architectures.md)</span></span>
