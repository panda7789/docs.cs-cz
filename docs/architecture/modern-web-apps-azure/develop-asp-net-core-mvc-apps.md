---
title: Vývoj aplikací ASP.NET Core MVC
description: Architekt moderní webové aplikace s ASP.NET core a Azure | vývoj ASP.NET core MVC Apps
author: ardalis
ms.author: wiwagn
ms.date: 12/04/2019
ms.openlocfilehash: 3de70af23206b0ae0525541b3d2cb480dc5bb882
ms.sourcegitcommit: e3cbf26d67f7e9286c7108a2752804050762d02d
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 04/09/2020
ms.locfileid: "80987904"
---
# <a name="develop-aspnet-core-mvc-apps"></a><span data-ttu-id="8fb2c-103">Vývoj aplikací ASP.NET Core MVC</span><span class="sxs-lookup"><span data-stu-id="8fb2c-103">Develop ASP.NET Core MVC apps</span></span>

> <span data-ttu-id="8fb2c-104">"Není důležité, aby to bylo napoprvé správně.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-104">"It's not important to get it right the first time.</span></span> <span data-ttu-id="8fb2c-105">Je životně důležité, aby to bylo správné minule."</span><span class="sxs-lookup"><span data-stu-id="8fb2c-105">It's vitally important to get it right the last time."</span></span>  
> <span data-ttu-id="8fb2c-106">_- Andrew Hunt a David Thomas_</span><span class="sxs-lookup"><span data-stu-id="8fb2c-106">_- Andrew Hunt and David Thomas_</span></span>

<span data-ttu-id="8fb2c-107">ASP.NET Core je multiplatformní open source framework pro vytváření moderních webových aplikací optimalizovaných pro cloud.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-107">ASP.NET Core is a cross-platform, open-source framework for building modern cloud-optimized web applications.</span></span> <span data-ttu-id="8fb2c-108">aplikace ASP.NET Core jsou lehké a modulární, s integrovanou podporou vkládání závislostí, což umožňuje větší testovatelnost a udržovatelnost.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-108">ASP.NET Core apps are lightweight and modular, with built-in support for dependency injection, enabling greater testability and maintainability.</span></span> <span data-ttu-id="8fb2c-109">V kombinaci s MVC, který podporuje vytváření moderních webových rozhraní API kromě aplikací založených na zobrazení, ASP.NET Core je výkonný rámec pro vytváření podnikových webových aplikací.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-109">Combined with MVC, which supports building modern web APIs in addition to view-based apps, ASP.NET Core is a powerful framework with which to build enterprise web applications.</span></span>

## <a name="mvc-and-razor-pages"></a><span data-ttu-id="8fb2c-110">MVC a Břitva stránky</span><span class="sxs-lookup"><span data-stu-id="8fb2c-110">MVC and Razor Pages</span></span>

<span data-ttu-id="8fb2c-111">ASP.NET Core MVC nabízí mnoho funkcí, které jsou užitečné pro vytváření webových api a aplikací.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-111">ASP.NET Core MVC offers many features that are useful for building web-based APIs and apps.</span></span> <span data-ttu-id="8fb2c-112">Termín MVC je zkratka pro "Model-View-Controller", vzor uživatelského rozhraní, které rozděluje odpovědnost i odpovědi na požadavky uživatelů do několika částí.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-112">The term MVC stands for "Model-View-Controller", a UI pattern that breaks up the responsibilities of responding to user requests into several parts.</span></span> <span data-ttu-id="8fb2c-113">Kromě sledování tohoto vzoru můžete také implementovat funkce ve svých aplikacích ASP.NET Core jako Razor Pages.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-113">In addition to following this pattern, you can also implement features in your ASP.NET Core apps as Razor Pages.</span></span> <span data-ttu-id="8fb2c-114">Razor Pages jsou integrovány do ASP.NET Core MVC a používají stejné funkce pro směrování, vázání modelu atd. Místo toho, aby samostatné složky a soubory pro řadiče, zobrazení, atd.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-114">Razor Pages are built into ASP.NET Core MVC, and use the same features for routing, model binding, etc. However, instead of having separate folders and files for Controllers, Views, etc. and using attribute-based routing, Razor Pages are placed in a single folder ("/Pages"), route based on their relative location in this folder, and handle requests with handlers instead of controller actions.</span></span>

<span data-ttu-id="8fb2c-115">Když vytvoříte novou ASP.NET základní aplikaci, měli byste mít na mysli plán pro druh aplikace, kterou chcete vytvořit.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-115">When you create a new ASP.NET Core App, you should have a plan in mind for the kind of app you want to build.</span></span> <span data-ttu-id="8fb2c-116">V sadě Visual Studio si vyberete z několika šablon.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-116">In Visual Studio, you'll choose from several templates.</span></span> <span data-ttu-id="8fb2c-117">Tři nejběžnější šablony projektu jsou webové rozhraní API, webová aplikace a webová aplikace (Model-View-Controller).</span><span class="sxs-lookup"><span data-stu-id="8fb2c-117">The three most common project templates are Web API, Web Application, and Web Application (Model-View-Controller).</span></span> <span data-ttu-id="8fb2c-118">I když toto rozhodnutí můžete učinit pouze při prvním vytvoření projektu, není to neodvolatelné rozhodnutí.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-118">Although you can only make this decision when you first create a project, it's not an irrevocable decision.</span></span> <span data-ttu-id="8fb2c-119">Projekt webového rozhraní API používá standardní řadiče model-view-controller – ve výchozím nastavení prostě postrádá zobrazení.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-119">The Web API project uses standard Model-View-Controller controllers – it just lacks Views by default.</span></span> <span data-ttu-id="8fb2c-120">Stejně tak výchozí šablona webové aplikace používá Razor Pages, a proto také postrádá složku Zobrazení.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-120">Likewise, the default Web Application template uses Razor Pages, and so also lacks a Views folder.</span></span> <span data-ttu-id="8fb2c-121">Později můžete do těchto projektů přidat složku Zobrazení, která podporuje chování založené na zobrazení.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-121">You can add a Views folder to these projects later to support view-based behavior.</span></span> <span data-ttu-id="8fb2c-122">Webové rozhraní API a projekty Model-View-Controller ve výchozím nastavení neobsahují složku Stránky, ale můžete ji přidat později pro podporu chování založeného na Razor Pages.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-122">Web API and Model-View-Controller projects don't include a Pages folder by default, but you can add one later to support Razor Pages-based behavior.</span></span> <span data-ttu-id="8fb2c-123">Tyto tři šablony si můžete myslet jako podporu tří různých druhů výchozí interakce s uživatelem: data (webové rozhraní API), založené na stránce a založené na zobrazení.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-123">You can think of these three templates as supporting three different kinds of default user interaction: data (web API), page-based, and view-based.</span></span> <span data-ttu-id="8fb2c-124">Pokud však chcete, můžete některé nebo všechny tyto kombinace kombinovat v rámci jednoho projektu.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-124">However, you can mix and match any or all of these within a single project if you wish.</span></span>

### <a name="why-razor-pages"></a><span data-ttu-id="8fb2c-125">Proč Razor Stránky?</span><span class="sxs-lookup"><span data-stu-id="8fb2c-125">Why Razor Pages?</span></span>

<span data-ttu-id="8fb2c-126">Razor Pages je výchozí přístup pro nové webové aplikace v sadě Visual Studio.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-126">Razor Pages is the default approach for new web applications in Visual Studio.</span></span> <span data-ttu-id="8fb2c-127">Razor Pages nabízí jednodušší způsob vytváření funkcí aplikací založených na stránce, jako jsou formuláře bez SPA.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-127">Razor Pages offers a simpler way of building page-based application features, such as non-SPA forms.</span></span> <span data-ttu-id="8fb2c-128">Pomocí řadičů a zobrazení bylo běžné, že aplikace mají velmi velké řadiče, které pracovaly s mnoha různými závislostmi a zobrazovaly modely a vracely mnoho různých zobrazení.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-128">Using controllers and views, it was common for applications to have very large controllers that worked with many different dependencies and view models and returned many different views.</span></span> <span data-ttu-id="8fb2c-129">To mělo za následek větší složitost a často vedlo k tomu, že řadiče, které účinně nedodržovaly zásady jednotné odpovědnosti nebo zásady otevřených/uzavřených zásad.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-129">This resulted in more complexity and often resulted in controllers that didn’t follow the Single Responsibility Principle or Open/Closed Principles effectively.</span></span> <span data-ttu-id="8fb2c-130">Razor Pages řeší tento problém zapouzdřením logiky na straně serveru pro danou logickou "stránku" ve webové aplikaci se značkami Razor.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-130">Razor Pages addresses this issue by encapsulating the server-side logic for a given logical "page" in a web application with its Razor markup.</span></span> <span data-ttu-id="8fb2c-131">Razor Page, který nemá logiku na straně serveru může jednoduše sestávat ze souboru Razor (například "Index.cshtml").</span><span class="sxs-lookup"><span data-stu-id="8fb2c-131">A Razor Page that has no server-side logic can simply consist of a Razor file (for instance, "Index.cshtml").</span></span> <span data-ttu-id="8fb2c-132">Většina netriviálních stránek Razor však bude mít přidruženou třídu modelu stránky, která je podle konvence pojmenována stejně jako soubor Razor s příponou ".cs" (například "Index.cshtml.cs").</span><span class="sxs-lookup"><span data-stu-id="8fb2c-132">However, most non-trivial Razor Pages will have an associated page model class, which by convention is named the same as the Razor file with a ".cs" extension (for example, "Index.cshtml.cs").</span></span>

<span data-ttu-id="8fb2c-133">Model stránky Razor Page kombinuje odpovědnosti řadiče MVC a modelu zobrazení.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-133">A Razor Page's page model combines the responsibilities of an MVC controller and a viewmodel.</span></span> <span data-ttu-id="8fb2c-134">Namísto zpracování požadavků s metodami akce řadiče, obslužné rutiny modelu stránky jako "OnGet()" jsou provedeny, vykreslování jejich přidružené stránky ve výchozím nastavení.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-134">Instead of handling requests with controller action methods, page model handlers like "OnGet()" are executed, rendering their associated page by default.</span></span> <span data-ttu-id="8fb2c-135">Razor Pages zjednodušuje proces vytváření jednotlivých stránek v aplikaci ASP.NET Core a zároveň poskytuje všechny architektonické funkce ASP.NET Core MVC.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-135">Razor Pages simplifies the process of building individual pages in an ASP.NET Core app, while still providing all the architectural features of ASP.NET Core MVC.</span></span> <span data-ttu-id="8fb2c-136">Jsou dobrou výchozí volbou pro nové funkce založené na stránce.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-136">They're a good default choice for new page-based functionality.</span></span>

### <a name="when-to-use-mvc"></a><span data-ttu-id="8fb2c-137">Kdy použít MVC</span><span class="sxs-lookup"><span data-stu-id="8fb2c-137">When to use MVC</span></span>

<span data-ttu-id="8fb2c-138">Pokud vytváříte webová api, vzor MVC dává větší smysl než pokus o použití stránek Razor Pages.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-138">If you're building web APIs, the MVC pattern makes more sense than trying to use Razor Pages.</span></span> <span data-ttu-id="8fb2c-139">Pokud váš projekt bude pouze vystavit koncové body webového rozhraní API, měli byste v ideálním případě začít ze šablony projektu webového rozhraní API.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-139">If your project will only expose web API endpoints, you should ideally start from the Web API project template.</span></span> <span data-ttu-id="8fb2c-140">V opačném případě je snadné přidat řadiče a přidružené koncové body rozhraní API do libovolné aplikace ASP.NET Core.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-140">Otherwise, it's easy to add controllers and associated API endpoints to any ASP.NET Core app.</span></span> <span data-ttu-id="8fb2c-141">Přístup MVC založený na zobrazení použijte, pokud migrujete existující aplikaci z ASP.NET MVC 5 nebo starší, abyste ASP.NET Core MVC a chcete tak učinit s nejmenším úsilím.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-141">Use the view-based MVC approach if you're migrating an existing application from ASP.NET MVC 5 or earlier to ASP.NET Core MVC and you want to do so with the least amount of effort.</span></span> <span data-ttu-id="8fb2c-142">Jakmile provedete počáteční migraci, můžete vyhodnotit, zda má smysl přijmout Razor Pages pro nové funkce nebo dokonce jako velkoobchodní migraci.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-142">Once you've made the initial migration, you can evaluate whether it makes sense to adopt Razor Pages for new features or even as a wholesale migration.</span></span>

<span data-ttu-id="8fb2c-143">Ať už se rozhodnete vytvořit webovou aplikaci pomocí Razor Pages nebo MVC zobrazení, vaše aplikace bude mít podobný výkon a bude zahrnovat podporu pro vkládání závislostí, filtry, vazby modelu, ověřování a tak dále.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-143">Whether you choose to build your web app using Razor Pages or MVC views, your app will have similar performance and will include support for dependency injection, filters, model binding, validation, and so on.</span></span>

## <a name="mapping-requests-to-responses"></a><span data-ttu-id="8fb2c-144">Mapování požadavků na odpovědi</span><span class="sxs-lookup"><span data-stu-id="8fb2c-144">Mapping requests to responses</span></span>

<span data-ttu-id="8fb2c-145">V srdci aplikace ASP.NET Core mapují příchozí požadavky na odchozí odpovědi.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-145">At its heart, ASP.NET Core apps map incoming requests to outgoing responses.</span></span> <span data-ttu-id="8fb2c-146">Na nízké úrovni se to provádí pomocí middlewaru a jednoduché ASP.NET základní aplikace a mikroslužby mohou být tvořeny výhradně vlastním middlewarem.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-146">At a low level, this is done with middleware, and simple ASP.NET Core apps and microservices may be comprised solely of custom middleware.</span></span> <span data-ttu-id="8fb2c-147">Při použití ASP.NET Core MVC, můžete pracovat na poněkud vyšší úrovni, myšlení, pokud jde o _trasy_, _regulátory_, a _akce_.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-147">When using ASP.NET Core MVC, you can work at a somewhat higher level, thinking in terms of _routes_, _controllers_, and _actions_.</span></span> <span data-ttu-id="8fb2c-148">Každý příchozí požadavek je porovnán s směrovací tabulkou aplikace a pokud je nalezena odpovídající trasa, je volána přidružená metoda akce (patřící k řadiči) pro zpracování požadavku.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-148">Each incoming request is compared with the application's routing table, and if a matching route is found, the associated action method (belonging to a controller) is called to handle the request.</span></span> <span data-ttu-id="8fb2c-149">Pokud není nalezena žádná odpovídající trasa, je volána obslužná rutina chyby (v tomto případě vrácení výsledku NotFound).</span><span class="sxs-lookup"><span data-stu-id="8fb2c-149">If no matching route is found, an error handler (in this case, returning a NotFound result) is called.</span></span>

<span data-ttu-id="8fb2c-150">ASP.NET aplikace Core MVC můžou používat konvenční trasy, trasy atributů nebo obojí.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-150">ASP.NET Core MVC apps can use conventional routes, attribute routes, or both.</span></span> <span data-ttu-id="8fb2c-151">Konvenční trasy jsou definovány v kódu a určují _konvence_ směrování pomocí syntaxe, jako v příkladu níže:</span><span class="sxs-lookup"><span data-stu-id="8fb2c-151">Conventional routes are defined in code, specifying routing _conventions_ using syntax like in the example below:</span></span>

```csharp
app.UseEndpoints(endpoints =>
{
    endpoints.MapControllerRoute(name: "default", pattern: "{controller=Home}/{action=Index}/{id?}");
});
```

<span data-ttu-id="8fb2c-152">V tomto příkladu byla do směrovací tabulky přidána trasa s názvem "výchozí".</span><span class="sxs-lookup"><span data-stu-id="8fb2c-152">In this example, a route named "default" has been added to the routing table.</span></span> <span data-ttu-id="8fb2c-153">Definuje šablonu trasy se zástupnými symboly pro _kontroler_, _akci_a _id_. Řadič a zástupné symboly akce mají výchozí zadané ("Home" a "Index", v uvedeném pořadí) a zástupný symbol id je volitelný (na základě "?" na něj aplikovaný).</span><span class="sxs-lookup"><span data-stu-id="8fb2c-153">It defines a route template with placeholders for _controller_, _action_, and _id_. The controller and action placeholders have default specified ("Home" and "Index", respectively), and the id placeholder is optional (by virtue of a "?" applied to it).</span></span> <span data-ttu-id="8fb2c-154">Konvence definované zde uvádí, že první část požadavku by měla odpovídat názvu řadiče, druhá část akce a pak v případě potřeby třetí část bude představovat id parametr.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-154">The convention defined here states that the first part of a request should correspond to the name of the controller, the second part to the action, and then if necessary a third part will represent an id parameter.</span></span> <span data-ttu-id="8fb2c-155">Konvenční trasy jsou obvykle definovány na jednom místě pro aplikaci, například v Configure metoda ve třídě Startup.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-155">Conventional routes are typically defined in one place for the application, such as in the Configure method in the Startup class.</span></span>

<span data-ttu-id="8fb2c-156">Atribut trasy jsou použity pro řadiče a akce přímo, nikoli určené globálně.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-156">Attribute routes are applied to controllers and actions directly, rather than specified globally.</span></span> <span data-ttu-id="8fb2c-157">To má tu výhodu, že je mnohem více zjistitelné, když se díváte na určitou metodu, ale znamená to, že informace o směrování nejsou uchovávány na jednom místě v aplikaci.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-157">This has the advantage of making them much more discoverable when you're looking at a particular method, but does mean that routing information is not kept in one place in the application.</span></span> <span data-ttu-id="8fb2c-158">Pomocí tras atributů můžete snadno zadat více tras pro danou akci a také kombinovat trasy mezi řadiči a akcemi.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-158">With attribute routes, you can easily specify multiple routes for a given action, as well as combine routes between controllers and actions.</span></span> <span data-ttu-id="8fb2c-159">Příklad:</span><span class="sxs-lookup"><span data-stu-id="8fb2c-159">For example:</span></span>

```csharp
[Route("Home")]
public class HomeController : Controller
{
    [Route("")] // Combines to define the route template "Home"
    [Route("Index")] // Combines to define route template "Home/Index"
    [Route("/")] // Does not combine, defines the route template ""
    public IActionResult Index() {}
}
```

<span data-ttu-id="8fb2c-160">Trasy lze zadat na [HttpGet] a podobné atributy, vyhnout se nutnosti přidat samostatné [Route] atributy.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-160">Routes can be specified on [HttpGet] and similar attributes, avoiding the need to add separate [Route] attributes.</span></span> <span data-ttu-id="8fb2c-161">Trasy atributů mohou také použít tokeny ke snížení potřeby opakovat názvy řadičů nebo akcí, jak je znázorněno níže:</span><span class="sxs-lookup"><span data-stu-id="8fb2c-161">Attribute routes can also use tokens to reduce the need to repeat controller or action names, as shown below:</span></span>

```csharp
[Route("[controller]")]
public class ProductsController : Controller
{
    [Route("")] // Matches 'Products'
    [Route("Index")] // Matches 'Products/Index'
    public IActionResult Index() {}
}
```

<span data-ttu-id="8fb2c-162">Razor Pages nepoužívá směrování atributů.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-162">Razor Pages doesn't use attribute routing.</span></span> <span data-ttu-id="8fb2c-163">Jako součást směrnice `@page` můžete zadat další informace o šabloně trasy pro stránku Razor:</span><span class="sxs-lookup"><span data-stu-id="8fb2c-163">You can specify additional route template information for a Razor Page as part of its `@page` directive:</span></span>

```csharp
@page "{id:int}"
```

<span data-ttu-id="8fb2c-164">V předchozím příkladu by dotyčná stránka odpovídala trase s parametrem celé číslo. `id`</span><span class="sxs-lookup"><span data-stu-id="8fb2c-164">In the previous example, the page in question would match a route with an integer `id` parameter.</span></span> <span data-ttu-id="8fb2c-165">Například stránka *Products.cshtml* umístěná v `/Pages` kořenovém adresáři bude mít tuto trasu:</span><span class="sxs-lookup"><span data-stu-id="8fb2c-165">For example, the *Products.cshtml* page located in the root of `/Pages` would have this route:</span></span>

```csharp
"/Products/123"
```

<span data-ttu-id="8fb2c-166">Jakmile daný požadavek byl spárován s trasou, ale před voláním metody akce, ASP.NET Core MVC provede [vazbu modelu](/aspnet/core/mvc/models/model-binding) a [ověření modelu](/aspnet/core/mvc/models/validation) na požadavek.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-166">Once a given request has been matched to a route, but before the action method is called, ASP.NET Core MVC will perform [model binding](/aspnet/core/mvc/models/model-binding) and [model validation](/aspnet/core/mvc/models/validation) on the request.</span></span> <span data-ttu-id="8fb2c-167">Vazba modelu je zodpovědná za převod příchozích dat HTTP na typy .NET zadané jako parametry metody akce, která má být volána.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-167">Model binding is responsible for converting incoming HTTP data into the .NET types specified as parameters of the action method to be called.</span></span> <span data-ttu-id="8fb2c-168">Například pokud metoda akce očekává parametr int id, vazba modelu se pokusí poskytnout tento parametr z hodnoty poskytnuté jako součást požadavku.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-168">For example, if the action method expects an int id parameter, model binding will attempt to provide this parameter from a value provided as part of the request.</span></span> <span data-ttu-id="8fb2c-169">Chcete-li tak učinit, vazba modelu hledá hodnoty v zaúčtovaném formuláři, hodnoty v samotném postupu a hodnoty řetězce dotazu.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-169">To do so, model binding looks for values in a posted form, values in the route itself, and query string values.</span></span> <span data-ttu-id="8fb2c-170">Za předpokladu, že je nalezena hodnota id, bude před předáním do metody akce převedena na celé číslo.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-170">Assuming an id value is found, it will be converted to an integer before being passed into the action method.</span></span>

<span data-ttu-id="8fb2c-171">Po vazbě modelu, ale před voláním metody akce dojde k ověření modelu.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-171">After binding the model but before calling the action method, model validation occurs.</span></span> <span data-ttu-id="8fb2c-172">Ověření modelu používá volitelné atributy pro typ modelu a může pomoci zajistit, aby zadaný objekt modelu splňoval určité požadavky na data.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-172">Model validation uses optional attributes on the model type, and can help ensure that the provided model object conforms to certain data requirements.</span></span> <span data-ttu-id="8fb2c-173">Některé hodnoty mohou být specifikovány podle potřeby nebo omezeny na určitou délku nebo číselný rozsah atd. Pokud jsou zadány atributy ověření, ale model nesplňuje jejich požadavky, vlastnost ModelState.IsValid bude false a sada selhání ověřovací pravidla budou k dispozici k odeslání klientovi, který žádost.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-173">Certain values may be specified as required, or limited to a certain length or numeric range, etc. If validation attributes are specified but the model does not conform to their requirements, the property ModelState.IsValid will be false, and the set of failing validation rules will be available to send to the client making the request.</span></span>

<span data-ttu-id="8fb2c-174">Pokud používáte ověření modelu, měli byste vždy zkontrolovat, zda je model platný před provedením jakýchkoli příkazů pro změnu stavu, abyste zajistili, že vaše aplikace není poškozena neplatnými daty.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-174">If you're using model validation, you should be sure to always check that the model is valid before performing any state-altering commands, to ensure your app is not corrupted by invalid data.</span></span> <span data-ttu-id="8fb2c-175">Můžete použít [filtr,](/aspnet/core/mvc/controllers/filters) aby se zabránilo nutnosti přidat kód pro tuto akci.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-175">You can use a [filter](/aspnet/core/mvc/controllers/filters) to avoid the need to add code for this in every action.</span></span> <span data-ttu-id="8fb2c-176">ASP.NET core MVC filtry nabízejí způsob, jak zachytit skupiny žádostí, takže společné politiky a průřezové obavy mohou být použity na cílené bázi.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-176">ASP.NET Core MVC filters offer a way of intercepting groups of requests, so that common policies and cross-cutting concerns can be applied on a targeted basis.</span></span> <span data-ttu-id="8fb2c-177">Filtry lze použít pro jednotlivé akce, celé řadiče nebo globálně pro aplikaci.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-177">Filters can be applied to individual actions, whole controllers, or globally for an application.</span></span>

<span data-ttu-id="8fb2c-178">Pro webová api ASP.NET Core MVC podporuje [_vyjednávání obsahu_](/aspnet/core/mvc/models/formatting), což umožňuje požadavkům určit, jak mají být odpovědi formátovány.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-178">For web APIs, ASP.NET Core MVC supports [_content negotiation_](/aspnet/core/mvc/models/formatting), allowing requests to specify how responses should be formatted.</span></span> <span data-ttu-id="8fb2c-179">Na základě záhlaví uvedených v požadavku budou akce vracející data formátovat odpověď ve formátu XML, JSON nebo jiném podporovaném formátu.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-179">Based on headers provided in the request, actions returning data will format the response in XML, JSON, or another supported format.</span></span> <span data-ttu-id="8fb2c-180">Tato funkce umožňuje stejné rozhraní API používat více klientů s různými požadavky na formát dat.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-180">This feature enables the same API to be used by multiple clients with different data format requirements.</span></span>

<span data-ttu-id="8fb2c-181">Projekty webového rozhraní `[ApiController]` API by měly zvážit použití atributu, který lze použít pro jednotlivé řadiče, pro třídu základního řadiče nebo pro celé sestavení.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-181">Web API projects should consider using the `[ApiController]` attribute, which can be applied to individual controllers, to a base controller class, or to the entire assembly.</span></span> <span data-ttu-id="8fb2c-182">Tento atribut přidá automatickou kontrolu ověření modelu a všechny akce s neplatným modelem vrátí BadRequest s podrobnostmi o chybách ověření.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-182">This attribute adds automatic model validation checking and any action with an invalid model will return a BadRequest with the details of the validation errors.</span></span> <span data-ttu-id="8fb2c-183">Atribut také vyžaduje, aby všechny akce mají trasu atributu, nikoli pomocí konvenční trasy a vrátí podrobnější ProblemDetails informace v reakci na chyby.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-183">The attribute also requires all actions have an attribute route, rather than using a conventional route, and returns more detailed ProblemDetails information in response to errors.</span></span>

> ### <a name="references--mapping-requests-to-responses"></a><span data-ttu-id="8fb2c-184">Odkazy – mapování požadavků na odpovědi</span><span class="sxs-lookup"><span data-stu-id="8fb2c-184">References – Mapping Requests to Responses</span></span>
>
> - <span data-ttu-id="8fb2c-185">**Směrování k akcím řadiče**
 > <https://docs.microsoft.com/aspnet/core/mvc/controllers/routing></span><span class="sxs-lookup"><span data-stu-id="8fb2c-185">**Routing to Controller Actions**
<https://docs.microsoft.com/aspnet/core/mvc/controllers/routing></span></span>
> - <span data-ttu-id="8fb2c-186">**Vazba modelu**
 > <https://docs.microsoft.com/aspnet/core/mvc/models/model-binding></span><span class="sxs-lookup"><span data-stu-id="8fb2c-186">**Model Binding**
<https://docs.microsoft.com/aspnet/core/mvc/models/model-binding></span></span>
> - <span data-ttu-id="8fb2c-187">**Ověření modelu**
 > <https://docs.microsoft.com/aspnet/core/mvc/models/validation></span><span class="sxs-lookup"><span data-stu-id="8fb2c-187">**Model Validation**
<https://docs.microsoft.com/aspnet/core/mvc/models/validation></span></span>
> - <span data-ttu-id="8fb2c-188">**Filtry**
 > <https://docs.microsoft.com/aspnet/core/mvc/controllers/filters></span><span class="sxs-lookup"><span data-stu-id="8fb2c-188">**Filters**
<https://docs.microsoft.com/aspnet/core/mvc/controllers/filters></span></span>
> - <span data-ttu-id="8fb2c-189">**Atribut ApiController**
 > <https://docs.microsoft.com/aspnet/core/web-api/></span><span class="sxs-lookup"><span data-stu-id="8fb2c-189">**ApiController Attribute**
<https://docs.microsoft.com/aspnet/core/web-api/></span></span>

## <a name="working-with-dependencies"></a><span data-ttu-id="8fb2c-190">Práce se závislostmi</span><span class="sxs-lookup"><span data-stu-id="8fb2c-190">Working with dependencies</span></span>

<span data-ttu-id="8fb2c-191">ASP.NET Core má vestavěnou podporu a interně využívá techniku známou jako [vkládání závislostí](/aspnet/core/fundamentals/dependency-injection).</span><span class="sxs-lookup"><span data-stu-id="8fb2c-191">ASP.NET Core has built-in support for and internally makes use of a technique known as [dependency injection](/aspnet/core/fundamentals/dependency-injection).</span></span> <span data-ttu-id="8fb2c-192">Vkládání závislostí je technika, která umožňuje volné párování mezi různými částmi aplikace.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-192">Dependency injection is a technique that enables loose coupling between different parts of an application.</span></span> <span data-ttu-id="8fb2c-193">Volnější spojka je žádoucí, protože usnadňuje izolátní částí aplikace, což umožňuje testování nebo výměnu.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-193">Looser coupling is desirable because it makes it easier to isolate parts of the application, allowing for testing or replacement.</span></span> <span data-ttu-id="8fb2c-194">To také dělá méně pravděpodobné, že změna v jedné části aplikace bude mít neočekávaný dopad někde jinde v aplikaci.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-194">It also makes it less likely that a change in one part of the application will have an unexpected impact somewhere else in the application.</span></span> <span data-ttu-id="8fb2c-195">Vkládání závislostí je založeno na principu inverze závislosti a je často klíčem k dosažení principu otevření/uzavření.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-195">Dependency injection is based on the dependency inversion principle, and is often key to achieving the open/closed principle.</span></span> <span data-ttu-id="8fb2c-196">Při vyhodnocování, jak vaše aplikace pracuje s jeho závislosti, dejte si pozor na [statické přilnavý](https://deviq.com/static-cling/) kód vůně, a pamatujte aforismus["nové je lepidlo](https://ardalis.com/new-is-glue)" .</span><span class="sxs-lookup"><span data-stu-id="8fb2c-196">When evaluating how your application works with its dependencies, beware of the [static cling](https://deviq.com/static-cling/) code smell, and remember the aphorism "[new is glue](https://ardalis.com/new-is-glue)."</span></span>

<span data-ttu-id="8fb2c-197">Statické přilnutí dochází při vaše třídy volat statické metody nebo přístup ke statickým vlastnostem, které mají vedlejší účinky nebo závislosti na infrastruktuře.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-197">Static cling occurs when your classes make calls to static methods, or access static properties, which have side effects or dependencies on infrastructure.</span></span> <span data-ttu-id="8fb2c-198">Například pokud máte metodu, která volá statickou metodu, která zase zapíše do databáze, vaše metoda je pevně spojena s databází.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-198">For example, if you have a method that calls a static method, which in turn writes to a database, your method is tightly coupled to the database.</span></span> <span data-ttu-id="8fb2c-199">Cokoli, co přeruší volání databáze, přeruší vaši metodu.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-199">Anything that breaks that database call will break your method.</span></span> <span data-ttu-id="8fb2c-200">Testování těchto metod je notoricky obtížné, protože tyto testy buď vyžadují komerční zesměšňovat knihovny zesměšňovat statické volání, nebo mohou být testovány pouze s testovací databáze na místě.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-200">Testing such methods is notoriously difficult, since such tests either require commercial mocking libraries to mock the static calls, or can only be tested with a test database in place.</span></span> <span data-ttu-id="8fb2c-201">Statická volání, která nemají žádnou závislost na infrastruktuře, zejména ty, které jsou zcela bezstátní, jsou v pořádku volat a nemají žádný vliv na párování nebo testovatelnost (mimo kód párování na statické volání samotné).</span><span class="sxs-lookup"><span data-stu-id="8fb2c-201">Static calls that don't have any dependence on infrastructure, especially those that are completely stateless, are fine to call and have no impact on coupling or testability (beyond coupling code to the static call itself).</span></span>

<span data-ttu-id="8fb2c-202">Mnoho vývojářů pochopit rizika statické lpět a globální stav, ale bude stále pevně spárovat svůj kód na konkrétní implementace prostřednictvím přímé instance.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-202">Many developers understand the risks of static cling and global state, but will still tightly couple their code to specific implementations through direct instantiation.</span></span> <span data-ttu-id="8fb2c-203">"New is glue" má být připomínkou této spojky, a nikoli `new` obecným odsouzením použití klíčového slova.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-203">"New is glue" is meant to be a reminder of this coupling, and not a general condemnation of the use of the `new` keyword.</span></span> <span data-ttu-id="8fb2c-204">Stejně jako u volání statické metody, nové instance typů, které nemají žádné externí závislosti obvykle nejsou pevně pár kód implementace podrobnosti nebo ztížit testování.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-204">Just as with static method calls, new instances of types that have no external dependencies typically do not tightly couple code to implementation details or make testing more difficult.</span></span> <span data-ttu-id="8fb2c-205">Ale pokaždé, když je vytvořena instance třídy, trvat jen krátkou chvíli, aby zvážila, zda má smysl, aby pevný kód, že konkrétní instance v tomto konkrétním umístění, nebo pokud by bylo lepší návrh požadovat, aby instance jako závislost.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-205">But each time a class is instantiated, take just a brief moment to consider whether it makes sense to hard-code that specific instance in that particular location, or if it would be a better design to request that instance as a dependency.</span></span>

### <a name="declare-your-dependencies"></a><span data-ttu-id="8fb2c-206">Deklarovat své závislosti</span><span class="sxs-lookup"><span data-stu-id="8fb2c-206">Declare your dependencies</span></span>

<span data-ttu-id="8fb2c-207">ASP.NET Core je postaven na tom, že metody a třídy deklarují své závislosti a požadují je jako argumenty.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-207">ASP.NET Core is built around having methods and classes declare their dependencies, requesting them as arguments.</span></span> <span data-ttu-id="8fb2c-208">ASP.NET aplikace jsou obvykle nastaveny ve třídě Startup, která je sama nakonfigurována tak, aby podporovala vkládání závislostí na několika místech.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-208">ASP.NET applications are typically set up in a Startup class, which itself is configured to support dependency injection at several points.</span></span> <span data-ttu-id="8fb2c-209">Pokud vaše startupová třída má konstruktor, může prostřednictvím konstruktoru požadovat závislosti, například takto:</span><span class="sxs-lookup"><span data-stu-id="8fb2c-209">If your Startup class has a constructor, it can request dependencies through the constructor, like so:</span></span>

```csharp
public class Startup
{
    public Startup(IHostingEnvironment env)
    {
        var builder = new ConfigurationBuilder()
            .SetBasePath(env.ContentRootPath)
            .AddJsonFile("appsettings.json", optional: false, reloadOnChange: true)
            .AddJsonFile($"appsettings.{env.EnvironmentName}.json", optional: true);
    }
}
```

<span data-ttu-id="8fb2c-210">Startup třída je zajímavé v tom, že neexistují žádné požadavky explicitní typ pro něj.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-210">The Startup class is interesting in that there are no explicit type requirements for it.</span></span> <span data-ttu-id="8fb2c-211">Nedědí ze speciální základní třídy při spuštění, ani neimplementuje žádné konkrétní rozhraní.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-211">It doesn't inherit from a special Startup base class, nor does it implement any particular interface.</span></span> <span data-ttu-id="8fb2c-212">Můžete mu dát konstruktor, nebo ne, a můžete zadat tolik parametrů na konstruktoru, jak chcete.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-212">You can give it a constructor, or not, and you can specify as many parameters on the constructor as you want.</span></span> <span data-ttu-id="8fb2c-213">Po spuštění webového hostitele, který jste nakonfigurovali pro vaši aplikaci, bude volat třídu Startup, kterou jste mu řekli, aby používala, a použije vkládání závislostí k naplnění všech závislostí, které třída Po spuštění vyžaduje.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-213">When the web host you've configured for your application starts, it will call the Startup class you've told it to use, and will use dependency injection to populate any dependencies the Startup class requires.</span></span> <span data-ttu-id="8fb2c-214">Samozřejmě pokud požadujete parametry, které nejsou nakonfigurovány v kontejneru služeb používaném ASP.NET Core, dostanete výjimku, ale pokud se budete držet závislostí, o kterých kontejner ví, můžete požádat o cokoliv chcete.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-214">Of course, if you request parameters that aren't configured in the services container used by ASP.NET Core, you'll get an exception, but as long as you stick to dependencies the container knows about, you can request anything you want.</span></span>

<span data-ttu-id="8fb2c-215">Vkládání závislostí je integrovándo ASP.NET základní aplikace hned od začátku, když vytvoříte instanci po spuštění.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-215">Dependency injection is built into your ASP.NET Core apps right from the start, when you create the Startup instance.</span></span> <span data-ttu-id="8fb2c-216">To nekončí, že pro spuštění třídy.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-216">It doesn't stop there for the Startup class.</span></span> <span data-ttu-id="8fb2c-217">Můžete také požádat o závislosti v configure metoda:</span><span class="sxs-lookup"><span data-stu-id="8fb2c-217">You can also request dependencies in the Configure method:</span></span>

```csharp
public void Configure(IApplicationBuilder app,
    IHostingEnvironment env,
    ILoggerFactory loggerFactory)
{

}
```

<span data-ttu-id="8fb2c-218">ConfigureServices Metoda je výjimka z tohoto chování; musí trvat pouze jeden parametr typu IServiceCollection.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-218">The ConfigureServices method is the exception to this behavior; it must take just one parameter of type IServiceCollection.</span></span> <span data-ttu-id="8fb2c-219">Není opravdu nutné podporovat vkládání závislostí, protože na jedné straně je zodpovědný za přidání objektů do kontejneru služeb a na druhé straně má přístup ke všem aktuálně nakonfigurovaných služeb prostřednictvím iServiceCollection parametr.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-219">It doesn't really need to support dependency injection, since on the one hand it is responsible for adding objects to the services container, and on the other it has access to all currently configured services via the IServiceCollection parameter.</span></span> <span data-ttu-id="8fb2c-220">Proto můžete pracovat se závislostmi definovanými v kolekci služeb ASP.NET Core v každé části třídy Startup, a to buď vyžádáním potřebné služby jako parametru, nebo prací s IServiceCollection v ConfigureServices.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-220">Thus, you can work with dependencies defined in the ASP.NET Core services collection in every part of the Startup class, either by requesting the needed service as a parameter or by working with the IServiceCollection in ConfigureServices.</span></span>

> [!NOTE]
> <span data-ttu-id="8fb2c-221">Pokud potřebujete zajistit, aby určité služby byly k dispozici pro vaši třídu Startup, můžete je nakonfigurovat pomocí IWebHostBuilder a jeho metody ConfigureServices uvnitř volání CreateDefaultBuilder.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-221">If you need to ensure certain services are available to your Startup class, you can configure them using an IWebHostBuilder and its ConfigureServices method inside the CreateDefaultBuilder call.</span></span>

<span data-ttu-id="8fb2c-222">Třída Startup je model pro strukturu jiných částí aplikace ASP.NET Core, od řadičů přes Middleware až po filtry až po vlastní služby.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-222">The Startup class is a model for how you should structure other parts of your ASP.NET Core application, from Controllers to Middleware to Filters to your own Services.</span></span> <span data-ttu-id="8fb2c-223">V každém případě byste měli dodržovat [explicitdependencies principle](https://deviq.com/explicit-dependencies-principle/), požadující vaše závislosti spíše než jejich přímé vytváření a využití vkládání závislostí v celé aplikaci.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-223">In each case, you should follow the [Explicit Dependencies Principle](https://deviq.com/explicit-dependencies-principle/), requesting your dependencies rather than directly creating them, and leveraging dependency injection throughout your application.</span></span> <span data-ttu-id="8fb2c-224">Dávejte pozor na to, kde a jak přímo konkretizovat implementace, zejména služby a objekty, které pracují s infrastrukturou nebo mají vedlejší účinky.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-224">Be careful of where and how you directly instantiate implementations, especially services and objects that work with infrastructure or have side effects.</span></span> <span data-ttu-id="8fb2c-225">Preferujte práci s abstrakcemi definovanými v jádru aplikace a předávanými jako argumenty pro odkazy na hardcoding na konkrétní typy implementace.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-225">Prefer working with abstractions defined in your application core and passed in as arguments to hardcoding references to specific implementation types.</span></span>

## <a name="structuring-the-application"></a><span data-ttu-id="8fb2c-226">Strukturování aplikace</span><span class="sxs-lookup"><span data-stu-id="8fb2c-226">Structuring the application</span></span>

<span data-ttu-id="8fb2c-227">Monolitické aplikace mají obvykle jeden vstupní bod.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-227">Monolithic applications typically have a single entry point.</span></span> <span data-ttu-id="8fb2c-228">V případě webové aplikace ASP.NET Core bude vstupním bodem webový projekt ASP.NET Core.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-228">In the case of an ASP.NET Core web application, the entry point will be the ASP.NET Core web project.</span></span> <span data-ttu-id="8fb2c-229">To však neznamená, že řešení by se mělo skládat pouze z jednoho projektu.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-229">However, that doesn't mean the solution should consist of just a single project.</span></span> <span data-ttu-id="8fb2c-230">Je užitečné rozdělit aplikaci do různých vrstev, aby bylo možné sledovat oddělení obav.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-230">It's useful to break up the application into different layers in order to follow separation of concerns.</span></span> <span data-ttu-id="8fb2c-231">Po rozdělení do vrstev je užitečné jít nad rámec složek do samostatných projektů, což může pomoci dosáhnout lepšího zapouzdření.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-231">Once broken up into layers, it's helpful to go beyond folders to separate projects, which can help achieve better encapsulation.</span></span> <span data-ttu-id="8fb2c-232">Nejlepší přístup k dosažení těchto cílů s aplikací ASP.NET Core je varianta čisté architektury popsané v kapitole 5.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-232">The best approach to achieve these goals with an ASP.NET Core application is a variation of the Clean Architecture discussed in chapter 5.</span></span> <span data-ttu-id="8fb2c-233">Podle tohoto přístupu bude řešení aplikace se skládá ze samostatných knihoven pro uživatelské ui, infrastruktury a ApplicationCore.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-233">Following this approach, the application's solution will be comprised of separate libraries for the UI, Infrastructure, and ApplicationCore.</span></span>

<span data-ttu-id="8fb2c-234">Kromě těchto projektů jsou zahrnuty také samostatné testovací projekty (testování je popsáno v kapitole 9).</span><span class="sxs-lookup"><span data-stu-id="8fb2c-234">In addition to these projects, separate test projects are included as well (Testing is discussed in Chapter 9).</span></span>

<span data-ttu-id="8fb2c-235">Objektový model aplikace a rozhraní by měly být umístěny v projektu ApplicationCore.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-235">The application's object model and interfaces should be placed in the ApplicationCore project.</span></span> <span data-ttu-id="8fb2c-236">Tento projekt bude mít co nejméně závislostí a ostatní projekty v řešení na něj budou odkazovat.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-236">This project will have as few dependencies as possible, and the other projects in the solution will reference it.</span></span> <span data-ttu-id="8fb2c-237">Obchodní entity, které je třeba zachovat, jsou definovány v projektu ApplicationCore, stejně jako služby, které nejsou přímo závislé na infrastruktuře.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-237">Business entities that need to be persisted are defined in the ApplicationCore project, as are services that do not directly depend on infrastructure.</span></span>

<span data-ttu-id="8fb2c-238">Podrobnosti implementace, například jak se provádí trvalost nebo jak mohou být oznámení odesílána uživateli, jsou uchovávány v projektu Infrastruktura.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-238">Implementation details, such as how persistence is performed or how notifications might be sent to a user, are kept in the Infrastructure project.</span></span> <span data-ttu-id="8fb2c-239">Tento projekt bude odkazovat na balíčky specifické pro implementaci, jako je například core entity framework, ale neměl by vystavit podrobnosti o těchto implementacích mimo projekt.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-239">This project will reference implementation-specific packages such as Entity Framework Core, but should not expose details about these implementations outside of the project.</span></span> <span data-ttu-id="8fb2c-240">Infrastrukturní služby a úložiště by měly implementovat rozhraní, která jsou definována v projektu ApplicationCore, a jeho implementace trvalosti jsou zodpovědné za načítání a ukládání entit definovaných v ApplicationCore.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-240">Infrastructure services and repositories should implement interfaces that are defined in the ApplicationCore project, and its persistence implementations are responsible for retrieving and storing entities defined in ApplicationCore.</span></span>

<span data-ttu-id="8fb2c-241">Projekt ASP.NET základního ui je zodpovědný za všechny obavy o úroveň ui, ale neměl by obsahovat obchodní logiku nebo podrobnosti o infrastruktuře.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-241">The ASP.NET Core UI project is responsible for any UI level concerns, but should not include business logic or infrastructure details.</span></span> <span data-ttu-id="8fb2c-242">Ve skutečnosti v ideálním případě by neměl mít ani závislost na projektu Infrastruktura, což pomůže zajistit, že žádná závislost mezi těmito dvěma projekty není náhodně zavedena.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-242">In fact, ideally it shouldn't even have a dependency on the Infrastructure project, which will help ensure no dependency between the two projects is introduced accidentally.</span></span> <span data-ttu-id="8fb2c-243">Toho lze dosáhnout pomocí kontejneru DI jiného výrobce, jako je Autofac, který umožňuje definovat pravidla DI ve třídách modulu v každém projektu.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-243">This can be achieved using a third-party DI container like Autofac, which allows you to define DI rules in Module classes in each project.</span></span>

<span data-ttu-id="8fb2c-244">Dalším přístupem k oddělení aplikace od podrobností implementace je mít mikroslužby volání aplikace, možná nasazené v jednotlivých kontejnerech Dockeru.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-244">Another approach to decoupling the application from implementation details is to have the application call microservices, perhaps deployed in individual Docker containers.</span></span> <span data-ttu-id="8fb2c-245">To poskytuje ještě větší oddělení obav a oddělení než využití DI mezi dvěma projekty, ale má další složitost.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-245">This provides even greater separation of concerns and decoupling than leveraging DI between two projects, but has additional complexity.</span></span>

### <a name="feature-organization"></a><span data-ttu-id="8fb2c-246">Organizace funkcí</span><span class="sxs-lookup"><span data-stu-id="8fb2c-246">Feature organization</span></span>

<span data-ttu-id="8fb2c-247">Ve výchozím nastavení ASP.NET základní aplikace uspořádat jejich strukturu složek tak, aby zahrnovala řadiče a zobrazení a často ViewModels.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-247">By default, ASP.NET Core applications organize their folder structure to include Controllers and Views, and frequently ViewModels.</span></span> <span data-ttu-id="8fb2c-248">Kód na straně klienta pro podporu těchto struktur na straně serveru je obvykle uložen samostatně ve složce wwwroot.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-248">Client-side code to support these server-side structures is typically stored separately in the wwwroot folder.</span></span> <span data-ttu-id="8fb2c-249">Velké aplikace však mohou narazit na problémy s touto organizací, protože práce na dané funkci často vyžaduje přechod mezi těmito složkami.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-249">However, large applications may encounter problems with this organization, since working on any given feature often requires jumping between these folders.</span></span> <span data-ttu-id="8fb2c-250">To je stále obtížnější, protože počet souborů a podsložek v každé složce roste, což má za následek velké procházení Průzkumníka řešení.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-250">This gets more and more difficult as the number of files and subfolders in each folder grows, resulting in a great deal of scrolling through Solution Explorer.</span></span> <span data-ttu-id="8fb2c-251">Jedním z řešení tohoto problému je uspořádání kódu aplikace podle _funkce_ namísto podle typu souboru.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-251">One solution to this problem is to organize application code by _feature_ instead of by file type.</span></span> <span data-ttu-id="8fb2c-252">Tento organizační styl se obvykle označuje jako složky prvků nebo [řezy prvků](https://docs.microsoft.com/archive/msdn-magazine/2016/september/asp-net-core-feature-slices-for-asp-net-core-mvc) (viz také: [Svislé řezy](https://deviq.com/vertical-slices/)).</span><span class="sxs-lookup"><span data-stu-id="8fb2c-252">This organizational style is typically referred to as feature folders or [feature slices](https://docs.microsoft.com/archive/msdn-magazine/2016/september/asp-net-core-feature-slices-for-asp-net-core-mvc) (see also: [Vertical Slices](https://deviq.com/vertical-slices/)).</span></span>

<span data-ttu-id="8fb2c-253">ASP.NET Core MVC podporuje oblasti pro tento účel.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-253">ASP.NET Core MVC supports Areas for this purpose.</span></span> <span data-ttu-id="8fb2c-254">Pomocí oblastí můžete v každé složce Oblast vytvořit samostatné sady složek Řadiče a zobrazení (stejně jako všechny přidružené modely).</span><span class="sxs-lookup"><span data-stu-id="8fb2c-254">Using areas, you can create separate sets of Controllers and Views folders (as well as any associated models) in each Area folder.</span></span> <span data-ttu-id="8fb2c-255">Obrázek 7-1 znázorňuje ukázkovou strukturu složek pomocí funkce Oblasti.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-255">Figure 7-1 shows an example folder structure, using Areas.</span></span>

![Vzorová oblast organizace](./media/image7-1.png)

<span data-ttu-id="8fb2c-257">**Obrázek 7-1**.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-257">**Figure 7-1**.</span></span> <span data-ttu-id="8fb2c-258">Vzorová oblast organizace</span><span class="sxs-lookup"><span data-stu-id="8fb2c-258">Sample Area Organization</span></span>

<span data-ttu-id="8fb2c-259">Při použití oblastí, musíte použít atributy k dekoraci řadiče s názvem oblasti, do které patří:</span><span class="sxs-lookup"><span data-stu-id="8fb2c-259">When using Areas, you must use attributes to decorate your controllers with the name of the area to which they belong:</span></span>

```csharp
[Area("Catalog")]
public class HomeController
{}
```

<span data-ttu-id="8fb2c-260">K cestám je také třeba přidat podporu oblasti:</span><span class="sxs-lookup"><span data-stu-id="8fb2c-260">You also need to add area support to your routes:</span></span>

```csharp
app.UseEndpoints(endpoints =>
{
    endpoints.MapControllerRoute(name: "areaRoute", pattern: "{area:exists}/{controller=Home}/{action=Index}/{id?}");
    endpoints.MapControllerRoute(name: "default", pattern: "{controller=Home}/{action=Index}/{id?}");
});
```

<span data-ttu-id="8fb2c-261">Kromě integrované podpory pro oblasti můžete také použít vlastní strukturu složek a konvence namísto atributů a vlastních tras.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-261">In addition to the built-in support for Areas, you can also use your own folder structure, and conventions in place of attributes and custom routes.</span></span> <span data-ttu-id="8fb2c-262">To by vám umožnilo mít složky funkcí, které neobsahovaly samostatné složky pro zobrazení, řadiče atd., aby hierarchie byla plošší a usnadnila zobrazení všech souvisejících souborů na jednom místě pro každou funkci.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-262">This would allow you to have feature folders that didn't include separate folders for Views, Controllers, etc., keeping the hierarchy flatter and making it easier to see all related files in a single place for each feature.</span></span>

<span data-ttu-id="8fb2c-263">ASP.NET Core používá integrované typy konvencí k řízení jeho chování.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-263">ASP.NET Core uses built-in convention types to control its behavior.</span></span> <span data-ttu-id="8fb2c-264">Tyto konvence můžete upravit nebo nahradit.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-264">You can modify or replace these conventions.</span></span> <span data-ttu-id="8fb2c-265">Můžete například vytvořit konvenci, která automaticky získá název funkce pro daný řadič na základě jeho oboru názvů (který obvykle koreluje se složkou, ve které je řadič umístěn):</span><span class="sxs-lookup"><span data-stu-id="8fb2c-265">For example, you can create a convention that will automatically get the feature name for a given controller based on its namespace (which typically correlates to the folder in which the controller is located):</span></span>

```csharp
public class FeatureConvention : IControllerModelConvention
{
    public void Apply(ControllerModel controller)
    {
        controller.Properties.Add("feature",
        GetFeatureName(controller.ControllerType));
    }

    private string GetFeatureName(TypeInfo controllerType)
    {
        string[] tokens = controllerType.FullName.Split('.');
        if (!tokens.Any(t => t == "Features")) return "";
        string featureName = tokens
        .SkipWhile(t => !t.Equals("features",
        StringComparison.CurrentCultureIgnoreCase))
        .Skip(1)
        .Take(1)
        .FirstOrDefault();
        return featureName;
    }
}
```

<span data-ttu-id="8fb2c-266">Tuto konvenci pak zadáte jako možnost, když přidáte podporu pro MVC do vaší aplikace v ConfigureServices:</span><span class="sxs-lookup"><span data-stu-id="8fb2c-266">You then specify this convention as an option when you add support for MVC to your application in ConfigureServices:</span></span>

```csharp
services.AddMvc(o => o.Conventions.Add(new FeatureConvention()));
```

<span data-ttu-id="8fb2c-267">ASP.NET Core MVC také používá konvence k vyhledání zobrazení.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-267">ASP.NET Core MVC also uses a convention to locate views.</span></span> <span data-ttu-id="8fb2c-268">Můžete přepsat pomocí vlastní konvence tak, aby zobrazení budou umístěny ve složkách funkcí (pomocí názvu funkce poskytované FeatureConvention, výše).</span><span class="sxs-lookup"><span data-stu-id="8fb2c-268">You can override it with a custom convention so that views will be located in your feature folders (using the feature name provided by the FeatureConvention, above).</span></span> <span data-ttu-id="8fb2c-269">Můžete se dozvědět více o tomto přístupu a stáhnout pracovní ukázku z článku Časopisu MSDN, [Funkce řezy pro ASP.NET Core MVC](https://docs.microsoft.com/archive/msdn-magazine/2016/september/asp-net-core-feature-slices-for-asp-net-core-mvc).</span><span class="sxs-lookup"><span data-stu-id="8fb2c-269">You can learn more about this approach and download a working sample from the MSDN Magazine article, [Feature Slices for ASP.NET Core MVC](https://docs.microsoft.com/archive/msdn-magazine/2016/september/asp-net-core-feature-slices-for-asp-net-core-mvc).</span></span>

### <a name="cross-cutting-concerns"></a><span data-ttu-id="8fb2c-270">Související aspekty</span><span class="sxs-lookup"><span data-stu-id="8fb2c-270">Cross-cutting concerns</span></span>

<span data-ttu-id="8fb2c-271">S růstem aplikací je stále důležitější zohlednit průřezové obavy, aby se odstranila duplicita a zachovala konzistence.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-271">As applications grow, it becomes increasingly important to factor out cross-cutting concerns to eliminate duplication and maintain consistency.</span></span> <span data-ttu-id="8fb2c-272">Některé příklady průřezových problémů v ASP.NET základních aplikacích jsou ověřování, pravidla ověřování modelu, ukládání do mezipaměti výstupu a zpracování chyb, i když existuje mnoho dalších.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-272">Some examples of cross-cutting concerns in ASP.NET Core applications are authentication, model validation rules, output caching, and error handling, though there are many others.</span></span> <span data-ttu-id="8fb2c-273">ASP.NET core MVC [filtry](/aspnet/core/mvc/controllers/filters) umožňují spustit kód před nebo po určité kroky v kanálu zpracování požadavků.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-273">ASP.NET Core MVC [filters](/aspnet/core/mvc/controllers/filters) allow you to run code before or after certain steps in the request processing pipeline.</span></span> <span data-ttu-id="8fb2c-274">Například filtr lze spustit před a po vazby modelu, před a po akci nebo před a po výsledku akce.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-274">For instance, a filter can run before and after model binding, before and after an action, or before and after an action's result.</span></span> <span data-ttu-id="8fb2c-275">K řízení přístupu ke zbytku kanálu můžete také použít filtr autorizace.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-275">You can also use an authorization filter to control access to the rest of the pipeline.</span></span> <span data-ttu-id="8fb2c-276">Obrázek 7-2 ukazuje, jak spuštění požadavku toky filtry, pokud jsou nakonfigurovány.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-276">Figures 7-2 shows how request execution flows through filters, if configured.</span></span>

![Požadavek je zpracován prostřednictvím filtrů autorizace, filtrů prostředků, vazby modelu, filtrů akcí, provádění akcí a převodu výsledků akce, filtrů výjimek, filtrů výsledků a spuštění výsledků.](./media/image7-2.png)

<span data-ttu-id="8fb2c-279">**Obrázek 7-2**.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-279">**Figure 7-2**.</span></span> <span data-ttu-id="8fb2c-280">Požádejte o spuštění prostřednictvím filtrů a kanálu požadavků.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-280">Request execution through filters and request pipeline.</span></span>

<span data-ttu-id="8fb2c-281">Filtry jsou obvykle implementovány jako atributy, takže je můžete použít na řadiče nebo akce (nebo dokonce globálně).</span><span class="sxs-lookup"><span data-stu-id="8fb2c-281">Filters are usually implemented as attributes, so you can apply them to controllers or actions (or even globally).</span></span> <span data-ttu-id="8fb2c-282">Při přidání tímto způsobem filtry zadané na úrovni akce přepsat nebo stavět na filtry určené na úrovni řadiče, které samy přepsat globální filtry.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-282">When added in this fashion, filters specified at the action level override or build upon filters specified at the controller level, which themselves override global filters.</span></span> <span data-ttu-id="8fb2c-283">Atribut \[Route\] lze například použít k vytvoření tras mezi řadiči a akcemi.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-283">For example, the \[Route\] attribute can be used to build up routes between controllers and actions.</span></span> <span data-ttu-id="8fb2c-284">Podobně autorizace může být nakonfigurována na úrovni řadiče a poté přepsána jednotlivými akcemi, jak ukazuje následující ukázka:</span><span class="sxs-lookup"><span data-stu-id="8fb2c-284">Likewise, authorization can be configured at the controller level, and then overridden by individual actions, as the following sample demonstrates:</span></span>

```csharp
[Authorize]
public class AccountController : Controller

{
    [AllowAnonymous] // overrides the Authorize attribute
    public async Task<IActionResult> Login() {}
    public async Task<IActionResult> ForgotPassword() {}
}
```

<span data-ttu-id="8fb2c-285">První metoda, Login, používá AllowAnonymous filtr (atribut) přepsat autorizovat filtr nastavit na úrovni řadiče.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-285">The first method, Login, uses the AllowAnonymous filter (attribute) to override the Authorize filter set at the controller level.</span></span> <span data-ttu-id="8fb2c-286">Akce ForgotPassword (a jakákoli jiná akce ve třídě, která nemá atribut AllowAnonymous) bude vyžadovat ověřený požadavek.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-286">The ForgotPassword action (and any other action in the class that doesn't have an AllowAnonymous attribute) will require an authenticated request.</span></span>

<span data-ttu-id="8fb2c-287">Filtry lze použít k odstranění duplicit ve formě běžných zásad zpracování chyb pro rozhraní API.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-287">Filters can be used to eliminate duplication in the form of common error handling policies for APIs.</span></span> <span data-ttu-id="8fb2c-288">Například typické zásady rozhraní API je vrátit NotFound odpověď na požadavky odkazující na klíče, které neexistují, a Odpověď BadRequest, pokud se nezdaří ověření modelu.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-288">For example, a typical API policy is to return a NotFound response to requests referencing keys that do not exist, and a BadRequest response if model validation fails.</span></span> <span data-ttu-id="8fb2c-289">Následující příklad ukazuje tyto dvě zásady v akci:</span><span class="sxs-lookup"><span data-stu-id="8fb2c-289">The following example demonstrates these two policies in action:</span></span>

```csharp
[HttpPut("{id}")]
public async Task<IActionResult> Put(int id, [FromBody]Author author)
{
    if ((await _authorRepository.ListAsync()).All(a => a.Id != id))
    {
        return NotFound(id);
    }
    if (!ModelState.IsValid)
    {
        return BadRequest(ModelState);
    }
    author.Id = id;
    await _authorRepository.UpdateAsync(author);
    return Ok();
}
```

<span data-ttu-id="8fb2c-290">Nedovolte, aby vaše metody akce, aby se stal přeplněný s podmíněným kódem, jako je tento.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-290">Don't allow your action methods to become cluttered with conditional code like this.</span></span> <span data-ttu-id="8fb2c-291">Místo toho přetáhněte zásady do filtrů, které lze použít podle potřeby.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-291">Instead, pull the policies into filters that can be applied on an as-needed basis.</span></span> <span data-ttu-id="8fb2c-292">V tomto příkladu může být kontrola ověření modelu, ke které by mělo dojít při každém odeslání příkazu do rozhraní API, nahrazena následujícím atributem:</span><span class="sxs-lookup"><span data-stu-id="8fb2c-292">In this example, the model validation check, which should occur anytime a command is sent to the API, can be replaced by the following attribute:</span></span>

```csharp
public class ValidateModelAttribute : ActionFilterAttribute
{
    public override void OnActionExecuting(ActionExecutingContext context)
    {
        if (!context.ModelState.IsValid)
        {
            context.Result = new BadRequestObjectResult(context.ModelState);
        }
    }
}
```

<span data-ttu-id="8fb2c-293">Můžete přidat `ValidateModelAttribute` do projektu jako závislost NuGet zahrnutím balíčku [Ardalis.ValidateModel.](https://www.nuget.org/packages/Ardalis.ValidateModel)</span><span class="sxs-lookup"><span data-stu-id="8fb2c-293">You can add the `ValidateModelAttribute` to your project as a NuGet dependency by including the [Ardalis.ValidateModel](https://www.nuget.org/packages/Ardalis.ValidateModel) package.</span></span> <span data-ttu-id="8fb2c-294">Pro api můžete použít `ApiController` atribut k vynucení tohoto chování `ValidateModel` bez nutnosti samostatného filtru.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-294">For APIs, you can use the `ApiController` attribute to enforce this behavior without the need for a separate `ValidateModel` filter.</span></span>

<span data-ttu-id="8fb2c-295">Podobně filtr lze použít ke kontrole, zda existuje záznam a vrátit 404 před provedením akce, což eliminuje potřebu provádět tyto kontroly v akci.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-295">Likewise, a filter can be used to check if a record exists and return a 404 before the action is executed, eliminating the need to perform these checks in the action.</span></span> <span data-ttu-id="8fb2c-296">Jakmile vytáhnete běžné konvence a uspořádáte řešení tak, aby oddělovali kód infrastruktury a obchodní logiku od vašeho ui, měly by být vaše metody akce MVC extrémně tenké:</span><span class="sxs-lookup"><span data-stu-id="8fb2c-296">Once you've pulled out common conventions and organized your solution to separate infrastructure code and business logic from your UI, your MVC action methods should be extremely thin:</span></span>

```csharp
[HttpPut("{id}")]
[ValidateAuthorExists]
public async Task<IActionResult> Put(int id, [FromBody]Author author)
{
    await _authorRepository.UpdateAsync(author);
    return Ok();
}
```

<span data-ttu-id="8fb2c-297">Můžete si přečíst více o implementaci filtrů a stáhnout pracovní ukázku z článku Časopisu MSDN, [Real-World ASP.NET Core MVC filtry](https://docs.microsoft.com/archive/msdn-magazine/2016/august/asp-net-core-real-world-asp-net-core-mvc-filters).</span><span class="sxs-lookup"><span data-stu-id="8fb2c-297">You can read more about implementing filters and download a working sample from the MSDN Magazine article, [Real-World ASP.NET Core MVC Filters](https://docs.microsoft.com/archive/msdn-magazine/2016/august/asp-net-core-real-world-asp-net-core-mvc-filters).</span></span>

> ### <a name="references--structuring-applications"></a><span data-ttu-id="8fb2c-298">Reference – Strukturování aplikací</span><span class="sxs-lookup"><span data-stu-id="8fb2c-298">References – Structuring applications</span></span>
>
> - <span data-ttu-id="8fb2c-299">**Oblasti**</span><span class="sxs-lookup"><span data-stu-id="8fb2c-299">**Areas**</span></span>  
>   <https://docs.microsoft.com/aspnet/core/mvc/controllers/areas>
> - <span data-ttu-id="8fb2c-300">**MSDN Magazine - Funkce plátky pro ASP.NET Jádra MVC**</span><span class="sxs-lookup"><span data-stu-id="8fb2c-300">**MSDN Magazine – Feature Slices for ASP.NET Core MVC**</span></span>  
>   <https://docs.microsoft.com/archive/msdn-magazine/2016/september/asp-net-core-feature-slices-for-asp-net-core-mvc>
> - <span data-ttu-id="8fb2c-301">**Filtry**</span><span class="sxs-lookup"><span data-stu-id="8fb2c-301">**Filters**</span></span>  
>   <https://docs.microsoft.com/aspnet/core/mvc/controllers/filters>
> - <span data-ttu-id="8fb2c-302">**MSDN Magazine - Real World ASP.NET Core MVC filtry**</span><span class="sxs-lookup"><span data-stu-id="8fb2c-302">**MSDN Magazine – Real World ASP.NET Core MVC Filters**</span></span>  
>   <https://docs.microsoft.com/archive/msdn-magazine/2016/august/asp-net-core-real-world-asp-net-core-mvc-filters>

## <a name="security"></a><span data-ttu-id="8fb2c-303">Zabezpečení</span><span class="sxs-lookup"><span data-stu-id="8fb2c-303">Security</span></span>

<span data-ttu-id="8fb2c-304">Zabezpečení webových aplikací je velké téma, s mnoha úvahami.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-304">Securing web applications is a large topic, with many considerations.</span></span> <span data-ttu-id="8fb2c-305">Na nejzákladnější úrovni zabezpečení zahrnuje zajištění, že víte, od koho daný požadavek pochází, a pak zajištění, že žádost má pouze přístup k prostředkům, které by měla.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-305">At its most basic level, security involves ensuring you know who a given request is coming from, and then ensuring that the request only has access to resources it should.</span></span> <span data-ttu-id="8fb2c-306">Ověřování je proces porovnání pověření dodaný s požadavkem na ty v důvěryhodném úložišti dat, chcete-li zjistit, zda požadavek by měl být považován za pocházející ze známé entity.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-306">Authentication is the process of comparing credentials provided with a request to those in a trusted data store, to see if the request should be treated as coming from a known entity.</span></span> <span data-ttu-id="8fb2c-307">Autorizace je proces omezení přístupu k určitým prostředkům na základě identity uživatele.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-307">Authorization is the process of restricting access to certain resources based on user identity.</span></span> <span data-ttu-id="8fb2c-308">Třetím bezpečnostním problémem je ochrana žádostí před odposlechem třetími stranami, pro které byste měli alespoň [zajistit, aby vaše aplikace používala ssl](/aspnet/core/security/enforcing-ssl).</span><span class="sxs-lookup"><span data-stu-id="8fb2c-308">A third security concern is protecting requests from eavesdropping by third parties, for which you should at least [ensure that SSL is used by your application](/aspnet/core/security/enforcing-ssl).</span></span>

### <a name="authentication"></a><span data-ttu-id="8fb2c-309">Authentication</span><span class="sxs-lookup"><span data-stu-id="8fb2c-309">Authentication</span></span>

<span data-ttu-id="8fb2c-310">ASP.NET Core Identity je systém členství, který můžete použít k podpoře funkce přihlášení pro vaši aplikaci.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-310">ASP.NET Core Identity is a membership system you can use to support login functionality for your application.</span></span> <span data-ttu-id="8fb2c-311">Má podporu pro místní uživatelské účty, stejně jako externí podporu poskytovatele přihlášení od poskytovatelů, jako je účet Microsoft, Twitter, Facebook, Google a další.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-311">It has support for local user accounts as well as external login provider support from providers like Microsoft Account, Twitter, Facebook, Google, and more.</span></span> <span data-ttu-id="8fb2c-312">Kromě ASP.NET základní identity může vaše aplikace používat ověřování systému Windows nebo poskytovatele identity jiného výrobce, jako [je Identity Server](https://github.com/IdentityServer/IdentityServer4).</span><span class="sxs-lookup"><span data-stu-id="8fb2c-312">In addition to ASP.NET Core Identity, your application can use windows authentication, or a third-party identity provider like [Identity Server](https://github.com/IdentityServer/IdentityServer4).</span></span>

<span data-ttu-id="8fb2c-313">ASP.NET Základní identita je zahrnuta v nových šablonách projektu, pokud je vybrána možnost Individuální uživatelské účty.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-313">ASP.NET Core Identity is included in new project templates if the Individual User Accounts option is selected.</span></span> <span data-ttu-id="8fb2c-314">Tato šablona obsahuje podporu pro registraci, přihlášení, externí přihlášení, zapomenutá hesla a další funkce.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-314">This template includes support for registration, login, external logins, forgotten passwords, and additional functionality.</span></span>

![Vyberte jednotlivé uživatelské účty, chcete-li mít předkonfigurovanou identitu.](./media/image7-3.png)

<span data-ttu-id="8fb2c-316">**Obrázek 7-3**.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-316">**Figure 7-3**.</span></span> <span data-ttu-id="8fb2c-317">Vyberte jednotlivé uživatelské účty, chcete-li mít identitu předem nakonfigurovanou.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-317">Select Individual User Accounts to have Identity preconfigured.</span></span>

<span data-ttu-id="8fb2c-318">Podpora identit je nakonfigurována při spuštění, a to jak v ConfigureServices, tak v configureservices a configure:</span><span class="sxs-lookup"><span data-stu-id="8fb2c-318">Identity support is configured in Startup, both in ConfigureServices and Configure:</span></span>

```csharp
public void ConfigureServices(IServiceCollection services)
{
    // Add framework services.
    services.AddDbContext<ApplicationDbContext>(options =>
    options.UseSqlServer(Configuration.GetConnectionString("DefaultConnection")));
    services.AddIdentity<ApplicationUser, IdentityRole>()
    .AddEntityFrameworkStores<ApplicationDbContext>()
    .AddDefaultTokenProviders();
    services.AddMvc();
}

public void Configure(IApplicationBuilder app)
{
    app.UseStaticFiles();
    app.UseIdentity();
    app.UseEndpoints(endpoints =>
    {
        endpoints.MapControllerRoute(name: "default", pattern: "{controller=Home}/{action=Index}/{id?}");
    });
}
```

<span data-ttu-id="8fb2c-319">Je důležité, aby UseIdentity se zobrazí před UseMvc v Configure metoda.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-319">It's important that UseIdentity appear before UseMvc in the Configure method.</span></span> <span data-ttu-id="8fb2c-320">Při konfiguraci identity v ConfigureServices, všimnete si volání AddDefaultTokenProviders.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-320">When configuring Identity in ConfigureServices, you'll notice a call to AddDefaultTokenProviders.</span></span> <span data-ttu-id="8fb2c-321">To nemá nic společného s tokeny, které mohou být použity k zabezpečení webové komunikace, ale místo toho odkazuje na poskytovatele, kteří vytvářejí výzvy, které mohou být odeslány uživatelům prostřednictvím SMS nebo e-mailu, aby mohli potvrdit svou identitu.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-321">This has nothing to do with tokens that may be used to secure web communications, but instead refers to providers that create prompts that can be sent to users via SMS or email in order for them to confirm their identity.</span></span>

<span data-ttu-id="8fb2c-322">Další informace o [konfiguraci dvoufaktorového ověřování](/aspnet/core/security/authentication/2fa) a [povolení externích poskytovatelů přihlášení](/aspnet/core/security/authentication/social/) z oficiálních ASP.NET základní dokumenty.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-322">You can learn more about [configuring two-factor authentication](/aspnet/core/security/authentication/2fa) and [enabling external login providers](/aspnet/core/security/authentication/social/) from the official ASP.NET Core docs.</span></span>

### <a name="authorization"></a><span data-ttu-id="8fb2c-323">Autorizace</span><span class="sxs-lookup"><span data-stu-id="8fb2c-323">Authorization</span></span>

<span data-ttu-id="8fb2c-324">Nejjednodušší forma autorizace zahrnuje omezení přístupu k anonymním uživatelům.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-324">The simplest form of authorization involves restricting access to anonymous users.</span></span> <span data-ttu-id="8fb2c-325">Toho lze dosáhnout jednoduše \[použitím\] atributu Authorize na určité řadiče nebo akce.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-325">This can be achieved by simply applying the \[Authorize\] attribute to certain controllers or actions.</span></span> <span data-ttu-id="8fb2c-326">Pokud jsou role používány, atribut lze dále rozšířit omezit přístup k uživatelům, kteří patří do určité role, jak je znázorněno:</span><span class="sxs-lookup"><span data-stu-id="8fb2c-326">If roles are being used, the attribute can be further extended to restrict access to users who belong to certain roles, as shown:</span></span>

```csharp
[Authorize(Roles = "HRManager,Finance")]
public class SalaryController : Controller
{

}
```

<span data-ttu-id="8fb2c-327">V tomto případě by uživatelé, kteří patří do role HRManager nebo Finance (nebo obojí), měli přístup k SalaryController.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-327">In this case, users belonging to either the HRManager or Finance roles (or both) would have access to the SalaryController.</span></span> <span data-ttu-id="8fb2c-328">Chcete-li vyžadovat, aby uživatel patřil do více rolí (nikoli pouze do jedné z několika), můžete atribut použít vícekrát a pokaždé zadat požadovanou roli.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-328">To require that a user belong to multiple roles (not just one of several), you can apply the attribute multiple times, specifying a required role each time.</span></span>

<span data-ttu-id="8fb2c-329">Určení určitých sad rolí jako řetězců v mnoha různých řadičích a akcích může vést k nežádoucímu opakování.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-329">Specifying certain sets of roles as strings in many different controllers and actions can lead to undesirable repetition.</span></span> <span data-ttu-id="8fb2c-330">Můžete nakonfigurovat zásady autorizace, které zapouzdřují autorizační pravidla, a při použití atributu \[Authorize\] určit zásady namísto jednotlivých rolí:</span><span class="sxs-lookup"><span data-stu-id="8fb2c-330">You can configure authorization policies, which encapsulate authorization rules, and then specify the policy instead of individual roles when applying the \[Authorize\] attribute:</span></span>

```csharp
[Authorize(Policy = "CanViewPrivateReport")]
public IActionResult ExecutiveSalaryReport()
{
    return View();
}
```

<span data-ttu-id="8fb2c-331">Pomocí zásad tímto způsobem můžete oddělit druhy akcí, které jsou omezeny, od konkrétních rolí nebo pravidel, která se na ně vztahují.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-331">Using policies in this way, you can separate the kinds of actions being restricted from the specific roles or rules that apply to it.</span></span> <span data-ttu-id="8fb2c-332">Později pokud vytvoříte novou roli, která potřebuje mít přístup k určitým prostředkům, můžete pouze \[aktualizovat\] zásady, spíše než aktualizovat každý seznam rolí na každém atributu Authorize.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-332">Later, if you create a new role that needs to have access to certain resources, you can just update a policy, rather than updating every list of roles on every \[Authorize\] attribute.</span></span>

#### <a name="claims"></a><span data-ttu-id="8fb2c-333">Deklarace identity</span><span class="sxs-lookup"><span data-stu-id="8fb2c-333">Claims</span></span>

<span data-ttu-id="8fb2c-334">Deklarace jsou dvojice hodnot názvů, které představují vlastnosti ověřeného uživatele.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-334">Claims are name value pairs that represent properties of an authenticated user.</span></span> <span data-ttu-id="8fb2c-335">Můžete například uložit číslo zaměstnance uživatele jako deklaraci.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-335">For example, you might store users' employee number as a claim.</span></span> <span data-ttu-id="8fb2c-336">Deklarace identity pak lze použít jako součást zásad autorizace.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-336">Claims can then be used as part of authorization policies.</span></span> <span data-ttu-id="8fb2c-337">Můžete vytvořit zásadu s názvem "EmployeeOnly", která vyžaduje existenci deklarace s názvem "EmployeeNumber", jak je znázorněno v tomto příkladu:</span><span class="sxs-lookup"><span data-stu-id="8fb2c-337">You could create a policy called "EmployeeOnly" that requires the existence of a claim called "EmployeeNumber", as shown in this example:</span></span>

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddMvc();
    services.AddAuthorization(options =>
    {
        options.AddPolicy("EmployeeOnly", policy => policy.RequireClaim("EmployeeNumber"));
    });
}
```

<span data-ttu-id="8fb2c-338">Tato zásada by pak \[\] mohla být použita s atributem Authorize k ochraně libovolného řadiče nebo akce, jak je popsáno výše.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-338">This policy could then be used with the \[Authorize\] attribute to protect any controller and/or action, as described above.</span></span>

#### <a name="securing-web-apis"></a><span data-ttu-id="8fb2c-339">Zabezpečení webových api</span><span class="sxs-lookup"><span data-stu-id="8fb2c-339">Securing web APIs</span></span>

<span data-ttu-id="8fb2c-340">Většina webových api by měla implementovat ověřovací systém založený na tokenech.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-340">Most web APIs should implement a token-based authentication system.</span></span> <span data-ttu-id="8fb2c-341">Ověřování tokenů je bezstavové a je navrženo tak, aby bylo škálovatelné.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-341">Token authentication is stateless and designed to be scalable.</span></span> <span data-ttu-id="8fb2c-342">V ověřovacím systému založeném na tokenech musí klient nejprve ověřit u zprostředkovatele ověřování.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-342">In a token-based authentication system, the client must first authenticate with the authentication provider.</span></span> <span data-ttu-id="8fb2c-343">Pokud je úspěšný, je klientovi vydán token, který je jednoduše kryptograficky smysluplný řetězec znaků.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-343">If successful, the client is issued a token, which is simply a cryptographically meaningful string of characters.</span></span> <span data-ttu-id="8fb2c-344">Když klient pak potřebuje vydat požadavek na rozhraní API, přidá tento token jako záhlaví na požadavek.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-344">When the client then needs to issue a request to an API, it adds this token as a header on the request.</span></span> <span data-ttu-id="8fb2c-345">Server pak ověří token nalezený v hlavičce požadavku před dokončením požadavku.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-345">The server then validates the token found in the request header before completing the request.</span></span> <span data-ttu-id="8fb2c-346">Obrázek 7-4 ukazuje tento proces.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-346">Figure 7-4 demonstrates this process.</span></span>

![TokenAuth](./media/image7-4.png)

<span data-ttu-id="8fb2c-348">**Obrázek 7-4.**</span><span class="sxs-lookup"><span data-stu-id="8fb2c-348">**Figure 7-4.**</span></span> <span data-ttu-id="8fb2c-349">Ověřování na základě tokenu pro webová řešení API.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-349">Token-based authentication for Web APIs.</span></span>

<span data-ttu-id="8fb2c-350">Můžete vytvořit vlastní ověřovací službu, integrovat s Azure AD a OAuth nebo implementovat službu pomocí open source nástroje, jako [je IdentityServer](https://github.com/IdentityServer).</span><span class="sxs-lookup"><span data-stu-id="8fb2c-350">You can create your own authentication service, integrate with Azure AD and OAuth, or implement a service using an open-source tool like [IdentityServer](https://github.com/IdentityServer).</span></span>

#### <a name="custom-security"></a><span data-ttu-id="8fb2c-351">Vlastní zabezpečení</span><span class="sxs-lookup"><span data-stu-id="8fb2c-351">Custom Security</span></span>

<span data-ttu-id="8fb2c-352">Buďte obzvláště opatrní při "válcování vlastní" implementace kryptografie, členství uživatele nebo token generování systému.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-352">Be especially careful about "rolling your own" implementation of cryptography, user membership, or token generation system.</span></span> <span data-ttu-id="8fb2c-353">Existuje mnoho komerčních a open-source alternativy k dispozici, které budou téměř jistě mít lepší zabezpečení než vlastní implementace.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-353">There are many commercial and open-source alternatives available, which will almost certainly have better security than a custom implementation.</span></span>

> ### <a name="references--security"></a><span data-ttu-id="8fb2c-354">Reference – zabezpečení</span><span class="sxs-lookup"><span data-stu-id="8fb2c-354">References – Security</span></span>
>
> - <span data-ttu-id="8fb2c-355">**Přehled dokumentů zabezpečení**</span><span class="sxs-lookup"><span data-stu-id="8fb2c-355">**Security Docs Overview**</span></span>  
>   https://docs.microsoft.com/aspnet/core/security/
> - <span data-ttu-id="8fb2c-356">**Vynucení ssl v ASP.NET základní aplikaci**</span><span class="sxs-lookup"><span data-stu-id="8fb2c-356">**Enforcing SSL in an ASP.NET Core App**</span></span>  
>   <https://docs.microsoft.com/aspnet/core/security/enforcing-ssl>
> - <span data-ttu-id="8fb2c-357">**Úvod do systému Identity**</span><span class="sxs-lookup"><span data-stu-id="8fb2c-357">**Introduction to Identity**</span></span>  
>   <https://docs.microsoft.com/aspnet/core/security/authentication/identity>
> - <span data-ttu-id="8fb2c-358">**Úvod do autorizace**</span><span class="sxs-lookup"><span data-stu-id="8fb2c-358">**Introduction to Authorization**</span></span>  
>   <https://docs.microsoft.com/aspnet/core/security/authorization/introduction>
> - <span data-ttu-id="8fb2c-359">**Ověřování a autorizace API Apps ve službě Azure App Service**</span><span class="sxs-lookup"><span data-stu-id="8fb2c-359">**Authentication and Authorization for API Apps in Azure App Service**</span></span>  
>   <https://docs.microsoft.com/azure/app-service-api/app-service-api-authentication>
> - <span data-ttu-id="8fb2c-360">**Server identit**</span><span class="sxs-lookup"><span data-stu-id="8fb2c-360">**Identity Server**</span></span>  
>   <https://github.com/IdentityServer>

## <a name="client-communication"></a><span data-ttu-id="8fb2c-361">Komunikace s klientem</span><span class="sxs-lookup"><span data-stu-id="8fb2c-361">Client communication</span></span>

<span data-ttu-id="8fb2c-362">Kromě zobrazování stránek a odpovídání na požadavky na data prostřednictvím webových api mohou aplikace ASP.NET Core komunikovat přímo s připojenými klienty.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-362">In addition to serving pages and responding to requests for data via web APIs, ASP.NET Core apps can communicate directly with connected clients.</span></span> <span data-ttu-id="8fb2c-363">Tato odchozí komunikace může používat celou řadu dopravních technologií, nejběžnější je WebSockets.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-363">This outbound communication can use a variety of transport technologies, the most common being WebSockets.</span></span> <span data-ttu-id="8fb2c-364">ASP.NET Core SignalR je knihovna, která usnadňuje přidávání funkcí komunikace mezi servery v reálném čase do aplikací.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-364">ASP.NET Core SignalR is a library that makes it simple to add real-time server-to-client communication functionality to your applications.</span></span> <span data-ttu-id="8fb2c-365">SignalR podporuje celou řadu technologií přenosu, včetně WebSockets a abstrahuje mnoho podrobností implementace od vývojáře.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-365">SignalR supports a variety of transport technologies, including WebSockets, and abstracts away many of the implementation details from the developer.</span></span>

<span data-ttu-id="8fb2c-366">Komunikace klienta v reálném čase, ať už pomocí WebSockets přímo nebo jiné techniky, jsou užitečné v různých scénářích aplikace.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-366">Real-time client communication, whether using WebSockets directly or other techniques, are useful in a variety of application scenarios.</span></span> <span data-ttu-id="8fb2c-367">Možné příklady:</span><span class="sxs-lookup"><span data-stu-id="8fb2c-367">Some examples include:</span></span>

- <span data-ttu-id="8fb2c-368">Aplikace živé chatovací místnosti</span><span class="sxs-lookup"><span data-stu-id="8fb2c-368">Live chat room applications</span></span>

- <span data-ttu-id="8fb2c-369">Monitorování aplikací</span><span class="sxs-lookup"><span data-stu-id="8fb2c-369">Monitoring applications</span></span>

- <span data-ttu-id="8fb2c-370">Aktualizace průběhu projektu</span><span class="sxs-lookup"><span data-stu-id="8fb2c-370">Job progress updates</span></span>

- <span data-ttu-id="8fb2c-371">Oznámení</span><span class="sxs-lookup"><span data-stu-id="8fb2c-371">Notifications</span></span>

- <span data-ttu-id="8fb2c-372">Aplikace interaktivních formulářů</span><span class="sxs-lookup"><span data-stu-id="8fb2c-372">Interactive forms applications</span></span>

<span data-ttu-id="8fb2c-373">Při vytváření komunikace klienta do aplikací, obvykle existují dvě součásti:</span><span class="sxs-lookup"><span data-stu-id="8fb2c-373">When building client communication into your applications, there are typically two components:</span></span>

- <span data-ttu-id="8fb2c-374">Správce připojení na straně serveru (hub SignalR, WebSocketManager WebSocketHandler)</span><span class="sxs-lookup"><span data-stu-id="8fb2c-374">Server-side connection manager (SignalR Hub, WebSocketManager WebSocketHandler)</span></span>

- <span data-ttu-id="8fb2c-375">Knihovna na straně klienta</span><span class="sxs-lookup"><span data-stu-id="8fb2c-375">Client-side library</span></span>

<span data-ttu-id="8fb2c-376">Klienti nejsou omezeny na prohlížeče – mobilní aplikace, konzolové aplikace a další nativní aplikace mohou také komunikovat pomocí SignalR/WebSockets.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-376">Clients aren't limited to browsers – mobile apps, console apps, and other native apps can also communicate using SignalR/WebSockets.</span></span> <span data-ttu-id="8fb2c-377">Následující jednoduchý program odráží veškerý obsah odeslaný do chatovací aplikace do konzoly jako součást ukázkové aplikace WebSocketManager:</span><span class="sxs-lookup"><span data-stu-id="8fb2c-377">The following simple program echoes all content sent to a chat application to the console, as part of a WebSocketManager sample application:</span></span>

```csharp
public class Program
{
    private static Connection _connection;
    public static void Main(string[] args)
    {
        StartConnectionAsync();
        _connection.On("receiveMessage", (arguments) =>
        {
            Console.WriteLine($"{arguments[0]} said: {arguments[1]}");
        });
        Console.ReadLine();
        StopConnectionAsync();
    }

    public static async Task StartConnectionAsync()
    {
        _connection = new Connection();
        await _connection.StartConnectionAsync("ws://localhost:65110/chat");
    }

    public static async Task StopConnectionAsync()
    {
        await _connection.StopConnectionAsync();
    }
}
```

<span data-ttu-id="8fb2c-378">Zvažte způsoby, jakými vaše aplikace komunikují přímo s klientskými aplikacemi, a zvažte, zda by komunikace v reálném čase zlepšila uživatelské prostředí vaší aplikace.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-378">Consider ways in which your applications communicate directly with client applications, and consider whether real-time communication would improve your app's user experience.</span></span>

> ### <a name="references--client-communication"></a><span data-ttu-id="8fb2c-379">Reference – komunikace s klientem</span><span class="sxs-lookup"><span data-stu-id="8fb2c-379">References – Client Communication</span></span>
>
> - <span data-ttu-id="8fb2c-380">**ASP.NET Core SignalR**</span><span class="sxs-lookup"><span data-stu-id="8fb2c-380">**ASP.NET Core SignalR**</span></span>  
>   <https://github.com/dotnet/aspnetcore/tree/master/src/SignalR>
> - <span data-ttu-id="8fb2c-381">**Správce websocketů**</span><span class="sxs-lookup"><span data-stu-id="8fb2c-381">**WebSocket Manager**</span></span>  
>   https://github.com/radu-matei/websocket-manager

## <a name="domain-driven-design--should-you-apply-it"></a><span data-ttu-id="8fb2c-382">Návrh řízený doménou – Měli byste jej použít?</span><span class="sxs-lookup"><span data-stu-id="8fb2c-382">Domain-driven design – Should you apply it?</span></span>

<span data-ttu-id="8fb2c-383">Domain-Driven Design (DDD) je agilní přístup k vytváření softwaru, který klade důraz na zaměření na _obchodní doménu_.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-383">Domain-Driven Design (DDD) is an agile approach to building software that emphasizes focusing on the _business domain_.</span></span> <span data-ttu-id="8fb2c-384">Klade velký důraz na komunikaci a interakci s odborníky na obchodní doménu, kteří se mohou vztahovat k vývojářům, jak funguje reálný systém.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-384">It places a heavy emphasis on communication and interaction with business domain expert(s) who can relate to the developers how the real-world system works.</span></span> <span data-ttu-id="8fb2c-385">Pokud například vytváříte systém, který zpracovává obchody s akciemi, může být váš odborník na doménu zkušeným burzovním makléřem.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-385">For example, if you're building a system that handles stock trades, your domain expert might be an experienced stock broker.</span></span> <span data-ttu-id="8fb2c-386">DDD je navržen tak, aby řešit velké, složité obchodní problémy, a často není vhodný pro menší, jednodušší aplikace, jako investice do pochopení a modelování domény nestojí za to.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-386">DDD is designed to address large, complex business problems, and is often not appropriate for smaller, simpler applications, as the investment in understanding and modeling the domain is not worth it.</span></span>

<span data-ttu-id="8fb2c-387">Při vytváření softwaru podle přístupu DDD by váš tým (včetně netechnických zúčastněných stran a přispěvatelů) měl vyvinout _všudypřítomný jazyk_ pro problémový prostor.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-387">When building software following a DDD approach, your team (including non-technical stakeholders and contributors) should develop a _ubiquitous language_ for the problem space.</span></span> <span data-ttu-id="8fb2c-388">To znamená, že stejná terminologie by měla být použita pro koncept reálného světa, který je modelován, ekvivalent softwaru a všechny struktury, které mohou existovat k zachování konceptu (například databázové tabulky).</span><span class="sxs-lookup"><span data-stu-id="8fb2c-388">That is, the same terminology should be used for the real-world concept being modeled, the software equivalent, and any structures that might exist to persist the concept (for example, database tables).</span></span> <span data-ttu-id="8fb2c-389">Proto pojmy popsané v všudypřítomném jazyce by měly tvořit základ pro _model domény_.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-389">Thus, the concepts described in the ubiquitous language should form the basis for your _domain model_.</span></span>

<span data-ttu-id="8fb2c-390">Model domény se skládá z objektů, které vzájemně spolupracují a představují chování systému.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-390">Your domain model is comprised of objects that interact with one another to represent the behavior of the system.</span></span> <span data-ttu-id="8fb2c-391">Tyto objekty mohou spadat do následujících kategorií:</span><span class="sxs-lookup"><span data-stu-id="8fb2c-391">These objects may fall into the following categories:</span></span>

- <span data-ttu-id="8fb2c-392">[Entity](https://deviq.com/entity/), které představují objekty s podprocesem identity.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-392">[Entities](https://deviq.com/entity/), which represent objects with a thread of identity.</span></span> <span data-ttu-id="8fb2c-393">Entity jsou obvykle uloženy v trvalost s klíčem, kterým mohou být později načteny.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-393">Entities are typically stored in persistence with a key by which they can later be retrieved.</span></span>

- <span data-ttu-id="8fb2c-394">[Agregace](https://deviq.com/aggregate-pattern/), které představují skupiny objektů, které by měly být trvalé jako celek.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-394">[Aggregates](https://deviq.com/aggregate-pattern/), which represent groups of objects that should be persisted as a unit.</span></span>

- <span data-ttu-id="8fb2c-395">[Hodnota objekty](https://deviq.com/value-object/), které představují koncepty, které lze porovnat na základě součtu jejich hodnoty vlastností.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-395">[Value objects](https://deviq.com/value-object/), which represent concepts that can be compared on the basis of the sum of their property values.</span></span> <span data-ttu-id="8fb2c-396">Například DateRange skládající se z počátečního a koncového data.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-396">For example, DateRange consisting of a start and end date.</span></span>

- <span data-ttu-id="8fb2c-397">[Události domény](https://martinfowler.com/eaaDev/DomainEvent.html), které představují věci, které se dějí v rámci systému a které jsou zajímavé pro jiné části systému.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-397">[Domain events](https://martinfowler.com/eaaDev/DomainEvent.html), which represent things happening within the system that are of interest to other parts of the system.</span></span>

<span data-ttu-id="8fb2c-398">Model domény DDD by měl zapouzdřit složité chování v rámci modelu.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-398">A DDD domain model should encapsulate complex behavior within the model.</span></span> <span data-ttu-id="8fb2c-399">Entity by zejména neměly být pouze sbírkami vlastností.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-399">Entities, in particular, should not merely be collections of properties.</span></span> <span data-ttu-id="8fb2c-400">Pokud model domény postrádá chování a pouze představuje stav systému, říká se, že je [chudokrevný model](https://deviq.com/anemic-model/), což je nežádoucí v DDD.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-400">When the domain model lacks behavior and merely represents the state of the system, it is said to be an [anemic model](https://deviq.com/anemic-model/), which is undesirable in DDD.</span></span>

<span data-ttu-id="8fb2c-401">Kromě těchto typů modelů DDD obvykle používá různé vzory:</span><span class="sxs-lookup"><span data-stu-id="8fb2c-401">In addition to these model types, DDD typically employs a variety of patterns:</span></span>

- <span data-ttu-id="8fb2c-402">[Úložiště](https://deviq.com/repository-pattern/), pro abstrakce podrobnosti trvalosti.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-402">[Repository](https://deviq.com/repository-pattern/), for abstracting persistence details.</span></span>

- <span data-ttu-id="8fb2c-403">[Factory](https://en.wikipedia.org/wiki/Factory_method_pattern), pro zapouzdření vytvoření složitých objektů.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-403">[Factory](https://en.wikipedia.org/wiki/Factory_method_pattern), for encapsulating complex object creation.</span></span>

- <span data-ttu-id="8fb2c-404">Události domény pro oddělení závislé chování od spouštění chování.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-404">Domain events, for decoupling dependent behavior from triggering behavior.</span></span>

- <span data-ttu-id="8fb2c-405">[služby](http://gorodinski.com/blog/2012/04/14/services-in-domain-driven-design-ddd/), pro zapouzdření podrobností o komplexním chování nebo implementaci infrastruktury.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-405">[Services](http://gorodinski.com/blog/2012/04/14/services-in-domain-driven-design-ddd/), for encapsulating complex behavior and/or infrastructure implementation details.</span></span>

- <span data-ttu-id="8fb2c-406">[příkazu](https://en.wikipedia.org/wiki/Command_pattern)pro oddělení vydávání příkazů a provádění samotného příkazu.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-406">[Command](https://en.wikipedia.org/wiki/Command_pattern), for decoupling issuing commands and executing the command itself.</span></span>

- <span data-ttu-id="8fb2c-407">[Specifikace](https://deviq.com/specification-pattern/), pro zapouzdření podrobností o dotazu.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-407">[Specification](https://deviq.com/specification-pattern/), for encapsulating query details.</span></span>

<span data-ttu-id="8fb2c-408">DDD také doporučuje použití architektury čištění popsané dříve, umožňující volné párování, zapouzdření a kód, který lze snadno ověřit pomocí testování částí.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-408">DDD also recommends the use of the Clean Architecture discussed previously, allowing for loose coupling, encapsulation, and code that can easily be verified using unit tests.</span></span>

### <a name="when-should-you-apply-ddd"></a><span data-ttu-id="8fb2c-409">Kdy byste měli použít DDD</span><span class="sxs-lookup"><span data-stu-id="8fb2c-409">When should you apply DDD</span></span>

<span data-ttu-id="8fb2c-410">DDD je vhodný pro velké aplikace s významnou obchodní (nejen technickou) složitostí.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-410">DDD is well suited to large applications with significant business (not just technical) complexity.</span></span> <span data-ttu-id="8fb2c-411">Aplikace by měla vyžadovat znalosti odborníků na doménu.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-411">The application should require the knowledge of domain experts.</span></span> <span data-ttu-id="8fb2c-412">V samotném modelu domény by mělo být významné chování představující obchodní pravidla a interakce nad rámec pouhého ukládání a načítání aktuálního stavu různých záznamů z úložišť dat.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-412">There should be significant behavior in the domain model itself, representing business rules and interactions beyond simply storing and retrieving the current state of various records from data stores.</span></span>

### <a name="when-shouldnt-you-apply-ddd"></a><span data-ttu-id="8fb2c-413">Kdy byste neměli použít DDD</span><span class="sxs-lookup"><span data-stu-id="8fb2c-413">When shouldn't you apply DDD</span></span>

<span data-ttu-id="8fb2c-414">DDD zahrnuje investice do modelování, architektury a komunikace, které nemusí být oprávněné pro menší aplikace nebo aplikace, které jsou v podstatě jen CRUD (vytvořit / číst / aktualizovat / odstranit).</span><span class="sxs-lookup"><span data-stu-id="8fb2c-414">DDD involves investments in modeling, architecture, and communication that may not be warranted for smaller applications or applications that are essentially just CRUD (create/read/update/delete).</span></span> <span data-ttu-id="8fb2c-415">Pokud se rozhodnete přistupovat k aplikaci po DDD, ale zjistíte, že vaše doména má chudokrevný model bez chování, možná budete muset přehodnotit svůj přístup.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-415">If you choose to approach your application following DDD, but find that your domain has an anemic model with no behavior, you may need to rethink your approach.</span></span> <span data-ttu-id="8fb2c-416">Buď vaše aplikace nemusí potřebovat DDD, nebo budete potřebovat pomoc refaktoring aplikace zapouzdřit obchodní logiku v modelu domény, nikoli v databázi nebo uživatelskérozhraní.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-416">Either your application may not need DDD, or you may need assistance refactoring your application to encapsulate business logic in the domain model, rather than in your database or user interface.</span></span>

<span data-ttu-id="8fb2c-417">Hybridní přístup by bylo použít pouze DDD pro transakční nebo složitější oblasti aplikace, ale ne pro jednodušší CRUD nebo jen pro čtení části aplikace.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-417">A hybrid approach would be to only use DDD for the transactional or more complex areas of the application, but not for simpler CRUD or read-only portions of the application.</span></span> <span data-ttu-id="8fb2c-418">Například nemusíte mít omezení Agregace, pokud dotazujete data k zobrazení sestavy nebo k vizualizaci dat pro řídicí panel.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-418">For instance, you needn't have the constraints of an Aggregate if you're querying data to display a report or to visualize data for a dashboard.</span></span> <span data-ttu-id="8fb2c-419">Je naprosto přijatelné mít samostatný, jednodušší model čtení pro takové požadavky.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-419">It's perfectly acceptable to have a separate, simpler read model for such requirements.</span></span>

> ### <a name="references--domain-driven-design"></a><span data-ttu-id="8fb2c-420">Odkazy – návrh řízený doménou</span><span class="sxs-lookup"><span data-stu-id="8fb2c-420">References – Domain-Driven Design</span></span>
>
> - <span data-ttu-id="8fb2c-421">**DDD v jednoduché angličtině (StackOverflow Odpověď)**</span><span class="sxs-lookup"><span data-stu-id="8fb2c-421">**DDD in Plain English (StackOverflow Answer)**</span></span>  
>   <https://stackoverflow.com/questions/1222392/can-someone-explain-domain-driven-design-ddd-in-plain-english-please/1222488#1222488>

## <a name="deployment"></a><span data-ttu-id="8fb2c-422">Nasazení</span><span class="sxs-lookup"><span data-stu-id="8fb2c-422">Deployment</span></span>

<span data-ttu-id="8fb2c-423">Existuje několik kroků zapojených do procesu nasazení ASP.NET základní aplikace, bez ohledu na to, kde bude hostována.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-423">There are a few steps involved in the process of deploying your ASP.NET Core application, regardless of where it will be hosted.</span></span> <span data-ttu-id="8fb2c-424">Prvním krokem je publikovat aplikaci, kterou lze `dotnet publish` provést pomocí příkazu CLI.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-424">The first step is to publish the application, which can be done using the `dotnet publish` CLI command.</span></span> <span data-ttu-id="8fb2c-425">Tím se zkompiluje aplikace a umístí všechny soubory potřebné ke spuštění aplikace do určené složky.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-425">This will compile the application and place all of the files needed to run the application into a designated folder.</span></span> <span data-ttu-id="8fb2c-426">Při nasazení z visual studia se tento krok provede automaticky.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-426">When you deploy from Visual Studio, this step is performed for you automatically.</span></span> <span data-ttu-id="8fb2c-427">Složka publikování obsahuje soubory EXE a DLL pro aplikaci a její závislosti.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-427">The publish folder contains .exe and .dll files for the application and its dependencies.</span></span> <span data-ttu-id="8fb2c-428">Samostatná aplikace bude také obsahovat verzi běhu .NET.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-428">A self-contained application will also include a version of the .NET runtime.</span></span> <span data-ttu-id="8fb2c-429">ASP.NET základní aplikace budou také obsahovat konfigurační soubory, statické prostředky klienta a zobrazení MVC.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-429">ASP.NET Core applications will also include configuration files, static client assets, and MVC views.</span></span>

<span data-ttu-id="8fb2c-430">ASP.NET Základní aplikace jsou konzolové aplikace, které musí být spuštěny při spuštění a restartování serveru, pokud dojde k chybě aplikace (nebo serveru).</span><span class="sxs-lookup"><span data-stu-id="8fb2c-430">ASP.NET Core applications are console applications that must be started when the server boots and restarted if the application (or server) crashes.</span></span> <span data-ttu-id="8fb2c-431">K automatizaci tohoto procesu lze použít správce procesů.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-431">A process manager can be used to automate this process.</span></span> <span data-ttu-id="8fb2c-432">Nejběžnější procesní manažeři pro ASP.NET Core jsou Nginx a Apache na Linuxu a IIS nebo Windows Service v systému Windows.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-432">The most common process managers for ASP.NET Core are Nginx and Apache on Linux and IIS or Windows Service on Windows.</span></span>

<span data-ttu-id="8fb2c-433">Kromě správce procesů mohou aplikace ASP.NET Core používat reverzní proxy server.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-433">In addition to a process manager, ASP.NET Core applications may use a reverse proxy server.</span></span> <span data-ttu-id="8fb2c-434">Reverzní proxy server přijímá požadavky HTTP z Internetu a předává je Kestrel po nějaké předběžné zpracování.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-434">A reverse proxy server receives HTTP requests from the Internet and forwards them to Kestrel after some preliminary handling.</span></span> <span data-ttu-id="8fb2c-435">Reverzní proxy servery poskytují vrstvu zabezpečení pro aplikaci.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-435">Reverse proxy servers provide a layer of security for the application.</span></span> <span data-ttu-id="8fb2c-436">Kestrel také nepodporuje hostování více aplikací na stejném portu, takže techniky, jako jsou hlavičky hostitele, s ním nelze použít k povolení hostování více aplikací na stejném portu a IP adrese.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-436">Kestrel also doesn't support hosting multiple applications on the same port, so techniques like host headers cannot be used with it to enable hosting multiple applications on the same port and IP address.</span></span>

![Poštolka k internetu](./media/image7-5.png)

<span data-ttu-id="8fb2c-438">**Obrázek 7-5**.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-438">**Figure 7-5**.</span></span> <span data-ttu-id="8fb2c-439">ASP.NET hostované v Kestrelu za reverzním proxy serverem</span><span class="sxs-lookup"><span data-stu-id="8fb2c-439">ASP.NET hosted in Kestrel behind a reverse proxy server</span></span>

<span data-ttu-id="8fb2c-440">Dalším scénářem, ve kterém může být užitečný reverzní proxy server, je zabezpečení více aplikací pomocí protokolu SSL/HTTPS.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-440">Another scenario in which a reverse proxy can be helpful is to secure multiple applications using SSL/HTTPS.</span></span> <span data-ttu-id="8fb2c-441">V takovém případě by pouze reverzní proxy server musel mít nakonfigurovaný SSL.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-441">In this case, only the reverse proxy would need to have SSL configured.</span></span> <span data-ttu-id="8fb2c-442">Komunikace mezi reverzní proxy server a Kestrel by mohla probíhat přes HTTP, jak je znázorněno na obrázku 7-6.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-442">Communication between the reverse proxy server and Kestrel could take place over HTTP, as shown in Figure 7-6.</span></span>

![ASP.NET hostované za serverem reverzního proxy serveru zabezpečeného protokolem HTTPS](./media/image7-6.png)

<span data-ttu-id="8fb2c-444">**Obrázek 7-6**.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-444">**Figure 7-6**.</span></span> <span data-ttu-id="8fb2c-445">ASP.NET hostované za serverem reverzního proxy serveru zabezpečeného protokolem HTTPS</span><span class="sxs-lookup"><span data-stu-id="8fb2c-445">ASP.NET hosted behind an HTTPS-secured reverse proxy server</span></span>

<span data-ttu-id="8fb2c-446">Stále populárnější přístup je hostování aplikace ASP.NET Core v kontejneru Dockeru, který pak může být hostovaný místně nebo nasazený do Azure pro cloudový hosting.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-446">An increasingly popular approach is to host your ASP.NET Core application in a Docker container, which then can be hosted locally or deployed to Azure for cloud-based hosting.</span></span> <span data-ttu-id="8fb2c-447">Kontejner Dockeru může obsahovat kód aplikace, spuštěný na Kestrelu a bude nasazen za reverzní proxy server, jak je znázorněno výše.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-447">The Docker container could contain your application code, running on Kestrel, and would be deployed behind a reverse proxy server, as shown above.</span></span>

<span data-ttu-id="8fb2c-448">Pokud hostujete svou aplikaci v Azure, můžete použít Microsoft Azure Application Gateway jako vyhrazené virtuální zařízení k poskytování několika služeb.</span><span class="sxs-lookup"><span data-stu-id="8fb2c-448">If you're hosting your application on Azure, you can use Microsoft Azure Application Gateway as a dedicated virtual appliance to provide several services.</span></span> <span data-ttu-id="8fb2c-449">Kromě toho, že funguje jako reverzní proxy pro jednotlivé aplikace, aplikace gateway může také nabídnout následující funkce:</span><span class="sxs-lookup"><span data-stu-id="8fb2c-449">In addition to acting as a reverse proxy for individual applications, Application Gateway can also offer the following features:</span></span>

- <span data-ttu-id="8fb2c-450">Http vyrovnávání zatížení</span><span class="sxs-lookup"><span data-stu-id="8fb2c-450">HTTP load balancing</span></span>

- <span data-ttu-id="8fb2c-451">SSL redikace (SSL pouze k Internetu)</span><span class="sxs-lookup"><span data-stu-id="8fb2c-451">SSL offload (SSL only to Internet)</span></span>

- <span data-ttu-id="8fb2c-452">Ssl od konce ke konci</span><span class="sxs-lookup"><span data-stu-id="8fb2c-452">End to End SSL</span></span>

- <span data-ttu-id="8fb2c-453">Směrování na více sítích (konsolidace až 20 sítí na jedné aplikační bráně)</span><span class="sxs-lookup"><span data-stu-id="8fb2c-453">Multi-site routing (consolidate up to 20 sites on a single Application Gateway)</span></span>

- <span data-ttu-id="8fb2c-454">Brána firewall webových aplikací</span><span class="sxs-lookup"><span data-stu-id="8fb2c-454">Web application firewall</span></span>

- <span data-ttu-id="8fb2c-455">Podpora pro Websocket</span><span class="sxs-lookup"><span data-stu-id="8fb2c-455">Websocket support</span></span>

- <span data-ttu-id="8fb2c-456">Pokročilá diagnostika</span><span class="sxs-lookup"><span data-stu-id="8fb2c-456">Advanced diagnostics</span></span>

<span data-ttu-id="8fb2c-457">_Další informace o možnostech nasazení Azure najdete v [kapitole 10](development-process-for-azure.md)._</span><span class="sxs-lookup"><span data-stu-id="8fb2c-457">_Learn more about Azure deployment options in [Chapter 10](development-process-for-azure.md)._</span></span>

> ### <a name="references--deployment"></a><span data-ttu-id="8fb2c-458">Reference – nasazení</span><span class="sxs-lookup"><span data-stu-id="8fb2c-458">References – Deployment</span></span>
>
> - <span data-ttu-id="8fb2c-459">**Přehled hostování a nasazení**</span><span class="sxs-lookup"><span data-stu-id="8fb2c-459">**Hosting and Deployment Overview**</span></span>  
>   <https://docs.microsoft.com/aspnet/core/publishing/>
> - <span data-ttu-id="8fb2c-460">**Kdy použít Kestrel s reverzním proxy serverem**</span><span class="sxs-lookup"><span data-stu-id="8fb2c-460">**When to use Kestrel with a reverse proxy**</span></span>  
>   <https://docs.microsoft.com/aspnet/core/fundamentals/servers/kestrel#when-to-use-kestrel-with-a-reverse-proxy>
> - <span data-ttu-id="8fb2c-461">**Hostování aplikací ASP.NET jádra v Dockeru**</span><span class="sxs-lookup"><span data-stu-id="8fb2c-461">**Host ASP.NET Core apps in Docker**</span></span>  
>   <https://docs.microsoft.com/aspnet/core/publishing/docker>
> - <span data-ttu-id="8fb2c-462">**Představujeme aplikační bránu Azure**</span><span class="sxs-lookup"><span data-stu-id="8fb2c-462">**Introducing Azure Application Gateway**</span></span>  
>   <https://docs.microsoft.com/azure/application-gateway/application-gateway-introduction>

>[!div class="step-by-step"]
><span data-ttu-id="8fb2c-463">[Předchozí](common-client-side-web-technologies.md)
>[další](work-with-data-in-asp-net-core-apps.md)</span><span class="sxs-lookup"><span data-stu-id="8fb2c-463">[Previous](common-client-side-web-technologies.md)
[Next](work-with-data-in-asp-net-core-apps.md)</span></span>
