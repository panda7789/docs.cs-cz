---
title: Běžné architektury webových aplikací
description: Architekt moderních webových aplikací pomocí ASP.NET Core a Azure | Prozkoumat společné architektury webových aplikací
author: ardalis
ms.author: wiwagn
ms.date: 12/04/2019
ms.openlocfilehash: de90db9061d0b7bd15141b277ae4272b5208f76b
ms.sourcegitcommit: b78018c850590dfc0348301e1748b779c28604cc
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 09/02/2020
ms.locfileid: "89379158"
---
# <a name="common-web-application-architectures"></a><span data-ttu-id="4c0cc-103">Běžné architektury webových aplikací</span><span class="sxs-lookup"><span data-stu-id="4c0cc-103">Common web application architectures</span></span>

> <span data-ttu-id="4c0cc-104">"Pokud se domníváte, že dobrá architektura je náročná, vyzkoušejte si chybnou architekturu."</span><span class="sxs-lookup"><span data-stu-id="4c0cc-104">"If you think good architecture is expensive, try bad architecture."</span></span>  
> <span data-ttu-id="4c0cc-105">_– Briana nohou a Josepha Yoder_</span><span class="sxs-lookup"><span data-stu-id="4c0cc-105">_- Brian Foote and Joseph Yoder_</span></span>

<span data-ttu-id="4c0cc-106">Většina tradičních aplikací .NET je nasazena jako samostatné jednotky, které odpovídají spustitelnému souboru nebo jedné webové aplikaci běžící v rámci jedné domény aplikace služby IIS.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-106">Most traditional .NET applications are deployed as single units corresponding to an executable or a single web application running within a single IIS appdomain.</span></span> <span data-ttu-id="4c0cc-107">Toto je nejjednodušší model nasazení a obsluhuje mnoho interních a menších veřejných aplikací.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-107">This is the simplest deployment model and serves many internal and smaller public applications very well.</span></span> <span data-ttu-id="4c0cc-108">I když je však tato jediná jednotka nasazení, většina netriviálních obchodních aplikací má výhodu z některých logických oddělení do několika vrstev.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-108">However, even given this single unit of deployment, most non-trivial business applications benefit from some logical separation into several layers.</span></span>

## <a name="what-is-a-monolithic-application"></a><span data-ttu-id="4c0cc-109">Co je aplikace monolitické?</span><span class="sxs-lookup"><span data-stu-id="4c0cc-109">What is a monolithic application?</span></span>

<span data-ttu-id="4c0cc-110">Aplikace monolitické je zcela samostatná, z pohledu jejího chování.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-110">A monolithic application is one that is entirely self-contained, in terms of its behavior.</span></span> <span data-ttu-id="4c0cc-111">Může komunikovat s jinými službami nebo úložišti dat v průběhu provádění jeho operací, ale jádro jeho chování běží v rámci svého vlastního procesu a celá aplikace je obvykle nasazena jako jediná jednotka.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-111">It may interact with other services or data stores in the course of performing its operations, but the core of its behavior runs within its own process and the entire application is typically deployed as a single unit.</span></span> <span data-ttu-id="4c0cc-112">Pokud taková aplikace potřebuje horizontální horizontální navýšení kapacity, obvykle je celá aplikace duplikována napříč více servery nebo virtuálními počítači.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-112">If such an application needs to scale horizontally, typically the entire application is duplicated across multiple servers or virtual machines.</span></span>

## <a name="all-in-one-applications"></a><span data-ttu-id="4c0cc-113">Všechny aplikace v jednom</span><span class="sxs-lookup"><span data-stu-id="4c0cc-113">All-in-one applications</span></span>

<span data-ttu-id="4c0cc-114">Nejmenší možný počet projektů pro architekturu aplikace je jeden.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-114">The smallest possible number of projects for an application architecture is one.</span></span> <span data-ttu-id="4c0cc-115">V této architektuře je celá logika aplikace obsažena v jednom projektu, zkompilována do jediného sestavení a nasazena jako jedna jednotka.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-115">In this architecture, the entire logic of the application is contained in a single project, compiled to a single assembly, and deployed as a single unit.</span></span>

<span data-ttu-id="4c0cc-116">Nový ASP.NET Core projekt, ať už je vytvořený v aplikaci Visual Studio nebo z příkazového řádku, začíná jako jednoduché monolituy "All-in-One".</span><span class="sxs-lookup"><span data-stu-id="4c0cc-116">A new ASP.NET Core project, whether created in Visual Studio or from the command line, starts out as a simple "all-in-one" monolith.</span></span> <span data-ttu-id="4c0cc-117">Obsahuje všechna chování aplikace, včetně prezentace, obchodu a logiky přístupu k datům.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-117">It contains all of the behavior of the application, including presentation, business, and data access logic.</span></span> <span data-ttu-id="4c0cc-118">Obrázek 5-1 ukazuje strukturu souborů aplikace s jedním projektem.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-118">Figure 5-1 shows the file structure of a single-project app.</span></span>

![Jeden projekt ASP.NET Core aplikaci](./media/image5-1.png)

<span data-ttu-id="4c0cc-120">**Obrázek 5-1.**</span><span class="sxs-lookup"><span data-stu-id="4c0cc-120">**Figure 5-1.**</span></span> <span data-ttu-id="4c0cc-121">Jeden projekt ASP.NET Core aplikaci.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-121">A single project ASP.NET Core app.</span></span>

<span data-ttu-id="4c0cc-122">V případě jednoho projektu je rozdělení obav zajištěno pomocí složek.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-122">In a single project scenario, separation of concerns is achieved through the use of folders.</span></span> <span data-ttu-id="4c0cc-123">Výchozí šablona obsahuje samostatné složky pro zodpovědnost vzorků MVC modelů, zobrazení a řadičů a také další složky pro data a služby.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-123">The default template includes separate folders for MVC pattern responsibilities of Models, Views, and Controllers, as well as additional folders for Data and Services.</span></span> <span data-ttu-id="4c0cc-124">V tomto uspořádání by se měly podrobnosti o prezentaci co nejvíce omezit na složku zobrazení a podrobnosti implementace přístupu k datům by měly být omezené na třídy uchovávané ve složce data.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-124">In this arrangement, presentation details should be limited as much as possible to the Views folder, and data access implementation details should be limited to classes kept in the Data folder.</span></span> <span data-ttu-id="4c0cc-125">Obchodní logika by se měla nacházet v části služby a třídy v rámci složky modely.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-125">Business logic should reside in services and classes within the Models folder.</span></span>

<span data-ttu-id="4c0cc-126">I když je jednoduché řešení monolitické s jedním projektem nějaké nevýhody.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-126">Although simple, the single-project monolithic solution has some disadvantages.</span></span> <span data-ttu-id="4c0cc-127">Jak roste velikost a složitost projektu, počet souborů a složek bude i nadále rostoucí.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-127">As the project's size and complexity grows, the number of files and folders will continue to grow as well.</span></span> <span data-ttu-id="4c0cc-128">Problematika uživatelského rozhraní (modely, zobrazení, řadiče) se nachází ve více složkách, které nejsou seskupeny abecedně.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-128">User interface (UI) concerns (models, views, controllers) reside in multiple folders, which aren't grouped together alphabetically.</span></span> <span data-ttu-id="4c0cc-129">K tomuto problému dochází pouze v případě, že se do vlastních složek přidávají další konstrukce na úrovni uživatelského rozhraní, jako jsou například filtry nebo ModelBinders.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-129">This issue only gets worse when additional UI-level constructs, such as Filters or ModelBinders, are added in their own folders.</span></span> <span data-ttu-id="4c0cc-130">Obchodní logika je rozptýlená mezi složkami modely a služby a neexistuje žádné jasné označení tříd, na kterých by měly složky záviset.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-130">Business logic is scattered between the Models and Services folders, and there's no clear indication of which classes in which folders should depend on which others.</span></span> <span data-ttu-id="4c0cc-131">Tato nedostatečná organizace na úrovni projektu často vede k [Spaghetti kódu](https://deviq.com/spaghetti-code/).</span><span class="sxs-lookup"><span data-stu-id="4c0cc-131">This lack of organization at the project level frequently leads to [spaghetti code](https://deviq.com/spaghetti-code/).</span></span>

<span data-ttu-id="4c0cc-132">Pro vyřešení těchto problémů se aplikace často rozvíjejí do řešení s více projekty, kde každý projekt je považován za umístěný v konkrétní _vrstvě_ aplikace.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-132">To address these issues, applications often evolve into multi-project solutions, where each project is considered to reside in a particular _layer_ of the application.</span></span>

## <a name="what-are-layers"></a><span data-ttu-id="4c0cc-133">Co jsou vrstvy?</span><span class="sxs-lookup"><span data-stu-id="4c0cc-133">What are layers?</span></span>

<span data-ttu-id="4c0cc-134">Vzhledem k tím, že aplikace výrazně roste, je třeba tuto složitost zvládnout tak, že se aplikace rozdělují podle svých povinností nebo obav.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-134">As applications grow in complexity, one way to manage that complexity is to break up the application according to its responsibilities or concerns.</span></span> <span data-ttu-id="4c0cc-135">Postupuje podle oddělení principů a může pomáhat udržet rostoucí základ kódu, aby mohli vývojáři snadno najít, kde jsou určité funkce implementované.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-135">This follows the separation of concerns principle and can help keep a growing codebase organized so that developers can easily find where certain functionality is implemented.</span></span> <span data-ttu-id="4c0cc-136">Vrstvená architektura nabízí řadu výhod mimo organizaci s kódem, i když.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-136">Layered architecture offers a number of advantages beyond just code organization, though.</span></span>

<span data-ttu-id="4c0cc-137">Díky uspořádání kódu do vrstev lze v celé aplikaci znovu použít běžné funkce nízké úrovně.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-137">By organizing code into layers, common low-level functionality can be reused throughout the application.</span></span> <span data-ttu-id="4c0cc-138">Toto opakované použití je užitečné, protože znamená, že je nutné zapsat méně kódu a protože může aplikaci povolit standardizaci na jednu implementaci, a to po [neopakuji (suchý)](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself) princip.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-138">This reuse is beneficial because it means less code needs to be written and because it can allow the application to standardize on a single implementation, following the [don't repeat yourself (DRY)](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself) principle.</span></span>

<span data-ttu-id="4c0cc-139">Pomocí vrstvené architektury můžou aplikace vyhovět omezením, které vrstvy můžou komunikovat s jinými vrstvami.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-139">With a layered architecture, applications can enforce restrictions on which layers can communicate with other layers.</span></span> <span data-ttu-id="4c0cc-140">To pomáhá dosáhnout zapouzdření.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-140">This helps to achieve encapsulation.</span></span> <span data-ttu-id="4c0cc-141">Když je vrstva změněna nebo nahrazena, mělo by to mít vliv pouze na ty vrstvy, které s ní pracují.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-141">When a layer is changed or replaced, only those layers that work with it should be impacted.</span></span> <span data-ttu-id="4c0cc-142">Omezením, které vrstvy závisí na tom, na které jiné vrstvy, může dopad změn zmírnit, aby jedna změna neovlivnila celou aplikaci.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-142">By limiting which layers depend on which other layers, the impact of changes can be mitigated so that a single change doesn't impact the entire application.</span></span>

<span data-ttu-id="4c0cc-143">Vrstvy (a zapouzdření) výrazně usnadňují nahrazování funkcí v rámci aplikace.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-143">Layers (and encapsulation) make it much easier to replace functionality within the application.</span></span> <span data-ttu-id="4c0cc-144">Například aplikace může zpočátku používat svou vlastní databázi SQL Server pro trvalost, ale později se může rozhodnout použít cloudovou strategii trvalosti nebo jedno za webovým rozhraním API.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-144">For example, an application might initially use its own SQL Server database for persistence, but later could choose to use a cloud-based persistence strategy, or one behind a web API.</span></span> <span data-ttu-id="4c0cc-145">Pokud aplikace správně zapouzdřuje jeho implementaci trvalosti v rámci logické vrstvy, může být SQL Server konkrétní vrstva nahrazena novou jednou implementací stejného veřejného rozhraní.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-145">If the application has properly encapsulated its persistence implementation within a logical layer, that SQL Server specific layer could be replaced by a new one implementing the same public interface.</span></span>

<span data-ttu-id="4c0cc-146">Kromě potenciálu záměny implementací v reakci na budoucí změny v požadavcích může aplikační vrstvy také usnadnit výměnu implementací pro účely testování.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-146">In addition to the potential of swapping out implementations in response to future changes in requirements, application layers can also make it easier to swap out implementations for testing purposes.</span></span> <span data-ttu-id="4c0cc-147">Místo toho, aby bylo nutné zapisovat testy, které pracují s reálnými datovými vrstvami nebo ve vrstvě uživatelského rozhraní aplikace, lze tyto vrstvy nahradit v době testování pomocí falešných implementací, které poskytují známé odpovědi na požadavky.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-147">Instead of having to write tests that operate against the real data layer or UI layer of the application, these layers can be replaced at test time with fake implementations that provide known responses to requests.</span></span> <span data-ttu-id="4c0cc-148">To obvykle usnadňuje psaní a mnohem rychlejší spouštění testů ve srovnání se spouštěním testů v rámci reálné infrastruktury aplikace.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-148">This typically makes tests much easier to write and much faster to run when compared to running tests against the application's real infrastructure.</span></span>

<span data-ttu-id="4c0cc-149">Logická vrstva je běžná technika pro zlepšení organizace kódu v podnikových softwarových aplikacích a existuje několik způsobů, jak lze kód uspořádat do vrstev.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-149">Logical layering is a common technique for improving the organization of code in enterprise software applications, and there are several ways in which code can be organized into layers.</span></span>

> [!NOTE]
 > <span data-ttu-id="4c0cc-150">_Vrstvy_ reprezentují logické oddělování v rámci aplikace.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-150">_Layers_ represent logical separation within the application.</span></span> <span data-ttu-id="4c0cc-151">V případě, že je aplikační logika fyzicky distribuována na samostatné servery nebo procesy, jsou tyto samostatné cíle fyzického nasazení označovány jako _vrstvy_.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-151">In the event that application logic is physically distributed to separate servers or processes, these separate physical deployment targets are referred to as _tiers_.</span></span> <span data-ttu-id="4c0cc-152">Je možné a poměrně běžné, aby bylo možné používat N-vrstvou aplikaci, která je nasazena na jednu vrstvu.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-152">It's possible, and quite common, to have an N-Layer application that is deployed to a single tier.</span></span>

## <a name="traditional-n-layer-architecture-applications"></a><span data-ttu-id="4c0cc-153">Tradiční aplikace architektury N-Layer</span><span class="sxs-lookup"><span data-stu-id="4c0cc-153">Traditional "N-Layer" architecture applications</span></span>

<span data-ttu-id="4c0cc-154">Nejběžnější uspořádání logiky aplikace do vrstev je znázorněno na obrázku 5-2.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-154">The most common organization of application logic into layers is shown in Figure 5-2.</span></span>

![Typické aplikační vrstvy](./media/image5-2.png)

<span data-ttu-id="4c0cc-156">**Obrázek 5-2.**</span><span class="sxs-lookup"><span data-stu-id="4c0cc-156">**Figure 5-2.**</span></span> <span data-ttu-id="4c0cc-157">Typické vrstvy aplikace.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-157">Typical application layers.</span></span>

<span data-ttu-id="4c0cc-158">Tyto vrstvy jsou často zkrácené jako uživatelské rozhraní, knihoven BLL (vrstva obchodní logiky) a DAL (Data Access Layer).</span><span class="sxs-lookup"><span data-stu-id="4c0cc-158">These layers are frequently abbreviated as UI, BLL (Business Logic Layer), and DAL (Data Access Layer).</span></span> <span data-ttu-id="4c0cc-159">Pomocí této architektury můžou uživatelé provádět žádosti přes vrstvu uživatelského rozhraní, která komunikuje jenom s knihoven BLL.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-159">Using this architecture, users make requests through the UI layer, which interacts only with the BLL.</span></span> <span data-ttu-id="4c0cc-160">KNIHOVEN BLL pak může volat DAL pro žádosti o přístup k datům.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-160">The BLL, in turn, can call the DAL for data access requests.</span></span> <span data-ttu-id="4c0cc-161">Vrstva uživatelského rozhraní by neměla přímo předávat žádné požadavky na DAL, ani by nemusela komunikovat s persistencí přímo jiným způsobem.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-161">The UI layer shouldn't make any requests to the DAL directly, nor should it interact with persistence directly through other means.</span></span> <span data-ttu-id="4c0cc-162">Stejně tak by knihoven BLL mělo pracovat pouze s trvalou cestou přes DAL.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-162">Likewise, the BLL should only interact with persistence by going through the DAL.</span></span> <span data-ttu-id="4c0cc-163">Tímto způsobem má každá vrstva svou vlastní dobře známou zodpovědnost.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-163">In this way, each layer has its own well-known responsibility.</span></span>

<span data-ttu-id="4c0cc-164">Jednou z nevýhod tohoto tradičního přístupu k vrstvení je to, že se závislosti při kompilaci spouštějí shora dolů.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-164">One disadvantage of this traditional layering approach is that compile-time dependencies run from the top to the bottom.</span></span> <span data-ttu-id="4c0cc-165">To znamená, že vrstva uživatelského rozhraní závisí na knihoven BLL, který závisí na DAL.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-165">That is, the UI layer depends on the BLL, which depends on the DAL.</span></span> <span data-ttu-id="4c0cc-166">To znamená, že knihoven BLL, který obvykle obsahuje nejdůležitější logiku v aplikaci, závisí na podrobnostech implementace přístupu k datům (a často při existenci databáze).</span><span class="sxs-lookup"><span data-stu-id="4c0cc-166">This means that the BLL, which usually holds the most important logic in the application, is dependent on data access implementation details (and often on the existence of a database).</span></span> <span data-ttu-id="4c0cc-167">Testování obchodní logiky v takové architektuře je často obtížné a vyžaduje testovací databázi.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-167">Testing business logic in such an architecture is often difficult, requiring a test database.</span></span> <span data-ttu-id="4c0cc-168">Princip inverze závislostí lze použít k vyřešení tohoto problému, jak se zobrazí v další části.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-168">The dependency inversion principle can be used to address this issue, as you'll see in the next section.</span></span>

<span data-ttu-id="4c0cc-169">Obrázek 5-3 ukazuje ukázkové řešení a rozdělení aplikace na tři projekty podle zodpovědnosti (nebo vrstvy).</span><span class="sxs-lookup"><span data-stu-id="4c0cc-169">Figure 5-3 shows an example solution, breaking the application into three projects by responsibility (or layer).</span></span>

![Jednoduchá aplikace monolitické se třemi projekty](./media/image5-3.png)

<span data-ttu-id="4c0cc-171">**Obrázek 5-3.**</span><span class="sxs-lookup"><span data-stu-id="4c0cc-171">**Figure 5-3.**</span></span> <span data-ttu-id="4c0cc-172">Jednoduchá aplikace monolitické se třemi projekty.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-172">A simple monolithic application with three projects.</span></span>

<span data-ttu-id="4c0cc-173">I když tato aplikace používá pro organizační účely několik projektů, je stále nasazena jako jediná jednotka a její klienti s ní budou pracovat jako jedna webová aplikace.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-173">Although this application uses several projects for organizational purposes, it's still deployed as a single unit and its clients will interact with it as a single web app.</span></span> <span data-ttu-id="4c0cc-174">To umožňuje velmi jednoduchý proces nasazení.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-174">This allows for very simple deployment process.</span></span> <span data-ttu-id="4c0cc-175">Obrázek 5-4 ukazuje, jak může být taková aplikace hostovaná pomocí Azure.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-175">Figure 5-4 shows how such an app might be hosted using Azure.</span></span>

![Jednoduché nasazení webové aplikace Azure](./media/image5-4.png)

<span data-ttu-id="4c0cc-177">**Obrázek 5-4.**</span><span class="sxs-lookup"><span data-stu-id="4c0cc-177">**Figure 5-4.**</span></span> <span data-ttu-id="4c0cc-178">Jednoduché nasazení webové aplikace Azure</span><span class="sxs-lookup"><span data-stu-id="4c0cc-178">Simple deployment of Azure Web App</span></span>

<span data-ttu-id="4c0cc-179">Vzhledem k rostoucí potřebě aplikací se může vyžadovat složitější a robustní řešení nasazení.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-179">As application needs grow, more complex and robust deployment solutions may be required.</span></span> <span data-ttu-id="4c0cc-180">Obrázek 5-5 ukazuje příklad složitějšího plánu nasazení, který podporuje další možnosti.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-180">Figure 5-5 shows an example of a more complex deployment plan that supports additional capabilities.</span></span>

![Nasazení webové aplikace do Azure App Service](./media/image5-5.png)

<span data-ttu-id="4c0cc-182">**Obrázek 5-5.**</span><span class="sxs-lookup"><span data-stu-id="4c0cc-182">**Figure 5-5.**</span></span> <span data-ttu-id="4c0cc-183">Nasazení webové aplikace do Azure App Service</span><span class="sxs-lookup"><span data-stu-id="4c0cc-183">Deploying a web app to an Azure App Service</span></span>

<span data-ttu-id="4c0cc-184">Interně, organizace tohoto projektu do více projektů na základě zodpovědnosti zlepšuje udržovatelnost aplikace.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-184">Internally, this project's organization into multiple projects based on responsibility improves the maintainability of the application.</span></span>

<span data-ttu-id="4c0cc-185">Tato jednotka se dá škálovat nahoru nebo dolů, aby využila výhody cloudové škálovatelnosti na vyžádání.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-185">This unit can be scaled up or out to take advantage of cloud-based on-demand scalability.</span></span> <span data-ttu-id="4c0cc-186">Vertikální škálování znamená přidání dalšího procesoru, paměti, místa na disku nebo jiných prostředků na servery hostující vaši aplikaci.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-186">Scaling up means adding additional CPU, memory, disk space, or other resources to the server(s) hosting your app.</span></span> <span data-ttu-id="4c0cc-187">Horizontální navýšení kapacity znamená přidání dalších instancí takových serverů, ať už jde o fyzické servery, virtuální počítače nebo kontejnery.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-187">Scaling out means adding additional instances of such servers, whether these are physical servers, virtual machines, or containers.</span></span> <span data-ttu-id="4c0cc-188">Pokud je vaše aplikace hostována v rámci více instancí, používá nástroj pro vyrovnávání zatížení k přiřazování požadavků jednotlivým instancím aplikací.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-188">When your app is hosted across multiple instances, a load balancer is used to assign requests to individual app instances.</span></span>

<span data-ttu-id="4c0cc-189">Nejjednodušší způsob, jak škálovat webovou aplikaci v Azure, je nakonfigurovat škálování ručně v plánu App Service aplikace.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-189">The simplest approach to scaling a web application in Azure is to configure scaling manually in the application's App Service Plan.</span></span> <span data-ttu-id="4c0cc-190">Obrázek 5-6 ukazuje příslušnou obrazovku řídicího panelu Azure ke konfiguraci, kolik instancí obsluhuje aplikace.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-190">Figure 5-6 shows the appropriate Azure dashboard screen to configure how many instances are serving an app.</span></span>

![App Service plánování škálování v Azure](./media/image5-6.png)

<span data-ttu-id="4c0cc-192">**Obrázek 5-6.**</span><span class="sxs-lookup"><span data-stu-id="4c0cc-192">**Figure 5-6.**</span></span> <span data-ttu-id="4c0cc-193">App Service plánování škálování v Azure.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-193">App Service Plan scaling in Azure.</span></span>

## <a name="clean-architecture"></a><span data-ttu-id="4c0cc-194">Čistá architektura</span><span class="sxs-lookup"><span data-stu-id="4c0cc-194">Clean architecture</span></span>

<span data-ttu-id="4c0cc-195">Aplikace, které následují po principu inverze závislostí, a také principy návrhu založeného na doméně (DDD), které mají za následek podobnou architekturu.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-195">Applications that follow the Dependency Inversion Principle as well as the Domain-Driven Design (DDD) principles tend to arrive at a similar architecture.</span></span> <span data-ttu-id="4c0cc-196">Tato architektura prošla řadou názvů za roky.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-196">This architecture has gone by many names over the years.</span></span> <span data-ttu-id="4c0cc-197">Jedním z prvních názvů je Šestiúhelníkická architektura následovaný porty-a-adaptery.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-197">One of the first names was Hexagonal Architecture, followed by Ports-and-Adapters.</span></span> <span data-ttu-id="4c0cc-198">V poslední době je citována jako [cibulová architektura](https://jeffreypalermo.com/blog/the-onion-architecture-part-1/) nebo [čistá architektura](https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html).</span><span class="sxs-lookup"><span data-stu-id="4c0cc-198">More recently, it's been cited as the [Onion Architecture](https://jeffreypalermo.com/blog/the-onion-architecture-part-1/) or [Clean Architecture](https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html).</span></span> <span data-ttu-id="4c0cc-199">Tento název se používá jako název pro tuto architekturu v této elektronické příručce.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-199">The latter name, Clean Architecture, is used as the name for this architecture in this e-book.</span></span>

<span data-ttu-id="4c0cc-200">Referenční aplikace eShopOnWeb používá přístup k čisté architektuře při uspořádávání kódu do projektů.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-200">The eShopOnWeb reference application uses the Clean Architecture approach in organizing its code into projects.</span></span> <span data-ttu-id="4c0cc-201">Můžete najít šablonu řešení, kterou můžete použít jako výchozí bod pro vlastní ASP.NET Core v úložišti GitHub [ardalis/cleanarchitecture](https://github.com/ardalis/cleanarchitecture) .</span><span class="sxs-lookup"><span data-stu-id="4c0cc-201">You can find a solution template you can use as a starting point for your own ASP.NET Core on the [ardalis/cleanarchitecture](https://github.com/ardalis/cleanarchitecture) GitHub repository.</span></span>

<span data-ttu-id="4c0cc-202">Čistá architektura vloží model obchodní logiky a aplikace do středu aplikace.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-202">Clean architecture puts the business logic and application model at the center of the application.</span></span> <span data-ttu-id="4c0cc-203">Místo toho, aby obchodní logika závisela na přístupu k datům nebo jiné infrastruktuře, je tato závislost opačná: informace o infrastruktuře a implementaci závisí na jádru aplikace.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-203">Instead of having business logic depend on data access or other infrastructure concerns, this dependency is inverted: infrastructure and implementation details depend on the Application Core.</span></span> <span data-ttu-id="4c0cc-204">Toho je dosaženo definováním abstrakcí nebo rozhraní v jádru aplikace, které jsou následně implementovány pomocí typů definovaných ve vrstvě infrastruktury.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-204">This is achieved by defining abstractions, or interfaces, in the Application Core, which are then implemented by types defined in the Infrastructure layer.</span></span> <span data-ttu-id="4c0cc-205">Běžným způsobem vizualizace této architektury je použití řady soustředných kruhů, podobně jako cibule.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-205">A common way of visualizing this architecture is to use a series of concentric circles, similar to an onion.</span></span> <span data-ttu-id="4c0cc-206">Obrázek 5-7 ukazuje příklad tohoto stylu strukturální reprezentace.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-206">Figure 5-7 shows an example of this style of architectural representation.</span></span>

![Čistá architektura; zobrazení průsvitek](./media/image5-7.png)

<span data-ttu-id="4c0cc-208">**Obrázek 5-7.**</span><span class="sxs-lookup"><span data-stu-id="4c0cc-208">**Figure 5-7.**</span></span> <span data-ttu-id="4c0cc-209">Čistá architektura; zobrazení průsvitek</span><span class="sxs-lookup"><span data-stu-id="4c0cc-209">Clean Architecture; onion view</span></span>

<span data-ttu-id="4c0cc-210">V tomto diagramu se závislosti nasměrují k vnitřnímu kruhu.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-210">In this diagram, dependencies flow toward the innermost circle.</span></span> <span data-ttu-id="4c0cc-211">Jádro aplikace přebírá svůj název od pozice v jádru tohoto diagramu.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-211">The Application Core takes its name from its position at the core of this diagram.</span></span> <span data-ttu-id="4c0cc-212">A můžete se podívat na diagram, že jádro aplikace nemá žádné závislosti na jiných vrstvách aplikace.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-212">And you can see on the diagram that the Application Core has no dependencies on other application layers.</span></span> <span data-ttu-id="4c0cc-213">Entity a rozhraní aplikace jsou ve velmi středu.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-213">The application's entities and interfaces are at the very center.</span></span> <span data-ttu-id="4c0cc-214">Stejně jako mimo, ale i v jádru aplikace, jsou doménové služby, které obvykle implementují rozhraní definovaná ve vnitřním kruhu.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-214">Just outside, but still in the Application Core, are domain services, which typically implement interfaces defined in the inner circle.</span></span> <span data-ttu-id="4c0cc-215">Mimo jádro aplikace závisí rozhraní a vrstvy infrastruktury na jádru aplikace, ale ne na jednom jiném (nutně).</span><span class="sxs-lookup"><span data-stu-id="4c0cc-215">Outside of the Application Core, both the UI and the Infrastructure layers depend on the Application Core, but not on one another (necessarily).</span></span>

<span data-ttu-id="4c0cc-216">Obrázek 5-8 ukazuje obecnější vodorovný Diagram vrstev, který lépe odráží závislosti mezi uživatelským rozhraním a dalšími vrstvami.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-216">Figure 5-8 shows a more traditional horizontal layer diagram that better reflects the dependency between the UI and other layers.</span></span>

![Čistá architektura; horizontální zobrazení vrstvy](./media/image5-8.png)

<span data-ttu-id="4c0cc-218">**Obrázek 5-8.**</span><span class="sxs-lookup"><span data-stu-id="4c0cc-218">**Figure 5-8.**</span></span> <span data-ttu-id="4c0cc-219">Čistá architektura; horizontální zobrazení vrstvy</span><span class="sxs-lookup"><span data-stu-id="4c0cc-219">Clean Architecture; horizontal layer view</span></span>

<span data-ttu-id="4c0cc-220">Všimněte si, že plné šipky představují závislosti v době kompilace, zatímco Čárkovaná šipka představuje závislost pouze za běhu.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-220">Note that the solid arrows represent compile-time dependencies, while the dashed arrow represents a runtime-only dependency.</span></span> <span data-ttu-id="4c0cc-221">V případě čisté architektury pracuje vrstva uživatelského rozhraní s rozhraními definovanými v jádru aplikace v době kompilace a v ideálním případě by neměla znát typy implementace definované v infrastruktuře vrstev.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-221">With the clean architecture, the UI layer works with interfaces defined in the Application Core at compile time, and ideally shouldn't know about the implementation types defined in the Infrastructure layer.</span></span> <span data-ttu-id="4c0cc-222">V době běhu jsou však tyto typy implementace požadovány, aby bylo možné aplikaci spustit, takže musí být přítomna a zapojena do základních rozhraní aplikace prostřednictvím injektáže závislosti.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-222">At run time, however, these implementation types are required for the app to execute, so they need to be present and wired up to the Application Core interfaces via dependency injection.</span></span>

<span data-ttu-id="4c0cc-223">Obrázek 5-9 ukazuje podrobnější zobrazení architektury aplikace ASP.NET Core při sestavení těchto doporučení.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-223">Figure 5-9 shows a more detailed view of an ASP.NET Core application's architecture when built following these recommendations.</span></span>

![Diagram architektury ASP.NET Core po čisté architektuře](./media/image5-9.png)

<span data-ttu-id="4c0cc-225">**Obrázek 5-9.**</span><span class="sxs-lookup"><span data-stu-id="4c0cc-225">**Figure 5-9.**</span></span> <span data-ttu-id="4c0cc-226">ASP.NET Core diagramu architektury po vyčištění architektury.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-226">ASP.NET Core architecture diagram following Clean Architecture.</span></span>

<span data-ttu-id="4c0cc-227">Vzhledem k tomu, že jádro aplikace nezávisí na infrastruktuře, je velmi snadné zapsat automatizované testy jednotek pro tuto vrstvu.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-227">Because the Application Core doesn't depend on Infrastructure, it's very easy to write automated unit tests for this layer.</span></span> <span data-ttu-id="4c0cc-228">Obrázky 5-10 a 5-11 ukazují, jak testy spadají do této architektury.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-228">Figures 5-10 and 5-11 show how tests fit into this architecture.</span></span>

![UnitTestCore](./media/image5-10.png)

<span data-ttu-id="4c0cc-230">**Obrázek 5-10.**</span><span class="sxs-lookup"><span data-stu-id="4c0cc-230">**Figure 5-10.**</span></span> <span data-ttu-id="4c0cc-231">Jádro testování částí aplikace v izolaci.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-231">Unit testing Application Core in isolation.</span></span>

![IntegrationTests](./media/image5-11.png)

<span data-ttu-id="4c0cc-233">**Obrázek 5-11.**</span><span class="sxs-lookup"><span data-stu-id="4c0cc-233">**Figure 5-11.**</span></span> <span data-ttu-id="4c0cc-234">Implementace testování infrastruktury v rámci integrace s externími závislostmi.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-234">Integration testing Infrastructure implementations with external dependencies.</span></span>

<span data-ttu-id="4c0cc-235">Vzhledem k tomu, že vrstva uživatelského rozhraní nemá žádnou přímou závislost na typech definovaných v projektu infrastruktury, je také velmi snadné vyměňovat implementace, a to buď pro usnadnění testování, nebo v reakci na změnu požadavků aplikace.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-235">Since the UI layer doesn't have any direct dependency on types defined in the Infrastructure project, it's likewise very easy to swap out implementations, either to facilitate testing or in response to changing application requirements.</span></span> <span data-ttu-id="4c0cc-236">ASP.NET Core integrované použití a podpora pro vkládání závislostí dává této architektuře nejvhodnější způsob, jak strukturovat jiné než triviální aplikace monolitické.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-236">ASP.NET Core's built-in use of and support for dependency injection makes this architecture the most appropriate way to structure non-trivial monolithic applications.</span></span>

<span data-ttu-id="4c0cc-237">Pro aplikace monolitické jsou všechny projekty jádra, infrastruktury a uživatelského rozhraní spouštěny jako jedna aplikace.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-237">For monolithic applications the Application Core, Infrastructure, and UI projects are all run as a single application.</span></span> <span data-ttu-id="4c0cc-238">Běhová architektura aplikace může vypadat přibližně jako obrázek 5-12.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-238">The runtime application architecture might look something like Figure 5-12.</span></span>

![ASP.NET Core architektura 2](./media/image5-12.png)

<span data-ttu-id="4c0cc-240">**Obrázek 5-12.**</span><span class="sxs-lookup"><span data-stu-id="4c0cc-240">**Figure 5-12.**</span></span> <span data-ttu-id="4c0cc-241">Ukázková Architektura modulu runtime ASP.NET Core aplikace</span><span class="sxs-lookup"><span data-stu-id="4c0cc-241">A sample ASP.NET Core app's runtime architecture.</span></span>

### <a name="organizing-code-in-clean-architecture"></a><span data-ttu-id="4c0cc-242">Organizování kódu v čisté architektuře</span><span class="sxs-lookup"><span data-stu-id="4c0cc-242">Organizing code in Clean Architecture</span></span>

<span data-ttu-id="4c0cc-243">V řešení čisté architektury má každý projekt jasné zodpovědnosti.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-243">In a Clean Architecture solution, each project has clear responsibilities.</span></span> <span data-ttu-id="4c0cc-244">V takovém případě určité typy patří do každého projektu a často najdete složky odpovídající těmto typům v příslušném projektu.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-244">As such, certain types belong in each project and you'll frequently find folders corresponding to these types in the appropriate project.</span></span>

#### <a name="application-core"></a><span data-ttu-id="4c0cc-245">Jádro aplikace</span><span class="sxs-lookup"><span data-stu-id="4c0cc-245">Application Core</span></span>

<span data-ttu-id="4c0cc-246">Jádro aplikace obsahuje obchodní model, který zahrnuje entity, služby a rozhraní.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-246">The Application Core holds the business model, which includes entities, services, and interfaces.</span></span> <span data-ttu-id="4c0cc-247">Mezi tato rozhraní patří abstrakce pro operace, které budou provedeny pomocí infrastruktury, jako je například přístup k datům, přístup k systému souborů, volání sítě atd. Někdy služby nebo rozhraní definované v této vrstvě budou potřebovat pracovat s typy bez entit, které neobsahují žádné závislosti na uživatelském rozhraní nebo infrastruktuře.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-247">These interfaces include abstractions for operations that will be performed using Infrastructure, such as data access, file system access, network calls, etc. Sometimes services or interfaces defined at this layer will need to work with non-entity types that have no dependencies on UI or Infrastructure.</span></span> <span data-ttu-id="4c0cc-248">Ty lze definovat jako jednoduché objekty Přenos dat (DTO).</span><span class="sxs-lookup"><span data-stu-id="4c0cc-248">These can be defined as simple Data Transfer Objects (DTOs).</span></span>

##### <a name="application-core-types"></a><span data-ttu-id="4c0cc-249">Základní typy aplikace</span><span class="sxs-lookup"><span data-stu-id="4c0cc-249">Application Core types</span></span>

- <span data-ttu-id="4c0cc-250">Entity (třídy obchodního modelu, které jsou trvalé)</span><span class="sxs-lookup"><span data-stu-id="4c0cc-250">Entities (business model classes that are persisted)</span></span>
- <span data-ttu-id="4c0cc-251">Rozhraní</span><span class="sxs-lookup"><span data-stu-id="4c0cc-251">Interfaces</span></span>
- <span data-ttu-id="4c0cc-252">Služby</span><span class="sxs-lookup"><span data-stu-id="4c0cc-252">Services</span></span>
- <span data-ttu-id="4c0cc-253">DTO</span><span class="sxs-lookup"><span data-stu-id="4c0cc-253">DTOs</span></span>

#### <a name="infrastructure"></a><span data-ttu-id="4c0cc-254">Infrastruktura</span><span class="sxs-lookup"><span data-stu-id="4c0cc-254">Infrastructure</span></span>

<span data-ttu-id="4c0cc-255">Projekt infrastruktury obvykle zahrnuje implementace přístupu k datům.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-255">The Infrastructure project typically includes data access implementations.</span></span> <span data-ttu-id="4c0cc-256">V typické ASP.NET Core webové aplikaci zahrnuje tyto implementace Entity Framework (EF) DbContext, všechny EF Core `Migration` objekty, které byly definovány, a třídy implementace přístupu k datům.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-256">In a typical ASP.NET Core web application, these implementations include the Entity Framework (EF) DbContext, any EF Core `Migration` objects that have been defined, and data access implementation classes.</span></span> <span data-ttu-id="4c0cc-257">Nejběžnější způsob, jak abstraktní kód pro implementaci přístupu k datům, je použití [vzoru návrhu úložiště](https://deviq.com/repository-pattern/).</span><span class="sxs-lookup"><span data-stu-id="4c0cc-257">The most common way to abstract data access implementation code is through the use of the [Repository design pattern](https://deviq.com/repository-pattern/).</span></span>

<span data-ttu-id="4c0cc-258">Kromě implementace přístupu k datům by měl projekt infrastruktury obsahovat implementace služeb, které musí komunikovat s infrastrukturou infrastruktury.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-258">In addition to data access implementations, the Infrastructure project should contain implementations of services that must interact with infrastructure concerns.</span></span> <span data-ttu-id="4c0cc-259">Tyto služby by měly implementovat rozhraní definovaná v jádru aplikace, takže infrastruktura by měla mít odkaz na projekt Application Core.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-259">These services should implement interfaces defined in the Application Core, and so Infrastructure should have a reference to the Application Core project.</span></span>

##### <a name="infrastructure-types"></a><span data-ttu-id="4c0cc-260">Typy infrastruktury</span><span class="sxs-lookup"><span data-stu-id="4c0cc-260">Infrastructure types</span></span>

- <span data-ttu-id="4c0cc-261">Typy EF Core ( `DbContext` , `Migration` )</span><span class="sxs-lookup"><span data-stu-id="4c0cc-261">EF Core types (`DbContext`, `Migration`)</span></span>
- <span data-ttu-id="4c0cc-262">Typy implementace přístupu k datům (úložiště)</span><span class="sxs-lookup"><span data-stu-id="4c0cc-262">Data access implementation types (Repositories)</span></span>
- <span data-ttu-id="4c0cc-263">Služby specifické pro infrastrukturu (například `FileLogger` nebo `SmtpNotifier` )</span><span class="sxs-lookup"><span data-stu-id="4c0cc-263">Infrastructure-specific services (for example, `FileLogger` or `SmtpNotifier`)</span></span>

#### <a name="ui-layer"></a><span data-ttu-id="4c0cc-264">Vrstva uživatelského rozhraní</span><span class="sxs-lookup"><span data-stu-id="4c0cc-264">UI Layer</span></span>

<span data-ttu-id="4c0cc-265">Vrstva uživatelského rozhraní v aplikaci ASP.NET Core MVC je vstupním bodem pro aplikaci.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-265">The user interface layer in an ASP.NET Core MVC application is the entry point for the application.</span></span> <span data-ttu-id="4c0cc-266">Tento projekt by měl odkazovat na projekt základního projektu a jeho typy by měly komunikovat s infrastrukturou výhradně prostřednictvím rozhraní definovaných v Application Core.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-266">This project should reference the Application Core project, and its types should interact with infrastructure strictly through interfaces defined in Application Core.</span></span> <span data-ttu-id="4c0cc-267">Ve vrstvě uživatelského rozhraní by se měly povolit žádné přímé vytváření instancí ani statická volání typů vrstev infrastruktury.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-267">No direct instantiation of or static calls to the Infrastructure layer types should be allowed in the UI layer.</span></span>

##### <a name="ui-layer-types"></a><span data-ttu-id="4c0cc-268">Typy vrstev uživatelského rozhraní</span><span class="sxs-lookup"><span data-stu-id="4c0cc-268">UI Layer types</span></span>

- <span data-ttu-id="4c0cc-269">Kontrolery</span><span class="sxs-lookup"><span data-stu-id="4c0cc-269">Controllers</span></span>
- <span data-ttu-id="4c0cc-270">Filtry</span><span class="sxs-lookup"><span data-stu-id="4c0cc-270">Filters</span></span>
- <span data-ttu-id="4c0cc-271">Zobrazení</span><span class="sxs-lookup"><span data-stu-id="4c0cc-271">Views</span></span>
- <span data-ttu-id="4c0cc-272">ViewModels</span><span class="sxs-lookup"><span data-stu-id="4c0cc-272">ViewModels</span></span>
- <span data-ttu-id="4c0cc-273">Spuštění</span><span class="sxs-lookup"><span data-stu-id="4c0cc-273">Startup</span></span>

<span data-ttu-id="4c0cc-274">Třída po spuštění zodpovídá za konfiguraci aplikace a pro zapojení typů implementace do rozhraní, což umožňuje, aby vkládání závislostí fungovalo správně v době běhu.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-274">The Startup class is responsible for configuring the application, and for wiring up implementation types to interfaces, allowing dependency injection to work properly at run time.</span></span>

> [!NOTE]
> <span data-ttu-id="4c0cc-275">Aby bylo možné vytvořit ConfigureServices závislostí v souboru Startup.cs projektu uživatelského rozhraní, může se stát, že projekt bude potřebovat odkaz na projekt infrastruktury.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-275">In order to wire up dependency injection in ConfigureServices in the Startup.cs file of the UI project, the project may need to reference the Infrastructure project.</span></span> <span data-ttu-id="4c0cc-276">Tuto závislost lze pomocí vlastního kontejneru DI snadno eliminovat.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-276">This dependency can be eliminated, most easily by using a custom DI container.</span></span> <span data-ttu-id="4c0cc-277">Pro účely této ukázky je nejjednodušší přístup k tomu, aby projekt uživatelského rozhraní odkazoval na projekt infrastruktury.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-277">For the purposes of this sample, the simplest approach is to allow the UI project to reference the Infrastructure project.</span></span>

## <a name="monolithic-applications-and-containers"></a><span data-ttu-id="4c0cc-278">Monolitické aplikací a kontejnerů</span><span class="sxs-lookup"><span data-stu-id="4c0cc-278">Monolithic applications and containers</span></span>

<span data-ttu-id="4c0cc-279">Můžete vytvořit jednu a monolitické webovou aplikaci nebo službu založenou na nasazení a nasadit ji jako kontejner.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-279">You can build a single and monolithic-deployment based Web Application or Service and deploy it as a container.</span></span> <span data-ttu-id="4c0cc-280">V rámci aplikace nemusí být monolitické, ale uspořádány do několika knihoven, komponent nebo vrstev.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-280">Within the application, it might not be monolithic but organized into several libraries, components, or layers.</span></span> <span data-ttu-id="4c0cc-281">Externě se jedná o jediný kontejner, jako je jeden proces, jedna webová aplikace nebo jedna služba.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-281">Externally, it's a single container like a single process, single web application, or single service.</span></span>

<span data-ttu-id="4c0cc-282">Chcete-li spravovat tento model, nasadíte jeden kontejner, který bude představovat aplikaci.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-282">To manage this model, you deploy a single container to represent the application.</span></span> <span data-ttu-id="4c0cc-283">Chcete-li škálovat, stačí přidat další kopie pomocí nástroje pro vyrovnávání zatížení předem.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-283">To scale, just add additional copies with a load balancer in front.</span></span> <span data-ttu-id="4c0cc-284">Jednoduchost pochází ze správy jednoho nasazení v jednom kontejneru nebo virtuálním počítači.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-284">The simplicity comes from managing a single deployment in a single container or VM.</span></span>

![Obrázek 5-13](./media/image5-13.png)

<span data-ttu-id="4c0cc-286">V rámci každého kontejneru můžete zahrnout více komponent, knihoven nebo vnitřních vrstev, jak je znázorněno na obrázku 5-13.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-286">You can include multiple components/libraries or internal layers within each container, as illustrated in Figure 5-13.</span></span> <span data-ttu-id="4c0cc-287">Ale podle principu kontejneru _"kontejner provede jednu věc a provede ho v jednom procesu_", vzor monolitické může být konflikt.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-287">But, following the container principle of _"a container does one thing, and does it in one process_", the monolithic pattern might be a conflict.</span></span>

<span data-ttu-id="4c0cc-288">K Nevýhodou tohoto přístupu přijde, když/když aplikace roste a vyžaduje, aby se škálovat.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-288">The downside of this approach comes if/when the application grows, requiring it to scale.</span></span> <span data-ttu-id="4c0cc-289">Pokud se celá aplikace škáluje, není ve skutečnosti problém.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-289">If the entire application scales, it's not really a problem.</span></span> <span data-ttu-id="4c0cc-290">Ve většině případů některé části aplikace jsou však potlačením bodů vyžadujících škálování, zatímco jiné součásti jsou používány méně.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-290">However, in most cases, a few parts of the application are the choke points requiring scaling, while other components are used less.</span></span>

<span data-ttu-id="4c0cc-291">Pomocí typického příkladu elektronického obchodování, co pravděpodobně budete potřebovat ke škálování, je součást informace o produktu.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-291">Using the typical eCommerce example, what you likely need to scale is the product information component.</span></span> <span data-ttu-id="4c0cc-292">Mnoho dalších zákazníků prochází produkty, než je koupí.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-292">Many more customers browse products than purchase them.</span></span> <span data-ttu-id="4c0cc-293">Další zákazníci používají svůj koš, než používá platební kanál.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-293">More customers use their basket than use the payment pipeline.</span></span> <span data-ttu-id="4c0cc-294">Méně zákazníkům přidávají komentáře nebo zobrazují historii jejich nákupu.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-294">Fewer customers add comments or view their purchase history.</span></span> <span data-ttu-id="4c0cc-295">A máte pravděpodobně pouze několik zaměstnanců v jedné oblasti, které potřebují spravovat obsah a marketingové kampaně.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-295">And you likely only have a handful of employees, in a single region, that need to manage the content and marketing campaigns.</span></span> <span data-ttu-id="4c0cc-296">Díky škálování návrhu monolitické je veškerý kód nasazen několikrát.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-296">By scaling the monolithic design, all the code is deployed multiple times.</span></span>

<span data-ttu-id="4c0cc-297">Kromě problému "škálovat vše", změny jedné součásti vyžadují dokončení opětovného testování celé aplikace a úplné opětovné nasazení všech instancí.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-297">In addition to the "scale everything" problem, changes to a single component require complete retesting of the entire application, and a complete redeployment of all the instances.</span></span>

<span data-ttu-id="4c0cc-298">Přístup k monolitické je společný a mnoho organizací vyvíjí s tímto přístupem k architektuře.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-298">The monolithic approach is common, and many organizations are developing with this architectural approach.</span></span> <span data-ttu-id="4c0cc-299">Mnoho z nich má dostatečný dobrý výsledek, zatímco jiné jsou omezení na více počítačů.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-299">Many are having good enough results, while others are hitting limits.</span></span> <span data-ttu-id="4c0cc-300">Řada navrhla své aplikace v tomto modelu, protože nástroje a infrastruktura byly příliš obtížné sestavovat architektury orientované na služby (SOA) a nemusely být potřebné, dokud se aplikace vypnula.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-300">Many designed their applications in this model, because the tools and infrastructure were too difficult to build service-oriented architectures (SOA), and they didn't see the need until the app grew.</span></span> <span data-ttu-id="4c0cc-301">Pokud zjistíte, že jste dosáhli limitu přístupu monolitické, rozbalíte aplikaci, aby ji bylo možné lépe využívat kontejnery a mikroslužby se může jednat o další logický krok.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-301">If you find you're hitting the limits of the monolithic approach, breaking up the app to enable it to better leverage containers and microservices may be the next logical step.</span></span>

![Obrázek 5-14](./media/image5-14.png)

<span data-ttu-id="4c0cc-303">Nasazení aplikací monolitické v Microsoft Azure lze dosáhnout použitím vyhrazených virtuálních počítačů pro každou instanci.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-303">Deploying monolithic applications in Microsoft Azure can be achieved using dedicated VMs for each instance.</span></span> <span data-ttu-id="4c0cc-304">Pomocí [Azure Virtual Machine Scale Sets](https://docs.microsoft.com/azure/virtual-machine-scale-sets/)můžete virtuální počítače snadno škálovat.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-304">Using [Azure Virtual Machine Scale Sets](https://docs.microsoft.com/azure/virtual-machine-scale-sets/), you can easily scale the VMs.</span></span> <span data-ttu-id="4c0cc-305">[Azure App Services](https://azure.microsoft.com/services/app-service/) může spouštět aplikace v monolitické a snadno škálovat instance bez nutnosti správy virtuálních počítačů.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-305">[Azure App Services](https://azure.microsoft.com/services/app-service/) can run monolithic applications and easily scale instances without having to manage the VMs.</span></span> <span data-ttu-id="4c0cc-306">Azure App Services může také spouštět jednotlivé instance kontejnerů Docker a zjednodušit tak nasazení.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-306">Azure App Services can run single instances of Docker containers as well, simplifying the deployment.</span></span> <span data-ttu-id="4c0cc-307">Pomocí Docker můžete nasadit jeden virtuální počítač jako hostitele Docker a spustit víc instancí.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-307">Using Docker, you can deploy a single VM as a Docker host, and run multiple instances.</span></span> <span data-ttu-id="4c0cc-308">Pomocí služby Azure Balancer, jak je znázorněno na obrázku 5-14, můžete spravovat škálování.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-308">Using the Azure balancer, as shown in the Figure 5-14, you can manage scaling.</span></span>

<span data-ttu-id="4c0cc-309">Nasazení na různé hostitele je možné spravovat pomocí tradičních technik nasazení.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-309">The deployment to the various hosts can be managed with traditional deployment techniques.</span></span> <span data-ttu-id="4c0cc-310">Hostitele Docker je možné spravovat pomocí příkazů, jako je například **spuštění Docker** , a to prostřednictvím automatizace, jako jsou kanály pro průběžné doručování (CD).</span><span class="sxs-lookup"><span data-stu-id="4c0cc-310">The Docker hosts can be managed with commands like **docker run** performed manually, or through automation such as Continuous Delivery (CD) pipelines.</span></span>

### <a name="monolithic-application-deployed-as-a-container"></a><span data-ttu-id="4c0cc-311">Aplikace monolitické nasazená jako kontejner</span><span class="sxs-lookup"><span data-stu-id="4c0cc-311">Monolithic application deployed as a container</span></span>

<span data-ttu-id="4c0cc-312">Existují výhody použití kontejnerů ke správě nasazení aplikací monolitické.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-312">There are benefits of using containers to manage monolithic application deployments.</span></span> <span data-ttu-id="4c0cc-313">Škálování instancí kontejnerů je mnohem rychlejší a jednodušší než nasazení dalších virtuálních počítačů.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-313">Scaling the instances of containers is far faster and easier than deploying additional VMs.</span></span> <span data-ttu-id="4c0cc-314">I v případě, že se k škálování virtuálních počítačů používá Virtual Machine Scale Sets, doba jejich instance trvá.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-314">Even when using virtual machine scale sets to scale VMs, they take time to instance.</span></span> <span data-ttu-id="4c0cc-315">Když se nasadí jako instance aplikace, bude se konfigurace aplikace spravovat jako součást virtuálního počítače.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-315">When deployed as app instances, the configuration of the app is managed as part of the VM.</span></span>

<span data-ttu-id="4c0cc-316">Nasazování aktualizací jako imagí Docker je mnohem rychlejší a efektivně v síti.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-316">Deploying updates as Docker images is far faster and network efficient.</span></span> <span data-ttu-id="4c0cc-317">Image Docker obvykle začínají během sekund a urychlují uvádění.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-317">Docker Images typically start in seconds, speeding rollouts.</span></span> <span data-ttu-id="4c0cc-318">Zrušení instance Docker je stejně snadné jako vydávání `docker stop` příkazu, obvykle dokončení za méně než sekundu.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-318">Tearing down a Docker instance is as easy as issuing a `docker stop` command, typically completing in less than a second.</span></span>

<span data-ttu-id="4c0cc-319">Vzhledem k tomu, že jsou kontejnery v podstatě neměnné, nemusíte si dělat starosti s poškozenými virtuálními počítači, zatímco skripty pro aktualizace se nemusí zapomenout na určitou konkrétní konfiguraci nebo soubor, který zůstal na disku.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-319">As containers are inherently immutable by design, you never need to worry about corrupted VMs, whereas update scripts might forget to account for some specific configuration or file left on disk.</span></span>

<span data-ttu-id="4c0cc-320">Kontejnery Docker můžete použít k nasazení monolitické pro jednodušší webové aplikace.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-320">You can use Docker containers for monolithic deployment of simpler web applications.</span></span> <span data-ttu-id="4c0cc-321">Tím se zlepší průběžná integrace a kanály průběžného nasazování a pomáhá dosáhnout úspěchu nasazení na produkční prostředí.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-321">This improves continuous integration and continuous deployment pipelines and helps achieve deployment-to-production success.</span></span> <span data-ttu-id="4c0cc-322">Žádné další "na mém počítači nefunguje, proč nefunguje v produkčním prostředí?"</span><span class="sxs-lookup"><span data-stu-id="4c0cc-322">No more “It works on my machine, why does it not work in production?”</span></span>

<span data-ttu-id="4c0cc-323">Architektura založená na mikroslužbách má spoustu výhod, ale tyto výhody přináší náklady na zvýšení složitosti.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-323">A microservices-based architecture has many benefits, but those benefits come at a cost of increased complexity.</span></span> <span data-ttu-id="4c0cc-324">V některých případech náklady převažují nad výhodami, takže aplikace nasazení monolitické spuštěná v jednom kontejneru nebo v několika kontejnerech je lepší volbou.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-324">In some cases, the costs outweigh the benefits, so a monolithic deployment application running in a single container or in just a few containers is a better option.</span></span>

<span data-ttu-id="4c0cc-325">Aplikace monolitické se možná snadno nedokáže snadno desestavit do dobře oddělených mikroslužeb.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-325">A monolithic application might not be easily decomposable into well-separated microservices.</span></span> <span data-ttu-id="4c0cc-326">Mikroslužby by měly pracovat nezávisle na sobě, aby poskytovaly pružnější aplikaci.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-326">Microservices should work independently of each other to provide a more resilient application.</span></span> <span data-ttu-id="4c0cc-327">Pokud nemůžete doručovat nezávislé řezy funkcí aplikace, oddělení IT pouze zvyšuje složitost.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-327">If you can't deliver independent feature slices of the application, separating it only adds complexity.</span></span>

<span data-ttu-id="4c0cc-328">Aplikace nemusí ještě potřebovat škálování funkcí nezávisle.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-328">An application might not yet need to scale features independently.</span></span> <span data-ttu-id="4c0cc-329">Mnoho aplikací, pokud potřebují škálovat nad rámec jedné instance, to může prozatím poměrně jednoduchý proces klonování celého instance.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-329">Many applications, when they need to scale beyond a single instance, can do so through the relatively simple process of cloning that entire instance.</span></span> <span data-ttu-id="4c0cc-330">Další práce, která odděluje aplikaci do diskrétních služeb, poskytuje minimální přínos při škálování úplných instancí aplikace je jednoduché a nákladově efektivní.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-330">The additional work to separate the application into discrete services provides minimal benefit when scaling full instances of the application is simple and cost-effective.</span></span>

<span data-ttu-id="4c0cc-331">V rané fázi vývoje aplikace možná nemáte jasný nápad, kde jsou hranice přirozené funkčnosti.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-331">Early in the development of an application, you might not have a clear idea where the natural functional boundaries are.</span></span> <span data-ttu-id="4c0cc-332">Když vyvíjíte minimální životaschopný produkt, přirozené oddělení se ještě nemusí narazit.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-332">As you develop a minimum viable product, the natural separation might not yet have emerged.</span></span> <span data-ttu-id="4c0cc-333">Některé z těchto podmínek můžou být dočasné.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-333">Some of these conditions might be temporary.</span></span> <span data-ttu-id="4c0cc-334">Můžete začít vytvořením aplikace v monolitické a později oddělit některé funkce, které se budou vyvíjet a nasazovat jako mikroslužby.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-334">You might start by creating a monolithic application, and later separate some features to be developed and deployed as microservices.</span></span> <span data-ttu-id="4c0cc-335">Další podmínky můžou být nezbytné pro místo v oblasti problému aplikace, což znamená, že aplikace nemusí být nikdy rozdělená do více mikroslužeb.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-335">Other conditions might be essential to the application's problem space, meaning that the application might never be broken into multiple microservices.</span></span>

<span data-ttu-id="4c0cc-336">Oddělení aplikace do mnoha diskrétních procesů také přináší režijní náklady.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-336">Separating an application into many discrete processes also introduces overhead.</span></span> <span data-ttu-id="4c0cc-337">Oddělení funkcí do různých procesů je složitější.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-337">There's more complexity in separating features into different processes.</span></span> <span data-ttu-id="4c0cc-338">Komunikační protokoly se stanou složitější.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-338">The communication protocols become more complex.</span></span> <span data-ttu-id="4c0cc-339">Místo volání metod je nutné použít asynchronní komunikaci mezi službami.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-339">Instead of method calls, you must use asynchronous communications between services.</span></span> <span data-ttu-id="4c0cc-340">Při přesunu do architektury mikroslužeb je potřeba přidat spoustu stavebních bloků implementovaných ve verzi mikroslužeb aplikace eShopOnContainers: zpracování sběrnice událostí, odolnost zpráv a opakované pokusy, konečná konzistence a další.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-340">As you move to a microservices architecture, you need to add many of the building blocks implemented in the microservices version of the eShopOnContainers application: event bus handling, message resiliency and retries, eventual consistency, and more.</span></span>

<span data-ttu-id="4c0cc-341">Mnohem jednodušší [Referenční aplikace eShopOnWeb](https://github.com/dotnet-architecture/eShopOnWeb) podporuje použití kontejneru monolitické s jedním kontejnerem.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-341">The much simpler [eShopOnWeb reference application](https://github.com/dotnet-architecture/eShopOnWeb) supports single-container monolithic container usage.</span></span> <span data-ttu-id="4c0cc-342">Aplikace zahrnuje jednu webovou aplikaci, která zahrnuje tradiční zobrazení MVC, webová rozhraní API a Razor Pages.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-342">The application includes one web application that includes traditional MVC views, web APIs, and Razor Pages.</span></span> <span data-ttu-id="4c0cc-343">Tuto aplikaci lze spustit z kořene řešení pomocí `docker-compose build` `docker-compose up` příkazů a.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-343">This application can be launched from the solution root using the `docker-compose build` and `docker-compose up` commands.</span></span> <span data-ttu-id="4c0cc-344">Tento příkaz nakonfiguruje kontejner pro webovou instanci pomocí `Dockerfile` elementu nalezeného v kořenovém adresáři webového projektu a spustí kontejner na zadaném portu.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-344">This command configures a container for the web instance, using the `Dockerfile` found in the web project's root, and runs the container on a specified port.</span></span> <span data-ttu-id="4c0cc-345">Zdroj pro tuto aplikaci si můžete stáhnout z GitHubu a spustit místně.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-345">You can download the source for this application from GitHub and run it locally.</span></span> <span data-ttu-id="4c0cc-346">I tyto výhody aplikace v monolitické se nesadí do prostředí kontejneru.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-346">Even this monolithic application benefits from being deployed in a container environment.</span></span>

<span data-ttu-id="4c0cc-347">U jednoho z kontejnerových nasazení znamená, že každá instance aplikace běží ve stejném prostředí.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-347">For one, the containerized deployment means that every instance of the application runs in the same environment.</span></span> <span data-ttu-id="4c0cc-348">To zahrnuje vývojové prostředí, ve kterém se provádí předčasné testování a vývoj.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-348">This includes the developer environment where early testing and development take place.</span></span> <span data-ttu-id="4c0cc-349">Vývojový tým může spustit aplikaci v kontejnerovém prostředí, které odpovídá provoznímu prostředí.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-349">The development team can run the application in a containerized environment that matches the production environment.</span></span>

<span data-ttu-id="4c0cc-350">Kromě toho se v kontejnerových aplikacích naškálují snížení nákladů.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-350">In addition, containerized applications scale out at lower cost.</span></span> <span data-ttu-id="4c0cc-351">Použití prostředí kontejneru umožňuje větší sdílení prostředků než tradiční prostředí virtuálních počítačů.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-351">Using a container environment enables greater resource sharing than traditional VM environments.</span></span>

<span data-ttu-id="4c0cc-352">Nakonec uzavření aplikace vynutí oddělení mezi obchodní logikou a serverem úložiště.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-352">Finally, containerizing the application forces a separation between the business logic and the storage server.</span></span> <span data-ttu-id="4c0cc-353">Jak aplikace škáluje, budou se všechny kontejnery spoléhat na jedno fyzické paměťové médium.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-353">As the application scales out, the multiple containers will all rely on a single physical storage medium.</span></span> <span data-ttu-id="4c0cc-354">Toto paměťové médium by normálně představovalo Server s vysokou dostupností, na kterém běží databáze SQL Server.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-354">This storage medium would typically be a high-availability server running a SQL Server database.</span></span>

## <a name="docker-support"></a><span data-ttu-id="4c0cc-355">Podpora Docker</span><span class="sxs-lookup"><span data-stu-id="4c0cc-355">Docker support</span></span>

<span data-ttu-id="4c0cc-356">`eShopOnWeb`Projekt běží na .NET Core.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-356">The `eShopOnWeb` project runs on .NET Core.</span></span> <span data-ttu-id="4c0cc-357">Proto je možné jej spustit buď v kontejnerech se systémem Linux nebo Windows.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-357">Therefore, it can run in either Linux-based or Windows-based containers.</span></span> <span data-ttu-id="4c0cc-358">Všimněte si, že pro nasazení Docker chcete pro SQL Server použít stejný typ hostitele.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-358">Note that for Docker deployment, you want to use the same host type for SQL Server.</span></span> <span data-ttu-id="4c0cc-359">Kontejnery se systémem Linux umožňují menší nároky a jsou preferovány.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-359">Linux-based containers allow a smaller footprint and are preferred.</span></span>

<span data-ttu-id="4c0cc-360">Pomocí sady Visual Studio 2017 nebo novější můžete přidat podporu Docker do existující aplikace tak, že kliknete pravým tlačítkem na projekt v **Průzkumník řešení** a zvolíte **Přidat**  >  **podporu Docker**.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-360">You can use Visual Studio 2017 or later to add Docker support to an existing application by right-clicking on a project in **Solution Explorer** and choosing **Add** > **Docker Support**.</span></span> <span data-ttu-id="4c0cc-361">Tím se přidají potřebné soubory a aplikace se upraví tak, aby se používaly.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-361">This adds the files required and modifies the project to use them.</span></span> <span data-ttu-id="4c0cc-362">Aktuální `eShopOnWeb` Ukázka již má tyto soubory na místě.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-362">The current `eShopOnWeb` sample already has these files in place.</span></span>

<span data-ttu-id="4c0cc-363">Soubor na úrovni řešení `docker-compose.yml` obsahuje informace o tom, jaké obrázky se mají sestavit a jaké kontejnery se mají spustit.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-363">The solution-level `docker-compose.yml` file contains information about what images to build and what containers to launch.</span></span> <span data-ttu-id="4c0cc-364">Soubor umožňuje použít `docker-compose` příkaz ke spuštění více aplikací současně.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-364">The file allows you to use the `docker-compose` command to launch multiple applications at the same time.</span></span> <span data-ttu-id="4c0cc-365">V tomto případě se spouští pouze webový projekt.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-365">In this case, it is only launching the Web project.</span></span> <span data-ttu-id="4c0cc-366">Můžete ji také použít ke konfiguraci závislostí, například samostatného kontejneru databáze.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-366">You can also use it to configure dependencies, such as a separate database container.</span></span>

```yml
version: '3'

services:
  eshopwebmvc:
    image: eshopwebmvc
    build:
      context: .
      dockerfile: src/Web/Dockerfile
    environment:
      - ASPNETCORE_ENVIRONMENT=Development
    ports:
      - "5106:5106"

networks:
  default:
    external:
      name: nat
```

<span data-ttu-id="4c0cc-367">`docker-compose.yml`Soubor odkazuje na `Dockerfile` v `Web` projektu.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-367">The `docker-compose.yml` file references the `Dockerfile` in the `Web` project.</span></span> <span data-ttu-id="4c0cc-368">`Dockerfile`Slouží k určení, který základní kontejner bude použit a jakým způsobem bude aplikace konfigurována.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-368">The `Dockerfile` is used to specify which base container will be used and how the application will be configured on it.</span></span> <span data-ttu-id="4c0cc-369">`Web` `Dockerfile` :</span><span class="sxs-lookup"><span data-stu-id="4c0cc-369">The `Web`' `Dockerfile`:</span></span>

```Dockerfile
FROM mcr.microsoft.com/dotnet/core/sdk:3.1 AS build
WORKDIR /app

COPY *.sln .
COPY . .
WORKDIR /app/src/Web
RUN dotnet restore

RUN dotnet publish -c Release -o out

FROM mcr.microsoft.com/dotnet/core/aspnet:3.1 AS runtime
WORKDIR /app
COPY --from=build /app/src/Web/out ./

ENTRYPOINT ["dotnet", "Web.dll"]
```

### <a name="troubleshooting-docker-problems"></a><span data-ttu-id="4c0cc-370">Řešení potíží s Docker</span><span class="sxs-lookup"><span data-stu-id="4c0cc-370">Troubleshooting Docker problems</span></span>

<span data-ttu-id="4c0cc-371">Po spuštění kontejnerové aplikace bude nadále běžet, dokud ji nezastavíte.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-371">Once you run the containerized application, it continues to run until you stop it.</span></span> <span data-ttu-id="4c0cc-372">Pomocí příkazu můžete zobrazit kontejnery, které jsou spuštěny `docker ps` .</span><span class="sxs-lookup"><span data-stu-id="4c0cc-372">You can view which containers are running with the `docker ps` command.</span></span> <span data-ttu-id="4c0cc-373">Běžící kontejner můžete zastavit pomocí `docker stop` příkazu a zadáním ID kontejneru.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-373">You can stop a running container by using the `docker stop` command and specifying the container ID.</span></span>

<span data-ttu-id="4c0cc-374">Všimněte si, že spuštěné kontejnery Docker mohou být vázány na porty, které můžete jinak zkusit použít ve vašem vývojovém prostředí.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-374">Note that running Docker containers may be bound to ports you might otherwise try to use in your development environment.</span></span> <span data-ttu-id="4c0cc-375">Pokud se pokusíte spustit nebo ladit aplikaci pomocí stejného portu jako běžícího kontejneru Docker, zobrazí se chyba s oznámením, že se server nemůže přivážet k tomuto portu.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-375">If you try to run or debug an application using the same port as a running Docker container, you'll get an error stating that the server can't bind to that port.</span></span> <span data-ttu-id="4c0cc-376">Poté by se měl tento problém vyřešit zastavením kontejneru.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-376">Once again, stopping the container should resolve the issue.</span></span>

<span data-ttu-id="4c0cc-377">Pokud chcete přidat podporu Docker do aplikace pomocí sady Visual Studio, ujistěte se, že je na něm spuštěný Docker Desktop.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-377">If you want to add Docker support to your application using Visual Studio, make sure Docker Desktop is running when you do so.</span></span> <span data-ttu-id="4c0cc-378">Průvodce nebude správně fungovat, pokud při spuštění Průvodce neběží dokovací plocha.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-378">The wizard won't run correctly if Docker Desktop isn't running when you start the wizard.</span></span> <span data-ttu-id="4c0cc-379">Kromě toho průvodce prověřuje aktuální možnost kontejneru a přidá správnou podporu Docker.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-379">In addition, the wizard examines your current container choice to add the correct Docker support.</span></span> <span data-ttu-id="4c0cc-380">Pokud chcete přidat podporu pro kontejnery Windows, musíte spustit průvodce, když máte na počítači Docker běžící s nakonfigurovanými kontejnery Windows.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-380">If you want to add support for Windows Containers, you need to run the wizard while you have Docker Desktop running with Windows Containers configured.</span></span> <span data-ttu-id="4c0cc-381">Pokud chcete přidat podporu pro kontejnery pro Linux, spusťte průvodce, když máte k dispozici Docker s nakonfigurovanými kontejnery systému Linux.</span><span class="sxs-lookup"><span data-stu-id="4c0cc-381">If you want to add support for Linux containers, run the wizard while you have Docker running with Linux containers configured.</span></span>

### <a name="references--common-web-architectures"></a><span data-ttu-id="4c0cc-382">Odkazy – společné webové architektury</span><span class="sxs-lookup"><span data-stu-id="4c0cc-382">References – Common web architectures</span></span>

- <span data-ttu-id="4c0cc-383">**Čistá architektura**</span><span class="sxs-lookup"><span data-stu-id="4c0cc-383">**The Clean Architecture**</span></span>  
  <https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html>
- <span data-ttu-id="4c0cc-384">**Průsvitky**</span><span class="sxs-lookup"><span data-stu-id="4c0cc-384">**The Onion Architecture**</span></span>  
  <https://jeffreypalermo.com/blog/the-onion-architecture-part-1/>
- <span data-ttu-id="4c0cc-385">**Vzor úložiště**</span><span class="sxs-lookup"><span data-stu-id="4c0cc-385">**The Repository Pattern**</span></span>  
  <https://deviq.com/repository-pattern/>
- <span data-ttu-id="4c0cc-386">**Šablona řešení pro čištění architektury**</span><span class="sxs-lookup"><span data-stu-id="4c0cc-386">**Clean Architecture Solution Template**</span></span>  
  <https://github.com/ardalis/cleanarchitecture>
- <span data-ttu-id="4c0cc-387">**Elektronická kniha – architekti mikroslužeb**</span><span class="sxs-lookup"><span data-stu-id="4c0cc-387">**Architecting Microservices e-book**</span></span>  
  <https://aka.ms/MicroservicesEbook>
- <span data-ttu-id="4c0cc-388">**DDD (návrh založený na doméně)**</span><span class="sxs-lookup"><span data-stu-id="4c0cc-388">**DDD (Domain-Driven Design)**</span></span>  
  <https://docs.microsoft.com/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/>

>[!div class="step-by-step"]
><span data-ttu-id="4c0cc-389">[Předchozí](architectural-principles.md) 
> [Další](common-client-side-web-technologies.md)</span><span class="sxs-lookup"><span data-stu-id="4c0cc-389">[Previous](architectural-principles.md)
[Next](common-client-side-web-technologies.md)</span></span>
