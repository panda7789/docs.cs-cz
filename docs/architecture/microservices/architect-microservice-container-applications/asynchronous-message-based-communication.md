---
title: Asynchronní komunikace založená na zprávách
description: Architektura mikroslužeb .NET pro kontejnerizované aplikace .NET | Asynchronní komunikace založená na zprávuje základní koncept v architektuře mikroslužeb, protože je to nejlepší způsob, jak zachovat mikroslužeb nezávislé na sobě a zároveň je synchronizován nakonec.
ms.date: 09/20/2018
ms.openlocfilehash: 84eaf70178cce91a86dae8a55badb0b4ddd6a7c1
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 03/14/2020
ms.locfileid: "73454230"
---
# <a name="asynchronous-message-based-communication"></a><span data-ttu-id="bac7d-103">Asynchronní komunikace založená na zprávách</span><span class="sxs-lookup"><span data-stu-id="bac7d-103">Asynchronous message-based communication</span></span>

<span data-ttu-id="bac7d-104">Asynchronní zasílání zpráv a komunikace řízená událostmi jsou důležité při šíření změn mezi více mikroslužeb a jejich souvisejících modelů domén.</span><span class="sxs-lookup"><span data-stu-id="bac7d-104">Asynchronous messaging and event-driven communication are critical when propagating changes across multiple microservices and their related domain models.</span></span> <span data-ttu-id="bac7d-105">Jak již bylo zmíněno dříve v diskusi mikroslužeb a ohraničené kontexty (BCs), modely (uživatel, zákazník, produkt, účet atd.) může znamenat různé věci pro různé mikroslužeb nebo BC.</span><span class="sxs-lookup"><span data-stu-id="bac7d-105">As mentioned earlier in the discussion microservices and Bounded Contexts (BCs), models (User, Customer, Product, Account, etc.) can mean different things to different microservices or BCs.</span></span> <span data-ttu-id="bac7d-106">To znamená, že když dojde ke změnám, potřebujete nějaký způsob, jak sladit změny mezi různými modely.</span><span class="sxs-lookup"><span data-stu-id="bac7d-106">That means that when changes occur, you need some way to reconcile changes across the different models.</span></span> <span data-ttu-id="bac7d-107">Řešením je případná konzistence a komunikace založená na událostech na základě asynchronního zasílání zpráv.</span><span class="sxs-lookup"><span data-stu-id="bac7d-107">A solution is eventual consistency and event-driven communication based on asynchronous messaging.</span></span>

<span data-ttu-id="bac7d-108">Při použití zasílání zpráv procesy komunikovat prostřednictvím výměny zpráv asynchronně.</span><span class="sxs-lookup"><span data-stu-id="bac7d-108">When using messaging, processes communicate by exchanging messages asynchronously.</span></span> <span data-ttu-id="bac7d-109">Klient provede příkaz nebo požadavek na službu odesláním zprávy.</span><span class="sxs-lookup"><span data-stu-id="bac7d-109">A client makes a command or a request to a service by sending it a message.</span></span> <span data-ttu-id="bac7d-110">Pokud služba potřebuje odpovědět, odešle klientovi jinou zprávu.</span><span class="sxs-lookup"><span data-stu-id="bac7d-110">If the service needs to reply, it sends a different message back to the client.</span></span> <span data-ttu-id="bac7d-111">Vzhledem k tomu, že se jedná o komunikaci založenou na zprávě, klient předpokládá, že odpověď nebude přijata okamžitě a že nemusí existovat žádná odpověď vůbec.</span><span class="sxs-lookup"><span data-stu-id="bac7d-111">Since it's a message-based communication, the client assumes that the reply won't be received immediately, and that there might be no response at all.</span></span>

<span data-ttu-id="bac7d-112">Zpráva se skládá z hlavičky (metadata, jako jsou identifikační nebo bezpečnostní informace) a tělo.</span><span class="sxs-lookup"><span data-stu-id="bac7d-112">A message is composed by a header (metadata such as identification or security information) and a body.</span></span> <span data-ttu-id="bac7d-113">Zprávy jsou obvykle odesílány prostřednictvím asynchronních protokolů, jako je AMQP.</span><span class="sxs-lookup"><span data-stu-id="bac7d-113">Messages are usually sent through asynchronous protocols like AMQP.</span></span>

<span data-ttu-id="bac7d-114">Upřednostňovaná infrastruktura pro tento typ komunikace v komunitě mikroslužeb je zjednodušené zprostředkovatele zpráv, který se liší od velkých zprostředkovatelů a orchestrátorů používaných v SOA.</span><span class="sxs-lookup"><span data-stu-id="bac7d-114">The preferred infrastructure for this type of communication in the microservices community is a lightweight message broker, which is different than the large brokers and orchestrators used in SOA.</span></span> <span data-ttu-id="bac7d-115">V zprostředkovateli lehkých zpráv infrastruktury je obvykle "němý", funguje pouze jako zprostředkovatel zpráv, s jednoduché implementace, jako je RabbitMQ nebo škálovatelné sběrnice v cloudu, jako je Azure Service Bus.</span><span class="sxs-lookup"><span data-stu-id="bac7d-115">In a lightweight message broker, the infrastructure is typically "dumb," acting only as a message broker, with simple implementations such as RabbitMQ or a scalable service bus in the cloud like Azure Service Bus.</span></span> <span data-ttu-id="bac7d-116">V tomto scénáři většina "inteligentní" myšlení stále žije v koncových bodech, které jsou vytváření a spotřebovává zprávy, které je v mikroslužeb.</span><span class="sxs-lookup"><span data-stu-id="bac7d-116">In this scenario, most of the "smart" thinking still lives in the endpoints that are producing and consuming messages-that is, in the microservices.</span></span>

<span data-ttu-id="bac7d-117">Dalším pravidlem, které byste se měli snažit co nejvíce dodržovat, je používat pouze asynchronní zasílání zpráv mezi interními službami a používat synchronní komunikaci (například HTTP) pouze z klientských aplikací do front-endových služeb (brány rozhraní API plus první úroveň mikroslužeb).</span><span class="sxs-lookup"><span data-stu-id="bac7d-117">Another rule you should try to follow, as much as possible, is to use only asynchronous messaging between the internal services, and to use synchronous communication (such as HTTP) only from the client apps to the front-end services (API Gateways plus the first level of microservices).</span></span>

<span data-ttu-id="bac7d-118">Existují dva druhy asynchronní komunikace zasílání zpráv: komunikace založená na zprávách jednoho příjemce a komunikace založená na zprávách více příjemců.</span><span class="sxs-lookup"><span data-stu-id="bac7d-118">There are two kinds of asynchronous messaging communication: single receiver message-based communication, and multiple receivers message-based communication.</span></span> <span data-ttu-id="bac7d-119">V následujících částech jsou uvedeny podrobnosti o nich.</span><span class="sxs-lookup"><span data-stu-id="bac7d-119">The following sections provide details about them.</span></span>

## <a name="single-receiver-message-based-communication"></a><span data-ttu-id="bac7d-120">Komunikace založená na zprávě s jedním přijímačem</span><span class="sxs-lookup"><span data-stu-id="bac7d-120">Single-receiver message-based communication</span></span>

<span data-ttu-id="bac7d-121">Asynchronní komunikace založená na zprávě s jedním příjemcem znamená, že je komunikace point-to-point, která doručuje zprávu přesně jednomu z příjemců, který čte z kanálu, a že zpráva je zpracována pouze jednou.</span><span class="sxs-lookup"><span data-stu-id="bac7d-121">Message-based asynchronous communication with a single receiver means there's point-to-point communication that delivers a message to exactly one of the consumers that's reading from the channel, and that the message is processed just once.</span></span> <span data-ttu-id="bac7d-122">Existují však zvláštní situace.</span><span class="sxs-lookup"><span data-stu-id="bac7d-122">However, there are special situations.</span></span> <span data-ttu-id="bac7d-123">Například v cloudovém systému, který se snaží automaticky zotavit z chyb, může být stejná zpráva odeslána vícekrát.</span><span class="sxs-lookup"><span data-stu-id="bac7d-123">For instance, in a cloud system that tries to automatically recover from failures, the same message could be sent multiple times.</span></span> <span data-ttu-id="bac7d-124">Z důvodu sítě nebo jiných selhání musí být klient schopen opakovat odesílání zpráv a server musí implementovat operaci, která má být idempotentní, aby bylo možné zpracovat konkrétní zprávu pouze jednou.</span><span class="sxs-lookup"><span data-stu-id="bac7d-124">Due to network or other failures, the client has to be able to retry sending messages, and the server has to implement an operation to be idempotent in order to process a particular message just once.</span></span>

<span data-ttu-id="bac7d-125">Komunikace založená na zprávě s jedním přijímačem je obzvláště vhodná pro odesílání asynchronních příkazů z jedné mikroslužby do druhé, jak je znázorněno na obrázku 4-18, který ilustruje tento přístup.</span><span class="sxs-lookup"><span data-stu-id="bac7d-125">Single-receiver message-based communication is especially well suited for sending asynchronous commands from one microservice to another as shown in Figure 4-18 that illustrates this approach.</span></span>

<span data-ttu-id="bac7d-126">Jakmile začnete odesílat komunikaci založenou na zprávě (buď s příkazy nebo událostmi), měli byste se vyhnout míchání komunikace založené na zprávě se synchronní komunikací HTTP.</span><span class="sxs-lookup"><span data-stu-id="bac7d-126">Once you start sending message-based communication (either with commands or events), you should avoid mixing message-based communication with synchronous HTTP communication.</span></span>

![Jedna mikroslužba přijímající asynchronní zprávu](./media/asynchronous-message-based-communication/single-receiver-message-based-communication.png)

<span data-ttu-id="bac7d-128">**Obrázek 4-18**.</span><span class="sxs-lookup"><span data-stu-id="bac7d-128">**Figure 4-18**.</span></span> <span data-ttu-id="bac7d-129">Jedna mikroslužba přijímající asynchronní zprávu</span><span class="sxs-lookup"><span data-stu-id="bac7d-129">A single microservice receiving an asynchronous message</span></span>

<span data-ttu-id="bac7d-130">Všimněte si, že když příkazy pocházejí z klientských aplikací, mohou být implementovány jako synchronní příkazy HTTP.</span><span class="sxs-lookup"><span data-stu-id="bac7d-130">Note that when the commands come from client applications, they can be implemented as HTTP synchronous commands.</span></span> <span data-ttu-id="bac7d-131">Příkazy založené na zprávach byste měli používat, když potřebujete vyšší škálovatelnost nebo když už jste v obchodním procesu založeném na zprávě.</span><span class="sxs-lookup"><span data-stu-id="bac7d-131">You should use message-based commands when you need higher scalability or when you're already in a message-based business process.</span></span>

## <a name="multiple-receivers-message-based-communication"></a><span data-ttu-id="bac7d-132">Více přijímačů komunikace založená na textech</span><span class="sxs-lookup"><span data-stu-id="bac7d-132">Multiple-receivers message-based communication</span></span>

<span data-ttu-id="bac7d-133">Jako flexibilnější přístup můžete také použít mechanismus publikování/odběru tak, aby vaše komunikace od odesílatele bude k dispozici další mikroslužeb odběratele nebo externí aplikace.</span><span class="sxs-lookup"><span data-stu-id="bac7d-133">As a more flexible approach, you might also want to use a publish/subscribe mechanism so that your communication from the sender will be available to additional subscriber microservices or to external applications.</span></span> <span data-ttu-id="bac7d-134">Proto vám pomáhá dodržovat [princip otevření/uzavření](https://en.wikipedia.org/wiki/Open/closed_principle) v odesílající službě.</span><span class="sxs-lookup"><span data-stu-id="bac7d-134">Thus, it helps you to follow the [open/closed principle](https://en.wikipedia.org/wiki/Open/closed_principle) in the sending service.</span></span> <span data-ttu-id="bac7d-135">Tímto způsobem další předplatitelé mohou být přidány v budoucnu bez nutnosti měnit službu odesílatele.</span><span class="sxs-lookup"><span data-stu-id="bac7d-135">That way, additional subscribers can be added in the future without the need to modify the sender service.</span></span>

<span data-ttu-id="bac7d-136">Při použití publikování nebo odběru komunikace, můžete používat rozhraní sběrnice událostí publikovat události pro všechny odběratele.</span><span class="sxs-lookup"><span data-stu-id="bac7d-136">When you use a publish/subscribe communication, you might be using an event bus interface to publish events to any subscriber.</span></span>

## <a name="asynchronous-event-driven-communication"></a><span data-ttu-id="bac7d-137">Asynchronní komunikace řízená událostmi</span><span class="sxs-lookup"><span data-stu-id="bac7d-137">Asynchronous event-driven communication</span></span>

<span data-ttu-id="bac7d-138">Při použití asynchronní komunikace řízené událostmi mikroslužba publikuje událost integrace, když se něco stane v rámci své domény a jiné mikroslužby musí být vědomi, jako je změna ceny v katalogu produktů mikroslužeb.</span><span class="sxs-lookup"><span data-stu-id="bac7d-138">When using asynchronous event-driven communication, a microservice publishes an integration event when something happens within its domain and another microservice needs to be aware of it, like a price change in a product catalog microservice.</span></span> <span data-ttu-id="bac7d-139">Další mikroslužby přihlásit k odběru událostí, aby je můžete přijímat asynchronně.</span><span class="sxs-lookup"><span data-stu-id="bac7d-139">Additional microservices subscribe to the events so they can receive them asynchronously.</span></span> <span data-ttu-id="bac7d-140">V takovém případě mohou příjemci aktualizovat své vlastní entity domény, což může způsobit publikování dalších událostí integrace.</span><span class="sxs-lookup"><span data-stu-id="bac7d-140">When that happens, the receivers might update their own domain entities, which can cause more integration events to be published.</span></span> <span data-ttu-id="bac7d-141">Tento systém publikování/odběru se obvykle provádí pomocí implementace sběrnice událostí.</span><span class="sxs-lookup"><span data-stu-id="bac7d-141">This publish/subscribe system is usually performed by using an implementation of an event bus.</span></span> <span data-ttu-id="bac7d-142">Sběrnice událostí může být navržena jako abstrakce nebo rozhraní s rozhraním API, které je potřeba k přihlášení k odběru nebo odhlášení z odběru událostí a publikování událostí.</span><span class="sxs-lookup"><span data-stu-id="bac7d-142">The event bus can be designed as an abstraction or interface, with the API that's needed to subscribe or unsubscribe to events and to publish events.</span></span> <span data-ttu-id="bac7d-143">Sběrnice událostí může mít také jednu nebo více implementací založených na jakémkoli zprostředkovateli mezi procesy a zasílání zpráv, jako je fronta zpráv nebo sběrnice služby, která podporuje asynchronní komunikaci a model publikování/odběru.</span><span class="sxs-lookup"><span data-stu-id="bac7d-143">The event bus can also have one or more implementations based on any inter-process and messaging broker, like a messaging queue or service bus that supports asynchronous communication and a publish/subscribe model.</span></span>

<span data-ttu-id="bac7d-144">Pokud systém používá konečnou konzistenci řízenou událostmi integrace, doporučuje se, aby byl tento přístup koncovému uživateli zcela jasný.</span><span class="sxs-lookup"><span data-stu-id="bac7d-144">If a system uses eventual consistency driven by integration events, it's recommended that this approach is made completely clear to the end user.</span></span> <span data-ttu-id="bac7d-145">Systém by neměl používat přístup, který napodobuje události integrace, jako je SignalR nebo dotazování systémy z klienta.</span><span class="sxs-lookup"><span data-stu-id="bac7d-145">The system shouldn't use an approach that mimics integration events, like SignalR or polling systems from the client.</span></span> <span data-ttu-id="bac7d-146">Koncový uživatel a vlastník firmy musí explicitně přijmout konečnou konzistenci v systému a uvědomit si, že v mnoha případech podnikání nemá žádný problém s tímto přístupem, pokud je to explicitní.</span><span class="sxs-lookup"><span data-stu-id="bac7d-146">The end user and the business owner have to explicitly embrace eventual consistency in the system and realize that in many cases the business doesn't have any problem with this approach, as long as it's explicit.</span></span> <span data-ttu-id="bac7d-147">To je důležité, protože uživatelé mohou očekávat, že některé výsledky okamžitě a to nemusí dojít s konečnou konzistenci.</span><span class="sxs-lookup"><span data-stu-id="bac7d-147">This is important because users might expect to see some results immediately and this might not happen with eventual consistency.</span></span>

<span data-ttu-id="bac7d-148">Jak je uvedeno dříve v [části Výzvy a řešení pro správu distribuovaných dat,](distributed-data-management.md) můžete použít události integrace k implementaci obchodních úkolů, které pokrývají více mikroslužeb.</span><span class="sxs-lookup"><span data-stu-id="bac7d-148">As noted earlier in the [Challenges and solutions for distributed data management](distributed-data-management.md) section, you can use integration events to implement business tasks that span multiple microservices.</span></span> <span data-ttu-id="bac7d-149">Proto budete mít konečný soulad mezi těmito službami.</span><span class="sxs-lookup"><span data-stu-id="bac7d-149">Thus, you'll have eventual consistency between those services.</span></span> <span data-ttu-id="bac7d-150">Nakonec konzistentní transakce se skládá z kolekce distribuovaných akcí.</span><span class="sxs-lookup"><span data-stu-id="bac7d-150">An eventually consistent transaction is made up of a collection of distributed actions.</span></span> <span data-ttu-id="bac7d-151">Při každé akci související mikroslužby aktualizuje entitu domény a publikuje další událost integrace, která vyvolá další akci v rámci stejného obchodního úkolu od konce do konce.</span><span class="sxs-lookup"><span data-stu-id="bac7d-151">At each action, the related microservice updates a domain entity and publishes another integration event that raises the next action within the same end-to-end business task.</span></span>

<span data-ttu-id="bac7d-152">Důležitým bodem je, že můžete chtít komunikovat s více mikroslužeb, které jsou přihlášeni ke stejné události.</span><span class="sxs-lookup"><span data-stu-id="bac7d-152">An important point is that you might want to communicate to multiple microservices that are subscribed to the same event.</span></span> <span data-ttu-id="bac7d-153">Chcete-li tak učinit, můžete použít publikování nebo odběru zpráv na základě komunikace řízené událostmi, jak je znázorněno na obrázku 4-19.</span><span class="sxs-lookup"><span data-stu-id="bac7d-153">To do so, you can use publish/subscribe messaging based on event-driven communication, as shown in Figure 4-19.</span></span> <span data-ttu-id="bac7d-154">Tento mechanismus publikování/odběru není výhradní architekturou mikroslužeb.</span><span class="sxs-lookup"><span data-stu-id="bac7d-154">This publish/subscribe mechanism isn't exclusive to the microservice architecture.</span></span> <span data-ttu-id="bac7d-155">Je to podobné jako [ohraničené kontexty](https://martinfowler.com/bliki/BoundedContext.html) v DDD by měl komunikovat, nebo způsob, jakým šíření aktualizací z databáze zápisu do databáze pro čtení v [příkazu a dotazu odpovědnost i gregace (CQRS)](https://martinfowler.com/bliki/CQRS.html) architektura vzor.</span><span class="sxs-lookup"><span data-stu-id="bac7d-155">It's similar to the way [Bounded Contexts](https://martinfowler.com/bliki/BoundedContext.html) in DDD should communicate, or to the way you propagate updates from the write database to the read database in the [Command and Query Responsibility Segregation (CQRS)](https://martinfowler.com/bliki/CQRS.html) architecture pattern.</span></span> <span data-ttu-id="bac7d-156">Cílem je mít konečnou konzistenci mezi více zdroji dat v celém distribuovaném systému.</span><span class="sxs-lookup"><span data-stu-id="bac7d-156">The goal is to have eventual consistency between multiple data sources across your distributed system.</span></span>

![Diagram znázorňující asynchronní komunikaci řízenou událostmi.](./media/asynchronous-message-based-communication/asynchronous-event-driven-communication.png)

<span data-ttu-id="bac7d-158">**Obrázek 4-19**.</span><span class="sxs-lookup"><span data-stu-id="bac7d-158">**Figure 4-19**.</span></span> <span data-ttu-id="bac7d-159">Asynchronní komunikace zpráv řízená událostmi</span><span class="sxs-lookup"><span data-stu-id="bac7d-159">Asynchronous event-driven message communication</span></span>

<span data-ttu-id="bac7d-160">V komunikaci řízené asynchronní události jeden mikroslužba publikuje události do sběrnice událostí a mnoho mikroslužeb můžete přihlásit k odběru, získat oznámení a jednat na to.</span><span class="sxs-lookup"><span data-stu-id="bac7d-160">In asynchronous event-driven communication one microservice publishes events to an event bus and many microservices can subscribe to it, to get notified and act on it.</span></span> <span data-ttu-id="bac7d-161">Vaše implementace určí, jaký protokol se má použít pro komunikaci založenou na událostech a zprávách.</span><span class="sxs-lookup"><span data-stu-id="bac7d-161">Your implementation will determine what protocol to use for event-driven, message-based communications.</span></span> <span data-ttu-id="bac7d-162">[AMQP](https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol) může pomoci dosáhnout spolehlivé komunikace ve frontě.</span><span class="sxs-lookup"><span data-stu-id="bac7d-162">[AMQP](https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol) can help achieve reliable queued communication.</span></span>

<span data-ttu-id="bac7d-163">Při použití sběrnice událostí můžete chtít použít úroveň abstrakce (například rozhraní sběrnice událostí) na základě související implementace ve třídách s kódem pomocí rozhraní API z brokeru zpráv, jako je [RabbitMQ](https://www.rabbitmq.com/) nebo service bus, jako je [Azure Service Bus s tématy](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions).</span><span class="sxs-lookup"><span data-stu-id="bac7d-163">When you use an event bus, you might want to use an abstraction level (like an event bus interface) based on a related implementation in classes with code using the API from a message broker like [RabbitMQ](https://www.rabbitmq.com/) or a service bus like [Azure Service Bus with Topics](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions).</span></span> <span data-ttu-id="bac7d-164">Případně můžete chtít použít vyšší úroveň sběrnice, jako je NServiceBus, MassTransit nebo Brighter, k formulování sběrnice událostí a publikování/odběru systému.</span><span class="sxs-lookup"><span data-stu-id="bac7d-164">Alternatively, you might want to use a higher-level service bus like NServiceBus, MassTransit, or Brighter to articulate your event bus and publish/subscribe system.</span></span>

## <a name="a-note-about-messaging-technologies-for-production-systems"></a><span data-ttu-id="bac7d-165">Poznámka o technologiích zasílání zpráv pro produkční systémy</span><span class="sxs-lookup"><span data-stu-id="bac7d-165">A note about messaging technologies for production systems</span></span>

<span data-ttu-id="bac7d-166">Technologie zasílání zpráv, které jsou k dispozici pro implementaci sběrnice abstraktních událostí, jsou na různých úrovních.</span><span class="sxs-lookup"><span data-stu-id="bac7d-166">The messaging technologies available for implementing your abstract event bus are at different levels.</span></span> <span data-ttu-id="bac7d-167">Například produkty jako RabbitMQ (přenos zprostředkovatele zasílání zpráv) a Azure Service Bus jsou na nižší úrovni než jiné produkty, jako je NServiceBus, MassTransit nebo Brighter, které můžou fungovat na rabbitmq a Azure Service Bus.</span><span class="sxs-lookup"><span data-stu-id="bac7d-167">For instance, products like RabbitMQ (a messaging broker transport) and Azure Service Bus sit at a lower level than other products like, NServiceBus, MassTransit, or Brighter, which can work on top of RabbitMQ and Azure Service Bus.</span></span> <span data-ttu-id="bac7d-168">Vaše volba závisí na tom, kolik bohatých funkcí na úrovni aplikace a out-of-the-box škálovatelnost, kterou potřebujete pro vaši aplikaci.</span><span class="sxs-lookup"><span data-stu-id="bac7d-168">Your choice depends on how many rich features at the application level and out-of-the-box scalability you need for your application.</span></span> <span data-ttu-id="bac7d-169">Pro implementaci pouze proof-of-concept sběrnice událostí pro vaše vývojové prostředí, jak to bylo provedeno v eShopOnContainers vzorku, jednoduchá implementace na vrcholu RabbitMQ běží na kontejneru Dockeru může stačit.</span><span class="sxs-lookup"><span data-stu-id="bac7d-169">For implementing just a proof-of-concept event bus for your development environment, as it was done in the eShopOnContainers sample, a simple implementation on top of RabbitMQ running on a Docker container might be enough.</span></span>

<span data-ttu-id="bac7d-170">Pro kritické a produkční systémy, které potřebují hyperškálovatelnost, však můžete chtít vyhodnotit Azure Service Bus.</span><span class="sxs-lookup"><span data-stu-id="bac7d-170">However, for mission-critical and production systems that need hyper-scalability, you might want to evaluate Azure Service Bus.</span></span> <span data-ttu-id="bac7d-171">Pro vysoké úrovně abstrakce a funkce, které usnadňují vývoj distribuovaných aplikací, doporučujeme vyhodnotit další komerční a open source servisní sběrnice, jako je Například NServiceBus, MassTransit a Brighter.</span><span class="sxs-lookup"><span data-stu-id="bac7d-171">For high-level abstractions and features that make the development of distributed applications easier, we recommend that you evaluate other commercial and open-source service buses, such as NServiceBus, MassTransit, and Brighter.</span></span> <span data-ttu-id="bac7d-172">Samozřejmě můžete vytvořit vlastní funkce service-bus na nižší úrovni technologií, jako je RabbitMQ a Docker.</span><span class="sxs-lookup"><span data-stu-id="bac7d-172">Of course, you can build your own service-bus features on top of lower-level technologies like RabbitMQ and Docker.</span></span> <span data-ttu-id="bac7d-173">Ale že instalatérské práce může stát příliš mnoho pro vlastní podnikové aplikace.</span><span class="sxs-lookup"><span data-stu-id="bac7d-173">But that plumbing work might cost too much for a custom enterprise application.</span></span>

## <a name="resiliently-publishing-to-the-event-bus"></a><span data-ttu-id="bac7d-174">Odolné publikování na sběrnici událostí</span><span class="sxs-lookup"><span data-stu-id="bac7d-174">Resiliently publishing to the event bus</span></span>

<span data-ttu-id="bac7d-175">Výzvou při implementaci architektury řízené událostmi napříč více mikroslužbami je, jak atomicky aktualizovat stav v původní mikroslužbě a zároveň odolně publikovat související integrační událost do sběrnice událostí, jaksi na základě Transakce.</span><span class="sxs-lookup"><span data-stu-id="bac7d-175">A challenge when implementing an event-driven architecture across multiple microservices is how to atomically update state in the original microservice while resiliently publishing its related integration event into the event bus, somehow based on transactions.</span></span> <span data-ttu-id="bac7d-176">Následuje několik způsobů, jak toho dosáhnout, i když by mohly být další přístupy také.</span><span class="sxs-lookup"><span data-stu-id="bac7d-176">The following are a few ways to accomplish this, although there could be additional approaches as well.</span></span>

- <span data-ttu-id="bac7d-177">Použití transakční fronty (založené na DTC), jako je služba MSMQ.</span><span class="sxs-lookup"><span data-stu-id="bac7d-177">Using a transactional (DTC-based) queue like MSMQ.</span></span> <span data-ttu-id="bac7d-178">(Jedná se však o starší přístup.)</span><span class="sxs-lookup"><span data-stu-id="bac7d-178">(However, this is a legacy approach.)</span></span>

- <span data-ttu-id="bac7d-179">Použití [dolování transakční protokol](https://www.scoop.it/t/sql-server-transaction-log-mining).</span><span class="sxs-lookup"><span data-stu-id="bac7d-179">Using [transaction log mining](https://www.scoop.it/t/sql-server-transaction-log-mining).</span></span>

- <span data-ttu-id="bac7d-180">Použití [úplného](https://docs.microsoft.com/azure/architecture/patterns/event-sourcing) vzoru získávání událostí.</span><span class="sxs-lookup"><span data-stu-id="bac7d-180">Using full [Event Sourcing](https://docs.microsoft.com/azure/architecture/patterns/event-sourcing) pattern.</span></span>

- <span data-ttu-id="bac7d-181">Použití [vzoru Pošta k odeslání](https://www.kamilgrzybek.com/design/the-outbox-pattern/): transakční databázová tabulka jako fronta zpráv, která bude základem pro komponentu tvůrce událostí, která by vytvořila událost a publikovala ji.</span><span class="sxs-lookup"><span data-stu-id="bac7d-181">Using the [Outbox pattern](https://www.kamilgrzybek.com/design/the-outbox-pattern/): a transactional database table as a message queue that will be the base for an event-creator component that would create the event and publish it.</span></span>

<span data-ttu-id="bac7d-182">Další témata, která je třeba vzít v úvahu při použití asynchronní komunikace, jsou idempotence zprávy a odstranění duplicit zpráv.</span><span class="sxs-lookup"><span data-stu-id="bac7d-182">Additional topics to consider when using asynchronous communication are message idempotence and message deduplication.</span></span> <span data-ttu-id="bac7d-183">Tato témata jsou popsány v části [Implementace komunikace založené na událostech mezi mikroslužeb (události integrace)](../multi-container-microservice-net-applications/integration-event-based-microservice-communications.md) dále v této příručce.</span><span class="sxs-lookup"><span data-stu-id="bac7d-183">These topics are covered in the section [Implementing event-based communication between microservices (integration events)](../multi-container-microservice-net-applications/integration-event-based-microservice-communications.md) later in this guide.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="bac7d-184">Další zdroje</span><span class="sxs-lookup"><span data-stu-id="bac7d-184">Additional resources</span></span>

- <span data-ttu-id="bac7d-185">**Zasílání zpráv řízených událostmi** </span><span class="sxs-lookup"><span data-stu-id="bac7d-185">**Event Driven Messaging** </span></span>\
  <https://soapatterns.org/design_patterns/event_driven_messaging>

- <span data-ttu-id="bac7d-186">**Publikovat/odebírat kanál** </span><span class="sxs-lookup"><span data-stu-id="bac7d-186">**Publish/Subscribe Channel** </span></span>\
  <https://www.enterpriseintegrationpatterns.com/patterns/messaging/PublishSubscribeChannel.html>

- <span data-ttu-id="bac7d-187">**Udi Dahan. Vyjasněné CQRS** </span><span class="sxs-lookup"><span data-stu-id="bac7d-187">**Udi Dahan. Clarified CQRS** </span></span>\
  <http://udidahan.com/2009/12/09/clarified-cqrs/>

- <span data-ttu-id="bac7d-188">**Oddělení odpovědnosti příkazů a dotazů (CQRS)** </span><span class="sxs-lookup"><span data-stu-id="bac7d-188">**Command and Query Responsibility Segregation (CQRS)** </span></span>\
  <https://docs.microsoft.com/azure/architecture/patterns/cqrs>

- <span data-ttu-id="bac7d-189">**Komunikace mezi ohraničené kontexty** </span><span class="sxs-lookup"><span data-stu-id="bac7d-189">**Communicating Between Bounded Contexts** </span></span>\
  <https://docs.microsoft.com/previous-versions/msp-n-p/jj591572(v=pandp.10)>

- <span data-ttu-id="bac7d-190">**Konečná konzistence** </span><span class="sxs-lookup"><span data-stu-id="bac7d-190">**Eventual consistency** </span></span>\
  <https://en.wikipedia.org/wiki/Eventual_consistency>

- <span data-ttu-id="bac7d-191">**Jimmyho Bogarda. Refaktoring směrem k odolnosti: Hodnocení spojky** </span><span class="sxs-lookup"><span data-stu-id="bac7d-191">**Jimmy Bogard. Refactoring Towards Resilience: Evaluating Coupling** </span></span>\
  <https://jimmybogard.com/refactoring-towards-resilience-evaluating-coupling/>

> [!div class="step-by-step"]
> <span data-ttu-id="bac7d-192">[Předchozí](communication-in-microservice-architecture.md)
> [další](maintain-microservice-apis.md)</span><span class="sxs-lookup"><span data-stu-id="bac7d-192">[Previous](communication-in-microservice-architecture.md)
[Next](maintain-microservice-apis.md)</span></span>
