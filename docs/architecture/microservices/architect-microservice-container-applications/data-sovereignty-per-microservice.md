---
title: Svrchovanost dat v jednotlivých mikroslužbách
description: Suverenita dat na mikroslužbu je jedním z klíčových bodů mikroslužeb. Každá mikroslužba musí být jediným vlastníkem své databáze a sdílet ji s žádným jiným. Samozřejmě všechny instance mikroslužeb připojit ke stejné databázi s vysokou dostupností.
ms.date: 09/20/2018
ms.openlocfilehash: f606d6314f38bf3e2c163871af432806dddc7446
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 03/14/2020
ms.locfileid: "73191920"
---
# <a name="data-sovereignty-per-microservice"></a><span data-ttu-id="3f102-105">Svrchovanost dat v jednotlivých mikroslužbách</span><span class="sxs-lookup"><span data-stu-id="3f102-105">Data sovereignty per microservice</span></span>

<span data-ttu-id="3f102-106">Důležitým pravidlem pro architekturu mikroslužeb je, že každá mikroslužba musí vlastnit data a logiku své domény.</span><span class="sxs-lookup"><span data-stu-id="3f102-106">An important rule for microservices architecture is that each microservice must own its domain data and logic.</span></span> <span data-ttu-id="3f102-107">Stejně jako úplná aplikace vlastní svou logiku a data, tak musí každá mikroslužba vlastnit svou logiku a data v rámci autonomního životního cyklu, s nezávislým nasazením na mikroslužbu.</span><span class="sxs-lookup"><span data-stu-id="3f102-107">Just as a full application owns its logic and data, so must each microservice own its logic and data under an autonomous lifecycle, with independent deployment per microservice.</span></span>

<span data-ttu-id="3f102-108">To znamená, že koncepční model domény se bude lišit mezi subsystémy nebo mikroslužeb.</span><span class="sxs-lookup"><span data-stu-id="3f102-108">This means that the conceptual model of the domain will differ between subsystems or microservices.</span></span> <span data-ttu-id="3f102-109">Zvažte podnikové aplikace, kde aplikace pro řízení vztahů se zákazníky (CRM), subsystémy transakčních nákupů a subsystémy zákaznické podpory vyžadují atributy a data jedinečných entit zákazníka a kde každý z nich používá jiný Ohraničený kontext (BC).</span><span class="sxs-lookup"><span data-stu-id="3f102-109">Consider enterprise applications, where customer relationship management (CRM) applications, transactional purchase subsystems, and customer support subsystems each call on unique customer entity attributes and data, and where each employs a different Bounded Context (BC).</span></span>

<span data-ttu-id="3f102-110">Tento princip je podobný v [návrhu řízeném doménou (DDD)](https://en.wikipedia.org/wiki/Domain-driven_design), kde každý [ohraničený kontext](https://martinfowler.com/bliki/BoundedContext.html) nebo autonomní subsystém nebo služba musí vlastnit svůj model domény (data plus logiku a chování).</span><span class="sxs-lookup"><span data-stu-id="3f102-110">This principle is similar in [Domain-driven design (DDD)](https://en.wikipedia.org/wiki/Domain-driven_design), where each [Bounded Context](https://martinfowler.com/bliki/BoundedContext.html) or autonomous subsystem or service must own its domain model (data plus logic and behavior).</span></span> <span data-ttu-id="3f102-111">Každý kontext ohraničený DDD koreluje s jednou obchodní mikroslužbou (jednou nebo několika službami).</span><span class="sxs-lookup"><span data-stu-id="3f102-111">Each DDD Bounded Context correlates to one business microservice (one or several services).</span></span> <span data-ttu-id="3f102-112">Tento bod o ohraničeném kontextu vzor je rozbalen v další části.</span><span class="sxs-lookup"><span data-stu-id="3f102-112">This point about the Bounded Context pattern is expanded in the next section.</span></span>

<span data-ttu-id="3f102-113">Na druhou stranu tradiční (monolitická data) přístup používaný v mnoha aplikacích je mít jednu centralizovanou databázi nebo jen několik databází.</span><span class="sxs-lookup"><span data-stu-id="3f102-113">On the other hand, the traditional (monolithic data) approach used in many applications is to have a single centralized database or just a few databases.</span></span> <span data-ttu-id="3f102-114">Toto je často normalizovaná databáze SQL, která se používá pro celou aplikaci a všechny její vnitřní subsystémy, jak je znázorněno na obrázku 4-7.</span><span class="sxs-lookup"><span data-stu-id="3f102-114">This is often a normalized SQL database that's used for the whole application and all its internal subsystems, as shown in Figure 4-7.</span></span>

![Diagram znázorňující dva přístupy databáze.](./media/data-sovereignty-per-microservice/data-sovereignty-comparison.png)

<span data-ttu-id="3f102-116">**Obrázek 4-7**.</span><span class="sxs-lookup"><span data-stu-id="3f102-116">**Figure 4-7**.</span></span> <span data-ttu-id="3f102-117">Porovnání suverenity dat: monolitická databáze versus mikroslužby</span><span class="sxs-lookup"><span data-stu-id="3f102-117">Data sovereignty comparison: monolithic database versus microservices</span></span>

<span data-ttu-id="3f102-118">V tradičním přístupu je jedna databáze sdílená napříč všemi službami, obvykle v vrstvené architektuře.</span><span class="sxs-lookup"><span data-stu-id="3f102-118">In the traditional approach, there's a single database shared across all services, typically in a tiered architecture.</span></span> <span data-ttu-id="3f102-119">V přístupu mikroslužeb každá mikroslužba vlastní svůj model/data.</span><span class="sxs-lookup"><span data-stu-id="3f102-119">In the microservices approach, each microservice owns its model/data.</span></span> <span data-ttu-id="3f102-120">Centralizovaný databázový přístup zpočátku vypadá jednodušeji a zdá se, že umožňuje opakované použití entit v různých subsystémech, aby bylo vše konzistentní.</span><span class="sxs-lookup"><span data-stu-id="3f102-120">The centralized database approach initially looks simpler and seems to enable reuse of entities in different subsystems to make everything consistent.</span></span> <span data-ttu-id="3f102-121">Ale realita je, že skončíte s obrovskými tabulkami, které slouží mnoha různým subsystémům a které zahrnují atributy a sloupce, které nejsou ve většině případů potřeba.</span><span class="sxs-lookup"><span data-stu-id="3f102-121">But the reality is you end up with huge tables that serve many different subsystems, and that include attributes and columns that aren't needed in most cases.</span></span> <span data-ttu-id="3f102-122">Je to jako snažit se použít stejnou fyzickou mapu pro pěší turistiku na krátké stezce, celodenní výlet autem a učení geografie.</span><span class="sxs-lookup"><span data-stu-id="3f102-122">It's like trying to use the same physical map for hiking a short trail, taking a day-long car trip, and learning geography.</span></span>

<span data-ttu-id="3f102-123">Monolitická aplikace s obvykle jedinou relační databáze má dvě důležité výhody: [ACID transakce](https://en.wikipedia.org/wiki/ACID) a jazyk SQL, jak pracovat napříč všemi tabulkami a data související s vaší aplikací.</span><span class="sxs-lookup"><span data-stu-id="3f102-123">A monolithic application with typically a single relational database has two important benefits: [ACID transactions](https://en.wikipedia.org/wiki/ACID) and the SQL language, both working across all the tables and data related to your application.</span></span> <span data-ttu-id="3f102-124">Tento přístup poskytuje způsob, jak snadno napsat dotaz, který kombinuje data z více tabulek.</span><span class="sxs-lookup"><span data-stu-id="3f102-124">This approach provides a way to easily write a query that combines data from multiple tables.</span></span>

<span data-ttu-id="3f102-125">Přístup k datům se však stane mnohem složitější při přechodu na architekturu mikroslužeb.</span><span class="sxs-lookup"><span data-stu-id="3f102-125">However, data access becomes much more complicated when you move to a microservices architecture.</span></span> <span data-ttu-id="3f102-126">I při použití acid transakcí v rámci mikroslužeb nebo ohraničené kontextu, je důležité vzít v úvahu, že data vlastněná každou mikroslužbu je privátní pro tuto mikroslužbu a by měly být přístupné pouze synchronně prostřednictvím koncových bodů rozhraní API (REST, gRPC, SOAP, atd.) nebo asynchronně prostřednictvím zasílání zpráv (AMQP nebo podobné).</span><span class="sxs-lookup"><span data-stu-id="3f102-126">Even when using ACID transactions within a microservice or Bounded Context, it is crucial to consider that the data owned by each microservice is private to that microservice and should only be accessed either synchronously through its API endpoints(REST, gRPC, SOAP, etc) or asynchronously via messaging(AMQP or similar).</span></span>

<span data-ttu-id="3f102-127">Zapouzdření dat zajišťuje, že mikroslužby jsou volně spojeny a může vyvíjet nezávisle na sobě.</span><span class="sxs-lookup"><span data-stu-id="3f102-127">Encapsulating the data ensures that the microservices are loosely coupled and can evolve independently of one another.</span></span> <span data-ttu-id="3f102-128">Pokud více služeb byly přístup ke stejným datům, aktualizace schématu by vyžadovalo koordinované aktualizace všech služeb.</span><span class="sxs-lookup"><span data-stu-id="3f102-128">If multiple services were accessing the same data, schema updates would require coordinated updates to all the services.</span></span> <span data-ttu-id="3f102-129">To by přerušilo autonomii životního cyklu mikroslužeb.</span><span class="sxs-lookup"><span data-stu-id="3f102-129">This would break the microservice lifecycle autonomy.</span></span> <span data-ttu-id="3f102-130">Ale distribuované datové struktury znamenají, že nelze provést jednu transakci ACID napříč mikroslužbami.</span><span class="sxs-lookup"><span data-stu-id="3f102-130">But distributed data structures mean that you can't make a single ACID transaction across microservices.</span></span> <span data-ttu-id="3f102-131">To zase znamená, že je nutné použít konečnou konzistenci, když obchodní proces zahrnuje více mikroslužeb.</span><span class="sxs-lookup"><span data-stu-id="3f102-131">This in turn means you must use eventual consistency when a business process spans multiple microservices.</span></span> <span data-ttu-id="3f102-132">To je mnohem těžší implementovat než jednoduché sql spojení, protože nelze vytvořit omezení integrity nebo použít distribuované transakce mezi samostatnými databázemi, jak vysvětlíme později.</span><span class="sxs-lookup"><span data-stu-id="3f102-132">This is much harder to implement than simple SQL joins, because you can't create integrity constraints or use distributed transactions between separate databases, as we'll explain later on.</span></span> <span data-ttu-id="3f102-133">Podobně mnoho dalších funkcí relační databáze nejsou k dispozici ve více mikroslužeb.</span><span class="sxs-lookup"><span data-stu-id="3f102-133">Similarly, many other relational database features aren't available across multiple microservices.</span></span>

<span data-ttu-id="3f102-134">Chystáte ještě dále, různé mikroslužby často používají různé *druhy* databází.</span><span class="sxs-lookup"><span data-stu-id="3f102-134">Going even further, different microservices often use different *kinds* of databases.</span></span> <span data-ttu-id="3f102-135">Moderní aplikace ukládají a zpracovávají různé druhy dat a relační databáze není vždy tou nejlepší volbou.</span><span class="sxs-lookup"><span data-stu-id="3f102-135">Modern applications store and process diverse kinds of data, and a relational database isn't always the best choice.</span></span> <span data-ttu-id="3f102-136">V některých případech použití může mít databáze NoSQL, jako je Azure CosmosDB nebo MongoDB, pohodlnější datový model a nabízet lepší výkon a škálovatelnost než databáze SQL, jako je SQL Server nebo Azure SQL Database.</span><span class="sxs-lookup"><span data-stu-id="3f102-136">For some use cases, a NoSQL database such as Azure CosmosDB or MongoDB might have a more convenient data model and offer better performance and scalability than a SQL database like SQL Server or Azure SQL Database.</span></span> <span data-ttu-id="3f102-137">V ostatních případech relační databáze je stále nejlepší přístup.</span><span class="sxs-lookup"><span data-stu-id="3f102-137">In other cases, a relational database is still the best approach.</span></span> <span data-ttu-id="3f102-138">Proto aplikace založené na mikroslužbách často používají směs sql a nosql databází, což se někdy nazývá přístup [polyglot perzistence.](https://martinfowler.com/bliki/PolyglotPersistence.html)</span><span class="sxs-lookup"><span data-stu-id="3f102-138">Therefore, microservices-based applications often use a mixture of SQL and NoSQL databases, which is sometimes called the [polyglot persistence](https://martinfowler.com/bliki/PolyglotPersistence.html) approach.</span></span>

<span data-ttu-id="3f102-139">Rozdělená, polyglot trvalá architektura pro ukládání dat má mnoho výhod.</span><span class="sxs-lookup"><span data-stu-id="3f102-139">A partitioned, polyglot-persistent architecture for data storage has many benefits.</span></span> <span data-ttu-id="3f102-140">Patří mezi ně volně vázané služby a lepší výkon, škálovatelnost, náklady a možnosti správy.</span><span class="sxs-lookup"><span data-stu-id="3f102-140">These include loosely coupled services and better performance, scalability, costs, and manageability.</span></span> <span data-ttu-id="3f102-141">Může však zavést některé problémy správy distribuovaných dat, jak je vysvětleno v "[Identifikace hranic modelu domény](identify-microservice-domain-model-boundaries.md)" dále v této kapitole.</span><span class="sxs-lookup"><span data-stu-id="3f102-141">However, it can introduce some distributed data management challenges, as explained in "[Identifying domain-model boundaries](identify-microservice-domain-model-boundaries.md)" later in this chapter.</span></span>

## <a name="the-relationship-between-microservices-and-the-bounded-context-pattern"></a><span data-ttu-id="3f102-142">Vztah mezi mikroslužeb a ohraničený kontext vzor</span><span class="sxs-lookup"><span data-stu-id="3f102-142">The relationship between microservices and the Bounded Context pattern</span></span>

<span data-ttu-id="3f102-143">Koncept mikroslužeb je odvozen od [vzoru ohraničeného kontextu (BC)](https://martinfowler.com/bliki/BoundedContext.html) v [návrhu řízeném doménou (DDD).](https://en.wikipedia.org/wiki/Domain-driven_design)</span><span class="sxs-lookup"><span data-stu-id="3f102-143">The concept of microservice derives from the [Bounded Context (BC) pattern](https://martinfowler.com/bliki/BoundedContext.html) in [domain-driven design (DDD)](https://en.wikipedia.org/wiki/Domain-driven_design).</span></span> <span data-ttu-id="3f102-144">DDD se zabývá velkými modely jejich rozdělením do více př.</span><span class="sxs-lookup"><span data-stu-id="3f102-144">DDD deals with large models by dividing them into multiple BCs and being explicit about their boundaries.</span></span> <span data-ttu-id="3f102-145">Každý BC musí mít svůj vlastní model a databázi; stejně tak každá mikroslužba vlastní související data.</span><span class="sxs-lookup"><span data-stu-id="3f102-145">Each BC must have its own model and database; likewise, each microservice owns its related data.</span></span> <span data-ttu-id="3f102-146">Kromě toho má každý BC obvykle svůj [vlastní všudypřítomný jazyk,](https://martinfowler.com/bliki/UbiquitousLanguage.html) který pomáhá komunikaci mezi vývojáři softwaru a odborníky na domény.</span><span class="sxs-lookup"><span data-stu-id="3f102-146">In addition, each BC usually has its own [ubiquitous language](https://martinfowler.com/bliki/UbiquitousLanguage.html) to help communication between software developers and domain experts.</span></span>

<span data-ttu-id="3f102-147">Tyto termíny (hlavně entity domény) v všudypřítomném jazyce mohou mít různé názvy v různých ohraničených kontextech, i když různé entity domény sdílejí stejnou identitu (to znamená jedinečné ID, které se používá ke čtení entity z úložiště).</span><span class="sxs-lookup"><span data-stu-id="3f102-147">Those terms (mainly domain entities) in the ubiquitous language can have different names in different Bounded Contexts, even when different domain entities share the same identity (that is, the unique ID that's used to read the entity from storage).</span></span> <span data-ttu-id="3f102-148">Například v kontextu ohraničený profil uživatele může entita domény uživatele sdílet identitu s entitou domény kupujícího v objednacím ohraničeném kontextu.</span><span class="sxs-lookup"><span data-stu-id="3f102-148">For instance, in a user-profile Bounded Context, the User domain entity might share identity with the Buyer domain entity in the ordering Bounded Context.</span></span>

<span data-ttu-id="3f102-149">Mikroslužba je tedy jako ohraničený kontext, ale také určuje, že je distribuované služby.</span><span class="sxs-lookup"><span data-stu-id="3f102-149">A microservice is therefore like a Bounded Context, but it also specifies that it's a distributed service.</span></span> <span data-ttu-id="3f102-150">Je vytvořen jako samostatný proces pro každý ohraničený kontext a musí používat distribuované protokoly uvedené dříve, jako je HTTP/HTTPS, WebSockets nebo [AMQP](https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol).</span><span class="sxs-lookup"><span data-stu-id="3f102-150">It's built as a separate process for each Bounded Context, and it must use the distributed protocols noted earlier, like HTTP/HTTPS, WebSockets, or [AMQP](https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol).</span></span> <span data-ttu-id="3f102-151">Ohraničený kontext vzor, ale neurčuje, zda ohraničený kontext je distribuovaná služba nebo pokud je to prostě logická hranice (například obecný subsystém) v rámci aplikace monolitického nasazení.</span><span class="sxs-lookup"><span data-stu-id="3f102-151">The Bounded Context pattern, however, doesn't specify whether the Bounded Context is a distributed service or if it's simply a logical boundary (such as a generic subsystem) within a monolithic-deployment application.</span></span>

<span data-ttu-id="3f102-152">Je důležité zdůraznit, že definování služby pro každý ohraničený kontext je vhodné začít.</span><span class="sxs-lookup"><span data-stu-id="3f102-152">It's important to highlight that defining a service for each Bounded Context is a good place to start.</span></span> <span data-ttu-id="3f102-153">Ale nemusíte omezovat svůj návrh na to.</span><span class="sxs-lookup"><span data-stu-id="3f102-153">But you don't have to constrain your design to it.</span></span> <span data-ttu-id="3f102-154">Někdy je nutné navrhnout ohraničený kontext nebo obchodní mikroslužbu složenou z několika fyzických služeb.</span><span class="sxs-lookup"><span data-stu-id="3f102-154">Sometimes you must design a Bounded Context or business microservice composed of several physical services.</span></span> <span data-ttu-id="3f102-155">Ale nakonec oba vzory -Ohraničený kontext a mikroslužby- úzce souvisí.</span><span class="sxs-lookup"><span data-stu-id="3f102-155">But ultimately, both patterns -Bounded Context and microservice- are closely related.</span></span>

<span data-ttu-id="3f102-156">DDD těží z mikroslužeb tím, že získá skutečné hranice ve formě distribuovaných mikroslužeb.</span><span class="sxs-lookup"><span data-stu-id="3f102-156">DDD benefits from microservices by getting real boundaries in the form of distributed microservices.</span></span> <span data-ttu-id="3f102-157">Ale nápady, jako je nesdílení modelu mezi mikroslužeb jsou to, co také chcete v ohraničené kontextu.</span><span class="sxs-lookup"><span data-stu-id="3f102-157">But ideas like not sharing the model between microservices are what you also want in a Bounded Context.</span></span>

### <a name="additional-resources"></a><span data-ttu-id="3f102-158">Další zdroje</span><span class="sxs-lookup"><span data-stu-id="3f102-158">Additional resources</span></span>

- <span data-ttu-id="3f102-159">**Chrise Richardsona. Vzor: Databáze na službu** </span><span class="sxs-lookup"><span data-stu-id="3f102-159">**Chris Richardson. Pattern: Database per service** </span></span>\
  <https://microservices.io/patterns/data/database-per-service.html>

- <span data-ttu-id="3f102-160">**Martin Fowler. Ohraničený kontext** </span><span class="sxs-lookup"><span data-stu-id="3f102-160">**Martin Fowler. BoundedContext** </span></span>\
  <https://martinfowler.com/bliki/BoundedContext.html>

- <span data-ttu-id="3f102-161">**Martin Fowler. PolyglotPersistence** </span><span class="sxs-lookup"><span data-stu-id="3f102-161">**Martin Fowler. PolyglotPersistence** </span></span>\
  <https://martinfowler.com/bliki/PolyglotPersistence.html>

- <span data-ttu-id="3f102-162">**Alberto Brandolini. Strategický návrh řízený doménou s mapováním kontextu** </span><span class="sxs-lookup"><span data-stu-id="3f102-162">**Alberto Brandolini. Strategic Domain Driven Design with Context Mapping** </span></span>\
  <https://www.infoq.com/articles/ddd-contextmapping>

>[!div class="step-by-step"]
><span data-ttu-id="3f102-163">[Předchozí](microservices-architecture.md)
>[další](logical-versus-physical-architecture.md)</span><span class="sxs-lookup"><span data-stu-id="3f102-163">[Previous](microservices-architecture.md)
[Next](logical-versus-physical-architecture.md)</span></span>
