---
title: Komunikace v architektuře mikroslužeb
description: Prozkoumejte různé způsoby komunikace mezi mikroslužbami a seznamte se s důsledky synchronních a asynchronních způsobů.
ms.date: 01/30/2020
ms.openlocfilehash: f2d6e78966bb7d5f481de6db0ab1dcfe2812a1b5
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 03/14/2020
ms.locfileid: "79401653"
---
# <a name="communication-in-a-microservice-architecture"></a><span data-ttu-id="2a4d8-103">Komunikace v architektuře mikroslužeb</span><span class="sxs-lookup"><span data-stu-id="2a4d8-103">Communication in a microservice architecture</span></span>

<span data-ttu-id="2a4d8-104">V monolitické aplikaci spuštěné v jednom procesu se komponenty vzájemně vyvolávají pomocí metody nebo volání funkcí na úrovni jazyka.</span><span class="sxs-lookup"><span data-stu-id="2a4d8-104">In a monolithic application running on a single process, components invoke one another using language-level method or function calls.</span></span> <span data-ttu-id="2a4d8-105">Ty mohou být silně spojeny, pokud vytváříte objekty `new ClassName()`s kódem (například ), nebo mohou být vyvolány odděleným způsobem, pokud používáte vkládání závislostí odkazováním na abstrakce spíše než na konkrétní instance objektů.</span><span class="sxs-lookup"><span data-stu-id="2a4d8-105">These can be strongly coupled if you're creating objects with code (for example, `new ClassName()`), or can be invoked in a decoupled way if you're using Dependency Injection by referencing abstractions rather than concrete object instances.</span></span> <span data-ttu-id="2a4d8-106">V obou směrech jsou objekty spuštěny ve stejném procesu.</span><span class="sxs-lookup"><span data-stu-id="2a4d8-106">Either way, the objects are running within the same process.</span></span> <span data-ttu-id="2a4d8-107">Největší výzvou při přechodu z monolitické aplikace na aplikaci založenou na mikroslužbách spočívá ve změně komunikačního mechanismu.</span><span class="sxs-lookup"><span data-stu-id="2a4d8-107">The biggest challenge when changing from a monolithic application to a microservices-based application lies in changing the communication mechanism.</span></span> <span data-ttu-id="2a4d8-108">Přímý převod z volání metody v procesu do volání Vzdáleného volání na služby způsobí upovídaný a neefektivní komunikaci, která nebude fungovat dobře v distribuovaných prostředích.</span><span class="sxs-lookup"><span data-stu-id="2a4d8-108">A direct conversion from in-process method calls into RPC calls to services will cause a chatty and not efficient communication that won't perform well in distributed environments.</span></span> <span data-ttu-id="2a4d8-109">Výzvy navrhování distribuovaného systému správně jsou dostatečně dobře známé, že existuje i kánek známý jako [Fallacies distribuovaných výpočetních počítačů,](https://en.wikipedia.org/wiki/Fallacies_of_distributed_computing) který uvádí předpoklady, které vývojáři často dělají při přechodu z monolitických na distribuované návrhy.</span><span class="sxs-lookup"><span data-stu-id="2a4d8-109">The challenges of designing distributed system properly are well enough known that there's even a canon known as the [Fallacies of distributed computing](https://en.wikipedia.org/wiki/Fallacies_of_distributed_computing) that lists assumptions that developers often make when moving from monolithic to distributed designs.</span></span>

<span data-ttu-id="2a4d8-110">Neexistuje jedno řešení, ale několik.</span><span class="sxs-lookup"><span data-stu-id="2a4d8-110">There isn't one solution, but several.</span></span> <span data-ttu-id="2a4d8-111">Jedno řešení zahrnuje izolaci obchodní mikroslužeb co nejvíce.</span><span class="sxs-lookup"><span data-stu-id="2a4d8-111">One solution involves isolating the business microservices as much as possible.</span></span> <span data-ttu-id="2a4d8-112">Potom použijte asynchronní komunikaci mezi interní mikroslužeb a nahradit jemně odstupňované komunikace, která je typická v intraprocesové komunikace mezi objekty s hrubší odstupňované komunikace.</span><span class="sxs-lookup"><span data-stu-id="2a4d8-112">You then use asynchronous communication between the internal microservices and replace fine-grained communication that's typical in intra-process communication between objects with coarser-grained communication.</span></span> <span data-ttu-id="2a4d8-113">Můžete to provést seskupením volání a vrácením dat, která agreguje výsledky více interních volání, klientovi.</span><span class="sxs-lookup"><span data-stu-id="2a4d8-113">You can do this by grouping calls, and by returning data that aggregates the results of multiple internal calls, to the client.</span></span>

<span data-ttu-id="2a4d8-114">Aplikace založená na mikroslužbách je distribuovaný systém spuštěný na více procesech nebo službách, obvykle i na více serverech nebo hostitelích.</span><span class="sxs-lookup"><span data-stu-id="2a4d8-114">A microservices-based application is a distributed system running on multiple processes or services, usually even across multiple servers or hosts.</span></span> <span data-ttu-id="2a4d8-115">Každá instance služby je obvykle proces.</span><span class="sxs-lookup"><span data-stu-id="2a4d8-115">Each service instance is typically a process.</span></span> <span data-ttu-id="2a4d8-116">Proto musí služby komunikovat pomocí meziprocesového komunikačního protokolu, jako je HTTP, AMQP nebo binární protokol, jako je TCP, v závislosti na povaze každé služby.</span><span class="sxs-lookup"><span data-stu-id="2a4d8-116">Therefore, services must interact using an inter-process communication protocol such as HTTP, AMQP, or a binary protocol like TCP, depending on the nature of each service.</span></span>

<span data-ttu-id="2a4d8-117">Komunita mikroslužeb podporuje filozofii "[inteligentní koncové body a hloupé kanály](https://simplicable.com/new/smart-endpoints-and-dumb-pipes)" Tento slogan podporuje návrh, který je co nejvíce oddělené mezi mikroslužeb a co nejsoudržnější v rámci jedné mikroslužby.</span><span class="sxs-lookup"><span data-stu-id="2a4d8-117">The microservice community promotes the philosophy of "[smart endpoints and dumb pipes](https://simplicable.com/new/smart-endpoints-and-dumb-pipes)" This slogan encourages a design that's as decoupled as possible between microservices, and as cohesive as possible within a single microservice.</span></span> <span data-ttu-id="2a4d8-118">Jak bylo vysvětleno dříve, každá mikroslužba vlastní vlastní data a vlastní logiku domény.</span><span class="sxs-lookup"><span data-stu-id="2a4d8-118">As explained earlier, each microservice owns its own data and its own domain logic.</span></span> <span data-ttu-id="2a4d8-119">Ale mikroslužeb, které tvoří end-to-end aplikace jsou obvykle jednoduše choreografie pomocí rest\* komunikace spíše než složité protokoly, jako je ws a flexibilní komunikace řízené událostmi namísto centralizovaných orchestrátorů obchodního procesu.</span><span class="sxs-lookup"><span data-stu-id="2a4d8-119">But the microservices composing an end-to-end application are usually simply choreographed by using REST communications rather than complex protocols such as WS-\* and flexible event-driven communications instead of centralized business-process-orchestrators.</span></span>

<span data-ttu-id="2a4d8-120">Dva běžně používané protokoly jsou požadavek/odpověď HTTP s api prostředků (při dotazování ze všeho nejvíce) a zjednodušené asynchronní zasílání zpráv při komunikaci aktualizací napříč více mikroslužeb.</span><span class="sxs-lookup"><span data-stu-id="2a4d8-120">The two commonly used protocols are HTTP request/response with resource APIs (when querying most of all), and lightweight asynchronous messaging when communicating updates across multiple microservices.</span></span> <span data-ttu-id="2a4d8-121">Ty jsou podrobněji vysvětleny v následujících částech.</span><span class="sxs-lookup"><span data-stu-id="2a4d8-121">These are explained in more detail in the following sections.</span></span>

## <a name="communication-types"></a><span data-ttu-id="2a4d8-122">Typy komunikace</span><span class="sxs-lookup"><span data-stu-id="2a4d8-122">Communication types</span></span>

<span data-ttu-id="2a4d8-123">Klient a služby mohou komunikovat prostřednictvím mnoha různých typů komunikace, z nichž každý cílí na jiný scénář a cíle.</span><span class="sxs-lookup"><span data-stu-id="2a4d8-123">Client and services can communicate through many different types of communication, each one targeting a different scenario and goals.</span></span> <span data-ttu-id="2a4d8-124">Zpočátku mohou být tyto typy komunikace klasifikovány ve dvou osách.</span><span class="sxs-lookup"><span data-stu-id="2a4d8-124">Initially, those types of communications can be classified in two axes.</span></span>

<span data-ttu-id="2a4d8-125">První osa definuje, zda je protokol synchronní nebo asynchronní:</span><span class="sxs-lookup"><span data-stu-id="2a4d8-125">The first axis defines if the protocol is synchronous or asynchronous:</span></span>

- <span data-ttu-id="2a4d8-126">Synchronní protokol.</span><span class="sxs-lookup"><span data-stu-id="2a4d8-126">Synchronous protocol.</span></span> <span data-ttu-id="2a4d8-127">HTTP je synchronní protokol.</span><span class="sxs-lookup"><span data-stu-id="2a4d8-127">HTTP is a synchronous protocol.</span></span> <span data-ttu-id="2a4d8-128">Klient odešle požadavek a čeká na odpověď ze služby.</span><span class="sxs-lookup"><span data-stu-id="2a4d8-128">The client sends a request and waits for a response from the service.</span></span> <span data-ttu-id="2a4d8-129">To je nezávislé na spuštění kódu klienta, který může být synchronní (vlákno je blokováno) nebo asynchronní (vlákno není blokováno a odpověď nakonec dosáhne zpětného volání).</span><span class="sxs-lookup"><span data-stu-id="2a4d8-129">That's independent of the client code execution that could be synchronous (thread is blocked) or asynchronous (thread isn't blocked, and the response will reach a callback eventually).</span></span> <span data-ttu-id="2a4d8-130">Důležitým bodem je, že protokol (HTTP/HTTPS) je synchronní a klientský kód může pokračovat ve své úloze pouze v případě, že obdrží odpověď serveru HTTP.</span><span class="sxs-lookup"><span data-stu-id="2a4d8-130">The important point here is that the protocol (HTTP/HTTPS) is synchronous and the client code can only continue its task when it receives the HTTP server response.</span></span>

- <span data-ttu-id="2a4d8-131">Asynchronní protokol.</span><span class="sxs-lookup"><span data-stu-id="2a4d8-131">Asynchronous protocol.</span></span> <span data-ttu-id="2a4d8-132">Jiné protokoly, jako je AMQP (protokol podporovaný mnoha operačními systémy a cloudovými prostředími) používají asynchronní zprávy.</span><span class="sxs-lookup"><span data-stu-id="2a4d8-132">Other protocols like AMQP (a protocol supported by many operating systems and cloud environments) use asynchronous messages.</span></span> <span data-ttu-id="2a4d8-133">Klientský kód nebo odesílatel zprávy obvykle nečeká na odpověď.</span><span class="sxs-lookup"><span data-stu-id="2a4d8-133">The client code or message sender usually doesn't wait for a response.</span></span> <span data-ttu-id="2a4d8-134">To jen odešle zprávu jako při odesílání zprávy do fronty RabbitMQ nebo jiné zprávy broker.</span><span class="sxs-lookup"><span data-stu-id="2a4d8-134">It just sends the message as when sending a message to a RabbitMQ queue or any other message broker.</span></span>

<span data-ttu-id="2a4d8-135">Druhá osa definuje, zda má komunikace jeden přijímač nebo více přijímačů:</span><span class="sxs-lookup"><span data-stu-id="2a4d8-135">The second axis defines if the communication has a single receiver or multiple receivers:</span></span>

- <span data-ttu-id="2a4d8-136">Jeden přijímač.</span><span class="sxs-lookup"><span data-stu-id="2a4d8-136">Single receiver.</span></span> <span data-ttu-id="2a4d8-137">Každý požadavek musí být zpracován přesně jedním příjemcem nebo službou.</span><span class="sxs-lookup"><span data-stu-id="2a4d8-137">Each request must be processed by exactly one receiver or service.</span></span> <span data-ttu-id="2a4d8-138">Příkladem této komunikace je [vzor příkazu](https://en.wikipedia.org/wiki/Command_pattern).</span><span class="sxs-lookup"><span data-stu-id="2a4d8-138">An example of this communication is the [Command pattern](https://en.wikipedia.org/wiki/Command_pattern).</span></span>

- <span data-ttu-id="2a4d8-139">Více přijímačů.</span><span class="sxs-lookup"><span data-stu-id="2a4d8-139">Multiple receivers.</span></span> <span data-ttu-id="2a4d8-140">Každý požadavek může být zpracován nulou na více přijímačů.</span><span class="sxs-lookup"><span data-stu-id="2a4d8-140">Each request can be processed by zero to multiple receivers.</span></span> <span data-ttu-id="2a4d8-141">Tento typ komunikace musí být asynchronní.</span><span class="sxs-lookup"><span data-stu-id="2a4d8-141">This type of communication must be asynchronous.</span></span> <span data-ttu-id="2a4d8-142">Příkladem je mechanismus [publikování/odběru](https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern) používaný ve vzorcích, jako je [architektura řízená událostmi](https://microservices.io/patterns/data/event-driven-architecture.html).</span><span class="sxs-lookup"><span data-stu-id="2a4d8-142">An example is the [publish/subscribe](https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern) mechanism used in patterns like [Event-driven architecture](https://microservices.io/patterns/data/event-driven-architecture.html).</span></span> <span data-ttu-id="2a4d8-143">To je založeno na rozhraní event-bus nebo zprostředkovatele zpráv při šíření aktualizací dat mezi více mikroslužeb prostřednictvím událostí; obvykle se implementuje prostřednictvím sběrnice service bus nebo podobné artefakty, jako je [Azure Service Bus](https://azure.microsoft.com/services/service-bus/) pomocí témat a [předplatných](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions).</span><span class="sxs-lookup"><span data-stu-id="2a4d8-143">This is based on an event-bus interface or message broker when propagating data updates between multiple microservices through events; it's usually implemented through a service bus or similar artifact like [Azure Service Bus](https://azure.microsoft.com/services/service-bus/) by using [topics and subscriptions](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions).</span></span>

<span data-ttu-id="2a4d8-144">Aplikace založená na mikroslužbách často používá kombinaci těchto stylů komunikace.</span><span class="sxs-lookup"><span data-stu-id="2a4d8-144">A microservice-based application will often use a combination of these communication styles.</span></span> <span data-ttu-id="2a4d8-145">Nejběžnějším typem je komunikace s jedním přijímačem se synchronním protokolem, jako je HTTP/HTTPS při vyvolání běžné služby HTTP webového rozhraní API.</span><span class="sxs-lookup"><span data-stu-id="2a4d8-145">The most common type is single-receiver communication with a synchronous protocol like HTTP/HTTPS when invoking a regular Web API HTTP service.</span></span> <span data-ttu-id="2a4d8-146">Mikroslužby také obvykle používají protokoly zasílání zpráv pro asynchronní komunikaci mezi mikroslužbami.</span><span class="sxs-lookup"><span data-stu-id="2a4d8-146">Microservices also typically use messaging protocols for asynchronous communication between microservices.</span></span>

<span data-ttu-id="2a4d8-147">Tyto osy jsou dobré vědět, takže máte jasno na možné komunikační mechanismy, ale nejsou důležité obavy při vytváření mikroslužeb.</span><span class="sxs-lookup"><span data-stu-id="2a4d8-147">These axes are good to know so you have clarity on the possible communication mechanisms, but they're not the important concerns when building microservices.</span></span> <span data-ttu-id="2a4d8-148">Asynchronní povaha spuštění vlákna klienta ani asynchronní povaha vybraného protokolu nejsou důležitými body při integraci mikroslužeb.</span><span class="sxs-lookup"><span data-stu-id="2a4d8-148">Neither the asynchronous nature of client thread execution nor the asynchronous nature of the selected protocol are the important points when integrating microservices.</span></span> <span data-ttu-id="2a4d8-149">Co *je* důležité, je možnost integrovat mikroslužeb asynchronně při zachování nezávislosti mikroslužeb, jak je vysvětleno v následující části.</span><span class="sxs-lookup"><span data-stu-id="2a4d8-149">What *is* important is being able to integrate your microservices asynchronously while maintaining the independence of microservices, as explained in the following section.</span></span>

## <a name="asynchronous-microservice-integration-enforces-microservices-autonomy"></a><span data-ttu-id="2a4d8-150">Asynchronní integrace mikroslužeb vynucuje autonomii mikroslužeb</span><span class="sxs-lookup"><span data-stu-id="2a4d8-150">Asynchronous microservice integration enforces microservice's autonomy</span></span>

<span data-ttu-id="2a4d8-151">Jak již bylo zmíněno, důležitým bodem při vytváření aplikace založené na mikroslužbách je způsob, jakým integrovat mikroslužeb.</span><span class="sxs-lookup"><span data-stu-id="2a4d8-151">As mentioned, the important point when building a microservices-based application is the way you integrate your microservices.</span></span> <span data-ttu-id="2a4d8-152">V ideálním případě byste se měli pokusit minimalizovat komunikaci mezi interní mikroslužeb.</span><span class="sxs-lookup"><span data-stu-id="2a4d8-152">Ideally, you should try to minimize the communication between the internal microservices.</span></span> <span data-ttu-id="2a4d8-153">Čím méně komunikace mezi mikroslužbami, tím lépe.</span><span class="sxs-lookup"><span data-stu-id="2a4d8-153">The fewer communications between microservices, the better.</span></span> <span data-ttu-id="2a4d8-154">Ale v mnoha případech budete muset nějak integrovat mikroslužeb.</span><span class="sxs-lookup"><span data-stu-id="2a4d8-154">But in many cases, you'll have to somehow integrate the microservices.</span></span> <span data-ttu-id="2a4d8-155">Když to potřebujete udělat, kritické pravidlo je, že komunikace mezi mikroslužeb by měla být asynchronní.</span><span class="sxs-lookup"><span data-stu-id="2a4d8-155">When you need to do that, the critical rule here is that the communication between the microservices should be asynchronous.</span></span> <span data-ttu-id="2a4d8-156">To neznamená, že budete muset použít konkrétní protokol (například asynchronní zasílání zpráv versus synchronní HTTP).</span><span class="sxs-lookup"><span data-stu-id="2a4d8-156">That doesn't mean that you have to use a specific protocol (for example, asynchronous messaging versus synchronous HTTP).</span></span> <span data-ttu-id="2a4d8-157">To jen znamená, že komunikace mezi mikroslužeb by měla být provedena pouze šíření dat asynchronně, ale snažte se nezávisí na jiné interní mikroslužeb jako součást počáteční služby http požadavek/odpověď operace.</span><span class="sxs-lookup"><span data-stu-id="2a4d8-157">It just means that the communication between microservices should be done only by propagating data asynchronously, but try not to depend on other internal microservices as part of the initial service's HTTP request/response operation.</span></span>

<span data-ttu-id="2a4d8-158">Pokud je to možné, nikdy nezávisí na synchronní komunikaci (požadavek/odpověď) mezi více mikroslužeb, ani pro dotazy.</span><span class="sxs-lookup"><span data-stu-id="2a4d8-158">If possible, never depend on synchronous communication (request/response) between multiple microservices, not even for queries.</span></span> <span data-ttu-id="2a4d8-159">Cílem každé mikroslužby je být autonomní a k dispozici pro klienta spotřebitele, i v případě, že ostatní služby, které jsou součástí aplikace end-to-end jsou mimo nebo není v pořádku.</span><span class="sxs-lookup"><span data-stu-id="2a4d8-159">The goal of each microservice is to be autonomous and available to the client consumer, even if the other services that are part of the end-to-end application are down or unhealthy.</span></span> <span data-ttu-id="2a4d8-160">Pokud si myslíte, že potřebujete volat z jedné mikroslužby do jiných mikroslužeb (jako je provádění požadavku HTTP pro datový dotaz), abyste mohli poskytnout odpověď na klientskou aplikaci, máte architekturu, která nebude odolná, když některé mikroslužby selžou.</span><span class="sxs-lookup"><span data-stu-id="2a4d8-160">If you think you need to make a call from one microservice to other microservices (like performing an HTTP request for a data query) to be able to provide a response to a client application, you have an architecture that won't be resilient when some microservices fail.</span></span>

<span data-ttu-id="2a4d8-161">Navíc s http závislosti mezi mikroslužeb, jako při vytváření dlouhé cykly požadavků a odpovědí s řetězci požadavků HTTP, jak je znázorněno v první části obrázku 4-15, nejen dělá vaše mikroslužby není autonomní, ale také jejich výkon je ovlivněna, jakmile jedna ze služeb v tomto řetězci nefunguje dobře.</span><span class="sxs-lookup"><span data-stu-id="2a4d8-161">Moreover, having HTTP dependencies between microservices, like when creating long request/response cycles with HTTP request chains, as shown in the first part of the Figure 4-15, not only makes your microservices not autonomous but also their performance is impacted as soon as one of the services in that chain isn't performing well.</span></span>

<span data-ttu-id="2a4d8-162">Čím více přidáte synchronní závislosti mezi mikroslužeb, jako jsou požadavky na dotazy, tím horší je celková doba odezvy pro klientské aplikace.</span><span class="sxs-lookup"><span data-stu-id="2a4d8-162">The more you add synchronous dependencies between microservices, such as query requests, the worse the overall response time gets for the client apps.</span></span>

![Diagram znázorňující tři typy komunikace mezi mikroslužbami.](./media/communication-in-microservice-architecture/sync-vs-async-patterns-across-microservices.png)

<span data-ttu-id="2a4d8-164">**Obrázek 4-15**.</span><span class="sxs-lookup"><span data-stu-id="2a4d8-164">**Figure 4-15**.</span></span> <span data-ttu-id="2a4d8-165">Anti-patterns a vzory v komunikaci mezi mikroslužbami</span><span class="sxs-lookup"><span data-stu-id="2a4d8-165">Anti-patterns and patterns in communication between microservices</span></span>

<span data-ttu-id="2a4d8-166">Jak je znázorněno na výše uvedeném diagramu, v synchronní komunikaci je vytvořen "řetězec" požadavků mezi mikroslužbami při poskytování požadavku klienta.</span><span class="sxs-lookup"><span data-stu-id="2a4d8-166">As shown in the above diagram, in synchronous communication a "chain" of requests is created between microservices while serving the client request.</span></span> <span data-ttu-id="2a4d8-167">Tohle je anti-vzor.</span><span class="sxs-lookup"><span data-stu-id="2a4d8-167">This is an anti-pattern.</span></span> <span data-ttu-id="2a4d8-168">V asynchronní komunikace mikroslužeb použít asynchronní zprávy nebo http dotazování ke komunikaci s jinými mikroslužeb, ale požadavek klienta je obsluhována ihned.</span><span class="sxs-lookup"><span data-stu-id="2a4d8-168">In asynchronous communication microservices use asynchronous messages or http polling to communicate with other microservices, but the client request is served right away.</span></span>

<span data-ttu-id="2a4d8-169">Pokud vaše mikroslužby potřebuje vyvolat další akci v jiné mikroslužby, pokud je to možné, neprovádějte tuto akci synchronně a jako součást původní mikroslužeb požadavku a odpovědi operace.</span><span class="sxs-lookup"><span data-stu-id="2a4d8-169">If your microservice needs to raise an additional action in another microservice, if possible, do not perform that action synchronously and as part of the original microservice request and reply operation.</span></span> <span data-ttu-id="2a4d8-170">Místo toho to asynchronně (pomocí asynchronní zasílání zpráv nebo integrační události, fronty, atd.).</span><span class="sxs-lookup"><span data-stu-id="2a4d8-170">Instead, do it asynchronously (using asynchronous messaging or integration events, queues, etc.).</span></span> <span data-ttu-id="2a4d8-171">Ale co nejvíce nevyvolávejte akci synchronně jako součást původní synchronní operace požadavku a odpovědi.</span><span class="sxs-lookup"><span data-stu-id="2a4d8-171">But, as much as possible, do not invoke the action synchronously as part of the original synchronous request and reply operation.</span></span>

<span data-ttu-id="2a4d8-172">A nakonec (a to je místo, kde většina problémů vznikají při vytváření mikroslužeb), pokud počáteční mikroslužeb potřebuje data, která je původně vlastněna jinými mikroslužbami, nespoléhejte na provádění synchronních požadavků pro tato data.</span><span class="sxs-lookup"><span data-stu-id="2a4d8-172">And finally (and this is where most of the issues arise when building microservices), if your initial microservice needs data that's originally owned by other microservices, do not rely on making synchronous requests for that data.</span></span> <span data-ttu-id="2a4d8-173">Místo toho replikujte nebo rozšíříte tato data (pouze atributy, které potřebujete) do databáze počáteční služby pomocí konečné konzistence (obvykle pomocí událostí integrace, jak je vysvětleno v nadcházejících částech).</span><span class="sxs-lookup"><span data-stu-id="2a4d8-173">Instead, replicate or propagate that data (only the attributes you need) into the initial service's database by using eventual consistency (typically by using integration events, as explained in upcoming sections).</span></span>

<span data-ttu-id="2a4d8-174">Jak je uvedeno dříve v identifikaci hranice modelu domény pro každou část [mikroslužeb,](identify-microservice-domain-model-boundaries.md) duplikování některých dat v několika mikroslužeb není nesprávný návrh – naopak, když to uděláte, že můžete přeložit data do konkrétního jazyka nebo podmínky této další domény nebo ohraničený kontext.</span><span class="sxs-lookup"><span data-stu-id="2a4d8-174">As noted earlier in the [Identifying domain-model boundaries for each microservice](identify-microservice-domain-model-boundaries.md) section, duplicating some data across several microservices isn't an incorrect design—on the contrary, when doing that you can translate the data into the specific language or terms of that additional domain or Bounded Context.</span></span> <span data-ttu-id="2a4d8-175">Například v [aplikaci eShopOnContainers](https://github.com/dotnet-architecture/eShopOnContainers) máte mikroslužbu s názvem, `identity-api` která má na starosti většinu `User`dat uživatele s entitou s názvem .</span><span class="sxs-lookup"><span data-stu-id="2a4d8-175">For instance, in the [eShopOnContainers application](https://github.com/dotnet-architecture/eShopOnContainers) you have a microservice named `identity-api` that's in charge of most of the user's data with an entity named `User`.</span></span> <span data-ttu-id="2a4d8-176">Však v případě, že potřebujete ukládat data o uživateli v rámci `Ordering` mikroslužby, uložíte je jako jinou entitu s názvem `Buyer`.</span><span class="sxs-lookup"><span data-stu-id="2a4d8-176">However, when you need to store data about the user within the `Ordering` microservice, you store it as a different entity named `Buyer`.</span></span> <span data-ttu-id="2a4d8-177">Entita `Buyer` sdílí stejnou identitu `User` s původní entitou, ale může `Ordering` mít pouze několik atributů potřebných pro doménu a ne celý profil uživatele.</span><span class="sxs-lookup"><span data-stu-id="2a4d8-177">The `Buyer` entity shares the same identity with the original `User` entity, but it might have only the few attributes needed by the `Ordering` domain, and not the whole user profile.</span></span>

<span data-ttu-id="2a4d8-178">Můžete použít libovolný protokol ke komunikaci a šíření dat asynchronně mezi mikroslužeb, aby měly konečnou konzistenci.</span><span class="sxs-lookup"><span data-stu-id="2a4d8-178">You might use any protocol to communicate and propagate data asynchronously across microservices in order to have eventual consistency.</span></span> <span data-ttu-id="2a4d8-179">Jak již bylo zmíněno, můžete použít události integrace pomocí sběrnice událostí nebo zprostředkovatele zpráv nebo můžete dokonce použít protokol HTTP dotazováním jiných služeb.</span><span class="sxs-lookup"><span data-stu-id="2a4d8-179">As mentioned, you could use integration events using an event bus or message broker or you could even use HTTP by polling the other services instead.</span></span> <span data-ttu-id="2a4d8-180">Nezáleží.</span><span class="sxs-lookup"><span data-stu-id="2a4d8-180">It doesn't matter.</span></span> <span data-ttu-id="2a4d8-181">Důležitým pravidlem je nevytvářet synchronní závislosti mezi mikroslužbami.</span><span class="sxs-lookup"><span data-stu-id="2a4d8-181">The important rule is to not create synchronous dependencies between your microservices.</span></span>

<span data-ttu-id="2a4d8-182">V následujících částech je vysvětleno více stylů komunikace, které můžete zvážit použití v aplikaci založené na mikroslužbách.</span><span class="sxs-lookup"><span data-stu-id="2a4d8-182">The following sections explain the multiple communication styles you can consider using in a microservice-based application.</span></span>

## <a name="communication-styles"></a><span data-ttu-id="2a4d8-183">Styly komunikace</span><span class="sxs-lookup"><span data-stu-id="2a4d8-183">Communication styles</span></span>

<span data-ttu-id="2a4d8-184">Existuje mnoho protokolů a možností, které můžete použít pro komunikaci, v závislosti na typu komunikace, který chcete použít.</span><span class="sxs-lookup"><span data-stu-id="2a4d8-184">There are many protocols and choices you can use for communication, depending on the communication type you want to use.</span></span> <span data-ttu-id="2a4d8-185">Pokud používáte synchronní mechanismus komunikace založené na požadavcích a odpovědích, jsou nejběžnější protokoly, jako jsou přístupy HTTP a REST, zejména pokud publikujete služby mimo hostitelský nebo cluster mikroslužeb Dockeru.</span><span class="sxs-lookup"><span data-stu-id="2a4d8-185">If you're using a synchronous request/response-based communication mechanism, protocols such as HTTP and REST approaches are the most common, especially if you're publishing your services outside the Docker host or microservice cluster.</span></span> <span data-ttu-id="2a4d8-186">Pokud komunikujete interně mezi službami (v rámci vašeho hostitele Dockeru nebo clusteru mikroslužeb), můžete také chtít použít mechanismy komunikace binárního formátu (jako je WCF pomocí TCP a binárního formátu).</span><span class="sxs-lookup"><span data-stu-id="2a4d8-186">If you're communicating between services internally (within your Docker host or microservices cluster), you might also want to use binary format communication mechanisms (like WCF using TCP and binary format).</span></span> <span data-ttu-id="2a4d8-187">Alternativně můžete použít asynchronní, na základě zpráv komunikační mechanismy, jako je například AMQP.</span><span class="sxs-lookup"><span data-stu-id="2a4d8-187">Alternatively, you can use asynchronous, message-based communication mechanisms such as AMQP.</span></span>

<span data-ttu-id="2a4d8-188">Existuje také více formátů zpráv, jako je JSON nebo XML, nebo dokonce binární formáty, které mohou být efektivnější.</span><span class="sxs-lookup"><span data-stu-id="2a4d8-188">There are also multiple message formats like JSON or XML, or even binary formats, which can be more efficient.</span></span> <span data-ttu-id="2a4d8-189">Pokud zvolený binární formát není standardem, pravděpodobně není vhodné veřejně publikovat služby pomocí tohoto formátu.</span><span class="sxs-lookup"><span data-stu-id="2a4d8-189">If your chosen binary format isn't a standard, it's probably not a good idea to publicly publish your services using that format.</span></span> <span data-ttu-id="2a4d8-190">Pro interní komunikaci mezi mikroslužbami můžete použít nestandardní formát.</span><span class="sxs-lookup"><span data-stu-id="2a4d8-190">You could use a non-standard format for internal communication between your microservices.</span></span> <span data-ttu-id="2a4d8-191">Můžete to provést při komunikaci mezi mikroslužeb v rámci hostitele Dockeru nebo clusteru mikroslužeb (například orchestrátory Dockeru) nebo pro proprietární klientské aplikace, které komunikují s mikroslužbami.</span><span class="sxs-lookup"><span data-stu-id="2a4d8-191">You might do this when communicating between microservices within your Docker host or microservice cluster (for example, Docker orchestrators), or for proprietary client applications that talk to the microservices.</span></span>

### <a name="requestresponse-communication-with-http-and-rest"></a><span data-ttu-id="2a4d8-192">Komunikace mezi požadavky a odpověďmi s HTTP a REST</span><span class="sxs-lookup"><span data-stu-id="2a4d8-192">Request/response communication with HTTP and REST</span></span>

<span data-ttu-id="2a4d8-193">Když klient používá komunikaci požadavku a odpovědi, odešle požadavek službě, pak služba zpracuje požadavek a odešle zpět odpověď.</span><span class="sxs-lookup"><span data-stu-id="2a4d8-193">When a client uses request/response communication, it sends a request to a service, then the service processes the request and sends back a response.</span></span> <span data-ttu-id="2a4d8-194">Komunikace mezi požadavky a odpověďmi je obzvláště vhodná pro dotazování dat pro uživatelské rozhraní v reálném čase (živé uživatelské rozhraní) z klientských aplikací.</span><span class="sxs-lookup"><span data-stu-id="2a4d8-194">Request/response communication is especially well suited for querying data for a real-time UI (a live user interface) from client apps.</span></span> <span data-ttu-id="2a4d8-195">Proto v architektuře mikroslužeb budete pravděpodobně používat tento komunikační mechanismus pro většinu dotazů, jak je znázorněno na obrázku 4-16.</span><span class="sxs-lookup"><span data-stu-id="2a4d8-195">Therefore, in a microservice architecture you'll probably use this communication mechanism for most queries, as shown in Figure 4-16.</span></span>

![Diagram zobrazující komunikování požadavků a odpovědí pro živé dotazy a aktualizace.](./media/communication-in-microservice-architecture/request-response-comms-live-queries-updates.png)

<span data-ttu-id="2a4d8-197">**Obrázek 4-16**.</span><span class="sxs-lookup"><span data-stu-id="2a4d8-197">**Figure 4-16**.</span></span> <span data-ttu-id="2a4d8-198">Použití http komunikace mezi požadavky a odpověďmi (synchronní nebo asynchronní)</span><span class="sxs-lookup"><span data-stu-id="2a4d8-198">Using HTTP request/response communication (synchronous or asynchronous)</span></span>

<span data-ttu-id="2a4d8-199">Pokud klient používá komunikaci požadavku a odpovědi, předpokládá, že odpověď dorazí v krátkém čase, obvykle méně než sekundu nebo maximálně několik sekund.</span><span class="sxs-lookup"><span data-stu-id="2a4d8-199">When a client uses request/response communication, it assumes that the response will arrive in a short time, typically less than a second, or a few seconds at most.</span></span> <span data-ttu-id="2a4d8-200">Pro zpožděné odpovědi je třeba implementovat asynchronní komunikaci na základě [vzorů zasílání zpráv](https://docs.microsoft.com/azure/architecture/patterns/category/messaging) a technologií zasílání [zpráv](https://en.wikipedia.org/wiki/Message-oriented_middleware), což je jiný přístup, který vysvětlujeme v další části.</span><span class="sxs-lookup"><span data-stu-id="2a4d8-200">For delayed responses, you need to implement asynchronous communication based on [messaging patterns](https://docs.microsoft.com/azure/architecture/patterns/category/messaging) and [messaging technologies](https://en.wikipedia.org/wiki/Message-oriented_middleware), which is a different approach that we explain in the next section.</span></span>

<span data-ttu-id="2a4d8-201">Populární architektonický styl pro komunikaci mezi požadavky a odezvou je [REST](https://en.wikipedia.org/wiki/Representational_state_transfer).</span><span class="sxs-lookup"><span data-stu-id="2a4d8-201">A popular architectural style for request/response communication is [REST](https://en.wikipedia.org/wiki/Representational_state_transfer).</span></span> <span data-ttu-id="2a4d8-202">Tento přístup je založen na protokolu [HTTP](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol) a pevně s ním spojený, který zahrnuje slovesa HTTP jako GET, POST a PUT.</span><span class="sxs-lookup"><span data-stu-id="2a4d8-202">This approach is based on, and tightly coupled to, the [HTTP](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol) protocol, embracing HTTP verbs like GET, POST, and PUT.</span></span> <span data-ttu-id="2a4d8-203">REST je nejčastěji používaný architektonický komunikační přístup při vytváření služeb.</span><span class="sxs-lookup"><span data-stu-id="2a4d8-203">REST is the most commonly used architectural communication approach when creating services.</span></span> <span data-ttu-id="2a4d8-204">Služby REST můžete implementovat při vývoji ASP.NET služby základního webového rozhraní API.</span><span class="sxs-lookup"><span data-stu-id="2a4d8-204">You can implement REST services when you develop ASP.NET Core Web API services.</span></span>

<span data-ttu-id="2a4d8-205">Existuje další hodnota při použití služby HTTP REST jako jazyk definice rozhraní.</span><span class="sxs-lookup"><span data-stu-id="2a4d8-205">There's additional value when using HTTP REST services as your interface definition language.</span></span> <span data-ttu-id="2a4d8-206">Například pokud používáte [Metadata Swagger](https://swagger.io/) k popisu rozhraní API služby, můžete použít nástroje, které generují zástupné procedury klientů, které můžete přímo zjistit a využívat vaše služby.</span><span class="sxs-lookup"><span data-stu-id="2a4d8-206">For instance, if you use [Swagger metadata](https://swagger.io/) to describe your service API, you can use tools that generate client stubs that can directly discover and consume your services.</span></span>

### <a name="additional-resources"></a><span data-ttu-id="2a4d8-207">Další zdroje</span><span class="sxs-lookup"><span data-stu-id="2a4d8-207">Additional resources</span></span>

- <span data-ttu-id="2a4d8-208">**Martin fowler. Richardson Maturity Model** Popis modelu REST.</span><span class="sxs-lookup"><span data-stu-id="2a4d8-208">**Martin Fowler. Richardson Maturity Model** A description of the REST model.</span></span> \
  <https://martinfowler.com/articles/richardsonMaturityModel.html>

- <span data-ttu-id="2a4d8-209">**Chvástání** Oficiální stránky.</span><span class="sxs-lookup"><span data-stu-id="2a4d8-209">**Swagger** The official site.</span></span> \
  <https://swagger.io/>

### <a name="push-and-real-time-communication-based-on-http"></a><span data-ttu-id="2a4d8-210">Push a komunikace v reálném čase založená na protokolu HTTP</span><span class="sxs-lookup"><span data-stu-id="2a4d8-210">Push and real-time communication based on HTTP</span></span>

<span data-ttu-id="2a4d8-211">Další možností (obvykle pro jiné účely než REST) je komunikace v reálném čase a 1:N s architekturami vyšší úrovně, jako je [například ASP.NET SignalR](https://www.asp.net/signalr) a protokoly, jako je [WebSockets](https://en.wikipedia.org/wiki/WebSocket).</span><span class="sxs-lookup"><span data-stu-id="2a4d8-211">Another possibility (usually for different purposes than REST) is a real-time and one-to-many communication with higher-level frameworks such as [ASP.NET SignalR](https://www.asp.net/signalr) and protocols such as [WebSockets](https://en.wikipedia.org/wiki/WebSocket).</span></span>

<span data-ttu-id="2a4d8-212">Jak ukazuje obrázek 4-17, komunikace HTTP v reálném čase znamená, že můžete mít kód serveru, který tlačí obsah připojeným klientům, jakmile budou data k dispozici, namísto toho, aby server čekal, až klient požádá o nová data.</span><span class="sxs-lookup"><span data-stu-id="2a4d8-212">As Figure 4-17 shows, real-time HTTP communication means that you can have server code pushing content to connected clients as the data becomes available, rather than having the server wait for a client to request new data.</span></span>

![Diagram znázorňující push a real-time comms založené na SignalR.](./media/communication-in-microservice-architecture/one-to-many-communication.png)

<span data-ttu-id="2a4d8-214">**Obrázek 4-17**.</span><span class="sxs-lookup"><span data-stu-id="2a4d8-214">**Figure 4-17**.</span></span> <span data-ttu-id="2a4d8-215">Komunikace asynchronních zpráv v reálném čase</span><span class="sxs-lookup"><span data-stu-id="2a4d8-215">One-to-one real-time asynchronous message communication</span></span>

<span data-ttu-id="2a4d8-216">SignalR je dobrý způsob, jak dosáhnout komunikace v reálném čase pro odesílání obsahu klientům z back-end serveru.</span><span class="sxs-lookup"><span data-stu-id="2a4d8-216">SignalR is a good way to achieve real-time communication for pushing content to the clients from a back-end server.</span></span> <span data-ttu-id="2a4d8-217">Vzhledem k tomu, že komunikace je v reálném čase, klientské aplikace ukazují změny téměř okamžitě.</span><span class="sxs-lookup"><span data-stu-id="2a4d8-217">Since communication is in real time, client apps show the changes almost instantly.</span></span> <span data-ttu-id="2a4d8-218">To je obvykle zpracována protokolem, jako je Například WebSockets, pomocí mnoha připojení WebSockets (jeden na klienta).</span><span class="sxs-lookup"><span data-stu-id="2a4d8-218">This is usually handled by a protocol such as WebSockets, using many WebSockets connections (one per client).</span></span> <span data-ttu-id="2a4d8-219">Typickým příkladem je, když služba komunikuje změnu skóre sportovní hry do mnoha klientských webových aplikací současně.</span><span class="sxs-lookup"><span data-stu-id="2a4d8-219">A typical example is when a service communicates a change in the score of a sports game to many client web apps simultaneously.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="2a4d8-220">[Předchozí](direct-client-to-microservice-communication-versus-the-api-gateway-pattern.md)
>[další](asynchronous-message-based-communication.md)</span><span class="sxs-lookup"><span data-stu-id="2a4d8-220">[Previous](direct-client-to-microservice-communication-versus-the-api-gateway-pattern.md)
[Next](asynchronous-message-based-communication.md)</span></span>
