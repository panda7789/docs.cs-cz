---
title: Návrh doménového modelu mikroslužby
description: Architektura mikroslužeb .NET pro kontejnerizované aplikace .NET | Seznamte se s klíčovými koncepty při navrhování modelu domény orientovaného na DDD.
ms.date: 01/30/2020
ms.openlocfilehash: 64860d75dca645904e973a4b8927a716a1603394
ms.sourcegitcommit: e3cbf26d67f7e9286c7108a2752804050762d02d
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 04/09/2020
ms.locfileid: "80988411"
---
# <a name="design-a-microservice-domain-model"></a><span data-ttu-id="4a495-103">Návrh modelu domény mikroslužeb</span><span class="sxs-lookup"><span data-stu-id="4a495-103">Design a microservice domain model</span></span>

<span data-ttu-id="4a495-104">*Definujte jeden model bohaté domény pro každou obchodní mikroslužbu nebo ohraničený kontext.*</span><span class="sxs-lookup"><span data-stu-id="4a495-104">*Define one rich domain model for each business microservice or Bounded Context.*</span></span>

<span data-ttu-id="4a495-105">Vaším cílem je vytvořit jeden soudržný model domény pro každou obchodní mikroslužbu nebo ohraničený kontext (BC).</span><span class="sxs-lookup"><span data-stu-id="4a495-105">Your goal is to create a single cohesive domain model for each business microservice or Bounded Context (BC).</span></span> <span data-ttu-id="4a495-106">Mějte však na paměti, že bc nebo obchodní mikroslužby může být někdy skládá z několika fyzických služeb, které sdílejí model jedné domény.</span><span class="sxs-lookup"><span data-stu-id="4a495-106">Keep in mind, however, that a BC or business microservice could sometimes be composed of several physical services that share a single domain model.</span></span> <span data-ttu-id="4a495-107">Model domény musí zachytit pravidla, chování, obchodní jazyk a omezení jednoho ohraničeného kontextu nebo obchodní mikroslužby, které představuje.</span><span class="sxs-lookup"><span data-stu-id="4a495-107">The domain model must capture the rules, behavior, business language, and constraints of the single Bounded Context or business microservice that it represents.</span></span>

## <a name="the-domain-entity-pattern"></a><span data-ttu-id="4a495-108">Vzor entity domény</span><span class="sxs-lookup"><span data-stu-id="4a495-108">The Domain Entity pattern</span></span>

<span data-ttu-id="4a495-109">Entity představují objekty domény a jsou primárně definovány jejich identitou, kontinuitou a trvalostí v průběhu času, a nikoli pouze atributy, které je tvoří.</span><span class="sxs-lookup"><span data-stu-id="4a495-109">Entities represent domain objects and are primarily defined by their identity, continuity, and persistence over time, and not only by the attributes that comprise them.</span></span> <span data-ttu-id="4a495-110">Jak říká Eric Evans, "objekt primárně definovaný jeho identitou se nazývá entita."</span><span class="sxs-lookup"><span data-stu-id="4a495-110">As Eric Evans says, "an object primarily defined by its identity is called an Entity."</span></span> <span data-ttu-id="4a495-111">Entity jsou velmi důležité v modelu domény, protože jsou základem pro model.</span><span class="sxs-lookup"><span data-stu-id="4a495-111">Entities are very important in the domain model, since they are the base for a model.</span></span> <span data-ttu-id="4a495-112">Proto byste je měli pečlivě identifikovat a navrhnout.</span><span class="sxs-lookup"><span data-stu-id="4a495-112">Therefore, you should identify and design them carefully.</span></span>

<span data-ttu-id="4a495-113">*Identita entity může procházet více mikroslužeb nebo ohraničené kontexty.*</span><span class="sxs-lookup"><span data-stu-id="4a495-113">*An entity's identity can cross multiple microservices or Bounded Contexts.*</span></span>

<span data-ttu-id="4a495-114">Stejná identita (to znamená, že stejná `Id` hodnota, i když možná není stejná entita domény) lze modelovat napříč více ohraničené kontexty nebo mikroslužeb.</span><span class="sxs-lookup"><span data-stu-id="4a495-114">The same identity (that is, the same `Id` value, although perhaps not the same domain entity) can be modeled across multiple Bounded Contexts or microservices.</span></span> <span data-ttu-id="4a495-115">To však neznamená, že stejná entita se stejnými atributy a logikou by byla implementována ve více ohraničených kontextech.</span><span class="sxs-lookup"><span data-stu-id="4a495-115">However, that does not imply that the same entity, with the same attributes and logic would be implemented in multiple Bounded Contexts.</span></span> <span data-ttu-id="4a495-116">Místo toho entity v každém ohraničeném kontextu omezují jejich atributy a chování na ty, které jsou požadovány v doméně ohraničeného kontextu.</span><span class="sxs-lookup"><span data-stu-id="4a495-116">Instead, entities in each Bounded Context limit their attributes and behaviors to those required in that Bounded Context's domain.</span></span>

<span data-ttu-id="4a495-117">Například entita kupujícího může mít většinu atributů osoby, které jsou definovány v entitě uživatele v mikroslužbě profilu nebo identity, včetně identity.</span><span class="sxs-lookup"><span data-stu-id="4a495-117">For instance, the buyer entity might have most of a person's attributes that are defined in the user entity in the profile or identity microservice, including the identity.</span></span> <span data-ttu-id="4a495-118">Ale entita kupujícív objednávání mikroslužby může mít méně atributů, protože pouze určitá data kupujícího souvisí s procesem objednávky.</span><span class="sxs-lookup"><span data-stu-id="4a495-118">But the buyer entity in the ordering microservice might have fewer attributes, because only certain buyer data is related to the order process.</span></span> <span data-ttu-id="4a495-119">Kontext každé mikroslužby nebo ohraničený kontext má vliv na jeho model domény.</span><span class="sxs-lookup"><span data-stu-id="4a495-119">The context of each microservice or Bounded Context impacts its domain model.</span></span>

<span data-ttu-id="4a495-120">*Entity domény musí implementovat chování kromě implementace atributů dat.*</span><span class="sxs-lookup"><span data-stu-id="4a495-120">*Domain entities must implement behavior in addition to implementing data attributes.*</span></span>

<span data-ttu-id="4a495-121">Entita domény v DDD musí implementovat logiku domény nebo chování související s daty entity (objekt přístupný v paměti).</span><span class="sxs-lookup"><span data-stu-id="4a495-121">A domain entity in DDD must implement the domain logic or behavior related to the entity data (the object accessed in memory).</span></span> <span data-ttu-id="4a495-122">Například jako součást třídy entity objednávky musíte mít obchodní logiku a operace implementovány jako metody pro úkoly, jako je přidání položky objednávky, ověření dat a celkový výpočet.</span><span class="sxs-lookup"><span data-stu-id="4a495-122">For example, as part of an order entity class you must have business logic and operations implemented as methods for tasks such as adding an order item, data validation, and total calculation.</span></span> <span data-ttu-id="4a495-123">Metody entity se starají o invarianty a pravidla entity namísto rozložení těchto pravidel na aplikační vrstvu.</span><span class="sxs-lookup"><span data-stu-id="4a495-123">The entity's methods take care of the invariants and rules of the entity instead of having those rules spread across the application layer.</span></span>

<span data-ttu-id="4a495-124">Obrázek 7-8 znázorňuje entitu domény, která implementuje nejen atributy dat, ale i operace nebo metody s logikou související domény.</span><span class="sxs-lookup"><span data-stu-id="4a495-124">Figure 7-8 shows a domain entity that implements not only data attributes but operations or methods with related domain logic.</span></span>

![Diagram znázorňující vzor entity domény.](./media/microservice-domain-model/domain-entity-pattern.png)

<span data-ttu-id="4a495-126">**Obrázek 7-8**.</span><span class="sxs-lookup"><span data-stu-id="4a495-126">**Figure 7-8**.</span></span> <span data-ttu-id="4a495-127">Příklad návrhu entity domény implementující data plus chování</span><span class="sxs-lookup"><span data-stu-id="4a495-127">Example of a domain entity design implementing data plus behavior</span></span>

<span data-ttu-id="4a495-128">Entita modelu domény implementuje chování prostřednictvím metod, to znamená, že není "chudokrevný" model.</span><span class="sxs-lookup"><span data-stu-id="4a495-128">A domain model entity implements behaviors through methods, that is, it's not an "anemic" model.</span></span> <span data-ttu-id="4a495-129">Samozřejmě někdy můžete mít entity, které neimplementují žádnou logiku jako součást třídy entity.</span><span class="sxs-lookup"><span data-stu-id="4a495-129">Of course, sometimes you can have entities that do not implement any logic as part of the entity class.</span></span> <span data-ttu-id="4a495-130">K tomu může dojít v podřízených entitách v rámci agregace, pokud podřízená entita nemá žádnou zvláštní logiku, protože většina logiky je definována v agregačním kořenovém adresáři.</span><span class="sxs-lookup"><span data-stu-id="4a495-130">This can happen in child entities within an aggregate if the child entity does not have any special logic because most of the logic is defined in the aggregate root.</span></span> <span data-ttu-id="4a495-131">Pokud máte komplexní mikroslužbu, která má velké množství logiky implementované ve třídách služby namísto v entitách domény, může být spadají do modelu anemické domény, je vysvětleno v následující části.</span><span class="sxs-lookup"><span data-stu-id="4a495-131">If you have a complex microservice that has a lot of logic implemented in the service classes instead of in the domain entities, you could be falling into the anemic domain model, explained in the following section.</span></span>

### <a name="rich-domain-model-versus-anemic-domain-model"></a><span data-ttu-id="4a495-132">Bohatý model domény versus model chudokrevné domény</span><span class="sxs-lookup"><span data-stu-id="4a495-132">Rich domain model versus anemic domain model</span></span>

<span data-ttu-id="4a495-133">Ve svém [příspěvku AnemicDomainModel](https://martinfowler.com/bliki/AnemicDomainModel.html), Martin Fowler popisuje anemický model domény tímto způsobem:</span><span class="sxs-lookup"><span data-stu-id="4a495-133">In his post [AnemicDomainModel](https://martinfowler.com/bliki/AnemicDomainModel.html), Martin Fowler describes an anemic domain model this way:</span></span>

<span data-ttu-id="4a495-134">Základním příznakem anemické domény Model je, že na první červenat to vypadá jako skutečná věc.</span><span class="sxs-lookup"><span data-stu-id="4a495-134">The basic symptom of an Anemic Domain Model is that at first blush it looks like the real thing.</span></span> <span data-ttu-id="4a495-135">Existují objekty, mnoho pojmenovaných po substivatelech v prostoru domény a tyto objekty jsou spojeny s bohatými vztahy a strukturou, které mají skutečné modely domén.</span><span class="sxs-lookup"><span data-stu-id="4a495-135">There are objects, many named after the nouns in the domain space, and these objects are connected with the rich relationships and structure that true domain models have.</span></span> <span data-ttu-id="4a495-136">Úlovek přichází, když se podíváte na chování, a uvědomíte si, že tam je téměř žádné chování na tyto objekty, což je o něco více než pytle getters a setters.</span><span class="sxs-lookup"><span data-stu-id="4a495-136">The catch comes when you look at the behavior, and you realize that there is hardly any behavior on these objects, making them little more than bags of getters and setters.</span></span>

<span data-ttu-id="4a495-137">Samozřejmě, když použijete model chudokrevné domény, tyto datové modely budou použity ze sady objektů služby (tradičně pojmenovaných *obchodní vrstva),* které zachycují všechny domény nebo obchodní logiku.</span><span class="sxs-lookup"><span data-stu-id="4a495-137">Of course, when you use an anemic domain model, those data models will be used from a set of service objects (traditionally named the *business layer*) which capture all the domain or business logic.</span></span> <span data-ttu-id="4a495-138">Obchodní vrstva je na datovém modelu a používá datový model stejně jako data.</span><span class="sxs-lookup"><span data-stu-id="4a495-138">The business layer sits on top of the data model and uses the data model just as data.</span></span>

<span data-ttu-id="4a495-139">Anemický model domény je jen procedurální styl designu.</span><span class="sxs-lookup"><span data-stu-id="4a495-139">The anemic domain model is just a procedural style design.</span></span> <span data-ttu-id="4a495-140">Objekty anemické entity nejsou skutečné objekty, protože postrádají chování (metody).</span><span class="sxs-lookup"><span data-stu-id="4a495-140">Anemic entity objects are not real objects because they lack behavior (methods).</span></span> <span data-ttu-id="4a495-141">Uchovávají pouze vlastnosti dat, a proto není objektově orientovaným návrhem.</span><span class="sxs-lookup"><span data-stu-id="4a495-141">They only hold data properties and thus it is not object-oriented design.</span></span> <span data-ttu-id="4a495-142">Vložením všech chování do objektů služby (obchodní vrstva) v podstatě skončíte s [špagetovým kódem](https://en.wikipedia.org/wiki/Spaghetti_code) nebo [transakčními skripty](https://martinfowler.com/eaaCatalog/transactionScript.html), a proto ztratíte výhody, které poskytuje model domény.</span><span class="sxs-lookup"><span data-stu-id="4a495-142">By putting all the behavior out into service objects (the business layer) you essentially end up with [spaghetti code](https://en.wikipedia.org/wiki/Spaghetti_code) or [transaction scripts](https://martinfowler.com/eaaCatalog/transactionScript.html), and therefore you lose the advantages that a domain model provides.</span></span>

<span data-ttu-id="4a495-143">Bez ohledu na to, pokud vaše mikroslužeb nebo ohraničený kontext je velmi jednoduché (služba CRUD), anemické doménové modely ve formě objektů entity s pouze vlastnosti dat může být dost dobré a nemusí být vhodné implementovat složitější vzory DDD.</span><span class="sxs-lookup"><span data-stu-id="4a495-143">Regardless, if your microservice or Bounded Context is very simple (a CRUD service), the anemic domain model in the form of entity objects with just data properties might be good enough, and it might not be worth implementing more complex DDD patterns.</span></span> <span data-ttu-id="4a495-144">V takovém případě to bude jednoduše model trvalosti, protože jste záměrně vytvořili entitu s pouze daty pro účely CRUD.</span><span class="sxs-lookup"><span data-stu-id="4a495-144">In that case, it will be simply a persistence model, because you have intentionally created an entity with only data for CRUD purposes.</span></span>

<span data-ttu-id="4a495-145">To je důvod, proč architektury mikroslužeb jsou ideální pro vícearchitektonický přístup v závislosti na každém ohraničené kontextu.</span><span class="sxs-lookup"><span data-stu-id="4a495-145">That is why microservices architectures are perfect for a multi-architectural approach depending on each Bounded Context.</span></span> <span data-ttu-id="4a495-146">Například v eShopOnContainers objednávání mikroslužby implementuje DDD vzory, ale mikroslužby katalogu, což je jednoduchá služba CRUD, není.</span><span class="sxs-lookup"><span data-stu-id="4a495-146">For instance, in eShopOnContainers, the ordering microservice implements DDD patterns, but the catalog microservice, which is a simple CRUD service, does not.</span></span>

<span data-ttu-id="4a495-147">Někteří lidé říkají, že anemický model domény je anti-vzor.</span><span class="sxs-lookup"><span data-stu-id="4a495-147">Some people say that the anemic domain model is an anti-pattern.</span></span> <span data-ttu-id="4a495-148">To opravdu záleží na tom, co implementujete.</span><span class="sxs-lookup"><span data-stu-id="4a495-148">It really depends on what you are implementing.</span></span> <span data-ttu-id="4a495-149">Pokud mikroslužbu, kterou vytváříte, je dostatečně jednoduchá (například služba CRUD), po modelu anemické domény není anti-pattern.</span><span class="sxs-lookup"><span data-stu-id="4a495-149">If the microservice you are creating is simple enough (for example, a CRUD service), following the anemic domain model it is not an anti-pattern.</span></span> <span data-ttu-id="4a495-150">Pokud však potřebujete řešit složitost domény mikroslužeb, která má mnoho neustále se měnících obchodních pravidel, může být model chudokrevné domény anti-vzor pro tuto mikroslužbu nebo ohraničený kontext.</span><span class="sxs-lookup"><span data-stu-id="4a495-150">However, if you need to tackle the complexity of a microservice's domain that has a lot of ever-changing business rules, the anemic domain model might be an anti-pattern for that microservice or Bounded Context.</span></span> <span data-ttu-id="4a495-151">V takovém případě jeho návrh jako bohatý model s entitami obsahujícími data a chování, stejně jako implementace dalších vzorů DDD (agregace, hodnotové objekty atd.) může mít obrovské výhody pro dlouhodobý úspěch takové mikroslužby.</span><span class="sxs-lookup"><span data-stu-id="4a495-151">In that case, designing it as a rich model with entities containing data plus behavior as well as implementing additional DDD patterns (aggregates, value objects, etc.) might have huge benefits for the long-term success of such a microservice.</span></span>

#### <a name="additional-resources"></a><span data-ttu-id="4a495-152">Další zdroje</span><span class="sxs-lookup"><span data-stu-id="4a495-152">Additional resources</span></span>

- <span data-ttu-id="4a495-153">**DevIQ. Entita domény** </span><span class="sxs-lookup"><span data-stu-id="4a495-153">**DevIQ. Domain Entity** </span></span>\
  <https://deviq.com/entity/>

- <span data-ttu-id="4a495-154">**Martin Fowler. Model domény** </span><span class="sxs-lookup"><span data-stu-id="4a495-154">**Martin Fowler. The Domain Model** </span></span>\
  <https://martinfowler.com/eaaCatalog/domainModel.html>

- <span data-ttu-id="4a495-155">**Martin Fowler. Annemic doménový model** </span><span class="sxs-lookup"><span data-stu-id="4a495-155">**Martin Fowler. The Anemic Domain Model** </span></span>\
  <https://martinfowler.com/bliki/AnemicDomainModel.html>

### <a name="the-value-object-pattern"></a><span data-ttu-id="4a495-156">Vzor Objekt hodnoty</span><span class="sxs-lookup"><span data-stu-id="4a495-156">The Value Object pattern</span></span>

<span data-ttu-id="4a495-157">Jak poznamenal Eric Evans: "Mnoho objektů nemá koncepční identitu.</span><span class="sxs-lookup"><span data-stu-id="4a495-157">As Eric Evans has noted, "Many objects do not have conceptual identity.</span></span> <span data-ttu-id="4a495-158">Tyto objekty popisují určité vlastnosti věci."</span><span class="sxs-lookup"><span data-stu-id="4a495-158">These objects describe certain characteristics of a thing."</span></span>

<span data-ttu-id="4a495-159">Entita vyžaduje identitu, ale existuje mnoho objektů v systému, které nemají, stejně jako vzor Value Object.</span><span class="sxs-lookup"><span data-stu-id="4a495-159">An entity requires an identity, but there are many objects in a system that do not, like the Value Object pattern.</span></span> <span data-ttu-id="4a495-160">Objekt hodnoty je objekt bez konceptuální identity, který popisuje aspekt domény.</span><span class="sxs-lookup"><span data-stu-id="4a495-160">A value object is an object with no conceptual identity that describes a domain aspect.</span></span> <span data-ttu-id="4a495-161">Jedná se o objekty, které konkretizovat představují prvky návrhu, které se týkají pouze dočasně.</span><span class="sxs-lookup"><span data-stu-id="4a495-161">These are objects that you instantiate to represent design elements that only concern you temporarily.</span></span> <span data-ttu-id="4a495-162">Záleží ti na tom, *co* jsou, ne *na tom, kdo* jsou.</span><span class="sxs-lookup"><span data-stu-id="4a495-162">You care about *what* they are, not *who* they are.</span></span> <span data-ttu-id="4a495-163">Příklady zahrnují čísla a řetězce, ale mohou být také koncepty vyšší úrovně, jako jsou skupiny atributů.</span><span class="sxs-lookup"><span data-stu-id="4a495-163">Examples include numbers and strings, but can also be higher-level concepts like groups of attributes.</span></span>

<span data-ttu-id="4a495-164">Něco, co je entita v mikroslužeb nemusí být entita v jiné mikroslužby, protože v druhém případě ohraničené kontextu může mít jiný význam.</span><span class="sxs-lookup"><span data-stu-id="4a495-164">Something that is an entity in a microservice might not be an entity in another microservice, because in the second case, the Bounded Context might have a different meaning.</span></span> <span data-ttu-id="4a495-165">Například adresa v aplikaci elektronického obchodu nemusí mít identitu vůbec, protože může představovat pouze skupinu atributů profilu zákazníka pro osobu nebo společnost.</span><span class="sxs-lookup"><span data-stu-id="4a495-165">For example, an address in an e-commerce application might not have an identity at all, since it might only represent a group of attributes of the customer's profile for a person or company.</span></span> <span data-ttu-id="4a495-166">V takovém případě by měla být adresa klasifikována jako objekt hodnoty.</span><span class="sxs-lookup"><span data-stu-id="4a495-166">In this case, the address should be classified as a value object.</span></span> <span data-ttu-id="4a495-167">V aplikaci pro energetickou společnost by však mohla být adresa zákazníka důležitá pro obchodní doménu.</span><span class="sxs-lookup"><span data-stu-id="4a495-167">However, in an application for an electric power utility company, the customer address could be important for the business domain.</span></span> <span data-ttu-id="4a495-168">Proto musí mít adresa identitu, aby fakturační systém mohl být přímo propojen s adresou.</span><span class="sxs-lookup"><span data-stu-id="4a495-168">Therefore, the address must have an identity so the billing system can be directly linked to the address.</span></span> <span data-ttu-id="4a495-169">V takovém případě by měla být adresa klasifikována jako entita domény.</span><span class="sxs-lookup"><span data-stu-id="4a495-169">In that case, an address should be classified as a domain entity.</span></span>

<span data-ttu-id="4a495-170">Osoba se jménem a příjmením je obvykle subjektem, protože osoba má totožnost, a to i v případě, že se jméno a příjmení shodují s jinou sadou hodnot, například pokud se tato jména vztahují i na jinou osobu.</span><span class="sxs-lookup"><span data-stu-id="4a495-170">A person with a name and surname is usually an entity because a person has identity, even if the name and surname coincide with another set of values, such as if those names also refers to a different person.</span></span>

<span data-ttu-id="4a495-171">Hodnotové objekty je obtížné spravovat v relačních databázích a ORM, jako je entity Framework (EF), zatímco v databázích orientovaných na dokumenty se snadněji implementují a používají.</span><span class="sxs-lookup"><span data-stu-id="4a495-171">Value objects are hard to manage in relational databases and ORMs like Entity Framework (EF), whereas in document-oriented databases they are easier to implement and use.</span></span>

<span data-ttu-id="4a495-172">EF Core 2.0 a novější verze zahrnují [funkci Vlastněných entit,](https://devblogs.microsoft.com/dotnet/announcing-entity-framework-core-2-0/#owned-entities-and-table-splitting) která usnadňuje zpracování hodnotových objektů, jak uvidíme podrobně později.</span><span class="sxs-lookup"><span data-stu-id="4a495-172">EF Core 2.0 and later versions include the [Owned Entities](https://devblogs.microsoft.com/dotnet/announcing-entity-framework-core-2-0/#owned-entities-and-table-splitting) feature that makes it easier to handle value objects, as we’ll see in detail later on.</span></span>

#### <a name="additional-resources"></a><span data-ttu-id="4a495-173">Další zdroje</span><span class="sxs-lookup"><span data-stu-id="4a495-173">Additional resources</span></span>

- <span data-ttu-id="4a495-174">**Martin Fowler. Vzor objektu hodnoty** </span><span class="sxs-lookup"><span data-stu-id="4a495-174">**Martin Fowler. Value Object pattern** </span></span>\
  <https://martinfowler.com/bliki/ValueObject.html>

- <span data-ttu-id="4a495-175">**Objekt hodnoty** </span><span class="sxs-lookup"><span data-stu-id="4a495-175">**Value Object** </span></span>\
  <https://deviq.com/value-object/>

- <span data-ttu-id="4a495-176">**Hodnotové objekty ve vývoji řízeném testem** </span><span class="sxs-lookup"><span data-stu-id="4a495-176">**Value Objects in Test-Driven Development** </span></span>\
  [https://leanpub.com/tdd-ebook/read\#leanpub-auto-value-objects](https://leanpub.com/tdd-ebook/read#leanpub-auto-value-objects)

- <span data-ttu-id="4a495-177">**Eric Evans. Návrh řízený doménou: Řešení složitosti v srdci softwaru.**</span><span class="sxs-lookup"><span data-stu-id="4a495-177">**Eric Evans. Domain-Driven Design: Tackling Complexity in the Heart of Software.**</span></span> <span data-ttu-id="4a495-178">(Kniha; obsahuje diskusi o hodnotových objektech) </span><span class="sxs-lookup"><span data-stu-id="4a495-178">(Book; includes a discussion of value objects) </span></span>\
  <https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/>

### <a name="the-aggregate-pattern"></a><span data-ttu-id="4a495-179">Agregační vzor</span><span class="sxs-lookup"><span data-stu-id="4a495-179">The Aggregate pattern</span></span>

<span data-ttu-id="4a495-180">Model domény obsahuje clustery různých datových entit a procesů, které mohou řídit významnou oblast funkčnosti, jako je plnění objednávek nebo zásoby.</span><span class="sxs-lookup"><span data-stu-id="4a495-180">A domain model contains clusters of different data entities and processes that can control a significant area of functionality, such as order fulfillment or inventory.</span></span> <span data-ttu-id="4a495-181">Více jemně odstupňované Jednotky DDD je agregace, která popisuje cluster nebo skupinu entit a chování, které lze považovat za soudržnou jednotku.</span><span class="sxs-lookup"><span data-stu-id="4a495-181">A more fine-grained DDD unit is the aggregate, which describes a cluster or group of entities and behaviors that can be treated as a cohesive unit.</span></span>

<span data-ttu-id="4a495-182">Obvykle definujete agregaci na základě transakcí, které potřebujete.</span><span class="sxs-lookup"><span data-stu-id="4a495-182">You usually define an aggregate based on the transactions that you need.</span></span> <span data-ttu-id="4a495-183">Klasickým příkladem je objednávka, která obsahuje také seznam položek objednávky.</span><span class="sxs-lookup"><span data-stu-id="4a495-183">A classic example is an order that also contains a list of order items.</span></span> <span data-ttu-id="4a495-184">Zboží objednávky bude obvykle entita.</span><span class="sxs-lookup"><span data-stu-id="4a495-184">An order item will usually be an entity.</span></span> <span data-ttu-id="4a495-185">Ale bude podřízená entita v rámci agregace objednávky, která bude také obsahovat entitu objednávky jako její kořenovou entitu, obvykle nazývanou agregační kořen.</span><span class="sxs-lookup"><span data-stu-id="4a495-185">But it will be a child entity within the order aggregate, which will also contain the order entity as its root entity, typically called an aggregate root.</span></span>

<span data-ttu-id="4a495-186">Identifikace agregátů může být těžká.</span><span class="sxs-lookup"><span data-stu-id="4a495-186">Identifying aggregates can be hard.</span></span> <span data-ttu-id="4a495-187">Agregace je skupina objektů, které musí být konzistentní dohromady, ale nelze pouze vybrat skupinu objektů a označit je agregaci.</span><span class="sxs-lookup"><span data-stu-id="4a495-187">An aggregate is a group of objects that must be consistent together, but you cannot just pick a group of objects and label them an aggregate.</span></span> <span data-ttu-id="4a495-188">Musíte začít s konceptem domény a přemýšlet o entitách, které se používají v nejběžnějších transakcích souvisejících s tímto konceptem.</span><span class="sxs-lookup"><span data-stu-id="4a495-188">You must start with a domain concept and think about the entities that are used in the most common transactions related to that concept.</span></span> <span data-ttu-id="4a495-189">Tyto entity, které musí být transakce konzistentní jsou to, co tvoří agregaci.</span><span class="sxs-lookup"><span data-stu-id="4a495-189">Those entities that need to be transactionally consistent are what forms an aggregate.</span></span> <span data-ttu-id="4a495-190">Přemýšlení o transakčních operacích je pravděpodobně nejlepší způsob, jak identifikovat agregáty.</span><span class="sxs-lookup"><span data-stu-id="4a495-190">Thinking about transaction operations is probably the best way to identify aggregates.</span></span>

### <a name="the-aggregate-root-or-root-entity-pattern"></a><span data-ttu-id="4a495-191">Vzor agregované kořenové nebo kořenové entity</span><span class="sxs-lookup"><span data-stu-id="4a495-191">The Aggregate Root or Root Entity pattern</span></span>

<span data-ttu-id="4a495-192">Agregace se skládá alespoň z jedné entity: agregační kořen, také nazývaný kořenová entita nebo primární entita.</span><span class="sxs-lookup"><span data-stu-id="4a495-192">An aggregate is composed of at least one entity: the aggregate root, also called root entity or primary entity.</span></span> <span data-ttu-id="4a495-193">Navíc může mít více podřízených entit a hodnotových objektů, přičemž všechny entity a objekty spolupracují na implementaci požadovaného chování a transakcí.</span><span class="sxs-lookup"><span data-stu-id="4a495-193">Additionally, it can have multiple child entities and value objects, with all entities and objects working together to implement required behavior and transactions.</span></span>

<span data-ttu-id="4a495-194">Účelem agregovaného kořene je zajistit konzistenci agregátu; měl by být jediným vstupním bodem pro aktualizace agregace prostřednictvím metod nebo operací v agregované kořenové třídě.</span><span class="sxs-lookup"><span data-stu-id="4a495-194">The purpose of an aggregate root is to ensure the consistency of the aggregate; it should be the only entry point for updates to the aggregate through methods or operations in the aggregate root class.</span></span> <span data-ttu-id="4a495-195">Změny entit v rámci agregace byste měli provádět pouze prostřednictvím agregačního kořenového adresáře.</span><span class="sxs-lookup"><span data-stu-id="4a495-195">You should make changes to entities within the aggregate only via the aggregate root.</span></span> <span data-ttu-id="4a495-196">Je agregát konzistence opatrovník, s ohledem na všechny invariants a pravidla konzistence, které budete muset dodržovat v agregátu.</span><span class="sxs-lookup"><span data-stu-id="4a495-196">It is the aggregate's consistency guardian, considering all the invariants and consistency rules you might need to comply with in your aggregate.</span></span> <span data-ttu-id="4a495-197">Pokud změníte podřízenou entitu nebo objekt hodnoty nezávisle, agregační kořen nemůže zajistit, že agregace je v platném stavu.</span><span class="sxs-lookup"><span data-stu-id="4a495-197">If you change a child entity or value object independently, the aggregate root cannot ensure that the aggregate is in a valid state.</span></span> <span data-ttu-id="4a495-198">Bylo by to jako stůl s volnou nohou.</span><span class="sxs-lookup"><span data-stu-id="4a495-198">It would be like a table with a loose leg.</span></span> <span data-ttu-id="4a495-199">Zachování konzistence je hlavním účelem agregačníkořen.</span><span class="sxs-lookup"><span data-stu-id="4a495-199">Maintaining consistency is the main purpose of the aggregate root.</span></span>

<span data-ttu-id="4a495-200">Na obrázku 7-9 můžete vidět ukázkové agregace, jako je agregace kupujícího, která obsahuje jednu entitu (agregační kořenový kupující).</span><span class="sxs-lookup"><span data-stu-id="4a495-200">In Figure 7-9, you can see sample aggregates like the buyer aggregate, which contains a single entity (the aggregate root Buyer).</span></span> <span data-ttu-id="4a495-201">Agregace pořadí obsahuje více entit a objekt hodnoty.</span><span class="sxs-lookup"><span data-stu-id="4a495-201">The order aggregate contains multiple entities and a value object.</span></span>

![Diagram porovnání agregace kupujícího a agregace objednávky.](./media/microservice-domain-model/buyer-order-aggregate-pattern.png)

<span data-ttu-id="4a495-203">**Obrázek 7-9**.</span><span class="sxs-lookup"><span data-stu-id="4a495-203">**Figure 7-9**.</span></span> <span data-ttu-id="4a495-204">Příklad agregací s více nebo jednotlivými entitami</span><span class="sxs-lookup"><span data-stu-id="4a495-204">Example of aggregates with multiple or single entities</span></span>

<span data-ttu-id="4a495-205">Model domény DDD se skládá z agregace, agregace může mít pouze jednu entitu nebo více a může také obsahovat objekty hodnoty.</span><span class="sxs-lookup"><span data-stu-id="4a495-205">A DDD domain model is composed from aggregates, an aggregate can have just one entity or more, and can include value objects as well.</span></span> <span data-ttu-id="4a495-206">Všimněte si, že Kupující agregace může mít další podřízené entity, v závislosti na vaší doméně, stejně jako v objednávání mikroslužby v referenční aplikaci eShopOnContainers.</span><span class="sxs-lookup"><span data-stu-id="4a495-206">Note that the Buyer aggregate could have additional child entities, depending on your domain, as it does in the ordering microservice in the eShopOnContainers reference application.</span></span> <span data-ttu-id="4a495-207">Obrázek 7-9 pouze ilustruje případ, ve kterém kupující má jednu entitu, jako příklad agregátu, který obsahuje pouze agregační kořen.</span><span class="sxs-lookup"><span data-stu-id="4a495-207">Figure 7-9 just illustrates a case in which the buyer has a single entity, as an example of an aggregate that contains only an aggregate root.</span></span>

<span data-ttu-id="4a495-208">Chcete-li zachovat oddělení agregace a zachovat jasné hranice mezi nimi, je vhodné v modelu domény DDD zakázat přímou navigaci mezi agregacemi a pouze s polem cizího klíče (FK), jak je implementováno v [modelu domény mikroslužeb](https://github.com/dotnet-architecture/eShopOnContainers/blob/master/src/Services/Ordering/Ordering.Domain/AggregatesModel/OrderAggregate/Order.cs) v eShopOnContainers.</span><span class="sxs-lookup"><span data-stu-id="4a495-208">In order to maintain separation of aggregates and keep clear boundaries between them, it is a good practice in a DDD domain model to disallow direct navigation between aggregates and only having the foreign key (FK) field, as implemented in the [Ordering microservice domain model](https://github.com/dotnet-architecture/eShopOnContainers/blob/master/src/Services/Ordering/Ordering.Domain/AggregatesModel/OrderAggregate/Order.cs) in eShopOnContainers.</span></span> <span data-ttu-id="4a495-209">Entita Objednávka má pouze pole FK pro kupujícího, ale ne navigační vlastnost EF Core, jak je znázorněno v následujícím kódu:</span><span class="sxs-lookup"><span data-stu-id="4a495-209">The Order entity only has a FK field for the buyer, but not an EF Core navigation property, as shown in the following code:</span></span>

```csharp
public class Order : Entity, IAggregateRoot
{
    private DateTime _orderDate;
    public Address Address { get; private set; }
    private int? _buyerId; //FK pointing to a different aggregate root
    public OrderStatus OrderStatus { get; private set; }
    private readonly List<OrderItem> _orderItems;
    public IReadOnlyCollection<OrderItem> OrderItems => _orderItems;
    // ... Additional code
}
```

<span data-ttu-id="4a495-210">Identifikace a práce s agregáty vyžaduje výzkum a zkušenosti.</span><span class="sxs-lookup"><span data-stu-id="4a495-210">Identifying and working with aggregates requires research and experience.</span></span> <span data-ttu-id="4a495-211">Další informace naleznete v následujícím seznamu Další zdroje.</span><span class="sxs-lookup"><span data-stu-id="4a495-211">For more information, see the following Additional resources list.</span></span>

#### <a name="additional-resources"></a><span data-ttu-id="4a495-212">Další zdroje</span><span class="sxs-lookup"><span data-stu-id="4a495-212">Additional resources</span></span>

- <span data-ttu-id="4a495-213">**Vaughn Vernon, to je můj zástupce. Efektivní agregační design - část I: Modelování jednoho agregátu** (od <http://dddcommunity.org/>) </span><span class="sxs-lookup"><span data-stu-id="4a495-213">**Vaughn Vernon. Effective Aggregate Design - Part I: Modeling a Single Aggregate** (from <http://dddcommunity.org/>) </span></span>\
  <http://dddcommunity.org/wp-content/uploads/files/pdf_articles/Vernon_2011_1.pdf>

- <span data-ttu-id="4a495-214">**Vaughn Vernon, to je můj zástupce. Efektivní agregační design - část II: Tvorba agregáty pracovat společně** (od <http://dddcommunity.org/>) </span><span class="sxs-lookup"><span data-stu-id="4a495-214">**Vaughn Vernon. Effective Aggregate Design - Part II: Making Aggregates Work Together** (from <http://dddcommunity.org/>) </span></span>\
  <http://dddcommunity.org/wp-content/uploads/files/pdf_articles/Vernon_2011_2.pdf>

- <span data-ttu-id="4a495-215">**Vaughn Vernon, to je můj zástupce. Efektivní agregační design - část III: Získání Insight Prostřednictvím Discovery** (od <http://dddcommunity.org/>) </span><span class="sxs-lookup"><span data-stu-id="4a495-215">**Vaughn Vernon. Effective Aggregate Design - Part III: Gaining Insight Through Discovery** (from <http://dddcommunity.org/>) </span></span>\
  <http://dddcommunity.org/wp-content/uploads/files/pdf_articles/Vernon_2011_3.pdf>

- <span data-ttu-id="4a495-216">**Sergej Grybniak. DDD Taktické návrhové vzory** </span><span class="sxs-lookup"><span data-stu-id="4a495-216">**Sergey Grybniak. DDD Tactical Design Patterns** </span></span>\
  <https://www.codeproject.com/Articles/1164363/Domain-Driven-Design-Tactical-Design-Patterns-Part>

- <span data-ttu-id="4a495-217">**Chrise Richardsona. Vývoj transakčních mikroslužeb pomocí agregací** </span><span class="sxs-lookup"><span data-stu-id="4a495-217">**Chris Richardson. Developing Transactional Microservices Using Aggregates** </span></span>\
  <https://www.infoq.com/articles/microservices-aggregates-events-cqrs-part-1-richardson>

- <span data-ttu-id="4a495-218">**DevIQ. Agregační vzor** </span><span class="sxs-lookup"><span data-stu-id="4a495-218">**DevIQ. The Aggregate pattern** </span></span>\
  <https://deviq.com/aggregate-pattern/>

>[!div class="step-by-step"]
><span data-ttu-id="4a495-219">[Předchozí](ddd-oriented-microservice.md)
>[další](net-core-microservice-domain-model.md)</span><span class="sxs-lookup"><span data-stu-id="4a495-219">[Previous](ddd-oriented-microservice.md)
[Next](net-core-microservice-domain-model.md)</span></span>
