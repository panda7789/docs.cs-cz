---
title: Návrh vrstvy trvalosti infrastruktury
description: Architektura mikroslužeb .NET pro kontejnerové aplikace .NET | Prozkoumejte vzor úložiště v návrhu vrstvy trvalosti infrastruktury.
ms.date: 10/08/2018
ms.openlocfilehash: f1c5df1cc5672760374610a416ae22b45cd76c25
ms.sourcegitcommit: 22be09204266253d45ece46f51cc6f080f2b3fd6
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 11/07/2019
ms.locfileid: "73737940"
---
# <a name="design-the-infrastructure-persistence-layer"></a><span data-ttu-id="d64c2-103">Návrh vrstvy trvalosti infrastruktury</span><span class="sxs-lookup"><span data-stu-id="d64c2-103">Design the infrastructure persistence layer</span></span>

<span data-ttu-id="d64c2-104">Komponenty Trvalost dat poskytují přístup k datům hostovaným v rámci hranic mikroslužby (tj. databáze mikroslužeb).</span><span class="sxs-lookup"><span data-stu-id="d64c2-104">Data persistence components provide access to the data hosted within the boundaries of a microservice (that is, a microservice’s database).</span></span> <span data-ttu-id="d64c2-105">Obsahují skutečnou implementaci komponent, jako jsou úložiště a [jednotky pracovních](https://martinfowler.com/eaaCatalog/unitOfWork.html) tříd, jako jsou například vlastní Entity Framework (EF) <xref:Microsoft.EntityFrameworkCore.DbContext> objekty.</span><span class="sxs-lookup"><span data-stu-id="d64c2-105">They contain the actual implementation of components such as repositories and [Unit of Work](https://martinfowler.com/eaaCatalog/unitOfWork.html) classes, like custom Entity Framework (EF) <xref:Microsoft.EntityFrameworkCore.DbContext> objects.</span></span> <span data-ttu-id="d64c2-106">EF DbContext implementuje jak úložiště, tak i pracovní jednotky.</span><span class="sxs-lookup"><span data-stu-id="d64c2-106">EF DbContext implements both, the Repository and the Unit of Work patterns.</span></span>

## <a name="the-repository-pattern"></a><span data-ttu-id="d64c2-107">Vzor úložiště</span><span class="sxs-lookup"><span data-stu-id="d64c2-107">The Repository pattern</span></span>

<span data-ttu-id="d64c2-108">Úložiště jsou třídy nebo komponenty, které zapouzdřují logiku potřebnou k přístupu ke zdrojům dat.</span><span class="sxs-lookup"><span data-stu-id="d64c2-108">Repositories are classes or components that encapsulate the logic required to access data sources.</span></span> <span data-ttu-id="d64c2-109">Slouží k centralizaci běžných funkcí přístupu k datům, což zajišťuje lepší udržovatelnost a odpojuje infrastrukturu nebo technologii používanou pro přístup k databázím z vrstvy doménového modelu.</span><span class="sxs-lookup"><span data-stu-id="d64c2-109">They centralize common data access functionality, providing better maintainability and decoupling the infrastructure or technology used to access databases from the domain model layer.</span></span> <span data-ttu-id="d64c2-110">Použijete-li objektově-relační mapovači (ORM), jako je Entity Framework, kód, který musí být implementován, je zjednodušený, díky LINQ a silnému psaní.</span><span class="sxs-lookup"><span data-stu-id="d64c2-110">If you use an Object-Relational Mapper (ORM) like Entity Framework, the code that must be implemented is simplified, thanks to LINQ and strong typing.</span></span> <span data-ttu-id="d64c2-111">To vám umožní soustředit se na logiku trvalosti dat, a ne na domovníing pro přístup k datům.</span><span class="sxs-lookup"><span data-stu-id="d64c2-111">This lets you focus on the data persistence logic rather than on data access plumbing.</span></span>

<span data-ttu-id="d64c2-112">Vzor úložiště je dobře dokumentovaný způsob práce se zdrojem dat.</span><span class="sxs-lookup"><span data-stu-id="d64c2-112">The Repository pattern is a well-documented way of working with a data source.</span></span> <span data-ttu-id="d64c2-113">V rámci příručky k [architektuře podnikových aplikací](https://www.amazon.com/Patterns-Enterprise-Application-Architecture-Martin/dp/0321127420/)Fowlera Martin popisuje úložiště následujícím způsobem:</span><span class="sxs-lookup"><span data-stu-id="d64c2-113">In the book [Patterns of Enterprise Application Architecture](https://www.amazon.com/Patterns-Enterprise-Application-Architecture-Martin/dp/0321127420/), Martin Fowler describes a repository as follows:</span></span>

> <span data-ttu-id="d64c2-114">Úložiště provádí úlohy zprostředkovatele mezi vrstvami doménového modelu a mapováním dat a funguje podobným způsobem jako sada doménových objektů v paměti.</span><span class="sxs-lookup"><span data-stu-id="d64c2-114">A repository performs the tasks of an intermediary between the domain model layers and data mapping, acting in a similar way to a set of domain objects in memory.</span></span> <span data-ttu-id="d64c2-115">Klientské objekty deklarativně sestavují dotazy a odesílají je do úložišť pro odpovědi.</span><span class="sxs-lookup"><span data-stu-id="d64c2-115">Client objects declaratively build queries and send them to the repositories for answers.</span></span> <span data-ttu-id="d64c2-116">V koncepčním případě úložiště zapouzdřuje sadu objektů uložených v databázi a operace, které lze v nich provést, a poskytuje tak způsob, který je blíže vrstvě trvalosti.</span><span class="sxs-lookup"><span data-stu-id="d64c2-116">Conceptually, a repository encapsulates a set of objects stored in the database and operations that can be performed on them, providing a way that is closer to the persistence layer.</span></span> <span data-ttu-id="d64c2-117">Úložiště také podporují účely oddělení, jasně i v jednom směru závislost mezi pracovní doménou a přidělením nebo mapováním dat.</span><span class="sxs-lookup"><span data-stu-id="d64c2-117">Repositories, also, support the purpose of separating, clearly and in one direction, the dependency between the work domain and the data allocation or mapping.</span></span>

### <a name="define-one-repository-per-aggregate"></a><span data-ttu-id="d64c2-118">Definování jednoho úložiště na agregaci</span><span class="sxs-lookup"><span data-stu-id="d64c2-118">Define one repository per aggregate</span></span>

<span data-ttu-id="d64c2-119">Pro každý agregovaný nebo agregovaný kořenový adresář byste měli vytvořit jednu třídu úložiště.</span><span class="sxs-lookup"><span data-stu-id="d64c2-119">For each aggregate or aggregate root, you should create one repository class.</span></span> <span data-ttu-id="d64c2-120">V mikroslužbě založené na vzorcích pro návrh na základě domén (DDD) by měl být jediným kanálem, který byste měli použít k aktualizaci databáze, úložiště.</span><span class="sxs-lookup"><span data-stu-id="d64c2-120">In a microservice based on Domain-Driven Design (DDD) patterns, the only channel you should use to update the database should be the repositories.</span></span> <span data-ttu-id="d64c2-121">Důvodem je, že mají relaci 1:1 s agregovaným kořenovým adresářem, který řídí invariantování agregace a transakční konzistenci.</span><span class="sxs-lookup"><span data-stu-id="d64c2-121">This is because they have a one-to-one relationship with the aggregate root, which controls the aggregate’s invariants and transactional consistency.</span></span> <span data-ttu-id="d64c2-122">Je možné se dotazovat databáze prostřednictvím jiných kanálů (jak můžete postupovat podle CQRS přístupu), protože dotazy nemění stav databáze.</span><span class="sxs-lookup"><span data-stu-id="d64c2-122">It's okay to query the database through other channels (as you can do following a CQRS approach), because queries don't change the state of the database.</span></span> <span data-ttu-id="d64c2-123">Nicméně transakční oblast (tj. aktualizace) musí být vždy ovládána úložištěm a agregovanými kořeny.</span><span class="sxs-lookup"><span data-stu-id="d64c2-123">However, the transactional area (that is, the updates) must always be controlled by the repositories and the aggregate roots.</span></span>

<span data-ttu-id="d64c2-124">V podstatě umožňuje úložiště naplnit data v paměti, která pocházejí z databáze, ve formě doménových entit.</span><span class="sxs-lookup"><span data-stu-id="d64c2-124">Basically, a repository allows you to populate data in memory that comes from the database in the form of the domain entities.</span></span> <span data-ttu-id="d64c2-125">Jakmile jsou entity v paměti, můžou se změnit a pak trvale uložit do databáze prostřednictvím transakcí.</span><span class="sxs-lookup"><span data-stu-id="d64c2-125">Once the entities are in memory, they can be changed and then persisted back to the database through transactions.</span></span>

<span data-ttu-id="d64c2-126">Jak bylo uvedeno dříve, pokud používáte model architektury CQS/CQRS, počáteční dotazy se provádějí pomocí dotazů na straně sebe z doménového modelu, které provádí jednoduché příkazy SQL pomocí Dapperem.</span><span class="sxs-lookup"><span data-stu-id="d64c2-126">As noted earlier, if you're using the CQS/CQRS architectural pattern, the initial queries are performed by side queries out of the domain model, performed by simple SQL statements using Dapper.</span></span> <span data-ttu-id="d64c2-127">Tento přístup je mnohem flexibilnější než u úložišť, protože můžete zadávat dotazy a spojit se s libovolnými tabulkami, které potřebujete, a tyto dotazy nejsou omezeny pravidly z agregací.</span><span class="sxs-lookup"><span data-stu-id="d64c2-127">This approach is much more flexible than repositories because you can query and join any tables you need, and these queries aren't restricted by rules from the aggregates.</span></span> <span data-ttu-id="d64c2-128">Tato data přecházejí do prezentační vrstvy nebo klientské aplikace.</span><span class="sxs-lookup"><span data-stu-id="d64c2-128">That data goes to the presentation layer or client app.</span></span>

<span data-ttu-id="d64c2-129">Pokud uživatel provede změny, data, která mají být aktualizována, pocházejí z klientské aplikace nebo prezentační vrstvy do aplikační vrstvy (například služby webového rozhraní API).</span><span class="sxs-lookup"><span data-stu-id="d64c2-129">If the user makes changes, the data to be updated comes from the client app or presentation layer to the application layer (such as a Web API service).</span></span> <span data-ttu-id="d64c2-130">Když obdržíte příkaz v obslužné rutině příkazu, použijete úložiště k získání dat, která chcete aktualizovat z databáze.</span><span class="sxs-lookup"><span data-stu-id="d64c2-130">When you receive a command in a command handler, you use repositories to get the data you want to update from the database.</span></span> <span data-ttu-id="d64c2-131">Aktualizujete ho v paměti daty, která byla předána pomocí příkazů, a pak v databázi přidáte nebo aktualizujete data (entity domény) v rámci transakce.</span><span class="sxs-lookup"><span data-stu-id="d64c2-131">You update it in memory with the data passed with the commands, and you then add or update the data (domain entities) in the database through a transaction.</span></span>

<span data-ttu-id="d64c2-132">Je důležité se znovu zdůraznit, že byste měli definovat jenom jedno úložiště pro každý agregovaný kořen, jak je znázorněno na obrázku 7-17.</span><span class="sxs-lookup"><span data-stu-id="d64c2-132">It's important to emphasize again that you should only define one repository for each aggregate root, as shown in Figure 7-17.</span></span> <span data-ttu-id="d64c2-133">Aby bylo možné dosáhnout cíle agregovaného kořene pro zachování transakční konzistence mezi všemi objekty v rámci agregace, neměli byste nikdy vytvořit úložiště pro každou tabulku v databázi.</span><span class="sxs-lookup"><span data-stu-id="d64c2-133">To achieve the goal of the aggregate root to maintain transactional consistency between all the objects within the aggregate, you should never create a repository for each table in the database.</span></span>

![Diagram znázorňující vztahy domény a jiné infrastruktury](./media/infrastructure-persistence-layer-design/repository-aggregate-database-table-relationships.png)

<span data-ttu-id="d64c2-135">**Obrázek 7-17**.</span><span class="sxs-lookup"><span data-stu-id="d64c2-135">**Figure 7-17**.</span></span> <span data-ttu-id="d64c2-136">Vztah mezi úložišti, agregacemi a databázovými tabulkami</span><span class="sxs-lookup"><span data-stu-id="d64c2-136">The relationship between repositories, aggregates, and database tables</span></span>

<span data-ttu-id="d64c2-137">Výše uvedený diagram znázorňuje vztahy mezi doménami a vrstvami infrastruktury: agregace kupující závisí na IBuyerRepository a pořadí agregace závisí na rozhraních IOrderRepository, tato rozhraní se implementují ve vrstvě infrastruktury. v odpovídajících úložištích, které jsou závislé na UnitOfWork, se také implementují, které přistupují k tabulkám v datové vrstvě.</span><span class="sxs-lookup"><span data-stu-id="d64c2-137">The above diagram shows the relationships between Domain and Infrastructure layers: Buyer Aggregate depends on the IBuyerRepository and Order Aggregate depends on the IOrderRepository interfaces, these interfaces are implemented in the Infrastructure layer by the corresponding repositories that depend on UnitOfWork, also implemented there, that accesses the tables in the Data tier.</span></span>

### <a name="enforce-one-aggregate-root-per-repository"></a><span data-ttu-id="d64c2-138">Vysazení jednoho agregovaného kořene na úložiště</span><span class="sxs-lookup"><span data-stu-id="d64c2-138">Enforce one aggregate root per repository</span></span>

<span data-ttu-id="d64c2-139">To může být užitečné pro implementaci návrhu úložiště takovým způsobem, že vynutilo pravidlo, že by měli mít úložiště jenom agregované kořeny.</span><span class="sxs-lookup"><span data-stu-id="d64c2-139">It can be valuable to implement your repository design in such a way that it enforces the rule that only aggregate roots should have repositories.</span></span> <span data-ttu-id="d64c2-140">Můžete vytvořit obecný nebo základní typ úložiště, který omezuje typ entit, se kterými pracuje, aby bylo zajištěno, že mají rozhraní `IAggregateRoot` značky.</span><span class="sxs-lookup"><span data-stu-id="d64c2-140">You can create a generic or base repository type that constrains the type of entities it works with to ensure they have the `IAggregateRoot` marker interface.</span></span>

<span data-ttu-id="d64c2-141">Proto každá třída úložiště implementovaná na infrastruktuře infrastruktury implementuje svůj vlastní kontrakt nebo rozhraní, jak je znázorněno v následujícím kódu:</span><span class="sxs-lookup"><span data-stu-id="d64c2-141">Thus, each repository class implemented at the infrastructure layer implements its own contract or interface, as shown in the following code:</span></span>

```csharp
namespace Microsoft.eShopOnContainers.Services.Ordering.Infrastructure.Repositories
{
    public class OrderRepository : IOrderRepository
    {
      // ...
    }
}
```

<span data-ttu-id="d64c2-142">Každé konkrétní rozhraní úložiště implementuje obecné rozhraní IRepository:</span><span class="sxs-lookup"><span data-stu-id="d64c2-142">Each specific repository interface implements the generic IRepository interface:</span></span>

```csharp
public interface IOrderRepository : IRepository<Order>
{
    Order Add(Order order);
    // ...
}
```

<span data-ttu-id="d64c2-143">Lepší způsob, jak mít kód vyhovět konvenci, že každé úložiště souvisí s jednou agregací, je implementovat obecný typ úložiště.</span><span class="sxs-lookup"><span data-stu-id="d64c2-143">However, a better way to have the code enforce the convention that each repository is related to a single aggregate is to implement a generic repository type.</span></span> <span data-ttu-id="d64c2-144">Tímto způsobem je explicitní použít úložiště k zaměření na konkrétní agregaci.</span><span class="sxs-lookup"><span data-stu-id="d64c2-144">That way, it's explicit that you're using a repository to target a specific aggregate.</span></span> <span data-ttu-id="d64c2-145">To lze snadno provést implementací obecného `IRepository` základního rozhraní, jak je uvedeno v následujícím kódu:</span><span class="sxs-lookup"><span data-stu-id="d64c2-145">That can be easily done by implementing a generic `IRepository` base interface, as in the following code:</span></span>

```csharp
public interface IRepository<T> where T : IAggregateRoot
{
    //....
}
```

### <a name="the-repository-pattern-makes-it-easier-to-test-your-application-logic"></a><span data-ttu-id="d64c2-146">Vzor úložiště usnadňuje testování logiky aplikace.</span><span class="sxs-lookup"><span data-stu-id="d64c2-146">The Repository pattern makes it easier to test your application logic</span></span>

<span data-ttu-id="d64c2-147">Vzor úložiště vám umožňuje snadno testovat aplikace pomocí testů jednotek.</span><span class="sxs-lookup"><span data-stu-id="d64c2-147">The Repository pattern allows you to easily test your application with unit tests.</span></span> <span data-ttu-id="d64c2-148">Mějte na paměti, že testy jednotek testují pouze kód, nikoli infrastrukturu, takže abstrakce úložiště usnadňují dosažení tohoto cíle.</span><span class="sxs-lookup"><span data-stu-id="d64c2-148">Remember that unit tests only test your code, not infrastructure, so the repository abstractions make it easier to achieve that goal.</span></span>

<span data-ttu-id="d64c2-149">Jak je uvedeno v předchozí části, doporučuje se definovat a umístit rozhraní úložiště do vrstvy doménového modelu, takže aplikační vrstva, jako je například vaše mikroslužba webového rozhraní API, nezávisí přímo na vrstvě infrastruktury, ve které jste implementovali. skutečné třídy úložiště</span><span class="sxs-lookup"><span data-stu-id="d64c2-149">As noted in an earlier section, it's recommended that you define and place the repository interfaces in the domain model layer so the application layer, such as your Web API microservice, doesn't depend directly on the infrastructure layer where you've implemented the actual repository classes.</span></span> <span data-ttu-id="d64c2-150">Tímto způsobem a použitím injektáže závislosti v řadičích webového rozhraní API můžete implementovat napodobná úložiště, která vracejí falešná data namísto dat z databáze.</span><span class="sxs-lookup"><span data-stu-id="d64c2-150">By doing this and using Dependency Injection in the controllers of your Web API, you can implement mock repositories that return fake data instead of data from the database.</span></span> <span data-ttu-id="d64c2-151">Tento oddělený přístup umožňuje vytvořit a spustit testy jednotek, které se zaměřují na logiku vaší aplikace bez nutnosti připojení k databázi.</span><span class="sxs-lookup"><span data-stu-id="d64c2-151">This decoupled approach allows you to create and run unit tests that focus the logic of your application without requiring connectivity to the database.</span></span>

<span data-ttu-id="d64c2-152">Připojení k databázím může selhat a důležitější je, že spouštění stovek testů proti databázi je ze dvou důvodů špatné.</span><span class="sxs-lookup"><span data-stu-id="d64c2-152">Connections to databases can fail and, more importantly, running hundreds of tests against a database is bad for two reasons.</span></span> <span data-ttu-id="d64c2-153">Za prvé může trvat dlouhou dobu z důvodu velkého počtu testů.</span><span class="sxs-lookup"><span data-stu-id="d64c2-153">First, it can take a long time because of the large number of tests.</span></span> <span data-ttu-id="d64c2-154">Za druhé se můžou záznamy databáze změnit a ovlivnit výsledky testů, aby mohly být nekonzistentní.</span><span class="sxs-lookup"><span data-stu-id="d64c2-154">Second, the database records might change and impact the results of your tests, so that they might not be consistent.</span></span> <span data-ttu-id="d64c2-155">Testování proti databázi není jednotkovým testem, ale s testem integrace.</span><span class="sxs-lookup"><span data-stu-id="d64c2-155">Testing against the database isn't a unit test but an integration test.</span></span> <span data-ttu-id="d64c2-156">Měli byste mít spoustu testů jednotek spuštěných rychleji, ale méně integračních testů pro databáze.</span><span class="sxs-lookup"><span data-stu-id="d64c2-156">You should have many unit tests running fast, but fewer integration tests against the databases.</span></span>

<span data-ttu-id="d64c2-157">V souvislosti s oddělením potíží s testováním jednotek vaše logika funguje na doménových entitách v paměti.</span><span class="sxs-lookup"><span data-stu-id="d64c2-157">In terms of separation of concerns for unit tests, your logic operates on domain entities in memory.</span></span> <span data-ttu-id="d64c2-158">Předpokládá, že třída úložiště je dodala.</span><span class="sxs-lookup"><span data-stu-id="d64c2-158">It assumes the repository class has delivered those.</span></span> <span data-ttu-id="d64c2-159">Jakmile vaše logika upraví entity domény, předpokládá se, že třída úložiště bude ukládat správně.</span><span class="sxs-lookup"><span data-stu-id="d64c2-159">Once your logic modifies the domain entities, it assumes the repository class will store them correctly.</span></span> <span data-ttu-id="d64c2-160">Důležitým bodem je postup, jak vytvořit testování částí pro doménový model a jeho doménovou logiku.</span><span class="sxs-lookup"><span data-stu-id="d64c2-160">The important point here is to create unit tests against your domain model and its domain logic.</span></span> <span data-ttu-id="d64c2-161">Agregované kořeny jsou hlavní hranice konzistence v DDD.</span><span class="sxs-lookup"><span data-stu-id="d64c2-161">Aggregate roots are the main consistency boundaries in DDD.</span></span>

<span data-ttu-id="d64c2-162">Úložiště implementovaná v eShopOnContainers spoléhají EF Core na DbContext implementaci úložiště a pracovní jednotky pracovních schémat pomocí sledování změn, takže tyto funkce neduplikují.</span><span class="sxs-lookup"><span data-stu-id="d64c2-162">The repositories implemented in eShopOnContainers rely on EF Core’s DbContext implementation of the Repository and Unit of Work patterns using its change tracker, so they don’t duplicate this functionality.</span></span>

### <a name="the-difference-between-the-repository-pattern-and-the-legacy-data-access-class-dal-class-pattern"></a><span data-ttu-id="d64c2-163">Rozdíl mezi vzorem úložiště a vzorem třídy pro přístup k datům starší verze (třída DAL)</span><span class="sxs-lookup"><span data-stu-id="d64c2-163">The difference between the Repository pattern and the legacy Data Access class (DAL class) pattern</span></span>

<span data-ttu-id="d64c2-164">Objekt pro přístup k datům přímo provádí operace přístupu k datům a trvalých operací proti úložišti.</span><span class="sxs-lookup"><span data-stu-id="d64c2-164">A data access object directly performs data access and persistence operations against storage.</span></span> <span data-ttu-id="d64c2-165">Úložiště označí data operacemi, které chcete provést, v paměti objektu pracovní jednotky (jako v EF při použití třídy <xref:Microsoft.EntityFrameworkCore.DbContext>), ale tyto aktualizace nejsou okamžitě provedeny do databáze.</span><span class="sxs-lookup"><span data-stu-id="d64c2-165">A repository marks the data with the operations you want to perform in the memory of a unit of work object (as in EF when using the <xref:Microsoft.EntityFrameworkCore.DbContext> class), but these updates aren't performed immediately to the database.</span></span>

<span data-ttu-id="d64c2-166">Pracovní jednotka je označována jako jediná transakce, která zahrnuje několik operací vložení, aktualizace nebo odstranění.</span><span class="sxs-lookup"><span data-stu-id="d64c2-166">A unit of work is referred to as a single transaction that involves multiple insert, update, or delete operations.</span></span> <span data-ttu-id="d64c2-167">V jednoduchých případech to znamená, že pro konkrétní akci uživatele, jako je například registrace na webu, jsou všechny operace vložení, aktualizace a odstranění zpracovávány v rámci jedné transakce.</span><span class="sxs-lookup"><span data-stu-id="d64c2-167">In simple terms, it means that for a specific user action, such as a registration on a website, all the insert, update, and delete operations are handled in a single transaction.</span></span> <span data-ttu-id="d64c2-168">To je efektivnější než zpracování více transakcí databáze chattier způsobem.</span><span class="sxs-lookup"><span data-stu-id="d64c2-168">This is more efficient than handling multiple database transactions in a chattier way.</span></span>

<span data-ttu-id="d64c2-169">Tyto vícenásobné operace trvalosti jsou prováděny později v rámci jedné akce, když kód z aplikační vrstvy je příkaz.</span><span class="sxs-lookup"><span data-stu-id="d64c2-169">These multiple persistence operations are performed later in a single action when your code from the application layer commands it.</span></span> <span data-ttu-id="d64c2-170">Rozhodnutí o použití změn v paměti pro skutečné úložiště databáze je obvykle založené na [modelu pracovní jednotky](https://martinfowler.com/eaaCatalog/unitOfWork.html).</span><span class="sxs-lookup"><span data-stu-id="d64c2-170">The decision about applying the in-memory changes to the actual database storage is typically based on the [Unit of Work pattern](https://martinfowler.com/eaaCatalog/unitOfWork.html).</span></span> <span data-ttu-id="d64c2-171">V EF je pracovní jednotka modelu implementována jako <xref:Microsoft.EntityFrameworkCore.DbContext>.</span><span class="sxs-lookup"><span data-stu-id="d64c2-171">In EF, the Unit of Work pattern is implemented as the <xref:Microsoft.EntityFrameworkCore.DbContext>.</span></span>

<span data-ttu-id="d64c2-172">V mnoha případech může tento model nebo způsob použití operací s úložištěm zvýšit výkon aplikace a snížit možnost nekonzistencí.</span><span class="sxs-lookup"><span data-stu-id="d64c2-172">In many cases, this pattern or way of applying operations against the storage can increase application performance and reduce the possibility of inconsistencies.</span></span> <span data-ttu-id="d64c2-173">Také snižuje blokování transakcí v databázových tabulkách, protože všechny zamýšlené operace jsou potvrzeny jako součást jedné transakce.</span><span class="sxs-lookup"><span data-stu-id="d64c2-173">It also reduces transaction blocking in the database tables, because all the intended operations are committed as part of one transaction.</span></span> <span data-ttu-id="d64c2-174">To je efektivnější pro porovnání se spouštěním velkého množství izolovaných operací s databází.</span><span class="sxs-lookup"><span data-stu-id="d64c2-174">This is more efficient in comparison to executing many isolated operations against the database.</span></span> <span data-ttu-id="d64c2-175">Proto vybraný ORM může optimalizovat spouštění proti databázi seskupením několika akcí aktualizace v rámci stejné transakce, na rozdíl od mnoha malých a oddělených spuštění transakcí.</span><span class="sxs-lookup"><span data-stu-id="d64c2-175">Therefore, the selected ORM can optimize the execution against the database by grouping several update actions within the same transaction, as opposed to many small and separate transaction executions.</span></span>

### <a name="repositories-shouldnt-be-mandatory"></a><span data-ttu-id="d64c2-176">Úložiště by neměla být povinná</span><span class="sxs-lookup"><span data-stu-id="d64c2-176">Repositories shouldn't be mandatory</span></span>

<span data-ttu-id="d64c2-177">Vlastní úložiště jsou užitečná z výše uvedených důvodů a to je přístup k řazení mikroslužby v eShopOnContainers.</span><span class="sxs-lookup"><span data-stu-id="d64c2-177">Custom repositories are useful for the reasons cited earlier, and that is the approach for the ordering microservice in eShopOnContainers.</span></span> <span data-ttu-id="d64c2-178">Nejedná se ale o zásadní vzor, který by bylo možné implementovat v rámci návrhu DDD nebo dokonce i při obecném vývoji pro .NET.</span><span class="sxs-lookup"><span data-stu-id="d64c2-178">However, it isn't an essential pattern to implement in a DDD design or even in general .NET development.</span></span>

<span data-ttu-id="d64c2-179">Například Jimmy Bogard při poskytování přímé zpětné vazby k této příručce říkáme následující:</span><span class="sxs-lookup"><span data-stu-id="d64c2-179">For instance, Jimmy Bogard, when providing direct feedback for this guide, said the following:</span></span>

> <span data-ttu-id="d64c2-180">To pravděpodobně bude největší zpětnou vazbu.</span><span class="sxs-lookup"><span data-stu-id="d64c2-180">This’ll probably be my biggest feedback.</span></span> <span data-ttu-id="d64c2-181">Nerozumím ventilátoru úložišť, hlavně protože skrývají důležité podrobnosti základního mechanismu trvalosti.</span><span class="sxs-lookup"><span data-stu-id="d64c2-181">I’m really not a fan of repositories, mainly because they hide the important details of the underlying persistence mechanism.</span></span> <span data-ttu-id="d64c2-182">Z tohoto důvodu je to pro příkazy MediatR.</span><span class="sxs-lookup"><span data-stu-id="d64c2-182">It’s why I go for MediatR for commands, too.</span></span> <span data-ttu-id="d64c2-183">Můžu použít plný výkon vrstvy trvalosti a všechny tyto vlastnosti domény nahrajte do agregovaných kořenů.</span><span class="sxs-lookup"><span data-stu-id="d64c2-183">I can use the full power of the persistence layer, and push all that domain behavior into my aggregate roots.</span></span> <span data-ttu-id="d64c2-184">Nechci obvykle nastavovat moje úložiště – I přesto je potřeba mít tento test integrace s skutečnou věc.</span><span class="sxs-lookup"><span data-stu-id="d64c2-184">I don’t usually want to mock my repositories – I still need to have that integration test with the real thing.</span></span> <span data-ttu-id="d64c2-185">CQRS znamenalo, že ještě nepotřebujeme nějaká úložiště.</span><span class="sxs-lookup"><span data-stu-id="d64c2-185">Going CQRS meant that we didn’t really have a need for repositories any more.</span></span>

<span data-ttu-id="d64c2-186">Úložiště můžou být užitečná, ale pro návrh DDD nejsou kritická, a to tak, jak jsou agregovaným vzorem a bohatým doménovým modelem.</span><span class="sxs-lookup"><span data-stu-id="d64c2-186">Repositories might be useful, but they are not critical for your DDD design, in the way that the Aggregate pattern and rich domain model are.</span></span> <span data-ttu-id="d64c2-187">Proto použijte vzor úložiště, a to podle potřeby.</span><span class="sxs-lookup"><span data-stu-id="d64c2-187">Therefore, use the Repository pattern or not, as you see fit.</span></span> <span data-ttu-id="d64c2-188">V takovém případě budete používat model úložiště vždy, když použijete EF Core i když v tomto případě úložiště pokrývá celý mikroslužbu nebo ohraničený kontext.</span><span class="sxs-lookup"><span data-stu-id="d64c2-188">Anyway, you’ll be using the repository pattern whenever you use EF Core although, in this case, the repository covers the whole microservice or bounded context.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="d64c2-189">Další zdroje</span><span class="sxs-lookup"><span data-stu-id="d64c2-189">Additional resources</span></span>

### <a name="repository-pattern"></a><span data-ttu-id="d64c2-190">Vzor úložiště</span><span class="sxs-lookup"><span data-stu-id="d64c2-190">Repository pattern</span></span>

- <span data-ttu-id="d64c2-191"> \ **vzoru úložiště**</span><span class="sxs-lookup"><span data-stu-id="d64c2-191">**The Repository pattern** \</span></span>
  <https://deviq.com/repository-pattern/>

- <span data-ttu-id="d64c2-192">**Edward Hieatt a Rob mě. Vzor úložiště**</span><span class="sxs-lookup"><span data-stu-id="d64c2-192">**Edward Hieatt and Rob Mee. Repository pattern.**</span></span> \
  <https://martinfowler.com/eaaCatalog/repository.html>

- <span data-ttu-id="d64c2-193"> \ **vzoru úložiště**</span><span class="sxs-lookup"><span data-stu-id="d64c2-193">**The Repository pattern** \</span></span>
  <https://docs.microsoft.com/previous-versions/msp-n-p/ff649690(v=pandp.10)>

- <span data-ttu-id="d64c2-194">**Eric Evans. Návrh založený na doméně: řešení složitosti na srdce softwaru.**</span><span class="sxs-lookup"><span data-stu-id="d64c2-194">**Eric Evans. Domain-Driven Design: Tackling Complexity in the Heart of Software.**</span></span> <span data-ttu-id="d64c2-195">(Kniha; zahrnuje diskusi ke vzoru úložiště) </span><span class="sxs-lookup"><span data-stu-id="d64c2-195">(Book; includes a discussion of the Repository pattern) </span></span>\
  <https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/>

### <a name="unit-of-work-pattern"></a><span data-ttu-id="d64c2-196">Vzor pracovní jednotky</span><span class="sxs-lookup"><span data-stu-id="d64c2-196">Unit of Work pattern</span></span>

- <span data-ttu-id="d64c2-197">**Martin Fowlera. Model pracovní jednotky.**</span><span class="sxs-lookup"><span data-stu-id="d64c2-197">**Martin Fowler. Unit of Work pattern.**</span></span> \
  <https://martinfowler.com/eaaCatalog/unitOfWork.html>

- <span data-ttu-id="d64c2-198">**Implementace vzorového úložiště a pracovní jednotky v aplikaci ASP.NET MVC** </span><span class="sxs-lookup"><span data-stu-id="d64c2-198">**Implementing the Repository and Unit of Work Patterns in an ASP.NET MVC Application** </span></span>\
  <https://docs.microsoft.com/aspnet/mvc/overview/older-versions/getting-started-with-ef-5-using-mvc-4/implementing-the-repository-and-unit-of-work-patterns-in-an-asp-net-mvc-application>

>[!div class="step-by-step"]
><span data-ttu-id="d64c2-199">[Předchozí](domain-events-design-implementation.md)
>[Další](infrastructure-persistence-layer-implemenation-entity-framework-core.md)</span><span class="sxs-lookup"><span data-stu-id="d64c2-199">[Previous](domain-events-design-implementation.md)
[Next](infrastructure-persistence-layer-implemenation-entity-framework-core.md)</span></span>
