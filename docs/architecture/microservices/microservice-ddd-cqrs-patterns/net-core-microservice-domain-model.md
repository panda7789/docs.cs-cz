---
title: Implementace doménového modelu mikroslužby pomocí .NET Core
description: Architektura mikroslužeb .NET pro kontejnerizované aplikace .NET | Získejte podrobnosti implementace modelu domény orientovaného na DDD.
ms.date: 10/08/2018
ms.openlocfilehash: 24f700b371d998cf99cbcf260a5278d797cb39d4
ms.sourcegitcommit: e3cbf26d67f7e9286c7108a2752804050762d02d
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 04/09/2020
ms.locfileid: "80988424"
---
# <a name="implement-a-microservice-domain-model-with-net-core"></a><span data-ttu-id="17aa5-103">Implementace modelu domény mikroslužeb pomocí jádra .NET Core</span><span class="sxs-lookup"><span data-stu-id="17aa5-103">Implement a microservice domain model with .NET Core</span></span>

<span data-ttu-id="17aa5-104">V předchozí části byly vysvětleny základní principy návrhu a vzory pro návrh modelu domény.</span><span class="sxs-lookup"><span data-stu-id="17aa5-104">In the previous section, the fundamental design principles and patterns for designing a domain model were explained.</span></span> <span data-ttu-id="17aa5-105">Nyní je čas prozkoumat možné způsoby implementace modelu domény pomocí\# .NET Core (prostý kód C) a EF Core.</span><span class="sxs-lookup"><span data-stu-id="17aa5-105">Now it is time to explore possible ways to implement the domain model by using .NET Core (plain C\# code) and EF Core.</span></span> <span data-ttu-id="17aa5-106">Všimněte si, že váš model domény se bude skládat pouze z vašeho kódu.</span><span class="sxs-lookup"><span data-stu-id="17aa5-106">Note that your domain model will be composed simply of your code.</span></span> <span data-ttu-id="17aa5-107">Bude mít pouze požadavky modelu EF Core, ale ne skutečné závislosti na EF.</span><span class="sxs-lookup"><span data-stu-id="17aa5-107">It will have just the EF Core model requirements, but not real dependencies on EF.</span></span> <span data-ttu-id="17aa5-108">Neměli byste mít pevné závislosti nebo odkazy na EF Core nebo jiné ORM v modelu domény.</span><span class="sxs-lookup"><span data-stu-id="17aa5-108">You should not have hard dependencies or references to EF Core or any other ORM in your domain model.</span></span>

## <a name="domain-model-structure-in-a-custom-net-standard-library"></a><span data-ttu-id="17aa5-109">Struktura modelu domény ve vlastní standardní knihovně .NET</span><span class="sxs-lookup"><span data-stu-id="17aa5-109">Domain model structure in a custom .NET Standard Library</span></span>

<span data-ttu-id="17aa5-110">Organizace složek použitá pro referenční aplikaci eShopOnContainers demonstruje model DDD pro aplikaci.</span><span class="sxs-lookup"><span data-stu-id="17aa5-110">The folder organization used for the eShopOnContainers reference application demonstrates the DDD model for the application.</span></span> <span data-ttu-id="17aa5-111">Možná zjistíte, že jiná organizace složek jasněji sděluje volby návrhu provedené pro vaši aplikaci.</span><span class="sxs-lookup"><span data-stu-id="17aa5-111">You might find that a different folder organization more clearly communicates the design choices made for your application.</span></span> <span data-ttu-id="17aa5-112">Jak můžete vidět na obrázku 7-10, v modelu objednávací domény existují dvě agregace, agregace objednávky a agregace kupujícího.</span><span class="sxs-lookup"><span data-stu-id="17aa5-112">As you can see in Figure 7-10, in the ordering domain model there are two aggregates, the order aggregate and the buyer aggregate.</span></span> <span data-ttu-id="17aa5-113">Každý agregace je skupina entit domény a hodnotové objekty, i když můžete mít agregát složený z jedné entity domény (agregační kořenová nebo kořenová entita) také.</span><span class="sxs-lookup"><span data-stu-id="17aa5-113">Each aggregate is a group of domain entities and value objects, although you could have an aggregate composed of a single domain entity (the aggregate root or root entity) as well.</span></span>

:::image type="complex" source="./media/net-core-microservice-domain-model/ordering-microservice-container.png" alt-text="Snímek obrazovky projektu Ordering.Domain v Průzkumníku řešení":::
<span data-ttu-id="17aa5-115">Zobrazení Průzkumník řešení pro projekt Ordering.Domain, zobrazující složku AggregatesModel obsahující složky BuyerAggregate a OrderAggregate, z nichž každá obsahuje třídy entit, soubory objektů hodnoty a tak dále.</span><span class="sxs-lookup"><span data-stu-id="17aa5-115">The Solution Explorer view for the Ordering.Domain project, showing the AggregatesModel folder containing the BuyerAggregate and OrderAggregate folders, each one containing it's entity classes, value object files and so on.</span></span>
:::image-end:::

<span data-ttu-id="17aa5-116">**Obrázek 7-10**.</span><span class="sxs-lookup"><span data-stu-id="17aa5-116">**Figure 7-10**.</span></span> <span data-ttu-id="17aa5-117">Struktura modelu domény pro objednávání mikroslužeb v eShopOnContainers</span><span class="sxs-lookup"><span data-stu-id="17aa5-117">Domain model structure for the ordering microservice in eShopOnContainers</span></span>

<span data-ttu-id="17aa5-118">Kromě toho vrstva modelu domény zahrnuje kontrakty úložiště (rozhraní), které jsou požadavky na infrastrukturu modelu domény.</span><span class="sxs-lookup"><span data-stu-id="17aa5-118">Additionally, the domain model layer includes the repository contracts (interfaces) that are the infrastructure requirements of your domain model.</span></span> <span data-ttu-id="17aa5-119">Jinými slovy tato rozhraní vyjadřují, jaké repozitáře a metody vrstvy infrastruktury musí implementovat.</span><span class="sxs-lookup"><span data-stu-id="17aa5-119">In other words, these interfaces express what repositories and the methods the infrastructure layer must implement.</span></span> <span data-ttu-id="17aa5-120">Je důležité, aby implementace úložišť byla umístěna mimo vrstvu modelu domény v knihovně vrstvy infrastruktury, takže vrstva modelu domény není "kontaminována" rozhraním API nebo třídami z infrastrukturních technologií, jako je entity Framework.</span><span class="sxs-lookup"><span data-stu-id="17aa5-120">It is critical that the implementation of the repositories be placed outside of the domain model layer, in the infrastructure layer library, so the domain model layer is not "contaminated" by API or classes from infrastructure technologies, like Entity Framework.</span></span>

<span data-ttu-id="17aa5-121">Můžete také zobrazit složku [SeedWork,](https://martinfowler.com/bliki/Seedwork.html) která obsahuje vlastní základní třídy, které můžete použít jako základ pro entity domény a objekty hodnot, takže nemáte redundantní kód v třídě objektů každé domény.</span><span class="sxs-lookup"><span data-stu-id="17aa5-121">You can also see a [SeedWork](https://martinfowler.com/bliki/Seedwork.html) folder that contains custom base classes that you can use as a base for your domain entities and value objects, so you do not have redundant code in each domain's object class.</span></span>

## <a name="structure-aggregates-in-a-custom-net-standard-library"></a><span data-ttu-id="17aa5-122">Struktura agregací ve vlastní knihovně .NET Standard</span><span class="sxs-lookup"><span data-stu-id="17aa5-122">Structure aggregates in a custom .NET Standard library</span></span>

<span data-ttu-id="17aa5-123">Agregace odkazuje na cluster objektů domény seskupených dohromady tak, aby odpovídaly transakční konzistenci.</span><span class="sxs-lookup"><span data-stu-id="17aa5-123">An aggregate refers to a cluster of domain objects grouped together to match transactional consistency.</span></span> <span data-ttu-id="17aa5-124">Tyto objekty mohou být instance entit (z nichž jeden je agregační kořenová nebo kořenová entita) plus všechny další hodnoty objektů.</span><span class="sxs-lookup"><span data-stu-id="17aa5-124">Those objects could be instances of entities (one of which is the aggregate root or root entity) plus any additional value objects.</span></span>

<span data-ttu-id="17aa5-125">Transakční konzistence znamená, že agregát je zaručeno, že bude konzistentní a aktuální na konci obchodní akce.</span><span class="sxs-lookup"><span data-stu-id="17aa5-125">Transactional consistency means that an aggregate is guaranteed to be consistent and up to date at the end of a business action.</span></span> <span data-ttu-id="17aa5-126">Například agregace objednávky z modelu domény eShopOnContainers objednávající mikroslužby se skládá, jak je znázorněno na obrázku 7-11.</span><span class="sxs-lookup"><span data-stu-id="17aa5-126">For example, the order aggregate from the eShopOnContainers ordering microservice domain model is composed as shown in Figure 7-11.</span></span>

:::image type="complex" source="./media/net-core-microservice-domain-model/vs-solution-explorer-order-aggregate.png" alt-text="Snímek obrazovky složky OrderAggregate a jejích tříd.":::
<span data-ttu-id="17aa5-128">Podrobné zobrazení složky OrderAggregate: Address.cs je objekt hodnoty, IOrderRepository je repo rozhraní, Order.cs je agregační kořen, OrderItem.cs je podřízená entita a OrderStatus.cs je třída výčtu.</span><span class="sxs-lookup"><span data-stu-id="17aa5-128">A detailed view of the OrderAggregate folder: Address.cs is a value object, IOrderRepository is a repo interface, Order.cs is an aggregate root, OrderItem.cs is a child entity, and OrderStatus.cs is an enumeration class.</span></span>
:::image-end:::

<span data-ttu-id="17aa5-129">**Obrázek 7-11**.</span><span class="sxs-lookup"><span data-stu-id="17aa5-129">**Figure 7-11**.</span></span> <span data-ttu-id="17aa5-130">Agregace objednávek v řešení Sady Visual Studio</span><span class="sxs-lookup"><span data-stu-id="17aa5-130">The order aggregate in Visual Studio solution</span></span>

<span data-ttu-id="17aa5-131">Pokud otevřete některý ze souborů v agregované složce, můžete vidět, jak je označen jako vlastní základní třídy nebo rozhraní, jako entita nebo objekt hodnoty, jak je implementováno ve složce [SeedWork.](https://github.com/dotnet-architecture/eShopOnContainers/tree/master/src/Services/Ordering/Ordering.Domain/SeedWork)</span><span class="sxs-lookup"><span data-stu-id="17aa5-131">If you open any of the files in an aggregate folder, you can see how it is marked as either a custom base class or interface, like entity or value object, as implemented in the [SeedWork](https://github.com/dotnet-architecture/eShopOnContainers/tree/master/src/Services/Ordering/Ordering.Domain/SeedWork) folder.</span></span>

## <a name="implement-domain-entities-as-poco-classes"></a><span data-ttu-id="17aa5-132">Implementovat entity domény jako třídy POCO</span><span class="sxs-lookup"><span data-stu-id="17aa5-132">Implement domain entities as POCO classes</span></span>

<span data-ttu-id="17aa5-133">Model domény implementujete v rozhraní .NET vytvořením tříd POCO, které implementují entity domény.</span><span class="sxs-lookup"><span data-stu-id="17aa5-133">You implement a domain model in .NET by creating POCO classes that implement your domain entities.</span></span> <span data-ttu-id="17aa5-134">V následujícím příkladu order třída je definována jako entita a také jako agregační kořen.</span><span class="sxs-lookup"><span data-stu-id="17aa5-134">In the following example, the Order class is defined as an entity and also as an aggregate root.</span></span> <span data-ttu-id="17aa5-135">Vzhledem k tomu, že order třída pochází ze základní třídy Entity, můžete znovu použít společný kód vztahující se k entitám.</span><span class="sxs-lookup"><span data-stu-id="17aa5-135">Because the Order class derives from the Entity base class, it can reuse common code related to entities.</span></span> <span data-ttu-id="17aa5-136">Mějte na paměti, že tyto základní třídy a rozhraní jsou definovány v projektu modelu domény, takže je váš kód, nikoli kód infrastruktury z ORM jako EF.</span><span class="sxs-lookup"><span data-stu-id="17aa5-136">Bear in mind that these base classes and interfaces are defined by you in the domain model project, so it is your code, not infrastructure code from an ORM like EF.</span></span>

```csharp
// COMPATIBLE WITH ENTITY FRAMEWORK CORE 2.0
// Entity is a custom base class with the ID
public class Order : Entity, IAggregateRoot
{
    private DateTime _orderDate;
    public Address Address { get; private set; }
    private int? _buyerId;

    public OrderStatus OrderStatus { get; private set; }
    private int _orderStatusId;

    private string _description;
    private int? _paymentMethodId;

    private readonly List<OrderItem> _orderItems;
    public IReadOnlyCollection<OrderItem> OrderItems => _orderItems;

    public Order(string userId, Address address, int cardTypeId, string cardNumber, string cardSecurityNumber,
            string cardHolderName, DateTime cardExpiration, int? buyerId = null, int? paymentMethodId = null)
    {
        _orderItems = new List<OrderItem>();
        _buyerId = buyerId;
        _paymentMethodId = paymentMethodId;
        _orderStatusId = OrderStatus.Submitted.Id;
        _orderDate = DateTime.UtcNow;
        Address = address;

        // ...Additional code ...
    }

    public void AddOrderItem(int productId, string productName,
                            decimal unitPrice, decimal discount,
                            string pictureUrl, int units = 1)
    {
        //...
        // Domain rules/logic for adding the OrderItem to the order
        // ...

        var orderItem = new OrderItem(productId, productName, unitPrice, discount, pictureUrl, units);

        _orderItems.Add(orderItem);

    }
    // ...
    // Additional methods with domain rules/logic related to the Order aggregate
    // ...
}
```

<span data-ttu-id="17aa5-137">Je důležité si uvědomit, že se jedná o entitu domény implementovanou jako třída POCO.</span><span class="sxs-lookup"><span data-stu-id="17aa5-137">It is important to note that this is a domain entity implemented as a POCO class.</span></span> <span data-ttu-id="17aa5-138">Nemá žádnou přímou závislost na jádru entity frameworku nebo jiném rozhraní infrastruktury.</span><span class="sxs-lookup"><span data-stu-id="17aa5-138">It does not have any direct dependency on Entity Framework Core or any other infrastructure framework.</span></span> <span data-ttu-id="17aa5-139">Tato implementace je, jak by měla být\# v DDD, jen C kód implementace modelu domény.</span><span class="sxs-lookup"><span data-stu-id="17aa5-139">This implementation is as it should be in DDD, just C\# code implementing a domain model.</span></span>

<span data-ttu-id="17aa5-140">Kromě toho je třída zdobena rozhraním s názvem IAggregateRoot.</span><span class="sxs-lookup"><span data-stu-id="17aa5-140">In addition, the class is decorated with an interface named IAggregateRoot.</span></span> <span data-ttu-id="17aa5-141">Toto rozhraní je prázdné rozhraní, někdy nazývané *rozhraní značky*, které se používá pouze k označení, že tato třída entity je také agregační kořen.</span><span class="sxs-lookup"><span data-stu-id="17aa5-141">That interface is an empty interface, sometimes called a *marker interface*, that is used just to indicate that this entity class is also an aggregate root.</span></span>

<span data-ttu-id="17aa5-142">Rozhraní značky je někdy považováno za anti-pattern; je však také čistý způsob, jak označit třídu, zejména v případě, že rozhraní může být vyvíjející se.</span><span class="sxs-lookup"><span data-stu-id="17aa5-142">A marker interface is sometimes considered as an anti-pattern; however, it is also a clean way to mark a class, especially when that interface might be evolving.</span></span> <span data-ttu-id="17aa5-143">Atribut může být další volbou pro značku, ale je rychlejší zobrazit základní třídu (entitu) vedle rozhraní IAggregate namísto umístění značky atributu Aggregate nad třídu.</span><span class="sxs-lookup"><span data-stu-id="17aa5-143">An attribute could be the other choice for the marker, but it is quicker to see the base class (Entity) next to the IAggregate interface instead of putting an Aggregate attribute marker above the class.</span></span> <span data-ttu-id="17aa5-144">Je to otázka preferencí, v každém případě.</span><span class="sxs-lookup"><span data-stu-id="17aa5-144">It is a matter of preferences, in any case.</span></span>

<span data-ttu-id="17aa5-145">S agregační kořen znamená, že většina kódu týkající se konzistence a obchodní pravidla entity agregace by měly být implementovány jako metody v pořadí agregační kořenové třídy (například AddOrderItem při přidávání OrderItem objektu agregovat).</span><span class="sxs-lookup"><span data-stu-id="17aa5-145">Having an aggregate root means that most of the code related to consistency and business rules of the aggregate's entities should be implemented as methods in the Order aggregate root class (for example, AddOrderItem when adding an OrderItem object to the aggregate).</span></span> <span data-ttu-id="17aa5-146">Neměli byste vytvářet nebo aktualizovat Objekty OrderItems nezávisle nebo přímo; Třída AggregateRoot musí zachovat kontrolu a konzistenci všech operací aktualizace vůči svým podřízeným entitam.</span><span class="sxs-lookup"><span data-stu-id="17aa5-146">You should not create or update OrderItems objects independently or directly; the AggregateRoot class must keep control and consistency of any update operation against its child entities.</span></span>

## <a name="encapsulate-data-in-the-domain-entities"></a><span data-ttu-id="17aa5-147">Zapouzdření dat v entitách domény</span><span class="sxs-lookup"><span data-stu-id="17aa5-147">Encapsulate data in the Domain Entities</span></span>

<span data-ttu-id="17aa5-148">Běžným problémem v modelech entit je, že zveřejňují navigační vlastnosti kolekce jako veřejně přístupné typy seznamů.</span><span class="sxs-lookup"><span data-stu-id="17aa5-148">A common problem in entity models is that they expose collection navigation properties as publicly accessible list types.</span></span> <span data-ttu-id="17aa5-149">To umožňuje všechny vývojáře spolupracovník manipulovat s obsahem těchto typů kolekce, které mohou obejít důležitá obchodní pravidla týkající se kolekce, případně ponechat objekt v neplatném stavu.</span><span class="sxs-lookup"><span data-stu-id="17aa5-149">This allows any collaborator developer to manipulate the contents of these collection types, which may bypass important business rules related to the collection, possibly leaving the object in an invalid state.</span></span> <span data-ttu-id="17aa5-150">Řešením je vystavit přístup jen pro čtení k související kolekce a explicitně poskytnout metody, které definují způsoby, ve kterém klienti mohou manipulovat s nimi.</span><span class="sxs-lookup"><span data-stu-id="17aa5-150">The solution to this is to expose read-only access to related collections and explicitly provide methods that define ways in which clients can manipulate them.</span></span>

<span data-ttu-id="17aa5-151">V předchozím kódu si všimněte, že mnoho atributů je jen pro čtení nebo soukromé a jsou aktualizovatelné pouze metodami třídy, takže každá aktualizace bere v úvahu invarianty a logiku obchodní domény zadanou v rámci metod třídy.</span><span class="sxs-lookup"><span data-stu-id="17aa5-151">In the previous code, note that many attributes are read-only or private and are only updatable by the class methods, so any update considers business domain invariants and logic specified within the class methods.</span></span>

<span data-ttu-id="17aa5-152">Například následující vzory DDD **byste *neměli* dělat následující kroky** z žádné metody obslužné rutiny příkazu nebo třídy aplikační vrstvy (ve skutečnosti by to mělo být nemožné):</span><span class="sxs-lookup"><span data-stu-id="17aa5-152">For example, following DDD patterns, **you should *not* do the following** from any command handler method or application layer class (actually, it should be impossible for you to do so):</span></span>

```csharp
// WRONG ACCORDING TO DDD PATTERNS – CODE AT THE APPLICATION LAYER OR
// COMMAND HANDLERS
// Code in command handler methods or Web API controllers
//... (WRONG) Some code with business logic out of the domain classes ...
OrderItem myNewOrderItem = new OrderItem(orderId, productId, productName,
    pictureUrl, unitPrice, discount, units);

//... (WRONG) Accessing the OrderItems collection directly from the application layer // or command handlers
myOrder.OrderItems.Add(myNewOrderItem);
//...
```

<span data-ttu-id="17aa5-153">V tomto případě Add Metoda je čistě operace pro přidání dat, s přímým přístupem k OrderItems kolekce.</span><span class="sxs-lookup"><span data-stu-id="17aa5-153">In this case, the Add method is purely an operation to add data, with direct access to the OrderItems collection.</span></span> <span data-ttu-id="17aa5-154">Proto většina logiky domény, pravidla nebo ověření související s této operace s podřízenými entitami budou rozloženy do aplikační vrstvy (obslužné rutiny příkazů a řadiče webového rozhraní API).</span><span class="sxs-lookup"><span data-stu-id="17aa5-154">Therefore, most of the domain logic, rules, or validations related to that operation with the child entities will be spread across the application layer (command handlers and Web API controllers).</span></span>

<span data-ttu-id="17aa5-155">Pokud půjdete kolem agregační kořen, agregační kořen nemůže zaručit jeho invariants, jeho platnost nebo jeho konzistence.</span><span class="sxs-lookup"><span data-stu-id="17aa5-155">If you go around the aggregate root, the aggregate root cannot guarantee its invariants, its validity, or its consistency.</span></span> <span data-ttu-id="17aa5-156">Nakonec budete mít špagety kód nebo transakční skript kód.</span><span class="sxs-lookup"><span data-stu-id="17aa5-156">Eventually you will have spaghetti code or transactional script code.</span></span>

<span data-ttu-id="17aa5-157">Chcete-li sledovat vzory DDD, entity nesmí mít veřejné nastavení v žádné vlastnosti entity.</span><span class="sxs-lookup"><span data-stu-id="17aa5-157">To follow DDD patterns, entities must not have public setters in any entity property.</span></span> <span data-ttu-id="17aa5-158">Změny v entitě by měly být řízeny explicitními metodami s explicitním všudypřítomným jazykem o změně, kterou v entitě provádějí.</span><span class="sxs-lookup"><span data-stu-id="17aa5-158">Changes in an entity should be driven by explicit methods with explicit ubiquitous language about the change they are performing in the entity.</span></span>

<span data-ttu-id="17aa5-159">Kromě toho kolekce v rámci entity (jako položky objednávky) by měly být vlastnosti jen pro čtení (AsReadOnly metoda vysvětlena později).</span><span class="sxs-lookup"><span data-stu-id="17aa5-159">Furthermore, collections within the entity (like the order items) should be read-only properties (the AsReadOnly method explained later).</span></span> <span data-ttu-id="17aa5-160">Měli byste být schopni aktualizovat pouze z v rámci metody agregované kořenové třídy nebo metody podřízené entity.</span><span class="sxs-lookup"><span data-stu-id="17aa5-160">You should be able to update it only from within the aggregate root class methods or the child entity methods.</span></span>

<span data-ttu-id="17aa5-161">Jak můžete vidět v kódu pro kořenový kořen objednávky, všechny nastavení by měly být soukromé nebo alespoň pro čtení externě, takže všechny operace proti datům entity nebo její podřízené entity musí být provedeny prostřednictvím metod ve třídě entity.</span><span class="sxs-lookup"><span data-stu-id="17aa5-161">As you can see in the code for the Order aggregate root, all setters should be private or at least read-only externally, so that any operation against the entity's data or its child entities has to be performed through methods in the entity class.</span></span> <span data-ttu-id="17aa5-162">To udržuje konzistenci řízeným a objektově orientovaným způsobem namísto implementace transakčního kódu skriptu.</span><span class="sxs-lookup"><span data-stu-id="17aa5-162">This maintains consistency in a controlled and object-oriented way instead of implementing transactional script code.</span></span>

<span data-ttu-id="17aa5-163">Následující fragment kódu ukazuje správný způsob, jak kód ovat úkol přidání OrderItem objektu pořadí agregace.</span><span class="sxs-lookup"><span data-stu-id="17aa5-163">The following code snippet shows the proper way to code the task of adding an OrderItem object to the Order aggregate.</span></span>

```csharp
// RIGHT ACCORDING TO DDD--CODE AT THE APPLICATION LAYER OR COMMAND HANDLERS
// The code in command handlers or WebAPI controllers, related only to application stuff
// There is NO code here related to OrderItem object's business logic
myOrder.AddOrderItem(productId, productName, pictureUrl, unitPrice, discount, units);

// The code related to OrderItem params validations or domain rules should
// be WITHIN the AddOrderItem method.

//...
```

<span data-ttu-id="17aa5-164">V tomto fragmentu bude většina ověření nebo logiky související s vytvořením objektu OrderItem pod kontrolou agregačního kořenu Order – v metodě AddOrderItem – zejména ověření a logiky související s jinými prvky v agregaci.</span><span class="sxs-lookup"><span data-stu-id="17aa5-164">In this snippet, most of the validations or logic related to the creation of an OrderItem object will be under the control of the Order aggregate root—in the AddOrderItem method—especially validations and logic related to other elements in the aggregate.</span></span> <span data-ttu-id="17aa5-165">Například můžete získat stejnou položku produktu v důsledku více volání AddOrderItem.</span><span class="sxs-lookup"><span data-stu-id="17aa5-165">For instance, you might get the same product item as the result of multiple calls to AddOrderItem.</span></span> <span data-ttu-id="17aa5-166">V této metodě můžete prozkoumat položky produktu a konsolidovat stejné položky produktu do jednoho objektu OrderItem s několika jednotkami.</span><span class="sxs-lookup"><span data-stu-id="17aa5-166">In that method, you could examine the product items and consolidate the same product items into a single OrderItem object with several units.</span></span> <span data-ttu-id="17aa5-167">Navíc, pokud existují různé částky slevy, ale ID produktu je stejný, pravděpodobně použít vyšší slevu.</span><span class="sxs-lookup"><span data-stu-id="17aa5-167">Additionally, if there are different discount amounts but the product ID is the same, you would likely apply the higher discount.</span></span> <span data-ttu-id="17aa5-168">Tento princip platí pro všechny ostatní logiky domény pro OrderItem objektu.</span><span class="sxs-lookup"><span data-stu-id="17aa5-168">This principle applies to any other domain logic for the OrderItem object.</span></span>

<span data-ttu-id="17aa5-169">Kromě toho nové OrderItem (params) operace bude také řízena a provedena AddOrderItem metoda z Order agregační kořen.</span><span class="sxs-lookup"><span data-stu-id="17aa5-169">In addition, the new OrderItem(params) operation will also be controlled and performed by the AddOrderItem method from the Order aggregate root.</span></span> <span data-ttu-id="17aa5-170">Proto většina logiky nebo ověření související s této operace (zejména cokoli, co má vliv na konzistenci mezi jinými podřízenými entitami) bude na jednom místě v rámci agregační kořen.</span><span class="sxs-lookup"><span data-stu-id="17aa5-170">Therefore, most of the logic or validations related to that operation (especially anything that impacts the consistency between other child entities) will be in a single place within the aggregate root.</span></span> <span data-ttu-id="17aa5-171">To je konečný účel souhrnného kořenového vzoru.</span><span class="sxs-lookup"><span data-stu-id="17aa5-171">That is the ultimate purpose of the aggregate root pattern.</span></span>

<span data-ttu-id="17aa5-172">Při použití entity Framework Core 1.1 nebo novější, entita DDD může být lépe vyjádřena, protože umožňuje [mapování na pole](https://docs.microsoft.com/ef/core/modeling/backing-field) kromě vlastností.</span><span class="sxs-lookup"><span data-stu-id="17aa5-172">When you use Entity Framework Core 1.1 or later, a DDD entity can be better expressed because it allows [mapping to fields](https://docs.microsoft.com/ef/core/modeling/backing-field) in addition to properties.</span></span> <span data-ttu-id="17aa5-173">To je užitečné při ochraně kolekce podřízených entit nebo hodnotových objektů.</span><span class="sxs-lookup"><span data-stu-id="17aa5-173">This is useful when protecting collections of child entities or value objects.</span></span> <span data-ttu-id="17aa5-174">S tímto vylepšením můžete použít jednoduchá soukromá pole namísto vlastností a můžete implementovat libovolnou aktualizaci kolekce polí ve veřejných metodách a poskytnout přístup jen pro čtení prostřednictvím metody AsReadOnly.</span><span class="sxs-lookup"><span data-stu-id="17aa5-174">With this enhancement, you can use simple private fields instead of properties and you can implement any update to the field collection in public methods and provide read-only access through the AsReadOnly method.</span></span>

<span data-ttu-id="17aa5-175">V DDD chcete aktualizovat entitu pouze prostřednictvím metod v entitě (nebo konstruktoru) za účelem řízení jakékoli invarianty a konzistence dat, takže vlastnosti jsou definovány pouze pomocí přistupujícího objektu get.</span><span class="sxs-lookup"><span data-stu-id="17aa5-175">In DDD you want to update the entity only through methods in the entity (or the constructor) in order to control any invariant and the consistency of the data, so properties are defined only with a get accessor.</span></span> <span data-ttu-id="17aa5-176">Vlastnosti jsou zálohovány soukromými poli.</span><span class="sxs-lookup"><span data-stu-id="17aa5-176">The properties are backed by private fields.</span></span> <span data-ttu-id="17aa5-177">Soukromé členy lze přistupovat pouze z v rámci třídy.</span><span class="sxs-lookup"><span data-stu-id="17aa5-177">Private members can only be accessed from within the class.</span></span> <span data-ttu-id="17aa5-178">Existuje však jedna výjimka: EF Core musí také nastavit tato pole (tak, aby může vrátit objekt se správnými hodnotami).</span><span class="sxs-lookup"><span data-stu-id="17aa5-178">However, there one exception: EF Core needs to set these fields as well (so it can return the object with the proper values).</span></span>

### <a name="map-properties-with-only-get-accessors-to-the-fields-in-the-database-table"></a><span data-ttu-id="17aa5-179">Mapování vlastností pouze s přístupovými objekty k polím v databázové tabulce</span><span class="sxs-lookup"><span data-stu-id="17aa5-179">Map properties with only get accessors to the fields in the database table</span></span>

<span data-ttu-id="17aa5-180">Mapování vlastností na sloupce databázové tabulky není odpovědností domény, ale součástí vrstvy infrastruktury a trvalosti.</span><span class="sxs-lookup"><span data-stu-id="17aa5-180">Mapping properties to database table columns is not a domain responsibility but part of the infrastructure and persistence layer.</span></span> <span data-ttu-id="17aa5-181">Zmíníme se zde jen proto, abyste si byli vědomi nových funkcí v EF Core 1.1 nebo novějších, které souvisejí s tím, jak můžete modelovat entity.</span><span class="sxs-lookup"><span data-stu-id="17aa5-181">We mention this here just so you are aware of the new capabilities in EF Core 1.1 or later related to how you can model entities.</span></span> <span data-ttu-id="17aa5-182">Další podrobnosti k tomuto tématu jsou vysvětleny v části infrastruktury a trvalosti.</span><span class="sxs-lookup"><span data-stu-id="17aa5-182">Additional details on this topic are explained in the infrastructure and persistence section.</span></span>

<span data-ttu-id="17aa5-183">Při použití EF Core 1.0 nebo novější, v rámci DbContext je třeba mapovat vlastnosti, které jsou definovány pouze s getters na skutečná pole v databázové tabulce.</span><span class="sxs-lookup"><span data-stu-id="17aa5-183">When you use EF Core 1.0 or later, within the DbContext you need to map the properties that are defined only with getters to the actual fields in the database table.</span></span> <span data-ttu-id="17aa5-184">To se provádí metodou HasField třídy PropertyBuilder.</span><span class="sxs-lookup"><span data-stu-id="17aa5-184">This is done with the HasField method of the PropertyBuilder class.</span></span>

### <a name="map-fields-without-properties"></a><span data-ttu-id="17aa5-185">Mapování polí bez vlastností</span><span class="sxs-lookup"><span data-stu-id="17aa5-185">Map fields without properties</span></span>

<span data-ttu-id="17aa5-186">Pomocí funkce v EF Core 1.1 nebo novější mapovat sloupce na pole, je také možné nepoužívat vlastnosti.</span><span class="sxs-lookup"><span data-stu-id="17aa5-186">With the feature in EF Core 1.1 or later to map columns to fields, it is also possible to not use properties.</span></span> <span data-ttu-id="17aa5-187">Místo toho můžete pouze mapovat sloupce z tabulky na pole.</span><span class="sxs-lookup"><span data-stu-id="17aa5-187">Instead, you can just map columns from a table to fields.</span></span> <span data-ttu-id="17aa5-188">Běžnýpřípad použití pro toto je privátní pole pro vnitřní stav, který není nutné přistupovat z mimo entitu.</span><span class="sxs-lookup"><span data-stu-id="17aa5-188">A common use case for this is private fields for an internal state that does not need to be accessed from outside the entity.</span></span>

<span data-ttu-id="17aa5-189">Například v předchozím příkladu orderaggregate kódu existuje několik soukromých polí, jako je `_paymentMethodId` pole, které nemají žádnou související vlastnost pro setter nebo getter.</span><span class="sxs-lookup"><span data-stu-id="17aa5-189">For example, in the preceding OrderAggregate code example, there are several private fields, like the  `_paymentMethodId` field, that have no related property for either a setter or getter.</span></span> <span data-ttu-id="17aa5-190">Toto pole lze také vypočítat v rámci obchodní logiky objednávky a použít z metod objednávky, ale musí být také trvalé v databázi.</span><span class="sxs-lookup"><span data-stu-id="17aa5-190">That field could also be calculated within the order's business logic and used from the order's methods, but it needs to be persisted in the database as well.</span></span> <span data-ttu-id="17aa5-191">Takže v EF Core (od verze 1.1) existuje způsob, jak mapovat pole bez související vlastnosti na sloupec v databázi.</span><span class="sxs-lookup"><span data-stu-id="17aa5-191">So in EF Core (since v1.1) there is a way to map a field without a related property to a column in the database.</span></span> <span data-ttu-id="17aa5-192">To je také vysvětleno v části [Vrstva infrastruktury](ddd-oriented-microservice.md#the-infrastructure-layer) v této příručce.</span><span class="sxs-lookup"><span data-stu-id="17aa5-192">This is also explained in the [Infrastructure layer](ddd-oriented-microservice.md#the-infrastructure-layer) section of this guide.</span></span>

### <a name="additional-resources"></a><span data-ttu-id="17aa5-193">Další zdroje</span><span class="sxs-lookup"><span data-stu-id="17aa5-193">Additional resources</span></span>

- <span data-ttu-id="17aa5-194">**Vaughn Vernon, to je můj zástupce. Modelování agregace s DDD a entity framework.**</span><span class="sxs-lookup"><span data-stu-id="17aa5-194">**Vaughn Vernon. Modeling Aggregates with DDD and Entity Framework.**</span></span> <span data-ttu-id="17aa5-195">Všimněte si, že *toto není* jádro entity frameworku.</span><span class="sxs-lookup"><span data-stu-id="17aa5-195">Note that this is *not* Entity Framework Core.</span></span> \
  <https://kalele.io/blog-posts/modeling-aggregates-with-ddd-and-entity-framework/>

- <span data-ttu-id="17aa5-196">**Julie Lermanová. Datové body - Kódování pro návrh řízený doménou: Tipy pro data-zaměřené devs** </span><span class="sxs-lookup"><span data-stu-id="17aa5-196">**Julie Lerman. Data Points - Coding for Domain-Driven Design: Tips for Data-Focused Devs** </span></span>\
  <https://docs.microsoft.com/archive/msdn-magazine/2013/august/data-points-coding-for-domain-driven-design-tips-for-data-focused-devs>

- <span data-ttu-id="17aa5-197">**Udi Dahan. Jak vytvořit plně zapouzdřené modely domény** </span><span class="sxs-lookup"><span data-stu-id="17aa5-197">**Udi Dahan. How to create fully encapsulated Domain Models** </span></span>\
  <http://udidahan.com/2008/02/29/how-to-create-fully-encapsulated-domain-models/>

> [!div class="step-by-step"]
> <span data-ttu-id="17aa5-198">[Předchozí](microservice-domain-model.md)
> [další](seedwork-domain-model-base-classes-interfaces.md)</span><span class="sxs-lookup"><span data-stu-id="17aa5-198">[Previous](microservice-domain-model.md)
[Next](seedwork-domain-model-base-classes-interfaces.md)</span></span>
