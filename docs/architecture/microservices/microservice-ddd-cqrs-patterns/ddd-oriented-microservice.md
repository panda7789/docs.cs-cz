---
title: Návrh mikroslužby orientované na DDD
description: Architektura mikroslužeb .NET pro kontejnerové aplikace .NET | Seznamte se s návrhem mikroslužeb a vrstev jejich aplikací orientovaných na DDD.
ms.date: 10/08/2018
ms.openlocfilehash: c5ac55978ca979a3ae055d9b0cd2d3c6b3187b4e
ms.sourcegitcommit: 22be09204266253d45ece46f51cc6f080f2b3fd6
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 11/07/2019
ms.locfileid: "73739933"
---
# <a name="design-a-ddd-oriented-microservice"></a><span data-ttu-id="caf85-103">Návrh mikroslužby orientované na DDD</span><span class="sxs-lookup"><span data-stu-id="caf85-103">Design a DDD-oriented microservice</span></span>

<span data-ttu-id="caf85-104">Návrh založený na doméně (DDD) pomáhá modelování na základě reality firmy, které jsou relevantní pro vaše případy použití.</span><span class="sxs-lookup"><span data-stu-id="caf85-104">Domain-driven design (DDD) advocates modeling based on the reality of business as relevant to your use cases.</span></span> <span data-ttu-id="caf85-105">V kontextu sestavování aplikací se DDD na problémy jako domény.</span><span class="sxs-lookup"><span data-stu-id="caf85-105">In the context of building applications, DDD talks about problems as domains.</span></span> <span data-ttu-id="caf85-106">Popisuje nezávisle problematické oblasti jako ohraničené kontexty (každý ohraničený kontext odpovídá mikroslužbám) a zvýrazňuje společný jazyk, ve kterém se tyto problémy potýkají.</span><span class="sxs-lookup"><span data-stu-id="caf85-106">It describes independent problem areas as Bounded Contexts (each Bounded Context correlates to a microservice), and emphasizes a common language to talk about these problems.</span></span> <span data-ttu-id="caf85-107">Navrhuje taky mnoho technických konceptů a vzorů, jako jsou entity domény s bohatými modely (žádný [anemic model](https://martinfowler.com/bliki/AnemicDomainModel.html)), objekty hodnot, agregace a agregovaná kořenová pravidla (nebo kořenová entita) pro podporu interní implementace.</span><span class="sxs-lookup"><span data-stu-id="caf85-107">It also suggests many technical concepts and patterns, like domain entities with rich models (no [anemic-domain model](https://martinfowler.com/bliki/AnemicDomainModel.html)), value objects, aggregates and aggregate root (or root entity) rules to support the internal implementation.</span></span> <span data-ttu-id="caf85-108">V této části se seznámíte s návrhem a implementací těchto interních vzorů.</span><span class="sxs-lookup"><span data-stu-id="caf85-108">This section introduces the design and implementation of those internal patterns.</span></span>

<span data-ttu-id="caf85-109">Někdy jsou tato DDD technická pravidla a vzory vnímané jako překážky, které mají pro implementaci DDDých přístupů křivku výukového strmé.</span><span class="sxs-lookup"><span data-stu-id="caf85-109">Sometimes these DDD technical rules and patterns are perceived as obstacles that have a steep learning curve for implementing DDD approaches.</span></span> <span data-ttu-id="caf85-110">Ale důležitá součást není vzorci, ale organizuje kód tak, aby byl zarovnán k obchodním problémům a používal stejné obchodní výrazy (všudypřítomný jazyk).</span><span class="sxs-lookup"><span data-stu-id="caf85-110">But the important part is not the patterns themselves, but organizing the code so it is aligned to the business problems, and using the same business terms (ubiquitous language).</span></span> <span data-ttu-id="caf85-111">Kromě toho by se měly použít jenom DDD, Pokud implementujete komplexní mikroslužby s významnými obchodními pravidly.</span><span class="sxs-lookup"><span data-stu-id="caf85-111">In addition, DDD approaches should be applied only if you are implementing complex microservices with significant business rules.</span></span> <span data-ttu-id="caf85-112">Jednodušší zodpovědnosti, jako je třeba služba CRUD, je možné spravovat pomocí jednodušších přístupů.</span><span class="sxs-lookup"><span data-stu-id="caf85-112">Simpler responsibilities, like a CRUD service, can be managed with simpler approaches.</span></span>

<span data-ttu-id="caf85-113">Místo vykreslování hranic je klíčovou úlohou při navrhování a definování mikroslužby.</span><span class="sxs-lookup"><span data-stu-id="caf85-113">Where to draw the boundaries is the key task when designing and defining a microservice.</span></span> <span data-ttu-id="caf85-114">Vzory DDD vám pomůžou pochopit složitost v doméně.</span><span class="sxs-lookup"><span data-stu-id="caf85-114">DDD patterns help you understand the complexity in the domain.</span></span> <span data-ttu-id="caf85-115">Pro model domény pro každý ohraničený kontext identifikujete a definujete entity, objekty hodnot a agregované modely, které modelují vaši doménu.</span><span class="sxs-lookup"><span data-stu-id="caf85-115">For the domain model for each Bounded Context, you identify and define the entities, value objects, and aggregates that model your domain.</span></span> <span data-ttu-id="caf85-116">Vytvoříte a upřesníte model domény, který je obsažen v hranici definující váš kontext.</span><span class="sxs-lookup"><span data-stu-id="caf85-116">You build and refine a domain model that is contained within a boundary that defines your context.</span></span> <span data-ttu-id="caf85-117">A to je velmi jasné v podobě mikroslužby.</span><span class="sxs-lookup"><span data-stu-id="caf85-117">And that is very explicit in the form of a microservice.</span></span> <span data-ttu-id="caf85-118">Komponenty v těchto hranicích mají za následek vaše mikroslužby, i když v některých případech mohou být BC nebo obchodní mikroslužby tvořené několika fyzickými službami.</span><span class="sxs-lookup"><span data-stu-id="caf85-118">The components within those boundaries end up being your microservices, although in some cases a BC or business microservices can be composed of several physical services.</span></span> <span data-ttu-id="caf85-119">DDD je o hranicích, takže se jedná o mikroslužby.</span><span class="sxs-lookup"><span data-stu-id="caf85-119">DDD is about boundaries and so are microservices.</span></span>

## <a name="keep-the-microservice-context-boundaries-relatively-small"></a><span data-ttu-id="caf85-120">Ponechejte hranice kontextu mikroslužeb relativně malé.</span><span class="sxs-lookup"><span data-stu-id="caf85-120">Keep the microservice context boundaries relatively small</span></span>

<span data-ttu-id="caf85-121">Určení místa, kde umístit hranice mezi ohraničené kontexty, vyvažuje ze dvou konkurenčních cílů.</span><span class="sxs-lookup"><span data-stu-id="caf85-121">Determining where to place boundaries between Bounded Contexts balances two competing goals.</span></span> <span data-ttu-id="caf85-122">Nejdřív budete chtít zpočátku vytvořit nejmenší možné mikroslužby, i když by neměl být hlavním ovladačem. měli byste vytvořit hranici kolem akcí, které vyžadují soudržnost.</span><span class="sxs-lookup"><span data-stu-id="caf85-122">First, you want to initially create the smallest possible microservices, although that should not be the main driver; you should create a boundary around things that need cohesion.</span></span> <span data-ttu-id="caf85-123">Za druhé se chcete vyhnout komunikaci mezi těmito mikroslužbami v konverzaci.</span><span class="sxs-lookup"><span data-stu-id="caf85-123">Second, you want to avoid chatty communications between microservices.</span></span> <span data-ttu-id="caf85-124">Tyto cíle mohou být vzájemně v konfliktu.</span><span class="sxs-lookup"><span data-stu-id="caf85-124">These goals can contradict one another.</span></span> <span data-ttu-id="caf85-125">Měli byste je vyrovnávat tím, že systém vyřadíte do tolika malých mikroslužeb, dokud se každý další pokus o oddělíte novým ohraničeným kontextem, dokud neuvidíte hranice komunikace.</span><span class="sxs-lookup"><span data-stu-id="caf85-125">You should balance them by decomposing the system into as many small microservices as you can until you see communication boundaries growing quickly with each additional attempt to separate a new Bounded Context.</span></span> <span data-ttu-id="caf85-126">Soudržnost je klíč v rámci jednoho ohraničeného kontextu.</span><span class="sxs-lookup"><span data-stu-id="caf85-126">Cohesion is key within a single bounded context.</span></span>

<span data-ttu-id="caf85-127">Je podobná [nevhodnému pachu kódu Intimacy](https://sourcemaking.com/refactoring/smells/inappropriate-intimacy) při implementaci tříd.</span><span class="sxs-lookup"><span data-stu-id="caf85-127">It is similar to the [Inappropriate Intimacy code smell](https://sourcemaking.com/refactoring/smells/inappropriate-intimacy) when implementing classes.</span></span> <span data-ttu-id="caf85-128">Pokud je potřeba, aby dvě mikroslužby vzájemně spolupracovaly, měly by být stejné mikroslužby.</span><span class="sxs-lookup"><span data-stu-id="caf85-128">If two microservices need to collaborate a lot with each other, they should probably be the same microservice.</span></span>

<span data-ttu-id="caf85-129">Dalším způsobem, jak se podívat, je autonomie.</span><span class="sxs-lookup"><span data-stu-id="caf85-129">Another way to look at this is autonomy.</span></span> <span data-ttu-id="caf85-130">Pokud mikroslužba musí spoléhat na jinou službu, aby mohla přímo obsluhovat požadavek, není to skutečně autonomní.</span><span class="sxs-lookup"><span data-stu-id="caf85-130">If a microservice must rely on another service to directly service a request, it is not truly autonomous.</span></span>

## <a name="layers-in-ddd-microservices"></a><span data-ttu-id="caf85-131">Vrstvy v DDD mikroslužby</span><span class="sxs-lookup"><span data-stu-id="caf85-131">Layers in DDD microservices</span></span>

<span data-ttu-id="caf85-132">Většina podnikových aplikací s významnou firmou a technickou složitostí je definována více vrstvami.</span><span class="sxs-lookup"><span data-stu-id="caf85-132">Most enterprise applications with significant business and technical complexity are defined by multiple layers.</span></span> <span data-ttu-id="caf85-133">Vrstvy jsou logický artefakt a nesouvisejí s nasazením služby.</span><span class="sxs-lookup"><span data-stu-id="caf85-133">The layers are a logical artifact, and are not related to the deployment of the service.</span></span> <span data-ttu-id="caf85-134">Existují, aby usnadnily vývojářům spravovat složitost v kódu.</span><span class="sxs-lookup"><span data-stu-id="caf85-134">They exist to help developers manage the complexity in the code.</span></span> <span data-ttu-id="caf85-135">Různé vrstvy (podobně jako vrstva doménového modelu oproti prezentační vrstvě atd.) mohou mít různé typy, které přijímají překlady mezi těmito typy.</span><span class="sxs-lookup"><span data-stu-id="caf85-135">Different layers (like the domain model layer versus the presentation layer, etc.) might have different types, which mandates translations between those types.</span></span>

<span data-ttu-id="caf85-136">Například entita může být načtena z databáze.</span><span class="sxs-lookup"><span data-stu-id="caf85-136">For example, an entity could be loaded from the database.</span></span> <span data-ttu-id="caf85-137">Tato informace je pak součástí těchto informací, nebo agregace informací, včetně dalších dat z jiných entit, je možné odeslat do uživatelského rozhraní klienta prostřednictvím webového rozhraní REST API.</span><span class="sxs-lookup"><span data-stu-id="caf85-137">Then part of that information, or an aggregation of information including additional data from other entities, can be sent to the client UI through a REST Web API.</span></span> <span data-ttu-id="caf85-138">Zde je uvedeno, že entita domény je obsažena v rámci vrstvy doménového modelu a neměla by být šířena do jiných oblastí, do kterých nepatří, například do prezentační vrstvy.</span><span class="sxs-lookup"><span data-stu-id="caf85-138">The point here is that the domain entity is contained within the domain model layer and should not be propagated to other areas that it does not belong to, like to the presentation layer.</span></span>

<span data-ttu-id="caf85-139">Kromě toho je potřeba mít vždycky platné entity (viz téma [návrh ověření v oddílu vrstva doménového modelu](domain-model-layer-validations.md) ) řízené agregovanými kořeny (kořenové entity).</span><span class="sxs-lookup"><span data-stu-id="caf85-139">Additionally, you need to have always-valid entities (see the [Designing validations in the domain model layer](domain-model-layer-validations.md) section) controlled by aggregate roots (root entities).</span></span> <span data-ttu-id="caf85-140">Entity by proto neměly být vázány na zobrazení klientů, protože na úrovni uživatelského rozhraní mohou být některá data stále neověřena.</span><span class="sxs-lookup"><span data-stu-id="caf85-140">Therefore, entities should not be bound to client views, because at the UI level some data might still not be validated.</span></span> <span data-ttu-id="caf85-141">To je to, pro který je ViewModel pro.</span><span class="sxs-lookup"><span data-stu-id="caf85-141">This is what the ViewModel is for.</span></span> <span data-ttu-id="caf85-142">ViewModel je datový model výhradně pro potřeby prezentační vrstvy.</span><span class="sxs-lookup"><span data-stu-id="caf85-142">The ViewModel is a data model exclusively for presentation layer needs.</span></span> <span data-ttu-id="caf85-143">Entity domény nepatří přímo do rozhraní ViewModel.</span><span class="sxs-lookup"><span data-stu-id="caf85-143">The domain entities do not belong directly to the ViewModel.</span></span> <span data-ttu-id="caf85-144">Místo toho je třeba překládat mezi ViewModels a doménovými entitami a naopak.</span><span class="sxs-lookup"><span data-stu-id="caf85-144">Instead, you need to translate between ViewModels and domain entities and vice versa.</span></span>

<span data-ttu-id="caf85-145">Při řešení složitosti je důležité mít doménový model řízený agregovanými kořeny, které zajistí, že všechny invariantní a pravidla související s touto skupinou entit (agregace) jsou prováděna prostřednictvím jediného vstupního bodu nebo brány, agregovaného kořene.</span><span class="sxs-lookup"><span data-stu-id="caf85-145">When tackling complexity, it is important to have a domain model controlled by aggregate roots that make sure that all the invariants and rules related to that group of entities (aggregate) are performed through a single entry-point or gate, the aggregate root.</span></span>

<span data-ttu-id="caf85-146">Obrázek 7-5 ukazuje, jak se v aplikaci eShopOnContainers implementuje vrstvený návrh.</span><span class="sxs-lookup"><span data-stu-id="caf85-146">Figure 7-5 shows how a layered design is implemented in the eShopOnContainers application.</span></span>

![Diagram znázorňující vrstvy v mikroslužbě návrhu založené na doméně](./media/ddd-oriented-microservice/domain-driven-design-microservice.png)

<span data-ttu-id="caf85-148">**Obrázek 7-5**.</span><span class="sxs-lookup"><span data-stu-id="caf85-148">**Figure 7-5**.</span></span> <span data-ttu-id="caf85-149">DDD vrstev v eShopOnContainersu pro řazení mikroslužeb</span><span class="sxs-lookup"><span data-stu-id="caf85-149">DDD layers in the ordering microservice in eShopOnContainers</span></span>

<span data-ttu-id="caf85-150">Tři vrstvy ve mikroslužbě DDD, jako je objednávání.</span><span class="sxs-lookup"><span data-stu-id="caf85-150">The three layers in a DDD microservice like Ordering.</span></span> <span data-ttu-id="caf85-151">Každá vrstva je projekt VS: aplikační vrstva se seřazením. API, vrstva domény se seřazením. doména a vrstva infrastruktury se seřazením. Infrastructure.</span><span class="sxs-lookup"><span data-stu-id="caf85-151">Each layer is a VS project: Application layer is Ordering.API, Domain layer is Ordering.Domain and the Infrastructure layer is Ordering.Infrastructure.</span></span> <span data-ttu-id="caf85-152">Chcete navrhnout systém tak, aby každá vrstva komunikovala pouze s některými jinými vrstvami.</span><span class="sxs-lookup"><span data-stu-id="caf85-152">You want to design the system so that each layer communicates only with certain other layers.</span></span> <span data-ttu-id="caf85-153">To může být snazší vyhovět, pokud jsou vrstvy implementovány jako jiné knihovny tříd, protože můžete jasně určit, jaké závislosti jsou nastaveny mezi knihovnami.</span><span class="sxs-lookup"><span data-stu-id="caf85-153">That may be easier to enforce if layers are implemented as different class libraries, because you can clearly identify what dependencies are set between libraries.</span></span> <span data-ttu-id="caf85-154">Například vrstva doménového modelu by neměla mít závislost na žádné jiné vrstvě (třídy doménového modelu by měly být prosté staré objekty CLR nebo [POCO](https://en.wikipedia.org/wiki/Plain_Old_CLR_Object), třídy).</span><span class="sxs-lookup"><span data-stu-id="caf85-154">For instance, the domain model layer should not take a dependency on any other layer (the domain model classes should be Plain Old CLR Objects, or [POCO](https://en.wikipedia.org/wiki/Plain_Old_CLR_Object), classes).</span></span> <span data-ttu-id="caf85-155">Jak je znázorněno na obrázku 7-6, **seřazení** knihovny vrstev domény má závislosti pouze na knihovnách .NET Core nebo balíčcích NuGet, ale ne na žádné jiné vlastní knihovně, jako je například knihovna dat nebo knihovna trvalosti.</span><span class="sxs-lookup"><span data-stu-id="caf85-155">As shown in Figure 7-6, the **Ordering.Domain** layer library has dependencies only on the .NET Core libraries or NuGet packages, but not on any other custom library, such as data library or persistence library.</span></span>

![Snímek obrazovky s řazením a závislostmi domén.](./media/ddd-oriented-microservice/ordering-domain-dependencies.png)

<span data-ttu-id="caf85-157">**Obrázek 7-6**.</span><span class="sxs-lookup"><span data-stu-id="caf85-157">**Figure 7-6**.</span></span> <span data-ttu-id="caf85-158">Vrstvy implementované jako knihovny umožňují lepší kontrolu závislostí mezi vrstvami.</span><span class="sxs-lookup"><span data-stu-id="caf85-158">Layers implemented as libraries allow better control of dependencies between layers</span></span>

### <a name="the-domain-model-layer"></a><span data-ttu-id="caf85-159">Vrstva doménového modelu</span><span class="sxs-lookup"><span data-stu-id="caf85-159">The domain model layer</span></span>

<span data-ttu-id="caf85-160">Vynikající [návrh založený na doméně](https://domainlanguage.com/ddd/) Eric Evans uvádí následující informace o vrstvě doménového modelu a vrstvě aplikace.</span><span class="sxs-lookup"><span data-stu-id="caf85-160">Eric Evans's excellent book [Domain Driven Design](https://domainlanguage.com/ddd/) says the following about the domain model layer and the application layer.</span></span>

<span data-ttu-id="caf85-161">**Vrstva doménového modelu**: zodpovídá za znázornění konceptů podnikání, informací o obchodní situaci a obchodních pravidel.</span><span class="sxs-lookup"><span data-stu-id="caf85-161">**Domain Model Layer**: Responsible for representing concepts of the business, information about the business situation, and business rules.</span></span> <span data-ttu-id="caf85-162">Stav, který odráží provozní situaci, se řídí a používá, i když jsou technické podrobnosti o jejich uložení delegovány na infrastrukturu.</span><span class="sxs-lookup"><span data-stu-id="caf85-162">State that reflects the business situation is controlled and used here, even though the technical details of storing it are delegated to the infrastructure.</span></span> <span data-ttu-id="caf85-163">Tato vrstva je srdcem podnikového softwaru.</span><span class="sxs-lookup"><span data-stu-id="caf85-163">This layer is the heart of business software.</span></span>

<span data-ttu-id="caf85-164">Vrstva doménového modelu je místo, kde se vyjadřuje podnikání.</span><span class="sxs-lookup"><span data-stu-id="caf85-164">The domain model layer is where the business is expressed.</span></span> <span data-ttu-id="caf85-165">Při implementaci vrstvy modelu domény mikroslužeb v rozhraní .NET je tato vrstva kódována jako knihovna tříd s entitami domény, které zachycují chování dat a chování (metody s logikou).</span><span class="sxs-lookup"><span data-stu-id="caf85-165">When you implement a microservice domain model layer in .NET, that layer is coded as a class library with the domain entities that capture data plus behavior (methods with logic).</span></span>

<span data-ttu-id="caf85-166">Po [ignorování perzistence](https://deviq.com/persistence-ignorance/) a principu [ignorování infrastruktury](https://ayende.com/blog/3137/infrastructure-ignorance) musí tato vrstva zcela ignorovat podrobnosti o trvalosti dat.</span><span class="sxs-lookup"><span data-stu-id="caf85-166">Following the [Persistence Ignorance](https://deviq.com/persistence-ignorance/) and the [Infrastructure Ignorance](https://ayende.com/blog/3137/infrastructure-ignorance) principles, this layer must completely ignore data persistence details.</span></span> <span data-ttu-id="caf85-167">Tyto úlohy trvalosti by měly být provedeny vrstvou infrastruktury.</span><span class="sxs-lookup"><span data-stu-id="caf85-167">These persistence tasks should be performed by the infrastructure layer.</span></span> <span data-ttu-id="caf85-168">Proto by tato vrstva neměla mít přímé závislosti na infrastruktuře, což znamená, že důležité pravidlo je, že třídy entit doménového modelu by měly být [POCO](https://en.wikipedia.org/wiki/Plain_Old_CLR_Object)s.</span><span class="sxs-lookup"><span data-stu-id="caf85-168">Therefore, this layer should not take direct dependencies on the infrastructure, which means that an important rule is that your domain model entity classes should be [POCO](https://en.wikipedia.org/wiki/Plain_Old_CLR_Object)s.</span></span>

<span data-ttu-id="caf85-169">Entity domény by neměly mít žádné přímé závislosti (například odvozené od základní třídy) na jakémkoli rozhraní infrastruktury pro přístup k datům, jako je Entity Framework nebo NHibernate.</span><span class="sxs-lookup"><span data-stu-id="caf85-169">Domain entities should not have any direct dependency (like deriving from a base class) on any data access infrastructure framework like Entity Framework or NHibernate.</span></span> <span data-ttu-id="caf85-170">V ideálním případě by vaše entity domény neměly odvozovat ani implementovat jakýkoli typ definovaný v žádném rozhraní infrastruktury.</span><span class="sxs-lookup"><span data-stu-id="caf85-170">Ideally, your domain entities should not derive from or implement any type defined in any infrastructure framework.</span></span>

<span data-ttu-id="caf85-171">Většina moderních rozhraní ORM, jako je Entity Framework Core, umožňují tento přístup, takže vaše třídy doménového modelu nejsou spojeny s infrastrukturou.</span><span class="sxs-lookup"><span data-stu-id="caf85-171">Most modern ORM frameworks like Entity Framework Core allow this approach, so that your domain model classes are not coupled to the infrastructure.</span></span> <span data-ttu-id="caf85-172">Nicméně při použití určitých databází NoSQL a architektur, jako jsou aktéri a spolehlivé kolekce v Azure Service Fabric, ale POCO entity nejsou vždy možné.</span><span class="sxs-lookup"><span data-stu-id="caf85-172">However, having POCO entities is not always possible when using certain NoSQL databases and frameworks, like Actors and Reliable Collections in Azure Service Fabric.</span></span>

<span data-ttu-id="caf85-173">I v případě, že je důležité dodržovat princip ignorování trvalosti pro doménový model, neměli byste ignorovat obavy o trvalosti.</span><span class="sxs-lookup"><span data-stu-id="caf85-173">Even when it is important to follow the Persistence Ignorance principle for your Domain model, you should not ignore persistence concerns.</span></span> <span data-ttu-id="caf85-174">Pořád je důležité pochopit fyzický datový model a jak se mapuje na model objektu entity.</span><span class="sxs-lookup"><span data-stu-id="caf85-174">It is still very important to understand the physical data model and how it maps to your entity object model.</span></span> <span data-ttu-id="caf85-175">V opačném případě můžete vytvořit neproveditelné návrhy.</span><span class="sxs-lookup"><span data-stu-id="caf85-175">Otherwise you can create impossible designs.</span></span>

<span data-ttu-id="caf85-176">To neznamená, že můžete vytvořit model navržený pro relační databázi a přímo ho přesunout do NoSQL nebo databáze orientované na dokument.</span><span class="sxs-lookup"><span data-stu-id="caf85-176">Also, this does not mean you can take a model designed for a relational database and directly move it to a NoSQL or document-oriented database.</span></span> <span data-ttu-id="caf85-177">V některých modelech entit se model může přizpůsobit, ale obvykle to není.</span><span class="sxs-lookup"><span data-stu-id="caf85-177">In some entity models, the model might fit, but usually it does not.</span></span> <span data-ttu-id="caf85-178">K dispozici jsou i omezení, která musí splňovat váš model entity, a to na základě technologie úložiště i technologie ORM.</span><span class="sxs-lookup"><span data-stu-id="caf85-178">There are still constraints that your entity model must adhere to, based both on the storage technology and ORM technology.</span></span>

### <a name="the-application-layer"></a><span data-ttu-id="caf85-179">Aplikační vrstva</span><span class="sxs-lookup"><span data-stu-id="caf85-179">The application layer</span></span>

<span data-ttu-id="caf85-180">Když se přesunete na aplikační vrstvu, můžeme znovu citovat [Návrh řízený](https://domainlanguage.com/ddd/)z Eric Evans v knize založené na doméně:</span><span class="sxs-lookup"><span data-stu-id="caf85-180">Moving on to the application layer, we can again cite Eric Evans's book [Domain Driven Design](https://domainlanguage.com/ddd/):</span></span>

<span data-ttu-id="caf85-181">**Aplikační vrstva:** Definuje úlohy, které má software dělat, a směruje objekty pro vyjádření na zpracování problémů.</span><span class="sxs-lookup"><span data-stu-id="caf85-181">**Application Layer:** Defines the jobs the software is supposed to do and directs the expressive domain objects to work out problems.</span></span> <span data-ttu-id="caf85-182">Úkoly, za které je tato vrstva odpovědná, jsou smysluplné pro firmu nebo nutné pro interakci s aplikačními vrstvami jiných systémů.</span><span class="sxs-lookup"><span data-stu-id="caf85-182">The tasks this layer is responsible for are meaningful to the business or necessary for interaction with the application layers of other systems.</span></span> <span data-ttu-id="caf85-183">Tato vrstva je udržována tenká.</span><span class="sxs-lookup"><span data-stu-id="caf85-183">This layer is kept thin.</span></span> <span data-ttu-id="caf85-184">Neobsahuje obchodní pravidla ani znalosti, ale koordinuje úlohy a delegáty fungují na spolupráci doménových objektů v další vrstvě.</span><span class="sxs-lookup"><span data-stu-id="caf85-184">It does not contain business rules or knowledge, but only coordinates tasks and delegates work to collaborations of domain objects in the next layer down.</span></span> <span data-ttu-id="caf85-185">Neodráží stav, který odráží provozní situaci, ale může mít stav, který odráží průběh úkolu pro uživatele nebo program.</span><span class="sxs-lookup"><span data-stu-id="caf85-185">It does not have state reflecting the business situation, but it can have state that reflects the progress of a task for the user or the program.</span></span>

<span data-ttu-id="caf85-186">Aplikační vrstva mikroslužeb v rozhraní .NET je běžně kódována jako ASP.NET Core projekt webového rozhraní API.</span><span class="sxs-lookup"><span data-stu-id="caf85-186">A microservice’s application layer in .NET is commonly coded as an ASP.NET Core Web API project.</span></span> <span data-ttu-id="caf85-187">Projekt implementuje interakci mikroslužby, vzdálený přístup k síti a externí webová rozhraní API, která se používají z uživatelského rozhraní nebo klientských aplikací.</span><span class="sxs-lookup"><span data-stu-id="caf85-187">The project implements the microservice’s interaction, remote network access, and the external Web APIs used from the UI or client apps.</span></span> <span data-ttu-id="caf85-188">Zahrnuje dotazy, pokud používáte přístup CQRS, příkazy akceptované mikroslužbou a dokonce i komunikaci řízenou událostmi mezi mikroslužbami (integračními událostmi).</span><span class="sxs-lookup"><span data-stu-id="caf85-188">It includes queries if using a CQRS approach, commands accepted by the microservice, and even the event-driven communication between microservices (integration events).</span></span> <span data-ttu-id="caf85-189">ASP.NET Core webové rozhraní API, které představuje aplikační vrstvu, nesmí obsahovat obchodní pravidla ani znalostní bázi domény (zejména pravidla domény pro transakce a aktualizace). Ty by měly být vlastněny knihovnou tříd doménového modelu.</span><span class="sxs-lookup"><span data-stu-id="caf85-189">The ASP.NET Core Web API that represents the application layer must not contain business rules or domain knowledge (especially domain rules for transactions or updates); these should be owned by the domain model class library.</span></span> <span data-ttu-id="caf85-190">Aplikační vrstva musí koordinovat pouze úlohy a nesmí obsahovat ani definovat žádný stav domény (doménový model).</span><span class="sxs-lookup"><span data-stu-id="caf85-190">The application layer must only coordinate tasks and must not hold or define any domain state (domain model).</span></span> <span data-ttu-id="caf85-191">Deleguje provádění obchodních pravidel pro samotné třídy doménového modelu (agregované kořeny a doménové entity), které budou nakonec aktualizovat data v těchto doménových entitách.</span><span class="sxs-lookup"><span data-stu-id="caf85-191">It delegates the execution of business rules to the domain model classes themselves (aggregate roots and domain entities), which will ultimately update the data within those domain entities.</span></span>

<span data-ttu-id="caf85-192">V podstatě aplikační logika je místo, kde implementujete všechny případy použití, které závisejí na daném front-endu.</span><span class="sxs-lookup"><span data-stu-id="caf85-192">Basically, the application logic is where you implement all use cases that depend on a given front end.</span></span> <span data-ttu-id="caf85-193">Například implementace týkající se služby webového rozhraní API.</span><span class="sxs-lookup"><span data-stu-id="caf85-193">For example, the implementation related to a Web API service.</span></span>

<span data-ttu-id="caf85-194">Cílem je, aby doménová logika v úrovni doménového modelu, její invariantní, datového modelu a souvisejících obchodních pravidel musela být zcela nezávislá na prezentačních a aplikačních vrstvách.</span><span class="sxs-lookup"><span data-stu-id="caf85-194">The goal is that the domain logic in the domain model layer, its invariants, the data model, and related business rules must be completely independent from the presentation and application layers.</span></span> <span data-ttu-id="caf85-195">Ve většině případů nesmí vrstva doménového modelu přímo záviset na žádném rozhraní infrastruktury.</span><span class="sxs-lookup"><span data-stu-id="caf85-195">Most of all, the domain model layer must not directly depend on any infrastructure framework.</span></span>

### <a name="the-infrastructure-layer"></a><span data-ttu-id="caf85-196">Vrstva infrastruktury</span><span class="sxs-lookup"><span data-stu-id="caf85-196">The infrastructure layer</span></span>

<span data-ttu-id="caf85-197">Vrstva infrastruktury je způsob, jakým se data, která se zpočátku ukládají v doménových entitách (v paměti), ukládají v databázích nebo jiném trvalém úložišti.</span><span class="sxs-lookup"><span data-stu-id="caf85-197">The infrastructure layer is how the data that is initially held in domain entities (in memory) is persisted in databases or another persistent store.</span></span> <span data-ttu-id="caf85-198">Příklad používá Entity Framework Core kód k implementaci tříd vzoru úložiště, které používají DBContext k uchování dat v relační databázi.</span><span class="sxs-lookup"><span data-stu-id="caf85-198">An example is using Entity Framework Core code to implement the Repository pattern classes that use a DBContext to persist data in a relational database.</span></span>

<span data-ttu-id="caf85-199">V souladu se zásadami pro [ignorování trvalého přetrvávání](https://deviq.com/persistence-ignorance/) a [ignorování infrastruktury](https://ayende.com/blog/3137/infrastructure-ignorance) nesmí vrstva infrastruktury "kontaminovat" vrstvu doménového modelu.</span><span class="sxs-lookup"><span data-stu-id="caf85-199">In accordance with the previously mentioned [Persistence Ignorance](https://deviq.com/persistence-ignorance/) and [Infrastructure Ignorance](https://ayende.com/blog/3137/infrastructure-ignorance) principles, the infrastructure layer must not “contaminate” the domain model layer.</span></span> <span data-ttu-id="caf85-200">Aby se třídy entit doménového modelu nezávislá z infrastruktury, která se používá k zachování dat (EF nebo jiných rozhraní), je nutné, aby nedošlo k nevynuceným závislostem na architekturách.</span><span class="sxs-lookup"><span data-stu-id="caf85-200">You must keep the domain model entity classes agnostic from the infrastructure that you use to persist data (EF or any other framework) by not taking hard dependencies on frameworks.</span></span> <span data-ttu-id="caf85-201">Knihovna tříd vrstvy doménového modelu by měla mít jenom svůj doménový kód, stačí [POCO](https://en.wikipedia.org/wiki/Plain_Old_CLR_Object) třídy entit, které implementují srdcový software a kompletně se odpojí od technologií infrastruktury.</span><span class="sxs-lookup"><span data-stu-id="caf85-201">Your domain model layer class library should have only your domain code, just [POCO](https://en.wikipedia.org/wiki/Plain_Old_CLR_Object) entity classes implementing the heart of your software and completely decoupled from infrastructure technologies.</span></span>

<span data-ttu-id="caf85-202">Proto by vaše vrstvy nebo knihovny tříd a projekty měly nakonec záviset na vaší vrstvě doménového modelu (knihovny), nikoli naopak, jak je znázorněno na obrázku 7-7.</span><span class="sxs-lookup"><span data-stu-id="caf85-202">Thus, your layers or class libraries and projects should ultimately depend on your domain model layer (library), not vice versa, as shown in Figure 7-7.</span></span>

![Diagram znázorňující závislosti, které existují mezi DDD vrstva služby](./media/ddd-oriented-microservice/ddd-service-layer-dependencies.png)

<span data-ttu-id="caf85-204">**Obrázek 7-7**.</span><span class="sxs-lookup"><span data-stu-id="caf85-204">**Figure 7-7**.</span></span> <span data-ttu-id="caf85-205">Závislosti mezi vrstvami v DDD</span><span class="sxs-lookup"><span data-stu-id="caf85-205">Dependencies between layers in DDD</span></span>

<span data-ttu-id="caf85-206">Závislosti v rámci služby na DDD závisí na doméně a infrastruktuře a infrastruktura závisí na doméně, ale doména není závislá na žádné vrstvě.</span><span class="sxs-lookup"><span data-stu-id="caf85-206">Dependencies in a DDD Service, the Application layer depends on Domain and Infrastructure, and Infrastructure depends on Domain, but Domain doesn't depend on any layer.</span></span> <span data-ttu-id="caf85-207">Tento návrh vrstvy by měl být nezávislý na každé mikroslužbě.</span><span class="sxs-lookup"><span data-stu-id="caf85-207">This layer design should be independent for each microservice.</span></span> <span data-ttu-id="caf85-208">Jak bylo uvedeno dříve, můžete implementovat nejvíc komplexní mikroslužby za vzory DDD, zatímco při jednodušším způsobu implementace jednodušších mikroslužeb založených na datech (jednoduchá CRUD v jedné vrstvě).</span><span class="sxs-lookup"><span data-stu-id="caf85-208">As noted earlier, you can implement the most complex microservices following DDD patterns, while implementing simpler data-driven microservices (simple CRUD in a single layer) in a simpler way.</span></span>

#### <a name="additional-resources"></a><span data-ttu-id="caf85-209">Další zdroje</span><span class="sxs-lookup"><span data-stu-id="caf85-209">Additional resources</span></span>

- <span data-ttu-id="caf85-210">**DevIQ. Princip ignorování trvalosti** </span><span class="sxs-lookup"><span data-stu-id="caf85-210">**DevIQ. Persistence Ignorance principle** </span></span>\
  <https://deviq.com/persistence-ignorance/>

- <span data-ttu-id="caf85-211">**Oren Eini. \ ignorování infrastruktury**</span><span class="sxs-lookup"><span data-stu-id="caf85-211">**Oren Eini. Infrastructure Ignorance** \</span></span>
  <https://ayende.com/blog/3137/infrastructure-ignorance>

- <span data-ttu-id="caf85-212">**Angel Lopez. Vrstvená architektura v návrhu založeném na doméně** </span><span class="sxs-lookup"><span data-stu-id="caf85-212">**Angel Lopez. Layered Architecture In Domain-Driven Design** </span></span>\
  <https://ajlopez.wordpress.com/2008/09/12/layered-architecture-in-domain-driven-design/>

>[!div class="step-by-step"]
><span data-ttu-id="caf85-213">[Předchozí](cqrs-microservice-reads.md)
>[Další](microservice-domain-model.md)</span><span class="sxs-lookup"><span data-stu-id="caf85-213">[Previous](cqrs-microservice-reads.md)
[Next](microservice-domain-model.md)</span></span>
