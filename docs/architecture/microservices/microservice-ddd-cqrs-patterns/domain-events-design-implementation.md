---
title: Události domény. návrh a realizace
description: Architektura mikroslužeb .NET pro kontejnerizované aplikace .NET | Získejte podrobný přehled událostí domény, což je klíčový koncept pro navázání komunikace mezi agregacemi.
ms.date: 10/08/2018
ms.openlocfilehash: 3bba18d4a77b47abee55c16bae8a64ed27ac9aba
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 03/14/2020
ms.locfileid: "74884225"
---
# <a name="domain-events-design-and-implementation"></a><span data-ttu-id="b0033-104">Doménové události: Návrh a implementace</span><span class="sxs-lookup"><span data-stu-id="b0033-104">Domain events: design and implementation</span></span>

<span data-ttu-id="b0033-105">Události domény slouží k explicitní implementaci vedlejších účinků změn v rámci domény.</span><span class="sxs-lookup"><span data-stu-id="b0033-105">Use domain events to explicitly implement side effects of changes within your domain.</span></span> <span data-ttu-id="b0033-106">Jinými slovy a pomocí terminologie DDD použijte události domény explicitně implementovat vedlejší účinky napříč více agregacemi.</span><span class="sxs-lookup"><span data-stu-id="b0033-106">In other words, and using DDD terminology, use domain events to explicitly implement side effects across multiple aggregates.</span></span> <span data-ttu-id="b0033-107">Volitelně pro lepší škálovatelnost a menší dopad na uzamčení databáze, použijte konečnou konzistenci mezi agregacemi v rámci stejné domény.</span><span class="sxs-lookup"><span data-stu-id="b0033-107">Optionally, for better scalability and less impact in database locks, use eventual consistency between aggregates within the same domain.</span></span>

## <a name="what-is-a-domain-event"></a><span data-ttu-id="b0033-108">Co je událost domény?</span><span class="sxs-lookup"><span data-stu-id="b0033-108">What is a domain event?</span></span>

<span data-ttu-id="b0033-109">Událost je něco, co se stalo v minulosti.</span><span class="sxs-lookup"><span data-stu-id="b0033-109">An event is something that has happened in the past.</span></span> <span data-ttu-id="b0033-110">Událost domény je něco, co se stalo v doméně, které chcete, aby ostatní části stejné domény (v procesu) být vědomi.</span><span class="sxs-lookup"><span data-stu-id="b0033-110">A domain event is, something that happened in the domain that you want other parts of the same domain (in-process) to be aware of.</span></span> <span data-ttu-id="b0033-111">Oznámené části obvykle nějak reagují na události.</span><span class="sxs-lookup"><span data-stu-id="b0033-111">The notified parts usually react somehow to the events.</span></span>

<span data-ttu-id="b0033-112">Důležitou výhodou událostí domény je, že vedlejší účinky mohou být vyjádřeny explicitně.</span><span class="sxs-lookup"><span data-stu-id="b0033-112">An important benefit of domain events is that side effects can be expressed explicitly.</span></span>

<span data-ttu-id="b0033-113">Například pokud právě používáte Entity Framework a musí být reakce na některé události, pravděpodobně kód, co potřebujete blízko co spouští událost.</span><span class="sxs-lookup"><span data-stu-id="b0033-113">For example, if you're just using Entity Framework and there has to be a reaction to some event, you would probably code whatever you need close to what triggers the event.</span></span> <span data-ttu-id="b0033-114">Takže pravidlo dostane spojen, implicitně, do kódu a budete muset podívat do kódu, doufejme, že si uvědomit, že pravidlo je implementováno tam.</span><span class="sxs-lookup"><span data-stu-id="b0033-114">So the rule gets coupled, implicitly, to the code, and you have to look into the code to, hopefully, realize the rule is implemented there.</span></span>

<span data-ttu-id="b0033-115">Na druhou stranu pomocí události domény je koncept explicitní, protože je `DomainEvent` a alespoň jeden `DomainEventHandler` zapojených.</span><span class="sxs-lookup"><span data-stu-id="b0033-115">On the other hand, using domain events makes the concept explicit, because there is a `DomainEvent` and at least one `DomainEventHandler` involved.</span></span>

<span data-ttu-id="b0033-116">Například v aplikaci eShopOnContainers při vytvoření objednávky se uživatel stane `OrderStartedDomainEvent` kupujícím, takže `ValidateOrAddBuyerAggregateWhenOrderStartedDomainEventHandler`je aktivována a zpracována v , takže základní koncept je evidentní.</span><span class="sxs-lookup"><span data-stu-id="b0033-116">For example, in the eShopOnContainers application, when an order is created, the user becomes a buyer, so an `OrderStartedDomainEvent` is raised and handled in the `ValidateOrAddBuyerAggregateWhenOrderStartedDomainEventHandler`, so the underlying concept is evident.</span></span>

<span data-ttu-id="b0033-117">Stručně řečeno, události domény vám pomohou explicitně vyjádřit pravidla domény založená v všudypřítomném jazyce poskytovaném odborníky domény.</span><span class="sxs-lookup"><span data-stu-id="b0033-117">In short, domain events help you to express, explicitly, the domain rules, based in the ubiquitous language provided by the domain experts.</span></span> <span data-ttu-id="b0033-118">Události domény také umožňují lepší oddělení obav mezi třídy v rámci stejné domény.</span><span class="sxs-lookup"><span data-stu-id="b0033-118">Domain events also enable a better separation of concerns among classes within the same domain.</span></span>

<span data-ttu-id="b0033-119">Je důležité zajistit, že stejně jako databázová transakce, buď všechny operace související s událostí domény úspěšně dokončit nebo žádný z nich dělat.</span><span class="sxs-lookup"><span data-stu-id="b0033-119">It's important to ensure that, just like a database transaction, either all the operations related to a domain event finish successfully or none of them do.</span></span>

<span data-ttu-id="b0033-120">Události domény jsou podobné události ve stylu zasílání zpráv, s jedním důležitým rozdílem.</span><span class="sxs-lookup"><span data-stu-id="b0033-120">Domain events are similar to messaging-style events, with one important difference.</span></span> <span data-ttu-id="b0033-121">Při skutečném zasílání zpráv, frontách zpráv, zprostředkovatelích zpráv nebo službě Service Bus pomocí služby AMQP je zpráva vždy odesílána asynchronně a komunikována mezi procesy a počítači.</span><span class="sxs-lookup"><span data-stu-id="b0033-121">With real messaging, message queuing, message brokers, or a service bus using AMQP, a message is always sent asynchronously and communicated across processes and machines.</span></span> <span data-ttu-id="b0033-122">To je užitečné pro integraci více ohraničené kontexty, mikroslužeb nebo dokonce různé aplikace.</span><span class="sxs-lookup"><span data-stu-id="b0033-122">This is useful for integrating multiple Bounded Contexts, microservices, or even different applications.</span></span> <span data-ttu-id="b0033-123">S událostmi domény však chcete vyvolat událost z operace domény, kterou právě sbíháte, ale chcete, aby se v rámci stejné domény vyskytly jakékoli vedlejší účinky.</span><span class="sxs-lookup"><span data-stu-id="b0033-123">However, with domain events, you want to raise an event from the domain operation you are currently running, but you want any side effects to occur within the same domain.</span></span>

<span data-ttu-id="b0033-124">Události domény a jejich vedlejší účinky (akce aktivované později, které jsou spravovány obslužnými rutinami událostí) by se měly objevit téměř okamžitě, obvykle v procesu a v rámci stejné domény.</span><span class="sxs-lookup"><span data-stu-id="b0033-124">The domain events and their side effects (the actions triggered afterwards that are managed by event handlers) should occur almost immediately, usually in-process, and within the same domain.</span></span> <span data-ttu-id="b0033-125">Události domény tedy mohou být synchronní nebo asynchronní.</span><span class="sxs-lookup"><span data-stu-id="b0033-125">Thus, domain events could be synchronous or asynchronous.</span></span> <span data-ttu-id="b0033-126">Události integrace by však měly být vždy asynchronní.</span><span class="sxs-lookup"><span data-stu-id="b0033-126">Integration events, however, should always be asynchronous.</span></span>

## <a name="domain-events-versus-integration-events"></a><span data-ttu-id="b0033-127">Události domény versus události integrace</span><span class="sxs-lookup"><span data-stu-id="b0033-127">Domain events versus integration events</span></span>

<span data-ttu-id="b0033-128">Sémanticky, domény a integrace události jsou totéž: oznámení o něčem, co se právě stalo.</span><span class="sxs-lookup"><span data-stu-id="b0033-128">Semantically, domain and integration events are the same thing: notifications about something that just happened.</span></span> <span data-ttu-id="b0033-129">Jejich provádění však musí být odlišné.</span><span class="sxs-lookup"><span data-stu-id="b0033-129">However, their implementation must be different.</span></span> <span data-ttu-id="b0033-130">Události domény jsou pouze zprávy odeslané dispečerovi událostí domény, které mohou být implementovány jako mediátor v paměti založené na kontejneru IoC nebo jiné metodě.</span><span class="sxs-lookup"><span data-stu-id="b0033-130">Domain events are just messages pushed to a domain event dispatcher, which could be implemented as an in-memory mediator based on an IoC container or any other method.</span></span>

<span data-ttu-id="b0033-131">Na druhé straně účelem události integrace je šířit potvrzené transakce a aktualizace dalších subsystémů, ať už jsou jiné mikroslužby, ohraničené kontexty nebo dokonce externí aplikace.</span><span class="sxs-lookup"><span data-stu-id="b0033-131">On the other hand, the purpose of integration events is to propagate committed transactions and updates to additional subsystems, whether they are other microservices, Bounded Contexts or even external applications.</span></span> <span data-ttu-id="b0033-132">Proto by k nim mělo dojít pouze v případě, že entita je úspěšně trvalá, jinak je to, jako by se celá operace nikdy neuskutečnila.</span><span class="sxs-lookup"><span data-stu-id="b0033-132">Hence, they should occur only if the entity is successfully persisted, otherwise it's as if the entire operation never happened.</span></span>

<span data-ttu-id="b0033-133">Jak již bylo zmíněno dříve, události integrace musí být založeny na asynchronní komunikaci mezi více mikroslužeb (jiné ohraničené kontexty) nebo dokonce externí systémy/aplikace.</span><span class="sxs-lookup"><span data-stu-id="b0033-133">As mentioned before, integration events must be based on asynchronous communication between multiple microservices (other Bounded Contexts) or even external systems/applications.</span></span>

<span data-ttu-id="b0033-134">Rozhraní sběrnice událostí tedy potřebuje určitou infrastrukturu, která umožňuje meziprocesovou a distribuovanou komunikaci mezi potenciálně vzdálenými službami.</span><span class="sxs-lookup"><span data-stu-id="b0033-134">Thus, the event bus interface needs some infrastructure that allows inter-process and distributed communication between potentially remote services.</span></span> <span data-ttu-id="b0033-135">Může být založen na komerční sběrnici, frontách, sdílené databázi používané jako poštovní schránka nebo jiném distribuovaném a ideálně nabízeném systému zasílání zpráv.</span><span class="sxs-lookup"><span data-stu-id="b0033-135">It can be based on a commercial service bus, queues, a shared database used as a mailbox, or any other distributed and ideally push based messaging system.</span></span>

## <a name="domain-events-as-a-preferred-way-to-trigger-side-effects-across-multiple-aggregates-within-the-same-domain"></a><span data-ttu-id="b0033-136">Události domény jako upřednostňovaný způsob, jak vyvolat vedlejší účinky napříč více agregacemi v rámci stejné domény</span><span class="sxs-lookup"><span data-stu-id="b0033-136">Domain events as a preferred way to trigger side effects across multiple aggregates within the same domain</span></span>

<span data-ttu-id="b0033-137">Pokud spuštění příkazu souvisejícího s jednou agregační instancí vyžaduje spuštění dalších pravidel domény na jednom nebo více dalších agregacích, měli byste tyto vedlejší účinky navrhnout a implementovat tak, aby byly spuštěny událostmi domény.</span><span class="sxs-lookup"><span data-stu-id="b0033-137">If executing a command related to one aggregate instance requires additional domain rules to be run on one or more additional aggregates, you should design and implement those side effects to be triggered by domain events.</span></span> <span data-ttu-id="b0033-138">Jak je znázorněno na obrázku 7-14 a jako jeden z nejdůležitějších případů použití, událost domény by měla být použita k šíření změn stavu napříč více agregacemi v rámci stejného modelu domény.</span><span class="sxs-lookup"><span data-stu-id="b0033-138">As shown in Figure 7-14, and as one of the most important use cases, a domain event should be used to propagate state changes across multiple aggregates within the same domain model.</span></span>

![Diagram znázorňující událost domény ovládající data do agregace Kupujícího.](./media/domain-events-design-implementation/domain-model-ordering-microservice.png)

<span data-ttu-id="b0033-140">**Obrázek 7-14**.</span><span class="sxs-lookup"><span data-stu-id="b0033-140">**Figure 7-14**.</span></span> <span data-ttu-id="b0033-141">Události domény k vynucení konzistence mezi více agregacemi v rámci stejné domény</span><span class="sxs-lookup"><span data-stu-id="b0033-141">Domain events to enforce consistency between multiple aggregates within the same domain</span></span>

<span data-ttu-id="b0033-142">Obrázek 7-14 ukazuje, jak je dosaženo konzistence mezi agregacemi podle událostí domény.</span><span class="sxs-lookup"><span data-stu-id="b0033-142">Figure 7-14 shows how consistency between aggregates is achieved by domain events.</span></span> <span data-ttu-id="b0033-143">Když uživatel zahájí objednávku, agregace objednávky odešle `OrderStarted` událost domény.</span><span class="sxs-lookup"><span data-stu-id="b0033-143">When the user initiates an order, the Order Aggregate sends an `OrderStarted` domain event.</span></span> <span data-ttu-id="b0033-144">Událost domény OrderStarted je zpracována agregací kupujícího k vytvoření objektu Buyer v objednávající mikroslužbě na základě původních informací o uživateli z mikroslužby identity (s informacemi poskytnutými v příkazu CreateOrder).</span><span class="sxs-lookup"><span data-stu-id="b0033-144">The OrderStarted domain event is handled by the Buyer Aggregate to create a Buyer object in the ordering microservice, based on the original user info from the identity microservice (with information provided in the CreateOrder command).</span></span>

<span data-ttu-id="b0033-145">Alternativně můžete mít agregované root objednané události vyvolané členy jeho agregace (podřízené entity).</span><span class="sxs-lookup"><span data-stu-id="b0033-145">Alternately, you can have the aggregate root subscribed for events raised by members of its aggregates (child entities).</span></span> <span data-ttu-id="b0033-146">Například každá podřízená entita OrderItem může vyvolat událost, když je cena položky vyšší než určitá částka nebo pokud je částka položky produktu příliš vysoká.</span><span class="sxs-lookup"><span data-stu-id="b0033-146">For instance, each OrderItem child entity can raise an event when the item price is higher than a specific amount, or when the product item amount is too high.</span></span> <span data-ttu-id="b0033-147">Agregační kořen pak můžete přijímat tyto události a provést globální výpočet nebo agregaci.</span><span class="sxs-lookup"><span data-stu-id="b0033-147">The aggregate root can then receive those events and perform a global calculation or aggregation.</span></span>

<span data-ttu-id="b0033-148">Je důležité si uvědomit, že tato komunikace založená na událostech není implementována přímo v rámci agregací; je třeba implementovat obslužné rutiny událostí domény.</span><span class="sxs-lookup"><span data-stu-id="b0033-148">It is important to understand that this event-based communication is not implemented directly within the aggregates; you need to implement domain event handlers.</span></span>

<span data-ttu-id="b0033-149">Zpracování událostí domény je problém aplikace.</span><span class="sxs-lookup"><span data-stu-id="b0033-149">Handling the domain events is an application concern.</span></span> <span data-ttu-id="b0033-150">Vrstva modelu domény by se měla zaměřit pouze na logiku domény – věci, které by znalec domény pochopil, nikoli aplikační infrastruktury, jako jsou obslužné rutiny a akce trvalosti vedlejších účinků pomocí úložišť.</span><span class="sxs-lookup"><span data-stu-id="b0033-150">The domain model layer should only focus on the domain logic—things that a domain expert would understand, not application infrastructure like handlers and side-effect persistence actions using repositories.</span></span> <span data-ttu-id="b0033-151">Úroveň aplikační vrstvy je proto místo, kde byste měli mít obslužné rutiny událostí domény, které spouštějí akce při vyvolání události domény.</span><span class="sxs-lookup"><span data-stu-id="b0033-151">Therefore, the application layer level is where you should have domain event handlers triggering actions when a domain event is raised.</span></span>

<span data-ttu-id="b0033-152">Události domény lze také použít k aktivaci libovolného počtu akcí aplikace a co je důležitější, musí být otevřené zvýšit toto číslo v budoucnu odděleným způsobem.</span><span class="sxs-lookup"><span data-stu-id="b0033-152">Domain events can also be used to trigger any number of application actions, and what is more important, must be open to increase that number in the future in a decoupled way.</span></span> <span data-ttu-id="b0033-153">Například při spuštění objednávky můžete chtít publikovat událost domény k šíření těchto informací do jiných agregací nebo dokonce zvýšit akce aplikace, jako jsou oznámení.</span><span class="sxs-lookup"><span data-stu-id="b0033-153">For instance, when the order is started, you might want to publish a domain event to propagate that info to other aggregates or even to raise application actions like notifications.</span></span>

<span data-ttu-id="b0033-154">Klíčovým bodem je otevřený počet akcí, které mají být provedeny při výskytu události domény.</span><span class="sxs-lookup"><span data-stu-id="b0033-154">The key point is the open number of actions to be executed when a domain event occurs.</span></span> <span data-ttu-id="b0033-155">Nakonec akce a pravidla v doméně a aplikaci poroste.</span><span class="sxs-lookup"><span data-stu-id="b0033-155">Eventually, the actions and rules in the domain and application will grow.</span></span> <span data-ttu-id="b0033-156">Složitost nebo počet akcí vedlejších účinků, když se něco stane, se zvýší, ale pokud byl váš `new`kód spojen s "lepidlem" (to znamená vytvářením konkrétních objektů s ), pak pokaždé, když potřebujete přidat novou akci, budete také muset změnit pracovní a testovaný kód.</span><span class="sxs-lookup"><span data-stu-id="b0033-156">The complexity or number of side-effect actions when something happens will grow, but if your code were coupled with “glue” (that is, creating specific objects with `new`), then every time you needed to add a new action you would also need to change working and tested code.</span></span>

<span data-ttu-id="b0033-157">Tato změna by mohla vést k novým chybám a tento přístup je také v rozporu s [principem otevření/uzavření](https://en.wikipedia.org/wiki/Open/closed_principle) z [SOLID](https://en.wikipedia.org/wiki/SOLID).</span><span class="sxs-lookup"><span data-stu-id="b0033-157">This change could result in new bugs and this approach also goes against the [Open/Closed principle](https://en.wikipedia.org/wiki/Open/closed_principle) from [SOLID](https://en.wikipedia.org/wiki/SOLID).</span></span> <span data-ttu-id="b0033-158">Nejen to, původní třída, která byla orchestrating operace by růst a růst, což je v rozporu s [jednotnou odpovědnost i (SRP)](https://en.wikipedia.org/wiki/Single_responsibility_principle).</span><span class="sxs-lookup"><span data-stu-id="b0033-158">Not only that, the original class that was orchestrating the operations would grow and grow, which goes against the [Single Responsibility Principle (SRP)](https://en.wikipedia.org/wiki/Single_responsibility_principle).</span></span>

<span data-ttu-id="b0033-159">Na druhou stranu, pokud používáte události domény, můžete vytvořit jemně odstupňované a oddělené implementace oddělením odpovědnosti pomocí tohoto přístupu:</span><span class="sxs-lookup"><span data-stu-id="b0033-159">On the other hand, if you use domain events, you can create a fine-grained and decoupled implementation by segregating responsibilities using this approach:</span></span>

1. <span data-ttu-id="b0033-160">Odeslat příkaz (například CreateOrder).</span><span class="sxs-lookup"><span data-stu-id="b0033-160">Send a command (for example, CreateOrder).</span></span>
2. <span data-ttu-id="b0033-161">Přijměte příkaz v obslužné rutině příkazu.</span><span class="sxs-lookup"><span data-stu-id="b0033-161">Receive the command in a command handler.</span></span>
   - <span data-ttu-id="b0033-162">Proveďte transakci jednoho agregace.</span><span class="sxs-lookup"><span data-stu-id="b0033-162">Execute a single aggregate’s transaction.</span></span>
   - <span data-ttu-id="b0033-163">(Nepovinné) Raise domain events for side effects (například OrderStartedDomainEvent).</span><span class="sxs-lookup"><span data-stu-id="b0033-163">(Optional) Raise domain events for side effects (for example, OrderStartedDomainEvent).</span></span>
3. <span data-ttu-id="b0033-164">Zpracování událostí domény (v rámci aktuálního procesu), který provede otevřený počet vedlejších účinků ve více agregaci nebo akce aplikace.</span><span class="sxs-lookup"><span data-stu-id="b0033-164">Handle domain events (within the current process) that will execute an open number of side effects in multiple aggregates or application actions.</span></span> <span data-ttu-id="b0033-165">Například:</span><span class="sxs-lookup"><span data-stu-id="b0033-165">For example:</span></span>
   - <span data-ttu-id="b0033-166">Ověřte nebo vytvořte kupujícího a způsob platby.</span><span class="sxs-lookup"><span data-stu-id="b0033-166">Verify or create buyer and payment method.</span></span>
   - <span data-ttu-id="b0033-167">Vytvořte a odešlete související integrační událost do sběrnice událostí, abyste rozšířili stavy napříč mikroslužbami nebo spustili externí akce, jako je odeslání e-mailu kupujícímu.</span><span class="sxs-lookup"><span data-stu-id="b0033-167">Create and send a related integration event to the event bus to propagate states across microservices or trigger external actions like sending an email to the buyer.</span></span>
   - <span data-ttu-id="b0033-168">Zvládejte další nežádoucí účinky.</span><span class="sxs-lookup"><span data-stu-id="b0033-168">Handle other side effects.</span></span>

<span data-ttu-id="b0033-169">Jak je znázorněno na obrázku 7-15, počínaje stejnou událostí domény, můžete zpracovat více akcí souvisejících s jinými agregacemi v doméně nebo dalšími akcemi aplikace, které je třeba provést napříč mikroslužbami, které se připojují k událostem integrace a sběrnici událostí.</span><span class="sxs-lookup"><span data-stu-id="b0033-169">As shown in Figure 7-15, starting from the same domain event, you can handle multiple actions related to other aggregates in the domain or additional application actions you need to perform across microservices connecting with integration events and the event bus.</span></span>

![Diagram znázorňující událost domény, která předává data několika obslužným rutinám událostí.](./media/domain-events-design-implementation/aggregate-domain-event-handlers.png)

<span data-ttu-id="b0033-171">**Obrázek 7-15**.</span><span class="sxs-lookup"><span data-stu-id="b0033-171">**Figure 7-15**.</span></span> <span data-ttu-id="b0033-172">Zpracování více akcí na doménu</span><span class="sxs-lookup"><span data-stu-id="b0033-172">Handling multiple actions per domain</span></span>

<span data-ttu-id="b0033-173">Může existovat několik obslužných rutin pro stejnou událost domény v aplikační vrstvě, jedna obslužná rutina může vyřešit konzistenci mezi agregacemi a jinou obslužnou rutinou může publikovat integrační událost, takže s ní mohou jiné mikroslužby něco udělat.</span><span class="sxs-lookup"><span data-stu-id="b0033-173">There can be several handlers for the same domain event in the Application Layer, one handler can solve consistency between aggregates and another handler can publish an integration event, so other microservices can do something with it.</span></span> <span data-ttu-id="b0033-174">Obslužné rutiny událostí jsou obvykle ve vrstvě aplikace, protože budete používat objekty infrastruktury, jako jsou úložiště nebo rozhraní API aplikace pro chování mikroslužby.</span><span class="sxs-lookup"><span data-stu-id="b0033-174">The event handlers are typically in the application layer, because you will use infrastructure objects like repositories or an application API for the microservice’s behavior.</span></span> <span data-ttu-id="b0033-175">V tomto smyslu jsou obslužné rutiny událostí podobné obslužným rutinám příkazů, takže obě jsou součástí aplikační vrstvy.</span><span class="sxs-lookup"><span data-stu-id="b0033-175">In that sense, event handlers are similar to command handlers, so both are part of the application layer.</span></span> <span data-ttu-id="b0033-176">Důležitým rozdílem je, že příkaz by měl být zpracován pouze jednou.</span><span class="sxs-lookup"><span data-stu-id="b0033-176">The important difference is that a command should be processed only once.</span></span> <span data-ttu-id="b0033-177">Událost domény může být zpracována nula nebo *n* krát, protože může být přijata více příjemců nebo obslužné rutiny událostí s jiným účelem pro každou obslužnou rutinu.</span><span class="sxs-lookup"><span data-stu-id="b0033-177">A domain event could be processed zero or *n* times, because it can be received by multiple receivers or event handlers with a different purpose for each handler.</span></span>

<span data-ttu-id="b0033-178">S otevřeným počtem obslužných rutin na událost domény umožňuje přidat tolik pravidel domény podle potřeby, aniž by to ovlivnilo aktuální kód.</span><span class="sxs-lookup"><span data-stu-id="b0033-178">Having an open number of handlers per domain event allows you to add as many domain rules as needed, without affecting  current code.</span></span> <span data-ttu-id="b0033-179">Například implementace následujícího obchodního pravidla může být stejně snadná jako přidání několika obslužných rutin událostí (nebo dokonce jen jednoho):</span><span class="sxs-lookup"><span data-stu-id="b0033-179">For instance, implementing the following business rule might be as easy as adding a few event handlers (or even just one):</span></span>

> <span data-ttu-id="b0033-180">Pokud celková částka zakoupená zákazníkem v obchodě v libovolném počtu objednávek přesáhne 6 000 USD, použijte slevu 10% na každou novou objednávku a informujte zákazníka e-mailem o této slevě pro budoucí objednávky.</span><span class="sxs-lookup"><span data-stu-id="b0033-180">When the total amount purchased by a customer in the store, across any number of orders, exceeds $6,000, apply a 10% off discount to every new order and notify the customer with an email about that discount for future orders.</span></span>

## <a name="implement-domain-events"></a><span data-ttu-id="b0033-181">Implementace událostí domény</span><span class="sxs-lookup"><span data-stu-id="b0033-181">Implement domain events</span></span>

<span data-ttu-id="b0033-182">V C#, událost domény je jednoduše struktura nebo třída pro držení dat, jako je DTO, se všemi informacemi týkajícími se toho, co se právě stalo v doméně, jak je znázorněno v následujícím příkladu:</span><span class="sxs-lookup"><span data-stu-id="b0033-182">In C#, a domain event is simply a data-holding structure or class, like a DTO, with all the information related to what just happened in the domain, as shown in the following example:</span></span>

```csharp
public class OrderStartedDomainEvent : INotification
{
    public string UserId { get; }
    public int CardTypeId { get; }
    public string CardNumber { get; }
    public string CardSecurityNumber { get; }
    public string CardHolderName { get; }
    public DateTime CardExpiration { get; }
    public Order Order { get; }

    public OrderStartedDomainEvent(Order order,
                                   int cardTypeId, string cardNumber,
                                   string cardSecurityNumber, string cardHolderName,
                                   DateTime cardExpiration)
    {
        Order = order;
        CardTypeId = cardTypeId;
        CardNumber = cardNumber;
        CardSecurityNumber = cardSecurityNumber;
        CardHolderName = cardHolderName;
        CardExpiration = cardExpiration;
    }
}
```

<span data-ttu-id="b0033-183">Toto je v podstatě třída, která obsahuje všechna data související s OrderStarted události.</span><span class="sxs-lookup"><span data-stu-id="b0033-183">This is essentially a class that holds all the data related to the OrderStarted event.</span></span>

<span data-ttu-id="b0033-184">Pokud jde o všudypřítomný jazyk domény, protože událost je něco, co se stalo v minulosti, název třídy události by měl být reprezentován jako sloveso v minulém řádu, jako orderstarteddomainevent nebo OrderShippedDomainEvent.</span><span class="sxs-lookup"><span data-stu-id="b0033-184">In terms of the ubiquitous language of the domain, since an event is something that happened in the past, the class name of the event should be represented as a past-tense verb, like OrderStartedDomainEvent or OrderShippedDomainEvent.</span></span> <span data-ttu-id="b0033-185">Tak je událost domény implementována v objednávání mikroslužby v eShopOnContainers.</span><span class="sxs-lookup"><span data-stu-id="b0033-185">That's how the domain event is implemented in the ordering microservice in eShopOnContainers.</span></span>

<span data-ttu-id="b0033-186">Jak již bylo uvedeno dříve, důležitou charakteristikou událostí je, že vzhledem k tomu, že událost je něco, co se stalo v minulosti, nemělo by se to měnit.</span><span class="sxs-lookup"><span data-stu-id="b0033-186">As noted earlier, an important characteristic of events is that since an event is something that happened in the past, it should not change.</span></span> <span data-ttu-id="b0033-187">Proto musí být neměnné třídy.</span><span class="sxs-lookup"><span data-stu-id="b0033-187">Therefore, it must be an immutable class.</span></span> <span data-ttu-id="b0033-188">V předchozím kódu se zobrazí, že vlastnosti jsou jen pro čtení.</span><span class="sxs-lookup"><span data-stu-id="b0033-188">You can see in the previous code that the properties are read-only.</span></span> <span data-ttu-id="b0033-189">Neexistuje žádný způsob, jak aktualizovat objekt, můžete nastavit hodnoty pouze při jeho vytvoření.</span><span class="sxs-lookup"><span data-stu-id="b0033-189">There's no way to update the object, you can only set values when you create it.</span></span>

<span data-ttu-id="b0033-190">Je důležité zdůraznit, že pokud by události domény byly zpracovány asynchronně pomocí fronty, která vyžadovala serializaci a deserializaci objektů události, vlastnosti by musely být "soukromé sady" namísto jen pro čtení, takže by byl deserializátor mohou přiřadit hodnoty při dequeuing.</span><span class="sxs-lookup"><span data-stu-id="b0033-190">It’s important to highlight here that if domain events were to be handled asynchronously, using a queue that required serializing and deserializing the event objects, the properties would have to be “private set” instead of read-only, so the deserializer would be able to assign the values upon dequeuing.</span></span> <span data-ttu-id="b0033-191">To to není problém v objednávání mikroslužby, jako domain event pub/sub je implementována synchronně pomocí MediatR.</span><span class="sxs-lookup"><span data-stu-id="b0033-191">This is not an issue in the Ordering microservice, as the domain event pub/sub is implemented synchronously using MediatR.</span></span>

### <a name="raise-domain-events"></a><span data-ttu-id="b0033-192">Zvýšit události domény</span><span class="sxs-lookup"><span data-stu-id="b0033-192">Raise domain events</span></span>

<span data-ttu-id="b0033-193">Další otázkou je, jak vyvolat událost domény tak, aby dosáhla související chod ní obslužné rutiny události.</span><span class="sxs-lookup"><span data-stu-id="b0033-193">The next question is how to raise a domain event so it reaches its related event handlers.</span></span> <span data-ttu-id="b0033-194">Můžete použít více přístupů.</span><span class="sxs-lookup"><span data-stu-id="b0033-194">You can use multiple approaches.</span></span>

<span data-ttu-id="b0033-195">Udi Dahan původně navrhl (například v několika souvisejících pracovních míst, jako je [například domain events - Take 2](http://udidahan.com/2008/08/25/domain-events-take-2/)) pomocí statické třídy pro správu a zvyšování událostí.</span><span class="sxs-lookup"><span data-stu-id="b0033-195">Udi Dahan originally proposed (for example, in several related posts, such as [Domain Events – Take 2](http://udidahan.com/2008/08/25/domain-events-take-2/)) using a static class for managing and raising the events.</span></span> <span data-ttu-id="b0033-196">To může zahrnovat statickou třídu s názvem DomainEvents, která by `DomainEvents.Raise(Event myEvent)`okamžitě vyvolala události domény, když je volána, pomocí syntaxe jako .</span><span class="sxs-lookup"><span data-stu-id="b0033-196">This might include a static class named DomainEvents that would raise domain events immediately when it is called, using syntax like `DomainEvents.Raise(Event myEvent)`.</span></span> <span data-ttu-id="b0033-197">Jimmy Bogard napsal blogový příspěvek[(Posílení vaší domény: Domain Events),](https://lostechies.com/jimmybogard/2010/04/08/strengthening-your-domain-domain-events/)který doporučuje podobný přístup.</span><span class="sxs-lookup"><span data-stu-id="b0033-197">Jimmy Bogard wrote a blog post ([Strengthening your domain: Domain Events](https://lostechies.com/jimmybogard/2010/04/08/strengthening-your-domain-domain-events/)) that recommends a similar approach.</span></span>

<span data-ttu-id="b0033-198">Však při třídy událostí domény je statická, také odešle obslužné rutiny okamžitě.</span><span class="sxs-lookup"><span data-stu-id="b0033-198">However, when the domain events class is static, it also dispatches to handlers immediately.</span></span> <span data-ttu-id="b0033-199">To ztěžuje testování a ladění, protože obslužné rutiny událostí s logikou vedlejších účinků jsou spuštěny ihned po vyvolání události.</span><span class="sxs-lookup"><span data-stu-id="b0033-199">This makes testing and debugging more difficult, because the event handlers with side-effects logic are executed immediately after the event is raised.</span></span> <span data-ttu-id="b0033-200">Při testování a ladění, chcete zaměřit na a jen to, co se děje v aktuální agregační třídy; nechcete být náhle přesměrováni na jiné obslužné rutiny událostí pro vedlejší účinky související s jinými agregacemi nebo aplikační logikou.</span><span class="sxs-lookup"><span data-stu-id="b0033-200">When you are testing and debugging, you want to focus on and just what is happening in the current aggregate classes; you do not want to suddenly be redirected to other event handlers for side effects related to other aggregates or application logic.</span></span> <span data-ttu-id="b0033-201">To je důvod, proč se vyvinuly jiné přístupy, jak je vysvětleno v další části.</span><span class="sxs-lookup"><span data-stu-id="b0033-201">This is why other approaches have evolved, as explained in the next section.</span></span>

#### <a name="the-deferred-approach-to-raise-and-dispatch-events"></a><span data-ttu-id="b0033-202">Odložený přístup ke zvýšení a odeslání událostí</span><span class="sxs-lookup"><span data-stu-id="b0033-202">The deferred approach to raise and dispatch events</span></span>

<span data-ttu-id="b0033-203">Místo okamžitého odeslání do obslužné rutiny události domény je lepším přístupem přidání událostí domény do kolekce a následné odeslání těchto událostí domény *přímo před* nebo *bezprostředně* *po* potvrzení transakce (jako u SaveChanges v EF).</span><span class="sxs-lookup"><span data-stu-id="b0033-203">Instead of dispatching to a domain event handler immediately, a better approach is to add the domain events to a collection and then to dispatch those domain events *right before* or *right* *after* committing the transaction (as with SaveChanges in EF).</span></span> <span data-ttu-id="b0033-204">(Tento přístup byl popsán Jimmy Bogard v tomto [příspěvku lepší doména události vzor](https://lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern/).)</span><span class="sxs-lookup"><span data-stu-id="b0033-204">(This approach was described by Jimmy Bogard in this post [A better domain events pattern](https://lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern/).)</span></span>

<span data-ttu-id="b0033-205">Rozhodování o tom, zda odešlete události domény přímo před nebo přímo po potvrzení transakce je důležité, protože určuje, zda bude zahrnovat vedlejší účinky jako součást stejné transakce nebo v různých transakcích.</span><span class="sxs-lookup"><span data-stu-id="b0033-205">Deciding if you send the domain events right before or right after committing the transaction is important, since it determines whether you will include the side effects as part of the same transaction or in different transactions.</span></span> <span data-ttu-id="b0033-206">V druhém případě je třeba řešit konečnou konzistenci mezi více agregáty.</span><span class="sxs-lookup"><span data-stu-id="b0033-206">In the latter case, you need to deal with eventual consistency across multiple aggregates.</span></span> <span data-ttu-id="b0033-207">Toto téma je popsáno v další části.</span><span class="sxs-lookup"><span data-stu-id="b0033-207">This topic is discussed in the next section.</span></span>

<span data-ttu-id="b0033-208">Odložený přístup je to, co používá eShopOnContainers.</span><span class="sxs-lookup"><span data-stu-id="b0033-208">The deferred approach is what eShopOnContainers uses.</span></span> <span data-ttu-id="b0033-209">Nejprve přidáte události, ke kterých dochází ve vašich entitách, do kolekce nebo seznamu událostí na entitu.</span><span class="sxs-lookup"><span data-stu-id="b0033-209">First, you add the events happening in your entities into a collection or list of events per entity.</span></span> <span data-ttu-id="b0033-210">Tento seznam by měl být součástí objektu entity nebo ještě lépe součástí základní třídy entity, jak je znázorněno v následujícím příkladu základní třídy Entity:</span><span class="sxs-lookup"><span data-stu-id="b0033-210">That list should be part of the entity object, or even better, part of your base entity class, as shown in the following example of the Entity base class:</span></span>

```csharp
public abstract class Entity
{
     //...
     private List<INotification> _domainEvents;
     public List<INotification> DomainEvents => _domainEvents;

     public void AddDomainEvent(INotification eventItem)
     {
         _domainEvents = _domainEvents ?? new List<INotification>();
         _domainEvents.Add(eventItem);
     }

     public void RemoveDomainEvent(INotification eventItem)
     {
         _domainEvents?.Remove(eventItem);
     }
     //... Additional code
}
```

<span data-ttu-id="b0033-211">Pokud chcete vyvolat událost, stačí ji přidat do kolekce událostí z kódu v libovolné metodě entity agregační kořenové.</span><span class="sxs-lookup"><span data-stu-id="b0033-211">When you want to raise an event, you just add it to the event collection from code at any method of the aggregate-root entity.</span></span>

<span data-ttu-id="b0033-212">Následující kód, který je součástí [agregačního kořene objednávky v eShopOnContainers](https://github.com/dotnet-architecture/eShopOnContainers/blob/dev/src/Services/Ordering/Ordering.Domain/AggregatesModel/OrderAggregate/Order.cs), ukazuje příklad:</span><span class="sxs-lookup"><span data-stu-id="b0033-212">The following code, part of the [Order aggregate-root at eShopOnContainers](https://github.com/dotnet-architecture/eShopOnContainers/blob/dev/src/Services/Ordering/Ordering.Domain/AggregatesModel/OrderAggregate/Order.cs), shows an example:</span></span>

```csharp
var orderStartedDomainEvent = new OrderStartedDomainEvent(this, //Order object
                                                          cardTypeId, cardNumber,
                                                          cardSecurityNumber,
                                                          cardHolderName,
                                                          cardExpiration);
this.AddDomainEvent(orderStartedDomainEvent);
```

<span data-ttu-id="b0033-213">Všimněte si, že jediná věc, kterou metoda AddDomainEvent dělá, je přidání události do seznamu.</span><span class="sxs-lookup"><span data-stu-id="b0033-213">Notice that the only thing that the AddDomainEvent method is doing is adding an event to the list.</span></span> <span data-ttu-id="b0033-214">Zatím není odeslána žádná událost a dosud není vyvolána žádná obslužná rutina události.</span><span class="sxs-lookup"><span data-stu-id="b0033-214">No event is dispatched yet, and no event handler is invoked yet.</span></span>

<span data-ttu-id="b0033-215">Ve skutečnosti chcete odeslat události později, když potvrdíte transakci do databáze.</span><span class="sxs-lookup"><span data-stu-id="b0033-215">You actually want to dispatch the events later on, when you commit the transaction to the database.</span></span> <span data-ttu-id="b0033-216">Pokud používáte core entity framework, znamená to v SaveChanges metoda EF DbContext, jako v následujícím kódu:</span><span class="sxs-lookup"><span data-stu-id="b0033-216">If you are using Entity Framework Core, that means in the SaveChanges method of your EF DbContext, as in the following code:</span></span>

```csharp
// EF Core DbContext
public class OrderingContext : DbContext, IUnitOfWork
{
    // ...
    public async Task<bool> SaveEntitiesAsync(CancellationToken cancellationToken = default(CancellationToken))
    {
        // Dispatch Domain Events collection.
        // Choices:
        // A) Right BEFORE committing data (EF SaveChanges) into the DB. This makes
        // a single transaction including side effects from the domain event
        // handlers that are using the same DbContext with Scope lifetime
        // B) Right AFTER committing data (EF SaveChanges) into the DB. This makes
        // multiple transactions. You will need to handle eventual consistency and
        // compensatory actions in case of failures.
        await _mediator.DispatchDomainEventsAsync(this);

        // After this line runs, all the changes (from the Command Handler and Domain
        // event handlers) performed through the DbContext will be committed
        var result = await base.SaveChangesAsync();
    }
}
```

<span data-ttu-id="b0033-217">Pomocí tohoto kódu odešlete události entity do příslušných obslužných rutin událostí.</span><span class="sxs-lookup"><span data-stu-id="b0033-217">With this code, you dispatch the entity events to their respective event handlers.</span></span>

<span data-ttu-id="b0033-218">Celkovývýsledek je, že jste oddělili zvýšení události domény (jednoduché přidání do seznamu v paměti) od odeslání do obslužné rutiny události.</span><span class="sxs-lookup"><span data-stu-id="b0033-218">The overall result is that you have decoupled the raising of a domain event (a simple add into a list in memory) from dispatching it to an event handler.</span></span> <span data-ttu-id="b0033-219">Kromě toho v závislosti na tom, jaký druh dispečera používáte, můžete odeslat události synchronně nebo asynchronně.</span><span class="sxs-lookup"><span data-stu-id="b0033-219">In addition, depending on what kind of dispatcher you are using, you could dispatch the events synchronously or asynchronously.</span></span>

<span data-ttu-id="b0033-220">Uvědomte si, že transakční hranice přicházejí do významné hry zde.</span><span class="sxs-lookup"><span data-stu-id="b0033-220">Be aware that transactional boundaries come into significant play here.</span></span> <span data-ttu-id="b0033-221">Pokud vaše jednotka práce a transakce může span více než jeden agregace (jako při použití EF Core a relační databáze), to může fungovat dobře.</span><span class="sxs-lookup"><span data-stu-id="b0033-221">If your unit of work and transaction can span more than one aggregate (as when using EF Core and a relational database), this can work well.</span></span> <span data-ttu-id="b0033-222">Ale pokud transakce nemůže span agregace, například při použití databáze NoSQL, jako je Azure CosmosDB, budete muset implementovat další kroky k dosažení konzistence.</span><span class="sxs-lookup"><span data-stu-id="b0033-222">But if the transaction cannot span aggregates, such as when you are using a NoSQL database like Azure CosmosDB, you have to implement additional steps to achieve consistency.</span></span> <span data-ttu-id="b0033-223">To je další důvod, proč neznalost vytrvalosti není univerzální; závisí na úložném systému, který používáte.</span><span class="sxs-lookup"><span data-stu-id="b0033-223">This is another reason why persistence ignorance is not universal; it depends on the storage system you use.</span></span>

### <a name="single-transaction-across-aggregates-versus-eventual-consistency-across-aggregates"></a><span data-ttu-id="b0033-224">Jednotlivá transakce mezi agregáty versus konečná konzistence mezi agregáty</span><span class="sxs-lookup"><span data-stu-id="b0033-224">Single transaction across aggregates versus eventual consistency across aggregates</span></span>

<span data-ttu-id="b0033-225">Otázka, zda provést jednu transakci napříč agregáty versus spoléhat se na konečnou konzistenci mezi těmito agregáty, je kontroverzní.</span><span class="sxs-lookup"><span data-stu-id="b0033-225">The question of whether to perform a single transaction across aggregates versus relying on eventual consistency across those aggregates is a controversial one.</span></span> <span data-ttu-id="b0033-226">Mnoho Autorů DDD jako Eric Evans a Vaughn Vernon obhajovat pravidlo, že jedna transakce = jeden agregát, a proto argumentují pro případné konzistence napříč agregáty.</span><span class="sxs-lookup"><span data-stu-id="b0033-226">Many DDD authors like Eric Evans and Vaughn Vernon advocate the rule that one transaction = one aggregate and therefore argue for eventual consistency across aggregates.</span></span> <span data-ttu-id="b0033-227">Například, ve své knize *Domain-Driven Design*, Eric Evans říká toto:</span><span class="sxs-lookup"><span data-stu-id="b0033-227">For example, in his book *Domain-Driven Design*, Eric Evans says this:</span></span>

> <span data-ttu-id="b0033-228">Jakékoli pravidlo, které zahrnuje agregace, nebude očekáváno, že bude vždy aktuální.</span><span class="sxs-lookup"><span data-stu-id="b0033-228">Any rule that spans Aggregates will not be expected to be up-to-date at all times.</span></span> <span data-ttu-id="b0033-229">Prostřednictvím zpracování událostí, dávkového zpracování nebo jiných aktualizačních mechanismů lze v určitém čase vyřešit jiné závislosti.</span><span class="sxs-lookup"><span data-stu-id="b0033-229">Through event processing, batch processing, or other update mechanisms, other dependencies can be resolved within some specific time.</span></span> <span data-ttu-id="b0033-230">(strana 128)</span><span class="sxs-lookup"><span data-stu-id="b0033-230">(page 128)</span></span>

<span data-ttu-id="b0033-231">Vaughn Vernon říká následující v [efektivní agregační design. Část II: Tvorba agregáty pracovat společně](https://dddcommunity.org/wp-content/uploads/files/pdf_articles/Vernon_2011_2.pdf):</span><span class="sxs-lookup"><span data-stu-id="b0033-231">Vaughn Vernon says the following in [Effective Aggregate Design. Part II: Making Aggregates Work Together](https://dddcommunity.org/wp-content/uploads/files/pdf_articles/Vernon_2011_2.pdf):</span></span>

> <span data-ttu-id="b0033-232">Pokud tedy provedení příkazu na jedné agregované instanci vyžaduje, aby se \[na jednom nebo více agregacích prováděla další obchodní pravidla, použijte konečnou konzistenci ... \] Existuje praktický způsob, jak podpořit konečnou konzistenci v modelu DDD.</span><span class="sxs-lookup"><span data-stu-id="b0033-232">Thus, if executing a command on one aggregate instance requires that additional business rules execute on one or more aggregates, use eventual consistency \[...\] There is a practical way to support eventual consistency in a DDD model.</span></span> <span data-ttu-id="b0033-233">Agregační metoda publikuje událost domény, která je doručena v čase dojednoho nebo více asynchronních odběratelů.</span><span class="sxs-lookup"><span data-stu-id="b0033-233">An aggregate method publishes a domain event that is in time delivered to one or more asynchronous subscribers.</span></span>

<span data-ttu-id="b0033-234">Toto zdůvodnění je založeno na přijetí jemně odstupňovaných transakcí namísto transakcí zahrnujících mnoho agregací nebo entit.</span><span class="sxs-lookup"><span data-stu-id="b0033-234">This rationale is based on embracing fine-grained transactions instead of transactions spanning many aggregates or entities.</span></span> <span data-ttu-id="b0033-235">Myšlenka je, že v druhém případě počet uzamčení databáze bude značný v rozsáhlých aplikacích s vysokými potřebami škálovatelnosti.</span><span class="sxs-lookup"><span data-stu-id="b0033-235">The idea is that in the second case, the number of database locks will be substantial in large-scale applications with high scalability needs.</span></span> <span data-ttu-id="b0033-236">Přijetí skutečnost, že vysoce škálovatelné aplikace nemusí mít okamžitou transakční konzistenci mezi více agregace mi pomáhá s přijetím konceptu konečné konzistence.</span><span class="sxs-lookup"><span data-stu-id="b0033-236">Embracing the fact that highly scalable applications need not have instant transactional consistency between multiple aggregates helps with accepting the concept of eventual consistency.</span></span> <span data-ttu-id="b0033-237">Atomové změny často nejsou potřebné pro podnikání, a to je v každém případě odpovědnost odborníků domény říci, zda konkrétní operace potřebují atomické transakce, nebo ne.</span><span class="sxs-lookup"><span data-stu-id="b0033-237">Atomic changes are often not needed by the business, and it is in any case the responsibility of the domain experts to say whether particular operations need atomic transactions or not.</span></span> <span data-ttu-id="b0033-238">Pokud operace vždy potřebuje atomické transakce mezi více agregace, můžete se zeptat, zda agregace by měla být větší nebo nebyla správně navržena.</span><span class="sxs-lookup"><span data-stu-id="b0033-238">If an operation always needs an atomic transaction between multiple aggregates, you might ask whether your aggregate should be larger or was not correctly designed.</span></span>

<span data-ttu-id="b0033-239">Nicméně, ostatní vývojáři a architekti jako Jimmy Bogard jsou v pořádku s kondrování jedné transakce přes několik agregátů-ale pouze v případě, že tyto další agregáty souvisejí s vedlejšími účinky pro stejný původní příkaz.</span><span class="sxs-lookup"><span data-stu-id="b0033-239">However, other developers and architects like Jimmy Bogard are okay with spanning a single transaction across several aggregates—but only when those additional aggregates are related to side effects for the same original command.</span></span> <span data-ttu-id="b0033-240">Například, v [lepší doména události vzor](https://lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern/), Bogard říká toto:</span><span class="sxs-lookup"><span data-stu-id="b0033-240">For instance, in [A better domain events pattern](https://lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern/), Bogard says this:</span></span>

> <span data-ttu-id="b0033-241">Obvykle chci, aby vedlejší účinky události domény nastat v rámci stejné logické transakce, ale \[ne nutně ve stejném rozsahu zvyšování domény události ... \] Těsně předtím, než potvrdíme naši transakci, odešleme naše události jejich příslušným obslužným rutinám.</span><span class="sxs-lookup"><span data-stu-id="b0033-241">Typically, I want the side effects of a domain event to occur within the same logical transaction, but not necessarily in the same scope of raising the domain event \[...\] Just before we commit our transaction, we dispatch our events to their respective handlers.</span></span>

<span data-ttu-id="b0033-242">Pokud odešlete události domény přímo *před* potvrzením původní transakce, je to proto, že chcete vedlejší účinky těchto událostí, které mají být zahrnuty do stejné transakce.</span><span class="sxs-lookup"><span data-stu-id="b0033-242">If you dispatch the domain events right *before* committing the original transaction, it is because you want the side effects of those events to be included in the same transaction.</span></span> <span data-ttu-id="b0033-243">Například pokud EF DbContext SaveChanges metoda selže, transakce vrátí zpět všechny změny, včetně výsledku všech operací vedlejších účinků implementovaných obslužné rutiny události související domény.</span><span class="sxs-lookup"><span data-stu-id="b0033-243">For example, if the EF DbContext SaveChanges method fails, the transaction will roll back all changes, including the result of any side effect operations implemented by the related domain event handlers.</span></span> <span data-ttu-id="b0033-244">Důvodem je, že dbContext životnost oboru je ve výchozím nastavení definován jako "s vymezeným oborem."</span><span class="sxs-lookup"><span data-stu-id="b0033-244">This is because the DbContext life scope is by default defined as "scoped."</span></span> <span data-ttu-id="b0033-245">Proto DbContext objekt je sdílena přes více objektů úložiště jsou vytvářeny v rámci stejného oboru nebo objektgrafu.</span><span class="sxs-lookup"><span data-stu-id="b0033-245">Therefore, the DbContext object is shared across multiple repository objects being instantiated within the same scope or object graph.</span></span> <span data-ttu-id="b0033-246">To se shoduje s rozsahem HttpRequest při vývoji webových rozhraní API nebo aplikací MVC.</span><span class="sxs-lookup"><span data-stu-id="b0033-246">This coincides with the HttpRequest scope when developing Web API or MVC apps.</span></span>

<span data-ttu-id="b0033-247">Ve skutečnosti oba přístupy (jedna atomová transakce a konečná konzistence) může být správné.</span><span class="sxs-lookup"><span data-stu-id="b0033-247">Actually, both approaches (single atomic transaction and eventual consistency) can be right.</span></span> <span data-ttu-id="b0033-248">To opravdu záleží na vaší oblasti nebo obchodní požadavky a to, co doména odborníci vám.</span><span class="sxs-lookup"><span data-stu-id="b0033-248">It really depends on your domain or business requirements and what the domain experts tell you.</span></span> <span data-ttu-id="b0033-249">Závisí také na tom, jak škálovatelné potřebujete službu být (podrobnější transakce mají menší dopad s ohledem na uzamčení databáze).</span><span class="sxs-lookup"><span data-stu-id="b0033-249">It also depends on how scalable you need the service to be (more granular transactions have less impact with regard to database locks).</span></span> <span data-ttu-id="b0033-250">A záleží na tom, kolik investic jste ochotni provést ve vašem kódu, protože konečná konzistence vyžaduje složitější kód, aby bylo možné zjistit možné nesrovnalosti mezi agregáty a potřebu implementovat kompenzační akce.</span><span class="sxs-lookup"><span data-stu-id="b0033-250">And it depends on how much investment you are willing to make in your code, since eventual consistency requires more complex code in order to detect possible inconsistencies across aggregates and the need to implement compensatory actions.</span></span> <span data-ttu-id="b0033-251">Zvažte, že pokud potvrdíte změny původní agregace a po odeslání události, pokud je problém a obslužné rutiny událostí nelze potvrdit jejich vedlejší účinky, budete mít nekonzistence mezi agregace.</span><span class="sxs-lookup"><span data-stu-id="b0033-251">Consider that if you commit changes to the original aggregate and afterwards, when the events are being dispatched, if there is an issue and the event handlers cannot commit their side effects, you will have inconsistencies between aggregates.</span></span>

<span data-ttu-id="b0033-252">Způsob, jak povolit kompenzační akce by bylo ukládat události domény v dalšídatabázové tabulky, takže mohou být součástí původní transakce.</span><span class="sxs-lookup"><span data-stu-id="b0033-252">A way to allow compensatory actions would be to store the domain events in additional database tables so they can be part of the original transaction.</span></span> <span data-ttu-id="b0033-253">Poté můžete mít dávkový proces, který zjistí nekonzistence a spustí kompenzační akce porovnáním seznamu událostí s aktuálním stavem agregací.</span><span class="sxs-lookup"><span data-stu-id="b0033-253">Afterwards, you could have a batch process that detects inconsistencies and runs compensatory actions by comparing the list of events with the current state of the aggregates.</span></span> <span data-ttu-id="b0033-254">Kompenzační akce jsou součástí komplexního tématu, které bude vyžadovat hloubkovou analýzu z vaší strany, což zahrnuje diskusi s odborníky na obchodní uživatele a doménu.</span><span class="sxs-lookup"><span data-stu-id="b0033-254">The compensatory actions are part of a complex topic that will require deep analysis from your side, which includes discussing it with the business user and domain experts.</span></span>

<span data-ttu-id="b0033-255">V každém případě si můžete vybrat přístup, který potřebujete.</span><span class="sxs-lookup"><span data-stu-id="b0033-255">In any case, you can choose the approach you need.</span></span> <span data-ttu-id="b0033-256">Ale počáteční odložené přístup – vyvolání události před potvrzením, takže použít jednu transakci – je nejjednodušší přístup při použití EF Core a relační databáze.</span><span class="sxs-lookup"><span data-stu-id="b0033-256">But the initial deferred approach—raising the events before committing, so you use a single transaction—is the simplest approach when using EF Core and a relational database.</span></span> <span data-ttu-id="b0033-257">Je jednodušší implementovat a platit v mnoha obchodních případech.</span><span class="sxs-lookup"><span data-stu-id="b0033-257">It is easier to implement and valid in many business cases.</span></span> <span data-ttu-id="b0033-258">Je to také přístup používaný v objednávání mikroslužby v eShopOnContainers.</span><span class="sxs-lookup"><span data-stu-id="b0033-258">It is also the approach used in the ordering microservice in eShopOnContainers.</span></span>

<span data-ttu-id="b0033-259">Ale jak se skutečně odeslat tyto události na jejich příslušné obslužné rutiny událostí?</span><span class="sxs-lookup"><span data-stu-id="b0033-259">But how do you actually dispatch those events to their respective event handlers?</span></span> <span data-ttu-id="b0033-260">Jaký je `_mediator` objekt, který vidíte v předchozím příkladu?</span><span class="sxs-lookup"><span data-stu-id="b0033-260">What's the `_mediator` object you see in the previous example?</span></span> <span data-ttu-id="b0033-261">Má co do činění s techniky a artefakty, které používáte k mapování mezi událostmi a jejich obslužné rutiny událostí.</span><span class="sxs-lookup"><span data-stu-id="b0033-261">It has to do with the techniques and artifacts you use to map between events and their event handlers.</span></span>

### <a name="the-domain-event-dispatcher-mapping-from-events-to-event-handlers"></a><span data-ttu-id="b0033-262">Dispečer událostí domény: mapování z událostí na obslužné rutiny událostí</span><span class="sxs-lookup"><span data-stu-id="b0033-262">The domain event dispatcher: mapping from events to event handlers</span></span>

<span data-ttu-id="b0033-263">Jakmile budete moci odeslat nebo publikovat události, budete potřebovat nějaký artefakt, který bude publikovat událost, takže každý související obslužná rutina může získat a zpracovat vedlejší účinky na základě této události.</span><span class="sxs-lookup"><span data-stu-id="b0033-263">Once you're able to dispatch or publish the events, you need some kind of artifact that will publish the event, so that every related handler can get it and process side effects based on that event.</span></span>

<span data-ttu-id="b0033-264">Jedním z přístupů je skutečný systém zasílání zpráv nebo dokonce sběrnice událostí, případně na základě sběrnice na rozdíl od událostí v paměti.</span><span class="sxs-lookup"><span data-stu-id="b0033-264">One approach is a real messaging system or even an event bus, possibly based on a service bus as opposed to in-memory events.</span></span> <span data-ttu-id="b0033-265">Však pro první případ skutečné zasílání zpráv by bylo přehnané pro zpracování událostí domény, protože stačí zpracovat tyto události v rámci stejného procesu (to znamená, že ve stejné doméně a aplikační vrstvy).</span><span class="sxs-lookup"><span data-stu-id="b0033-265">However, for the first case, real messaging would be overkill for processing domain events, since you just need to process those events within the same process (that is, within the same domain and application layer).</span></span>

<span data-ttu-id="b0033-266">Dalším způsobem, jak mapovat události na více obslužných rutin událostí, je použití registrace typů v kontejneru IoC, takže můžete dynamicky odvodit, kam mají být události odeslány.</span><span class="sxs-lookup"><span data-stu-id="b0033-266">Another way to map events to multiple event handlers is by using types registration in an IoC container so you can dynamically infer where to dispatch the events.</span></span> <span data-ttu-id="b0033-267">Jinými slovy, musíte vědět, jaké obslužné rutiny událostí potřebují získat konkrétní událost.</span><span class="sxs-lookup"><span data-stu-id="b0033-267">In other words, you need to know what event handlers need to get a specific event.</span></span> <span data-ttu-id="b0033-268">Obrázek 7–16 ukazuje zjednodušený přístup k tomuto přístupu.</span><span class="sxs-lookup"><span data-stu-id="b0033-268">Figure 7-16 shows a simplified approach for this approach.</span></span>

![Diagram znázorňující dispečera událostí domény odesílající události příslušným obslužným rutinám.](./media/domain-events-design-implementation/domain-event-dispatcher.png)

<span data-ttu-id="b0033-270">**Obrázek 7-16**.</span><span class="sxs-lookup"><span data-stu-id="b0033-270">**Figure 7-16**.</span></span> <span data-ttu-id="b0033-271">Dispečer událostí domény používající ioC</span><span class="sxs-lookup"><span data-stu-id="b0033-271">Domain event dispatcher using IoC</span></span>

<span data-ttu-id="b0033-272">Můžete vytvořit všechny instalatérské a artefakty k provedení tohoto přístupu sami.</span><span class="sxs-lookup"><span data-stu-id="b0033-272">You can build all the plumbing and artifacts to implement that approach by yourself.</span></span> <span data-ttu-id="b0033-273">Můžete však také použít dostupné knihovny, jako [je MediatR,](https://github.com/jbogard/MediatR) který používá kontejner IoC pod kryty.</span><span class="sxs-lookup"><span data-stu-id="b0033-273">However, you can also use available libraries like [MediatR](https://github.com/jbogard/MediatR) that uses your IoC container under the covers.</span></span> <span data-ttu-id="b0033-274">Proto můžete přímo použít předdefinovaná rozhraní a metody publikování a odeslání objektu mediátora.</span><span class="sxs-lookup"><span data-stu-id="b0033-274">You can therefore directly use the predefined interfaces and the mediator object’s publish/dispatch methods.</span></span>

<span data-ttu-id="b0033-275">V kódu musíte nejprve zaregistrovat typy obslužné rutiny událostí v kontejneru IoC, jak je znázorněno v následujícím příkladu na [eShopOnContainers Objednávání mikroslužby](https://github.com/dotnet-architecture/eShopOnContainers/blob/dev/src/Services/Ordering/Ordering.API/Infrastructure/AutofacModules/MediatorModule.cs):</span><span class="sxs-lookup"><span data-stu-id="b0033-275">In code, you first need to register the event handler types in your IoC container, as shown in the following example at [eShopOnContainers Ordering microservice](https://github.com/dotnet-architecture/eShopOnContainers/blob/dev/src/Services/Ordering/Ordering.API/Infrastructure/AutofacModules/MediatorModule.cs):</span></span>

```csharp
public class MediatorModule : Autofac.Module
{
    protected override void Load(ContainerBuilder builder)
    {
        // Other registrations ...
        // Register the DomainEventHandler classes (they implement IAsyncNotificationHandler<>)
        // in assembly holding the Domain Events
        builder.RegisterAssemblyTypes(typeof(ValidateOrAddBuyerAggregateWhenOrderStartedDomainEventHandler)
                                       .GetTypeInfo().Assembly)
                                         .AsClosedTypesOf(typeof(IAsyncNotificationHandler<>));
        // Other registrations ...
    }
}
```

<span data-ttu-id="b0033-276">Kód nejprve identifikuje sestavení, které obsahuje obslužné rutiny události domény vyhledáním sestavení, které obsahuje některý z obslužných rutin (pomocí typeof(ValidateOrAddBuyerAggregateWhenXxxx), ale můžete zvolit jakoukoli jinou obslužnou rutinu události k vyhledání sestavení).</span><span class="sxs-lookup"><span data-stu-id="b0033-276">The code first identifies the assembly that contains the domain event handlers by locating the assembly that holds any of the handlers (using typeof(ValidateOrAddBuyerAggregateWhenXxxx), but you could have chosen any other event handler to locate the assembly).</span></span> <span data-ttu-id="b0033-277">Vzhledem k tomu, že všechny obslužné rutiny událostí implementují rozhraní IAsyncNotificationHandler, kód pak pouze vyhledá tyto typy a zaregistruje všechny obslužné rutiny událostí.</span><span class="sxs-lookup"><span data-stu-id="b0033-277">Since all the event handlers implement the IAsyncNotificationHandler interface, the code then just searches for those types and registers all the event handlers.</span></span>

### <a name="how-to-subscribe-to-domain-events"></a><span data-ttu-id="b0033-278">Jak se přihlásit k odběru událostí domény</span><span class="sxs-lookup"><span data-stu-id="b0033-278">How to subscribe to domain events</span></span>

<span data-ttu-id="b0033-279">Při použití MediatR musí každá obslužná rutina události použít typ události, který je k dispozici na obecném parametru rozhraní INotificationHandler, jak je vidět v následujícím kódu:</span><span class="sxs-lookup"><span data-stu-id="b0033-279">When you use MediatR, each event handler must use an event type that is provided on the generic parameter of the INotificationHandler interface, as you can see in the following code:</span></span>

```csharp
public class ValidateOrAddBuyerAggregateWhenOrderStartedDomainEventHandler
  : IAsyncNotificationHandler<OrderStartedDomainEvent>
```

<span data-ttu-id="b0033-280">Na základě vztahu mezi obslužnou rutinou události a obslužnou rutinou události, kterou lze považovat za odběr, může artefakt MediatR zjistit všechny obslužné rutiny událostí pro každou událost a aktivovat každou z těchto obslužných rutin událostí.</span><span class="sxs-lookup"><span data-stu-id="b0033-280">Based on the relationship between event and event handler, which can be considered the subscription, the MediatR artifact can discover all the event handlers for each event and trigger each one of those event handlers.</span></span>

### <a name="how-to-handle-domain-events"></a><span data-ttu-id="b0033-281">Jak zpracovat události domény</span><span class="sxs-lookup"><span data-stu-id="b0033-281">How to handle domain events</span></span>

<span data-ttu-id="b0033-282">Nakonec obslužná rutina události obvykle implementuje kód aplikační vrstvy, který používá úložiště infrastruktury k získání požadovaných dalších agregací a ke spuštění logiky domény s vedlejším účinkem.</span><span class="sxs-lookup"><span data-stu-id="b0033-282">Finally, the event handler usually implements application layer code that uses infrastructure repositories to obtain the required additional aggregates and to execute side-effect domain logic.</span></span> <span data-ttu-id="b0033-283">Následující [kód obslužné rutiny události domény na eShopOnContainers](https://github.com/dotnet-architecture/eShopOnContainers/blob/dev/src/Services/Ordering/Ordering.API/Application/DomainEventHandlers/OrderStartedEvent/ValidateOrAddBuyerAggregateWhenOrderStartedDomainEventHandler.cs)ukazuje příklad implementace.</span><span class="sxs-lookup"><span data-stu-id="b0033-283">The following [domain event handler code at eShopOnContainers](https://github.com/dotnet-architecture/eShopOnContainers/blob/dev/src/Services/Ordering/Ordering.API/Application/DomainEventHandlers/OrderStartedEvent/ValidateOrAddBuyerAggregateWhenOrderStartedDomainEventHandler.cs), shows an implementation example.</span></span>

```csharp
public class ValidateOrAddBuyerAggregateWhenOrderStartedDomainEventHandler
                   : INotificationHandler<OrderStartedDomainEvent>
{
    private readonly ILoggerFactory _logger;
    private readonly IBuyerRepository<Buyer> _buyerRepository;
    private readonly IIdentityService _identityService;

    public ValidateOrAddBuyerAggregateWhenOrderStartedDomainEventHandler(
        ILoggerFactory logger,
        IBuyerRepository<Buyer> buyerRepository,
        IIdentityService identityService)
    {
        // ...Parameter validations...
    }

    public async Task Handle(OrderStartedDomainEvent orderStartedEvent)
    {
        var cardTypeId = (orderStartedEvent.CardTypeId != 0) ? orderStartedEvent.CardTypeId : 1;
        var userGuid = _identityService.GetUserIdentity();
        var buyer = await _buyerRepository.FindAsync(userGuid);
        bool buyerOriginallyExisted = (buyer == null) ? false : true;

        if (!buyerOriginallyExisted)
        {
            buyer = new Buyer(userGuid);
        }

        buyer.VerifyOrAddPaymentMethod(cardTypeId,
                                       $"Payment Method on {DateTime.UtcNow}",
                                       orderStartedEvent.CardNumber,
                                       orderStartedEvent.CardSecurityNumber,
                                       orderStartedEvent.CardHolderName,
                                       orderStartedEvent.CardExpiration,
                                       orderStartedEvent.Order.Id);

        var buyerUpdated = buyerOriginallyExisted ? _buyerRepository.Update(buyer)
                                                                      : _buyerRepository.Add(buyer);

        await _buyerRepository.UnitOfWork
                .SaveEntitiesAsync();

        // Logging code using buyerUpdated info, etc.
    }
}
```

<span data-ttu-id="b0033-284">Předchozí kód obslužné rutiny události domény je považován za kód aplikační vrstvy, protože používá úložiště infrastruktury, jak je vysvětleno v další části vrstvy trvalost v infrastruktuře.</span><span class="sxs-lookup"><span data-stu-id="b0033-284">The previous domain event handler code is considered application layer code because it uses infrastructure repositories, as explained in the next section on the infrastructure-persistence layer.</span></span> <span data-ttu-id="b0033-285">Obslužné rutiny událostí mohou také používat jiné součásti infrastruktury.</span><span class="sxs-lookup"><span data-stu-id="b0033-285">Event handlers could also use other infrastructure components.</span></span>

#### <a name="domain-events-can-generate-integration-events-to-be-published-outside-of-the-microservice-boundaries"></a><span data-ttu-id="b0033-286">Události domény mohou generovat události integrace, které mají být publikovány mimo hranice mikroslužeb.</span><span class="sxs-lookup"><span data-stu-id="b0033-286">Domain events can generate integration events to be published outside of the microservice boundaries</span></span>

<span data-ttu-id="b0033-287">Nakonec je důležité zmínit, že někdy můžete chtít šířit události napříč více mikroslužeb.</span><span class="sxs-lookup"><span data-stu-id="b0033-287">Finally, it's important to mention that you might sometimes want to propagate events across multiple microservices.</span></span> <span data-ttu-id="b0033-288">Toto šíření je událost integrace a může být publikována prostřednictvím sběrnice událostí z jakékoli obslužné rutiny události konkrétní domény.</span><span class="sxs-lookup"><span data-stu-id="b0033-288">That propagation is an integration event, and it could be published through an event bus from any specific domain event handler.</span></span>

## <a name="conclusions-on-domain-events"></a><span data-ttu-id="b0033-289">Závěry o událostech domény</span><span class="sxs-lookup"><span data-stu-id="b0033-289">Conclusions on domain events</span></span>

<span data-ttu-id="b0033-290">Jak je uvedeno, použijte události domény explicitně implementovat vedlejší účinky změn v rámci domény.</span><span class="sxs-lookup"><span data-stu-id="b0033-290">As stated, use domain events to explicitly implement side effects of changes within your domain.</span></span> <span data-ttu-id="b0033-291">Chcete-li použít terminologii DDD, použijte události domény explicitně implementovat vedlejší účinky v rámci jednoho nebo více agregací.</span><span class="sxs-lookup"><span data-stu-id="b0033-291">To use DDD terminology, use domain events to explicitly implement side effects across one or multiple aggregates.</span></span> <span data-ttu-id="b0033-292">Navíc a pro lepší škálovatelnost a menší dopad na uzamčení databáze, použijte konečnou konzistenci mezi agregacemi v rámci stejné domény.</span><span class="sxs-lookup"><span data-stu-id="b0033-292">Additionally, and for better scalability and less impact on database locks, use eventual consistency between aggregates within the same domain.</span></span>

<span data-ttu-id="b0033-293">Referenční aplikace používá [MediatR](https://github.com/jbogard/MediatR) k šíření událostí domény synchronně napříč agregacemi v rámci jedné transakce.</span><span class="sxs-lookup"><span data-stu-id="b0033-293">The reference app uses [MediatR](https://github.com/jbogard/MediatR) to propagate domain events synchronously across aggregates, within a single transaction.</span></span> <span data-ttu-id="b0033-294">Můžete však také použít některé implementace AMQP jako [RabbitMQ](https://www.rabbitmq.com/) nebo [Azure Service Bus](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-messaging-overview) k šíření událostí domény asynchronně pomocí konečné konzistence, ale jak je uvedeno výše, musíte zvážit potřebu kompenzačníakce v případě selhání.</span><span class="sxs-lookup"><span data-stu-id="b0033-294">However, you could also use some AMQP implementation like [RabbitMQ](https://www.rabbitmq.com/) or [Azure Service Bus](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-messaging-overview) to propagate domain events asynchronously, using eventual consistency but, as mentioned above, you have to consider the need for compensatory actions in case of failures.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="b0033-295">Další zdroje</span><span class="sxs-lookup"><span data-stu-id="b0033-295">Additional resources</span></span>

- <span data-ttu-id="b0033-296">**Greg Young. Co je událost domény?**</span><span class="sxs-lookup"><span data-stu-id="b0033-296">**Greg Young. What is a Domain Event?**</span></span> \
  <https://cqrs.files.wordpress.com/2010/11/cqrs_documents.pdf#page=25>

- <span data-ttu-id="b0033-297">**Jan Stenberg. Události domény a konečná konzistence** </span><span class="sxs-lookup"><span data-stu-id="b0033-297">**Jan Stenberg. Domain Events and Eventual Consistency** </span></span>\
  <https://www.infoq.com/news/2015/09/domain-events-consistency>

- <span data-ttu-id="b0033-298">**Jimmyho Bogarda. Lepší vzor událostí domény** </span><span class="sxs-lookup"><span data-stu-id="b0033-298">**Jimmy Bogard. A better domain events pattern** </span></span>\
  <https://lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern/>

- <span data-ttu-id="b0033-299">**Vaughn Vernon, to je můj zástupce. Efektivní agregační design část II: Tvorba agregáty spolupracovat** </span><span class="sxs-lookup"><span data-stu-id="b0033-299">**Vaughn Vernon. Effective Aggregate Design Part II: Making Aggregates Work Together** </span></span>\
  [https://dddcommunity.org/wp-content/uploads/files/pdf\_articles/Vernon\_2011\_2.pdf](https://dddcommunity.org/wp-content/uploads/files/pdf_articles/Vernon_2011_2.pdf)

- <span data-ttu-id="b0033-300">**Jimmyho Bogarda. Posílení vaší domény: Domain Events** </span><span class="sxs-lookup"><span data-stu-id="b0033-300">**Jimmy Bogard. Strengthening your domain: Domain Events** </span></span>\
  <https://lostechies.com/jimmybogard/2010/04/08/strengthening-your-domain-domain-events/>

- <span data-ttu-id="b0033-301">**Tonytruong. Příklad vzoru událostí domény** </span><span class="sxs-lookup"><span data-stu-id="b0033-301">**Tony Truong. Domain Events Pattern Example** </span></span>\
  <https://www.tonytruong.net/domain-events-pattern-example/>

- <span data-ttu-id="b0033-302">**Udi Dahan. Jak vytvořit plně zapouzdřené modely domény** </span><span class="sxs-lookup"><span data-stu-id="b0033-302">**Udi Dahan. How to create fully encapsulated Domain Models** </span></span>\
  <http://udidahan.com/2008/02/29/how-to-create-fully-encapsulated-domain-models/>

- <span data-ttu-id="b0033-303">**Udi Dahan. Události domény – take 2** </span><span class="sxs-lookup"><span data-stu-id="b0033-303">**Udi Dahan. Domain Events – Take 2** </span></span>\
  <http://udidahan.com/2008/08/25/domain-events-take-2/>

- <span data-ttu-id="b0033-304">**Udi Dahan. Události domény – spása** </span><span class="sxs-lookup"><span data-stu-id="b0033-304">**Udi Dahan. Domain Events – Salvation** </span></span>\
  <http://udidahan.com/2009/06/14/domain-events-salvation/>

- <span data-ttu-id="b0033-305">**Jan Kronquist. Nepublikujte domain události, vraťte je!**</span><span class="sxs-lookup"><span data-stu-id="b0033-305">**Jan Kronquist. Don't publish Domain Events, return them!**</span></span> \
  <https://blog.jayway.com/2013/06/20/dont-publish-domain-events-return-them/>

- <span data-ttu-id="b0033-306">**Cesar de la Torre. Události domény vs. Události integrace v architekturách DDD a mikroslužeb** </span><span class="sxs-lookup"><span data-stu-id="b0033-306">**Cesar de la Torre. Domain Events vs. Integration Events in DDD and microservices architectures** </span></span>\
  <https://devblogs.microsoft.com/cesardelatorre/domain-events-vs-integration-events-in-domain-driven-design-and-microservices-architectures/>

>[!div class="step-by-step"]
><span data-ttu-id="b0033-307">[Předchozí](client-side-validation.md)
>[další](infrastructure-persistence-layer-design.md)</span><span class="sxs-lookup"><span data-stu-id="b0033-307">[Previous](client-side-validation.md)
[Next](infrastructure-persistence-layer-design.md)</span></span>
