---
title: Strategie pro zpracování částečného selhání
description: Seznamte se s několika strategiemi pro řádné zpracování částečných chyb.
ms.date: 10/16/2018
ms.openlocfilehash: abf87df5afed02b4d794a1307a0ed943cafb4db3
ms.sourcegitcommit: e3cbf26d67f7e9286c7108a2752804050762d02d
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 04/09/2020
ms.locfileid: "80988801"
---
# <a name="strategies-to-handle-partial-failure"></a><span data-ttu-id="3daa6-103">Strategie pro zpracování částečného selhání</span><span class="sxs-lookup"><span data-stu-id="3daa6-103">Strategies to handle partial failure</span></span>

<span data-ttu-id="3daa6-104">Strategie pro řešení částečných selhání zahrnují následující.</span><span class="sxs-lookup"><span data-stu-id="3daa6-104">Strategies for dealing with partial failures include the following.</span></span>

<span data-ttu-id="3daa6-105">**Používejte asynchronní komunikaci (například komunikaci založenou na zprávě) mezi interními mikroslužbami**.</span><span class="sxs-lookup"><span data-stu-id="3daa6-105">**Use asynchronous communication (for example, message-based communication) across internal microservices**.</span></span> <span data-ttu-id="3daa6-106">Je velmi vhodné nevytvářet dlouhé řetězce synchronní volání HTTP napříč interní mikroslužeb, protože tento nesprávný návrh se nakonec stane hlavní příčinou výpadků chyb.</span><span class="sxs-lookup"><span data-stu-id="3daa6-106">It's highly advisable not to create long chains of synchronous HTTP calls across the internal microservices because that incorrect design will eventually become the main cause of bad outages.</span></span> <span data-ttu-id="3daa6-107">Naopak, s výjimkou front-endové komunikace mezi klientskými aplikacemi a první úrovní mikroslužeb nebo jemně odstupňovaných bran rozhraní API se doporučuje používat pouze asynchronní (na základě zpráv) komunikaci po počátečním cyklu požadavku a odpovědi napříč interními mikroslužbami.</span><span class="sxs-lookup"><span data-stu-id="3daa6-107">On the contrary, except for the front-end communications between the client applications and the first level of microservices or fine-grained API Gateways, it's recommended to use only asynchronous (message-based) communication once past the initial request/response cycle, across the internal microservices.</span></span> <span data-ttu-id="3daa6-108">Konečná konzistence a architektury řízené událostmi pomohou minimalizovat dominové efekty.</span><span class="sxs-lookup"><span data-stu-id="3daa6-108">Eventual consistency and event-driven architectures will help to minimize ripple effects.</span></span> <span data-ttu-id="3daa6-109">Tyto přístupy vynucují vyšší úroveň autonomie mikroslužeb a proto zabraňují problému, který je zde uveden.</span><span class="sxs-lookup"><span data-stu-id="3daa6-109">These approaches enforce a higher level of microservice autonomy and therefore prevent against the problem noted here.</span></span>

<span data-ttu-id="3daa6-110">**Použijte opakované pokusy s exponenciálním zpětným vypnutím**.</span><span class="sxs-lookup"><span data-stu-id="3daa6-110">**Use retries with exponential backoff**.</span></span> <span data-ttu-id="3daa6-111">Tato technika pomáhá vyhnout se krátkým a přerušovaným chybám provedením opakovaných pokusů o volání určitý počet opakování v případě, že služba nebyla k dispozici pouze krátkou dobu.</span><span class="sxs-lookup"><span data-stu-id="3daa6-111">This technique helps to avoid short and intermittent failures by performing call retries a certain number of times, in case the service was not available only for a short time.</span></span> <span data-ttu-id="3daa6-112">K tomu může dojít z důvodu občasné problémy se sítí nebo při mikroslužeb nebo kontejner je přesunuta do jiného uzlu v clusteru.</span><span class="sxs-lookup"><span data-stu-id="3daa6-112">This might occur due to intermittent network issues or when a microservice/container is moved to a different node in a cluster.</span></span> <span data-ttu-id="3daa6-113">Pokud však tyto opakování nejsou správně navrženy s jističi, může zhoršit dominové efekty, což nakonec dokonce způsobí [odmítnutí služby (DoS)](https://en.wikipedia.org/wiki/Denial-of-service_attack).</span><span class="sxs-lookup"><span data-stu-id="3daa6-113">However, if these retries are not designed properly with circuit breakers, it can aggravate the ripple effects, ultimately even causing a [Denial of Service (DoS)](https://en.wikipedia.org/wiki/Denial-of-service_attack).</span></span>

<span data-ttu-id="3daa6-114">**Obejít časové očasové časové opony sítě**.</span><span class="sxs-lookup"><span data-stu-id="3daa6-114">**Work around network timeouts**.</span></span> <span data-ttu-id="3daa6-115">Obecně by klienti měli být navrženi tak, aby neblokovali neomezeně dlouho a vždy používali časové osy při čekání na odpověď.</span><span class="sxs-lookup"><span data-stu-id="3daa6-115">In general, clients should be designed not to block indefinitely and to always use timeouts when waiting for a response.</span></span> <span data-ttu-id="3daa6-116">Použití časových časových opovenek zajišťuje, že prostředky nejsou nikdy vázány na neurčito.</span><span class="sxs-lookup"><span data-stu-id="3daa6-116">Using timeouts ensures that resources are never tied up indefinitely.</span></span>

<span data-ttu-id="3daa6-117">**Použijte vzor jističe**.</span><span class="sxs-lookup"><span data-stu-id="3daa6-117">**Use the Circuit Breaker pattern**.</span></span> <span data-ttu-id="3daa6-118">V tomto přístupu proces u klienta sleduje počet neúspěšných požadavků.</span><span class="sxs-lookup"><span data-stu-id="3daa6-118">In this approach, the client process tracks the number of failed requests.</span></span> <span data-ttu-id="3daa6-119">Pokud chybovost překročí nakonfigurovaný limit, "jistič" zakopne tak, aby další pokusy okamžitě selhaly.</span><span class="sxs-lookup"><span data-stu-id="3daa6-119">If the error rate exceeds a configured limit, a "circuit breaker" trips so that further attempts fail immediately.</span></span> <span data-ttu-id="3daa6-120">(Pokud velký počet požadavků selhávají, to naznačuje, že služba není k dispozici a že odesílání požadavků je zbytečné.) Po uplynutí časového období by měl klient zkusit znovu a pokud jsou nové požadavky úspěšné, zavřete jistič.</span><span class="sxs-lookup"><span data-stu-id="3daa6-120">(If a large number of requests are failing, that suggests the service is unavailable and that sending requests is pointless.) After a timeout period, the client should try again and, if the new requests are successful, close the circuit breaker.</span></span>

<span data-ttu-id="3daa6-121">**Poskytněte záložní soubory**.</span><span class="sxs-lookup"><span data-stu-id="3daa6-121">**Provide fallbacks**.</span></span> <span data-ttu-id="3daa6-122">V tomto přístupu klientský proces provádí záložní logiku při selhání požadavku, jako je například vrácení dat v mezipaměti nebo výchozí hodnota.</span><span class="sxs-lookup"><span data-stu-id="3daa6-122">In this approach, the client process performs fallback logic when a request fails, such as returning cached data or a default value.</span></span> <span data-ttu-id="3daa6-123">Jedná se o přístup vhodný pro dotazy a je složitější pro aktualizace nebo příkazy.</span><span class="sxs-lookup"><span data-stu-id="3daa6-123">This is an approach suitable for queries, and is more complex for updates or commands.</span></span>

<span data-ttu-id="3daa6-124">**Omezte počet požadavků zařazených do fronty**.</span><span class="sxs-lookup"><span data-stu-id="3daa6-124">**Limit the number of queued requests**.</span></span> <span data-ttu-id="3daa6-125">Klienti by také měli uložit horní mez počtu nevyřízených požadavků, které může mikroslužba klienta odeslat určité službě.</span><span class="sxs-lookup"><span data-stu-id="3daa6-125">Clients should also impose an upper bound on the number of outstanding requests that a client microservice can send to a particular service.</span></span> <span data-ttu-id="3daa6-126">Pokud bylo dosaženo limitu, je pravděpodobně zbytečné provádět další požadavky a tyto pokusy by měly okamžitě selhat.</span><span class="sxs-lookup"><span data-stu-id="3daa6-126">If the limit has been reached, it's probably pointless to make additional requests, and those attempts should fail immediately.</span></span> <span data-ttu-id="3daa6-127">Z hlediska implementace polly [přepážka izolace](https://github.com/App-vNext/Polly/wiki/Bulkhead) zásady lze použít ke splnění tohoto požadavku.</span><span class="sxs-lookup"><span data-stu-id="3daa6-127">In terms of implementation, the Polly [Bulkhead Isolation](https://github.com/App-vNext/Polly/wiki/Bulkhead) policy can be used to fulfill this requirement.</span></span> <span data-ttu-id="3daa6-128">Tento přístup je v podstatě omezení paralelizace s <xref:System.Threading.SemaphoreSlim> jako implementace.</span><span class="sxs-lookup"><span data-stu-id="3daa6-128">This approach is essentially a parallelization throttle with <xref:System.Threading.SemaphoreSlim> as the implementation.</span></span> <span data-ttu-id="3daa6-129">Umožňuje také "frontu" mimo přepážku.</span><span class="sxs-lookup"><span data-stu-id="3daa6-129">It also permits a "queue" outside the bulkhead.</span></span> <span data-ttu-id="3daa6-130">Můžete proaktivně zbavit nadměrné zatížení ještě před spuštěním (například proto, že kapacita je považována za plnou).</span><span class="sxs-lookup"><span data-stu-id="3daa6-130">You can proactively shed excess load even before execution (for example, because capacity is deemed full).</span></span> <span data-ttu-id="3daa6-131">Díky tomu je jeho reakce na určité scénáře selhání rychlejší, než by byl jistič, protože jistič čeká na poruchy.</span><span class="sxs-lookup"><span data-stu-id="3daa6-131">This makes its response to certain failure scenarios faster than a circuit breaker would be, since the circuit breaker waits for the failures.</span></span> <span data-ttu-id="3daa6-132">BulkheadPolicy objekt u [Polly](http://www.thepollyproject.org/) zveřejňuje, jak plná přepážka a fronty jsou a nabízí události na přetečení, takže lze také použít k řízení automatické horizontální škálování.</span><span class="sxs-lookup"><span data-stu-id="3daa6-132">The BulkheadPolicy object in [Polly](http://www.thepollyproject.org/) exposes how full the bulkhead and queue are, and offers events on overflow so can also be used to drive automated horizontal scaling.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="3daa6-133">Další zdroje</span><span class="sxs-lookup"><span data-stu-id="3daa6-133">Additional resources</span></span>

- <span data-ttu-id="3daa6-134">**Vzory odolnosti proti chybám**</span><span class="sxs-lookup"><span data-stu-id="3daa6-134">**Resiliency patterns**</span></span>\
  [https://docs.microsoft.com/azure/architecture/patterns/category/resiliency](/azure/architecture/patterns/category/resiliency)

- <span data-ttu-id="3daa6-135">**Přidání odolnosti a optimalizace výkonu**</span><span class="sxs-lookup"><span data-stu-id="3daa6-135">**Adding Resilience and Optimizing Performance**</span></span>\
  <https://docs.microsoft.com/previous-versions/msp-n-p/jj591574(v=pandp.10)>

- <span data-ttu-id="3daa6-136">**Přepážky.**</span><span class="sxs-lookup"><span data-stu-id="3daa6-136">**Bulkhead.**</span></span> <span data-ttu-id="3daa6-137">úložiště GitHub.</span><span class="sxs-lookup"><span data-stu-id="3daa6-137">GitHub repo.</span></span> <span data-ttu-id="3daa6-138">Implementace s polly politikou.</span><span class="sxs-lookup"><span data-stu-id="3daa6-138">Implementation with Polly policy.</span></span>\
  <https://github.com/App-vNext/Polly/wiki/Bulkhead>

- <span data-ttu-id="3daa6-139">**Navrhování odolných aplikací pro Azure**</span><span class="sxs-lookup"><span data-stu-id="3daa6-139">**Designing resilient applications for Azure**</span></span>\
  [https://docs.microsoft.com/azure/architecture/resiliency/](/azure/architecture/resiliency/)

- <span data-ttu-id="3daa6-140">**Přechodná manipulace s poruchami**</span><span class="sxs-lookup"><span data-stu-id="3daa6-140">**Transient fault handling**</span></span>\
  [https://docs.microsoft.com/azure/architecture/best-practices/transient-faults](/azure/architecture/best-practices/transient-faults)

>[!div class="step-by-step"]
><span data-ttu-id="3daa6-141">[Předchozí](handle-partial-failure.md)
>[další](implement-retries-exponential-backoff.md)</span><span class="sxs-lookup"><span data-stu-id="3daa6-141">[Previous](handle-partial-failure.md)
[Next](implement-retries-exponential-backoff.md)</span></span>
