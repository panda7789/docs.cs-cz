---
title: Definování vlastních typů pro práci s technologií .NET Framework XAML Services
ms.date: 03/30/2017
helpviewer_keywords:
- defining custom types [XAML Services]
ms.assetid: c2667cbd-2f46-4a7f-9dfc-53696e35e8e4
ms.openlocfilehash: e563c0d7e5113d55d4b942fb1d175a64f5b71abc
ms.sourcegitcommit: 30a83efb57c468da74e9e218de26cf88d3254597
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 07/20/2019
ms.locfileid: "68364291"
---
# <a name="defining-custom-types-for-use-with-net-framework-xaml-services"></a><span data-ttu-id="88cbc-102">Definování vlastních typů pro práci s technologií .NET Framework XAML Services</span><span class="sxs-lookup"><span data-stu-id="88cbc-102">Defining Custom Types for Use with .NET Framework XAML Services</span></span>
<span data-ttu-id="88cbc-103">Při definování vlastních typů, které jsou obchodní objekty, nebo typy, které nemají závislost na konkrétních architekturách, je možné sledovat určité osvědčené postupy pro XAML.</span><span class="sxs-lookup"><span data-stu-id="88cbc-103">When you define custom types that are business objects or are types that do not have a dependency on specific frameworks, there are certain best practices for XAML you can follow.</span></span> <span data-ttu-id="88cbc-104">Pokud budete postupovat podle těchto postupů, .NET Framework služby XAML a jeho čtenáři XAML a moduly pro zápis XAML mohou zjistit charakteristiky XAML vašeho typu a poskytnout mu odpovídající reprezentace v datovém proudu uzlu XAML pomocí systému typů XAML.</span><span class="sxs-lookup"><span data-stu-id="88cbc-104">If you follow these practices, .NET Framework XAML Services and its XAML readers and XAML writers can discover the XAML characteristics of your type and give it appropriate representation in a XAML node stream using the XAML type system.</span></span> <span data-ttu-id="88cbc-105">V tomto tématu jsou popsány osvědčené postupy pro definice typu, definice členů a CLR, které připisují typy nebo členy.</span><span class="sxs-lookup"><span data-stu-id="88cbc-105">This topic describes best practices for type definitions, member definitions, and CLR attributing of types or members.</span></span>  
  
## <a name="constructor-patterns-and-type-definitions-for-xaml"></a><span data-ttu-id="88cbc-106">Vzory konstruktoru a definice typů pro XAML</span><span class="sxs-lookup"><span data-stu-id="88cbc-106">Constructor Patterns and Type Definitions for XAML</span></span>  
 <span data-ttu-id="88cbc-107">Aby mohla vlastní třída vytvořit instanci jako prvek objektu v jazyce XAML, musí splňovat následující požadavky:</span><span class="sxs-lookup"><span data-stu-id="88cbc-107">To be instantiated as an object element in XAML, a custom class must meet the following requirements:</span></span>  
  
- <span data-ttu-id="88cbc-108">Vlastní třída musí být veřejná a musí vystavovat výchozí veřejný konstruktor (bez parametrů).</span><span class="sxs-lookup"><span data-stu-id="88cbc-108">The custom class must be public and must expose a default (parameterless) public constructor.</span></span> <span data-ttu-id="88cbc-109">(Poznámky týkající se struktur najdete v následující části.)</span><span class="sxs-lookup"><span data-stu-id="88cbc-109">(See following section for notes regarding structures.)</span></span>  
  
- <span data-ttu-id="88cbc-110">Vlastní třída nesmí být vnořená třída.</span><span class="sxs-lookup"><span data-stu-id="88cbc-110">The custom class must not be a nested class.</span></span> <span data-ttu-id="88cbc-111">Znak "tečka" v cestě s úplným názvem způsobuje nejednoznačnou divizi oboru názvů třídy a je v konfliktu s jinými funkcemi XAML, jako jsou například připojené vlastnosti.</span><span class="sxs-lookup"><span data-stu-id="88cbc-111">The extra "dot" in the full-name path makes the class-namespace division ambiguous, and interferes with other XAML features such as attached properties.</span></span>  
  
 <span data-ttu-id="88cbc-112">Pokud objekt může být vytvořen jako prvek objektu, může vytvořený objekt vyplnit formulář elementu vlastnosti všech vlastností, které přebírají objekt jako svůj podkladový typ.</span><span class="sxs-lookup"><span data-stu-id="88cbc-112">If an object can be instantiated as an object element, the created object can fill the property element form of any properties that take the object as their underlying type.</span></span>  
  
 <span data-ttu-id="88cbc-113">Pokud povolíte převaděč hodnot, můžete přesto zadat hodnoty objektů pro typy, které nesplňují tato kritéria.</span><span class="sxs-lookup"><span data-stu-id="88cbc-113">You can still provide object values for types that do not meet these criteria, if you enable a value converter.</span></span> <span data-ttu-id="88cbc-114">Další informace naleznete v tématu [převaděče typů a rozšíření značek pro jazyk XAML](type-converters-and-markup-extensions-for-xaml.md).</span><span class="sxs-lookup"><span data-stu-id="88cbc-114">For more information, see [Type Converters and Markup Extensions for XAML](type-converters-and-markup-extensions-for-xaml.md).</span></span>  
  
### <a name="structures"></a><span data-ttu-id="88cbc-115">Struktury</span><span class="sxs-lookup"><span data-stu-id="88cbc-115">Structures</span></span>  
 <span data-ttu-id="88cbc-116">Struktury jsou vždy možné sestavit v jazyce XAML podle definice CLR.</span><span class="sxs-lookup"><span data-stu-id="88cbc-116">Structures are always able to be constructed in XAML, by CLR definition.</span></span> <span data-ttu-id="88cbc-117">Je to proto, že kompilátor CLR implicitně vytvoří konstruktor bez parametrů pro strukturu.</span><span class="sxs-lookup"><span data-stu-id="88cbc-117">This is because a CLR compiler implicitly creates a parameterless constructor for a structure.</span></span> <span data-ttu-id="88cbc-118">Tento konstruktor inicializuje všechny hodnoty vlastností na jejich výchozí hodnoty.</span><span class="sxs-lookup"><span data-stu-id="88cbc-118">This constructor initializes all property values to their defaults.</span></span>  
  
 <span data-ttu-id="88cbc-119">V některých případech není výchozí chování konstrukce pro strukturu žádoucí.</span><span class="sxs-lookup"><span data-stu-id="88cbc-119">In some cases, the default construction behavior for a structure is not desirable.</span></span> <span data-ttu-id="88cbc-120">Důvodem může být to, že struktura je určena k vyplnění hodnot a funkce koncepčně jako sjednocení.</span><span class="sxs-lookup"><span data-stu-id="88cbc-120">This might be because the structure is intended to fill values and function conceptually as a union.</span></span> <span data-ttu-id="88cbc-121">V rámci sjednocení mohou obsažené hodnoty mít vzájemně exkluzivní výklad, a proto nelze nastavit žádnou z jejích vlastností.</span><span class="sxs-lookup"><span data-stu-id="88cbc-121">As a union, the contained values might have mutually exclusive interpretations, and therefore, none of its properties are settable.</span></span> <span data-ttu-id="88cbc-122">Příkladem takové struktury ve slovníku WPF je <xref:System.Windows.GridLength>.</span><span class="sxs-lookup"><span data-stu-id="88cbc-122">An example of such a structure in the WPF vocabulary is <xref:System.Windows.GridLength>.</span></span> <span data-ttu-id="88cbc-123">Tyto struktury by měly implementovat konvertor typu tak, aby hodnoty mohly být vyjádřeny ve formě atributu pomocí konvencí řetězců, které vytvářejí různé interpretace nebo režimy hodnot struktury.</span><span class="sxs-lookup"><span data-stu-id="88cbc-123">Such structures should implement a type converter so that the values can be expressed in attribute form, by using string conventions that create the different interpretations or modes of the structure values.</span></span> <span data-ttu-id="88cbc-124">Struktura by měla také vystavovat podobné chování pro vytváření kódu prostřednictvím konstruktoru bez parametrů.</span><span class="sxs-lookup"><span data-stu-id="88cbc-124">The structure should also expose similar behavior for code construction through a non-parameterless constructor.</span></span>  
  
### <a name="interfaces"></a><span data-ttu-id="88cbc-125">Rozhraní</span><span class="sxs-lookup"><span data-stu-id="88cbc-125">Interfaces</span></span>  
 <span data-ttu-id="88cbc-126">Rozhraní lze použít jako základní typy členů.</span><span class="sxs-lookup"><span data-stu-id="88cbc-126">Interfaces can be used as underlying types of members.</span></span> <span data-ttu-id="88cbc-127">Systém typů XAML kontroluje seznam přiřazení a očekává, že objekt, který je k dispozici jako hodnota, lze přiřadit k rozhraní.</span><span class="sxs-lookup"><span data-stu-id="88cbc-127">The XAML type system checks the assignable list and expects that the object that is provided as the value can be assigned to the interface.</span></span> <span data-ttu-id="88cbc-128">Neexistuje žádný koncept, jak musí být rozhraní prezentována jako typ XAML, pokud příslušný typ přiřazení podporuje požadavky na konstrukci XAML.</span><span class="sxs-lookup"><span data-stu-id="88cbc-128">There is no concept of how the interface must be presented as a XAML type as long as a relevant assignable type supports the XAML construction requirements.</span></span>  
  
### <a name="factory-methods"></a><span data-ttu-id="88cbc-129">Metody pro vytváření objektů</span><span class="sxs-lookup"><span data-stu-id="88cbc-129">Factory Methods</span></span>  
 <span data-ttu-id="88cbc-130">Metody pro vytváření objektů jsou funkcí XAML 2009.</span><span class="sxs-lookup"><span data-stu-id="88cbc-130">Factory methods are a XAML 2009 feature.</span></span> <span data-ttu-id="88cbc-131">Upravují princip jazyka XAML, že objekty musí mít konstruktory bez parametrů.</span><span class="sxs-lookup"><span data-stu-id="88cbc-131">They modify the XAML principle that objects must have parameterless constructors.</span></span> <span data-ttu-id="88cbc-132">Metody pro vytváření objektů nejsou popsány v tomto tématu.</span><span class="sxs-lookup"><span data-stu-id="88cbc-132">Factory methods are not documented in this topic.</span></span> <span data-ttu-id="88cbc-133">Viz [direktiva x:FactoryMethod –](x-factorymethod-directive.md).</span><span class="sxs-lookup"><span data-stu-id="88cbc-133">See [x:FactoryMethod Directive](x-factorymethod-directive.md).</span></span>  
  
## <a name="enumerations"></a><span data-ttu-id="88cbc-134">Výčty</span><span class="sxs-lookup"><span data-stu-id="88cbc-134">Enumerations</span></span>  
 <span data-ttu-id="88cbc-135">Výčty mají chování konverze nativního typu XAML.</span><span class="sxs-lookup"><span data-stu-id="88cbc-135">Enumerations have XAML native type conversion behavior.</span></span> <span data-ttu-id="88cbc-136">Výčty názvů výčtu zadané v jazyce XAML jsou vyřešeny proti základnímu typu výčtu a vracejí hodnotu výčtu do zapisovače objektu XAML.</span><span class="sxs-lookup"><span data-stu-id="88cbc-136">Enumeration constant names specified in XAML are resolved against the underlying enumeration type, and return the enumeration value to a XAML object writer.</span></span>  
  
 <span data-ttu-id="88cbc-137">Jazyk XAML podporuje použití stylu příznaků pro výčty s <xref:System.FlagsAttribute> použitím.</span><span class="sxs-lookup"><span data-stu-id="88cbc-137">XAML supports a flags-style usage for enumerations with <xref:System.FlagsAttribute> applied.</span></span> <span data-ttu-id="88cbc-138">Další informace naleznete v tématu [syntaxe jazyka XAML podrobněji](../wpf/advanced/xaml-syntax-in-detail.md).</span><span class="sxs-lookup"><span data-stu-id="88cbc-138">For more information, see [XAML Syntax In Detail](../wpf/advanced/xaml-syntax-in-detail.md).</span></span> <span data-ttu-id="88cbc-139">([Syntaxe jazyka XAML je podrobně](../wpf/advanced/xaml-syntax-in-detail.md) určena pro cílovou skupinu WPF, ale většina informací v tomto tématu je relevantní pro jazyk XAML, který není specifický pro konkrétní implementaci rozhraní.)</span><span class="sxs-lookup"><span data-stu-id="88cbc-139">([XAML Syntax In Detail](../wpf/advanced/xaml-syntax-in-detail.md) is written for the WPF audience, but most of the information in that topic is relevant for XAML that is not specific to a particular implementing framework.)</span></span>  
  
## <a name="member-definitions"></a><span data-ttu-id="88cbc-140">Definice členů</span><span class="sxs-lookup"><span data-stu-id="88cbc-140">Member Definitions</span></span>  
 <span data-ttu-id="88cbc-141">Typy mohou definovat členy pro použití v jazyce XAML.</span><span class="sxs-lookup"><span data-stu-id="88cbc-141">Types can define members for XAML usage.</span></span> <span data-ttu-id="88cbc-142">Je možné použít typy, které definují členy, které jsou použitelné v jazyce XAML, i v případě, že tento konkrétní typ není použit jako XAML.</span><span class="sxs-lookup"><span data-stu-id="88cbc-142">It is possible for types that define members that are XAML-usable even if that specific type is not XAML-usable.</span></span> <span data-ttu-id="88cbc-143">To je možné z důvodu dědičnosti CLR.</span><span class="sxs-lookup"><span data-stu-id="88cbc-143">This is possible because of CLR inheritance.</span></span> <span data-ttu-id="88cbc-144">Pokud nějaký typ, který dědí člen, podporuje použití XAML jako typ a člen podporuje použití XAML pro svůj základní typ nebo má k dispozici nativní syntaxi jazyka XAML, je tento člen použitelný jako XAML.</span><span class="sxs-lookup"><span data-stu-id="88cbc-144">So long as some type that inherits the member supports XAML usage as a type, and the member supports XAML usage for its underlying type or has a native XAML syntax available, that member is XAML-usable.</span></span>  
  
### <a name="properties"></a><span data-ttu-id="88cbc-145">Vlastnosti</span><span class="sxs-lookup"><span data-stu-id="88cbc-145">Properties</span></span>  
 <span data-ttu-id="88cbc-146">Definujete-li vlastnosti jako veřejnou vlastnost CLR pomocí typických vzorů `set` CLR `get` a přístupových objektů a odpovídajících jazyků, může systém typů XAML hlásit vlastnost jako člen s příslušnými informacemi poskytnutými pro <xref:System.Xaml.XamlMember> vlastnosti ,<xref:System.Xaml.XamlMember.IsReadPublic%2A> například a <xref:System.Xaml.XamlMember.IsWritePublic%2A>.</span><span class="sxs-lookup"><span data-stu-id="88cbc-146">If you define properties as a public CLR property using the typical CLR `get` and `set` accessor patterns and language-appropriate keywording, the XAML type system can report the property as a member with appropriate information provided for <xref:System.Xaml.XamlMember> properties, such as <xref:System.Xaml.XamlMember.IsReadPublic%2A> and <xref:System.Xaml.XamlMember.IsWritePublic%2A>.</span></span>  
  
 <span data-ttu-id="88cbc-147">Konkrétní vlastnosti umožňují použít syntaxi <xref:System.ComponentModel.TypeConverterAttribute>textu.</span><span class="sxs-lookup"><span data-stu-id="88cbc-147">Specific properties can enable a text syntax by applying <xref:System.ComponentModel.TypeConverterAttribute>.</span></span> <span data-ttu-id="88cbc-148">Další informace naleznete v tématu [převaděče typů a rozšíření značek pro jazyk XAML](type-converters-and-markup-extensions-for-xaml.md).</span><span class="sxs-lookup"><span data-stu-id="88cbc-148">For more information, see [Type Converters and Markup Extensions for XAML](type-converters-and-markup-extensions-for-xaml.md).</span></span>  
  
 <span data-ttu-id="88cbc-149">V případě, že se nejedná o syntaxi textu nebo nativní konverzi XAML a v případě neexistence dalšího indirekce, jako je například použití rozšíření značek, musí být typ vlastnosti<xref:System.Xaml.XamlMember.TargetType%2A> (v systému typů XAML) schopný vrátit instanci do zapisovače objektů XAML tím, že zpracuje t typ arget jako typ CLR.</span><span class="sxs-lookup"><span data-stu-id="88cbc-149">In the absence of a text syntax or native XAML conversion and in the absence of further indirection, such as a markup extension usage, the type of a property (<xref:System.Xaml.XamlMember.TargetType%2A> in the XAML type system) must be able to return an instance to a XAML object writer by treating the target type as a CLR type.</span></span>  
  
 <span data-ttu-id="88cbc-150">Pokud používáte XAML 2009, lze použít [rozšíření značek x:Reference](x-reference-markup-extension.md) k poskytnutí hodnot, pokud předchozí okolnosti nejsou splněny. ale to je více než problém s definicí typu.</span><span class="sxs-lookup"><span data-stu-id="88cbc-150">If using XAML 2009, [x:Reference Markup Extension](x-reference-markup-extension.md) can be used to provide values if the previous considerations are not met; however, that is more of a usage issue than a type definition issue.</span></span>  
  
### <a name="events"></a><span data-ttu-id="88cbc-151">Události</span><span class="sxs-lookup"><span data-stu-id="88cbc-151">Events</span></span>  
 <span data-ttu-id="88cbc-152">Definujete-li události jako veřejnou událost CLR, může systém typů XAML hlásit událost jako člen s <xref:System.Xaml.XamlMember.IsEvent%2A> jako. `true`</span><span class="sxs-lookup"><span data-stu-id="88cbc-152">If you define events as a public CLR event, the XAML type system can report the event as a member with <xref:System.Xaml.XamlMember.IsEvent%2A> as `true`.</span></span> <span data-ttu-id="88cbc-153">Kabely obslužných rutin událostí nejsou v rozsahu možností .NET Framework služby XAML. Toto je ponecháno na konkrétní architektury a implementace.</span><span class="sxs-lookup"><span data-stu-id="88cbc-153">Wiring the event handlers is not within the scope of .NET Framework XAML Services capabilities; this is left to specific frameworks and implementations.</span></span>  
  
### <a name="methods"></a><span data-ttu-id="88cbc-154">Metody</span><span class="sxs-lookup"><span data-stu-id="88cbc-154">Methods</span></span>  
 <span data-ttu-id="88cbc-155">Vložený kód pro metody není výchozí funkcí jazyka XAML.</span><span class="sxs-lookup"><span data-stu-id="88cbc-155">Inline code for methods is not a default XAML capability.</span></span> <span data-ttu-id="88cbc-156">Ve většině případů neodkazujte přímo na členy metody z XAML a role metod v jazyce XAML je určena pouze k poskytnutí podpory pro konkrétní vzory XAML.</span><span class="sxs-lookup"><span data-stu-id="88cbc-156">In most cases you do not directly reference method members from XAML, and the role of methods in XAML is only to provide support for specific XAML patterns.</span></span> <span data-ttu-id="88cbc-157">[direktiva x:FactoryMethod –](x-factorymethod-directive.md) je výjimka.</span><span class="sxs-lookup"><span data-stu-id="88cbc-157">[x:FactoryMethod Directive](x-factorymethod-directive.md) is an exception.</span></span>  
  
### <a name="fields"></a><span data-ttu-id="88cbc-158">Pole</span><span class="sxs-lookup"><span data-stu-id="88cbc-158">Fields</span></span>  
 <span data-ttu-id="88cbc-159">Pokyny pro návrh CLR odradit nestatickým polím.</span><span class="sxs-lookup"><span data-stu-id="88cbc-159">CLR design guidelines discourage nonstatic fields.</span></span> <span data-ttu-id="88cbc-160">Pro statická pole můžete přistupovat k hodnotám statického pole pouze prostřednictvím [rozšíření značek x:static](x-static-markup-extension.md); v takovém případě neprovádíte žádné speciální údaje v definici CLR k vystavení pole pro použití [x:static](x-static-markup-extension.md) .</span><span class="sxs-lookup"><span data-stu-id="88cbc-160">For static fields, you can access static field values only through [x:Static Markup Extension](x-static-markup-extension.md); in this case you are not doing anything special in the CLR definition to expose a field for [x:Static](x-static-markup-extension.md) usages.</span></span>  
  
## <a name="attachable-members"></a><span data-ttu-id="88cbc-161">Připojení členové</span><span class="sxs-lookup"><span data-stu-id="88cbc-161">Attachable Members</span></span>  
 <span data-ttu-id="88cbc-162">Připojitelné členy jsou zpřístupněny XAML prostřednictvím vzoru metody přístupového objektu na definujícím typu.</span><span class="sxs-lookup"><span data-stu-id="88cbc-162">Attachable members are exposed to XAML through an accessor method pattern on a defining type.</span></span> <span data-ttu-id="88cbc-163">Definiční typ samotný není nutné použít jako objekt XAML.</span><span class="sxs-lookup"><span data-stu-id="88cbc-163">The defining type itself does not need to be XAML-usable as an object.</span></span> <span data-ttu-id="88cbc-164">Společný vzor ve skutečnosti je deklarovat třídu služby, jejíž role je vlastníkem přihlášeného člena a implementovat související chování, ale neposkytuje žádnou jinou funkci, jako je například reprezentace uživatelského rozhraní.</span><span class="sxs-lookup"><span data-stu-id="88cbc-164">In fact, a common pattern is to declare a service class whose role is to own the attachable member and implement the related behaviors, but serve no other function such as a UI representation.</span></span> <span data-ttu-id="88cbc-165">V následujících částech zástupný symbol *PropertyName* nepředstavuje název připojeného člena.</span><span class="sxs-lookup"><span data-stu-id="88cbc-165">For the following sections, the placeholder *PropertyName* represents the name of your attachable member.</span></span> <span data-ttu-id="88cbc-166">Tento název musí být platný v gramatice v kódu [XAML](xamlname-grammar.md).</span><span class="sxs-lookup"><span data-stu-id="88cbc-166">That name must be valid in the [XamlName Grammar](xamlname-grammar.md).</span></span>  
  
 <span data-ttu-id="88cbc-167">Buďte opatrní proti kolizím názvů mezi těmito vzory a jinými metodami typu.</span><span class="sxs-lookup"><span data-stu-id="88cbc-167">Be cautious of name collisions between these patterns and other methods of a type.</span></span> <span data-ttu-id="88cbc-168">Pokud existuje člen, který odpovídá jednomu ze vzorů, lze jej interpretovat jako připojovatelné členy pomocí procesoru XAML, a to i v případě, že to nebylo vaším záměrem.</span><span class="sxs-lookup"><span data-stu-id="88cbc-168">If a member exists that matches one of the patterns, it can be interpreted as an attachable member usage pathway by a XAML processor even if that was not your intention.</span></span>  
  
#### <a name="the-getpropertyname-accessor"></a><span data-ttu-id="88cbc-169">Přístupový objekt GetProperty</span><span class="sxs-lookup"><span data-stu-id="88cbc-169">The GetPropertyName Accessor</span></span>  
 <span data-ttu-id="88cbc-170">Signatura `Get`přístupového objektu *PropertyName* musí být:</span><span class="sxs-lookup"><span data-stu-id="88cbc-170">The signature for the `Get`*PropertyName* accessor must be:</span></span>  
  
 <span data-ttu-id="88cbc-171">`public static object Get` *PropertyName* `(object`  `target` `)`</span><span class="sxs-lookup"><span data-stu-id="88cbc-171">`public static object Get` *PropertyName* `(object`  `target` `)`</span></span>  
  
- <span data-ttu-id="88cbc-172">`target` Objekt může být zadán jako konkrétnější typ v implementaci.</span><span class="sxs-lookup"><span data-stu-id="88cbc-172">The `target` object can be specified as a more specific type in your implementation.</span></span> <span data-ttu-id="88cbc-173">Tuto možnost můžete použít k určení rozsahu využití přidaného člena; použití mimo zamýšlený rozsah vyvolá neplatné výjimky přetypování, které jsou následně vykryty chybou analýzy XAML.</span><span class="sxs-lookup"><span data-stu-id="88cbc-173">You can use this to scope the usage of your attachable member; usages outside your intended scope will throw invalid cast exceptions that are then surfaced by a XAML parse error.</span></span> <span data-ttu-id="88cbc-174">Název `target` parametru není požadavek, ale je pojmenován `target` podle konvence ve většině implementací.</span><span class="sxs-lookup"><span data-stu-id="88cbc-174">The parameter name `target` is not a requirement, but is named `target` by convention in most implementations.</span></span>  
  
- <span data-ttu-id="88cbc-175">Návratová hodnota může být v implementaci zadána jako konkrétnější typ.</span><span class="sxs-lookup"><span data-stu-id="88cbc-175">The return value can be specified as a more specific type in your implementation.</span></span>  
  
 <span data-ttu-id="88cbc-176">Pro podporu <xref:System.ComponentModel.TypeConverter> povolených syntaxí textu pro použití atributu přistupujícího člena použijte <xref:System.ComponentModel.TypeConverterAttribute> pro přístup k `Get` *PropertyName* .</span><span class="sxs-lookup"><span data-stu-id="88cbc-176">To support a <xref:System.ComponentModel.TypeConverter> enabled text syntax for attribute usage of the attachable member, apply <xref:System.ComponentModel.TypeConverterAttribute> to the `Get`*PropertyName* accessor.</span></span> <span data-ttu-id="88cbc-177">Použití na `get` místo `set` se může zdát neintuitivní; Nicméně tato konvence může podporovat koncept přidaných členů, kteří jsou serializovatelný, což je užitečné v rámci scénářů pro návrháře.</span><span class="sxs-lookup"><span data-stu-id="88cbc-177">Applying to the `get` instead of the `set` may seem nonintuitive; however, this convention can support the concept of read-only attachable members that are serializable, which is useful in designer scenarios.</span></span>  
  
#### <a name="the-setpropertyname-accessor"></a><span data-ttu-id="88cbc-178">Přístup ke SetProperty</span><span class="sxs-lookup"><span data-stu-id="88cbc-178">The SetPropertyName Accessor</span></span>  
 <span data-ttu-id="88cbc-179">Podpis pro přístup Set*PropertyName* musí být:</span><span class="sxs-lookup"><span data-stu-id="88cbc-179">The signature for the Set*PropertyName* accessor must be:</span></span>  
  
 <span data-ttu-id="88cbc-180">`public static void Set` *PropertyName* `(object`  `target` `, object`  `value` `)`</span><span class="sxs-lookup"><span data-stu-id="88cbc-180">`public static void Set` *PropertyName* `(object`  `target` `, object`  `value` `)`</span></span>  
  
- <span data-ttu-id="88cbc-181">`target` Objekt může být zadán jako konkrétnější typ v implementaci, se stejnou logikou a následky, jak je popsáno v předchozí části.</span><span class="sxs-lookup"><span data-stu-id="88cbc-181">The `target` object can be specified as a more specific type in your implementation, with same logic and consequences as described in the previous section.</span></span>  
  
- <span data-ttu-id="88cbc-182">`value` Objekt může být zadán jako konkrétnější typ v implementaci.</span><span class="sxs-lookup"><span data-stu-id="88cbc-182">The `value` object can be specified as a more specific type in your implementation.</span></span>  
  
 <span data-ttu-id="88cbc-183">Pamatujte, že hodnota pro tuto metodu je vstup z použití XAML, obvykle ve formě atributu.</span><span class="sxs-lookup"><span data-stu-id="88cbc-183">Remember that the value for this method is the input coming from the XAML usage, typically in attribute form.</span></span> <span data-ttu-id="88cbc-184">Z formuláře atributu musí být podpora převaděče hodnot pro textovou syntaxi a atributem `Get`přístupového objektu *PropertyName* .</span><span class="sxs-lookup"><span data-stu-id="88cbc-184">From attribute form there must be value converter support for a text syntax, and you attribute on the `Get`*PropertyName* accessor.</span></span>  
  
### <a name="attachable-member-stores"></a><span data-ttu-id="88cbc-185">Připojitelná úložiště členů</span><span class="sxs-lookup"><span data-stu-id="88cbc-185">Attachable Member Stores</span></span>  
 <span data-ttu-id="88cbc-186">Přístupové metody nejsou obvykle dostačující k tomu, aby poskytovaly prostředky, které umožňují umístit přizpůsobitelné členské hodnoty do grafu objektů, nebo načíst hodnoty z grafu objektů a serializovat je správně.</span><span class="sxs-lookup"><span data-stu-id="88cbc-186">The accessor methods are typically not enough to provide a means to place attachable member values into an object graph, or to retrieve values out of the object graph and serialize them properly.</span></span> <span data-ttu-id="88cbc-187">Aby bylo možné tuto funkci poskytnout `target` , objekty v předchozích podpisech přístupového objektu musí být schopny ukládat hodnoty.</span><span class="sxs-lookup"><span data-stu-id="88cbc-187">To provide this functionality, the `target` objects in the previous accessor signatures must be capable of storing values.</span></span> <span data-ttu-id="88cbc-188">Mechanismus úložiště by měl být v souladu s principem připojitelné člena, že člen je možné připojit k cílům, kde je připojitelný člen v seznamu členů.</span><span class="sxs-lookup"><span data-stu-id="88cbc-188">The storage mechanism should be consistent with the attachable member principle that the member is attachable to targets where the attachable member is not in the members list.</span></span> <span data-ttu-id="88cbc-189">.NET Framework služby XAML poskytují techniku implementace pro připojovatelné členské obchody prostřednictvím rozhraní API <xref:System.Xaml.IAttachedPropertyStore> a <xref:System.Xaml.AttachablePropertyServices>.</span><span class="sxs-lookup"><span data-stu-id="88cbc-189">.NET Framework XAML Services provides an implementation technique for attachable member stores through the APIs <xref:System.Xaml.IAttachedPropertyStore> and <xref:System.Xaml.AttachablePropertyServices>.</span></span> <span data-ttu-id="88cbc-190"><xref:System.Xaml.IAttachedPropertyStore>je používána zapisovači jazyka XAML ke zjištění implementace úložiště a měla by být implementována na typ, který je `target` přístupovými objekty.</span><span class="sxs-lookup"><span data-stu-id="88cbc-190"><xref:System.Xaml.IAttachedPropertyStore> is used by the XAML writers to discover the store implementation, and should be implemented on the type that is the `target` of the accessors.</span></span> <span data-ttu-id="88cbc-191">Statická <xref:System.Xaml.AttachablePropertyServices> rozhraní API se používají v těle přístupových objektů a odkazují na připojitelné členy podle jeho <xref:System.Xaml.AttachableMemberIdentifier>.</span><span class="sxs-lookup"><span data-stu-id="88cbc-191">The static <xref:System.Xaml.AttachablePropertyServices> APIs are used within the body of the accessors, and refer to the attachable member by its <xref:System.Xaml.AttachableMemberIdentifier>.</span></span>  
  
## <a name="xaml-related-clr-attributes"></a><span data-ttu-id="88cbc-192">Atributy CLR související s jazykem XAML</span><span class="sxs-lookup"><span data-stu-id="88cbc-192">XAML-Related CLR Attributes</span></span>  
 <span data-ttu-id="88cbc-193">Správné označení vašich typů, členů a sestavení je důležité, aby bylo možné nahlásit systémové informace typu XAML do .NET Framework služby XAML.</span><span class="sxs-lookup"><span data-stu-id="88cbc-193">Correctly attributing your types, members, and assemblies is important in order to report XAML type system information to .NET Framework XAML Services.</span></span> <span data-ttu-id="88cbc-194">To je důležité, pokud máte v úmyslu používat systémy XAML přímo na základě .NET Framework čtenáři XAML a zapisovače XAML, nebo pokud definujete nebo používáte rozhraní XAML, které je založené na těchto čtenářích XAML a zapisovači XAML.</span><span class="sxs-lookup"><span data-stu-id="88cbc-194">This is relevant if you intend your types for use with XAML systems that are directly based on .NET Framework XAML Services XAML readers and XAML writers, or if you define or use a XAML-utilizing framework that is based on those XAML readers and XAML writers.</span></span>  
  
 <span data-ttu-id="88cbc-195">Seznam každého atributu souvisejícího s XAML, který je relevantní pro podporu jazyka XAML vašich vlastních typů, naleznete v tématu [atributy CLR související s jazykem XAML pro vlastní typy a knihovny](xaml-related-clr-attributes-for-custom-types-and-libraries.md).</span><span class="sxs-lookup"><span data-stu-id="88cbc-195">For a listing of each XAML-related attribute that is relevant for XAML support of your custom types, see [XAML-Related CLR Attributes for Custom Types and Libraries](xaml-related-clr-attributes-for-custom-types-and-libraries.md).</span></span>  
  
## <a name="usage"></a><span data-ttu-id="88cbc-196">Použití</span><span class="sxs-lookup"><span data-stu-id="88cbc-196">Usage</span></span>  
 <span data-ttu-id="88cbc-197">Použití vlastních typů vyžaduje, aby autor značek musel mapovat předponu pro sestavení a obor názvů CLR, který obsahuje vlastní typ.</span><span class="sxs-lookup"><span data-stu-id="88cbc-197">Usage of custom types requires that the markup author must map a prefix for the assembly and CLR namespace that contain the custom type.</span></span> <span data-ttu-id="88cbc-198">Tato procedura není popsána v tomto tématu.</span><span class="sxs-lookup"><span data-stu-id="88cbc-198">This procedure is not documented in this topic.</span></span>  
  
## <a name="access-level"></a><span data-ttu-id="88cbc-199">Úroveň přístupu</span><span class="sxs-lookup"><span data-stu-id="88cbc-199">Access Level</span></span>  
 <span data-ttu-id="88cbc-200">XAML poskytuje způsob načítání a vytváření instancí typů, které mají `internal` úroveň přístupu.</span><span class="sxs-lookup"><span data-stu-id="88cbc-200">XAML provides a means to load and instantiate types that have an `internal` access level.</span></span> <span data-ttu-id="88cbc-201">Tato funkce je k dispozici, aby kód uživatele mohl definovat vlastní typy, a poté vytvořit instance těchto tříd ze značek, který je také součástí stejného oboru kódu uživatele.</span><span class="sxs-lookup"><span data-stu-id="88cbc-201">This capability is provided so that user code can define its own types, and then instantiate those classes from markup that is also part of the same user code scope.</span></span>  
  
 <span data-ttu-id="88cbc-202">Příklad z WPF je vždy <xref:System.Windows.Controls.UserControl> , když uživatel definuje kód, který je určen jako způsob refaktorující chování uživatelského rozhraní, ale ne jako součást jakéhokoli mechanizmu rozšiřujícího mechanismu, který může být odvozen deklarováním podpůrné třídy s `public` úrovní přístupu.</span><span class="sxs-lookup"><span data-stu-id="88cbc-202">An example from WPF is whenever user code defines a <xref:System.Windows.Controls.UserControl> that is intended as a way to refactor a UI behavior, but not as part of any possible extension mechanism that might be implied by declaring the supporting class with `public` access level.</span></span> <span data-ttu-id="88cbc-203">Takový objekt <xref:System.Windows.Controls.UserControl> lze deklarovat s `internal` přístupem, pokud je zálohovaný kód zkompilován do stejného sestavení, ze kterého je odkazováno jako typ XAML.</span><span class="sxs-lookup"><span data-stu-id="88cbc-203">Such a <xref:System.Windows.Controls.UserControl> can be declared with `internal` access if the backing code is compiled into the same assembly from which it is referenced as a XAML type.</span></span>  
  
 <span data-ttu-id="88cbc-204">Pro aplikaci, která načte XAML pod úplným vztahem <xref:System.Xaml.XamlObjectWriter>důvěryhodnosti a pomocí, `internal` je načítání tříd s úrovní přístupu vždy povoleno.</span><span class="sxs-lookup"><span data-stu-id="88cbc-204">For an application that loads XAML under full trust and uses <xref:System.Xaml.XamlObjectWriter>, loading classes with `internal` access level is always enabled.</span></span>  
  
 <span data-ttu-id="88cbc-205">Pro aplikaci, která načte XAML v rámci částečné důvěryhodnosti, můžete řídit charakteristiky úrovně přístupu pomocí <xref:System.Xaml.Permissions.XamlAccessLevel> rozhraní API.</span><span class="sxs-lookup"><span data-stu-id="88cbc-205">For an application that loads XAML under partial trust, you can control the access level characteristics by using the <xref:System.Xaml.Permissions.XamlAccessLevel> API.</span></span> <span data-ttu-id="88cbc-206">Mechanismy odložení (například systém šablony WPF) musí být schopné rozšířit všechna oprávnění na úrovni přístupu a zachovat je pro případná vyhodnocení doby běhu; Tato <xref:System.Xaml.Permissions.XamlAccessLevel> informace je interně zpracována předáním informací.</span><span class="sxs-lookup"><span data-stu-id="88cbc-206">Also, deferral mechanisms (such as the WPF template system) must be able to propagate any access level permissions and preserve them for the eventual run time evaluations; this is handled internally by passing the <xref:System.Xaml.Permissions.XamlAccessLevel> information.</span></span>  
  
### <a name="wpf-implementation"></a><span data-ttu-id="88cbc-207">Implementace WPF</span><span class="sxs-lookup"><span data-stu-id="88cbc-207">WPF Implementation</span></span>  
 <span data-ttu-id="88cbc-208">WPF XAML používá model přístupu s částečnou důvěryhodností, kde Pokud je BAML načten v rámci částečné důvěryhodnosti, přístup <xref:System.Xaml.Permissions.XamlAccessLevel.AssemblyAccessTo%2A> je omezen na pro sestavení, které je zdrojem BAML.</span><span class="sxs-lookup"><span data-stu-id="88cbc-208">WPF XAML uses a partial-trust access model where if BAML is loaded under partial trust, access is restricted to <xref:System.Xaml.Permissions.XamlAccessLevel.AssemblyAccessTo%2A> for the assembly that is the BAML source.</span></span> <span data-ttu-id="88cbc-209">Pro odložení používá <xref:System.Xaml.IXamlObjectWriterFactory.GetParentSettings%2A?displayProperty=nameWithType> WPF jako mechanismus pro předávání informací o úrovni přístupu.</span><span class="sxs-lookup"><span data-stu-id="88cbc-209">For deferral, WPF uses <xref:System.Xaml.IXamlObjectWriterFactory.GetParentSettings%2A?displayProperty=nameWithType> as a mechanism for passing the access level information.</span></span>  
  
 <span data-ttu-id="88cbc-210">V terminologii WPF XAML je *interní typ* typu, který je definován stejným sestavením, které také obsahuje odkaz na XAML.</span><span class="sxs-lookup"><span data-stu-id="88cbc-210">In WPF XAML terminology, an *internal type* is a type that is defined by the same assembly that also includes the referencing XAML.</span></span> <span data-ttu-id="88cbc-211">Takový typ lze namapovat pomocí oboru názvů XAML, který záměrně vynechává sestavení = část mapování, `xmlns:local="clr-namespace:WPFApplication1"`například.</span><span class="sxs-lookup"><span data-stu-id="88cbc-211">Such a type can be mapped through a XAML namespace that deliberately omits the assembly= portion of a mapping, for example, `xmlns:local="clr-namespace:WPFApplication1"`.</span></span>  <span data-ttu-id="88cbc-212">Pokud BAML odkazuje na interní typ a tento typ má `internal` úroveň přístupu, `GeneratedInternalTypeHelper` vygeneruje třídu pro sestavení.</span><span class="sxs-lookup"><span data-stu-id="88cbc-212">If BAML references an internal type and that type has `internal` access level, this generates a `GeneratedInternalTypeHelper` class for the assembly.</span></span> <span data-ttu-id="88cbc-213">Pokud se chcete vyhnout `GeneratedInternalTypeHelper`, je nutné buď použít `public` úroveň přístupu, nebo musí zvážit relevantní třídu do samostatného sestavení a zajistit, aby bylo sestavení závislé.</span><span class="sxs-lookup"><span data-stu-id="88cbc-213">If you want to avoid `GeneratedInternalTypeHelper`, you either must use `public` access level, or must factor the relevant class into a separate assembly and make that assembly dependent.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="88cbc-214">Viz také:</span><span class="sxs-lookup"><span data-stu-id="88cbc-214">See also</span></span>

- [<span data-ttu-id="88cbc-215">Atributy CLR související s jazykem XAML pro vlastní typy a knihovny</span><span class="sxs-lookup"><span data-stu-id="88cbc-215">XAML-Related CLR Attributes for Custom Types and Libraries</span></span>](xaml-related-clr-attributes-for-custom-types-and-libraries.md)
- [<span data-ttu-id="88cbc-216">XAML Services</span><span class="sxs-lookup"><span data-stu-id="88cbc-216">XAML Services</span></span>](index.md)
