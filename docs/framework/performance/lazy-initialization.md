---
title: Opožděná inicializace
description: Prozkoumejte opožděnou inicializaci v rozhraní .NET, což znamená zvýšení výkonu, což znamená, že vytvoření objektu je odloženo, dokud není objekt nejprve použit.
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- lazy initialization in .NET, introduction
ms.assetid: 56b4ae5c-4745-44ff-ad78-ffe4fcde6b9b
ms.openlocfilehash: 355fa326fc19e9a50a74e21ace0a6353f5c740c5
ms.sourcegitcommit: 3824ff187947572b274b9715b60c11269335c181
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 06/17/2020
ms.locfileid: "84904231"
---
# <a name="lazy-initialization"></a><span data-ttu-id="e1dee-103">Opožděná inicializace</span><span class="sxs-lookup"><span data-stu-id="e1dee-103">Lazy Initialization</span></span>
<span data-ttu-id="e1dee-104">*Opožděná inicializace* objektu znamená, že jeho vytvoření je odloženo až do prvního použití.</span><span class="sxs-lookup"><span data-stu-id="e1dee-104">*Lazy initialization* of an object means that its creation is deferred until it is first used.</span></span> <span data-ttu-id="e1dee-105">(Pro toto téma jsou výrazy *opožděné inicializace* a *opožděné vytváření instancí* synonymní.) Opožděná inicializace se primárně používá ke zvýšení výkonu, vyhněte se výpočtu wasteful a snížení požadavků na paměť programu.</span><span class="sxs-lookup"><span data-stu-id="e1dee-105">(For this topic, the terms *lazy initialization* and *lazy instantiation* are synonymous.) Lazy initialization is primarily used to improve performance, avoid wasteful computation, and reduce program memory requirements.</span></span> <span data-ttu-id="e1dee-106">Jedná se o nejběžnější scénáře:</span><span class="sxs-lookup"><span data-stu-id="e1dee-106">These are the most common scenarios:</span></span>  
  
- <span data-ttu-id="e1dee-107">Pokud máte objekt, který je nákladný k vytvoření, a program ho možná nepoužije.</span><span class="sxs-lookup"><span data-stu-id="e1dee-107">When you have an object that is expensive to create, and the program might not use it.</span></span> <span data-ttu-id="e1dee-108">Předpokládejme například, že máte v paměti `Customer` objekt, který má `Orders` vlastnost, která obsahuje velké pole `Order` objektů, které mají být inicializovány, vyžaduje připojení k databázi.</span><span class="sxs-lookup"><span data-stu-id="e1dee-108">For example, assume that you have in memory a `Customer` object that has an `Orders` property that contains a large array of `Order` objects that, to be initialized, requires a database connection.</span></span> <span data-ttu-id="e1dee-109">Pokud uživatel nikdy nežádá o zobrazení objednávek nebo použití dat v rámci výpočtu, neexistuje žádný důvod k jeho vytvoření pomocí systémové paměti nebo výpočetních cyklů.</span><span class="sxs-lookup"><span data-stu-id="e1dee-109">If the user never asks to display the Orders or use the data in a computation, then there is no reason to use system memory or computing cycles to create it.</span></span> <span data-ttu-id="e1dee-110">Pomocí příkazu `Lazy<Orders>` k deklaraci `Orders` objektu pro opožděnou inicializaci se můžete vyhnout plýtvání systémových prostředků, když se objekt nepoužívá.</span><span class="sxs-lookup"><span data-stu-id="e1dee-110">By using `Lazy<Orders>` to declare the `Orders` object for lazy initialization, you can avoid wasting system resources when the object is not used.</span></span>  
  
- <span data-ttu-id="e1dee-111">Pokud máte objekt, který je nákladný k vytvoření, a chcete odložit jeho vytvoření až po dokončení dalších nákladných operací.</span><span class="sxs-lookup"><span data-stu-id="e1dee-111">When you have an object that is expensive to create, and you want to defer its creation until after other expensive operations have been completed.</span></span> <span data-ttu-id="e1dee-112">Předpokládejme například, že program při spuštění načte několik instancí objektů, ale pouze některé z nich jsou požadovány okamžitě.</span><span class="sxs-lookup"><span data-stu-id="e1dee-112">For example, assume that your program loads several object instances when it starts, but only some of them are required immediately.</span></span> <span data-ttu-id="e1dee-113">Můžete zlepšit výkon při spuštění programu odložením inicializace objektů, které nejsou požadovány, dokud nebudou vytvořeny požadované objekty.</span><span class="sxs-lookup"><span data-stu-id="e1dee-113">You can improve the startup performance of the program by deferring initialization of the objects that are not required until the required objects have been created.</span></span>  
  
 <span data-ttu-id="e1dee-114">I když můžete napsat vlastní kód pro provedení opožděné inicializace, doporučujeme <xref:System.Lazy%601> místo toho použít.</span><span class="sxs-lookup"><span data-stu-id="e1dee-114">Although you can write your own code to perform lazy initialization, we recommend that you use <xref:System.Lazy%601> instead.</span></span> <span data-ttu-id="e1dee-115"><xref:System.Lazy%601>a jeho související typy také podporují bezpečnost pro přístup z více vláken a poskytují konzistentní zásady šíření výjimek.</span><span class="sxs-lookup"><span data-stu-id="e1dee-115"><xref:System.Lazy%601> and its related types also support thread-safety and provide a consistent exception propagation policy.</span></span>  
  
 <span data-ttu-id="e1dee-116">Následující tabulka obsahuje seznam typů, které .NET Framework verze 4 poskytují pro povolení opožděné inicializace v různých scénářích.</span><span class="sxs-lookup"><span data-stu-id="e1dee-116">The following table lists the types that the .NET Framework version 4 provides to enable lazy initialization in different scenarios.</span></span>  
  
|<span data-ttu-id="e1dee-117">Typ</span><span class="sxs-lookup"><span data-stu-id="e1dee-117">Type</span></span>|<span data-ttu-id="e1dee-118">Description</span><span class="sxs-lookup"><span data-stu-id="e1dee-118">Description</span></span>|  
|----------|-----------------|  
|<xref:System.Lazy%601>|<span data-ttu-id="e1dee-119">Obálková třída, která poskytuje sémantiku opožděné inicializace pro libovolnou knihovnu tříd nebo uživatelsky definovaný typ.</span><span class="sxs-lookup"><span data-stu-id="e1dee-119">A wrapper class that provides lazy initialization semantics for any class library or user-defined type.</span></span>|  
|<xref:System.Threading.ThreadLocal%601>|<span data-ttu-id="e1dee-120">Se podobá <xref:System.Lazy%601> s tím rozdílem, že poskytuje sémantiku opožděné inicializace na místním vlákně.</span><span class="sxs-lookup"><span data-stu-id="e1dee-120">Resembles <xref:System.Lazy%601> except that it provides lazy initialization semantics on a thread-local basis.</span></span> <span data-ttu-id="e1dee-121">Každé vlákno má přístup k vlastní jedinečné hodnotě.</span><span class="sxs-lookup"><span data-stu-id="e1dee-121">Every thread has access to its own unique value.</span></span>|  
|<xref:System.Threading.LazyInitializer>|<span data-ttu-id="e1dee-122">Poskytuje pokročilé `static` ( `Shared` v Visual Basic) metody pro opožděnou inicializaci objektů bez režie třídy.</span><span class="sxs-lookup"><span data-stu-id="e1dee-122">Provides advanced `static` (`Shared` in Visual Basic) methods for lazy initialization of objects without the overhead of a class.</span></span>|  
  
## <a name="basic-lazy-initialization"></a><span data-ttu-id="e1dee-123">Základní opožděná inicializace</span><span class="sxs-lookup"><span data-stu-id="e1dee-123">Basic Lazy Initialization</span></span>  
 <span data-ttu-id="e1dee-124">Chcete-li definovat typ opožděně inicializovaného typu, například `MyType` , použijte `Lazy<MyType>` ( `Lazy(Of MyType)` v Visual Basic), jak je znázorněno v následujícím příkladu.</span><span class="sxs-lookup"><span data-stu-id="e1dee-124">To define a lazy-initialized type, for example, `MyType`, use `Lazy<MyType>` (`Lazy(Of MyType)` in Visual Basic), as shown in the following example.</span></span> <span data-ttu-id="e1dee-125">Pokud není předán žádný delegát v <xref:System.Lazy%601> konstruktoru, je vytvořen zabalený typ pomocí <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> při prvním použití vlastnosti Value.</span><span class="sxs-lookup"><span data-stu-id="e1dee-125">If no delegate is passed in the <xref:System.Lazy%601> constructor, the wrapped type is created by using <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> when the value property is first accessed.</span></span> <span data-ttu-id="e1dee-126">Pokud typ nemá konstruktor bez parametrů, je vyvolána výjimka za běhu.</span><span class="sxs-lookup"><span data-stu-id="e1dee-126">If the type does not have a parameterless constructor, a run-time exception is thrown.</span></span>  
  
 <span data-ttu-id="e1dee-127">V následujícím příkladu Předpokládejme, že `Orders` je třída, která obsahuje pole `Order` objektů načtených z databáze.</span><span class="sxs-lookup"><span data-stu-id="e1dee-127">In the following example, assume that `Orders` is a class that contains an array of `Order` objects retrieved from a database.</span></span> <span data-ttu-id="e1dee-128">`Customer`Objekt obsahuje instanci `Orders` , ale v závislosti na akcích uživatele `Orders` nemusí být potřebná data z objektu.</span><span class="sxs-lookup"><span data-stu-id="e1dee-128">A `Customer` object contains an instance of `Orders`, but depending on user actions, the data from the `Orders` object might not be required.</span></span>  
  
 [!code-csharp[Lazy#1](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#1)]
 [!code-vb[Lazy#1](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#1)]  
  
 <span data-ttu-id="e1dee-129">Můžete také předat delegáta v <xref:System.Lazy%601> konstruktoru, který vyvolá konkrétní přetížení konstruktoru pro zabalený typ při vytvoření a provést všechny další kroky inicializace, které jsou požadovány, jak je znázorněno v následujícím příkladu.</span><span class="sxs-lookup"><span data-stu-id="e1dee-129">You can also pass a delegate in the <xref:System.Lazy%601> constructor that invokes a specific constructor overload on the wrapped type at creation time, and perform any other initialization steps that are required, as shown in the following example.</span></span>  
  
 [!code-csharp[Lazy#2](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#2)]
 [!code-vb[Lazy#2](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#2)]  
  
 <span data-ttu-id="e1dee-130">Po vytvoření opožděného objektu není vytvořena žádná instance, `Orders` dokud nebude <xref:System.Lazy%601.Value%2A> poprvé k dispozici vlastnost pro opožděnou proměnnou.</span><span class="sxs-lookup"><span data-stu-id="e1dee-130">After the Lazy object is created, no instance of `Orders` is created until the <xref:System.Lazy%601.Value%2A> property of the Lazy variable is accessed for the first time.</span></span> <span data-ttu-id="e1dee-131">Při prvním přístupu se vytvoří a vrátí zabalený typ, který se uloží pro jakýkoliv budoucí přístup.</span><span class="sxs-lookup"><span data-stu-id="e1dee-131">On first access, the wrapped type is created and returned, and stored for any future access.</span></span>  
  
 [!code-csharp[Lazy#3](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#3)]
 [!code-vb[Lazy#3](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#3)]  
  
 <span data-ttu-id="e1dee-132"><xref:System.Lazy%601>Objekt vždy vrátí stejný objekt nebo hodnotu, se kterou bylo inicializováno.</span><span class="sxs-lookup"><span data-stu-id="e1dee-132">A <xref:System.Lazy%601> object always returns the same object or value that it was initialized with.</span></span> <span data-ttu-id="e1dee-133">Proto <xref:System.Lazy%601.Value%2A> je vlastnost určena pouze pro čtení.</span><span class="sxs-lookup"><span data-stu-id="e1dee-133">Therefore, the <xref:System.Lazy%601.Value%2A> property is read-only.</span></span> <span data-ttu-id="e1dee-134">Pokud <xref:System.Lazy%601.Value%2A> ukládá typ odkazu, nelze k němu přiřadit nový objekt.</span><span class="sxs-lookup"><span data-stu-id="e1dee-134">If <xref:System.Lazy%601.Value%2A> stores a reference type, you cannot assign a new object to it.</span></span> <span data-ttu-id="e1dee-135">(Můžete ale změnit hodnotu jeho nastavitelných veřejných polí a vlastností.) Pokud <xref:System.Lazy%601.Value%2A> ukládá typ hodnoty, nemůžete změnit jeho hodnotu.</span><span class="sxs-lookup"><span data-stu-id="e1dee-135">(However, you can change the value of its settable public fields and properties.) If <xref:System.Lazy%601.Value%2A> stores a value type, you cannot modify its value.</span></span> <span data-ttu-id="e1dee-136">Můžete však vytvořit novou proměnnou vyvoláním konstruktoru proměnné znovu pomocí nových argumentů.</span><span class="sxs-lookup"><span data-stu-id="e1dee-136">Nevertheless, you can create a new variable by invoking the variable constructor again by using new arguments.</span></span>  
  
 [!code-csharp[Lazy#4](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#4)]
 [!code-vb[Lazy#4](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#4)]  
  
 <span data-ttu-id="e1dee-137">Nová opožděná instance, jako je ta dřív, nevytvoří instanci, `Orders` dokud se její vlastnost nezíská <xref:System.Lazy%601.Value%2A> poprvé.</span><span class="sxs-lookup"><span data-stu-id="e1dee-137">The new lazy instance, like the earlier one, does not instantiate `Orders` until its <xref:System.Lazy%601.Value%2A> property is first accessed.</span></span>  
  
### <a name="thread-safe-initialization"></a><span data-ttu-id="e1dee-138">Inicializace bezpečná pro přístup z více vláken</span><span class="sxs-lookup"><span data-stu-id="e1dee-138">Thread-Safe Initialization</span></span>  
 <span data-ttu-id="e1dee-139">Ve výchozím nastavení <xref:System.Lazy%601> jsou objekty bezpečné pro přístup z více vláken.</span><span class="sxs-lookup"><span data-stu-id="e1dee-139">By default, <xref:System.Lazy%601> objects are thread-safe.</span></span> <span data-ttu-id="e1dee-140">To znamená, že pokud konstruktor neurčí druh zabezpečení vlákna, <xref:System.Lazy%601> objekty, které vytváří, jsou bezpečné pro přístup z více vláken.</span><span class="sxs-lookup"><span data-stu-id="e1dee-140">That is, if the constructor does not specify the kind of thread safety, the <xref:System.Lazy%601> objects it creates are thread-safe.</span></span> <span data-ttu-id="e1dee-141">Ve scénářích s více vlákny inicializuje první vlákno přístup k <xref:System.Lazy%601.Value%2A> vlastnosti objektu bezpečného pro přístup z více vláken <xref:System.Lazy%601> pro všechny následné přístupy na všechna vlákna a všechna vlákna sdílejí stejná data.</span><span class="sxs-lookup"><span data-stu-id="e1dee-141">In multi-threaded scenarios, the first thread to access the <xref:System.Lazy%601.Value%2A> property of a thread-safe <xref:System.Lazy%601> object initializes it for all subsequent accesses on all threads, and all threads share the same data.</span></span> <span data-ttu-id="e1dee-142">Proto nezáleží na tom, které vlákno inicializuje objekt a konflikty časování jsou neškodné.</span><span class="sxs-lookup"><span data-stu-id="e1dee-142">Therefore, it does not matter which thread initializes the object, and race conditions are benign.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="e1dee-143">Tuto konzistenci můžete roztáhnout na chybové podmínky pomocí ukládání výjimek do mezipaměti.</span><span class="sxs-lookup"><span data-stu-id="e1dee-143">You can extend this consistency to error conditions by using exception caching.</span></span> <span data-ttu-id="e1dee-144">Další informace naleznete v další části [výjimky v opožděných objektech](lazy-initialization.md#ExceptionsInLazyObjects).</span><span class="sxs-lookup"><span data-stu-id="e1dee-144">For more information, see the next section, [Exceptions in Lazy Objects](lazy-initialization.md#ExceptionsInLazyObjects).</span></span>  
  
 <span data-ttu-id="e1dee-145">Následující příklad ukazuje, že stejná `Lazy<int>` instance má stejnou hodnotu pro tři samostatná vlákna.</span><span class="sxs-lookup"><span data-stu-id="e1dee-145">The following example shows that the same `Lazy<int>` instance has the same value for three separate threads.</span></span>  
  
 [!code-csharp[Lazy#8](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#8)]
 [!code-vb[Lazy#8](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#8)]  
  
 <span data-ttu-id="e1dee-146">Pokud potřebujete samostatná data pro každé vlákno, použijte <xref:System.Threading.ThreadLocal%601> typ, jak je popsáno dále v tomto tématu.</span><span class="sxs-lookup"><span data-stu-id="e1dee-146">If you require separate data on each thread, use the <xref:System.Threading.ThreadLocal%601> type, as described later in this topic.</span></span>  
  
 <span data-ttu-id="e1dee-147">Některé <xref:System.Lazy%601> konstruktory mají logický parametr s názvem `isThreadSafe` , který se používá k určení, zda bude <xref:System.Lazy%601.Value%2A> k vlastnosti přicházet z více vláken.</span><span class="sxs-lookup"><span data-stu-id="e1dee-147">Some <xref:System.Lazy%601> constructors have a Boolean parameter named `isThreadSafe` that is used to specify whether the <xref:System.Lazy%601.Value%2A> property will be accessed from multiple threads.</span></span> <span data-ttu-id="e1dee-148">Pokud máte v úmyslu získat přístup k vlastnosti jenom z jednoho vlákna, předejte vám, `false` abyste získali mírné výhody výkonu.</span><span class="sxs-lookup"><span data-stu-id="e1dee-148">If you intend to access the property from just one thread, pass in `false` to obtain a modest performance benefit.</span></span> <span data-ttu-id="e1dee-149">Pokud máte v úmyslu získat přístup k vlastnosti z více vláken, přihlaste se `true` k instruování <xref:System.Lazy%601> instance pro správné zpracování konfliktů časování, ve kterých jedno vlákno vyvolá výjimku v době inicializace.</span><span class="sxs-lookup"><span data-stu-id="e1dee-149">If you intend to access the property from multiple threads, pass in `true` to instruct the <xref:System.Lazy%601> instance to correctly handle race conditions in which one thread throws an exception at initialization time.</span></span>  
  
 <span data-ttu-id="e1dee-150">Některé <xref:System.Lazy%601> konstruktory mají <xref:System.Threading.LazyThreadSafetyMode> parametr s názvem `mode` .</span><span class="sxs-lookup"><span data-stu-id="e1dee-150">Some <xref:System.Lazy%601> constructors have a <xref:System.Threading.LazyThreadSafetyMode> parameter named `mode`.</span></span> <span data-ttu-id="e1dee-151">Tyto konstruktory poskytují další režim zabezpečení vlákna.</span><span class="sxs-lookup"><span data-stu-id="e1dee-151">These constructors provide an additional thread safety mode.</span></span> <span data-ttu-id="e1dee-152">Následující tabulka ukazuje, jak je zabezpečení vlákna <xref:System.Lazy%601> objektu ovlivněno parametry konstruktoru, které určují bezpečnost vlákna.</span><span class="sxs-lookup"><span data-stu-id="e1dee-152">The following table shows how the thread safety of a <xref:System.Lazy%601> object is affected by constructor parameters that specify thread safety.</span></span> <span data-ttu-id="e1dee-153">Každý konstruktor má maximálně jeden takový parametr.</span><span class="sxs-lookup"><span data-stu-id="e1dee-153">Each constructor has at most one such parameter.</span></span>  
  
|<span data-ttu-id="e1dee-154">Bezpečnost vlákna objektu</span><span class="sxs-lookup"><span data-stu-id="e1dee-154">Thread safety of the object</span></span>|<span data-ttu-id="e1dee-155">`LazyThreadSafetyMode``mode`parametr</span><span class="sxs-lookup"><span data-stu-id="e1dee-155">`LazyThreadSafetyMode` `mode` parameter</span></span>|<span data-ttu-id="e1dee-156">Logický `isThreadSafe` parametr</span><span class="sxs-lookup"><span data-stu-id="e1dee-156">Boolean `isThreadSafe` parameter</span></span>|<span data-ttu-id="e1dee-157">Žádné parametry zabezpečení vlákna</span><span class="sxs-lookup"><span data-stu-id="e1dee-157">No thread safety parameters</span></span>|  
|---------------------------------|---------------------------------------------|--------------------------------------|---------------------------------|  
|<span data-ttu-id="e1dee-158">Plně bezpečné pro přístup z více vláken; pouze jedno vlákno v jednom okamžiku se pokusí inicializovat hodnotu.</span><span class="sxs-lookup"><span data-stu-id="e1dee-158">Fully thread-safe; only one thread at a time tries to initialize the value.</span></span>|<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>|`true`|<span data-ttu-id="e1dee-159">Ano.</span><span class="sxs-lookup"><span data-stu-id="e1dee-159">Yes.</span></span>|  
|<span data-ttu-id="e1dee-160">Není bezpečné pro přístup z více vláken.</span><span class="sxs-lookup"><span data-stu-id="e1dee-160">Not thread-safe.</span></span>|<xref:System.Threading.LazyThreadSafetyMode.None>|`false`|<span data-ttu-id="e1dee-161">Neužívá se.</span><span class="sxs-lookup"><span data-stu-id="e1dee-161">Not applicable.</span></span>|  
|<span data-ttu-id="e1dee-162">Plně bezpečné pro přístup z více vláken; vlákna mají za to, že se má inicializovat hodnota.</span><span class="sxs-lookup"><span data-stu-id="e1dee-162">Fully thread-safe; threads race to initialize the value.</span></span>|<xref:System.Threading.LazyThreadSafetyMode.PublicationOnly>|<span data-ttu-id="e1dee-163">Neužívá se.</span><span class="sxs-lookup"><span data-stu-id="e1dee-163">Not applicable.</span></span>|<span data-ttu-id="e1dee-164">Neužívá se.</span><span class="sxs-lookup"><span data-stu-id="e1dee-164">Not applicable.</span></span>|  
  
 <span data-ttu-id="e1dee-165">Jak je tabulka zobrazená, zadání <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> `mode` parametru je stejné jako zadání `true` `isThreadSafe` parametru a určení <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType> je stejné jako zadání `false` .</span><span class="sxs-lookup"><span data-stu-id="e1dee-165">As the table shows, specifying <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> for the `mode` parameter is the same as specifying `true` for the `isThreadSafe` parameter, and specifying <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType> is the same as specifying `false`.</span></span>  
  
 <span data-ttu-id="e1dee-166">Určení <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> umožňuje více vláknům pokusit se o inicializaci <xref:System.Lazy%601> instance.</span><span class="sxs-lookup"><span data-stu-id="e1dee-166">Specifying <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> allows multiple threads to attempt to initialize the <xref:System.Lazy%601> instance.</span></span> <span data-ttu-id="e1dee-167">Tuto rasy může získat pouze jeden podproces a všechna ostatní vlákna obdrží hodnotu, která byla inicializována úspěšným vláknem.</span><span class="sxs-lookup"><span data-stu-id="e1dee-167">Only one thread can win this race, and all the other threads receive the value that was initialized by the successful thread.</span></span> <span data-ttu-id="e1dee-168">Pokud je vyvolána výjimka ve vlákně během inicializace, vlákno neobdrží hodnotu nastavenou úspěšným vláknem.</span><span class="sxs-lookup"><span data-stu-id="e1dee-168">If an exception is thrown on a thread during initialization, that thread does not receive the value set by the successful thread.</span></span> <span data-ttu-id="e1dee-169">Výjimky nejsou ukládány do mezipaměti, takže při dalším pokusu o přístup k <xref:System.Lazy%601.Value%2A> vlastnosti může dojít k úspěšné inicializaci.</span><span class="sxs-lookup"><span data-stu-id="e1dee-169">Exceptions are not cached, so a subsequent attempt to access the <xref:System.Lazy%601.Value%2A> property can result in successful initialization.</span></span> <span data-ttu-id="e1dee-170">To se liší od způsobu, jakým jsou výjimky zpracovány v jiných režimech, které jsou popsány v následující části.</span><span class="sxs-lookup"><span data-stu-id="e1dee-170">This differs from the way exceptions are treated in other modes, which is described in the following section.</span></span> <span data-ttu-id="e1dee-171">Další informace najdete v tématu <xref:System.Threading.LazyThreadSafetyMode> výčet.</span><span class="sxs-lookup"><span data-stu-id="e1dee-171">For more information, see the <xref:System.Threading.LazyThreadSafetyMode> enumeration.</span></span>  
  
<a name="ExceptionsInLazyObjects"></a>
## <a name="exceptions-in-lazy-objects"></a><span data-ttu-id="e1dee-172">Výjimky v opožděných objektech</span><span class="sxs-lookup"><span data-stu-id="e1dee-172">Exceptions in Lazy Objects</span></span>  
 <span data-ttu-id="e1dee-173">Jak bylo uvedeno dříve, <xref:System.Lazy%601> objekt vždy vrátí stejný objekt nebo hodnotu, se kterou bylo inicializováno, a proto <xref:System.Lazy%601.Value%2A> je vlastnost určena pouze pro čtení.</span><span class="sxs-lookup"><span data-stu-id="e1dee-173">As stated earlier, a <xref:System.Lazy%601> object always returns the same object or value that it was initialized with, and therefore the <xref:System.Lazy%601.Value%2A> property is read-only.</span></span> <span data-ttu-id="e1dee-174">Pokud povolíte ukládání výjimek do mezipaměti, tato neměnnosti také rozšiřuje chování při výjimkách.</span><span class="sxs-lookup"><span data-stu-id="e1dee-174">If you enable exception caching, this immutability also extends to exception behavior.</span></span> <span data-ttu-id="e1dee-175">Pokud má opožděně inicializovaný objekt povolené ukládání výjimek do mezipaměti a vyvolá výjimku z své inicializační metody při <xref:System.Lazy%601.Value%2A> prvním přístupu k vlastnosti, je stejná výjimka vyvolána při každém dalším pokusu o přístup k <xref:System.Lazy%601.Value%2A> Vlastnosti.</span><span class="sxs-lookup"><span data-stu-id="e1dee-175">If a lazy-initialized object has exception caching enabled and throws an exception from its initialization method when the <xref:System.Lazy%601.Value%2A> property is first accessed, that same exception is thrown on every subsequent attempt to access the <xref:System.Lazy%601.Value%2A> property.</span></span> <span data-ttu-id="e1dee-176">Jinými slovy konstruktor zabaleného typu nikdy není znovu vyvolán ani ve scénářích s více vlákny.</span><span class="sxs-lookup"><span data-stu-id="e1dee-176">In other words, the constructor of the wrapped type is never re-invoked, even in multithreaded scenarios.</span></span> <span data-ttu-id="e1dee-177">Proto <xref:System.Lazy%601> objekt nemůže vyvolat výjimku u jednoho přístupu a vrátit hodnotu u následného přístupu.</span><span class="sxs-lookup"><span data-stu-id="e1dee-177">Therefore, the <xref:System.Lazy%601> object cannot throw an exception on one access and return a value on a subsequent access.</span></span>  
  
 <span data-ttu-id="e1dee-178">Ukládání výjimek do mezipaměti je povoleno, je-li použit libovolný <xref:System.Lazy%601?displayProperty=nameWithType> konstruktor, který přebírá metodu inicializace ( `valueFactory` parametr); například je povolen při použití `Lazy(T)(Func(T))` konstruktoru.</span><span class="sxs-lookup"><span data-stu-id="e1dee-178">Exception caching is enabled when you use any <xref:System.Lazy%601?displayProperty=nameWithType> constructor that takes an initialization method (`valueFactory` parameter); for example, it is enabled when you use the `Lazy(T)(Func(T))`constructor.</span></span> <span data-ttu-id="e1dee-179">Pokud konstruktor také převezme <xref:System.Threading.LazyThreadSafetyMode> hodnotu ( `mode` parametr), zadejte <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> nebo <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="e1dee-179">If the constructor also takes a <xref:System.Threading.LazyThreadSafetyMode> value (`mode` parameter), specify <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> or <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>.</span></span> <span data-ttu-id="e1dee-180">Zadání inicializační metody povoluje ukládání výjimek do mezipaměti pro tyto dva režimy.</span><span class="sxs-lookup"><span data-stu-id="e1dee-180">Specifying an initialization method enables exception caching for these two modes.</span></span> <span data-ttu-id="e1dee-181">Inicializační metoda může být velmi jednoduchá.</span><span class="sxs-lookup"><span data-stu-id="e1dee-181">The initialization method can be very simple.</span></span> <span data-ttu-id="e1dee-182">Například může volat konstruktor bez parametrů pro `T` : `new Lazy<Contents>(() => new Contents(), mode)` v jazyce C# nebo `New Lazy(Of Contents)(Function() New Contents())` v Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="e1dee-182">For example, it might call the parameterless constructor for `T`: `new Lazy<Contents>(() => new Contents(), mode)` in C#, or `New Lazy(Of Contents)(Function() New Contents())` in Visual Basic.</span></span> <span data-ttu-id="e1dee-183">Pokud použijete <xref:System.Lazy%601?displayProperty=nameWithType> konstruktor, který neurčuje metodu inicializace, výjimky, které jsou vyvolány konstruktor bez parametrů pro, `T` nejsou ukládány do mezipaměti.</span><span class="sxs-lookup"><span data-stu-id="e1dee-183">If you use a <xref:System.Lazy%601?displayProperty=nameWithType> constructor that does not specify an initialization method, exceptions that are thrown by the parameterless constructor for `T` are not cached.</span></span> <span data-ttu-id="e1dee-184">Další informace najdete v tématu <xref:System.Threading.LazyThreadSafetyMode> výčet.</span><span class="sxs-lookup"><span data-stu-id="e1dee-184">For more information, see the <xref:System.Threading.LazyThreadSafetyMode> enumeration.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="e1dee-185">Vytvoříte-li <xref:System.Lazy%601> objekt s `isThreadSafe` parametrem konstruktoru nastaveným na `false` nebo `mode` parametrem konstruktoru nastaveným na hodnotu <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType> , musíte získat přístup k <xref:System.Lazy%601> objektu z jednoho vlákna nebo zadat vlastní synchronizaci.</span><span class="sxs-lookup"><span data-stu-id="e1dee-185">If you create a <xref:System.Lazy%601> object with the `isThreadSafe` constructor parameter set to `false` or the `mode` constructor parameter set to <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>, you must access the <xref:System.Lazy%601> object from a single thread or provide your own synchronization.</span></span> <span data-ttu-id="e1dee-186">To platí pro všechny aspekty objektu, včetně ukládání výjimek do mezipaměti.</span><span class="sxs-lookup"><span data-stu-id="e1dee-186">This applies to all aspects of the object, including exception caching.</span></span>  
  
 <span data-ttu-id="e1dee-187">Jak je uvedeno v předchozí části, <xref:System.Lazy%601> objekty vytvořené zadáním <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> považovat výjimky odlišně.</span><span class="sxs-lookup"><span data-stu-id="e1dee-187">As noted in the previous section, <xref:System.Lazy%601> objects created by specifying <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> treat exceptions differently.</span></span> <span data-ttu-id="e1dee-188">V nástroji <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly> může více vláken konkurovat inicializaci <xref:System.Lazy%601> instance.</span><span class="sxs-lookup"><span data-stu-id="e1dee-188">With <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly>, multiple threads can compete to initialize the <xref:System.Lazy%601> instance.</span></span> <span data-ttu-id="e1dee-189">V takovém případě se výjimky neukládají do mezipaměti a pokusy o přístup k <xref:System.Lazy%601.Value%2A> vlastnosti mohou pokračovat, dokud nebude inicializace úspěšná.</span><span class="sxs-lookup"><span data-stu-id="e1dee-189">In this case, exceptions are not cached, and attempts to access the <xref:System.Lazy%601.Value%2A> property can continue until initialization is successful.</span></span>  
  
 <span data-ttu-id="e1dee-190">Následující tabulka shrnuje způsob, jakým <xref:System.Lazy%601> konstruktory řídí ukládání výjimek do mezipaměti.</span><span class="sxs-lookup"><span data-stu-id="e1dee-190">The following table summarizes the way the <xref:System.Lazy%601> constructors control exception caching.</span></span>  
  
|<span data-ttu-id="e1dee-191">Konstruktor</span><span class="sxs-lookup"><span data-stu-id="e1dee-191">Constructor</span></span>|<span data-ttu-id="e1dee-192">Režim zabezpečení vlákna</span><span class="sxs-lookup"><span data-stu-id="e1dee-192">Thread safety mode</span></span>|<span data-ttu-id="e1dee-193">Používá inicializační metodu</span><span class="sxs-lookup"><span data-stu-id="e1dee-193">Uses initialization method</span></span>|<span data-ttu-id="e1dee-194">Výjimky jsou ukládány do mezipaměti.</span><span class="sxs-lookup"><span data-stu-id="e1dee-194">Exceptions are cached</span></span>|  
|-----------------|------------------------|--------------------------------|---------------------------|  
|<span data-ttu-id="e1dee-195">Opožděné (T) ()</span><span class="sxs-lookup"><span data-stu-id="e1dee-195">Lazy(T)()</span></span>|<span data-ttu-id="e1dee-196">(<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>)</span><span class="sxs-lookup"><span data-stu-id="e1dee-196">(<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>)</span></span>|<span data-ttu-id="e1dee-197">Ne</span><span class="sxs-lookup"><span data-stu-id="e1dee-197">No</span></span>|<span data-ttu-id="e1dee-198">Ne</span><span class="sxs-lookup"><span data-stu-id="e1dee-198">No</span></span>|  
|<span data-ttu-id="e1dee-199">Opožděné (T) (Func (T))</span><span class="sxs-lookup"><span data-stu-id="e1dee-199">Lazy(T)(Func(T))</span></span>|<span data-ttu-id="e1dee-200">(<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>)</span><span class="sxs-lookup"><span data-stu-id="e1dee-200">(<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>)</span></span>|<span data-ttu-id="e1dee-201">Ano</span><span class="sxs-lookup"><span data-stu-id="e1dee-201">Yes</span></span>|<span data-ttu-id="e1dee-202">Ano</span><span class="sxs-lookup"><span data-stu-id="e1dee-202">Yes</span></span>|  
|<span data-ttu-id="e1dee-203">Opožděné (T) (Boolean)</span><span class="sxs-lookup"><span data-stu-id="e1dee-203">Lazy(T)(Boolean)</span></span>|<span data-ttu-id="e1dee-204">`True`( <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication> ) nebo `false` (<xref:System.Threading.LazyThreadSafetyMode.None>)</span><span class="sxs-lookup"><span data-stu-id="e1dee-204">`True` (<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>) or `false` (<xref:System.Threading.LazyThreadSafetyMode.None>)</span></span>|<span data-ttu-id="e1dee-205">Ne</span><span class="sxs-lookup"><span data-stu-id="e1dee-205">No</span></span>|<span data-ttu-id="e1dee-206">Ne</span><span class="sxs-lookup"><span data-stu-id="e1dee-206">No</span></span>|  
|<span data-ttu-id="e1dee-207">Opožděné (T) (Func (T), Boolean)</span><span class="sxs-lookup"><span data-stu-id="e1dee-207">Lazy(T)(Func(T), Boolean)</span></span>|<span data-ttu-id="e1dee-208">`True`( <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication> ) nebo `false` (<xref:System.Threading.LazyThreadSafetyMode.None>)</span><span class="sxs-lookup"><span data-stu-id="e1dee-208">`True` (<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>) or `false` (<xref:System.Threading.LazyThreadSafetyMode.None>)</span></span>|<span data-ttu-id="e1dee-209">Ano</span><span class="sxs-lookup"><span data-stu-id="e1dee-209">Yes</span></span>|<span data-ttu-id="e1dee-210">Ano</span><span class="sxs-lookup"><span data-stu-id="e1dee-210">Yes</span></span>|  
|<span data-ttu-id="e1dee-211">Opožděné (T) (LazyThreadSafetyMode)</span><span class="sxs-lookup"><span data-stu-id="e1dee-211">Lazy(T)(LazyThreadSafetyMode)</span></span>|<span data-ttu-id="e1dee-212">Zadáno uživatelem</span><span class="sxs-lookup"><span data-stu-id="e1dee-212">User-specified</span></span>|<span data-ttu-id="e1dee-213">Ne</span><span class="sxs-lookup"><span data-stu-id="e1dee-213">No</span></span>|<span data-ttu-id="e1dee-214">Ne</span><span class="sxs-lookup"><span data-stu-id="e1dee-214">No</span></span>|  
|<span data-ttu-id="e1dee-215">Opožděné (T) (Func (T); LazyThreadSafetyMode)</span><span class="sxs-lookup"><span data-stu-id="e1dee-215">Lazy(T)(Func(T), LazyThreadSafetyMode)</span></span>|<span data-ttu-id="e1dee-216">Zadáno uživatelem</span><span class="sxs-lookup"><span data-stu-id="e1dee-216">User-specified</span></span>|<span data-ttu-id="e1dee-217">Ano</span><span class="sxs-lookup"><span data-stu-id="e1dee-217">Yes</span></span>|<span data-ttu-id="e1dee-218">Ne, pokud uživatel zadá <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly> . v opačném případě ano.</span><span class="sxs-lookup"><span data-stu-id="e1dee-218">No if user specifies <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly>; otherwise, yes.</span></span>|  
  
## <a name="implementing-a-lazy-initialized-property"></a><span data-ttu-id="e1dee-219">Implementace opožděně inicializované vlastnosti</span><span class="sxs-lookup"><span data-stu-id="e1dee-219">Implementing a Lazy-Initialized Property</span></span>  
 <span data-ttu-id="e1dee-220">Chcete-li implementovat veřejnou vlastnost pomocí opožděné inicializace, definujte pole pro zálohování vlastnosti jako a <xref:System.Lazy%601> a vraťte <xref:System.Lazy%601.Value%2A> vlastnost z `get` přístupového objektu vlastnosti.</span><span class="sxs-lookup"><span data-stu-id="e1dee-220">To implement a public property by using lazy initialization, define the backing field of the property as a <xref:System.Lazy%601>, and return the <xref:System.Lazy%601.Value%2A> property from the `get` accessor of the property.</span></span>  
  
 [!code-csharp[Lazy#5](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#5)]
 [!code-vb[Lazy#5](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#5)]  
  
 <span data-ttu-id="e1dee-221"><xref:System.Lazy%601.Value%2A>Vlastnost je jen pro čtení; vlastnost, která ji zpřístupňuje, proto nemá `set` přístup.</span><span class="sxs-lookup"><span data-stu-id="e1dee-221">The <xref:System.Lazy%601.Value%2A> property is read-only; therefore, the property that exposes it has no `set` accessor.</span></span> <span data-ttu-id="e1dee-222">Pokud požadujete vlastnost pro čtení/zápis, kterou používá <xref:System.Lazy%601> objekt, přistupující objekt `set` musí vytvořit nový <xref:System.Lazy%601> objekt a přiřadit ho k záložnímu úložišti.</span><span class="sxs-lookup"><span data-stu-id="e1dee-222">If you require a read/write property backed by a <xref:System.Lazy%601> object, the `set` accessor must create a new <xref:System.Lazy%601> object and assign it to the backing store.</span></span> <span data-ttu-id="e1dee-223">`set`Přistupující objekt musí vytvořit lambda výraz, který vrací novou hodnotu vlastnosti, která byla předána `set` přístupovému objektu, a předat tento výraz lambda do konstruktoru nového <xref:System.Lazy%601> objektu.</span><span class="sxs-lookup"><span data-stu-id="e1dee-223">The `set` accessor must create a lambda expression that returns the new property value that was passed to the `set` accessor, and pass that lambda expression to the constructor for the new <xref:System.Lazy%601> object.</span></span> <span data-ttu-id="e1dee-224">Další přístup <xref:System.Lazy%601.Value%2A> vlastnosti způsobí inicializaci nového <xref:System.Lazy%601> a jeho <xref:System.Lazy%601.Value%2A> vlastnost pak vrátí novou hodnotu, která byla přiřazena vlastnosti.</span><span class="sxs-lookup"><span data-stu-id="e1dee-224">The next access of the <xref:System.Lazy%601.Value%2A> property will cause initialization of the new <xref:System.Lazy%601>, and its <xref:System.Lazy%601.Value%2A> property will thereafter return the new value that was assigned to the property.</span></span> <span data-ttu-id="e1dee-225">Důvodem pro toto konvoluce je zachování ochrany s více vlákny, které jsou integrované v <xref:System.Lazy%601> .</span><span class="sxs-lookup"><span data-stu-id="e1dee-225">The reason for this convoluted arrangement is to preserve the multithreading protections built into <xref:System.Lazy%601>.</span></span> <span data-ttu-id="e1dee-226">V opačném případě by přistupující objekty vlastnosti musely ukládat do mezipaměti první hodnotu vrácenou <xref:System.Lazy%601.Value%2A> vlastností a upravovat pouze hodnotu uloženou v mezipaměti, a k tomu byste museli napsat vlastní kód bezpečný pro přístup z více vláken.</span><span class="sxs-lookup"><span data-stu-id="e1dee-226">Otherwise, the property accessors would have to cache the first value returned by the <xref:System.Lazy%601.Value%2A> property and only modify the cached value, and you would have to write your own thread-safe code to do that.</span></span> <span data-ttu-id="e1dee-227">Kvůli dalším inicializacím, které vyžaduje vlastnost pro čtení a zápis zálohovanou <xref:System.Lazy%601> objektem, nemusí být výkon přijatelný.</span><span class="sxs-lookup"><span data-stu-id="e1dee-227">Because of the additional initializations required by a read/write property backed by a <xref:System.Lazy%601> object, the performance might not be acceptable.</span></span> <span data-ttu-id="e1dee-228">V závislosti na konkrétním scénáři se navíc může vyžadovat další koordinace, aby nedocházelo ke konfliktům mezi metodami setter a getter.</span><span class="sxs-lookup"><span data-stu-id="e1dee-228">Furthermore, depending on the specific scenario, additional coordination might be required to avoid race conditions between setters and getters.</span></span>  
  
## <a name="thread-local-lazy-initialization"></a><span data-ttu-id="e1dee-229">Opožděná inicializace místního vlákna</span><span class="sxs-lookup"><span data-stu-id="e1dee-229">Thread-Local Lazy Initialization</span></span>  
 <span data-ttu-id="e1dee-230">V některých scénářích s více vlákny můžete chtít každému vláknu poskytnout vlastní privátní data.</span><span class="sxs-lookup"><span data-stu-id="e1dee-230">In some multithreaded scenarios, you might want to give each thread its own private data.</span></span> <span data-ttu-id="e1dee-231">Tato data se nazývají *místní data vlákna*.</span><span class="sxs-lookup"><span data-stu-id="e1dee-231">Such data is called *thread-local data*.</span></span> <span data-ttu-id="e1dee-232">V .NET Framework verze 3,5 a starší můžete použít `ThreadStatic` atribut na statickou proměnnou a nastavit tak místní vlákno.</span><span class="sxs-lookup"><span data-stu-id="e1dee-232">In the .NET Framework version 3.5 and earlier, you could apply the `ThreadStatic` attribute to a static variable to make it thread-local.</span></span> <span data-ttu-id="e1dee-233">Použití `ThreadStatic` atributu však může vést k drobným chybám.</span><span class="sxs-lookup"><span data-stu-id="e1dee-233">However, using the `ThreadStatic` attribute can lead to subtle errors.</span></span> <span data-ttu-id="e1dee-234">Například dokonce základní inicializační příkazy způsobí, že proměnná bude inicializována pouze v prvním vlákně, která k němu přistupuje, jak je znázorněno v následujícím příkladu.</span><span class="sxs-lookup"><span data-stu-id="e1dee-234">For example, even basic initialization statements will cause the variable to be initialized only on the first thread that accesses it, as shown in the following example.</span></span>  
  
 [!code-csharp[Lazy#6](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#6)]
 [!code-vb[Lazy#6](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#6)]  
  
 <span data-ttu-id="e1dee-235">Ve všech ostatních vláknech bude proměnná inicializována pomocí výchozí hodnoty (nula).</span><span class="sxs-lookup"><span data-stu-id="e1dee-235">On all other threads, the variable will be initialized by using its default value (zero).</span></span> <span data-ttu-id="e1dee-236">Jako alternativu ve verzi .NET Framework 4 můžete použít <xref:System.Threading.ThreadLocal%601?displayProperty=nameWithType> typ k vytvoření místní proměnné vlákna na základě instance, která je inicializována na všech vláknech <xref:System.Action%601> , které poskytuje delegát.</span><span class="sxs-lookup"><span data-stu-id="e1dee-236">As an alternative in the .NET Framework version 4, you can use the <xref:System.Threading.ThreadLocal%601?displayProperty=nameWithType> type to create an instance-based, thread-local variable that is initialized on all threads by the <xref:System.Action%601> delegate that you provide.</span></span> <span data-ttu-id="e1dee-237">V následujícím příkladu všechna vlákna, která přistupuje k, uvidí `counter` počáteční hodnotu jako 1.</span><span class="sxs-lookup"><span data-stu-id="e1dee-237">In the following example, all threads that access `counter` will see its starting value as 1.</span></span>  
  
 [!code-csharp[Lazy#7](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#7)]
 [!code-vb[Lazy#7](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#7)]  
  
 <span data-ttu-id="e1dee-238"><xref:System.Threading.ThreadLocal%601>zalomí svůj objekt podobným způsobem jako <xref:System.Lazy%601> s těmito základními rozdíly:</span><span class="sxs-lookup"><span data-stu-id="e1dee-238"><xref:System.Threading.ThreadLocal%601> wraps its object in much the same way as <xref:System.Lazy%601>, with these essential differences:</span></span>  
  
- <span data-ttu-id="e1dee-239">Každé vlákno inicializuje místní proměnnou vlákna pomocí vlastních privátních dat, která nejsou přístupná z jiných vláken.</span><span class="sxs-lookup"><span data-stu-id="e1dee-239">Each thread initializes the thread-local variable by using its own private data that is not accessible from other threads.</span></span>  
  
- <span data-ttu-id="e1dee-240"><xref:System.Threading.ThreadLocal%601.Value%2A?displayProperty=nameWithType>Vlastnost je určena pro čtení i zápis a lze ji změnit libovolným počtem opakování.</span><span class="sxs-lookup"><span data-stu-id="e1dee-240">The <xref:System.Threading.ThreadLocal%601.Value%2A?displayProperty=nameWithType> property is read-write, and can be modified any number of times.</span></span> <span data-ttu-id="e1dee-241">To může mít vliv na šíření výjimek, například jedna `get` operace může vyvolat výjimku, ale další může úspěšně inicializovat hodnotu.</span><span class="sxs-lookup"><span data-stu-id="e1dee-241">This can affect exception propagation, for example, one `get` operation can raise an exception but the next one can successfully initialize the value.</span></span>  
  
- <span data-ttu-id="e1dee-242">Pokud není k dispozici žádný delegát inicializace, <xref:System.Threading.ThreadLocal%601> inicializuje zabalený typ pomocí výchozí hodnoty typu.</span><span class="sxs-lookup"><span data-stu-id="e1dee-242">If no initialization delegate is provided, <xref:System.Threading.ThreadLocal%601> will initialize its wrapped type by using the default value of the type.</span></span> <span data-ttu-id="e1dee-243">V tomto ohledu <xref:System.Threading.ThreadLocal%601> je konzistentní s <xref:System.ThreadStaticAttribute> atributem.</span><span class="sxs-lookup"><span data-stu-id="e1dee-243">In this regard, <xref:System.Threading.ThreadLocal%601> is consistent with the <xref:System.ThreadStaticAttribute> attribute.</span></span>  
  
 <span data-ttu-id="e1dee-244">Následující příklad ukazuje, že každé vlákno, které přistupuje k `ThreadLocal<int>` instanci, získá svou vlastní jedinečnou kopii dat.</span><span class="sxs-lookup"><span data-stu-id="e1dee-244">The following example demonstrates that every thread that accesses the `ThreadLocal<int>` instance gets its own unique copy of the data.</span></span>  
  
 [!code-csharp[Lazy#9](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#9)]
 [!code-vb[Lazy#9](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#9)]  
  
## <a name="thread-local-variables-in-parallelfor-and-foreach"></a><span data-ttu-id="e1dee-245">Místní proměnné vlákna paralelně. for a ForEach</span><span class="sxs-lookup"><span data-stu-id="e1dee-245">Thread-Local Variables in Parallel.For and ForEach</span></span>  
 <span data-ttu-id="e1dee-246">Použijete-li <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> metodu nebo <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> metodu pro iteraci zdrojů dat paralelně, můžete použít přetížení, která mají integrovanou podporu pro místní data vlákna.</span><span class="sxs-lookup"><span data-stu-id="e1dee-246">When you use the <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> method or <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> method to iterate over data sources in parallel, you can use the overloads that have built-in support for thread-local data.</span></span> <span data-ttu-id="e1dee-247">V těchto metodách je možné dosáhnout lokálního vlákna pomocí místních delegátů k vytváření, přístupu a vyčištění dat.</span><span class="sxs-lookup"><span data-stu-id="e1dee-247">In these methods, the thread-locality is achieved by using local delegates to create, access, and clean up the data.</span></span> <span data-ttu-id="e1dee-248">Další informace naleznete v tématu [How to: Write a Parallel. for smyčke s proměnnými místními vlákny](../../standard/parallel-programming/how-to-write-a-parallel-for-loop-with-thread-local-variables.md) a [How to: napište smyčku Parallel. ForEach s proměnnými místně na oddíl](../../standard/parallel-programming/how-to-write-a-parallel-foreach-loop-with-partition-local-variables.md).</span><span class="sxs-lookup"><span data-stu-id="e1dee-248">For more information, see [How to: Write a Parallel.For Loop with Thread-Local Variables](../../standard/parallel-programming/how-to-write-a-parallel-for-loop-with-thread-local-variables.md) and [How to: Write a Parallel.ForEach Loop with Partition-Local Variables](../../standard/parallel-programming/how-to-write-a-parallel-foreach-loop-with-partition-local-variables.md).</span></span>  
  
## <a name="using-lazy-initialization-for-low-overhead-scenarios"></a><span data-ttu-id="e1dee-249">Použití opožděné inicializace pro scénáře s nízkou režií</span><span class="sxs-lookup"><span data-stu-id="e1dee-249">Using Lazy Initialization for Low-Overhead Scenarios</span></span>  
 <span data-ttu-id="e1dee-250">Ve scénářích, kdy je nutné provést opožděnou inicializaci velkého počtu objektů, se můžete rozhodnout, že balení každého objektu v <xref:System.Lazy%601> vyžaduje příliš mnoho paměti nebo příliš mnoho výpočetních prostředků.</span><span class="sxs-lookup"><span data-stu-id="e1dee-250">In scenarios where you have to lazy-initialize a large number of objects, you might decide that wrapping each object in a <xref:System.Lazy%601> requires too much memory or too many computing resources.</span></span> <span data-ttu-id="e1dee-251">Nebo je možné, že máte přísné požadavky na to, jak je k dispozici opožděná inicializace.</span><span class="sxs-lookup"><span data-stu-id="e1dee-251">Or, you might have stringent requirements about how lazy initialization is exposed.</span></span> <span data-ttu-id="e1dee-252">V takových případech můžete použít `static` `Shared` metody (v Visual Basic) <xref:System.Threading.LazyInitializer?displayProperty=nameWithType> třídy k opožděné inicializaci každého objektu bez jeho zabalení v instanci <xref:System.Lazy%601> .</span><span class="sxs-lookup"><span data-stu-id="e1dee-252">In such cases, you can use the `static` (`Shared` in Visual Basic) methods of the <xref:System.Threading.LazyInitializer?displayProperty=nameWithType> class to lazy-initialize each object without wrapping it in an instance of <xref:System.Lazy%601>.</span></span>  
  
 <span data-ttu-id="e1dee-253">V následujícím příkladu Předpokládejme, že namísto zalamování celého `Orders` objektu v jednom <xref:System.Lazy%601> objektu máte opožděně inicializované jednotlivé `Order` objekty pouze v případě, že jsou požadovány.</span><span class="sxs-lookup"><span data-stu-id="e1dee-253">In the following example, assume that, instead of wrapping an entire `Orders` object in one <xref:System.Lazy%601> object, you have lazy-initialized individual `Order` objects only if they are required.</span></span>  
  
 [!code-csharp[Lazy#10](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#10)]
 [!code-vb[Lazy#10](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#10)]  
  
 <span data-ttu-id="e1dee-254">V tomto příkladu si všimněte, že inicializační proceduru je vyvolána při každé iteraci smyčky.</span><span class="sxs-lookup"><span data-stu-id="e1dee-254">In this example, notice that the initialization procedure is invoked on every iteration of the loop.</span></span> <span data-ttu-id="e1dee-255">Ve scénářích s více vlákny je prvním vláknem vyvolání inicializační procedury ta, jejíž hodnota je zobrazena ve všech vláknech.</span><span class="sxs-lookup"><span data-stu-id="e1dee-255">In multi-threaded scenarios, the first thread to invoke the initialization procedure is the one whose value is seen by all threads.</span></span> <span data-ttu-id="e1dee-256">Novější vlákna také vyvolávají inicializační proceduru, ale jejich výsledky se nepoužívají.</span><span class="sxs-lookup"><span data-stu-id="e1dee-256">Later threads also invoke the initialization procedure, but their results are not used.</span></span> <span data-ttu-id="e1dee-257">Pokud tento druh potenciální časování není přijatelný, použijte přetížení <xref:System.Threading.LazyInitializer.EnsureInitialized%2A?displayProperty=nameWithType> , které přijímá logický argument a synchronizační objekt.</span><span class="sxs-lookup"><span data-stu-id="e1dee-257">If this kind of potential race condition is not acceptable, use the overload of <xref:System.Threading.LazyInitializer.EnsureInitialized%2A?displayProperty=nameWithType> that takes a Boolean argument and a synchronization object.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="e1dee-258">Viz také</span><span class="sxs-lookup"><span data-stu-id="e1dee-258">See also</span></span>

- [<span data-ttu-id="e1dee-259">Základy dělení na spravovaná vlákna</span><span class="sxs-lookup"><span data-stu-id="e1dee-259">Managed Threading Basics</span></span>](../../standard/threading/managed-threading-basics.md)
- [<span data-ttu-id="e1dee-260">Vlákna a dělení na vlákna</span><span class="sxs-lookup"><span data-stu-id="e1dee-260">Threads and Threading</span></span>](../../standard/threading/threads-and-threading.md)
- [<span data-ttu-id="e1dee-261">Task Parallel Library (TPL)</span><span class="sxs-lookup"><span data-stu-id="e1dee-261">Task Parallel Library (TPL)</span></span>](../../standard/parallel-programming/task-parallel-library-tpl.md)
- [<span data-ttu-id="e1dee-262">Postupy: Provádění opožděné inicializace objektů</span><span class="sxs-lookup"><span data-stu-id="e1dee-262">How to: Perform Lazy Initialization of Objects</span></span>](how-to-perform-lazy-initialization-of-objects.md)
