---
title: Spolehlivost – doporučené postupy
description: Podívejte se na osvědčené postupy pro zajištění spolehlivosti v serverových aplikacích založených na hostitelích .NET, jako je například SQL Server. Zabránit v jejich nevracení prostředků nebo při nedostatku.
ms.date: 03/30/2017
helpviewer_keywords:
- marking locks
- rebooting databases
- denial of service attacks
- back-out code
- SQL Server [.NET Framework], reliability
- synchronization, reliability
- single-threaded COM components
- slow leaks
- suspending threads
- asynchronous exception handling
- leaked resources [.NET Framework]
- unmanaged memory
- memory, reliability
- threading [.NET Framework], reliability
- process-wide domain shared states
- shared states
- SafeHandle class, reliability
- reliability contracts [.NET Framework]
- cleanup operations
- constrained execution regions
- CERs
- finalizers, reliability
- reliability [.NET Framework]
- blocks, reliability
- finally clauses
- cross-application domain shared states
- catch blocks
- identifying locks
- writing reliable code
- impersonation
- GC.KeepAlive method
- managed threading
- locks, reliability
- STA-dependent features
- fibers
ms.assetid: cf624c1f-c160-46a1-bb2b-213587688da7
ms.openlocfilehash: 134b71153f95dffd4525f307d291ce4389e0ce60
ms.sourcegitcommit: cf5a800a33de64d0aad6d115ffcc935f32375164
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 07/20/2020
ms.locfileid: "86474238"
---
# <a name="reliability-best-practices"></a><span data-ttu-id="18e03-104">Spolehlivost – doporučené postupy</span><span class="sxs-lookup"><span data-stu-id="18e03-104">Reliability Best Practices</span></span>

<span data-ttu-id="18e03-105">Následující pravidla spolehlivosti se orientují na SQL Server; vztahují se ale také na všechny serverové aplikace založené na hostiteli.</span><span class="sxs-lookup"><span data-stu-id="18e03-105">The following reliability rules are oriented to SQL Server; however, they also apply to any host-based server application.</span></span> <span data-ttu-id="18e03-106">Je velmi důležité, aby servery, jako SQL Server, neunikly prostředky a nemohly být zavedeny.</span><span class="sxs-lookup"><span data-stu-id="18e03-106">It is extremely important that servers such as SQL Server not leak resources and not be brought down.</span></span>  <span data-ttu-id="18e03-107">To však nelze provést zápisem zpětného zápisu kódu pro každou metodu, která mění stav objektu.</span><span class="sxs-lookup"><span data-stu-id="18e03-107">However, that cannot be done by writing back-out code for every method that alters an object’s state.</span></span>  <span data-ttu-id="18e03-108">Cílem není zapsat 100% spolehlivého spravovaného kódu, který se bude obnovovat ze všech chyb v každém umístění s back-výstupním kódem.</span><span class="sxs-lookup"><span data-stu-id="18e03-108">The goal is not to write 100 percent reliable managed code that will recover from any errors in every location with back-out code.</span></span>  <span data-ttu-id="18e03-109">To by byl úkol těžké s nízkou pravděpodobností úspěchu.</span><span class="sxs-lookup"><span data-stu-id="18e03-109">That would be a daunting task with little chance of success.</span></span>  <span data-ttu-id="18e03-110">Modul CLR (Common Language Runtime) nemůže snadno poskytnout dostatečně velkou záruku pro spravovaný kód, aby bylo možné psát dokonalý kód.</span><span class="sxs-lookup"><span data-stu-id="18e03-110">The common language runtime (CLR) cannot easily provide strong enough guarantees to managed code to make writing perfect code feasible.</span></span>  <span data-ttu-id="18e03-111">Všimněte si, že na rozdíl od ASP.NET SQL Server používá pouze jeden proces, který nelze recyklovat, aniž by došlo k nepřijatelně dlouhé době databáze.</span><span class="sxs-lookup"><span data-stu-id="18e03-111">Note that unlike ASP.NET, SQL Server uses only one process that cannot be recycled without taking a database down for an unacceptably long time.</span></span>

<span data-ttu-id="18e03-112">S těmito slabšími zárukami a provozováním v jednom procesu je spolehlivost založena na ukončení vláken nebo recyklace domén aplikace, pokud je to nutné, a přijímá opatření k zajištění toho, aby prostředky operačního systému, jako jsou například popisovače nebo paměť, nebyly Nevráceny.</span><span class="sxs-lookup"><span data-stu-id="18e03-112">With these weaker guarantees and running in a single process, reliability is based on terminating threads or recycling application domains when necessary and taking precautions to ensure operating system resources such as handles or memory are not leaked.</span></span>  <span data-ttu-id="18e03-113">I s tímto jednodušším omezením spolehlivosti stále platí významný požadavek na spolehlivost:</span><span class="sxs-lookup"><span data-stu-id="18e03-113">Even with this simpler reliability constraint, there is still a significant reliability requirement:</span></span>

- <span data-ttu-id="18e03-114">Nikdy neúnik prostředků operačního systému.</span><span class="sxs-lookup"><span data-stu-id="18e03-114">Never leak operating system resources.</span></span>

- <span data-ttu-id="18e03-115">Identifikujte všechny spravované zámky ve všech formulářích pro CLR.</span><span class="sxs-lookup"><span data-stu-id="18e03-115">Identify all managed locks in all forms to the CLR.</span></span>

- <span data-ttu-id="18e03-116">Nikdy Nerušit sdílený stav domény mezi aplikacemi, což umožňuje <xref:System.AppDomain> hladce pracovat v recyklaci.</span><span class="sxs-lookup"><span data-stu-id="18e03-116">Never break cross-application domain shared state, allowing <xref:System.AppDomain> recycling to function smoothly.</span></span>

<span data-ttu-id="18e03-117">I když je teoreticky možné napsat spravovaný kód pro zpracování <xref:System.Threading.ThreadAbortException> výjimek, <xref:System.StackOverflowException> a <xref:System.OutOfMemoryException> , očekávají vývojářům, aby takový robustní kód napsal v celé aplikaci, je nepřípustný.</span><span class="sxs-lookup"><span data-stu-id="18e03-117">Although it is theoretically possible to write managed code to handle <xref:System.Threading.ThreadAbortException>, <xref:System.StackOverflowException>, and <xref:System.OutOfMemoryException> exceptions, expecting developers to write such robust code throughout an entire application is unreasonable.</span></span>  <span data-ttu-id="18e03-118">Z tohoto důvodu vyplývají z nedostatku pásma vykonávání zpracovávaného vlákna; a pokud ukončené vlákno upravovalo sdílený stav, což může být určeno, zda vlákno drží zámek, pak <xref:System.AppDomain> dojde k uvolnění.</span><span class="sxs-lookup"><span data-stu-id="18e03-118">For that reason, out-of-band exceptions result in the executing thread being terminated; and if the terminated thread was editing shared state, which can be determined by whether the thread holds a lock, then the <xref:System.AppDomain> is unloaded.</span></span>  <span data-ttu-id="18e03-119">Když je metoda, která upravuje sdílený stav, ukončená, stav bude poškozený, protože není možné zapsat spolehlivý back-výstupní kód pro aktualizace do sdíleného stavu.</span><span class="sxs-lookup"><span data-stu-id="18e03-119">When a method that is editing shared state is terminated, the state will be corrupt because it is not possible to write reliable back-out code for updates to shared state.</span></span>

<span data-ttu-id="18e03-120">V .NET Framework verze 2,0 je jediným hostitelem, který vyžaduje spolehlivost, SQL Server.</span><span class="sxs-lookup"><span data-stu-id="18e03-120">In the .NET Framework version 2.0, the only host that requires reliability is SQL Server.</span></span>  <span data-ttu-id="18e03-121">Pokud bude vaše sestavení spuštěno na SQL Server měli byste provádět spolehlivost v každé části tohoto sestavení, a to i v případě, že existují konkrétní funkce, které jsou při spuštění v databázi zakázané.</span><span class="sxs-lookup"><span data-stu-id="18e03-121">If your assembly will be run on SQL Server you should do the reliability work for every part of that assembly, even if there are specific features that are disabled when running in the database.</span></span>  <span data-ttu-id="18e03-122">To je vyžadováno, protože modul pro analýzu kódu kontroluje kód na úrovni sestavení a nemůže odlišit zakázaný kód.</span><span class="sxs-lookup"><span data-stu-id="18e03-122">This is required because the code analysis engine examines code at the assembly level and cannot differentiate disabled code.</span></span> <span data-ttu-id="18e03-123">Dalším aspektem SQL Server programování je to, že SQL Server spouští vše v jednom procesu a <xref:System.AppDomain> recyklace se používá pro vyčištění všech prostředků, jako jsou například obslužné rutiny paměti a operačního systému.</span><span class="sxs-lookup"><span data-stu-id="18e03-123">Another SQL Server programming consideration is that SQL Server runs everything in one process, and <xref:System.AppDomain> recycling is used for cleaning up all resources such as memory and operating system handles.</span></span>

<span data-ttu-id="18e03-124">Nemůžete záviset na finalizační nebo destruktorech nebo `try/finally` blocích pro back-výstupní kód.</span><span class="sxs-lookup"><span data-stu-id="18e03-124">You cannot depend on finalizers or destructors or `try/finally` blocks for back-out code.</span></span> <span data-ttu-id="18e03-125">Mohou být přerušeny nebo volány.</span><span class="sxs-lookup"><span data-stu-id="18e03-125">They might be interrupted or not called.</span></span>

<span data-ttu-id="18e03-126">Asynchronní výjimky lze vyvolat v neočekávaných umístěních, případně v každé instrukci počítače: <xref:System.Threading.ThreadAbortException> , <xref:System.StackOverflowException> a <xref:System.OutOfMemoryException> .</span><span class="sxs-lookup"><span data-stu-id="18e03-126">Asynchronous exceptions can be thrown in unexpected locations, possibly every machine instruction: <xref:System.Threading.ThreadAbortException>, <xref:System.StackOverflowException>, and <xref:System.OutOfMemoryException>.</span></span>

<span data-ttu-id="18e03-127">Spravovaná vlákna nejsou nutně vlákny Win32 v SQL; můžou být vlákny.</span><span class="sxs-lookup"><span data-stu-id="18e03-127">Managed threads are not necessarily Win32 threads in SQL; they might be fibers.</span></span>

<span data-ttu-id="18e03-128">Proměnlivý sdílený stav domény v úrovni procesu nebo meziaplikace je velmi obtížně pozměňován a je třeba se jim vyhnout, kdykoli je to možné.</span><span class="sxs-lookup"><span data-stu-id="18e03-128">Process-wide or cross-application domain mutable shared state is extremely difficult to alter safely and should be avoided whenever possible.</span></span>

<span data-ttu-id="18e03-129">Podmínky nedostatku paměti nejsou v SQL Server zřídka.</span><span class="sxs-lookup"><span data-stu-id="18e03-129">Out-of-memory conditions are not rare in SQL Server.</span></span>

<span data-ttu-id="18e03-130">Pokud knihovny hostované v SQL Server správně neaktualizují svůj sdílený stav, je vysoká pravděpodobnost, že kód nebude obnoven, dokud nebude databáze restartována.</span><span class="sxs-lookup"><span data-stu-id="18e03-130">If libraries hosted in SQL Server do not correctly update their shared state, there is a high probability that the code will not recover until the database has been restarted.</span></span>  <span data-ttu-id="18e03-131">V některých extrémních případech to může způsobit selhání procesu SQL Server, což způsobí, že se databáze restartuje.</span><span class="sxs-lookup"><span data-stu-id="18e03-131">Additionally, in some extreme cases, it is possible this might cause the SQL Server process to fail, causing the database to reboot.</span></span>  <span data-ttu-id="18e03-132">Restartování databáze může převzít web nebo ovlivnit operace společnosti, neubližujeme dostupnost.</span><span class="sxs-lookup"><span data-stu-id="18e03-132">Rebooting the database can take down a Web site or affect company operations, hurting availability.</span></span>  <span data-ttu-id="18e03-133">Pomalé úniky prostředků operačního systému, jako je například paměť nebo popisovače, může způsobit, že server nakonec selže při přidělování popisovačů bez možnosti obnovení, nebo může server pomalu snížit výkon a snižuje dostupnost aplikace zákazníka.</span><span class="sxs-lookup"><span data-stu-id="18e03-133">A slow leak of operating system resources such as memory or handles may cause the server to eventually fail allocating handles with no possibility of recovery, or potentially the server may slowly degrade in performance and reduces a customer’s application availability.</span></span>  <span data-ttu-id="18e03-134">Jasně chceme, abyste se vyhnuli těmto scénářům.</span><span class="sxs-lookup"><span data-stu-id="18e03-134">Clearly we want to avoid these scenarios.</span></span>

## <a name="best-practice-rules"></a><span data-ttu-id="18e03-135">Pravidla osvědčených postupů</span><span class="sxs-lookup"><span data-stu-id="18e03-135">Best practice rules</span></span>

<span data-ttu-id="18e03-136">Úvod se zaměřuje na to, co kontrola kódu pro spravovaný kód, který běží na serveru, by musela zachytit, aby se zvýšila stabilita a spolehlivost rozhraní.</span><span class="sxs-lookup"><span data-stu-id="18e03-136">The introduction focused on what the code review for the managed code that runs in the server would have to catch to increase the stability and reliability of the framework.</span></span> <span data-ttu-id="18e03-137">Všechny tyto kontroly jsou obecně osvědčené a na serveru musí být absolutní.</span><span class="sxs-lookup"><span data-stu-id="18e03-137">All these checks are good practice in general and an absolute must on the server.</span></span>

<span data-ttu-id="18e03-138">V případě nedoručeného zámku nebo omezení prostředku SQL Server přeruší vlákno nebo odhlásí <xref:System.AppDomain> .</span><span class="sxs-lookup"><span data-stu-id="18e03-138">In the face of a dead lock or resource constraint, SQL Server will abort a thread or tear down an <xref:System.AppDomain>.</span></span>  <span data-ttu-id="18e03-139">Pokud k tomu dojde, je zaručeno spuštění pouze back-výstupních kódů v oblasti s omezením spuštění (CER).</span><span class="sxs-lookup"><span data-stu-id="18e03-139">When this happens, only back-out code in a constrained execution region (CER) is guaranteed to be run.</span></span>

### <a name="use-safehandle-to-avoid-resource-leaks"></a><span data-ttu-id="18e03-140">Použití třídy SafeHandle k zamezení nevracení prostředků</span><span class="sxs-lookup"><span data-stu-id="18e03-140">Use SafeHandle to avoid resource leaks</span></span>

<span data-ttu-id="18e03-141">V případě <xref:System.AppDomain> uvolnění nemůžete záviset na `finally` blocích nebo finalizační metody, takže je důležité, aby byl veškerý přístup k prostředkům operačního systému abstraktní prostřednictvím <xref:System.Runtime.InteropServices.SafeHandle> třídy spíše než <xref:System.IntPtr> , <xref:System.Runtime.InteropServices.HandleRef> nebo podobných tříd.</span><span class="sxs-lookup"><span data-stu-id="18e03-141">In the case of an <xref:System.AppDomain> unload, you cannot depend on `finally` blocks or finalizers being executed, so it is important to abstract all operating system resource access through the <xref:System.Runtime.InteropServices.SafeHandle> class rather than <xref:System.IntPtr>, <xref:System.Runtime.InteropServices.HandleRef>, or similar classes.</span></span> <span data-ttu-id="18e03-142">To umožňuje, aby modul CLR sledoval a zavřel táhla, která používáte, i v <xref:System.AppDomain> případě nenáročného případu.</span><span class="sxs-lookup"><span data-stu-id="18e03-142">This allows the CLR to track and close the handles you use even in the <xref:System.AppDomain> tear-down case.</span></span>  <span data-ttu-id="18e03-143"><xref:System.Runtime.InteropServices.SafeHandle>bude používat kritický finalizační metodu, kterou bude modul CLR vždy spuštěn.</span><span class="sxs-lookup"><span data-stu-id="18e03-143"><xref:System.Runtime.InteropServices.SafeHandle> will be using a critical finalizer which the CLR will always run.</span></span>

<span data-ttu-id="18e03-144">Popisovač operačního systému je uložen v bezpečném popisovači od okamžiku, kdy je vytvořen až do chvíle, kdy se uvolnil.</span><span class="sxs-lookup"><span data-stu-id="18e03-144">The operating system handle is stored in the safe handle from the moment it is created until the moment it is released.</span></span>  <span data-ttu-id="18e03-145">Neexistuje žádné okno, ve kterém by <xref:System.Threading.ThreadAbortException> mohlo dojít k úniku popisovačů.</span><span class="sxs-lookup"><span data-stu-id="18e03-145">There is no window during which a <xref:System.Threading.ThreadAbortException> can occur to leak a handle.</span></span>  <span data-ttu-id="18e03-146">Kromě toho vyvolá vyvolání platformy odkaz – vyhodnotí popisovač, který umožňuje zavřít sledování životnosti popisovače a zabránit bezpečnostnímu problému s podmínkou časování mezi `Dispose` a metodou, která aktuálně používá popisovač.</span><span class="sxs-lookup"><span data-stu-id="18e03-146">Additionally, platform invoke will reference-count the handle, which allows close tracking of the lifetime of the handle, preventing a security issue with a race condition between `Dispose` and a method that is currently using the handle.</span></span>

<span data-ttu-id="18e03-147">Většina tříd, které v současné době mají finalizační metodu pro jednoduše vyčištění popisovače operačního systému, nebude potřebovat finalizační metodu.</span><span class="sxs-lookup"><span data-stu-id="18e03-147">Most classes that currently have a finalizer to simply clean up an operating system handle will not need the finalizer anymore.</span></span> <span data-ttu-id="18e03-148">Místo toho bude finalizační metoda na <xref:System.Runtime.InteropServices.SafeHandle> odvozené třídě.</span><span class="sxs-lookup"><span data-stu-id="18e03-148">Instead, the finalizer will be on the <xref:System.Runtime.InteropServices.SafeHandle> derived class.</span></span>

<span data-ttu-id="18e03-149">Všimněte si, že není <xref:System.Runtime.InteropServices.SafeHandle> náhradou za <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="18e03-149">Note that <xref:System.Runtime.InteropServices.SafeHandle> is not a replacement for <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>.</span></span>  <span data-ttu-id="18e03-150">Stále existují potenciální problémy s kolizem prostředků a výkonem, aby bylo možné explicitně uvolnit prostředky operačního systému.</span><span class="sxs-lookup"><span data-stu-id="18e03-150">There are still potential resource contention and performance advantages to explicitly dispose operating system resources.</span></span>  <span data-ttu-id="18e03-151">Stačí si uvědomit, že `finally` bloky, které explicitně odstraňují prostředky, se nemusí provádět k dokončení.</span><span class="sxs-lookup"><span data-stu-id="18e03-151">Just realize that `finally` blocks that do explicitly dispose of resources may not execute to completion.</span></span>

<span data-ttu-id="18e03-152"><xref:System.Runtime.InteropServices.SafeHandle>umožňuje implementovat vlastní <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> metodu, která provede práci k uvolnění popisovače, jako je například předání stavu do rutiny pro uvolnění operačního systému nebo uvolnění sady popisovačů ve smyčce.</span><span class="sxs-lookup"><span data-stu-id="18e03-152"><xref:System.Runtime.InteropServices.SafeHandle> allows you to implement your own <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method that performs the work to free the handle, such as passing state to an operating system handle freeing routine or freeing a set of handles in a loop.</span></span>  <span data-ttu-id="18e03-153">Modul CLR garantuje, že je tato metoda spuštěna.</span><span class="sxs-lookup"><span data-stu-id="18e03-153">The CLR guarantees that this method is run.</span></span>  <span data-ttu-id="18e03-154">Je zodpovědností autora <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> implementace, aby bylo zajištěno, že se popisovač uvolní za všech okolností.</span><span class="sxs-lookup"><span data-stu-id="18e03-154">It is the responsibility of the author of the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> implementation to ensure that the handle is released in all circumstances.</span></span> <span data-ttu-id="18e03-155">V takovém případě dojde k nevrácení popisovače, což často vede k úniku nativních prostředků přidružených k popisovači.</span><span class="sxs-lookup"><span data-stu-id="18e03-155">Failure to do so will cause the handle to be leaked, which often results in the leakage of native resources associated with the handle.</span></span> <span data-ttu-id="18e03-156">Proto je důležité strukturovat <xref:System.Runtime.InteropServices.SafeHandle> odvozené třídy tak, aby <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> implementace nevyžadovala přidělení všech prostředků, které nemusí být k dispozici v době vyvolání.</span><span class="sxs-lookup"><span data-stu-id="18e03-156">Therefore it is critical to structure <xref:System.Runtime.InteropServices.SafeHandle> derived classes such that the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> implementation does not require the allocation of any resources that may not be available at invocation time.</span></span> <span data-ttu-id="18e03-157">Všimněte si, že je dovoleno volat metody, které mohou selhat v rámci implementace <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> za předpokladu, že váš kód může zpracovat taková selhání a dokončit kontrakt k uvolnění nativního popisovače.</span><span class="sxs-lookup"><span data-stu-id="18e03-157">Note that it is permissible to call methods that may fail within the implementation of <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> provided that your code can handle such failures and complete the contract to release the native handle.</span></span> <span data-ttu-id="18e03-158">Pro účely ladění <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> má <xref:System.Boolean> návratovou hodnotu, která může být nastavena na hodnotu, `false` Pokud dojde k závažné chybě, která brání vydání prostředku.</span><span class="sxs-lookup"><span data-stu-id="18e03-158">For debugging purposes, <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> has a <xref:System.Boolean> return value which may be set to `false` if a catastrophic error is encountered which prevents release of the resource.</span></span> <span data-ttu-id="18e03-159">Tím se aktivuje [releaseHandleFailed](../debug-trace-profile/releasehandlefailed-mda.md) MDA, pokud je tato možnost povolená, aby bylo možné tento problém identifikovat.</span><span class="sxs-lookup"><span data-stu-id="18e03-159">Doing so will activate the [releaseHandleFailed](../debug-trace-profile/releasehandlefailed-mda.md) MDA, if enabled, to aid in identifying the problem.</span></span> <span data-ttu-id="18e03-160">Neovlivňuje modul runtime žádným jiným způsobem; <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A>nebude volána znovu pro stejný prostředek, a v důsledku toho nebude popisovač vrácen.</span><span class="sxs-lookup"><span data-stu-id="18e03-160">It does not affect the runtime in any other way; <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> will not be called again for the same resource and consequently the handle will be leaked.</span></span>

<span data-ttu-id="18e03-161"><xref:System.Runtime.InteropServices.SafeHandle>není v některých kontextech vhodný.</span><span class="sxs-lookup"><span data-stu-id="18e03-161"><xref:System.Runtime.InteropServices.SafeHandle> is not appropriate in certain contexts.</span></span>  <span data-ttu-id="18e03-162">Vzhledem k tomu <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> , že metodu lze spustit v <xref:System.GC> finalizační vlákně, nesmí být všechny popisovače, které jsou požadovány pro uvolnění určitého vlákna, zabaleny do <xref:System.Runtime.InteropServices.SafeHandle> .</span><span class="sxs-lookup"><span data-stu-id="18e03-162">Since the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method can be run on a <xref:System.GC> finalizer thread, any handles that are required to be freed on a particular thread should not be wrapped in a <xref:System.Runtime.InteropServices.SafeHandle>.</span></span>

<span data-ttu-id="18e03-163">Běhové obálky pro volání (RCW) lze vyčistit modulem CLR bez dalšího kódu.</span><span class="sxs-lookup"><span data-stu-id="18e03-163">Runtime callable wrappers (RCWs) can be cleaned by the CLR without additional code.</span></span>  <span data-ttu-id="18e03-164">Pro kód, který používá vyvolání platformy a pracuje s objektem COM jako `IUnknown*` nebo <xref:System.IntPtr> , by měl být kód přepsán, aby používal RCW.</span><span class="sxs-lookup"><span data-stu-id="18e03-164">For code that uses platform invoke and treats a COM object as an `IUnknown*` or an <xref:System.IntPtr>, the code should be rewritten to use an RCW.</span></span>  <span data-ttu-id="18e03-165"><xref:System.Runtime.InteropServices.SafeHandle>nemusí být vhodné pro tento scénář z důvodu možnosti nespravované metody verze zpětné volání zpět do spravovaného kódu.</span><span class="sxs-lookup"><span data-stu-id="18e03-165"><xref:System.Runtime.InteropServices.SafeHandle> may not be adequate for this scenario due to the possibility of an unmanaged release method calling back into managed code.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="18e03-166">Pravidlo analýzy kódu</span><span class="sxs-lookup"><span data-stu-id="18e03-166">Code analysis rule</span></span>

<span data-ttu-id="18e03-167">Slouží <xref:System.Runtime.InteropServices.SafeHandle> k zapouzdření prostředků operačního systému.</span><span class="sxs-lookup"><span data-stu-id="18e03-167">Use <xref:System.Runtime.InteropServices.SafeHandle> to encapsulate operating system resources.</span></span> <span data-ttu-id="18e03-168">Nepoužívejte <xref:System.Runtime.InteropServices.HandleRef> ani pole typu <xref:System.IntPtr> .</span><span class="sxs-lookup"><span data-stu-id="18e03-168">Do not use <xref:System.Runtime.InteropServices.HandleRef> or fields of type <xref:System.IntPtr>.</span></span>

### <a name="ensure-finalizers-do-not-have-to-run-to-prevent-leaking-operating-system-resources"></a><span data-ttu-id="18e03-169">Zajistěte, aby finalizační metody nemusely běžet, aby se zabránilo úniku prostředků operačního systému</span><span class="sxs-lookup"><span data-stu-id="18e03-169">Ensure finalizers do not have to run to prevent leaking operating system resources</span></span>

<span data-ttu-id="18e03-170">Pečlivě zkontrolujte své finalizační metody a ujistěte se, že i v případě, že nejsou spuštěné, není nevrácen důležitý prostředek operačního systému.</span><span class="sxs-lookup"><span data-stu-id="18e03-170">Review your finalizers carefully to ensure that even if they do not run, a critical operating system resource is not leaked.</span></span>  <span data-ttu-id="18e03-171">Na rozdíl od normálního <xref:System.AppDomain> uvolnění v případě, kdy je aplikace spuštěna v stabilním stavu, nebo pokud server, jako je například SQL Server vypnutí, objekty nejsou dokončeny během náhlého <xref:System.AppDomain> uvolnění.</span><span class="sxs-lookup"><span data-stu-id="18e03-171">Unlike a normal <xref:System.AppDomain> unload when the application is executing in a steady state or when a server such as SQL Server shuts down, objects are not finalized during an abrupt <xref:System.AppDomain> unload.</span></span>  <span data-ttu-id="18e03-172">Zajistěte, aby v případě náhlého uvolnění prostředků nedošlo k úniku prostředků, protože není zaručená správnost aplikace, ale integrita serveru musí být udržována nevracením prostředků.</span><span class="sxs-lookup"><span data-stu-id="18e03-172">Ensure resources are not leaked in the case of an abrupt unload, since an application's correctness cannot be guaranteed, but the integrity of the server must be maintained by not leaking resources.</span></span>  <span data-ttu-id="18e03-173">Použijte <xref:System.Runtime.InteropServices.SafeHandle> k uvolnění všech prostředků operačního systému.</span><span class="sxs-lookup"><span data-stu-id="18e03-173">Use <xref:System.Runtime.InteropServices.SafeHandle> to free any operating system resources.</span></span>

### <a name="ensure-that-finally-clauses-do-not-have-to-run-to-prevent-leaking-operating-system-resources"></a><span data-ttu-id="18e03-174">Zajistěte, aby klauzule finally nemusely běžet, aby se zabránilo úniku prostředků operačního systému</span><span class="sxs-lookup"><span data-stu-id="18e03-174">Ensure that finally clauses do not have to run to prevent leaking operating system resources</span></span>

<span data-ttu-id="18e03-175">`finally`není zaručeno spouštění klauzulí mimo CERs, což vyžaduje, aby vývojáři knihovny nespoléhat na kód v rámci `finally` bloku k uvolnění nespravovaných prostředků.</span><span class="sxs-lookup"><span data-stu-id="18e03-175">`finally` clauses are not guaranteed to run outside of CERs, requiring library developers to not rely on code within a `finally` block to free unmanaged resources.</span></span>  <span data-ttu-id="18e03-176">Použití <xref:System.Runtime.InteropServices.SafeHandle> je doporučené řešení.</span><span class="sxs-lookup"><span data-stu-id="18e03-176">Using <xref:System.Runtime.InteropServices.SafeHandle> is the recommended solution.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="18e03-177">Pravidlo analýzy kódu</span><span class="sxs-lookup"><span data-stu-id="18e03-177">Code analysis rule</span></span>

<span data-ttu-id="18e03-178">Použijte <xref:System.Runtime.InteropServices.SafeHandle> k čištění prostředků operačního systému místo `Finalize` .</span><span class="sxs-lookup"><span data-stu-id="18e03-178">Use <xref:System.Runtime.InteropServices.SafeHandle> for cleaning up operating system resources instead of `Finalize`.</span></span> <span data-ttu-id="18e03-179">Nepoužívejte <xref:System.IntPtr> , použijte <xref:System.Runtime.InteropServices.SafeHandle> k zapouzdření prostředků.</span><span class="sxs-lookup"><span data-stu-id="18e03-179">Do not use <xref:System.IntPtr>; use <xref:System.Runtime.InteropServices.SafeHandle> to encapsulate resources.</span></span> <span data-ttu-id="18e03-180">Pokud je nutné použít klauzuli finally, umístěte ji do CER.</span><span class="sxs-lookup"><span data-stu-id="18e03-180">If the finally clause must run, place it in a CER.</span></span>

### <a name="all-locks-should-go-through-existing-managed-locking-code"></a><span data-ttu-id="18e03-181">Všechny zámky by měly projít existujícím spravovaným kódem pro uzamykání</span><span class="sxs-lookup"><span data-stu-id="18e03-181">All locks should go through existing managed locking code</span></span>

<span data-ttu-id="18e03-182">CLR musí znát, pokud je kód v zámku, aby věděl, že by se <xref:System.AppDomain> místo pouhého přerušení vlákna přerušilo.</span><span class="sxs-lookup"><span data-stu-id="18e03-182">The CLR must know when code is in a lock so that it will know to tear down the <xref:System.AppDomain> rather than just aborting the thread.</span></span>  <span data-ttu-id="18e03-183">Přerušení vlákna může být nebezpečné, protože data provozovaná vláknem by mohla být ponechána v nekonzistentním stavu.</span><span class="sxs-lookup"><span data-stu-id="18e03-183">Aborting the thread could be dangerous as the data operated on by the thread could be left in an inconsistent state.</span></span> <span data-ttu-id="18e03-184">Proto je <xref:System.AppDomain> nutné provést recyklaci celého.</span><span class="sxs-lookup"><span data-stu-id="18e03-184">Therefore, the entire <xref:System.AppDomain> has to be recycled.</span></span>  <span data-ttu-id="18e03-185">Důsledky selhání identifikace zámku můžou být buď zablokované, nebo nesprávné výsledky.</span><span class="sxs-lookup"><span data-stu-id="18e03-185">The consequences of failing to identify a lock can be either deadlocks or incorrect results.</span></span> <span data-ttu-id="18e03-186">Použijte metody <xref:System.Threading.Thread.BeginCriticalRegion%2A> a <xref:System.Threading.Thread.EndCriticalRegion%2A> k identifikaci oblastí zámku.</span><span class="sxs-lookup"><span data-stu-id="18e03-186">Use the methods <xref:System.Threading.Thread.BeginCriticalRegion%2A> and <xref:System.Threading.Thread.EndCriticalRegion%2A> to identify lock regions.</span></span>  <span data-ttu-id="18e03-187">Jsou to statické metody pro <xref:System.Threading.Thread> třídu, která se vztahuje pouze na aktuální vlákno, což pomáhá zabránit jednomu vláknu v úpravě počtu zámků jiného vlákna.</span><span class="sxs-lookup"><span data-stu-id="18e03-187">They are static methods on the <xref:System.Threading.Thread> class that only apply to the current thread, helping to prevent one thread from editing another thread’s lock count.</span></span>

<span data-ttu-id="18e03-188"><xref:System.Threading.Monitor.Enter%2A>a <xref:System.Threading.Monitor.Exit%2A> mít tato oznámení CLR vestavěnou, takže jejich použití se doporučuje a také použití [příkazu Lock](../../csharp/language-reference/keywords/lock-statement.md), který tyto metody používá.</span><span class="sxs-lookup"><span data-stu-id="18e03-188"><xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A> have this CLR notification built in, so their usage is recommended as well as the use of the [lock Statement](../../csharp/language-reference/keywords/lock-statement.md), which uses these methods.</span></span>

<span data-ttu-id="18e03-189">Jiné mechanismy zamykání, jako jsou zámky a <xref:System.Threading.AutoResetEvent> musí volat tyto metody pro informování CLR o tom, že je zadávána kritická část.</span><span class="sxs-lookup"><span data-stu-id="18e03-189">Other locking mechanisms such as spin locks and <xref:System.Threading.AutoResetEvent> must call these methods to notify the CLR that a critical section is being entered.</span></span>  <span data-ttu-id="18e03-190">Tyto metody nevyužívají žádné zámky. informují CLR, že kód je spuštěn v kritickém oddílu a přerušení vlákna může opustit sdílený stav nekonzistentní.</span><span class="sxs-lookup"><span data-stu-id="18e03-190">These methods do not take any locks; they inform the CLR that code is executing in a critical section and aborting the thread could leave shared state inconsistent.</span></span>  <span data-ttu-id="18e03-191">Pokud jste definovali vlastní typ zámku, například vlastní <xref:System.Threading.ReaderWriterLock> třídu, použijte tyto metody čítače uzamčení.</span><span class="sxs-lookup"><span data-stu-id="18e03-191">If you have defined your own lock type, such as a custom <xref:System.Threading.ReaderWriterLock> class, use these lock count methods.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="18e03-192">Pravidlo analýzy kódu</span><span class="sxs-lookup"><span data-stu-id="18e03-192">Code analysis rule</span></span>

<span data-ttu-id="18e03-193">Označte a identifikujte všechny zámky pomocí <xref:System.Threading.Thread.BeginCriticalRegion%2A> a <xref:System.Threading.Thread.EndCriticalRegion%2A> .</span><span class="sxs-lookup"><span data-stu-id="18e03-193">Mark and identify all locks using <xref:System.Threading.Thread.BeginCriticalRegion%2A> and <xref:System.Threading.Thread.EndCriticalRegion%2A>.</span></span> <span data-ttu-id="18e03-194">Nepoužívejte <xref:System.Threading.Interlocked.CompareExchange%2A> , <xref:System.Threading.Interlocked.Increment%2A> a <xref:System.Threading.Interlocked.Decrement%2A> ve smyčce.</span><span class="sxs-lookup"><span data-stu-id="18e03-194">Do not use <xref:System.Threading.Interlocked.CompareExchange%2A>, <xref:System.Threading.Interlocked.Increment%2A>, and <xref:System.Threading.Interlocked.Decrement%2A> in a loop.</span></span>  <span data-ttu-id="18e03-195">Neprovádějte vyvolání platformy z variant těchto metod Win32.</span><span class="sxs-lookup"><span data-stu-id="18e03-195">Do not do a platform invoke of the Win32 variants of these methods.</span></span>  <span data-ttu-id="18e03-196">Nepoužívejte <xref:System.Threading.Thread.Sleep%2A> ve smyčce.</span><span class="sxs-lookup"><span data-stu-id="18e03-196">Do not use <xref:System.Threading.Thread.Sleep%2A> in a loop.</span></span>  <span data-ttu-id="18e03-197">Nepoužívejte nestálá pole.</span><span class="sxs-lookup"><span data-stu-id="18e03-197">Do not use volatile fields.</span></span>

### <a name="cleanup-code-must-be-in-a-finally-or-a-catch-block-not-following-a-catch"></a><span data-ttu-id="18e03-198">Kód pro vyčištění musí být v bloku finally nebo catch, který není po catch.</span><span class="sxs-lookup"><span data-stu-id="18e03-198">Cleanup code must be in a finally or a catch block, Not following a catch</span></span>

<span data-ttu-id="18e03-199">Kód pro vyčištění by nikdy neměl následovat za `catch` blokem, měl by být v `finally` `catch` samotném bloku nebo.</span><span class="sxs-lookup"><span data-stu-id="18e03-199">Cleanup code should never follow a `catch` block; it should be in a `finally` or in the `catch` block itself.</span></span> <span data-ttu-id="18e03-200">To by mělo být normální dobrý postup.</span><span class="sxs-lookup"><span data-stu-id="18e03-200">This should be a normal good practice.</span></span> <span data-ttu-id="18e03-201">`finally`Blok je obecně upřednostňovaný, protože spouští stejný kód v případě, že je vyvolána výjimka a při `try` normálním výskytu bloku.</span><span class="sxs-lookup"><span data-stu-id="18e03-201">A `finally` block is generally preferred because it runs the same code both when an exception is thrown and when the end of the `try` block is normally encountered.</span></span>  <span data-ttu-id="18e03-202">V případě vyvolání neočekávané výjimky, například <xref:System.Threading.ThreadAbortException> , nebude kód pro vyčištění spuštěn.</span><span class="sxs-lookup"><span data-stu-id="18e03-202">In the event of an unexpected exception being thrown, for example a <xref:System.Threading.ThreadAbortException>, the cleanup code will not run.</span></span>  <span data-ttu-id="18e03-203">Jakékoli nespravované prostředky, které byste měli vyčistit v rámci, `finally` by měly být v ideálním případě zabaleny do, <xref:System.Runtime.InteropServices.SafeHandle> aby se zabránilo únikům.</span><span class="sxs-lookup"><span data-stu-id="18e03-203">Any unmanaged resources that you would clean up in a `finally` should ideally be wrapped in a <xref:System.Runtime.InteropServices.SafeHandle> to prevent leaks.</span></span>  <span data-ttu-id="18e03-204">Poznámka: `using` klíčové slovo C# lze efektivně použít k Dispose objektů, včetně obslužných rutin.</span><span class="sxs-lookup"><span data-stu-id="18e03-204">Note the C# `using` keyword can be used effectively to dispose of objects, including handles.</span></span>

<span data-ttu-id="18e03-205">I když <xref:System.AppDomain> recyklace může vyčistit prostředky ve vlákně finalizační metody, je stále důležité umístit kód vyčištění na správné místo.</span><span class="sxs-lookup"><span data-stu-id="18e03-205">Although <xref:System.AppDomain> recycling can clean up resources on the finalizer thread, it is still important to put cleanup code in the correct place.</span></span> <span data-ttu-id="18e03-206">Všimněte si, že pokud vlákno obdrží asynchronní výjimku bez držení zámku, modul CLR se pokusí ukončit samotný podproces bez nutnosti recyklovat <xref:System.AppDomain> .</span><span class="sxs-lookup"><span data-stu-id="18e03-206">Note that if a thread receives an asynchronous exception without holding a lock, the CLR attempts to end the thread itself without having to recycle the <xref:System.AppDomain>.</span></span>  <span data-ttu-id="18e03-207">Zajistěte, aby se prostředky vyčistily dříve než později, a to díky tomu, že bude k dispozici více prostředků a lepší správa životního cyklu.</span><span class="sxs-lookup"><span data-stu-id="18e03-207">Ensuring that resources are cleaned up sooner rather than later helps by making more resources available, and by better managing the lifetime.</span></span> <span data-ttu-id="18e03-208">Pokud explicitně neuzavřete popisovač do souboru v nějaké cestě kódu chyby <xref:System.Runtime.InteropServices.SafeHandle> , počkejte, až ho finalizační metoda vyčistí. při dalším spuštění kódu se může pokusit o přístup k přesnému stejnému souboru, pokud se ještě nespustí finalizační metoda.</span><span class="sxs-lookup"><span data-stu-id="18e03-208">If you do not explicitly close a handle to a file in some error code path then wait for the <xref:System.Runtime.InteropServices.SafeHandle> finalizer to clean it up, the next time your code runs it may fail trying to access the exact same file if the finalizer has not already run.</span></span>  <span data-ttu-id="18e03-209">Z tohoto důvodu je potřeba zajistit, aby kód pro čištění existoval a správně fungoval, a to i v případě, že není nezbytně nutné.</span><span class="sxs-lookup"><span data-stu-id="18e03-209">For this reason, ensuring that cleanup code exists and works correctly will help recover from failures more cleanly and quickly, even though it is not strictly necessary.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="18e03-210">Pravidlo analýzy kódu</span><span class="sxs-lookup"><span data-stu-id="18e03-210">Code analysis rule</span></span>

<span data-ttu-id="18e03-211">Kód pro vyčištění po dokončení `catch` musí být v `finally` bloku.</span><span class="sxs-lookup"><span data-stu-id="18e03-211">Cleanup code after `catch` needs to be in a `finally` block.</span></span> <span data-ttu-id="18e03-212">Umístit volání k Dispose v bloku finally.</span><span class="sxs-lookup"><span data-stu-id="18e03-212">Place calls to dispose in a finally block.</span></span> <span data-ttu-id="18e03-213">`catch`bloky by měly končit throw nebo Rethrow.</span><span class="sxs-lookup"><span data-stu-id="18e03-213">`catch` blocks should end in a throw or rethrow.</span></span> <span data-ttu-id="18e03-214">I když dojde k výjimkám, jako je například zjištění, zda je možné vytvořit síťové připojení, kde může dojít k velkému počtu výjimek, jakýkoli kód, který vyžaduje zachycení množství výjimek za normálních okolností, by měl poskytnout indikaci, že by měl být testován kód, aby bylo možné zjistit, zda bude úspěšný.</span><span class="sxs-lookup"><span data-stu-id="18e03-214">While there will be exceptions, such as code detecting whether a network connection can be established where you might get any of a large number of exceptions, any code that requires the catching of a number of exceptions under normal circumstances should give an indication that the code should be tested to see if it will succeed.</span></span>

### <a name="process-wide-mutable-shared-state-between-application-domains-should-be-eliminated-or-use-a-constrained-execution-region"></a><span data-ttu-id="18e03-215">Proměnlivý sdílený stav na úrovni procesu mezi doménami aplikace by se měl vyloučit nebo použít oblast omezeného provádění.</span><span class="sxs-lookup"><span data-stu-id="18e03-215">Process-Wide mutable shared state between application domains should be eliminated or use a constrained execution region</span></span>

<span data-ttu-id="18e03-216">Jak je popsáno v úvodu, může být velmi obtížné napsat spravovaný kód, který monitoruje sdílený stav napříč doménami aplikace spolehlivým způsobem.</span><span class="sxs-lookup"><span data-stu-id="18e03-216">As described in the introduction, it can be very difficult to write managed code that monitors process-wide shared state across application domains in a reliable manner.</span></span>  <span data-ttu-id="18e03-217">Sdílený stav v rámci procesu je jakýkoli druh dat, který je sdílen mezi doménami aplikace, buď v kódu Win32, uvnitř CLR, nebo ve spravovaném kódu pomocí vzdálené komunikace.</span><span class="sxs-lookup"><span data-stu-id="18e03-217">Process-wide shared state is any sort of data structure shared between application domains, either in Win32 code, inside the CLR, or in managed code using remoting.</span></span>  <span data-ttu-id="18e03-218">Libovolný proměnlivý sdílený stav je velmi obtížné správně psát ve spravovaném kódu a jakýkoliv statický sdílený stav může být proveden pouze s velkou péčí.</span><span class="sxs-lookup"><span data-stu-id="18e03-218">Any mutable shared state is very difficult to correctly write in managed code, and any static shared state might be done only with great care.</span></span>  <span data-ttu-id="18e03-219">Pokud máte sdílený stav na úrovni procesu nebo počítače, najděte nějaký způsob, jak ho odstranit, nebo chránit sdílený stav pomocí omezené oblasti provádění (CER).</span><span class="sxs-lookup"><span data-stu-id="18e03-219">If you have process-wide or machine-wide shared state, find some way to eliminate it or protect the shared state using a constrained execution region (CER).</span></span>  <span data-ttu-id="18e03-220">Všimněte si, že jakákoliv knihovna se sdíleným stavem, který není identifikovaný a opravená, by mohla způsobit, že hostitel, jako je například SQL Server, potřebuje <xref:System.AppDomain> k chybě čistou vykládku.</span><span class="sxs-lookup"><span data-stu-id="18e03-220">Note that any library with shared state that is not identified and corrected could cause a host, such as SQL Server, that requires clean <xref:System.AppDomain> unloading to crash.</span></span>

<span data-ttu-id="18e03-221">Pokud kód používá objekt modelu COM, vyhněte se sdílení tohoto objektu COM mezi doménami aplikace.</span><span class="sxs-lookup"><span data-stu-id="18e03-221">If code uses a COM object, avoid sharing that COM object between application domains.</span></span>

### <a name="locks-do-not-work-process-wide-or-between-application-domains"></a><span data-ttu-id="18e03-222">Zámky nefungují v rámci aplikačních domén nebo mezi nimi.</span><span class="sxs-lookup"><span data-stu-id="18e03-222">Locks do not work process-wide or between application domains.</span></span>

<span data-ttu-id="18e03-223">V minulosti <xref:System.Threading.Monitor.Enter%2A> a [příkaz Lock](../../csharp/language-reference/keywords/lock-statement.md) byl použit k vytvoření globálních zámků procesu.</span><span class="sxs-lookup"><span data-stu-id="18e03-223">In the past, <xref:System.Threading.Monitor.Enter%2A> and the [lock Statement](../../csharp/language-reference/keywords/lock-statement.md) have been used to create global process locks.</span></span>  <span data-ttu-id="18e03-224">K tomu dochází například při zamykání na <xref:System.AppDomain> agilních třídách, jako jsou <xref:System.Type> instance z nesdílených sestavení, <xref:System.Threading.Thread> objekty, internované řetězce a některé řetězce sdílené napříč doménami aplikace pomocí vzdálené komunikace.</span><span class="sxs-lookup"><span data-stu-id="18e03-224">For example, this occurs when locking on <xref:System.AppDomain> agile classes, such as <xref:System.Type> instances from non-shared assemblies, <xref:System.Threading.Thread> objects, interned strings, and some strings shared across application domains using remoting.</span></span>  <span data-ttu-id="18e03-225">Tyto zámky již nejsou v procesu nadále platné.</span><span class="sxs-lookup"><span data-stu-id="18e03-225">These locks are no longer process-wide.</span></span>  <span data-ttu-id="18e03-226">Chcete-li zjistit přítomnost zámku meziaplikační domény v rámci procesu, určete, zda kód v zámku používá jakýkoliv externí, trvalý prostředek, jako je například soubor na disku nebo případně databáze.</span><span class="sxs-lookup"><span data-stu-id="18e03-226">To identify the presence of a process-wide interapplication domain lock, determine if the code within the lock uses any external, persisted resource such as a file on disk or possibly a database.</span></span>

<span data-ttu-id="18e03-227">Počítejte s tím, že při použití zámku v rámci <xref:System.AppDomain> může dojít k potížím, pokud chráněný kód používá externí prostředek, protože tento kód může běžet současně napříč více aplikačními doménami.</span><span class="sxs-lookup"><span data-stu-id="18e03-227">Note that taking a lock within an <xref:System.AppDomain> might cause problems if the protected code uses an external resource because that code may run simultaneously across multiple application domains.</span></span>  <span data-ttu-id="18e03-228">Může se jednat o problém při zápisu do jednoho souboru protokolu nebo k vytvoření vazby na soket pro celý proces.</span><span class="sxs-lookup"><span data-stu-id="18e03-228">This can be a problem when writing to one log file or binding to a socket for the entire process.</span></span>  <span data-ttu-id="18e03-229">Tyto změny znamenají, že neexistuje jednoduchý způsob použití spravovaného kódu pro získání globálního zámku procesu, než použití pojmenovaného <xref:System.Threading.Mutex> nebo <xref:System.Threading.Semaphore> instance.</span><span class="sxs-lookup"><span data-stu-id="18e03-229">These changes mean there is no easy way, using managed code, to get a process-global lock, other than using a named <xref:System.Threading.Mutex> or <xref:System.Threading.Semaphore> instance.</span></span>  <span data-ttu-id="18e03-230">Vytvořte kód, který neběží současně se dvěma aplikačními doménami, nebo <xref:System.Threading.Mutex> použijte <xref:System.Threading.Semaphore> třídy nebo.</span><span class="sxs-lookup"><span data-stu-id="18e03-230">Create code that does not run in two application domains simultaneously, or use the <xref:System.Threading.Mutex> or <xref:System.Threading.Semaphore> classes.</span></span>  <span data-ttu-id="18e03-231">Pokud existující kód nelze změnit, k dosažení této synchronizace nepoužívejte Win32 pojmenovaný mutex, protože je spuštěn v režimu Fiber-in znamená, že nemůžete zaručit, že stejné vlákno operačního systému získá a uvolní mutex.</span><span class="sxs-lookup"><span data-stu-id="18e03-231">If existing code cannot be changed, do not use a Win32 named mutex to achieve this synchronization because running in fiber mode means you cannot guarantee the same operating system thread will acquire and release a mutex.</span></span>  <span data-ttu-id="18e03-232">Je nutné použít spravovanou <xref:System.Threading.Mutex> třídu, nebo s názvem <xref:System.Threading.ManualResetEvent> , <xref:System.Threading.AutoResetEvent> , nebo, <xref:System.Threading.Semaphore> Chcete-li synchronizovat zámek kódu způsobem, který je v modulu CLR vědom, namísto synchronizace zámku pomocí nespravovaného kódu.</span><span class="sxs-lookup"><span data-stu-id="18e03-232">You must use the managed <xref:System.Threading.Mutex> class, or a named <xref:System.Threading.ManualResetEvent>, <xref:System.Threading.AutoResetEvent>, or a <xref:System.Threading.Semaphore> to synchronize the code lock in a manner that the CLR is aware of instead of synchronizing the lock using unmanaged code.</span></span>

#### <a name="avoid-locktypeofmytype"></a><span data-ttu-id="18e03-233">Nepoužívat zámek (typeof (MyType))</span><span class="sxs-lookup"><span data-stu-id="18e03-233">Avoid lock(typeof(MyType))</span></span>

<span data-ttu-id="18e03-234">Soukromé a veřejné <xref:System.Type> objekty ve sdílených sestaveních s pouze jednou kopií kódu sdílené napříč všemi doménami aplikace také představují problémy.</span><span class="sxs-lookup"><span data-stu-id="18e03-234">Private and public <xref:System.Type> objects in shared assemblies with only one copy of the code shared across all application domains also present problems.</span></span>  <span data-ttu-id="18e03-235">Pro sdílená sestavení je k dispozici pouze jedna instance pro <xref:System.Type> každý proces, což znamená, že více domén aplikace sdílí stejné <xref:System.Type> instance.</span><span class="sxs-lookup"><span data-stu-id="18e03-235">For shared assemblies, there is only one instance of a <xref:System.Type> per process, meaning that multiple application domains share the exact same <xref:System.Type> instance.</span></span>  <span data-ttu-id="18e03-236">Uzamčení <xref:System.Type> instance převezme zámek, který má vliv na celý proces, nikoli jenom na <xref:System.AppDomain> .</span><span class="sxs-lookup"><span data-stu-id="18e03-236">Taking a lock on a <xref:System.Type> instance takes a lock that affects the entire process, not just the <xref:System.AppDomain>.</span></span>  <span data-ttu-id="18e03-237">Pokud jeden z nich <xref:System.AppDomain> převezme zámek na <xref:System.Type> objektu, vlákno se náhle přeruší, ale zámek neuvolní.</span><span class="sxs-lookup"><span data-stu-id="18e03-237">If one <xref:System.AppDomain> takes a lock on a <xref:System.Type> object then that thread gets abruptly aborted, it will not release the lock.</span></span>  <span data-ttu-id="18e03-238">Tento zámek pak může způsobit zablokování jiných aplikačních domén.</span><span class="sxs-lookup"><span data-stu-id="18e03-238">This lock then may cause other application domains to deadlock.</span></span>

<span data-ttu-id="18e03-239">Dobrým způsobem, jak převzít zámky ve statických metodách, je přidání statického interního objektu synchronizace do kódu.</span><span class="sxs-lookup"><span data-stu-id="18e03-239">A good way to take locks in static methods involves adding a static internal synchronization object to the code.</span></span>  <span data-ttu-id="18e03-240">To může být inicializováno v konstruktoru třídy, pokud je k dispozici, ale pokud není možné ji inicializovat takto:</span><span class="sxs-lookup"><span data-stu-id="18e03-240">This could be initialized in the class constructor if one is present, but if not it can be initialized like this:</span></span>

```csharp
private static Object s_InternalSyncObject;
private static Object InternalSyncObject
{
    get
    {
        if (s_InternalSyncObject == null)
        {
            Object o = new Object();
            Interlocked.CompareExchange(
                ref s_InternalSyncObject, o, null);
        }
        return s_InternalSyncObject;
    }
}
```

<span data-ttu-id="18e03-241">Pak při použití zámku použijte `InternalSyncObject` vlastnost k získání objektu, který se má zamknout.</span><span class="sxs-lookup"><span data-stu-id="18e03-241">Then when taking a lock, use the `InternalSyncObject` property to obtain an object to lock on.</span></span>  <span data-ttu-id="18e03-242">Tuto vlastnost nemusíte používat, pokud jste v konstruktoru třídy provedli inicializaci objektu interní synchronizace.</span><span class="sxs-lookup"><span data-stu-id="18e03-242">You do not need to use the property if you have initialized the internal synchronization object in your class constructor.</span></span>  <span data-ttu-id="18e03-243">Inicializační kód zámku pro dvojité zaškrtnutí by měl vypadat jako v tomto příkladu:</span><span class="sxs-lookup"><span data-stu-id="18e03-243">The double checking lock initialization code should look like this example:</span></span>

```csharp
public static MyClass SingletonProperty
{
    get
    {
        if (s_SingletonProperty == null)
        {
            lock(InternalSyncObject)
            {
                // Do not use lock(typeof(MyClass))
                if (s_SingletonProperty == null)
                {
                    MyClass tmp = new MyClass(…);
                    // Do all initialization before publishing
                    s_SingletonProperty = tmp;
                }
            }
        }
        return s_SingletonProperty;
    }
}
```

#### <a name="a-note-about-lockthis"></a><span data-ttu-id="18e03-244">Poznámka o zámku (this)</span><span class="sxs-lookup"><span data-stu-id="18e03-244">A note about lock(this)</span></span>

<span data-ttu-id="18e03-245">Obecně je přijatelné přijmout zámek na individuálním objektu, který je veřejně přístupný.</span><span class="sxs-lookup"><span data-stu-id="18e03-245">It is generally acceptable to take a lock on an individual object that is publicly accessible.</span></span>  <span data-ttu-id="18e03-246">Pokud je však objekt objekt typu Singleton, který by mohl způsobit zablokování celého subsystému, zvažte použití výše uvedeného vzoru návrhu také.</span><span class="sxs-lookup"><span data-stu-id="18e03-246">However, if the object is a singleton object that might cause an entire subsystem to deadlock, consider using the above design pattern as well.</span></span>  <span data-ttu-id="18e03-247">Například zámek na jednom <xref:System.Security.SecurityManager> objektu by mohl způsobit zablokování v rámci <xref:System.AppDomain> celého <xref:System.AppDomain> nepoužitelného nastavení.</span><span class="sxs-lookup"><span data-stu-id="18e03-247">For example, a lock on the one <xref:System.Security.SecurityManager> object could cause a deadlock within the <xref:System.AppDomain> making the entire <xref:System.AppDomain> unusable.</span></span> <span data-ttu-id="18e03-248">Není vhodné pořizovat zámek u veřejně přístupného objektu tohoto typu.</span><span class="sxs-lookup"><span data-stu-id="18e03-248">It is good practice to not take a lock on a publicly accessible object of this type.</span></span>  <span data-ttu-id="18e03-249">Zámek u jednotlivých kolekcí nebo polí by však neměl obvykle představovat problém.</span><span class="sxs-lookup"><span data-stu-id="18e03-249">However a lock on an individual collection or array should generally not present a problem.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="18e03-250">Pravidlo analýzy kódu</span><span class="sxs-lookup"><span data-stu-id="18e03-250">Code analysis rule</span></span>

<span data-ttu-id="18e03-251">Neprovádějte zámky u typů, které by mohly být použity napříč doménami aplikace, nebo nemají silný smysl identity.</span><span class="sxs-lookup"><span data-stu-id="18e03-251">Do not take locks on types that might be used across application domains or do not have a strong sense of identity.</span></span> <span data-ttu-id="18e03-252">Nevolejte na,,,, <xref:System.Threading.Monitor.Enter%2A> <xref:System.Type> <xref:System.Reflection.MethodInfo> <xref:System.Reflection.PropertyInfo> <xref:System.String> <xref:System.ValueType> , <xref:System.Threading.Thread> nebo žádný objekt, který je odvozen z <xref:System.MarshalByRefObject> .</span><span class="sxs-lookup"><span data-stu-id="18e03-252">Do not call <xref:System.Threading.Monitor.Enter%2A> on a <xref:System.Type>, <xref:System.Reflection.MethodInfo>, <xref:System.Reflection.PropertyInfo>, <xref:System.String>, <xref:System.ValueType>, <xref:System.Threading.Thread>, or any object that derives from <xref:System.MarshalByRefObject>.</span></span>

### <a name="remove-gckeepalive-calls"></a><span data-ttu-id="18e03-253">Odeberte GC. Volání kontroly udržení naživu</span><span class="sxs-lookup"><span data-stu-id="18e03-253">Remove GC.KeepAlive calls</span></span>

<span data-ttu-id="18e03-254">Významné množství stávajícího kódu buď nepoužívá, <xref:System.GC.KeepAlive%2A> Pokud by ho mělo nebo používá, pokud není vhodné.</span><span class="sxs-lookup"><span data-stu-id="18e03-254">A significant amount of existing code either does not use <xref:System.GC.KeepAlive%2A> when it should or uses it when it is not appropriate.</span></span>  <span data-ttu-id="18e03-255">Po převodu na <xref:System.Runtime.InteropServices.SafeHandle> třídu není nutné volat třídy <xref:System.GC.KeepAlive%2A> za předpokladu, že nemají finalizační metodu, ale spoléhají na <xref:System.Runtime.InteropServices.SafeHandle> dokončení obslužných rutin operačního systému.</span><span class="sxs-lookup"><span data-stu-id="18e03-255">After converting to <xref:System.Runtime.InteropServices.SafeHandle>, classes do not need to call <xref:System.GC.KeepAlive%2A>, assuming they do not have a finalizer but rely on <xref:System.Runtime.InteropServices.SafeHandle> to finalize the operating system handles.</span></span>  <span data-ttu-id="18e03-256">I když náklady na výkon při zachování volání <xref:System.GC.KeepAlive%2A> mohou být zanedbatelné, vnímání, že volání <xref:System.GC.KeepAlive%2A> je buď nezbytné, nebo dostačující k vyřešení potíží při životnosti, která již nemusí existovat, způsobuje, že kód bude obtížnější udržovat.</span><span class="sxs-lookup"><span data-stu-id="18e03-256">While the performance cost of retaining a call to <xref:System.GC.KeepAlive%2A> may be negligible, the perception that a call to <xref:System.GC.KeepAlive%2A> is either necessary or sufficient to solve a lifetime issue that may no longer exist makes the code more difficult to maintain.</span></span>  <span data-ttu-id="18e03-257">Pokud však použijete volání RCW (COM interop CLR), <xref:System.GC.KeepAlive%2A> je stále vyžadován kódem.</span><span class="sxs-lookup"><span data-stu-id="18e03-257">However, when using the COM interop CLR callable wrappers (RCWs), <xref:System.GC.KeepAlive%2A> is still required by code.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="18e03-258">Pravidlo analýzy kódu</span><span class="sxs-lookup"><span data-stu-id="18e03-258">Code analysis rule</span></span>

<span data-ttu-id="18e03-259">Odebrat <xref:System.GC.KeepAlive%2A> .</span><span class="sxs-lookup"><span data-stu-id="18e03-259">Remove <xref:System.GC.KeepAlive%2A>.</span></span>

### <a name="use-the-hostprotection-attribute"></a><span data-ttu-id="18e03-260">Použití atributu HostProtection</span><span class="sxs-lookup"><span data-stu-id="18e03-260">Use the HostProtection Attribute</span></span>

<span data-ttu-id="18e03-261">Rozhraní <xref:System.Security.Permissions.HostProtectionAttribute> (hPa) poskytuje použití deklarativních akcí zabezpečení k určení požadavků na ochranu hostitele, aby mohl hostitel zabránit tomu, aby před voláním určitých metod, které jsou pro daného hostitele nevhodným způsobem, mohl zamezit i plně důvěryhodný kód, například <xref:System.Environment.Exit%2A> nebo <xref:System.Windows.Forms.MessageBox.Show%2A> pro SQL Server.</span><span class="sxs-lookup"><span data-stu-id="18e03-261">The <xref:System.Security.Permissions.HostProtectionAttribute> (HPA) provides the use of declarative security actions to determine host protection requirements, allowing the host to prevent even fully trusted code from calling certain methods which are inappropriate for the given host, such as <xref:System.Environment.Exit%2A> or <xref:System.Windows.Forms.MessageBox.Show%2A> for SQL Server.</span></span>

<span data-ttu-id="18e03-262">HPA ovlivňuje pouze nespravované aplikace, které hostují modul CLR (Common Language Runtime) a implementují ochranu hostitele, například SQL Server.</span><span class="sxs-lookup"><span data-stu-id="18e03-262">The HPA affects only unmanaged applications that host the common language runtime and implement host protection, such as SQL Server.</span></span> <span data-ttu-id="18e03-263">Při použití akce zabezpečení má za následek vytvoření požadavku propojení na základě prostředků hostitele, které třída nebo metoda zveřejňuje.</span><span class="sxs-lookup"><span data-stu-id="18e03-263">When applied, the security action results in the creation of a link demand based on the host resources the class or method exposes.</span></span> <span data-ttu-id="18e03-264">Pokud je kód spuštěn v klientské aplikaci nebo na serveru, který není chráněn hostitelem, atribut "vypařování"; nedetekuje se, a proto se nepoužije.</span><span class="sxs-lookup"><span data-stu-id="18e03-264">If the code is run in a client application or on a server that is not host-protected, the attribute "evaporates"; it is not detected and therefore not applied.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="18e03-265">Účelem tohoto atributu je vynutilit pokyny pro programovací model specifický pro hostitele, nikoli chování zabezpečení.</span><span class="sxs-lookup"><span data-stu-id="18e03-265">The purpose of this attribute is to enforce host-specific programming model guidelines, not security behavior.</span></span>  <span data-ttu-id="18e03-266">Přestože požadavek na propojení slouží ke kontrole shody s požadavky na programovací model, <xref:System.Security.Permissions.HostProtectionAttribute> není oprávnění zabezpečení.</span><span class="sxs-lookup"><span data-stu-id="18e03-266">Although a link demand is used to check for conformance to programming model requirements, the <xref:System.Security.Permissions.HostProtectionAttribute> is not a security permission.</span></span>

<span data-ttu-id="18e03-267">Pokud hostitel nemá požadavky na programovací model, nejsou k dispozici žádné požadavky propojení.</span><span class="sxs-lookup"><span data-stu-id="18e03-267">If the host does not have programming model requirements, the link demands do not occur.</span></span>

<span data-ttu-id="18e03-268">Tento atribut identifikuje následující:</span><span class="sxs-lookup"><span data-stu-id="18e03-268">This attribute identifies the following:</span></span>

- <span data-ttu-id="18e03-269">Metody nebo třídy, které se nevejdou do programovacího modelu hostitele, ale jsou jinak neškodné.</span><span class="sxs-lookup"><span data-stu-id="18e03-269">Methods or classes that do not fit the host programming model, but are otherwise benign.</span></span>

- <span data-ttu-id="18e03-270">Metody nebo třídy, které se nevejdou do programovacího modelu hostitele a můžou vést k destabilizující uživatelského kódu spravovaného serverem.</span><span class="sxs-lookup"><span data-stu-id="18e03-270">Methods or classes that do not fit the host programming model and could lead to destabilizing server-managed user code.</span></span>

- <span data-ttu-id="18e03-271">Metody nebo třídy, které se nevejdou do programovacího modelu hostitele a mohou vést k destabilizaci samotného procesu serveru.</span><span class="sxs-lookup"><span data-stu-id="18e03-271">Methods or classes that do not fit the host programming model and could lead to a destabilization of the server process itself.</span></span>

> [!NOTE]
> <span data-ttu-id="18e03-272">Pokud vytváříte knihovnu tříd, která bude volána aplikacemi, které mohou být spuštěny v hostitelském prostředí, měli byste tento atribut použít pro členy, kteří zveřejňují <xref:System.Security.Permissions.HostProtectionResource> kategorie prostředků.</span><span class="sxs-lookup"><span data-stu-id="18e03-272">If you are creating a class library that is to be called by applications that may execute in a host protected environment, you should apply this attribute to members that expose <xref:System.Security.Permissions.HostProtectionResource> resource categories.</span></span> <span data-ttu-id="18e03-273">.NET Framework členové knihovny tříd s tímto atributem způsobí, že bude zaškrtnuto pouze bezprostředního volajícího.</span><span class="sxs-lookup"><span data-stu-id="18e03-273">The .NET Framework class library members with this attribute cause only the immediate caller to be checked.</span></span>  <span data-ttu-id="18e03-274">Váš člen knihovny musí také způsobit kontrolu svého bezprostředního volajícího stejným způsobem.</span><span class="sxs-lookup"><span data-stu-id="18e03-274">Your library member must also cause a check of its immediate caller in the same manner.</span></span>

<span data-ttu-id="18e03-275">Další informace najdete v HPA v <xref:System.Security.Permissions.HostProtectionAttribute> .</span><span class="sxs-lookup"><span data-stu-id="18e03-275">Please find more information on HPA in <xref:System.Security.Permissions.HostProtectionAttribute>.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="18e03-276">Pravidlo analýzy kódu</span><span class="sxs-lookup"><span data-stu-id="18e03-276">Code analysis rule</span></span>

<span data-ttu-id="18e03-277">Pro SQL Server se všechny metody použité k zavedení synchronizace nebo dělení na vlákna musí identifikovat pomocí HPA.</span><span class="sxs-lookup"><span data-stu-id="18e03-277">For SQL Server, all methods used to introduce synchronization or threading must identified with the HPA.</span></span> <span data-ttu-id="18e03-278">Patří sem metody, které sdílejí stav, jsou synchronizovány nebo spravují externí procesy.</span><span class="sxs-lookup"><span data-stu-id="18e03-278">This includes methods that share state, are synchronized, or manage external processes.</span></span> <span data-ttu-id="18e03-279"><xref:System.Security.Permissions.HostProtectionResource>Hodnoty, které mají vliv na SQL Server jsou <xref:System.Security.Permissions.HostProtectionResource.SharedState> , <xref:System.Security.Permissions.HostProtectionResource.Synchronization> a <xref:System.Security.Permissions.HostProtectionResource.ExternalProcessMgmt> .</span><span class="sxs-lookup"><span data-stu-id="18e03-279">The <xref:System.Security.Permissions.HostProtectionResource> values that impact SQL Server are <xref:System.Security.Permissions.HostProtectionResource.SharedState>, <xref:System.Security.Permissions.HostProtectionResource.Synchronization>, and <xref:System.Security.Permissions.HostProtectionResource.ExternalProcessMgmt>.</span></span> <span data-ttu-id="18e03-280">Nicméně jakákoli metoda, která zveřejňuje nějaký, <xref:System.Security.Permissions.HostProtectionResource> by měla být identifikována hPa, nikoli jenom pomocí prostředků ovlivňujících SQL.</span><span class="sxs-lookup"><span data-stu-id="18e03-280">However, any method that exposes any <xref:System.Security.Permissions.HostProtectionResource> should be identified by a HPA, not just those using resources affecting SQL.</span></span>

### <a name="do-not-block-indefinitely-in-unmanaged-code"></a><span data-ttu-id="18e03-281">Neblokovat po neomezenou dobu v nespravovaném kódu</span><span class="sxs-lookup"><span data-stu-id="18e03-281">Do not block indefinitely in unmanaged code</span></span>

<span data-ttu-id="18e03-282">Blokování v nespravovaném kódu namísto ve spravovaném kódu může způsobit útok na dostupnost služby, protože modul CLR nemůže přerušit vlákno.</span><span class="sxs-lookup"><span data-stu-id="18e03-282">Blocking in unmanaged code instead of in managed code can cause a denial of service attack because the CLR is not able to abort the thread.</span></span>  <span data-ttu-id="18e03-283">Blokované vlákno zabraňuje CLR v uvolňování <xref:System.AppDomain> , přinejmenším bez provedení některých extrémně nebezpečných operací.</span><span class="sxs-lookup"><span data-stu-id="18e03-283">A blocked thread prevents the CLR from unloading the <xref:System.AppDomain>, at least without doing some extremely unsafe operations.</span></span>  <span data-ttu-id="18e03-284">Blokování použití primitiva synchronizace systému Windows je jasným příkladem něčeho, co nemůžeme dovolit.</span><span class="sxs-lookup"><span data-stu-id="18e03-284">Blocking using a Windows synchronization primitive is a clear example of something we cannot allow.</span></span>  <span data-ttu-id="18e03-285">Blokování volání `ReadFile` na soketu by se mělo vyhnout, pokud je to možné – v ideálním případě rozhraní Windows API by mělo poskytovat mechanismus pro operaci, jako je například vyprší časový limit.</span><span class="sxs-lookup"><span data-stu-id="18e03-285">Blocking in a call to `ReadFile` on a socket should be avoided if possible — ideally the Windows API should provide a mechanism for an operation like this to time out.</span></span>

<span data-ttu-id="18e03-286">Jakákoli metoda, která volá do nativního, by ideálním způsobem používala volání Win32 s přiměřeným, konečným časovým limitem.</span><span class="sxs-lookup"><span data-stu-id="18e03-286">Any method that calls into native should ideally use a Win32 call with a reasonable, finite timeout.</span></span>  <span data-ttu-id="18e03-287">Pokud má uživatel povolený časový limit, neměl by mít uživatel povoleno zadat neomezený časový limit bez určitého konkrétního oprávnění zabezpečení.</span><span class="sxs-lookup"><span data-stu-id="18e03-287">If the user is allowed to specify the timeout, the user should not be allowed to specify an infinite timeout without some specific security permission.</span></span>  <span data-ttu-id="18e03-288">V případě, že je metoda zablokovaná na více než ~ 10 sekund, je třeba použít verzi, která podporuje vypršení časových limitů, nebo potřebujete další podporu CLR.</span><span class="sxs-lookup"><span data-stu-id="18e03-288">As a guideline, if a method will block for more than ~10 seconds, you need to be using a version that supports timeouts or you need additional CLR support.</span></span>

<span data-ttu-id="18e03-289">Tady je několik příkladů problematických rozhraní API.</span><span class="sxs-lookup"><span data-stu-id="18e03-289">Here are some examples of problematic APIs.</span></span>  <span data-ttu-id="18e03-290">Kanály (anonymní i pojmenované) se dají vytvořit s časovým limitem. kód však musí zajistit, aby nikdy nevolal `CreateNamedPipe` ani `WaitNamedPipe` NMPWAIT_WAIT_FOREVER.</span><span class="sxs-lookup"><span data-stu-id="18e03-290">Pipes (both anonymous and named) can be created with a timeout; however, code must ensure it never calls `CreateNamedPipe` nor `WaitNamedPipe` with NMPWAIT_WAIT_FOREVER.</span></span>  <span data-ttu-id="18e03-291">Kromě toho může být neočekávané blokování i v případě, že je zadán časový limit.</span><span class="sxs-lookup"><span data-stu-id="18e03-291">Additionally, there can be unexpected blocking even if a timeout is specified.</span></span>  <span data-ttu-id="18e03-292">Volání `WriteFile` na anonymním kanálu se zablokuje, dokud se nezapisují všechny bajty, což znamená, že v ní dojde k nedostatku dat, `WriteFile` volání se zablokuje, dokud čtecí zařízení neuvolní místo ve vyrovnávací paměti kanálu.</span><span class="sxs-lookup"><span data-stu-id="18e03-292">Calling `WriteFile` on an anonymous pipe will block until all bytes are written, meaning if the buffer has unread data in it, the `WriteFile` call will block until the reader has freed up space in the pipe’s buffer.</span></span>  <span data-ttu-id="18e03-293">Sokety by měly vždycky používat rozhraní API, které respektují mechanismus časového limitu.</span><span class="sxs-lookup"><span data-stu-id="18e03-293">Sockets should always use some API that honors a timeout mechanism.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="18e03-294">Pravidlo analýzy kódu</span><span class="sxs-lookup"><span data-stu-id="18e03-294">Code analysis rule</span></span>

<span data-ttu-id="18e03-295">Blokování bez časového limitu v nespravovaném kódu je útok s cílem odepření služby.</span><span class="sxs-lookup"><span data-stu-id="18e03-295">Blocking without a timeout in unmanaged code is a denial of service attack.</span></span> <span data-ttu-id="18e03-296">Neprovádějte volání vyvolání platformy do `WaitForSingleObject` , `WaitForSingleObjectEx` ,, `WaitForMultipleObjects` `MsgWaitForMultipleObjects` a `MsgWaitForMultipleObjectsEx` .</span><span class="sxs-lookup"><span data-stu-id="18e03-296">Do not perform platform invoke calls to `WaitForSingleObject`, `WaitForSingleObjectEx`, `WaitForMultipleObjects`, `MsgWaitForMultipleObjects`, and `MsgWaitForMultipleObjectsEx`.</span></span>  <span data-ttu-id="18e03-297">Nepoužívejte NMPWAIT_WAIT_FOREVER.</span><span class="sxs-lookup"><span data-stu-id="18e03-297">Do not use NMPWAIT_WAIT_FOREVER.</span></span>

### <a name="identify-any-sta-dependent-features"></a><span data-ttu-id="18e03-298">Identifikujte všechny funkce závislé na STA</span><span class="sxs-lookup"><span data-stu-id="18e03-298">Identify any STA-Dependent features</span></span>

<span data-ttu-id="18e03-299">Identifikujte jakýkoli kód, který používá objekty Apartment s jedním vláknem modelu COM (STAs).</span><span class="sxs-lookup"><span data-stu-id="18e03-299">Identify any code that uses COM single-threaded apartments (STAs).</span></span>  <span data-ttu-id="18e03-300">STAs jsou v procesu SQL Server zakázané.</span><span class="sxs-lookup"><span data-stu-id="18e03-300">STAs are disabled in the SQL Server process.</span></span>  <span data-ttu-id="18e03-301">Funkce, které jsou závislé na `CoInitialize` , například čítače výkonu nebo schránka, musí být v rámci SQL Server zakázané.</span><span class="sxs-lookup"><span data-stu-id="18e03-301">Features that depend on `CoInitialize`, such as performance counters or the clipboard, must be disabled within SQL Server.</span></span>

### <a name="ensure-finalizers-are-free-of-synchronization-problems"></a><span data-ttu-id="18e03-302">Zajistěte, aby finalizační metody byly bez problémů s synchronizací.</span><span class="sxs-lookup"><span data-stu-id="18e03-302">Ensure finalizers are free of synchronization problems</span></span>

<span data-ttu-id="18e03-303">V budoucích verzích .NET Framework může existovat více vláken finalizační metody, což znamená, že finalizační metody pro různé instance stejného typu běží současně.</span><span class="sxs-lookup"><span data-stu-id="18e03-303">Multiple finalizer threads might exist in future versions of the .NET Framework, meaning the finalizers for different instances of the same type run simultaneously.</span></span>  <span data-ttu-id="18e03-304">Nemusí být zcela bezpečné pro přístup z více vláken; systém uvolňování paměti zaručuje, že pouze jedno vlákno spustí finalizační metodu pro danou instanci objektu.</span><span class="sxs-lookup"><span data-stu-id="18e03-304">They do not have to be completely thread safe; the garbage collector guarantees that only one thread will run the finalizer for a given object instance.</span></span>  <span data-ttu-id="18e03-305">Nicméně finalizační metody musí být kódované, aby nedocházelo ke konfliktům časování a zablokování při současném spuštění na více různých instancích objektů.</span><span class="sxs-lookup"><span data-stu-id="18e03-305">However, the finalizers must be coded to avoid race conditions and deadlocks when running simultaneously on multiple different object instances.</span></span>  <span data-ttu-id="18e03-306">Při použití libovolného externího stavu, jako je například zápis do souboru protokolu, musí být v finalizační metodě zpracovávány problémy s vlákny.</span><span class="sxs-lookup"><span data-stu-id="18e03-306">When using any external state, such as writing to a log file, in a finalizer, threading issues must be handled.</span></span>  <span data-ttu-id="18e03-307">Nespoléhá na finalizaci, aby se zajistila bezpečnost vlákna.</span><span class="sxs-lookup"><span data-stu-id="18e03-307">Do not rely on finalization to provide thread safety.</span></span> <span data-ttu-id="18e03-308">Nepoužívejte thread local úložiště, spravované nebo nativní, k uložení stavu ve vlákně finalizační metody.</span><span class="sxs-lookup"><span data-stu-id="18e03-308">Do not use thread local storage, managed or native, to store state on the finalizer thread.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="18e03-309">Pravidlo analýzy kódu</span><span class="sxs-lookup"><span data-stu-id="18e03-309">Code analysis rule</span></span>

<span data-ttu-id="18e03-310">Finalizační metody musí být bez problémů s synchronizací.</span><span class="sxs-lookup"><span data-stu-id="18e03-310">Finalizers must be free of synchronization problems.</span></span> <span data-ttu-id="18e03-311">Nepoužívejte statický proměnlivý stav v finalizační metodě.</span><span class="sxs-lookup"><span data-stu-id="18e03-311">Do not use a static mutable state in a finalizer.</span></span>

### <a name="avoid-unmanaged-memory-if-possible"></a><span data-ttu-id="18e03-312">Pokud je to možné, vyhněte se nespravované paměti</span><span class="sxs-lookup"><span data-stu-id="18e03-312">Avoid unmanaged memory if possible</span></span>

<span data-ttu-id="18e03-313">Nespravovanou paměť lze zneniknout, stejně jako popisovač operačního systému.</span><span class="sxs-lookup"><span data-stu-id="18e03-313">Unmanaged memory can be leaked, just like an operating system handle.</span></span> <span data-ttu-id="18e03-314">Pokud je to možné, zkuste použít paměť v zásobníku pomocí [stackalloc](../../csharp/language-reference/operators/stackalloc.md) nebo připnutého spravovaného objektu, jako je například [pevný příkaz](../../csharp/language-reference/keywords/fixed-statement.md) nebo s <xref:System.Runtime.InteropServices.GCHandle> použitím bajtu [].</span><span class="sxs-lookup"><span data-stu-id="18e03-314">If possible, try to use memory on the stack using [stackalloc](../../csharp/language-reference/operators/stackalloc.md) or a pinned managed object such as the [fixed Statement](../../csharp/language-reference/keywords/fixed-statement.md) or a <xref:System.Runtime.InteropServices.GCHandle> using a byte[].</span></span> <span data-ttu-id="18e03-315"><xref:System.GC>Nakonec je vyčistí.</span><span class="sxs-lookup"><span data-stu-id="18e03-315">The <xref:System.GC> eventually cleans these up.</span></span> <span data-ttu-id="18e03-316">Pokud však musíte přidělit nespravovanou paměť, zvažte použití třídy, která je odvozena z <xref:System.Runtime.InteropServices.SafeHandle> pro zabalení přidělení paměti.</span><span class="sxs-lookup"><span data-stu-id="18e03-316">However, if you must allocate unmanaged memory, consider using a class that derives from <xref:System.Runtime.InteropServices.SafeHandle> to wrap the memory allocation.</span></span>

<span data-ttu-id="18e03-317">Všimněte si, že existuje alespoň jeden případ, kde není <xref:System.Runtime.InteropServices.SafeHandle> dostačující.</span><span class="sxs-lookup"><span data-stu-id="18e03-317">Note that there is at least one case where <xref:System.Runtime.InteropServices.SafeHandle> is not adequate.</span></span> <span data-ttu-id="18e03-318">Pro volání metod modelu COM, které přidělují nebo uvolňují paměť, je běžné, že jedna knihovna DLL přidělí paměť prostřednictvím `CoTaskMemAlloc` jiné knihovny DLL uvolní tuto paměť `CoTaskMemFree` .</span><span class="sxs-lookup"><span data-stu-id="18e03-318">For COM method calls that allocate or free memory, it is common for one DLL to allocate memory via `CoTaskMemAlloc` then another DLL frees that memory with `CoTaskMemFree`.</span></span>  <span data-ttu-id="18e03-319">Použití <xref:System.Runtime.InteropServices.SafeHandle> na těchto místech by nebylo vhodné, protože se pokusí spojit životní cyklus nespravované paměti po celou dobu životnosti, <xref:System.Runtime.InteropServices.SafeHandle> místo aby jiná knihovna DLL mohla řídit dobu života paměti.</span><span class="sxs-lookup"><span data-stu-id="18e03-319">Using <xref:System.Runtime.InteropServices.SafeHandle> in these places would be inappropriate since it will attempt to tie the lifetime of the unmanaged memory to the lifetime of the <xref:System.Runtime.InteropServices.SafeHandle> instead of allowing the other DLL control the lifetime of the memory.</span></span>

### <a name="review-all-uses-of-catchexception"></a><span data-ttu-id="18e03-320">Zkontrolovat všechna použití catch (výjimka)</span><span class="sxs-lookup"><span data-stu-id="18e03-320">Review all uses of catch(Exception)</span></span>

<span data-ttu-id="18e03-321">Bloky catch, které zachycují všechny výjimky místo jedné konkrétní výjimky, teď budou zachytit i asynchronní výjimky.</span><span class="sxs-lookup"><span data-stu-id="18e03-321">Catch blocks that catch all exceptions instead of one specific exception will now catch the asynchronous exceptions as well.</span></span> <span data-ttu-id="18e03-322">Prověřte každý blok catch (Exception), vyhledá žádné důležité uvolnění prostředků nebo kód back-výstup, který může být vynechán, a potenciálně nesprávné chování v rámci bloku catch pro zpracování <xref:System.Threading.ThreadAbortException> , <xref:System.StackOverflowException> nebo <xref:System.OutOfMemoryException> .</span><span class="sxs-lookup"><span data-stu-id="18e03-322">Examine every catch(Exception) block, looking for no important resource releasing or backout code that might be skipped, as well as potentially incorrect behavior within the catch block itself for handling a <xref:System.Threading.ThreadAbortException>, <xref:System.StackOverflowException>, or <xref:System.OutOfMemoryException>.</span></span>  <span data-ttu-id="18e03-323">Všimněte si, že je možné, že tento kód může zaprotokolovat nebo vytvořit některé předpoklady, které mohou zobrazit pouze určité výjimky nebo které pokaždé, když dojde k výjimce, se nezdařila z přesně jednoho konkrétního důvodu.</span><span class="sxs-lookup"><span data-stu-id="18e03-323">Note that it is possible this code might be logging or making some assumptions that it may only see certain exceptions, or that whenever an exception happens it failed for exactly one particular reason.</span></span>  <span data-ttu-id="18e03-324">Tyto předpoklady je potřeba aktualizovat, aby zahrnovaly <xref:System.Threading.ThreadAbortException> .</span><span class="sxs-lookup"><span data-stu-id="18e03-324">These assumptions may need to be updated to include <xref:System.Threading.ThreadAbortException>.</span></span>

<span data-ttu-id="18e03-325">Zvažte změnu všech míst, která zachycují všechny výjimky pro zachycení konkrétního typu výjimky, kterou očekáváte, například <xref:System.FormatException> z metod formátování řetězce.</span><span class="sxs-lookup"><span data-stu-id="18e03-325">Consider changing all places that catch all exceptions to catching a specific type of exception that you expect will be thrown, such as a <xref:System.FormatException> from string formatting methods.</span></span>  <span data-ttu-id="18e03-326">To zabrání spuštění bloku catch v neočekávaných výjimkách a pomůže zajistit, že kód nebude skrývat chyby tím, že se zachytí neočekávané výjimky.</span><span class="sxs-lookup"><span data-stu-id="18e03-326">This prevents the catch block from running on unexpected exceptions and will help ensure the code does not hide bugs by catching unexpected exceptions.</span></span>  <span data-ttu-id="18e03-327">Jako obecné pravidlo nikdy nezpracovává výjimku v kódu knihovny (kód, který vyžaduje, abyste zachytili výjimku, může znamenat chybu návrhu v kódu, který voláte).</span><span class="sxs-lookup"><span data-stu-id="18e03-327">As a general rule never handle an exception in library code (code that requires you to catch an exception may indicate a design flaw in the code you are calling).</span></span>  <span data-ttu-id="18e03-328">V některých případech můžete chtít zachytit výjimku a vyvolat jiný typ výjimky, aby bylo možné poskytnout více dat.</span><span class="sxs-lookup"><span data-stu-id="18e03-328">In some cases you may want to catch an exception and throw a different exception type to provide more data.</span></span>  <span data-ttu-id="18e03-329">V tomto případě použijte vnořené výjimky a uložte skutečnou příčinu selhání do <xref:System.Exception.InnerException%2A> Vlastnosti nové výjimky.</span><span class="sxs-lookup"><span data-stu-id="18e03-329">Use nested exceptions in this case, storing the real cause of the failure in the <xref:System.Exception.InnerException%2A> property of the new exception.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="18e03-330">Pravidlo analýzy kódu</span><span class="sxs-lookup"><span data-stu-id="18e03-330">Code analysis rule</span></span>

<span data-ttu-id="18e03-331">Zkontrolujte všechny bloky catch ve spravovaném kódu, které zachycují všechny objekty nebo zachytí všechny výjimky.</span><span class="sxs-lookup"><span data-stu-id="18e03-331">Review all catch blocks in managed code that catch all objects or catch all exceptions.</span></span>  <span data-ttu-id="18e03-332">V jazyce C# to znamená označení příznakem `catch` {} a `catch(Exception)` {} .</span><span class="sxs-lookup"><span data-stu-id="18e03-332">In C#, this means flagging both `catch` {} and `catch(Exception)` {}.</span></span>  <span data-ttu-id="18e03-333">Zvažte, zda je typ výjimky velmi specifický, nebo zkontrolujte kód, abyste se ujistili, že se nejedná o špatný způsob, pokud zachytává neočekávaný typ výjimky.</span><span class="sxs-lookup"><span data-stu-id="18e03-333">Consider making the exception type very specific, or review the code to ensure it does not act in a bad way if it catches an unexpected exception type.</span></span>

### <a name="do-not-assume-a-managed-thread-is-a-win32-thread--it-is-a-fiber"></a><span data-ttu-id="18e03-334">Nepředpokládat spravované vlákno je vlákno Win32 – jedná se o vlákno.</span><span class="sxs-lookup"><span data-stu-id="18e03-334">Do not assume a managed thread is a Win32 thread – It is a Fiber</span></span>

<span data-ttu-id="18e03-335">Použití spravovaného úložiště thread local funguje, ale nepoužíváte nespravované úložiště thread local nebo předpokládáte, že se kód v aktuálním vláknu operačního systému spustí znovu.</span><span class="sxs-lookup"><span data-stu-id="18e03-335">Using managed thread local storage does work, but you may not use unmanaged thread local storage or assume the code will run on the current operating system thread again.</span></span> <span data-ttu-id="18e03-336">Neměňte nastavení, jako je národní prostředí vlákna.</span><span class="sxs-lookup"><span data-stu-id="18e03-336">Do not change settings like the thread’s locale.</span></span> <span data-ttu-id="18e03-337">Nevolejte nebo Nevolejte volání `InitializeCriticalSection` `CreateMutex` platformy, protože vyžadují vlákno operačního systému, které zadává zámek, také ukončí zámek.</span><span class="sxs-lookup"><span data-stu-id="18e03-337">Do not call `InitializeCriticalSection` or `CreateMutex` via platform invoke because they require the operating system thread that enters a lock also exit the lock.</span></span> <span data-ttu-id="18e03-338">Vzhledem k tomu, že se nejedná o případ použití vláken, důležité oddíly Win32 a mutex nelze použít přímo v SQL.</span><span class="sxs-lookup"><span data-stu-id="18e03-338">Since this will not be the case when using fibers, Win32 critical sections and mutexes cannot be used in SQL directly.</span></span>  <span data-ttu-id="18e03-339">Všimněte si, že spravovaná <xref:System.Threading.Mutex> Třída nezpracovává obavy tohoto spřažení vlákna.</span><span class="sxs-lookup"><span data-stu-id="18e03-339">Note that the managed <xref:System.Threading.Mutex> class does not handle these thread affinity concerns.</span></span>

<span data-ttu-id="18e03-340">Většinu stavu můžete bezpečně použít u spravovaného <xref:System.Threading.Thread> objektu, včetně spravovaného Thread localho úložiště a aktuální jazykové verze uživatelského rozhraní vlákna.</span><span class="sxs-lookup"><span data-stu-id="18e03-340">You can safely use most of the state on a managed <xref:System.Threading.Thread> object, including managed thread local storage and the thread’s current UI culture.</span></span> <span data-ttu-id="18e03-341">Můžete také použít <xref:System.ThreadStaticAttribute> , což umožňuje, aby byla hodnota existující statické proměnné přístupná pouze aktuálním spravovaným vláknem (Jedná se o další způsob, jak v modulu CLR provádět vlákna v místním úložišti).</span><span class="sxs-lookup"><span data-stu-id="18e03-341">You can also use the <xref:System.ThreadStaticAttribute>, which makes the value of an existing static variable accessible only by the current managed thread (this is another way of doing fiber local storage in the CLR).</span></span> <span data-ttu-id="18e03-342">Pro účely programovacího modelu nemůžete změnit aktuální jazykovou verzi vlákna při spuštění v SQL.</span><span class="sxs-lookup"><span data-stu-id="18e03-342">For programming model reasons, you can not change the current culture of a thread when running in SQL.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="18e03-343">Pravidlo analýzy kódu</span><span class="sxs-lookup"><span data-stu-id="18e03-343">Code analysis rule</span></span>

<span data-ttu-id="18e03-344">SQL Server běží v režimu Fiber; Nepoužívejte thread local Storage.</span><span class="sxs-lookup"><span data-stu-id="18e03-344">SQL Server runs in fiber mode; do not use thread local storage.</span></span> <span data-ttu-id="18e03-345">Vyhněte se vyvolání volání platformy `TlsAlloc` , `TlsFree` , `TlsGetValue` a`TlsSetValue.`</span><span class="sxs-lookup"><span data-stu-id="18e03-345">Avoid platform invoke calls to `TlsAlloc`, `TlsFree`, `TlsGetValue`, and `TlsSetValue.`</span></span>

### <a name="let-sql-server-handle-impersonation"></a><span data-ttu-id="18e03-346">Povolit SQL Server manipulaci s zosobněním</span><span class="sxs-lookup"><span data-stu-id="18e03-346">Let SQL Server handle impersonation</span></span>

<span data-ttu-id="18e03-347">Vzhledem k tomu, že zosobnění funguje na úrovni vlákna a SQL může běžet v vláknovém režimu, spravovaný kód by neměl zosobnit uživatele a neměl by volat `RevertToSelf` .</span><span class="sxs-lookup"><span data-stu-id="18e03-347">Since impersonation operates on the thread level and SQL can run in fiber mode, managed code should not impersonate users, and should not call `RevertToSelf`.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="18e03-348">Pravidlo analýzy kódu</span><span class="sxs-lookup"><span data-stu-id="18e03-348">Code analysis rule</span></span>

<span data-ttu-id="18e03-349">Umožněte SQL Server pořizování zosobnění.</span><span class="sxs-lookup"><span data-stu-id="18e03-349">Let SQL Server handle impersonation.</span></span> <span data-ttu-id="18e03-350">Nepoužívejte `RevertToSelf` ,, `ImpersonateAnonymousToken` , `DdeImpersonateClient` , `ImpersonateDdeClientWindow` `ImpersonateLoggedOnUser` , `ImpersonateNamedPipeClient` , `ImpersonateSelf` , `RpcImpersonateClient` , `RpcRevertToSelf` , `RpcRevertToSelfEx` , nebo `SetThreadToken` .</span><span class="sxs-lookup"><span data-stu-id="18e03-350">Do not use `RevertToSelf`, `ImpersonateAnonymousToken`, `DdeImpersonateClient`, `ImpersonateDdeClientWindow`, `ImpersonateLoggedOnUser`, `ImpersonateNamedPipeClient`, `ImpersonateSelf`, `RpcImpersonateClient`, `RpcRevertToSelf`, `RpcRevertToSelfEx`, or `SetThreadToken`.</span></span>

### <a name="do-not-call-threadsuspend"></a><span data-ttu-id="18e03-351">Nevolat vlákno:: Suspend</span><span class="sxs-lookup"><span data-stu-id="18e03-351">Do not call Thread::Suspend</span></span>

<span data-ttu-id="18e03-352">Schopnost pozastavit vlákno se může zobrazit jako jednoduchá operace, ale může způsobit zablokování.</span><span class="sxs-lookup"><span data-stu-id="18e03-352">The ability to suspend a thread may appear a simple operation, but it can cause deadlocks.</span></span>  <span data-ttu-id="18e03-353">Pokud vlákno drží zámek pozastaveno druhým vláknem a potom se druhé vlákno pokusí přebírat stejný zámek, dojde k zablokování.</span><span class="sxs-lookup"><span data-stu-id="18e03-353">If a thread holding a lock gets suspended by a second thread and then the second thread tries taking the same lock, a deadlock occurs.</span></span>  <span data-ttu-id="18e03-354"><xref:System.Threading.Thread.Suspend%2A>může v současné době ovlivňovat zabezpečení, načítání tříd, vzdálenou komunikaci a reflexi.</span><span class="sxs-lookup"><span data-stu-id="18e03-354"><xref:System.Threading.Thread.Suspend%2A> can interfere with security, class loading, remoting, and reflection currently.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="18e03-355">Pravidlo analýzy kódu</span><span class="sxs-lookup"><span data-stu-id="18e03-355">Code analysis rule</span></span>

<span data-ttu-id="18e03-356">Nevolejte <xref:System.Threading.Thread.Suspend%2A> .</span><span class="sxs-lookup"><span data-stu-id="18e03-356">Do not call <xref:System.Threading.Thread.Suspend%2A>.</span></span> <span data-ttu-id="18e03-357">Zvažte místo toho použití reálného primitiva synchronizace, jako je například <xref:System.Threading.Semaphore> nebo <xref:System.Threading.ManualResetEvent> .</span><span class="sxs-lookup"><span data-stu-id="18e03-357">Consider using a real synchronization primitive instead, such as a <xref:System.Threading.Semaphore> or <xref:System.Threading.ManualResetEvent> .</span></span>

### <a name="protect-critical-operations-with-constrained-execution-regions-and-reliability-contracts"></a><span data-ttu-id="18e03-358">Chraňte kritické operace s omezenými oblastmi provádění a smlouvami o spolehlivosti.</span><span class="sxs-lookup"><span data-stu-id="18e03-358">Protect critical operations with constrained execution regions and reliability contracts</span></span>

<span data-ttu-id="18e03-359">Při provádění složitých operací, které aktualizují sdílený stav nebo které musí být deterministické buď zcela úspěšné nebo zcela neúspěšné, se ujistěte, že je chráněna pomocí omezené oblasti provádění (CER).</span><span class="sxs-lookup"><span data-stu-id="18e03-359">When performing a complex operation that updates a shared status or that needs to deterministically either fully succeed or fully fail, be sure that it is protected by a constrained execution region (CER).</span></span> <span data-ttu-id="18e03-360">To zaručuje, že kód se spustí v každém případě, dokonce i náhlé přerušení vlákna nebo náhlé <xref:System.AppDomain> uvolnění.</span><span class="sxs-lookup"><span data-stu-id="18e03-360">This guarantees that the code runs in every case, even an abrupt thread abort or an abrupt <xref:System.AppDomain> unload.</span></span>

<span data-ttu-id="18e03-361">CER je konkrétní `try/finally` blok hned před voláním <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> .</span><span class="sxs-lookup"><span data-stu-id="18e03-361">A CER is a particular `try/finally` block immediately preceded by a call to <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A>.</span></span>

<span data-ttu-id="18e03-362">Tím se dá instruovat kompilátor za běhu pro přípravu veškerého kódu v bloku finally před spuštěním `try` bloku.</span><span class="sxs-lookup"><span data-stu-id="18e03-362">Doing so instructs the just-in-time compiler to prepare all the code in the finally block before running the `try` block.</span></span> <span data-ttu-id="18e03-363">To zaručuje, že kód v bloku finally je sestaven a bude spuštěn ve všech případech.</span><span class="sxs-lookup"><span data-stu-id="18e03-363">This guarantees that the code in the finally block is built and will run in all cases.</span></span> <span data-ttu-id="18e03-364">Není neobvyklé, že v CER může být prázdný `try` blok.</span><span class="sxs-lookup"><span data-stu-id="18e03-364">It is not uncommon in a CER to have an empty `try` block.</span></span> <span data-ttu-id="18e03-365">Použití CER chrání proti přerušení asynchronního vlákna a výjimky z důvodu nedostatku paměti.</span><span class="sxs-lookup"><span data-stu-id="18e03-365">Using a CER protects against asynchronous thread aborts and out-of-memory exceptions.</span></span> <span data-ttu-id="18e03-366">Přečtěte si téma pro podobu <xref:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup%2A> formátu CER, která navíc zpracovává přetečení zásobníku pro překročení hloubkového kódu.</span><span class="sxs-lookup"><span data-stu-id="18e03-366">See <xref:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup%2A> for a form of a CER that additionally handles stack overflows for exceedingly deep code.</span></span>

## <a name="see-also"></a><span data-ttu-id="18e03-367">Viz také</span><span class="sxs-lookup"><span data-stu-id="18e03-367">See also</span></span>

- <xref:System.Runtime.ConstrainedExecution>
- [<span data-ttu-id="18e03-368">Programování serveru SQL Server a atributy ochrany hostitele</span><span class="sxs-lookup"><span data-stu-id="18e03-368">SQL Server Programming and Host Protection Attributes</span></span>](sql-server-programming-and-host-protection-attributes.md)
