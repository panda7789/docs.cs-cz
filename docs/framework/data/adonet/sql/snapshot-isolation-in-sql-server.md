---
title: Izolace snímků na SQL Serveru
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
ms.assetid: 43ae5dd3-50f5-43a8-8d01-e37a61664176
ms.openlocfilehash: 8313ffc8eef70c1e5efc24b09a160edb7cec1595
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 03/12/2020
ms.locfileid: "79174261"
---
# <a name="snapshot-isolation-in-sql-server"></a><span data-ttu-id="89f35-102">Izolace snímků na SQL Serveru</span><span class="sxs-lookup"><span data-stu-id="89f35-102">Snapshot Isolation in SQL Server</span></span>
<span data-ttu-id="89f35-103">Snímek izolace zvyšuje souběžnost pro aplikace OLTP.</span><span class="sxs-lookup"><span data-stu-id="89f35-103">Snapshot isolation enhances concurrency for OLTP applications.</span></span>  
  
## <a name="understanding-snapshot-isolation-and-row-versioning"></a><span data-ttu-id="89f35-104">Principy izolace snímků a správy verzí řádků</span><span class="sxs-lookup"><span data-stu-id="89f35-104">Understanding Snapshot Isolation and Row Versioning</span></span>  
 <span data-ttu-id="89f35-105">Jakmile je povolena izolace snímku, musí být zachovány aktualizované verze řádků pro každou transakci.</span><span class="sxs-lookup"><span data-stu-id="89f35-105">Once snapshot isolation is enabled, updated row versions for each transaction must be maintained.</span></span>  <span data-ttu-id="89f35-106">Před SQL Server 2019 byly tyto verze uloženy v **databázi tempdb**.</span><span class="sxs-lookup"><span data-stu-id="89f35-106">Prior to SQL Server 2019, these versions were stored in **tempdb**.</span></span> <span data-ttu-id="89f35-107">SQL Server 2019 zavádí novou funkci, Accelerated Database Recovery (ADR), která vyžaduje vlastní sadu verzí řádků.</span><span class="sxs-lookup"><span data-stu-id="89f35-107">SQL Server 2019 introduces a new feature, Accelerated Database Recovery (ADR) which requires its own set of row versions.</span></span>  <span data-ttu-id="89f35-108">Takže jako SQL Server 2019, pokud ADR není povolena, verze řádků jsou uchovávány v **tempdb** jako vždy.</span><span class="sxs-lookup"><span data-stu-id="89f35-108">So, as of SQL Server 2019, if ADR is not enabled, row versions are kept in **tempdb** as always.</span></span>  <span data-ttu-id="89f35-109">Pokud je povolena ADR, pak jsou všechny verze řádků, které souvisejí s izolací snímků a ADR, uloženy v úložišti trvalých verzí ADR (PVS), který je umístěn v databázi uživatelů ve skupině souborů, kterou uživatel určuje.</span><span class="sxs-lookup"><span data-stu-id="89f35-109">If ADR is enabled, then all row versions, both related to snapshot isolation and ADR, are kept in ADR's Persistent Version Store (PVS), which is located in the user database in a filegroup which the user specifies.</span></span> <span data-ttu-id="89f35-110">Jedinečné pořadové číslo transakce identifikuje každou transakci a tato jedinečná čísla jsou zaznamenána pro každou verzi řádku.</span><span class="sxs-lookup"><span data-stu-id="89f35-110">A unique transaction sequence number identifies each transaction, and these unique numbers are recorded for each row version.</span></span> <span data-ttu-id="89f35-111">Transakce pracuje s nejnovějšími verzemi řádků, které mají pořadové číslo před pořadovým číslem transakce.</span><span class="sxs-lookup"><span data-stu-id="89f35-111">The transaction works with the most recent row versions having a sequence number before the sequence number of the transaction.</span></span> <span data-ttu-id="89f35-112">Novější verze řádků vytvořené po zahájení transakce jsou transakcí ignorovány.</span><span class="sxs-lookup"><span data-stu-id="89f35-112">Newer row versions created after the transaction has begun are ignored by the transaction.</span></span>  
  
 <span data-ttu-id="89f35-113">Termín "snímek" odráží skutečnost, že všechny dotazy v transakci zobrazit stejnou verzi nebo snímek databáze, na základě stavu databáze v okamžiku zahájení transakce.</span><span class="sxs-lookup"><span data-stu-id="89f35-113">The term "snapshot" reflects the fact that all queries in the transaction see the same version, or snapshot, of the database, based on the state of the database at the moment in time when the transaction begins.</span></span> <span data-ttu-id="89f35-114">Žádné zámky jsou získány na podkladových datových řádků nebo datových stránek v transakci snímek, který umožňuje jiné transakce provést bez blokování předchozí nedokončené transakce.</span><span class="sxs-lookup"><span data-stu-id="89f35-114">No locks are acquired on the underlying data rows or data pages in a snapshot transaction, which permits other transactions to execute without being blocked by a prior uncompleted transaction.</span></span> <span data-ttu-id="89f35-115">Transakce, které upravují data, neblokují transakce, které čtou data, a transakce, které čtou data, neblokují transakce, které zapisují data, jako by to obvykle bylo v rámci výchozí úrovně izolace READ COMMITTED na serveru SQL Server.</span><span class="sxs-lookup"><span data-stu-id="89f35-115">Transactions that modify data do not block transactions that read data, and transactions that read data do not block transactions that write data, as they normally would under the default READ COMMITTED isolation level in SQL Server.</span></span> <span data-ttu-id="89f35-116">Toto chování bez blokování také výrazně snižuje pravděpodobnost zablokování pro složité transakce.</span><span class="sxs-lookup"><span data-stu-id="89f35-116">This non-blocking behavior also significantly reduces the likelihood of deadlocks for complex transactions.</span></span>  
  
 <span data-ttu-id="89f35-117">Snímek izolace používá optimistický model souběžnosti.</span><span class="sxs-lookup"><span data-stu-id="89f35-117">Snapshot isolation uses an optimistic concurrency model.</span></span> <span data-ttu-id="89f35-118">Pokud snímek transakce pokusí potvrdit změny dat, která se změnila od zahájení transakce, transakce se vrátí zpět a bude vyvolána chyba.</span><span class="sxs-lookup"><span data-stu-id="89f35-118">If a snapshot transaction attempts to commit modifications to data that has changed since the transaction began, the transaction will roll back and an error will be raised.</span></span> <span data-ttu-id="89f35-119">Můžete se tomu vyhnout pomocí nápovědy UPDLOCK pro příkazy SELECT, které přístup k datům, které mají být změněny.</span><span class="sxs-lookup"><span data-stu-id="89f35-119">You can avoid this by using UPDLOCK hints for SELECT statements that access data to be modified.</span></span> <span data-ttu-id="89f35-120">Další informace naleznete v tématu "Locking Hints" v sql server books online.</span><span class="sxs-lookup"><span data-stu-id="89f35-120">See "Locking Hints" in SQL Server Books Online for more information.</span></span>  
  
 <span data-ttu-id="89f35-121">Snímek izolace musí být povolena nastavením ALLOW_SNAPSHOT_ISOLATION ON databáze možnost před použitím v transakcích.</span><span class="sxs-lookup"><span data-stu-id="89f35-121">Snapshot isolation must be enabled by setting the ALLOW_SNAPSHOT_ISOLATION ON database option before it is used in transactions.</span></span> <span data-ttu-id="89f35-122">Tím se aktivuje mechanismus pro ukládání verzí řádků v dočasné databázi (**tempdb**).</span><span class="sxs-lookup"><span data-stu-id="89f35-122">This activates the mechanism for storing row versions in the temporary database (**tempdb**).</span></span> <span data-ttu-id="89f35-123">Je nutné povolit izolaci snímek v každé databázi, která ji používá s příkazem Transact-SQL ALTER DATABASE.</span><span class="sxs-lookup"><span data-stu-id="89f35-123">You must enable snapshot isolation in each database that uses it with the Transact-SQL ALTER DATABASE statement.</span></span> <span data-ttu-id="89f35-124">V tomto ohledu snímek izolace se liší od tradiční úrovně izolace read committed, opakovatelné čtení, serializovata a čtení UNCOMMITTED, které nevyžadují žádnou konfiguraci.</span><span class="sxs-lookup"><span data-stu-id="89f35-124">In this respect, snapshot isolation differs from the traditional isolation levels of READ COMMITTED, REPEATABLE READ, SERIALIZABLE, and READ UNCOMMITTED, which require no configuration.</span></span> <span data-ttu-id="89f35-125">Následující příkazy aktivují izolaci snímku a nahradí výchozí chování READ COMMITTED s snapshotem:</span><span class="sxs-lookup"><span data-stu-id="89f35-125">The following statements activate snapshot isolation and replace the default READ COMMITTED behavior with SNAPSHOT:</span></span>  
  
```sql  
ALTER DATABASE MyDatabase  
SET ALLOW_SNAPSHOT_ISOLATION ON  
  
ALTER DATABASE MyDatabase  
SET READ_COMMITTED_SNAPSHOT ON  
```  
  
 <span data-ttu-id="89f35-126">Nastavení možnosti READ_COMMITTED_SNAPSHOT ON umožňuje přístup k řádkům s verzí pod výchozí úrovní izolace READ COMMITTED.</span><span class="sxs-lookup"><span data-stu-id="89f35-126">Setting the READ_COMMITTED_SNAPSHOT ON option allows access to versioned rows under the default READ COMMITTED isolation level.</span></span> <span data-ttu-id="89f35-127">Pokud je možnost READ_COMMITTED_SNAPSHOT nastavena na vypnuto, je nutné explicitně nastavit úroveň izolace snímek pro každou relaci, aby bylo možné získat přístup k řádkům s verzí.</span><span class="sxs-lookup"><span data-stu-id="89f35-127">If the READ_COMMITTED_SNAPSHOT option is set to OFF, you must explicitly set the Snapshot isolation level for each session in order to access versioned rows.</span></span>  
  
## <a name="managing-concurrency-with-isolation-levels"></a><span data-ttu-id="89f35-128">Správa souběžnosti s úrovněmi izolace</span><span class="sxs-lookup"><span data-stu-id="89f35-128">Managing Concurrency with Isolation Levels</span></span>  
 <span data-ttu-id="89f35-129">Úroveň izolace, pod kterou příkaz Transact-SQL provádí určuje jeho uzamčení a řádek správu verzí chování.</span><span class="sxs-lookup"><span data-stu-id="89f35-129">The isolation level under which a Transact-SQL statement executes determines its locking and row versioning behavior.</span></span> <span data-ttu-id="89f35-130">Úroveň izolace má obor pro celé připojení a po nastavení pro připojení s příkazem SET TRANSACTION ISOLATION LEVEL zůstane v platnosti, dokud není připojení uzavřeno nebo je nastavena jiná úroveň izolace.</span><span class="sxs-lookup"><span data-stu-id="89f35-130">An isolation level has connection-wide scope, and once set for a connection with the SET TRANSACTION ISOLATION LEVEL statement, it remains in effect until the connection is closed or another isolation level is set.</span></span> <span data-ttu-id="89f35-131">Když je připojení uzavřeno a vráceno do fondu, úroveň izolace z posledního příkazu SET TRANSACTION ISOLATION LEVEL zůstane zachována.</span><span class="sxs-lookup"><span data-stu-id="89f35-131">When a connection is closed and returned to the pool, the isolation level from the last SET TRANSACTION ISOLATION LEVEL statement is retained.</span></span> <span data-ttu-id="89f35-132">Následná připojení, která znovu používají sdružené připojení, používají úroveň izolace, která byla v platnosti v době, kdy je připojení sdruženo.</span><span class="sxs-lookup"><span data-stu-id="89f35-132">Subsequent connections reusing a pooled connection use the isolation level that was in effect at the time the connection is pooled.</span></span>  
  
 <span data-ttu-id="89f35-133">Jednotlivé dotazy vydané v rámci připojení může obsahovat rady při uzamčení, které upravují izolaci pro jeden příkaz nebo transakci, ale nemají vliv na úroveň izolace připojení.</span><span class="sxs-lookup"><span data-stu-id="89f35-133">Individual queries issued within a connection can contain lock hints that modify the isolation for a single statement or transaction but do not affect the isolation level of the connection.</span></span> <span data-ttu-id="89f35-134">Úrovně izolace nebo rady při zamykání nastavené v uložených procedurách nebo funkcích nemění úroveň izolace připojení, které je volá, a jsou platné pouze po dobu trvání uložené procedury nebo volání funkce.</span><span class="sxs-lookup"><span data-stu-id="89f35-134">Isolation levels or lock hints set in stored procedures or functions do not change the isolation level of the connection that calls them and are in effect only for the duration of the stored procedure or function call.</span></span>  
  
 <span data-ttu-id="89f35-135">V dřívějších verzích serveru SQL Server byly podporovány čtyři úrovně izolace definované ve standardu SQL-92:</span><span class="sxs-lookup"><span data-stu-id="89f35-135">Four isolation levels defined in the SQL-92 standard were supported in early versions of SQL Server:</span></span>  
  
- <span data-ttu-id="89f35-136">READ UNCOMMITTED je nejméně omezující úroveň izolace, protože ignoruje zámky umístěné jinými transakcemi.</span><span class="sxs-lookup"><span data-stu-id="89f35-136">READ UNCOMMITTED is the least restrictive isolation level because it ignores locks placed by other transactions.</span></span> <span data-ttu-id="89f35-137">Transakce prováděné v rámci čtení UNCOMMITTED můžete číst změněné hodnoty dat, které dosud nebyly potvrzeny jinými transakcemi; tyto se nazývají "špinavé" čte.</span><span class="sxs-lookup"><span data-stu-id="89f35-137">Transactions executing under READ UNCOMMITTED can read modified data values that have not yet been committed by other transactions; these are called "dirty" reads.</span></span>  
  
- <span data-ttu-id="89f35-138">Read COMMITTED je výchozí úroveň izolace pro SQL Server.</span><span class="sxs-lookup"><span data-stu-id="89f35-138">READ COMMITTED is the default isolation level for SQL Server.</span></span> <span data-ttu-id="89f35-139">Zabraňuje nečisté čtení zadáním, že příkazy nelze číst hodnoty dat, které byly změněny, ale dosud potvrzeny jinými transakcemi.</span><span class="sxs-lookup"><span data-stu-id="89f35-139">It prevents dirty reads by specifying that statements cannot read data values that have been modified but not yet committed by other transactions.</span></span> <span data-ttu-id="89f35-140">Jiné transakce můžete stále upravovat, vkládat nebo odstraňovat data mezi spuštění jednotlivých příkazů v rámci aktuální transakce, výsledkem je neopakovatelné čtení nebo "fiktivní" data.</span><span class="sxs-lookup"><span data-stu-id="89f35-140">Other transactions can still modify, insert, or delete data between executions of individual statements within the current transaction, resulting in non-repeatable reads, or "phantom" data.</span></span>  
  
- <span data-ttu-id="89f35-141">Opakovatelné čtení je více omezující úroveň izolace než READ COMMITTED.</span><span class="sxs-lookup"><span data-stu-id="89f35-141">REPEATABLE READ is a more restrictive isolation level than READ COMMITTED.</span></span> <span data-ttu-id="89f35-142">Zahrnuje READ COMMITTED a dále určuje, že žádné jiné transakce můžete upravit nebo odstranit data, která byla přečtena aktuální transakce, dokud aktuální transakce potvrdí.</span><span class="sxs-lookup"><span data-stu-id="89f35-142">It encompasses READ COMMITTED and additionally specifies that no other transactions can modify or delete data that has been read by the current transaction until the current transaction commits.</span></span> <span data-ttu-id="89f35-143">Souběžnost je nižší než pro READ COMMITTED, protože sdílené zámky na čtení dat jsou uchovávány po dobu trvání transakce namísto uvolnění na konci každého příkazu.</span><span class="sxs-lookup"><span data-stu-id="89f35-143">Concurrency is lower than for READ COMMITTED because shared locks on read data are held for the duration of the transaction instead of being released at the end of each statement.</span></span>  
  
- <span data-ttu-id="89f35-144">SERIALIZABLE je nejvíce omezující úroveň izolace, protože uzamkne celé rozsahy klíčů a zadrží zámky, dokud není transakce dokončena.</span><span class="sxs-lookup"><span data-stu-id="89f35-144">SERIALIZABLE is the most restrictive isolation level, because it locks entire ranges of keys and holds the locks until the transaction is complete.</span></span> <span data-ttu-id="89f35-145">Zahrnuje opakovatelné čtení a přidá omezení, které ostatní transakce nelze vložit nové řádky do rozsahů, které byly přečteny transakce, dokud transakce je dokončena.</span><span class="sxs-lookup"><span data-stu-id="89f35-145">It encompasses REPEATABLE READ and adds the restriction that other transactions cannot insert new rows into ranges that have been read by the transaction until the transaction is complete.</span></span>  
  
 <span data-ttu-id="89f35-146">Další informace naleznete v [průvodci uzamčením transakcí a verzí řádků](/sql/relational-databases/sql-server-transaction-locking-and-row-versioning-guide).</span><span class="sxs-lookup"><span data-stu-id="89f35-146">For more information, refer to the [Transaction Locking and Row Versioning Guide](/sql/relational-databases/sql-server-transaction-locking-and-row-versioning-guide).</span></span>  
  
### <a name="snapshot-isolation-level-extensions"></a><span data-ttu-id="89f35-147">Rozšíření úrovně izolace snímků</span><span class="sxs-lookup"><span data-stu-id="89f35-147">Snapshot Isolation Level Extensions</span></span>  
 <span data-ttu-id="89f35-148">SQL Server představil rozšíření úrovně izolace SQL-92 se zavedením úrovně izolace SNÍMEK a další implementace READ COMMITTED.</span><span class="sxs-lookup"><span data-stu-id="89f35-148">SQL Server introduced extensions to the SQL-92 isolation levels with the introduction of the SNAPSHOT isolation level and an additional implementation of READ COMMITTED.</span></span> <span data-ttu-id="89f35-149">Úroveň izolace READ_COMMITTED_SNAPSHOT může transparentně nahradit READ COMMITTED pro všechny transakce.</span><span class="sxs-lookup"><span data-stu-id="89f35-149">The READ_COMMITTED_SNAPSHOT isolation level can transparently replace READ COMMITTED for all transactions.</span></span>  
  
- <span data-ttu-id="89f35-150">SNÍMEK izolace určuje, že data čtení v rámci transakce nikdy nebude odrážet změny provedené jinými souběžnými transakcemi.</span><span class="sxs-lookup"><span data-stu-id="89f35-150">SNAPSHOT isolation specifies that data read within a transaction will never reflect changes made by other simultaneous transactions.</span></span> <span data-ttu-id="89f35-151">Transakce používá verze řádků dat, které existují při zahájení transakce.</span><span class="sxs-lookup"><span data-stu-id="89f35-151">The transaction uses the data row versions that exist when the transaction begins.</span></span> <span data-ttu-id="89f35-152">Žádné zámky jsou umístěny na data při čtení, takže transakce SNAPSHOT neblokují jiné transakce z zápisu dat.</span><span class="sxs-lookup"><span data-stu-id="89f35-152">No locks are placed on the data when it is read, so SNAPSHOT transactions do not block other transactions from writing data.</span></span> <span data-ttu-id="89f35-153">Transakce, které zapisují data neblokují transakce snímek z čtení dat.</span><span class="sxs-lookup"><span data-stu-id="89f35-153">Transactions that write data do not block snapshot transactions from reading data.</span></span> <span data-ttu-id="89f35-154">Je třeba povolit izolaci snímku nastavením možnosti databáze ALLOW_SNAPSHOT_ISOLATION, aby bylo možné ji použít.</span><span class="sxs-lookup"><span data-stu-id="89f35-154">You need to enable snapshot isolation by setting the ALLOW_SNAPSHOT_ISOLATION database option in order to use it.</span></span>  
  
- <span data-ttu-id="89f35-155">Možnost READ_COMMITTED_SNAPSHOT databáze určuje chování výchozí úrovně izolace READ COMMITTED, pokud je v databázi povolena izolace snímku.</span><span class="sxs-lookup"><span data-stu-id="89f35-155">The READ_COMMITTED_SNAPSHOT database option determines the behavior of the default READ COMMITTED isolation level when snapshot isolation is enabled in a database.</span></span> <span data-ttu-id="89f35-156">Pokud explicitně nezadáte READ_COMMITTED_SNAPSHOT ON, read potvrzena se použije na všechny implicitní transakce.</span><span class="sxs-lookup"><span data-stu-id="89f35-156">If you do not explicitly specify READ_COMMITTED_SNAPSHOT ON, READ COMMITTED is applied to all implicit transactions.</span></span> <span data-ttu-id="89f35-157">To vytváří stejné chování jako nastavení READ_COMMITTED_SNAPSHOT OFF (výchozí).</span><span class="sxs-lookup"><span data-stu-id="89f35-157">This produces the same behavior as setting READ_COMMITTED_SNAPSHOT OFF (the default).</span></span> <span data-ttu-id="89f35-158">Když READ_COMMITTED_SNAPSHOT OFF je v platnosti, Database Engine používá sdílené zámky vynutit výchozí úroveň izolace.</span><span class="sxs-lookup"><span data-stu-id="89f35-158">When READ_COMMITTED_SNAPSHOT OFF is in effect, the Database Engine uses shared locks to enforce the default isolation level.</span></span> <span data-ttu-id="89f35-159">Pokud nastavíte možnost READ_COMMITTED_SNAPSHOT databáze na ZAPNUTO, databázový stroj používá jako výchozí správu verzí řádků a izolaci snímků, místo toho, aby k ochraně dat používal zámky.</span><span class="sxs-lookup"><span data-stu-id="89f35-159">If you set the READ_COMMITTED_SNAPSHOT database option to ON, the database engine uses row versioning and snapshot isolation as the default, instead of using locks to protect the data.</span></span>  
  
## <a name="how-snapshot-isolation-and-row-versioning-work"></a><span data-ttu-id="89f35-160">Jak funguje izolace snímků a správa verzí řádků</span><span class="sxs-lookup"><span data-stu-id="89f35-160">How Snapshot Isolation and Row Versioning Work</span></span>  
 <span data-ttu-id="89f35-161">Je-li povolena úroveň izolace SNÍMEK, při každé aktualizaci řádku sql server databázový stroj uloží kopii původního řádku v **tempdb**a přidá pořadové číslo transakce do řádku.</span><span class="sxs-lookup"><span data-stu-id="89f35-161">When the SNAPSHOT isolation level is enabled, each time a row is updated, the SQL Server Database Engine stores a copy of the original row in **tempdb**, and adds a transaction sequence number to the row.</span></span> <span data-ttu-id="89f35-162">Následuje posloupnost událostí, ke kterým dochází:</span><span class="sxs-lookup"><span data-stu-id="89f35-162">The following is the sequence of events that occurs:</span></span>  
  
- <span data-ttu-id="89f35-163">Je zahájena nová transakce a je jí přiřazeno pořadové číslo transakce.</span><span class="sxs-lookup"><span data-stu-id="89f35-163">A new transaction is initiated, and it is assigned a transaction sequence number.</span></span>  
  
- <span data-ttu-id="89f35-164">Database Engine přečte řádek v rámci transakce a načte verzi řádku z **tempdb,** jehož pořadové číslo je nejblíže a nižší než pořadové číslo transakce.</span><span class="sxs-lookup"><span data-stu-id="89f35-164">The Database Engine reads a row within the transaction and retrieves the row version from **tempdb** whose sequence number is closest to, and lower than, the transaction sequence number.</span></span>  
  
- <span data-ttu-id="89f35-165">Databázový stroj zkontroluje, zda pořadové číslo transakce není v seznamu pořadových čísel transakcí nepotvrzených transakcí aktivních při spuštění transakce snímku.</span><span class="sxs-lookup"><span data-stu-id="89f35-165">The Database Engine checks to see if the transaction sequence number is not in the list of transaction sequence numbers of the uncommitted transactions active when the snapshot transaction started.</span></span>  
  
- <span data-ttu-id="89f35-166">Transakce přečte verzi řádku z **tempdb,** která byla aktuální od začátku transakce.</span><span class="sxs-lookup"><span data-stu-id="89f35-166">The transaction reads the version of the row from **tempdb** that was current as of the start of the transaction.</span></span> <span data-ttu-id="89f35-167">Po spuštění transakce se nové řádky nezobrazí, protože tyto hodnoty pořadového čísla budou vyšší než hodnota pořadového čísla transakce.</span><span class="sxs-lookup"><span data-stu-id="89f35-167">It will not see new rows inserted after the transaction was started because those sequence number values will be higher than the value of the transaction sequence number.</span></span>  
  
- <span data-ttu-id="89f35-168">Aktuální transakce uvidí řádky, které byly odstraněny po zahájení transakce, protože bude verze řádku v **tempdb** s nižší hodnotou pořadového čísla.</span><span class="sxs-lookup"><span data-stu-id="89f35-168">The current transaction will see rows that were deleted after the transaction began, because there will be a row version in **tempdb** with a lower sequence number value.</span></span>  
  
 <span data-ttu-id="89f35-169">Čistý efekt snímek izolace je, že transakce vidí všechna data, jak existovala na začátku transakce, bez uctívání nebo umístění jakékoli zámky na podkladové tabulky.</span><span class="sxs-lookup"><span data-stu-id="89f35-169">The net effect of snapshot isolation is that the transaction sees all of the data as it existed at the start of the transaction, without honoring or placing any locks on the underlying tables.</span></span> <span data-ttu-id="89f35-170">To může mít za následek zlepšení výkonu v situacích, kdy je tvrzení.</span><span class="sxs-lookup"><span data-stu-id="89f35-170">This can result in performance improvements in situations where there is contention.</span></span>  
  
 <span data-ttu-id="89f35-171">Snímek transakce vždy používá optimistické řízení souběžnosti, srážkové všechny zámky, které by zabránily jiné transakce z aktualizace řádků.</span><span class="sxs-lookup"><span data-stu-id="89f35-171">A snapshot transaction always uses optimistic concurrency control, withholding any locks that would prevent other transactions from updating rows.</span></span> <span data-ttu-id="89f35-172">Pokud snímek transakce pokusí potvrdit aktualizaci do řádku, který byl změněn po zahájení transakce, transakce je vrácena zpět a je vyvolána chyba.</span><span class="sxs-lookup"><span data-stu-id="89f35-172">If a snapshot transaction attempts to commit an update to a row that was changed after the transaction began, the transaction is rolled back, and an error is raised.</span></span>  
  
## <a name="working-with-snapshot-isolation-in-adonet"></a><span data-ttu-id="89f35-173">Práce s izolací snímků v ADO.NET</span><span class="sxs-lookup"><span data-stu-id="89f35-173">Working with Snapshot Isolation in ADO.NET</span></span>  
 <span data-ttu-id="89f35-174">Snímek izolace je <xref:System.Data.SqlClient.SqlTransaction> podporován v ADO.NET třídou.</span><span class="sxs-lookup"><span data-stu-id="89f35-174">Snapshot isolation is supported in ADO.NET by the <xref:System.Data.SqlClient.SqlTransaction> class.</span></span> <span data-ttu-id="89f35-175">Pokud databáze byla povolena pro snímek izolace, ale není <xref:System.Data.SqlClient.SqlTransaction> nakonfigurován pro READ_COMMITTED_SNAPSHOT ON, je <xref:System.Data.SqlClient.SqlConnection.BeginTransaction%2A> nutné zahájit pomocí **IsolationLevel.Snapshot** výčet hodnoty při volání metody.</span><span class="sxs-lookup"><span data-stu-id="89f35-175">If a database has been enabled for snapshot isolation but is not configured for READ_COMMITTED_SNAPSHOT ON, you must initiate a <xref:System.Data.SqlClient.SqlTransaction> using the **IsolationLevel.Snapshot** enumeration value when calling the <xref:System.Data.SqlClient.SqlConnection.BeginTransaction%2A> method.</span></span> <span data-ttu-id="89f35-176">Tento fragment kódu předpokládá, že <xref:System.Data.SqlClient.SqlConnection> připojení je otevřený objekt.</span><span class="sxs-lookup"><span data-stu-id="89f35-176">This code fragment assumes that connection is an open <xref:System.Data.SqlClient.SqlConnection> object.</span></span>  
  
```vb  
Dim sqlTran As SqlTransaction = _  
  connection.BeginTransaction(IsolationLevel.Snapshot)  
```  
  
```csharp  
SqlTransaction sqlTran =
  connection.BeginTransaction(IsolationLevel.Snapshot);  
```  
  
### <a name="example"></a><span data-ttu-id="89f35-177">Příklad</span><span class="sxs-lookup"><span data-stu-id="89f35-177">Example</span></span>  
 <span data-ttu-id="89f35-178">Následující příklad ukazuje, jak se chovají různé úrovně izolace pokusem o přístup k uzamčeným datům a není určen k použití v produkčním kódu.</span><span class="sxs-lookup"><span data-stu-id="89f35-178">The following example demonstrates how the different isolation levels behave by attempting to access locked data, and it is not intended to be used in production code.</span></span>  
  
 <span data-ttu-id="89f35-179">Kód se připojí k ukázkové databázi **AdventureWorks** na serveru SQL Server a vytvoří tabulku s názvem **TestSnapshot** a vloží jeden řádek dat.</span><span class="sxs-lookup"><span data-stu-id="89f35-179">The code connects to the **AdventureWorks** sample database in SQL Server and creates a table named **TestSnapshot** and inserts one row of data.</span></span> <span data-ttu-id="89f35-180">Kód používá příkaz ALTER DATABASE Transact-SQL k zapnutí izolace snímků pro databázi, ale nenastaví možnost READ_COMMITTED_SNAPSHOT, takže výchozí chování na úrovni izolace READ COMMITTED je v platnosti.</span><span class="sxs-lookup"><span data-stu-id="89f35-180">The code uses the ALTER DATABASE Transact-SQL statement to turn on snapshot isolation for the database, but it does not set the READ_COMMITTED_SNAPSHOT option, leaving the default READ COMMITTED isolation-level behavior in effect.</span></span> <span data-ttu-id="89f35-181">Kód pak provede následující akce:</span><span class="sxs-lookup"><span data-stu-id="89f35-181">The code then performs the following actions:</span></span>  
  
- <span data-ttu-id="89f35-182">Začíná, ale nedokončí sqlTransaction1, který používá serializable úroveň izolace ke spuštění transakce aktualizace.</span><span class="sxs-lookup"><span data-stu-id="89f35-182">It begins, but does not complete, sqlTransaction1, which uses the SERIALIZABLE isolation level to start an update transaction.</span></span> <span data-ttu-id="89f35-183">To má za následek uzamčení tabulky.</span><span class="sxs-lookup"><span data-stu-id="89f35-183">This has the effect of locking the table.</span></span>  
  
- <span data-ttu-id="89f35-184">Otevře druhé připojení a zahájí druhou transakci pomocí úrovně izolace SNÍMEK ke čtení dat v tabulce **TestSnapshot.**</span><span class="sxs-lookup"><span data-stu-id="89f35-184">It opens a second connection and initiates a second transaction using the SNAPSHOT isolation level to read the data in the **TestSnapshot** table.</span></span> <span data-ttu-id="89f35-185">Vzhledem k tomu, že je povolena izolace snímku, tato transakce můžete číst data, která existovala před sqlTransaction1 started.</span><span class="sxs-lookup"><span data-stu-id="89f35-185">Because snapshot isolation is enabled, this transaction can read the data that existed before sqlTransaction1 started.</span></span>  
  
- <span data-ttu-id="89f35-186">Otevře třetí připojení a zahájí transakci pomocí úrovně izolace READ COMMITTED k pokusu o čtení dat v tabulce.</span><span class="sxs-lookup"><span data-stu-id="89f35-186">It opens a third connection and initiates a transaction using the READ COMMITTED isolation level to attempt to read the data in the table.</span></span> <span data-ttu-id="89f35-187">V tomto případě kód nelze číst data, protože nelze číst za zámky umístěné v tabulce v první transakci a časový čas. Stejný výsledek by došlo, pokud opakovatelné čtení a serializable úrovně izolace byly použity, protože tyto úrovně izolace také nelze číst za zámky umístěné v první transakci.</span><span class="sxs-lookup"><span data-stu-id="89f35-187">In this case, the code cannot read the data because it cannot read past the locks placed on the table in the first transaction and times out. The same result would occur if the REPEATABLE READ and SERIALIZABLE isolation levels were used because these isolation levels also cannot read past the locks placed in the first transaction.</span></span>  
  
- <span data-ttu-id="89f35-188">Otevře čtvrté připojení a zahájí transakci pomocí úrovně izolace READ UNCOMMITTED, která provádí nečisté čtení nepotvrzené hodnoty v sqlTransaction1.</span><span class="sxs-lookup"><span data-stu-id="89f35-188">It opens a fourth connection and initiates a transaction using the READ UNCOMMITTED isolation level, which performs a dirty read of the uncommitted value in sqlTransaction1.</span></span> <span data-ttu-id="89f35-189">Tato hodnota může nikdy skutečně existovat v databázi, pokud první transakce není potvrzena.</span><span class="sxs-lookup"><span data-stu-id="89f35-189">This value may never actually exist in the database if the first transaction is not committed.</span></span>  
  
- <span data-ttu-id="89f35-190">Vrátí zpět první transakce a vyčistí odstraněním **TestSnapshot** tabulka a vypnutí izolace snímek pro **adventureworks** databáze.</span><span class="sxs-lookup"><span data-stu-id="89f35-190">It rolls back the first transaction and cleans up by deleting the **TestSnapshot** table and turning off snapshot isolation for the **AdventureWorks** database.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="89f35-191">Následující příklady používají stejný připojovací řetězec s vypnutým sdružováním připojení.</span><span class="sxs-lookup"><span data-stu-id="89f35-191">The following examples use the same connection string with connection pooling turned off.</span></span> <span data-ttu-id="89f35-192">Pokud je připojení sdruženo, obnovení jeho úrovně izolace neobnoví úroveň izolace na serveru.</span><span class="sxs-lookup"><span data-stu-id="89f35-192">If a connection is pooled, resetting its isolation level does not reset the isolation level at the server.</span></span> <span data-ttu-id="89f35-193">V důsledku toho následná připojení, které používají stejné sdružené vnitřní připojení začít s jejich úrovně izolace nastavena na sdružené připojení.</span><span class="sxs-lookup"><span data-stu-id="89f35-193">As a result, subsequent connections that use the same pooled inner connection start with their isolation levels set to that of the pooled connection.</span></span> <span data-ttu-id="89f35-194">Alternativou k vypnutí sdružování připojení je explicitně nastavit úroveň izolace pro každé připojení.</span><span class="sxs-lookup"><span data-stu-id="89f35-194">An alternative to turning off connection pooling is to set the isolation level explicitly for each connection.</span></span>  
  
 [!code-csharp[DataWorks SnapshotIsolation.Demo#1](../../../../../samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks SnapshotIsolation.Demo/CS/source.cs#1)]
 [!code-vb[DataWorks SnapshotIsolation.Demo#1](../../../../../samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks SnapshotIsolation.Demo/VB/source.vb#1)]  
  
### <a name="example"></a><span data-ttu-id="89f35-195">Příklad</span><span class="sxs-lookup"><span data-stu-id="89f35-195">Example</span></span>  
 <span data-ttu-id="89f35-196">Následující příklad ukazuje chování snímek izolace při změně dat.</span><span class="sxs-lookup"><span data-stu-id="89f35-196">The following example demonstrates the behavior of snapshot isolation when data is being modified.</span></span> <span data-ttu-id="89f35-197">Kód provádí následující akce:</span><span class="sxs-lookup"><span data-stu-id="89f35-197">The code performs the following actions:</span></span>  
  
- <span data-ttu-id="89f35-198">Připojí se k ukázkové databázi **AdventureWorks** a povolí izolaci SNAPSHOT.</span><span class="sxs-lookup"><span data-stu-id="89f35-198">Connects to the **AdventureWorks** sample database and enables SNAPSHOT isolation.</span></span>  
  
- <span data-ttu-id="89f35-199">Vytvoří tabulku s názvem **TestSnapshotUpdate** a vloží tři řádky ukázkových dat.</span><span class="sxs-lookup"><span data-stu-id="89f35-199">Creates a table named **TestSnapshotUpdate** and inserts three rows of sample data.</span></span>  
  
- <span data-ttu-id="89f35-200">Začíná, ale nedokončí sqlTransaction1 pomocí izolace SNÍMEK.</span><span class="sxs-lookup"><span data-stu-id="89f35-200">Begins, but does not complete, sqlTransaction1 using SNAPSHOT isolation.</span></span> <span data-ttu-id="89f35-201">V transakci jsou vybrány tři řádky dat.</span><span class="sxs-lookup"><span data-stu-id="89f35-201">Three rows of data are selected in the transaction.</span></span>  
  
- <span data-ttu-id="89f35-202">Vytvoří druhé **SqlConnection** na **AdventureWorks** a vytvoří druhou transakci pomocí úrovně izolace READ COMMITTED, která aktualizuje hodnotu v jednom z řádků vybraných v sqlTransaction1.</span><span class="sxs-lookup"><span data-stu-id="89f35-202">Creates a second **SqlConnection** to **AdventureWorks** and creates a second transaction using the READ COMMITTED isolation level that updates a value in one of the rows selected in sqlTransaction1.</span></span>  
  
- <span data-ttu-id="89f35-203">Potvrdí sqlTransaction2.</span><span class="sxs-lookup"><span data-stu-id="89f35-203">Commits sqlTransaction2.</span></span>  
  
- <span data-ttu-id="89f35-204">Vrátí sqlTransaction1 a pokusí se aktualizovat stejný řádek, který sqlTransaction1 již potvrzena.</span><span class="sxs-lookup"><span data-stu-id="89f35-204">Returns to sqlTransaction1 and attempts to update the same row that sqlTransaction1 already committed.</span></span> <span data-ttu-id="89f35-205">Je vyvolána chyba 3960 a sqlTransaction1 je vrácena zpět automaticky.</span><span class="sxs-lookup"><span data-stu-id="89f35-205">Error 3960 is raised, and sqlTransaction1 is rolled back automatically.</span></span> <span data-ttu-id="89f35-206">**SqlException.Number** a **SqlException.Message** jsou zobrazeny v okně konzoly.</span><span class="sxs-lookup"><span data-stu-id="89f35-206">The **SqlException.Number** and **SqlException.Message** are displayed in the Console window.</span></span>  
  
- <span data-ttu-id="89f35-207">Spustí vyčištění kód vypnout snímek izolace v **AdventureWorks** a odstranit **TestSnapshotUpdate** tabulka.</span><span class="sxs-lookup"><span data-stu-id="89f35-207">Executes clean-up code to turn off snapshot isolation in **AdventureWorks** and delete the **TestSnapshotUpdate** table.</span></span>  
  
 [!code-csharp[DataWorks SnapshotIsolation.DemoUpdate#1](../../../../../samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks SnapshotIsolation.DemoUpdate/CS/source.cs#1)]
 [!code-vb[DataWorks SnapshotIsolation.DemoUpdate#1](../../../../../samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks SnapshotIsolation.DemoUpdate/VB/source.vb#1)]  
  
### <a name="using-lock-hints-with-snapshot-isolation"></a><span data-ttu-id="89f35-208">Použití rady při psaní bodů zámku s izolací snímků</span><span class="sxs-lookup"><span data-stu-id="89f35-208">Using Lock Hints with Snapshot Isolation</span></span>  
 <span data-ttu-id="89f35-209">V předchozím příkladu první transakce vybere data a druhá transakce aktualizuje data před první transakce je možné dokončit, což způsobuje konflikt aktualizace při první transakce se pokusí aktualizovat stejný řádek.</span><span class="sxs-lookup"><span data-stu-id="89f35-209">In the previous example, the first transaction selects data, and a second transaction updates the data before the first transaction is able to complete, causing an update conflict when the first transaction tries to update the same row.</span></span> <span data-ttu-id="89f35-210">Můžete snížit pravděpodobnost konfliktů aktualizace v dlouhotrvající snímek transakce zadáním rady zámku na začátku transakce.</span><span class="sxs-lookup"><span data-stu-id="89f35-210">You can reduce the chance of update conflicts in long-running snapshot transactions by supplying lock hints at the beginning of the transaction.</span></span> <span data-ttu-id="89f35-211">Následující příkaz SELECT používá nápovědu UPDLOCK k uzamčení vybraných řádků:</span><span class="sxs-lookup"><span data-stu-id="89f35-211">The following SELECT statement uses the UPDLOCK hint to lock the selected rows:</span></span>  
  
```sql  
SELECT * FROM TestSnapshotUpdate WITH (UPDLOCK)
  WHERE PriKey BETWEEN 1 AND 3  
```  
  
 <span data-ttu-id="89f35-212">Pomocí nápovědy zámku UPDLOCK blokuje všechny řádky, které se pokoušejí aktualizovat řádky před dokončením první transakce.</span><span class="sxs-lookup"><span data-stu-id="89f35-212">Using the UPDLOCK lock hint blocks any rows attempting to update the rows before the first transaction completes.</span></span> <span data-ttu-id="89f35-213">To zaručuje, že vybrané řádky nemají žádné konflikty při jejich pozdější aktualizaci v transakci.</span><span class="sxs-lookup"><span data-stu-id="89f35-213">This guarantees that the selected rows have no conflicts when they are updated later in the transaction.</span></span> <span data-ttu-id="89f35-214">Viz "Zamykání rady" v SQL Server Knihy Online.</span><span class="sxs-lookup"><span data-stu-id="89f35-214">See "Locking Hints" in SQL Server Books Online.</span></span>  
  
 <span data-ttu-id="89f35-215">Pokud vaše aplikace má mnoho konfliktů, snímek izolace nemusí být nejlepší volbou.</span><span class="sxs-lookup"><span data-stu-id="89f35-215">If your application has many conflicts, snapshot isolation may not be the best choice.</span></span> <span data-ttu-id="89f35-216">Rady by měly být používány pouze v případě, že je to skutečně potřeba.</span><span class="sxs-lookup"><span data-stu-id="89f35-216">Hints should only be used when really needed.</span></span> <span data-ttu-id="89f35-217">Vaše aplikace by neměla být navržena tak, aby neustále spoléhá na tipy zámku pro jeho provoz.</span><span class="sxs-lookup"><span data-stu-id="89f35-217">Your application should not be designed so that it constantly relies on lock hints for its operation.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="89f35-218">Viz také</span><span class="sxs-lookup"><span data-stu-id="89f35-218">See also</span></span>

- [<span data-ttu-id="89f35-219">SQL Server a ADO.NET</span><span class="sxs-lookup"><span data-stu-id="89f35-219">SQL Server and ADO.NET</span></span>](index.md)
- [<span data-ttu-id="89f35-220">Přehled ADO.NET</span><span class="sxs-lookup"><span data-stu-id="89f35-220">ADO.NET Overview</span></span>](../ado-net-overview.md)
- [<span data-ttu-id="89f35-221">Průvodce uzamčením transakcí a verzí řádků</span><span class="sxs-lookup"><span data-stu-id="89f35-221">Transaction Locking and Row Versioning Guide</span></span>](/sql/relational-databases/sql-server-transaction-locking-and-row-versioning-guide)
