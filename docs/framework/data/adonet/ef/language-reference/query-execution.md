---
title: Provádění dotazů
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
ms.assetid: c0e6cf23-63ac-47dd-bfe9-d5bdca826fac
ms.openlocfilehash: e372744eea3eed7fc3f7ee9c8bbdd711c95b586e
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 03/12/2020
ms.locfileid: "79149970"
---
# <a name="query-execution"></a><span data-ttu-id="3e0b4-102">Provádění dotazů</span><span class="sxs-lookup"><span data-stu-id="3e0b4-102">Query Execution</span></span>
<span data-ttu-id="3e0b4-103">Po vytvoření dotazu LINQ uživatelem je převeden na strom příkazů.</span><span class="sxs-lookup"><span data-stu-id="3e0b4-103">After a LINQ query is created by a user, it is converted to a command tree.</span></span> <span data-ttu-id="3e0b4-104">Strom příkazů je reprezentace dotazu, který je kompatibilní s entity framework.</span><span class="sxs-lookup"><span data-stu-id="3e0b4-104">A command tree is a representation of a query that is compatible with the Entity Framework.</span></span> <span data-ttu-id="3e0b4-105">Strom příkazů je pak proveden proti zdroji dat.</span><span class="sxs-lookup"><span data-stu-id="3e0b4-105">The command tree is then executed against the data source.</span></span> <span data-ttu-id="3e0b4-106">V době spuštění dotazu jsou vyhodnoceny všechny výrazy dotazu (tj. všechny součásti dotazu), včetně výrazů, které se používají při materializaci výsledku.</span><span class="sxs-lookup"><span data-stu-id="3e0b4-106">At query execution time, all query expressions (that is, all components of the query) are evaluated, including those expressions that are used in result materialization.</span></span>  
  
 <span data-ttu-id="3e0b4-107">V jakém okamžiku jsou výrazy dotazu spuštěny se mohou lišit.</span><span class="sxs-lookup"><span data-stu-id="3e0b4-107">At what point query expressions are executed can vary.</span></span> <span data-ttu-id="3e0b4-108">Linq dotazy jsou vždy spuštěny, když je proměnná dotazu iterována, nikoli při vytvoření proměnné dotazu.</span><span class="sxs-lookup"><span data-stu-id="3e0b4-108">LINQ queries are always executed when the query variable is iterated over, not when the query variable is created.</span></span> <span data-ttu-id="3e0b4-109">To se nazývá *odložené spuštění*.</span><span class="sxs-lookup"><span data-stu-id="3e0b4-109">This is called *deferred execution*.</span></span> <span data-ttu-id="3e0b4-110">Můžete také vynutit okamžité spuštění dotazu, což je užitečné pro ukládání výsledků dotazu do mezipaměti.</span><span class="sxs-lookup"><span data-stu-id="3e0b4-110">You can also force a query to execute immediately, which is useful for caching query results.</span></span> <span data-ttu-id="3e0b4-111">To je popsáno dále v tomto tématu.</span><span class="sxs-lookup"><span data-stu-id="3e0b4-111">This is described later in this topic.</span></span>  
  
 <span data-ttu-id="3e0b4-112">Při spuštění dotazu LINQ entity, některé výrazy v dotazu může být spuštěn a některé části mohou být provedeny místně na straně klienta.</span><span class="sxs-lookup"><span data-stu-id="3e0b4-112">When a LINQ to Entities query is executed, some expressions in the query might be executed on the server and some parts might be executed locally on the client.</span></span> <span data-ttu-id="3e0b4-113">Vyhodnocení výrazu na straně klienta probíhá před spuštěním dotazu na serveru.</span><span class="sxs-lookup"><span data-stu-id="3e0b4-113">Client-side evaluation of an expression takes place before the query is executed on the server.</span></span> <span data-ttu-id="3e0b4-114">Pokud je výraz vyhodnocen na straně klienta, výsledek tohoto vyhodnocení je nahrazen výrazem v dotazu a dotaz je pak proveden na serveru.</span><span class="sxs-lookup"><span data-stu-id="3e0b4-114">If an expression is evaluated on the client, the result of that evaluation is substituted for the expression in the query, and the query is then executed on the server.</span></span> <span data-ttu-id="3e0b4-115">Vzhledem k tomu, že dotazy jsou spouštěny ve zdroji dat, konfigurace zdroje dat přepíše chování zadané v klientovi.</span><span class="sxs-lookup"><span data-stu-id="3e0b4-115">Because queries are executed on the data source, the data source configuration overrides the behavior specified in the client.</span></span> <span data-ttu-id="3e0b4-116">Například zpracování nulové hodnoty a číselná přesnost závisí na nastavení serveru.</span><span class="sxs-lookup"><span data-stu-id="3e0b4-116">For example, null value handling and numerical precision depend on the server settings.</span></span> <span data-ttu-id="3e0b4-117">Všechny výjimky vyvoláné během provádění dotazu na serveru jsou předány přímo klientovi.</span><span class="sxs-lookup"><span data-stu-id="3e0b4-117">Any exceptions thrown during query execution on the server are passed directly up to the client.</span></span>  

> [!TIP]
> <span data-ttu-id="3e0b4-118">Pro pohodlný souhrn operátorů dotazů ve formátu tabulky, který umožňuje rychle identifikovat chování spuštění operátoru, naleznete [v tématu Klasifikace operátorů standardních dotazů podle způsobu spuštění (C#)](../../../../../csharp/programming-guide/concepts/linq/classification-of-standard-query-operators-by-manner-of-execution.md).</span><span class="sxs-lookup"><span data-stu-id="3e0b4-118">For a convenient summary of query operators in table format, which lets you quickly identify an operator's execution behavior, see [Classification of Standard Query Operators by Manner of Execution (C#)](../../../../../csharp/programming-guide/concepts/linq/classification-of-standard-query-operators-by-manner-of-execution.md).</span></span>

## <a name="deferred-query-execution"></a><span data-ttu-id="3e0b4-119">Odložené spuštění dotazu</span><span class="sxs-lookup"><span data-stu-id="3e0b4-119">Deferred query execution</span></span>  
 <span data-ttu-id="3e0b4-120">V dotazu, který vrací posloupnost hodnot, samotná proměnná dotazu nikdy neobsahuje výsledky dotazu a ukládá pouze příkazy dotazu.</span><span class="sxs-lookup"><span data-stu-id="3e0b4-120">In a query that returns a sequence of values, the query variable itself never holds the query results and only stores the query commands.</span></span> <span data-ttu-id="3e0b4-121">Spuštění dotazu je odloženo, dokud je proměnná `foreach` dotazu iterována ve smyčce nebo. `For Each`</span><span class="sxs-lookup"><span data-stu-id="3e0b4-121">Execution of the query is deferred until the query variable is iterated over in a `foreach` or `For Each` loop.</span></span> <span data-ttu-id="3e0b4-122">To se označuje jako *odložené spuštění*; to znamená, že spuštění dotazu nastane nějaký čas po vytvoření dotazu.</span><span class="sxs-lookup"><span data-stu-id="3e0b4-122">This is known as *deferred execution*; that is, query execution occurs some time after the query is constructed.</span></span> <span data-ttu-id="3e0b4-123">To znamená, že můžete spustit dotaz tak často, jak chcete.</span><span class="sxs-lookup"><span data-stu-id="3e0b4-123">This means that you can execute a query as frequently as you want to.</span></span> <span data-ttu-id="3e0b4-124">To je užitečné například v případě, že máte databázi, která je aktualizována jinými aplikacemi.</span><span class="sxs-lookup"><span data-stu-id="3e0b4-124">This is useful when, for example, you have a database that is being updated by other applications.</span></span> <span data-ttu-id="3e0b4-125">V aplikaci můžete vytvořit dotaz pro načtení nejnovějších informací a opakovaně spustit dotaz, vrácení aktualizovaných informací pokaždé.</span><span class="sxs-lookup"><span data-stu-id="3e0b4-125">In your application, you can create a query to retrieve the latest information and repeatedly execute the query, returning the updated information every time.</span></span>  
  
 <span data-ttu-id="3e0b4-126">Odložené spuštění umožňuje více dotazů, které mají být kombinovány nebo dotaz, který má být rozšířen.</span><span class="sxs-lookup"><span data-stu-id="3e0b4-126">Deferred execution enables multiple queries to be combined or a query to be extended.</span></span> <span data-ttu-id="3e0b4-127">Při rozšíření dotazu je upraven tak, aby zahrnovala nové operace a případné spuštění bude odrážet změny.</span><span class="sxs-lookup"><span data-stu-id="3e0b4-127">When a query is extended, it is modified to include the new operations, and the eventual execution will reflect the changes.</span></span> <span data-ttu-id="3e0b4-128">V následujícím příkladu první dotaz vrátí všechny produkty.</span><span class="sxs-lookup"><span data-stu-id="3e0b4-128">In the following example, the first query returns all the products.</span></span> <span data-ttu-id="3e0b4-129">Druhý dotaz rozšiřuje první pomocí `Where` vrátit všechny produkty velikosti "L":</span><span class="sxs-lookup"><span data-stu-id="3e0b4-129">The second query extends the first by using `Where` to return all the products of size "L":</span></span>  
  
 [!code-csharp[DP L2E Conceptual Examples#Composing1](../../../../../../samples/snippets/csharp/VS_Snippets_Data/DP L2E Conceptual Examples/CS/Program.cs#composing1)]
 [!code-vb[DP L2E Conceptual Examples#Composing1](../../../../../../samples/snippets/visualbasic/VS_Snippets_Data/DP L2E Conceptual Examples/VB/Module1.vb#composing1)]  
  
 <span data-ttu-id="3e0b4-130">Po spuštění dotazu budou všechny následné dotazy používat operátory LINQ v paměti.</span><span class="sxs-lookup"><span data-stu-id="3e0b4-130">After a query has been executed all successive queries will use the in-memory LINQ operators.</span></span> <span data-ttu-id="3e0b4-131">Iterace přes proměnnou dotazu pomocí `foreach` nebo `For Each` příkaz nebo voláním jednoho z operátorů převodu LINQ způsobí okamžité spuštění.</span><span class="sxs-lookup"><span data-stu-id="3e0b4-131">Iterating over the query variable by using a `foreach` or `For Each` statement or by calling one of the LINQ conversion operators will cause immediate execution.</span></span> <span data-ttu-id="3e0b4-132">Tyto operátory převodu <xref:System.Linq.Enumerable.ToList%2A> <xref:System.Linq.Enumerable.ToArray%2A>zahrnují <xref:System.Linq.Enumerable.ToLookup%2A>následující: , , a <xref:System.Linq.Enumerable.ToDictionary%2A>.</span><span class="sxs-lookup"><span data-stu-id="3e0b4-132">These conversion operators include the following: <xref:System.Linq.Enumerable.ToList%2A>, <xref:System.Linq.Enumerable.ToArray%2A>, <xref:System.Linq.Enumerable.ToLookup%2A>, and <xref:System.Linq.Enumerable.ToDictionary%2A>.</span></span>  
  
## <a name="immediate-query-execution"></a><span data-ttu-id="3e0b4-133">Okamžité spuštění dotazu</span><span class="sxs-lookup"><span data-stu-id="3e0b4-133">Immediate Query Execution</span></span>  
 <span data-ttu-id="3e0b4-134">Na rozdíl od odložené provádění dotazů, které vytvářejí posloupnost hodnot, dotazy, které vracejí hodnotu singleton jsou provedeny okamžitě.</span><span class="sxs-lookup"><span data-stu-id="3e0b4-134">In contrast to the deferred execution of queries that produce a sequence of values, queries that return a singleton value are executed immediately.</span></span> <span data-ttu-id="3e0b4-135">Některé příklady singleton dotazů <xref:System.Linq.Enumerable.Count%2A> <xref:System.Linq.Enumerable.First%2A>jsou <xref:System.Linq.Enumerable.Average%2A> <xref:System.Linq.Enumerable.Max%2A>, , a .</span><span class="sxs-lookup"><span data-stu-id="3e0b4-135">Some examples of singleton queries are <xref:System.Linq.Enumerable.Average%2A>, <xref:System.Linq.Enumerable.Count%2A>, <xref:System.Linq.Enumerable.First%2A>, and <xref:System.Linq.Enumerable.Max%2A>.</span></span> <span data-ttu-id="3e0b4-136">Tyto spustit okamžitě, protože dotaz musí vytvořit posloupnost pro výpočet výsledku singleton.</span><span class="sxs-lookup"><span data-stu-id="3e0b4-136">These execute immediately because the query must produce a sequence to calculate the singleton result.</span></span> <span data-ttu-id="3e0b4-137">Můžete také vynutit okamžitou popravu.</span><span class="sxs-lookup"><span data-stu-id="3e0b4-137">You can also force immediate execution.</span></span> <span data-ttu-id="3e0b4-138">To je užitečné, pokud chcete uložit výsledky dotazu do mezipaměti.</span><span class="sxs-lookup"><span data-stu-id="3e0b4-138">This is useful when you want to cache the results of a query.</span></span> <span data-ttu-id="3e0b4-139">Chcete-li vynutit okamžité spuštění dotazu, který nevytváří <xref:System.Linq.Enumerable.ToList%2A> hodnotu <xref:System.Linq.Enumerable.ToDictionary%2A> singleton, <xref:System.Linq.Enumerable.ToArray%2A> můžete volat metodu, metodu nebo metodu v proměnné dotazu nebo dotazu.</span><span class="sxs-lookup"><span data-stu-id="3e0b4-139">To force immediate execution of a query that does not produce a singleton value, you can call the <xref:System.Linq.Enumerable.ToList%2A> method, the <xref:System.Linq.Enumerable.ToDictionary%2A> method, or the <xref:System.Linq.Enumerable.ToArray%2A> method on a query or query variable.</span></span> <span data-ttu-id="3e0b4-140">Následující příklad používá <xref:System.Linq.Enumerable.ToArray%2A> metodu okamžitě vyhodnotit sekvenci do pole.</span><span class="sxs-lookup"><span data-stu-id="3e0b4-140">The following example uses the <xref:System.Linq.Enumerable.ToArray%2A> method to immediately evaluate a sequence into an array.</span></span>  
  
 [!code-csharp[DP L2E Examples#ToArray](../../../../../../samples/snippets/csharp/VS_Snippets_Data/DP L2E Examples/CS/Program.cs#toarray)]
 [!code-vb[DP L2E Examples#ToArray](../../../../../../samples/snippets/visualbasic/VS_Snippets_Data/DP L2E Examples/VB/Module1.vb#toarray)]  
  
 <span data-ttu-id="3e0b4-141">Můžete také vynutit `foreach` spuštění `For Each` vložením nebo smyčky bezprostředně <xref:System.Linq.Enumerable.ToList%2A> za <xref:System.Linq.Enumerable.ToArray%2A> výraz dotazu, ale voláním nebo mezipaměti všechna data v jednom objektu kolekce.</span><span class="sxs-lookup"><span data-stu-id="3e0b4-141">You could also force execution by putting the `foreach` or `For Each` loop immediately after the query expression, but by calling <xref:System.Linq.Enumerable.ToList%2A> or <xref:System.Linq.Enumerable.ToArray%2A> you cache all the data in a single collection object.</span></span>  
  
## <a name="store-execution"></a><span data-ttu-id="3e0b4-142">Spuštění úložiště</span><span class="sxs-lookup"><span data-stu-id="3e0b4-142">Store Execution</span></span>  
 <span data-ttu-id="3e0b4-143">Obecně platí, že výrazy v LINQ entity jsou vyhodnocovány na serveru a chování výrazu by nemělo být očekáváno, že bude následovat sémantiku cltime společného jazyka (CLR), ale sémantiku zdroje dat.</span><span class="sxs-lookup"><span data-stu-id="3e0b4-143">In general, expressions in LINQ to Entities are evaluated on the server, and the behavior of the expression should not be expected to follow common language runtime (CLR) semantics, but those of the data source.</span></span> <span data-ttu-id="3e0b4-144">Existují však výjimky, například při spuštění výrazu na straně klienta.</span><span class="sxs-lookup"><span data-stu-id="3e0b4-144">There are exceptions to this, however, such as when the expression is executed on the client.</span></span> <span data-ttu-id="3e0b4-145">To může způsobit neočekávané výsledky, například pokud jsou server a klient v různých časových pásmech.</span><span class="sxs-lookup"><span data-stu-id="3e0b4-145">This could cause unexpected results, for example when the server and client are in different time zones.</span></span>  
  
 <span data-ttu-id="3e0b4-146">Některé výrazy v dotazu mohou být spuštěny na straně klienta.</span><span class="sxs-lookup"><span data-stu-id="3e0b4-146">Some expressions in the query might be executed on the client.</span></span> <span data-ttu-id="3e0b4-147">Obecně se očekává, že většina spuštění dotazu dojde na serveru.</span><span class="sxs-lookup"><span data-stu-id="3e0b4-147">In general, most query execution is expected to occur on the server.</span></span> <span data-ttu-id="3e0b4-148">Kromě metod prováděných proti prvkům dotazu mapovaným na zdroj dat jsou často výrazy v dotazu, které lze spustit místně.</span><span class="sxs-lookup"><span data-stu-id="3e0b4-148">Aside from methods executed against query elements mapped to the data source, there are often expressions in the query that can be executed locally.</span></span> <span data-ttu-id="3e0b4-149">Místní spuštění výrazu dotazu poskytuje hodnotu, která může být použita při provádění dotazu nebo konstrukci výsledků.</span><span class="sxs-lookup"><span data-stu-id="3e0b4-149">Local execution of a query expression yields a value that can be used in the query execution or result construction.</span></span>  
  
 <span data-ttu-id="3e0b4-150">Některé operace jsou vždy prováděny na straně klienta, jako je například vazba hodnot, dílčí výrazy, dílčí dotazy z uzavření a materializace objektů do výsledků dotazu.</span><span class="sxs-lookup"><span data-stu-id="3e0b4-150">Certain operations are always executed on the client, such as binding of values, sub expressions, sub queries from closures, and materialization of objects into query results.</span></span> <span data-ttu-id="3e0b4-151">Čistým důsledkem je, že tyto prvky (například hodnoty parametrů) nelze aktualizovat během provádění.</span><span class="sxs-lookup"><span data-stu-id="3e0b4-151">The net effect of this is that these elements (for example, parameter values) cannot be updated during the execution.</span></span> <span data-ttu-id="3e0b4-152">Anonymní typy mohou být vytvořeny vložku na zdroj dat, ale nemělo by se předpokládat, že tak učiníte.</span><span class="sxs-lookup"><span data-stu-id="3e0b4-152">Anonymous types can be constructed inline on the data source, but should not be assumed to do so.</span></span> <span data-ttu-id="3e0b4-153">Vložková seskupení mohou být vytvořena také ve zdroji dat, ale to by nemělo být předpokládáno v každém případě.</span><span class="sxs-lookup"><span data-stu-id="3e0b4-153">Inline groupings can be constructed in the data source, as well, but this should not be assumed in every instance.</span></span> <span data-ttu-id="3e0b4-154">Obecně je nejlepší neprovádět žádné předpoklady o tom, co je konstruováno na serveru.</span><span class="sxs-lookup"><span data-stu-id="3e0b4-154">In general, it is best not to make any assumptions about what is constructed on the server.</span></span>  
  
 <span data-ttu-id="3e0b4-155">Tato část popisuje scénáře, ve kterých je kód spuštěn místně na straně klienta.</span><span class="sxs-lookup"><span data-stu-id="3e0b4-155">This section describes the scenarios in which code is executed locally on the client.</span></span> <span data-ttu-id="3e0b4-156">Další informace o typech výrazů jsou spouštěny místně, naleznete [v tématu Výrazy v LINQ k entitám dotazy](expressions-in-linq-to-entities-queries.md).</span><span class="sxs-lookup"><span data-stu-id="3e0b4-156">For more information about which types of expressions are executed locally, see [Expressions in LINQ to Entities Queries](expressions-in-linq-to-entities-queries.md).</span></span>  
  
### <a name="literals-and-parameters"></a><span data-ttu-id="3e0b4-157">Literály a parametry</span><span class="sxs-lookup"><span data-stu-id="3e0b4-157">Literals and Parameters</span></span>  
 <span data-ttu-id="3e0b4-158">Místní proměnné, jako `orderID` je například proměnná v následujícím příkladu, jsou vyhodnocovány na straně klienta.</span><span class="sxs-lookup"><span data-stu-id="3e0b4-158">Local variables, such as the `orderID` variable in the following example, are evaluated on the client.</span></span>  
  
 [!code-csharp[DP L2E Conceptual Examples#LiteralParameter1](../../../../../../samples/snippets/csharp/VS_Snippets_Data/DP L2E Conceptual Examples/CS/Program.cs#literalparameter1)]
 [!code-vb[DP L2E Conceptual Examples#LiteralParameter1](../../../../../../samples/snippets/visualbasic/VS_Snippets_Data/DP L2E Conceptual Examples/VB/Module1.vb#literalparameter1)]  
  
 <span data-ttu-id="3e0b4-159">Parametry metody jsou také vyhodnocovány na straně klienta.</span><span class="sxs-lookup"><span data-stu-id="3e0b4-159">Method parameters are also evaluated on the client.</span></span> <span data-ttu-id="3e0b4-160">Parametr `orderID` předaný `MethodParameterExample` do metody, níže, je příkladem.</span><span class="sxs-lookup"><span data-stu-id="3e0b4-160">The `orderID` parameter passed into the `MethodParameterExample` method, below, is an example.</span></span>  
  
 [!code-csharp[DP L2E Conceptual Examples#MethodParameterExample](../../../../../../samples/snippets/csharp/VS_Snippets_Data/DP L2E Conceptual Examples/CS/Program.cs#methodparameterexample)]
 [!code-vb[DP L2E Conceptual Examples#MethodParameterExample](../../../../../../samples/snippets/visualbasic/VS_Snippets_Data/DP L2E Conceptual Examples/VB/Module1.vb#methodparameterexample)]  
  
### <a name="casting-literals-on-the-client"></a><span data-ttu-id="3e0b4-161">Odlévání literály na klienta</span><span class="sxs-lookup"><span data-stu-id="3e0b4-161">Casting Literals on the Client</span></span>  
 <span data-ttu-id="3e0b4-162">Přetypování z `null` typu CLR je spuštěno na straně klienta:</span><span class="sxs-lookup"><span data-stu-id="3e0b4-162">Casting from `null` to a CLR type is executed on the client:</span></span>  
  
 [!code-csharp[DP L2E Conceptual Examples#NullCastToString](../../../../../../samples/snippets/csharp/VS_Snippets_Data/DP L2E Conceptual Examples/CS/Program.cs#nullcasttostring)]
 [!code-vb[DP L2E Conceptual Examples#NullCastToString](../../../../../../samples/snippets/visualbasic/VS_Snippets_Data/DP L2E Conceptual Examples/VB/Module1.vb#nullcasttostring)]  
  
 <span data-ttu-id="3e0b4-163">Přetypování na typ, například hodnotu null, <xref:System.Decimal>je na straně klienta spuštěno:</span><span class="sxs-lookup"><span data-stu-id="3e0b4-163">Casting to a type, such as a nullable <xref:System.Decimal>, is executed on the client:</span></span>  
  
 [!code-csharp[DP L2E Conceptual Examples#CastToNullable](../../../../../../samples/snippets/csharp/VS_Snippets_Data/DP L2E Conceptual Examples/CS/Program.cs#casttonullable)]
 [!code-vb[DP L2E Conceptual Examples#CastToNullable](../../../../../../samples/snippets/visualbasic/VS_Snippets_Data/DP L2E Conceptual Examples/VB/Module1.vb#casttonullable)]  
  
### <a name="constructors-for-literals"></a><span data-ttu-id="3e0b4-164">Konstruktory pro literály</span><span class="sxs-lookup"><span data-stu-id="3e0b4-164">Constructors for Literals</span></span>  
 <span data-ttu-id="3e0b4-165">Nové typy CLR, které lze mapovat na konceptuální typy modelů, jsou spouštěny na straně klienta:</span><span class="sxs-lookup"><span data-stu-id="3e0b4-165">New CLR types that can be mapped to conceptual model types are executed on the client:</span></span>  
  
 [!code-csharp[DP L2E Conceptual Examples#ConstructorForLiteral](../../../../../../samples/snippets/csharp/VS_Snippets_Data/DP L2E Conceptual Examples/CS/Program.cs#constructorforliteral)]
 [!code-vb[DP L2E Conceptual Examples#ConstructorForLiteral](../../../../../../samples/snippets/visualbasic/VS_Snippets_Data/DP L2E Conceptual Examples/VB/Module1.vb#constructorforliteral)]  
  
 <span data-ttu-id="3e0b4-166">Nová pole jsou také spuštěny na straně klienta.</span><span class="sxs-lookup"><span data-stu-id="3e0b4-166">New arrays are also executed on the client.</span></span>  
  
## <a name="store-exceptions"></a><span data-ttu-id="3e0b4-167">Výjimky úložiště</span><span class="sxs-lookup"><span data-stu-id="3e0b4-167">Store Exceptions</span></span>  
 <span data-ttu-id="3e0b4-168">Všechny chyby úložiště, ke kterým došlo při spuštění dotazu, jsou předány klientovi a nejsou mapovány nebo zpracovávány.</span><span class="sxs-lookup"><span data-stu-id="3e0b4-168">Any store errors that are encountered during query execution are passed up to the client, and are not mapped or handled.</span></span>  
  
## <a name="store-configuration"></a><span data-ttu-id="3e0b4-169">Konfigurace úložiště</span><span class="sxs-lookup"><span data-stu-id="3e0b4-169">Store Configuration</span></span>  
 <span data-ttu-id="3e0b4-170">Při spuštění dotazu v úložišti konfigurace úložiště přepíše všechna chování klienta a sémantiku úložiště jsou vyjádřeny pro všechny operace a výrazy.</span><span class="sxs-lookup"><span data-stu-id="3e0b4-170">When the query executes on the store, the store configuration overrides all client behaviors, and store semantics are expressed for all operations and expressions.</span></span> <span data-ttu-id="3e0b4-171">To může mít za následek rozdíl v chování mezi CLR a provádění úložiště v oblastech, jako je například null porovnání, GUID <xref:System.DateTime>řazení, přesnost a přesnost operací zahrnující chod nepřesné datové typy (například typy s plovoucí desetinnou čárkou nebo ) a operace řetězce.</span><span class="sxs-lookup"><span data-stu-id="3e0b4-171">This can result in a difference in behavior between CLR and store execution in areas such as null comparisons, GUID ordering, precision and accuracy of operations involving non-precise data types (such as floating point types or <xref:System.DateTime>), and string operations.</span></span> <span data-ttu-id="3e0b4-172">Je důležité mít na paměti při zkoumání výsledků dotazu.</span><span class="sxs-lookup"><span data-stu-id="3e0b4-172">It is important to keep this in mind when examining query results.</span></span>  
  
 <span data-ttu-id="3e0b4-173">Například jsou následující rozdíly v chování mezi CLR a SQL Server:</span><span class="sxs-lookup"><span data-stu-id="3e0b4-173">For example, the following are some differences in behavior between the CLR and SQL Server:</span></span>  
  
- <span data-ttu-id="3e0b4-174">SQL Server objednávky GUID jinak než CLR.</span><span class="sxs-lookup"><span data-stu-id="3e0b4-174">SQL Server orders GUIDs differently than the CLR.</span></span>  
  
- <span data-ttu-id="3e0b4-175">Mohou také existovat rozdíly v přesnosti výsledků při práci s desetinným typem na serveru SQL Server.</span><span class="sxs-lookup"><span data-stu-id="3e0b4-175">There can also be differences in result precision when dealing with the Decimal type on SQL Server.</span></span> <span data-ttu-id="3e0b4-176">To je způsobeno požadavky na pevnou přesnost typu desetinné číslo serveru SQL Server.</span><span class="sxs-lookup"><span data-stu-id="3e0b4-176">This is due to the fixed precision requirements of the SQL Server decimal type.</span></span> <span data-ttu-id="3e0b4-177">Například průměr <xref:System.Decimal> hodnot 0.0, 0.0 a 1.0 je 0.333333333333333333333333333333333333333333333v paměti na straně klienta, ale 0,3333333 v úložišti (na základě výchozí přesnosti pro desítkový typ serveru SQL Server).</span><span class="sxs-lookup"><span data-stu-id="3e0b4-177">For example, the average of <xref:System.Decimal> values 0.0, 0.0, and 1.0 is 0.3333333333333333333333333333 in memory on the client, but 0.333333 in the store (based on the default precision for SQL Server’s decimal type).</span></span>  
  
- <span data-ttu-id="3e0b4-178">Některé operace porovnání řetězců jsou také zpracovány odlišně v SQL Server než v CLR.</span><span class="sxs-lookup"><span data-stu-id="3e0b4-178">Some string comparison operations are also handled differently in SQL Server than in the CLR.</span></span> <span data-ttu-id="3e0b4-179">Chování porovnání řetězců závisí na nastavení řazení na serveru.</span><span class="sxs-lookup"><span data-stu-id="3e0b4-179">String comparison behavior depends on the collation settings on the server.</span></span>  
  
- <span data-ttu-id="3e0b4-180">Volání funkce nebo metody, pokud jsou zahrnuty v linq entity dotazu, jsou mapovány na kanonické funkce v entity framework, které jsou pak přeloženy do Transact-SQL a provedeny v databázi SQL Server.</span><span class="sxs-lookup"><span data-stu-id="3e0b4-180">Function or method calls, when included in a LINQ to Entities query, are mapped to canonical functions in the Entity Framework, which are then translated to Transact-SQL and executed on the SQL Server database.</span></span> <span data-ttu-id="3e0b4-181">Existují případy, kdy chování těchto mapovaných funkcí exponát se může lišit od implementace v knihovnách základní třídy.</span><span class="sxs-lookup"><span data-stu-id="3e0b4-181">There are cases when the behavior these mapped functions exhibit might differ from the implementation in the base class libraries.</span></span> <span data-ttu-id="3e0b4-182">Například volání <xref:System.String.Contains%2A>, <xref:System.String.StartsWith%2A>a <xref:System.String.EndsWith%2A> metody s prázdným řetězcem `true` jako parametr se vrátí při `false` spuštění v CLR, ale vrátí při spuštění v SQL Server.</span><span class="sxs-lookup"><span data-stu-id="3e0b4-182">For example, calling the <xref:System.String.Contains%2A>, <xref:System.String.StartsWith%2A>, and <xref:System.String.EndsWith%2A> methods with an empty string as a parameter will return `true` when executed in the CLR, but will return `false` when executed in SQL Server.</span></span> <span data-ttu-id="3e0b4-183">Metoda <xref:System.String.EndsWith%2A> může také vrátit různé výsledky, protože SQL Server považuje dva řetězce za rovné, pokud se liší pouze v koncové prázdné místo, zatímco CLR považuje za není stejné.</span><span class="sxs-lookup"><span data-stu-id="3e0b4-183">The <xref:System.String.EndsWith%2A> method can also return different results because SQL Server considers two strings to be equal if they only differ in trailing white space, whereas the CLR considers them to be not equal.</span></span> <span data-ttu-id="3e0b4-184">To ilustruje následující příklad:</span><span class="sxs-lookup"><span data-stu-id="3e0b4-184">This is illustrated by the following example:</span></span>  
  
 [!code-csharp[DP L2E Conceptual Examples#CanonicalFuncVsCLRBaseType](../../../../../../samples/snippets/csharp/VS_Snippets_Data/DP L2E Conceptual Examples/CS/Program.cs#canonicalfuncvsclrbasetype)]
 [!code-vb[DP L2E Conceptual Examples#CanonicalFuncVsCLRBaseType](../../../../../../samples/snippets/visualbasic/VS_Snippets_Data/DP L2E Conceptual Examples/VB/Module1.vb#canonicalfuncvsclrbasetype)]
