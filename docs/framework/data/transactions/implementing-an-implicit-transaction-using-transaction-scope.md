---
title: Implementace implicitní transakce s využitím oboru transakcí
description: Implementujte implicitní transakci pomocí třídy TransactionScope v rozhraní .NET. Tato třída poskytuje způsob, jak označit blok kódu jako účastníka transakce.
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
ms.assetid: 49d1706a-1e0c-4c85-9704-75c908372eb9
ms.openlocfilehash: 48dd96dbba89a33cfce7d1b4efb776ef4ce4fada
ms.sourcegitcommit: 6219b1e1feccb16d88656444210fed3297f5611e
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 06/22/2020
ms.locfileid: "85141923"
---
# <a name="implementing-an-implicit-transaction-using-transaction-scope"></a><span data-ttu-id="7122b-104">Implementace implicitní transakce s využitím oboru transakcí</span><span class="sxs-lookup"><span data-stu-id="7122b-104">Implementing an Implicit Transaction using Transaction Scope</span></span>
<span data-ttu-id="7122b-105"><xref:System.Transactions.TransactionScope> Třída poskytuje jednoduchý způsob, jak označit bloku kódu jako účasti na transakci, aniž by bylo nutné k interakci se vlastní transakce.</span><span class="sxs-lookup"><span data-stu-id="7122b-105">The <xref:System.Transactions.TransactionScope> class provides a simple way to mark a block of code as participating in a transaction, without requiring you to interact with the transaction itself.</span></span> <span data-ttu-id="7122b-106">Obor transakce můžete vybrat a spravovat okolí transakce automaticky.</span><span class="sxs-lookup"><span data-stu-id="7122b-106">A transaction scope can select and manage the ambient transaction automatically.</span></span> <span data-ttu-id="7122b-107">Z důvodu jeho snadno použitelných a efektivitu, je doporučeno používat <xref:System.Transactions.TransactionScope> třídy při vývoji aplikace transakce.</span><span class="sxs-lookup"><span data-stu-id="7122b-107">Due to its ease of use and efficiency, it is recommended that you use the <xref:System.Transactions.TransactionScope> class when developing a transaction application.</span></span>  
  
 <span data-ttu-id="7122b-108">Kromě toho není nutné zařazení prostředky explicitně s transakcí.</span><span class="sxs-lookup"><span data-stu-id="7122b-108">In addition, you do not need to enlist resources explicitly with the transaction.</span></span> <span data-ttu-id="7122b-109">Jakékoli <xref:System.Transactions> můžete zjišťovat existenci transakci okolí Autor oboru a automaticky zařazení správce prostředků (například SQL Server 2005).</span><span class="sxs-lookup"><span data-stu-id="7122b-109">Any <xref:System.Transactions> resource manager (such as SQL Server 2005) can detect the existence of an ambient transaction created by the scope and automatically enlist.</span></span>  
  
## <a name="creating-a-transaction-scope"></a><span data-ttu-id="7122b-110">Vytváření oboru transakce</span><span class="sxs-lookup"><span data-stu-id="7122b-110">Creating a transaction scope</span></span>  
 <span data-ttu-id="7122b-111">Následující příklad ukazuje, jednoduché použití <xref:System.Transactions.TransactionScope> třídy.</span><span class="sxs-lookup"><span data-stu-id="7122b-111">The following sample shows a simple usage of the <xref:System.Transactions.TransactionScope> class.</span></span>  
  
 [!code-csharp[TransactionScope#1](../../../../samples/snippets/csharp/VS_Snippets_Remoting/TransactionScope/cs/ScopeWithSQL.cs#1)]
 [!code-vb[TransactionScope#1](../../../../samples/snippets/visualbasic/VS_Snippets_Remoting/TransactionScope/vb/ScopeWithSQL.vb#1)]  
  
 <span data-ttu-id="7122b-112">Obor transakce se spustí, jakmile vytvoříte nový <xref:System.Transactions.TransactionScope> objekt.</span><span class="sxs-lookup"><span data-stu-id="7122b-112">The transaction scope is started once you create a new <xref:System.Transactions.TransactionScope> object.</span></span>  <span data-ttu-id="7122b-113">Jak je znázorněno v ukázce kódu, doporučujeme vytvořit obory s `using` příkazem.</span><span class="sxs-lookup"><span data-stu-id="7122b-113">As illustrated in the code sample, it is recommended that you create scopes with a `using` statement.</span></span> <span data-ttu-id="7122b-114">`using`Příkaz je k dispozici v jazyce C# i v Visual Basic a funguje jako `try` blok... `finally` , aby bylo zajištěno, že je obor vyřazen správně.</span><span class="sxs-lookup"><span data-stu-id="7122b-114">The `using` statement is available both in C# and in Visual Basic, and works like a `try`...`finally` block to ensure that the scope is disposed of properly.</span></span>  
  
 <span data-ttu-id="7122b-115">Když vytváříte instance <xref:System.Transactions.TransactionScope>, určuje správce transakcí, které transakci se účastnit programu.</span><span class="sxs-lookup"><span data-stu-id="7122b-115">When you instantiate <xref:System.Transactions.TransactionScope>, the transaction manager determines which transaction to participate in.</span></span> <span data-ttu-id="7122b-116">Poté, co bylo zjištěno, oboru vždy se účastní dané transakce.</span><span class="sxs-lookup"><span data-stu-id="7122b-116">Once determined, the scope always participates in that transaction.</span></span> <span data-ttu-id="7122b-117">O tom, zda je založena na dva faktory: zda okolí transakce je přítomen a hodnota `TransactionScopeOption` parametr v konstruktoru.</span><span class="sxs-lookup"><span data-stu-id="7122b-117">The decision is based on two factors: whether an ambient transaction is present and the value of the `TransactionScopeOption` parameter in the constructor.</span></span> <span data-ttu-id="7122b-118">Okolí transakce je transakce, ve kterém se spustí váš kód.</span><span class="sxs-lookup"><span data-stu-id="7122b-118">The ambient transaction is the transaction within which your code executes.</span></span> <span data-ttu-id="7122b-119">Odkaz na okolí transakce můžete získat voláním statické <xref:System.Transactions.Transaction.Current%2A?displayProperty=nameWithType> vlastnost <xref:System.Transactions.Transaction> třídy.</span><span class="sxs-lookup"><span data-stu-id="7122b-119">You can obtain a reference to the ambient transaction by calling the static <xref:System.Transactions.Transaction.Current%2A?displayProperty=nameWithType> property of the <xref:System.Transactions.Transaction> class.</span></span> <span data-ttu-id="7122b-120">Další informace o tom, jak se tento parametr používá, najdete v části [Správa toku transakce pomocí TransactionScopeOption](#ManageTxFlow) tohoto tématu.</span><span class="sxs-lookup"><span data-stu-id="7122b-120">For more information on how this parameter is used, see the [Managing transaction flow using TransactionScopeOption](#ManageTxFlow) section of this topic.</span></span>  
  
## <a name="completing-a-transaction-scope"></a><span data-ttu-id="7122b-121">Dokončení rozsahu transakce</span><span class="sxs-lookup"><span data-stu-id="7122b-121">Completing a transaction scope</span></span>  
 <span data-ttu-id="7122b-122">Pokud vaše aplikace dokončí všechny pracovní chce provést v transakci, měli byste zavolat <xref:System.Transactions.TransactionScope.Complete%2A?displayProperty=nameWithType> metoda pouze jednou informovat správce transakcí, že je přijatelné potvrzení transakce.</span><span class="sxs-lookup"><span data-stu-id="7122b-122">When your application completes all the work it wants to perform in a transaction, you should call the <xref:System.Transactions.TransactionScope.Complete%2A?displayProperty=nameWithType> method only once to inform the transaction manager that it is acceptable to commit the transaction.</span></span> <span data-ttu-id="7122b-123">Je velmi dobrým zvykem umístit volání do <xref:System.Transactions.TransactionScope.Complete%2A> jako poslední příkaz v `using` bloku.</span><span class="sxs-lookup"><span data-stu-id="7122b-123">It is very good practice to put the call to <xref:System.Transactions.TransactionScope.Complete%2A> as the last statement in the `using` block.</span></span>  
  
 <span data-ttu-id="7122b-124">Při selhání volání této metody dojde k přerušení transakce, protože správce transakce tuto chybu interpretuje jako selhání systému nebo ekvivalentní výjimce vyvolané výjimku v rámci rozsahu transakce.</span><span class="sxs-lookup"><span data-stu-id="7122b-124">Failing to call this method aborts the transaction, because the transaction manager interprets this as a system failure, or equivalent to an exception thrown within the scope of the transaction.</span></span> <span data-ttu-id="7122b-125">Však voláním této metody není zaručit, že transakce probíhal v každé zemi být potvrzeny.</span><span class="sxs-lookup"><span data-stu-id="7122b-125">However, calling this method does not guarantee that the transaction wil be committed.</span></span> <span data-ttu-id="7122b-126">Je pouze způsob, jak o tom bude informovat správce transakcí stavu.</span><span class="sxs-lookup"><span data-stu-id="7122b-126">It is merely a way of informing the transaction manager of your status.</span></span> <span data-ttu-id="7122b-127">Po volání <xref:System.Transactions.TransactionScope.Complete%2A> v případě metody okolí transakce může již přistupovat pomocí <xref:System.Transactions.Transaction.Current%2A> vlastnost a pokusili, výsledkem bude výjimky.</span><span class="sxs-lookup"><span data-stu-id="7122b-127">After calling the <xref:System.Transactions.TransactionScope.Complete%2A> method, you can no longer access the ambient transaction by using the <xref:System.Transactions.Transaction.Current%2A> property, and attempting to do so will result in an exception being thrown.</span></span>  
  
 <span data-ttu-id="7122b-128">Pokud <xref:System.Transactions.TransactionScope> objekt původně vytvořil transakci, je skutečná práce potvrzující transakci správcem transakcí provedena za posledním řádkem kódu v `using` bloku.</span><span class="sxs-lookup"><span data-stu-id="7122b-128">If the <xref:System.Transactions.TransactionScope> object created the transaction initially, the actual work of committing the transaction by the transaction manager occurs after the last line of code in the `using` block.</span></span> <span data-ttu-id="7122b-129">Pokud nebyl vytvořen transakce, potvrzení dochází, pokud <xref:System.Transactions.CommittableTransaction.Commit%2A> je volána metodou vlastníka <xref:System.Transactions.CommittableTransaction> objektu.</span><span class="sxs-lookup"><span data-stu-id="7122b-129">If it did not create the transaction, the commit occurs whenever <xref:System.Transactions.CommittableTransaction.Commit%2A> is called by the owner of the <xref:System.Transactions.CommittableTransaction> object.</span></span> <span data-ttu-id="7122b-130">V tomto okamžiku správce transakcí volá správce prostředků a informuje je buď na potvrzení, nebo vrácení zpět, na základě toho, zda <xref:System.Transactions.TransactionScope.Complete%2A> byla metoda volána u <xref:System.Transactions.TransactionScope> objektu.</span><span class="sxs-lookup"><span data-stu-id="7122b-130">At that point the transaction manager calls the resource managers and informs them to either commit or rollback, based on whether the <xref:System.Transactions.TransactionScope.Complete%2A> method was called on the <xref:System.Transactions.TransactionScope> object.</span></span>  
  
 <span data-ttu-id="7122b-131">`using`Příkaz zajistí, že <xref:System.Transactions.TransactionScope.Dispose%2A> Metoda <xref:System.Transactions.TransactionScope> objektu je volána i v případě, že dojde k výjimce.</span><span class="sxs-lookup"><span data-stu-id="7122b-131">The `using` statement ensures that the <xref:System.Transactions.TransactionScope.Dispose%2A> method of the <xref:System.Transactions.TransactionScope> object is called even if an exception occurs.</span></span> <span data-ttu-id="7122b-132"><xref:System.Transactions.TransactionScope.Dispose%2A> Metoda označuje konec rozsahu transakce.</span><span class="sxs-lookup"><span data-stu-id="7122b-132">The <xref:System.Transactions.TransactionScope.Dispose%2A> method marks the end of the transaction scope.</span></span> <span data-ttu-id="7122b-133">Výjimky, k nimž došlo po volání této metody nemusí mít vliv na transakci.</span><span class="sxs-lookup"><span data-stu-id="7122b-133">Exceptions that occur after calling this method may not affect the transaction.</span></span> <span data-ttu-id="7122b-134">Tato metoda také obnoví okolí transakci ji předchozího stavu.</span><span class="sxs-lookup"><span data-stu-id="7122b-134">This method also restores the ambient transaction to it previous state.</span></span>  
  
 <span data-ttu-id="7122b-135">Objekt <xref:System.Transactions.TransactionAbortedException> je vyvolána, pokud obor vytvoří transakce a transakce je přerušená.</span><span class="sxs-lookup"><span data-stu-id="7122b-135">A <xref:System.Transactions.TransactionAbortedException> is thrown if the scope creates the transaction, and the transaction is aborted.</span></span> <span data-ttu-id="7122b-136">Objekt <xref:System.Transactions.TransactionInDoubtException> je vyvolána, pokud správce transakcí nelze dosáhnout rozhodnutí o potvrzení.</span><span class="sxs-lookup"><span data-stu-id="7122b-136">A <xref:System.Transactions.TransactionInDoubtException> is thrown if the transaction manager cannot reach a Commit decision.</span></span> <span data-ttu-id="7122b-137">Pokud transakce není vyvolána žádná výjimka.</span><span class="sxs-lookup"><span data-stu-id="7122b-137">No exception is thrown if the transaction is committed.</span></span>  
  
## <a name="rolling-back-a-transaction"></a><span data-ttu-id="7122b-138">Vrácení transakce zpět</span><span class="sxs-lookup"><span data-stu-id="7122b-138">Rolling back a transaction</span></span>  
 <span data-ttu-id="7122b-139">Pokud byste chtěli vrácení zpět transakcí, neměli by jste volat <xref:System.Transactions.TransactionScope.Complete%2A> metody v rozsahu transakce.</span><span class="sxs-lookup"><span data-stu-id="7122b-139">If you want to rollback a transaction, you should not call the <xref:System.Transactions.TransactionScope.Complete%2A> method within the transaction scope.</span></span> <span data-ttu-id="7122b-140">Například může vyvolat výjimku v rámci oboru.</span><span class="sxs-lookup"><span data-stu-id="7122b-140">For example, you can throw an exception within the scope.</span></span> <span data-ttu-id="7122b-141">Transakce, ve kterém je součástí bude vrácena zpět.</span><span class="sxs-lookup"><span data-stu-id="7122b-141">The transaction in which it participates in will be rolled back.</span></span>  
  
## <a name="managing-transaction-flow-using-transactionscopeoption"></a><a name="ManageTxFlow"></a><span data-ttu-id="7122b-142">Správa toku transakce pomocí TransactionScopeOption</span><span class="sxs-lookup"><span data-stu-id="7122b-142">Managing transaction flow using TransactionScopeOption</span></span>  
 <span data-ttu-id="7122b-143">Obor transakcí, které mohou být vnořené voláním metody, která používá <xref:System.Transactions.TransactionScope> z v rámci metody, která používá vlastní rozsah, jako je tomu u `RootMethod` metodu v následujícím příkladu</span><span class="sxs-lookup"><span data-stu-id="7122b-143">Transaction scope can be nested by calling a method that uses a <xref:System.Transactions.TransactionScope> from within a method that uses its own scope, as is the case with the `RootMethod` method in the following example,</span></span>  
  
```csharp  
void RootMethod()
{
    using(TransactionScope scope = new TransactionScope())
    {
        /* Perform transactional work here */
        SomeMethod();
        scope.Complete();
    }
}

void SomeMethod()
{
    using(TransactionScope scope = new TransactionScope())
    {
        /* Perform transactional work here */
        scope.Complete();
    }
}
```  
  
 <span data-ttu-id="7122b-144">Obor navrchu transakce se nazývá kořenového oboru.</span><span class="sxs-lookup"><span data-stu-id="7122b-144">The top-most transaction scope is referred to as the root scope.</span></span>  
  
 <span data-ttu-id="7122b-145"><xref:System.Transactions.TransactionScope> Třída poskytuje několik přetížených konstruktorů, které přijímají výčet typu <xref:System.Transactions.TransactionScopeOption>, která definuje transakční chování oboru.</span><span class="sxs-lookup"><span data-stu-id="7122b-145">The <xref:System.Transactions.TransactionScope> class provides several overloaded constructors that accept an enumeration of the type <xref:System.Transactions.TransactionScopeOption>, which defines the transactional behavior of the scope.</span></span>  
  
 <span data-ttu-id="7122b-146">Objekt <xref:System.Transactions.TransactionScope> objekt má tři možnosti:</span><span class="sxs-lookup"><span data-stu-id="7122b-146">A <xref:System.Transactions.TransactionScope> object has three options:</span></span>  
  
- <span data-ttu-id="7122b-147">Připojte se k okolí transakce nebo vytvořit novou, pokud neexistuje.</span><span class="sxs-lookup"><span data-stu-id="7122b-147">Join the ambient transaction, or create a new one if one does not exist.</span></span>  
  
- <span data-ttu-id="7122b-148">Být nových kořenový obor, to znamená, spusťte novou transakci a mají být nové okolí transakce v rámci vlastní rozsah transakce.</span><span class="sxs-lookup"><span data-stu-id="7122b-148">Be a new root scope, that is, start a new transaction and have that transaction be the new ambient transaction inside its own scope.</span></span>  
  
- <span data-ttu-id="7122b-149">Neúčastní transakcí vůbec.</span><span class="sxs-lookup"><span data-stu-id="7122b-149">Not take part in a transaction at all.</span></span> <span data-ttu-id="7122b-150">V důsledku není žádná okolí transakce.</span><span class="sxs-lookup"><span data-stu-id="7122b-150">There is no ambient transaction as a result.</span></span>  
  
 <span data-ttu-id="7122b-151">Pokud dojde k vytvoření oboru s <xref:System.Transactions.TransactionScopeOption.Required>a okolí transakce je přítomen, oboru spojí dané transakce.</span><span class="sxs-lookup"><span data-stu-id="7122b-151">If the scope is instantiated with <xref:System.Transactions.TransactionScopeOption.Required>, and an ambient transaction is present, the scope joins that transaction.</span></span> <span data-ttu-id="7122b-152">Je-li na druhé straně není žádná okolí transakce, pak oboru vytvoří novou transakci a Staňte se kořenového oboru.</span><span class="sxs-lookup"><span data-stu-id="7122b-152">If, on the other hand, there is no ambient transaction, then the scope creates a new transaction, and become the root scope.</span></span> <span data-ttu-id="7122b-153">Toto je výchozí hodnota.</span><span class="sxs-lookup"><span data-stu-id="7122b-153">This is the default value.</span></span> <span data-ttu-id="7122b-154">Při <xref:System.Transactions.TransactionScopeOption.Required> se používá, kód v rámci oboru není nutné, aby chovat odlišně, zda je kořenový adresář nebo právě připojuje okolí transakce.</span><span class="sxs-lookup"><span data-stu-id="7122b-154">When <xref:System.Transactions.TransactionScopeOption.Required> is used, the code inside the scope does not need to behave differently whether it is the root or just joining the ambient transaction.</span></span> <span data-ttu-id="7122b-155">Měla pracovat stejně jako v obou případech.</span><span class="sxs-lookup"><span data-stu-id="7122b-155">It should operate identically in both cases.</span></span>  
  
 <span data-ttu-id="7122b-156">Pokud dojde k vytvoření oboru s <xref:System.Transactions.TransactionScopeOption.RequiresNew>, je vždy kořenový oboru.</span><span class="sxs-lookup"><span data-stu-id="7122b-156">If the scope is instantiated with <xref:System.Transactions.TransactionScopeOption.RequiresNew>, it is always the root scope.</span></span> <span data-ttu-id="7122b-157">Spustí novou transakci a jeho transakce se změní na nové okolí transakce v rámci oboru.</span><span class="sxs-lookup"><span data-stu-id="7122b-157">It starts a new transaction, and its transaction becomes the new ambient transaction inside the scope.</span></span>  
  
 <span data-ttu-id="7122b-158">Pokud dojde k vytvoření oboru s <xref:System.Transactions.TransactionScopeOption.Suppress>, se nikdy účastní v transakci, bez ohledu na to zda okolí transakce je k dispozici.</span><span class="sxs-lookup"><span data-stu-id="7122b-158">If the scope is instantiated with <xref:System.Transactions.TransactionScopeOption.Suppress>, it never takes part in a transaction, regardless of whether an ambient transaction is present.</span></span> <span data-ttu-id="7122b-159">Obor s vytvořenou touto hodnotou má vždy stejnou `null` okolní transakci.</span><span class="sxs-lookup"><span data-stu-id="7122b-159">A scope instantiated with this value always have `null` as its ambient transaction.</span></span>  
  
 <span data-ttu-id="7122b-160">V následující tabulce je uveden výše uvedených možností.</span><span class="sxs-lookup"><span data-stu-id="7122b-160">The above options are summarized in the following table.</span></span>  
  
|<span data-ttu-id="7122b-161">TransactionScopeOption</span><span class="sxs-lookup"><span data-stu-id="7122b-161">TransactionScopeOption</span></span>|<span data-ttu-id="7122b-162">Okolí transakce</span><span class="sxs-lookup"><span data-stu-id="7122b-162">Ambient Transaction</span></span>|<span data-ttu-id="7122b-163">Rozsah podílí na</span><span class="sxs-lookup"><span data-stu-id="7122b-163">The scope takes part in</span></span>|  
|----------------------------|-------------------------|-----------------------------|  
|<span data-ttu-id="7122b-164">Vyžadováno</span><span class="sxs-lookup"><span data-stu-id="7122b-164">Required</span></span>|<span data-ttu-id="7122b-165">Ne</span><span class="sxs-lookup"><span data-stu-id="7122b-165">No</span></span>|<span data-ttu-id="7122b-166">Nová transakce (bude kořenového adresáře)</span><span class="sxs-lookup"><span data-stu-id="7122b-166">New Transaction (will be the root)</span></span>|  
|<span data-ttu-id="7122b-167">Požaduje novou</span><span class="sxs-lookup"><span data-stu-id="7122b-167">Requires New</span></span>|<span data-ttu-id="7122b-168">Ne</span><span class="sxs-lookup"><span data-stu-id="7122b-168">No</span></span>|<span data-ttu-id="7122b-169">Nová transakce (bude kořenového adresáře)</span><span class="sxs-lookup"><span data-stu-id="7122b-169">New Transaction (will be the root)</span></span>|  
|<span data-ttu-id="7122b-170">Potlačit</span><span class="sxs-lookup"><span data-stu-id="7122b-170">Suppress</span></span>|<span data-ttu-id="7122b-171">Ne</span><span class="sxs-lookup"><span data-stu-id="7122b-171">No</span></span>|<span data-ttu-id="7122b-172">Žádná transakce</span><span class="sxs-lookup"><span data-stu-id="7122b-172">No Transaction</span></span>|  
|<span data-ttu-id="7122b-173">Vyžadováno</span><span class="sxs-lookup"><span data-stu-id="7122b-173">Required</span></span>|<span data-ttu-id="7122b-174">Ano</span><span class="sxs-lookup"><span data-stu-id="7122b-174">Yes</span></span>|<span data-ttu-id="7122b-175">Okolí transakce</span><span class="sxs-lookup"><span data-stu-id="7122b-175">Ambient  Transaction</span></span>|  
|<span data-ttu-id="7122b-176">Požaduje novou</span><span class="sxs-lookup"><span data-stu-id="7122b-176">Requires New</span></span>|<span data-ttu-id="7122b-177">Ano</span><span class="sxs-lookup"><span data-stu-id="7122b-177">Yes</span></span>|<span data-ttu-id="7122b-178">Nová transakce (bude kořenového adresáře)</span><span class="sxs-lookup"><span data-stu-id="7122b-178">New Transaction (will be the root)</span></span>|  
|<span data-ttu-id="7122b-179">Potlačit</span><span class="sxs-lookup"><span data-stu-id="7122b-179">Suppress</span></span>|<span data-ttu-id="7122b-180">Ano</span><span class="sxs-lookup"><span data-stu-id="7122b-180">Yes</span></span>|<span data-ttu-id="7122b-181">Žádná transakce</span><span class="sxs-lookup"><span data-stu-id="7122b-181">No Transaction</span></span>|  
  
 <span data-ttu-id="7122b-182">Když <xref:System.Transactions.TransactionScope> objekt spojí existující okolí transakce, uvolnění objektu oboru nesmí končit transakce, pokud obor zruší transakce.</span><span class="sxs-lookup"><span data-stu-id="7122b-182">When a <xref:System.Transactions.TransactionScope> object joins an existing ambient transaction, disposing of the scope object may not end the transaction, unless the scope aborts the transaction.</span></span> <span data-ttu-id="7122b-183">Pokud okolí transakce byla vytvořena pomocí kořenového oboru, pouze v případě, že je kořenový obor odstraněn, nemá <xref:System.Transactions.CommittableTransaction.Commit%2A> zavolána v transakci.</span><span class="sxs-lookup"><span data-stu-id="7122b-183">If the ambient transaction was created by a root scope, only when the root scope is disposed of, does <xref:System.Transactions.CommittableTransaction.Commit%2A> get called on the transaction.</span></span> <span data-ttu-id="7122b-184">Pokud transakce byla vytvořena ručně, transakce končí, když je buď bylo přerušeno nebo potvrzené jeho tvůrcem.</span><span class="sxs-lookup"><span data-stu-id="7122b-184">If the transaction was created manually, the transaction ends when it is either aborted, or committed by its creator.</span></span>  
  
 <span data-ttu-id="7122b-185">Následující příklad ukazuje <xref:System.Transactions.TransactionScope> objekt, který vytvoří tři vnořených objektů s rozsahem, každá instance s jiným <xref:System.Transactions.TransactionScopeOption> hodnotu.</span><span class="sxs-lookup"><span data-stu-id="7122b-185">The following example shows a <xref:System.Transactions.TransactionScope> object that creates three nested scope objects, each instantiated with a different <xref:System.Transactions.TransactionScopeOption> value.</span></span>  
  
```csharp  
using(TransactionScope scope1 = new TransactionScope())
//Default is Required
{
    using(TransactionScope scope2 = new TransactionScope(TransactionScopeOption.Required))
    {
        //...
    }

    using(TransactionScope scope3 = new TransactionScope(TransactionScopeOption.RequiresNew))
    {
        //...  
    }
  
    using(TransactionScope scope4 = new TransactionScope(TransactionScopeOption.Suppress))
    {
        //...  
    }
}
```  
  
 <span data-ttu-id="7122b-186">Příklad ukazuje bloku kódu, bez jakékoli okolí transakce vytváření nového oboru (`scope1`) s <xref:System.Transactions.TransactionScopeOption.Required>.</span><span class="sxs-lookup"><span data-stu-id="7122b-186">The example shows a code block without any ambient transaction creating a new scope (`scope1`) with <xref:System.Transactions.TransactionScopeOption.Required>.</span></span> <span data-ttu-id="7122b-187">Rozsah `scope1` je kořenového oboru, který ji vytvoří novou transakci (transakce A) a usnadňuje transakce A okolí transakce.</span><span class="sxs-lookup"><span data-stu-id="7122b-187">The scope `scope1` is a root scope as it creates a new transaction (Transaction A) and makes Transaction A the ambient transaction.</span></span> <span data-ttu-id="7122b-188">`Scope1`pak vytvoří tři další objekty, z nichž každá má jinou <xref:System.Transactions.TransactionScopeOption> hodnotu.</span><span class="sxs-lookup"><span data-stu-id="7122b-188">`Scope1` then creates three more objects, each with a different <xref:System.Transactions.TransactionScopeOption> value.</span></span> <span data-ttu-id="7122b-189">Můžete například `scope2` je vytvořen s <xref:System.Transactions.TransactionScopeOption.Required>, a vzhledem k tomu, že existuje okolí transakce, spojení první transakce vytvořené `scope1`.</span><span class="sxs-lookup"><span data-stu-id="7122b-189">For example, `scope2` is created with <xref:System.Transactions.TransactionScopeOption.Required>, and since there is an ambient transaction, it joins the first transaction created by `scope1`.</span></span> <span data-ttu-id="7122b-190">Všimněte si, že `scope3` kořenového oboru novou transakci a že je `scope4` nemá žádné okolí transakce.</span><span class="sxs-lookup"><span data-stu-id="7122b-190">Note that `scope3` is the root scope of a new transaction, and that `scope4` has no ambient transaction.</span></span>  
  
 <span data-ttu-id="7122b-191">I když ve výchozím nastavení a většinu běžně používá hodnotu <xref:System.Transactions.TransactionScopeOption> je <xref:System.Transactions.TransactionScopeOption.Required>, všechny ostatní hodnoty, má své jedinečné účel.</span><span class="sxs-lookup"><span data-stu-id="7122b-191">Although the default and most commonly used value of <xref:System.Transactions.TransactionScopeOption> is <xref:System.Transactions.TransactionScopeOption.Required>, each of the other values has its unique purpose.</span></span>  

### <a name="non-transactional-code-inside-a-transaction-scope"></a><span data-ttu-id="7122b-192">Netransakční kód v rámci oboru transakce</span><span class="sxs-lookup"><span data-stu-id="7122b-192">Non-transactional code inside a transaction scope</span></span>

 <span data-ttu-id="7122b-193"><xref:System.Transactions.TransactionScopeOption.Suppress>je užitečné, pokud chcete zachovat operace prováděné částí Code a nechcete přerušit okolí transakce, pokud se operace nezdaří.</span><span class="sxs-lookup"><span data-stu-id="7122b-193"><xref:System.Transactions.TransactionScopeOption.Suppress> is useful when you want to preserve the operations performed by the code section, and do not want to abort the ambient transaction if the operations fail.</span></span> <span data-ttu-id="7122b-194">Například když chcete provádět protokolování nebo auditovat operace, nebo když chcete publikovat události odběratelům bez ohledu na tom, zda váš okolí potvrzení nebo přerušení transakce.</span><span class="sxs-lookup"><span data-stu-id="7122b-194">For example, when you want to perform logging or audit operations, or when you want to publish events to subscribers regardless of whether your ambient transaction commits or aborts.</span></span> <span data-ttu-id="7122b-195">Tato hodnota slouží k mít část s kódem netransakční v rámci oboru transakcí, jak je znázorněno v následujícím příkladu.</span><span class="sxs-lookup"><span data-stu-id="7122b-195">This value allows you to have a non-transactional code section inside a transaction scope, as shown in the following example.</span></span>  
  
```csharp  
using(TransactionScope scope1 = new TransactionScope())
{
    try
    {
        //Start of non-transactional section
        using(TransactionScope scope2 = new
            TransactionScope(TransactionScopeOption.Suppress))  
        {  
            //Do non-transactional work here  
        }  
        //Restores ambient transaction here
   }
   catch {}  
   //Rest of scope1
}
```  
  
### <a name="voting-inside-a-nested-scope"></a><span data-ttu-id="7122b-196">Hlasování uvnitř vnořené oboru</span><span class="sxs-lookup"><span data-stu-id="7122b-196">Voting inside a nested scope</span></span>  
 <span data-ttu-id="7122b-197">Přestože vnořené oboru se může připojit k okolí transakce kořenového oboru, voláním metody <xref:System.Transactions.TransactionScope.Complete%2A> v oboru vnořené nemá žádný vliv na kořenového oboru.</span><span class="sxs-lookup"><span data-stu-id="7122b-197">Although a nested scope can join the ambient transaction of the root scope, calling <xref:System.Transactions.TransactionScope.Complete%2A> in the nested scope has no affect on the root scope.</span></span> <span data-ttu-id="7122b-198">Pouze v případě, že všechny obory z kořenového oboru dolů poslední vnořené oboru hlasovat potvrzení transakce, transakce budou potvrzeny.</span><span class="sxs-lookup"><span data-stu-id="7122b-198">Only if all the scopes from the root scope down to the last nested scope vote to commit the transaction, will the transaction be committed.</span></span> <span data-ttu-id="7122b-199">Není volání <xref:System.Transactions.TransactionScope.Complete%2A> v oboru vnořené bude mít vliv na kořenového oboru jako okolí transakce bude okamžitě ukončeno.</span><span class="sxs-lookup"><span data-stu-id="7122b-199">Not calling <xref:System.Transactions.TransactionScope.Complete%2A> in a nested scope will affect the root scope as the ambient transaction will immediately be aborted.</span></span>  
  
## <a name="setting-the-transactionscope-timeout"></a><span data-ttu-id="7122b-200">Nastavení časového limitu TransactionScope</span><span class="sxs-lookup"><span data-stu-id="7122b-200">Setting the TransactionScope timeout</span></span>  
 <span data-ttu-id="7122b-201">Některé z přetížených konstruktorů z <xref:System.Transactions.TransactionScope> přijmout hodnoty typu <xref:System.TimeSpan>, která se používá k řízení časový limit transakce.</span><span class="sxs-lookup"><span data-stu-id="7122b-201">Some of the overloaded constructors of <xref:System.Transactions.TransactionScope> accept a value of type <xref:System.TimeSpan>, which is used to control the timeout of the transaction.</span></span> <span data-ttu-id="7122b-202">Časový limit nastaven na hodnotu nula znamená neomezený časový limit.</span><span class="sxs-lookup"><span data-stu-id="7122b-202">A timeout set to zero means an infinite timeout.</span></span> <span data-ttu-id="7122b-203">Neomezený časový limit je užitečné většinou pro ladění, pokud chcete izolovat problém v obchodní logiky krokování kódu jazyka a nechcete, aby transakce, které můžete ladit vypršení časového limitu při pokusu o nalezení problému.</span><span class="sxs-lookup"><span data-stu-id="7122b-203">Infinite timeout is useful mostly for debugging, when you want to isolate a problem in your business logic by stepping through your code, and you do not want the transaction you debug to time out while you attempt to locate the problem.</span></span> <span data-ttu-id="7122b-204">Velmi Vyhněte se pomocí hodnoty neomezený časový limit ve všech ostatních případech, protože přepisuje ochranu proti zablokování transakce.</span><span class="sxs-lookup"><span data-stu-id="7122b-204">Be extremely careful using the infinite timeout value in all other cases, because it overrides the safeguards against transaction deadlocks.</span></span>  
  
 <span data-ttu-id="7122b-205">Obvykle nastavena <xref:System.Transactions.TransactionScope> časový limit na hodnoty jiné než výchozí v obou případech.</span><span class="sxs-lookup"><span data-stu-id="7122b-205">You typically set the <xref:System.Transactions.TransactionScope> timeout to values other than default in two cases.</span></span> <span data-ttu-id="7122b-206">První je během vývoje, pokud chcete testovat tak, jak vaše aplikace zpracovává přerušené transakce.</span><span class="sxs-lookup"><span data-stu-id="7122b-206">The first is during development, when you want to test the way your application handles aborted transactions.</span></span> <span data-ttu-id="7122b-207">Nastavením časového limitu na malou hodnotu (například jeden milisekund) způsobit selhání transakce a můžete tak sledovat svůj kód pro zpracování chyb.</span><span class="sxs-lookup"><span data-stu-id="7122b-207">By setting the timeout to a small value (such as one millisecond), you cause your transaction to fail and can thus observe your error handling code.</span></span> <span data-ttu-id="7122b-208">Druhý případ, ve kterém nastavíte hodnotu menší než výchozí časový limit je v případě, že budete mít dojem, oboru se zabývá konflikty prostředků, výsledkem zablokování.</span><span class="sxs-lookup"><span data-stu-id="7122b-208">The second case in which you set the value to be less than the default timeout is when you believe that the scope is involved in resource contention, resulting in deadlocks.</span></span> <span data-ttu-id="7122b-209">V takovém případě budete chtít přerušení transakce co nejdříve a čekat výchozí časový limit vypršení platnosti.</span><span class="sxs-lookup"><span data-stu-id="7122b-209">In that case, you want to abort the transaction as soon as possible and not wait for the default timeout to expire.</span></span>  
  
 <span data-ttu-id="7122b-210">Pokud obor spojí okolí transakce, ale Určuje časový limit menší než okolí transakce je nastavena na, nový, kratší časový limit je vynucovat u <xref:System.Transactions.TransactionScope> objekt a obor musí končit v rámci vnořené dobu určenou, nebo je automaticky transakce zrušena.</span><span class="sxs-lookup"><span data-stu-id="7122b-210">When a scope joins an ambient transaction but specifies a smaller timeout than the one the ambient transaction is set to, the new, shorter timeout is enforced on the <xref:System.Transactions.TransactionScope> object, and the scope must end within the nested time specified, or the transaction is automatically aborted.</span></span> <span data-ttu-id="7122b-211">Je-li časový limit vnořené oboru je větší než který okolí transakce, nemá žádný vliv.</span><span class="sxs-lookup"><span data-stu-id="7122b-211">If the nested scope's timeout is more than that of the ambient transaction, it has no effect.</span></span>  
  
## <a name="setting-the-transactionscope-isolation-level"></a><span data-ttu-id="7122b-212">Nastavení zabezpečení na úroveň izolace TransactionScope</span><span class="sxs-lookup"><span data-stu-id="7122b-212">Setting the TransactionScope isolation level</span></span>  
 <span data-ttu-id="7122b-213">Některé z přetížených konstruktorů z <xref:System.Transactions.TransactionScope> přijmout strukturu typu <xref:System.Transactions.TransactionOptions> Chcete-li určit úroveň izolace kromě hodnotu časového limitu.</span><span class="sxs-lookup"><span data-stu-id="7122b-213">Some of the overloaded constructors of <xref:System.Transactions.TransactionScope> accept a structure of type <xref:System.Transactions.TransactionOptions> to specify an isolation level, in addition to a timeout value.</span></span> <span data-ttu-id="7122b-214">Ve výchozím nastavení, provede transakce s nastavena na úroveň izolace <xref:System.Transactions.IsolationLevel.Serializable>.</span><span class="sxs-lookup"><span data-stu-id="7122b-214">By default, the transaction executes with isolation level set to <xref:System.Transactions.IsolationLevel.Serializable>.</span></span> <span data-ttu-id="7122b-215">Jiné než výběrem úroveň izolace <xref:System.Transactions.IsolationLevel.Serializable> se obvykle používá pro čtení velkými nároky na výkon systémů.</span><span class="sxs-lookup"><span data-stu-id="7122b-215">Selecting an isolation level other than <xref:System.Transactions.IsolationLevel.Serializable> is commonly used for read-intensive systems.</span></span> <span data-ttu-id="7122b-216">To vyžaduje ucelené porozumění teorie zpracování transakcí a sémantiku samotné transakce, související problémy s souběžnou a důsledky konzistence systému.</span><span class="sxs-lookup"><span data-stu-id="7122b-216">This requires a solid understanding of transaction processing theory and the semantics of the transaction itself, the concurrency issues involved, and the consequences for system consistency.</span></span>  
  
 <span data-ttu-id="7122b-217">Kromě toho nejsou všechny správce prostředků nepodporují všechny úrovně izolace a uživatelé mohou zvolit, zda k účasti v transakci na vyšší úrovni než který je nakonfigurován.</span><span class="sxs-lookup"><span data-stu-id="7122b-217">In addition, not all resource managers support all levels of isolation, and they may elect to take part in the transaction at a higher level than the one configured.</span></span>  
  
 <span data-ttu-id="7122b-218">Každou úroveň izolace kromě <xref:System.Transactions.IsolationLevel.Serializable> se nekonzistence vyplývající z jiné transakce přístupu stejné informace.</span><span class="sxs-lookup"><span data-stu-id="7122b-218">Every isolation level besides <xref:System.Transactions.IsolationLevel.Serializable> is susceptible to inconsistency resulting from other transactions accessing the same information.</span></span> <span data-ttu-id="7122b-219">Rozdíl mezi úrovních různé izolace je způsobem, čtení a zápisu uzamčení se používají.</span><span class="sxs-lookup"><span data-stu-id="7122b-219">The difference between the different isolation levels is in the way read and write locks are used.</span></span> <span data-ttu-id="7122b-220">Zámek mohou konat pouze v případě, že transakce přistupuje k datům ve Správci zdrojů nebo můžete budou konat, dokud nebude transakce potvrzena nebo zrušena.</span><span class="sxs-lookup"><span data-stu-id="7122b-220">A lock can be held only when the transaction accesses the data in the resource manager, or it can be held until the transaction is committed or aborted.</span></span> <span data-ttu-id="7122b-221">Je lepší pro propustnost ten konzistence.</span><span class="sxs-lookup"><span data-stu-id="7122b-221">The former is better for throughput, the latter for consistency.</span></span> <span data-ttu-id="7122b-222">Dva druhy zámků a dva druhy operací (čtení a zápis) udává čtyři úrovně basic izolace.</span><span class="sxs-lookup"><span data-stu-id="7122b-222">The two kinds of locks and the two kinds of operations (read/write) give four basic isolation levels.</span></span> <span data-ttu-id="7122b-223">Další informace naleznete v tématu <xref:System.Transactions.IsolationLevel>.</span><span class="sxs-lookup"><span data-stu-id="7122b-223">See <xref:System.Transactions.IsolationLevel> for more information.</span></span>  
  
 <span data-ttu-id="7122b-224">Při použití vnořených <xref:System.Transactions.TransactionScope> objekty, musí být nakonfigurován obory všech vnořených používat přesně stejnou úroveň izolace, aby bylo možné připojit se k okolí transakce.</span><span class="sxs-lookup"><span data-stu-id="7122b-224">When using nested <xref:System.Transactions.TransactionScope> objects, all nested scopes must be configured to use exactly the same isolation level if they want to join the ambient transaction.</span></span> <span data-ttu-id="7122b-225">Pokud vnořený <xref:System.Transactions.TransactionScope> objekt se pokusí připojit okolí transakce ještě určuje na úroveň izolace jiný <xref:System.ArgumentException> je vyvolána.</span><span class="sxs-lookup"><span data-stu-id="7122b-225">If a nested <xref:System.Transactions.TransactionScope> object tries to join the ambient transaction yet it specifies a different isolation level, an <xref:System.ArgumentException> is thrown.</span></span>  
  
## <a name="interop-with-com"></a><span data-ttu-id="7122b-226">Vzájemná funkční spolupráce s modelu COM +</span><span class="sxs-lookup"><span data-stu-id="7122b-226">Interop with COM+</span></span>  
 <span data-ttu-id="7122b-227">Když vytvoříte nový <xref:System.Transactions.TransactionScope> instance, můžete použít <xref:System.Transactions.EnterpriseServicesInteropOption> výčet v jednom z konstruktorů k určení, jak pracovat s modelu COM +.</span><span class="sxs-lookup"><span data-stu-id="7122b-227">When you create a new <xref:System.Transactions.TransactionScope> instance, you can use the <xref:System.Transactions.EnterpriseServicesInteropOption> enumeration in one of the constructors to specify how to interact with COM+.</span></span> <span data-ttu-id="7122b-228">Další informace najdete v tématu [interoperabilita s podnikovými službami a transakcemi com+](interoperability-with-enterprise-services-and-com-transactions.md).</span><span class="sxs-lookup"><span data-stu-id="7122b-228">For more information on this, see [Interoperability with Enterprise Services and COM+ Transactions](interoperability-with-enterprise-services-and-com-transactions.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="7122b-229">Viz také</span><span class="sxs-lookup"><span data-stu-id="7122b-229">See also</span></span>

- <xref:System.Transactions.Transaction.Clone%2A>
- <xref:System.Transactions.TransactionScope>
