---
title: Kontrakty kódu
description: Prozkoumejte kontrakty kódu, které poskytují způsob, jak určit předběžné podmínky, následné podmínky a invariantování objektů v kódu .NET.
ms.date: 09/05/2018
dev_langs:
- csharp
- vb
helpviewer_keywords:
- Code contracts
ms.assetid: 84526045-496f-489d-8517-a258cf76f040
ms.openlocfilehash: 60f794373af75bd3f745c224e0a8c7a84192e4c4
ms.sourcegitcommit: 3824ff187947572b274b9715b60c11269335c181
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 06/17/2020
ms.locfileid: "84904140"
---
# <a name="code-contracts"></a><span data-ttu-id="58c39-103">Kontrakty kódu</span><span class="sxs-lookup"><span data-stu-id="58c39-103">Code Contracts</span></span>

<span data-ttu-id="58c39-104">Kontrakty kódu poskytují způsob, jak určit předběžné podmínky, následné podmínky a invariantní objektů ve vašem kódu.</span><span class="sxs-lookup"><span data-stu-id="58c39-104">Code contracts provide a way to specify preconditions, postconditions, and object invariants in your code.</span></span> <span data-ttu-id="58c39-105">Předběžné podmínky jsou požadavky, které musí být splněny při zadávání metody nebo vlastnosti.</span><span class="sxs-lookup"><span data-stu-id="58c39-105">Preconditions are requirements that must be met when entering a method or property.</span></span> <span data-ttu-id="58c39-106">Následné podmínky popisují očekávání v době ukončení metody nebo kódu vlastnosti.</span><span class="sxs-lookup"><span data-stu-id="58c39-106">Postconditions describe expectations at the time the method or property code exits.</span></span> <span data-ttu-id="58c39-107">Invariantní objekty popisují očekávaný stav pro třídu, která je v dobrém stavu.</span><span class="sxs-lookup"><span data-stu-id="58c39-107">Object invariants describe the expected state for a class that is in a good state.</span></span>

<span data-ttu-id="58c39-108">Kontrakty kódu zahrnují třídy pro označování kódu, statický analyzátor pro analýzu v době kompilace a analyzátor modulu runtime.</span><span class="sxs-lookup"><span data-stu-id="58c39-108">Code contracts include classes for marking your code, a static analyzer for compile-time analysis, and a runtime analyzer.</span></span> <span data-ttu-id="58c39-109">Třídy pro kontrakty kódu lze nalézt v <xref:System.Diagnostics.Contracts> oboru názvů.</span><span class="sxs-lookup"><span data-stu-id="58c39-109">The classes for code contracts can be found in the <xref:System.Diagnostics.Contracts> namespace.</span></span>

<span data-ttu-id="58c39-110">Mezi výhody kontraktů kódu patří následující:</span><span class="sxs-lookup"><span data-stu-id="58c39-110">The benefits of code contracts include the following:</span></span>

- <span data-ttu-id="58c39-111">Vylepšené testování: smlouvy o kódu poskytují statické ověřování kontraktů, kontrolu za běhu a generování dokumentace.</span><span class="sxs-lookup"><span data-stu-id="58c39-111">Improved testing: Code contracts provide static contract verification, runtime checking, and documentation generation.</span></span>

- <span data-ttu-id="58c39-112">Automatické testování nástrojů: kontrakty kódu můžete použít ke generování smysluplných testů jednotek, a to filtrováním nevýznamných testovacích argumentů, které nesplňují předpoklady.</span><span class="sxs-lookup"><span data-stu-id="58c39-112">Automatic testing tools: You can use code contracts to generate more meaningful unit tests by filtering out meaningless test arguments that do not satisfy preconditions.</span></span>

- <span data-ttu-id="58c39-113">Statické ověření: statická kontrola se může rozhodnout, jestli nedošlo k narušení kontraktu bez spuštění programu.</span><span class="sxs-lookup"><span data-stu-id="58c39-113">Static verification: The static checker can decide whether there are any contract violations without running the program.</span></span> <span data-ttu-id="58c39-114">Kontroluje implicitní kontrakty, jako jsou například odkazy na hodnoty null a hranice pole a explicitní kontrakty.</span><span class="sxs-lookup"><span data-stu-id="58c39-114">It checks for implicit contracts, such as null dereferences and array bounds, and explicit contracts.</span></span>

- <span data-ttu-id="58c39-115">Referenční dokumentace: generátor dokumentace rozšiřuje stávající soubory dokumentace XML o informace o kontraktech.</span><span class="sxs-lookup"><span data-stu-id="58c39-115">Reference documentation: The documentation generator augments existing XML documentation files with contract information.</span></span> <span data-ttu-id="58c39-116">K dispozici jsou také šablony stylů, které lze použít s [Sandcastle](https://github.com/EWSoftware/SHFB) , aby vygenerované stránky dokumentace měly oddíly smluv.</span><span class="sxs-lookup"><span data-stu-id="58c39-116">There are also style sheets that can be used with [Sandcastle](https://github.com/EWSoftware/SHFB) so that the generated documentation pages have contract sections.</span></span>

<span data-ttu-id="58c39-117">Všechny jazyky .NET Framework můžou okamžitě využít výhod smluv. Nemusíte psát speciální analyzátor nebo kompilátor.</span><span class="sxs-lookup"><span data-stu-id="58c39-117">All .NET Framework languages can immediately take advantage of contracts; you do not have to write a special parser or compiler.</span></span> <span data-ttu-id="58c39-118">Doplněk sady Visual Studio umožňuje určit úroveň analýzy kontraktu kódu, který se má provést.</span><span class="sxs-lookup"><span data-stu-id="58c39-118">A Visual Studio add-in lets you specify the level of code contract analysis to be performed.</span></span> <span data-ttu-id="58c39-119">Analyzátory si můžou ověřit, jestli jsou kontrakty ve správném formátu (kontrola typu a překlad názvů), a můžou vytvořit zkompilovanou formu smluv ve formátu MSIL (Microsoft Intermediate Language).</span><span class="sxs-lookup"><span data-stu-id="58c39-119">The analyzers can confirm that the contracts are well-formed (type checking and name resolution) and can produce a compiled form of the contracts in Microsoft intermediate language (MSIL) format.</span></span> <span data-ttu-id="58c39-120">Kontrakty vytváření v aplikaci Visual Studio umožňují využít standardní technologii IntelliSense poskytovanou nástrojem.</span><span class="sxs-lookup"><span data-stu-id="58c39-120">Authoring contracts in Visual Studio lets you take advantage of the standard IntelliSense provided by the tool.</span></span>

<span data-ttu-id="58c39-121">Většina metod ve třídě smlouvy je podmíněně zkompilována; To znamená, že kompilátor emituje volání těchto metod pouze v případě, že definujete speciální symbol CONTRACTS_FULL pomocí `#define` direktivy.</span><span class="sxs-lookup"><span data-stu-id="58c39-121">Most methods in the contract class are conditionally compiled; that is, the compiler emits calls to these methods only when  you define a special symbol, CONTRACTS_FULL, by using the `#define` directive.</span></span> <span data-ttu-id="58c39-122">CONTRACTS_FULL umožňuje psát smlouvy do kódu bez použití `#ifdef` direktiv. můžete vytvořit různá sestavení, některá se smlouvou a některé bez.</span><span class="sxs-lookup"><span data-stu-id="58c39-122">CONTRACTS_FULL lets you write contracts in your code without using `#ifdef` directives; you can produce different builds, some with contracts, and some without.</span></span>

<span data-ttu-id="58c39-123">Nástroje a podrobné pokyny k používání kontraktů kódu najdete v tématu [kontrakty kódu](https://marketplace.visualstudio.com/items?itemName=RiSEResearchinSoftwareEngineering.CodeContractsforNET) na webu Visual Studio Marketplace.</span><span class="sxs-lookup"><span data-stu-id="58c39-123">For tools and detailed instructions for using code contracts, see [Code Contracts](https://marketplace.visualstudio.com/items?itemName=RiSEResearchinSoftwareEngineering.CodeContractsforNET) on the Visual Studio marketplace site.</span></span>

## <a name="preconditions"></a><span data-ttu-id="58c39-124">Předběžné podmínky</span><span class="sxs-lookup"><span data-stu-id="58c39-124">Preconditions</span></span>

<span data-ttu-id="58c39-125">Podmínky můžete vyjádřit pomocí <xref:System.Diagnostics.Contracts.Contract.Requires%2A?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="58c39-125">You can express preconditions by using the <xref:System.Diagnostics.Contracts.Contract.Requires%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="58c39-126">Předběžné podmínky určují stav při vyvolání metody.</span><span class="sxs-lookup"><span data-stu-id="58c39-126">Preconditions specify state when a method is invoked.</span></span> <span data-ttu-id="58c39-127">Obvykle se používají k zadání platných hodnot parametrů.</span><span class="sxs-lookup"><span data-stu-id="58c39-127">They are generally used to specify valid parameter values.</span></span> <span data-ttu-id="58c39-128">Všechny členy, kteří jsou uvedeni v předběžných podmínkách, musí být alespoň tak přístupné jako samotná metoda; v opačném případě nemusí být předběžná podmínka srozumitelná všem volajícím metody.</span><span class="sxs-lookup"><span data-stu-id="58c39-128">All members that are mentioned in preconditions must be at least as accessible as the method itself; otherwise, the precondition might not be understood by all callers of a method.</span></span> <span data-ttu-id="58c39-129">Podmínka nesmí mít žádné vedlejší účinky.</span><span class="sxs-lookup"><span data-stu-id="58c39-129">The condition must have no side-effects.</span></span> <span data-ttu-id="58c39-130">Chování při neúspěšných předběžných podmínkách za běhu je určeno analyzátorem modulu runtime.</span><span class="sxs-lookup"><span data-stu-id="58c39-130">The run-time behavior of failed preconditions is determined by the runtime analyzer.</span></span>

<span data-ttu-id="58c39-131">Například následující předběžná podmínka vyjadřuje, že parametr `x` nesmí mít hodnotu null.</span><span class="sxs-lookup"><span data-stu-id="58c39-131">For example, the following precondition expresses that parameter `x` must be non-null.</span></span>

```csharp
Contract.Requires(x != null);
```

<span data-ttu-id="58c39-132">Pokud váš kód musí vyvolat určitou výjimku při selhání předběžné podmínky, můžete použít obecné přetížení <xref:System.Diagnostics.Contracts.Contract.Requires%2A> následujícím způsobem.</span><span class="sxs-lookup"><span data-stu-id="58c39-132">If your code must throw a particular exception on failure of a precondition, you can use the generic overload of <xref:System.Diagnostics.Contracts.Contract.Requires%2A> as follows.</span></span>

```csharp
Contract.Requires<ArgumentNullException>(x != null, "x");
```

### <a name="legacy-requires-statements"></a><span data-ttu-id="58c39-133">Starší verze vyžadují příkazy</span><span class="sxs-lookup"><span data-stu-id="58c39-133">Legacy Requires Statements</span></span>

<span data-ttu-id="58c39-134">Většina kódu obsahuje několik ověření parametrů ve formě `if` - `then` - `throw` kódu.</span><span class="sxs-lookup"><span data-stu-id="58c39-134">Most code contains some parameter validation in the form of `if`-`then`-`throw` code.</span></span> <span data-ttu-id="58c39-135">Nástroje kontraktu tyto příkazy rozpoznají jako předpoklady v následujících případech:</span><span class="sxs-lookup"><span data-stu-id="58c39-135">The contract tools recognize these statements as preconditions in the following cases:</span></span>

- <span data-ttu-id="58c39-136">Příkazy se zobrazí před všemi ostatními příkazy v metodě.</span><span class="sxs-lookup"><span data-stu-id="58c39-136">The statements appear before any other statements in a method.</span></span>

- <span data-ttu-id="58c39-137">Celá sada takových příkazů je následována explicitním <xref:System.Diagnostics.Contracts.Contract> voláním metody, jako je například volání <xref:System.Diagnostics.Contracts.Contract.Requires%2A> metody,, <xref:System.Diagnostics.Contracts.Contract.Ensures%2A> <xref:System.Diagnostics.Contracts.Contract.EnsuresOnThrow%2A> nebo <xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A> .</span><span class="sxs-lookup"><span data-stu-id="58c39-137">The entire set of such statements is followed by an explicit <xref:System.Diagnostics.Contracts.Contract> method call, such as a call to the <xref:System.Diagnostics.Contracts.Contract.Requires%2A>, <xref:System.Diagnostics.Contracts.Contract.Ensures%2A>, <xref:System.Diagnostics.Contracts.Contract.EnsuresOnThrow%2A>, or <xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A> method.</span></span>

<span data-ttu-id="58c39-138">Pokud `if` - `then` - `throw` se příkazy zobrazí v tomto formuláři, nástroje je rozpoznávají jako starší `requires` příkazy.</span><span class="sxs-lookup"><span data-stu-id="58c39-138">When `if`-`then`-`throw` statements appear in this form, the tools recognize them as legacy `requires` statements.</span></span> <span data-ttu-id="58c39-139">Pokud žádné jiné smlouvy nepostupují podle `if` - `then` - `throw` pořadí, ukončete kód pomocí <xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="58c39-139">If no other contracts follow the `if`-`then`-`throw` sequence, end the code with the <xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A?displayProperty=nameWithType> method.</span></span>

```csharp
if (x == null) throw new ...
Contract.EndContractBlock(); // All previous "if" checks are preconditions
```

<span data-ttu-id="58c39-140">Všimněte si, že podmínka v předchozím testu je předběžnou podmínkou.</span><span class="sxs-lookup"><span data-stu-id="58c39-140">Note that the condition in the preceding test is a negated precondition.</span></span> <span data-ttu-id="58c39-141">(Skutečná podmínka by byla `x != null` .) Předběžná podmínka typu negace je vysoce omezená: musí být zapsaná, jak je znázorněno v předchozím příkladu; To znamená, že by neměl obsahovat žádné `else` klauzule a tělo `then` klauzule musí být jediným `throw` příkazem.</span><span class="sxs-lookup"><span data-stu-id="58c39-141">(The actual precondition would be `x != null`.) A negated precondition is highly restricted: It must be written as shown in the previous example; that is, it should contain no `else` clauses, and the body of the `then` clause must be a single `throw` statement.</span></span> <span data-ttu-id="58c39-142">`if`Test podléhá pravidlům čistoty i viditelnosti (viz [pokyny pro použití](#usage_guidelines)), ale `throw` výraz podléhá pouze pravidlům čistoty.</span><span class="sxs-lookup"><span data-stu-id="58c39-142">The `if` test is subject to both purity and visibility rules (see [Usage Guidelines](#usage_guidelines)), but the `throw` expression is subject only to purity rules.</span></span> <span data-ttu-id="58c39-143">Nicméně typ vyvolané výjimky musí být viditelný jako metoda, ve které se kontrakt vyskytuje.</span><span class="sxs-lookup"><span data-stu-id="58c39-143">However, the type of the exception thrown must be as visible as the method in which the contract occurs.</span></span>

## <a name="postconditions"></a><span data-ttu-id="58c39-144">Následné podmínky</span><span class="sxs-lookup"><span data-stu-id="58c39-144">Postconditions</span></span>

<span data-ttu-id="58c39-145">Následné podmínky jsou kontrakty pro stav metody, když se ukončí.</span><span class="sxs-lookup"><span data-stu-id="58c39-145">Postconditions are contracts for the state of a method when it terminates.</span></span> <span data-ttu-id="58c39-146">Následná podmínka je kontrolován těsně před ukončením metody.</span><span class="sxs-lookup"><span data-stu-id="58c39-146">The postcondition is checked just before exiting a method.</span></span> <span data-ttu-id="58c39-147">Chování za běhu neúspěšného následné podmínky je určeno analyzátorem runtime.</span><span class="sxs-lookup"><span data-stu-id="58c39-147">The run-time behavior of failed postconditions is determined by the runtime analyzer.</span></span>

<span data-ttu-id="58c39-148">Na rozdíl od předběžných podmínek může následné podmínky odkazovat na členy s méně viditelností.</span><span class="sxs-lookup"><span data-stu-id="58c39-148">Unlike preconditions, postconditions may reference members with less visibility.</span></span> <span data-ttu-id="58c39-149">Klient nemusí být schopen pochopit nebo využít některé informace vyjádřené následná podmínka pomocí privátního stavu, ale nemá vliv na schopnost klienta používat metodu správně.</span><span class="sxs-lookup"><span data-stu-id="58c39-149">A client may not be able to understand or make use of some of the information expressed by a postcondition using private state, but this does not affect the client's ability to use the method correctly.</span></span>

### <a name="standard-postconditions"></a><span data-ttu-id="58c39-150">Následné podmínky úrovně Standard</span><span class="sxs-lookup"><span data-stu-id="58c39-150">Standard Postconditions</span></span>

<span data-ttu-id="58c39-151">Můžete vyjádřit standardní následné podmínky pomocí <xref:System.Diagnostics.Contracts.Contract.Ensures%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="58c39-151">You can express standard postconditions by using the <xref:System.Diagnostics.Contracts.Contract.Ensures%2A> method.</span></span> <span data-ttu-id="58c39-152">Následné podmínky vyjadřuje podmínku, která musí být `true` při normálním ukončení metody.</span><span class="sxs-lookup"><span data-stu-id="58c39-152">Postconditions express a condition that must be `true` upon normal termination of the method.</span></span>

```csharp
Contract.Ensures(this.F > 0);
```

### <a name="exceptional-postconditions"></a><span data-ttu-id="58c39-153">Výjimečný následné podmínky</span><span class="sxs-lookup"><span data-stu-id="58c39-153">Exceptional Postconditions</span></span>

<span data-ttu-id="58c39-154">Mimořádné následné podmínky jsou následné podmínky, které by měly být `true` v případě, že je vyvolána konkrétní výjimka metodou.</span><span class="sxs-lookup"><span data-stu-id="58c39-154">Exceptional postconditions are postconditions that should be `true` when a particular exception is thrown by a method.</span></span> <span data-ttu-id="58c39-155">Tyto následné podmínky můžete zadat pomocí <xref:System.Diagnostics.Contracts.Contract.EnsuresOnThrow%2A?displayProperty=nameWithType> metody, jak ukazuje následující příklad.</span><span class="sxs-lookup"><span data-stu-id="58c39-155">You can specify these postconditions by using the <xref:System.Diagnostics.Contracts.Contract.EnsuresOnThrow%2A?displayProperty=nameWithType> method, as the following example shows.</span></span>

```csharp
Contract.EnsuresOnThrow<T>(this.F > 0);
```

<span data-ttu-id="58c39-156">Argument je podmínka, která musí být `true` pokaždé, když je vyvolána výjimka, která je podtypem typu `T` .</span><span class="sxs-lookup"><span data-stu-id="58c39-156">The argument is the condition that must be `true` whenever an exception that is a subtype of `T` is thrown.</span></span>

<span data-ttu-id="58c39-157">Existují některé typy výjimek, které je obtížné použít ve výjimečných následná podmínka.</span><span class="sxs-lookup"><span data-stu-id="58c39-157">There are some exception types that are difficult to use in an exceptional postcondition.</span></span> <span data-ttu-id="58c39-158">Například použití typu <xref:System.Exception> pro `T` vyžaduje metodu pro zaručení podmínky bez ohledu na typ výjimky, která je vyvolána, i v případě, že se jedná o přetečení zásobníku nebo jiná neproveditelná výjimka.</span><span class="sxs-lookup"><span data-stu-id="58c39-158">For example, using the type <xref:System.Exception> for `T` requires the method to guarantee the condition regardless of the type of exception that is thrown, even if it is a stack overflow or other impossible-to-control exception.</span></span> <span data-ttu-id="58c39-159">Měli byste použít výjimečnou následné podmínky pouze pro konkrétní výjimky, které mohou být vyvolány při volání člena, například při <xref:System.InvalidTimeZoneException> vyvolání pro <xref:System.TimeZoneInfo> volání metody.</span><span class="sxs-lookup"><span data-stu-id="58c39-159">You should use exceptional postconditions only for specific exceptions that might be thrown when a member is called, for example, when an <xref:System.InvalidTimeZoneException> is thrown for a <xref:System.TimeZoneInfo> method call.</span></span>

### <a name="special-postconditions"></a><span data-ttu-id="58c39-160">Speciální následné podmínky</span><span class="sxs-lookup"><span data-stu-id="58c39-160">Special Postconditions</span></span>

<span data-ttu-id="58c39-161">V rámci následné podmínky lze použít následující metody:</span><span class="sxs-lookup"><span data-stu-id="58c39-161">The following methods may be used only within postconditions:</span></span>

- <span data-ttu-id="58c39-162">Můžete odkazovat na návratové hodnoty metody v následné podmínky pomocí výrazu `Contract.Result<T>()` , kde `T` je nahrazen návratovým typem metody.</span><span class="sxs-lookup"><span data-stu-id="58c39-162">You can refer to method return values in postconditions by using the expression `Contract.Result<T>()`, where `T` is replaced by the return type of the method.</span></span> <span data-ttu-id="58c39-163">Pokud kompilátor nemůže odvodit typ, je nutné jej explicitně poskytnout.</span><span class="sxs-lookup"><span data-stu-id="58c39-163">When the compiler is unable to infer the type, you must explicitly provide it.</span></span> <span data-ttu-id="58c39-164">Kompilátor jazyka C# například nemůže odvodit typy pro metody, které neberou žádné argumenty, takže vyžaduje následující následná podmínka: `Contract.Ensures(0 <Contract.Result<int>())` metody s návratovým typem `void` nemůže odkazovat na `Contract.Result<T>()` v jejich následné podmínky.</span><span class="sxs-lookup"><span data-stu-id="58c39-164">For example, the C# compiler is unable to infer types for methods that do not take any arguments, so it requires the following postcondition: `Contract.Ensures(0 <Contract.Result<int>())` Methods with a return type of `void` cannot refer to `Contract.Result<T>()` in their postconditions.</span></span>

- <span data-ttu-id="58c39-165">Hodnota představení v následná podmínka odkazuje na hodnotu výrazu na začátku metody nebo vlastnosti.</span><span class="sxs-lookup"><span data-stu-id="58c39-165">A prestate value in a postcondition refers to the value of an expression at the start of a method or property.</span></span> <span data-ttu-id="58c39-166">Používá výraz `Contract.OldValue<T>(e)` , kde `T` je typ `e` .</span><span class="sxs-lookup"><span data-stu-id="58c39-166">It uses the expression `Contract.OldValue<T>(e)`, where `T` is the type of `e`.</span></span> <span data-ttu-id="58c39-167">Argument obecného typu můžete vynechat vždy, když kompilátor dokáže odvodit svůj typ.</span><span class="sxs-lookup"><span data-stu-id="58c39-167">You can omit the generic type argument whenever the compiler is able to infer its type.</span></span> <span data-ttu-id="58c39-168">(Například kompilátor jazyka C# vždy odvodí typ, protože přebírá argument.) Existuje několik omezení na to, co se může stát `e` , a kontexty, ve kterých se může objevit starý výraz.</span><span class="sxs-lookup"><span data-stu-id="58c39-168">(For example, the C# compiler always infers the type because it takes an argument.) There are several restrictions on what can occur in `e` and the contexts in which an old expression may appear.</span></span> <span data-ttu-id="58c39-169">Starý výraz nemůže obsahovat jiný starý výraz.</span><span class="sxs-lookup"><span data-stu-id="58c39-169">An old expression cannot contain another old expression.</span></span> <span data-ttu-id="58c39-170">Co je důležité, Starý výraz musí odkazovat na hodnotu, která existovala ve stavu předběžné podmínky metody.</span><span class="sxs-lookup"><span data-stu-id="58c39-170">Most importantly, an old expression must refer to a value that existed in the method's precondition state.</span></span> <span data-ttu-id="58c39-171">Jinými slovy, musí být výraz, který lze vyhodnotit, pokud je předběžná podmínka metody `true` .</span><span class="sxs-lookup"><span data-stu-id="58c39-171">In other words, it must be an expression that can be evaluated as long as the method's precondition is `true`.</span></span> <span data-ttu-id="58c39-172">Tady je několik instancí tohoto pravidla.</span><span class="sxs-lookup"><span data-stu-id="58c39-172">Here are several instances of that rule.</span></span>

  - <span data-ttu-id="58c39-173">Hodnota musí existovat ve stavu předběžné podmínky metody.</span><span class="sxs-lookup"><span data-stu-id="58c39-173">The value must exist in the method's precondition state.</span></span> <span data-ttu-id="58c39-174">Aby bylo možné odkazovat na pole v objektu, předběžné podmínky musí zaručit, že objekt je vždycky null.</span><span class="sxs-lookup"><span data-stu-id="58c39-174">In order to reference a field on an object, the preconditions must guarantee that the object is always non-null.</span></span>

  - <span data-ttu-id="58c39-175">Nejde odkazovat na návratovou hodnotu metody ve starém výrazu:</span><span class="sxs-lookup"><span data-stu-id="58c39-175">You cannot refer to the method's return value in an old expression:</span></span>

      ```csharp
      Contract.OldValue(Contract.Result<int>() + x) // ERROR
      ```

  - <span data-ttu-id="58c39-176">Nejde odkazovat na `out` parametry ve starém výrazu.</span><span class="sxs-lookup"><span data-stu-id="58c39-176">You cannot refer to `out` parameters in an old expression.</span></span>

  - <span data-ttu-id="58c39-177">Starý výraz nemůže být závislý na vázané proměnné kvantifikátoru, pokud rozsah kvantifikátoru závisí na návratové hodnotě metody:</span><span class="sxs-lookup"><span data-stu-id="58c39-177">An old expression cannot depend on the bound variable of a quantifier if the range of the quantifier depends on the return value of the method:</span></span>

      ```csharp
      Contract.ForAll(0, Contract.Result<int>(), i => Contract.OldValue(xs[i]) > 3); // ERROR
      ```

  - <span data-ttu-id="58c39-178">Starý výraz nemůže odkazovat na parametr anonymního delegáta ve <xref:System.Diagnostics.Contracts.Contract.ForAll%2A> volání nebo, <xref:System.Diagnostics.Contracts.Contract.Exists%2A> Pokud není použit jako indexer nebo argument pro volání metody:</span><span class="sxs-lookup"><span data-stu-id="58c39-178">An old expression cannot refer to the parameter of the anonymous delegate in a <xref:System.Diagnostics.Contracts.Contract.ForAll%2A> or <xref:System.Diagnostics.Contracts.Contract.Exists%2A> call unless it is used as an indexer or argument to a method call:</span></span>

      ```csharp
      Contract.ForAll(0, xs.Length, i => Contract.OldValue(xs[i]) > 3); // OK
      Contract.ForAll(0, xs.Length, i => Contract.OldValue(i) > 3); // ERROR
      ```

  - <span data-ttu-id="58c39-179">V těle anonymního delegáta se nemůže vyskytovat starý výraz, pokud hodnota starého výrazu závisí na jakémkoli z parametrů anonymního delegáta, pokud anonymní delegát není argumentem <xref:System.Diagnostics.Contracts.Contract.ForAll%2A> <xref:System.Diagnostics.Contracts.Contract.Exists%2A> metody nebo:</span><span class="sxs-lookup"><span data-stu-id="58c39-179">An old expression cannot occur in the body of an anonymous delegate if the value of the old expression depends on any of the parameters of the anonymous delegate, unless the anonymous delegate is an argument to the <xref:System.Diagnostics.Contracts.Contract.ForAll%2A> or <xref:System.Diagnostics.Contracts.Contract.Exists%2A> method:</span></span>

      ```csharp
      Method(... (T t) => Contract.OldValue(... t ...) ...); // ERROR
      ```

  - <span data-ttu-id="58c39-180">`Out`parametry představují problém, protože kontrakty se zobrazí před tělem metody a většina kompilátorů nepovoluje odkazy na `out` parametry v následné podmínky.</span><span class="sxs-lookup"><span data-stu-id="58c39-180">`Out` parameters present a problem because contracts appear before the body of the method, and most compilers do not allow references to `out` parameters in postconditions.</span></span> <span data-ttu-id="58c39-181">Chcete-li tento problém vyřešit, <xref:System.Diagnostics.Contracts.Contract> Třída poskytuje <xref:System.Diagnostics.Contracts.Contract.ValueAtReturn%2A> metodu, která umožňuje následná podmínka na základě `out` parametru.</span><span class="sxs-lookup"><span data-stu-id="58c39-181">To solve this problem, the <xref:System.Diagnostics.Contracts.Contract> class provides the <xref:System.Diagnostics.Contracts.Contract.ValueAtReturn%2A> method, which allows a postcondition based on an `out` parameter.</span></span>

      ```csharp
      public void OutParam(out int x)
      {
          Contract.Ensures(Contract.ValueAtReturn(out x) == 3);
          x = 3;
      }
      ```

      <span data-ttu-id="58c39-182">Stejně jako u <xref:System.Diagnostics.Contracts.Contract.OldValue%2A> metody můžete vynechat parametr obecného typu vždy, když kompilátor dokáže odvodit svůj typ.</span><span class="sxs-lookup"><span data-stu-id="58c39-182">As with the <xref:System.Diagnostics.Contracts.Contract.OldValue%2A> method, you can omit the generic type parameter whenever the compiler is able to infer its type.</span></span> <span data-ttu-id="58c39-183">Přepis kontraktu nahrazuje volání metody hodnotou `out` parametru.</span><span class="sxs-lookup"><span data-stu-id="58c39-183">The contract rewriter replaces the method call with the value of the `out` parameter.</span></span> <span data-ttu-id="58c39-184"><xref:System.Diagnostics.Contracts.Contract.ValueAtReturn%2A>Metoda se může vyskytovat pouze v následné podmínky.</span><span class="sxs-lookup"><span data-stu-id="58c39-184">The <xref:System.Diagnostics.Contracts.Contract.ValueAtReturn%2A> method may appear only in postconditions.</span></span> <span data-ttu-id="58c39-185">Argument metody musí být `out` parametr nebo pole s `out` parametrem struktury.</span><span class="sxs-lookup"><span data-stu-id="58c39-185">The argument to the method must be an `out` parameter or a field of a structure `out` parameter.</span></span> <span data-ttu-id="58c39-186">Ta je užitečná také při odkazování na pole v následná podmínka konstruktoru struktury.</span><span class="sxs-lookup"><span data-stu-id="58c39-186">The latter is also useful when referring to fields in the postcondition of a structure constructor.</span></span>

      > [!NOTE]
      > <span data-ttu-id="58c39-187">V současné době nástroje pro analýzu kontraktů kódu nekontrolují, jestli `out` jsou parametry správně inicializované a neodpovídají jejich zmínkám v následná podmínka.</span><span class="sxs-lookup"><span data-stu-id="58c39-187">Currently, the code contract analysis tools do not check whether `out` parameters are initialized properly and disregard their mention in the postcondition.</span></span> <span data-ttu-id="58c39-188">Proto v předchozím příkladu, pokud řádek po kontraktu použil hodnotu `x` namísto přiřazení celého čísla, kompilátor nevydá správnou chybu.</span><span class="sxs-lookup"><span data-stu-id="58c39-188">Therefore, in the previous example, if the line after the contract had used the value of `x` instead of assigning an integer to it, a compiler would not issue the correct error.</span></span> <span data-ttu-id="58c39-189">Nicméně v sestavení, kde není definován symbol preprocesoru CONTRACTS_FULL (takové sestavení pro vydání ASA), kompilátor vydá chybu.</span><span class="sxs-lookup"><span data-stu-id="58c39-189">However, on a build where the CONTRACTS_FULL preprocessor symbol is not defined (such asa release build), the compiler will issue an error.</span></span>

## <a name="invariants"></a><span data-ttu-id="58c39-190">Invariantní</span><span class="sxs-lookup"><span data-stu-id="58c39-190">Invariants</span></span>

<span data-ttu-id="58c39-191">Invariantní objektu jsou podmínky, které by měly platit pro každou instanci třídy vždy, když je objekt viditelný pro klienta.</span><span class="sxs-lookup"><span data-stu-id="58c39-191">Object invariants are conditions that should be true for each instance of a class whenever that object is visible to a client.</span></span> <span data-ttu-id="58c39-192">Vyjadřují podmínky, za kterých se objekt považuje za správný.</span><span class="sxs-lookup"><span data-stu-id="58c39-192">They express the conditions under which the object is considered to be correct.</span></span>

<span data-ttu-id="58c39-193">Invariantní metody jsou identifikovány pomocí označení <xref:System.Diagnostics.Contracts.ContractInvariantMethodAttribute> atributem.</span><span class="sxs-lookup"><span data-stu-id="58c39-193">The invariant methods are identified by being marked with the <xref:System.Diagnostics.Contracts.ContractInvariantMethodAttribute> attribute.</span></span> <span data-ttu-id="58c39-194">Invariantní metody nesmí obsahovat žádný kód s výjimkou sekvence volání <xref:System.Diagnostics.Contracts.Contract.Invariant%2A> metody, každý z nich určuje jednotlivé invariantní, jak je znázorněno v následujícím příkladu.</span><span class="sxs-lookup"><span data-stu-id="58c39-194">The invariant methods must contain no code except for a sequence of calls to the <xref:System.Diagnostics.Contracts.Contract.Invariant%2A> method, each of which specifies an individual invariant, as shown in the following example.</span></span>

```csharp
[ContractInvariantMethod]
protected void ObjectInvariant ()
{
    Contract.Invariant(this.y >= 0);
    Contract.Invariant(this.x > this.y);
    ...
}
```

<span data-ttu-id="58c39-195">Invariantní jsou podmíněně definované symbolem preprocesoru CONTRACTS_FULL.</span><span class="sxs-lookup"><span data-stu-id="58c39-195">Invariants are conditionally defined by the CONTRACTS_FULL preprocessor symbol.</span></span> <span data-ttu-id="58c39-196">Během kontroly za běhu jsou nevarianty kontrolovány na konci každé veřejné metody.</span><span class="sxs-lookup"><span data-stu-id="58c39-196">During run-time checking, invariants are checked at the end of each public method.</span></span> <span data-ttu-id="58c39-197">Pokud invariantní zmiňuje veřejnou metodu ve stejné třídě, invariantní kontroly, které by normálně probíhaly na konci této veřejné metody, jsou zakázané.</span><span class="sxs-lookup"><span data-stu-id="58c39-197">If an invariant mentions a public method in the same class, the invariant check that would normally happen at the end of that public method is disabled.</span></span> <span data-ttu-id="58c39-198">Místo toho je tato kontrolu provedena pouze na konci nejvzdálenějšího volání metody této třídy.</span><span class="sxs-lookup"><span data-stu-id="58c39-198">Instead, the check occurs only at the end of the outermost method call to that class.</span></span> <span data-ttu-id="58c39-199">K tomu dojde také v případě, že je třída znovu zadána z důvodu volání metody v jiné třídě.</span><span class="sxs-lookup"><span data-stu-id="58c39-199">This also happens if the class is re-entered because of a call to a method on another class.</span></span> <span data-ttu-id="58c39-200">Pro finalizační metodu objektu a implementaci nejsou kontrolovány nevariantní objekty <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="58c39-200">Invariants are not checked for an object finalizer and an <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementation.</span></span>

<a name="usage_guidelines"></a>

## <a name="usage-guidelines"></a><span data-ttu-id="58c39-201">Pokyny k používání</span><span class="sxs-lookup"><span data-stu-id="58c39-201">Usage Guidelines</span></span>

### <a name="contract-ordering"></a><span data-ttu-id="58c39-202">Pořadí smluv</span><span class="sxs-lookup"><span data-stu-id="58c39-202">Contract Ordering</span></span>

<span data-ttu-id="58c39-203">Následující tabulka ukazuje pořadí prvků, které byste měli použít při psaní kontraktů metod.</span><span class="sxs-lookup"><span data-stu-id="58c39-203">The following table shows the order of elements you should use when you write method contracts.</span></span>

|`If-then-throw statements`|<span data-ttu-id="58c39-204">Zpětně kompatibilní veřejné předběžné podmínky</span><span class="sxs-lookup"><span data-stu-id="58c39-204">Backward-compatible public preconditions</span></span>|
|-|-|
|<xref:System.Diagnostics.Contracts.Contract.Requires%2A>|<span data-ttu-id="58c39-205">Všechny veřejné podmínky.</span><span class="sxs-lookup"><span data-stu-id="58c39-205">All public preconditions.</span></span>|
|<xref:System.Diagnostics.Contracts.Contract.Ensures%2A>|<span data-ttu-id="58c39-206">Všechny veřejné (normální) následné podmínky.</span><span class="sxs-lookup"><span data-stu-id="58c39-206">All public (normal) postconditions.</span></span>|
|<xref:System.Diagnostics.Contracts.Contract.EnsuresOnThrow%2A>|<span data-ttu-id="58c39-207">Všechny veřejné výjimečné následné podmínky.</span><span class="sxs-lookup"><span data-stu-id="58c39-207">All public exceptional postconditions.</span></span>|
|<xref:System.Diagnostics.Contracts.Contract.Ensures%2A>|<span data-ttu-id="58c39-208">Všechny soukromé/interní (normální) následné podmínky.</span><span class="sxs-lookup"><span data-stu-id="58c39-208">All private/internal (normal) postconditions.</span></span>|
|<xref:System.Diagnostics.Contracts.Contract.EnsuresOnThrow%2A>|<span data-ttu-id="58c39-209">Všechny soukromé/interní výjimečné následné podmínky.</span><span class="sxs-lookup"><span data-stu-id="58c39-209">All private/internal exceptional postconditions.</span></span>|
|<xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A>|<span data-ttu-id="58c39-210">Pokud používáte `if` - `then` - `throw` předběžné podmínky bez jakýchkoli jiných kontraktů, <xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A> zajistěte volání k označení toho, že všechny předchozí kontroly jsou předvedeny.</span><span class="sxs-lookup"><span data-stu-id="58c39-210">If using `if`-`then`-`throw` style preconditions without any other contracts, place a call to <xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A> to indicate that all previous if checks are preconditions.</span></span>|

<a name="purity"></a>

### <a name="purity"></a><span data-ttu-id="58c39-211">Čistotě</span><span class="sxs-lookup"><span data-stu-id="58c39-211">Purity</span></span>

<span data-ttu-id="58c39-212">Všechny metody, které jsou volány v rámci kontraktu, musí být čisté; To znamená, že nesmí aktualizovat žádný stávající stav.</span><span class="sxs-lookup"><span data-stu-id="58c39-212">All methods that are called within a contract must be pure; that is, they must not update any preexisting state.</span></span> <span data-ttu-id="58c39-213">Metoda Pure může upravovat objekty, které byly vytvořeny po vstupu do metody Pure.</span><span class="sxs-lookup"><span data-stu-id="58c39-213">A pure method is allowed to modify objects that have been created after entry into the pure method.</span></span>

<span data-ttu-id="58c39-214">Nástroje pro kontrakt kódu aktuálně předpokládají, že následující prvky kódu jsou čisté:</span><span class="sxs-lookup"><span data-stu-id="58c39-214">Code contract tools currently assume that the following code elements are pure:</span></span>

- <span data-ttu-id="58c39-215">Metody, které jsou označeny atributem <xref:System.Diagnostics.Contracts.PureAttribute> .</span><span class="sxs-lookup"><span data-stu-id="58c39-215">Methods that are marked with the <xref:System.Diagnostics.Contracts.PureAttribute>.</span></span>

- <span data-ttu-id="58c39-216">Typy, které jsou označeny <xref:System.Diagnostics.Contracts.PureAttribute> atributem (platí pro všechny metody typu).</span><span class="sxs-lookup"><span data-stu-id="58c39-216">Types that are marked with the <xref:System.Diagnostics.Contracts.PureAttribute> (the attribute applies to all the type's methods).</span></span>

- <span data-ttu-id="58c39-217">Přistupující objekty pro získání vlastnosti</span><span class="sxs-lookup"><span data-stu-id="58c39-217">Property get accessors.</span></span>

- <span data-ttu-id="58c39-218">Operátory (statické metody, jejichž názvy začínají na "op" a které mají jeden nebo dva parametry a návratový typ jiný než void).</span><span class="sxs-lookup"><span data-stu-id="58c39-218">Operators (static methods whose names start with "op", and that have one or two parameters and a non-void return type).</span></span>

- <span data-ttu-id="58c39-219">Libovolná metoda, jejíž plně kvalifikovaný název začíná řetězcem "System. Diagnostics. Contracts. Contract", "System. String", "System. IO. Path" nebo "System. Type".</span><span class="sxs-lookup"><span data-stu-id="58c39-219">Any method whose fully qualified name begins with "System.Diagnostics.Contracts.Contract", "System.String", "System.IO.Path", or "System.Type".</span></span>

- <span data-ttu-id="58c39-220">Jakýkoli vyvolaný delegát za předpokladu, že samotný typ delegáta má atribut <xref:System.Diagnostics.Contracts.PureAttribute> .</span><span class="sxs-lookup"><span data-stu-id="58c39-220">Any invoked delegate, provided that the delegate type itself is attributed with the <xref:System.Diagnostics.Contracts.PureAttribute>.</span></span> <span data-ttu-id="58c39-221">Typy delegátů <xref:System.Predicate%601?displayProperty=nameWithType> a <xref:System.Comparison%601?displayProperty=nameWithType> jsou považovány za čistě.</span><span class="sxs-lookup"><span data-stu-id="58c39-221">The delegate types <xref:System.Predicate%601?displayProperty=nameWithType> and <xref:System.Comparison%601?displayProperty=nameWithType> are considered pure.</span></span>

<a name="visibility"></a>

### <a name="visibility"></a><span data-ttu-id="58c39-222">Viditelnost</span><span class="sxs-lookup"><span data-stu-id="58c39-222">Visibility</span></span>

<span data-ttu-id="58c39-223">Všichni členové uvedení ve kontraktu musí být alespoň tak viditelné jako metoda, ve které se vyskytují.</span><span class="sxs-lookup"><span data-stu-id="58c39-223">All members mentioned in a contract must be at least as visible as the method in which they appear.</span></span> <span data-ttu-id="58c39-224">Například soukromé pole nelze uvést v předběžné podmínce pro veřejnou metodu; Klienti nemohou takový kontrakt ověřit před voláním metody.</span><span class="sxs-lookup"><span data-stu-id="58c39-224">For example, a private field cannot be mentioned in a precondition for a public method; clients cannot validate such a contract before they call the method.</span></span> <span data-ttu-id="58c39-225">Pokud je však pole označeno jako <xref:System.Diagnostics.Contracts.ContractPublicPropertyNameAttribute> , je z těchto pravidel vyloučeno.</span><span class="sxs-lookup"><span data-stu-id="58c39-225">However, if the field is marked with the <xref:System.Diagnostics.Contracts.ContractPublicPropertyNameAttribute>, it is exempt from these rules.</span></span>

## <a name="example"></a><span data-ttu-id="58c39-226">Příklad</span><span class="sxs-lookup"><span data-stu-id="58c39-226">Example</span></span>

<span data-ttu-id="58c39-227">Následující příklad ukazuje použití kontraktů kódu.</span><span class="sxs-lookup"><span data-stu-id="58c39-227">The following example shows the use of code contracts.</span></span>

[!code-csharp[ContractExample#1](../../../samples/snippets/csharp/VS_Snippets_CLR/contractexample/cs/program.cs#1)]
[!code-vb[ContractExample#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/contractexample/vb/program.vb#1)]
