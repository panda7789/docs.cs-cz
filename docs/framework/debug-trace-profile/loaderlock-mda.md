---
title: loaderLock – pomocník spravovaného ladění (MDA)
description: Přečtěte si pomocníka Managed ladění LoaderLock – (MDA) v rozhraní .NET, který detekuje pokusy o spuštění spravovaného kódu ve vlákně, které drží zámek zavaděče operačního systému Windows.
ms.date: 03/30/2017
helpviewer_keywords:
- deadlocks [.NET Framework]
- LoaderLock MDA
- MDAs (managed debugging assistants), loader locks
- managed debugging assistants (MDAs), loader locks
- operating system loader locks
- loader locks
- locks, threads
ms.assetid: 8c10fa02-1b9c-4be5-ab03-451d943ac1ee
ms.openlocfilehash: 055b07a805c5f0b613519d6019950a9b249a4b38
ms.sourcegitcommit: 0edbeb66d71b8df10fcb374cfca4d731b58ccdb2
ms.contentlocale: cs-CZ
ms.lasthandoff: 07/07/2020
ms.locfileid: "86051619"
---
# <a name="loaderlock-mda"></a><span data-ttu-id="7e3d1-103">loaderLock – pomocník spravovaného ladění (MDA)</span><span class="sxs-lookup"><span data-stu-id="7e3d1-103">loaderLock MDA</span></span>
<span data-ttu-id="7e3d1-104">`loaderLock`Pomocník spravovaného ladění (MDA) detekuje pokusy o spuštění spravovaného kódu ve vlákně, které má zámek zavaděče operačního systému Microsoft Windows.</span><span class="sxs-lookup"><span data-stu-id="7e3d1-104">The `loaderLock` managed debugging assistant (MDA) detects attempts to execute managed code on a thread that holds the Microsoft Windows operating system loader lock.</span></span>  <span data-ttu-id="7e3d1-105">Jakékoli takové spuštění je neplatné, protože může vést k zablokování a používání knihoven DLL předtím, než byly inicializovány zavaděčem operačního systému.</span><span class="sxs-lookup"><span data-stu-id="7e3d1-105">Any such execution is illegal because it can lead to deadlocks and to use of DLLs before they have been initialized by the operating system's loader.</span></span>  
  
## <a name="symptoms"></a><span data-ttu-id="7e3d1-106">Příznaky</span><span class="sxs-lookup"><span data-stu-id="7e3d1-106">Symptoms</span></span>  
 <span data-ttu-id="7e3d1-107">Nejběžnějším selháním při spouštění kódu uvnitř zámku zavaděče operačního systému je, že při pokusu o volání dalších funkcí Win32, které také vyžadují zámek zavaděče, budou vlákna zablokována.</span><span class="sxs-lookup"><span data-stu-id="7e3d1-107">The most common failure when executing code inside the operating system's loader lock is that threads will deadlock when attempting to call other Win32 functions that also require the loader lock.</span></span>  <span data-ttu-id="7e3d1-108">Příklady takových funkcí jsou `LoadLibrary` , `GetProcAddress` , `FreeLibrary` a `GetModuleHandle` .</span><span class="sxs-lookup"><span data-stu-id="7e3d1-108">Examples of such functions are `LoadLibrary`, `GetProcAddress`, `FreeLibrary`, and `GetModuleHandle`.</span></span>  <span data-ttu-id="7e3d1-109">Aplikace nemusí přímo volat tyto funkce; modul CLR (Common Language Runtime) může volat tyto funkce jako výsledek volání vyšší úrovně jako <xref:System.Reflection.Assembly.Load%2A> nebo první volání metody Invoke platformy.</span><span class="sxs-lookup"><span data-stu-id="7e3d1-109">The application might not directly call these functions; the common language runtime (CLR) might call these functions as the result of a higher level call like <xref:System.Reflection.Assembly.Load%2A> or the first call to a platform invoke method.</span></span>  
  
 <span data-ttu-id="7e3d1-110">K zablokování může docházet také v případě, že vlákno čeká na spuštění nebo dokončení jiného vlákna.</span><span class="sxs-lookup"><span data-stu-id="7e3d1-110">Deadlocks can also occur if a thread is waiting for another thread to start or finish.</span></span>  <span data-ttu-id="7e3d1-111">Když se vlákno spustí nebo dokončí, musí získat zámek zavaděče operačního systému, aby mohl doručovat události do ovlivněných knihoven DLL.</span><span class="sxs-lookup"><span data-stu-id="7e3d1-111">When a thread starts or finishes executing, it must acquire the operating system's loader lock to deliver events to affected DLLs.</span></span>  
  
 <span data-ttu-id="7e3d1-112">Nakonec existují případy, kdy volání do knihoven DLL mohou nastat předtím, než tyto knihovny DLL byly správně inicializovány zavaděčem operačního systému.</span><span class="sxs-lookup"><span data-stu-id="7e3d1-112">Finally, there are cases where calls into DLLs can occur before those DLLs have been properly initialized by the operating system's loader.</span></span>  <span data-ttu-id="7e3d1-113">Na rozdíl od chyb zablokování, které mohou být diagnostikovány kontrolou zásobníků všech vláken zapojených do zablokování, je velmi obtížné diagnostikovat použití neinicializovaných knihoven DLL bez použití tohoto procesu MDA.</span><span class="sxs-lookup"><span data-stu-id="7e3d1-113">Unlike the deadlock failures, which can be diagnosed by examining the stacks of all the threads involved in the deadlock, it is very difficult to diagnose the use of uninitialized DLLs without using this MDA.</span></span>  
  
## <a name="cause"></a><span data-ttu-id="7e3d1-114">Příčina</span><span class="sxs-lookup"><span data-stu-id="7e3d1-114">Cause</span></span>  
 <span data-ttu-id="7e3d1-115">Kombinovaná spravovaná nebo nespravovaná sestavení C++ vytvořená pro .NET Framework verze 1,0 nebo 1,1 se obecně pokusí spustit spravovaný kód uvnitř zámku zavaděče, pokud se nebere zvláštní péče, například propojení s **/NOENTRY**.</span><span class="sxs-lookup"><span data-stu-id="7e3d1-115">Mixed managed/unmanaged C++ assemblies built for .NET Framework versions 1.0 or 1.1 generally attempt to execute managed code inside the loader lock unless special care has been taken, for example, linking with **/NOENTRY**.</span></span>
  
 <span data-ttu-id="7e3d1-116">Smíšená spravovaná a nespravovaná sestavení C++ vytvořená pro .NET Framework verze 2,0 jsou pro tyto problémy méně náchylná a mají stejné snížené riziko jako aplikace využívající nespravované knihovny DLL, které porušují pravidla operačního systému.</span><span class="sxs-lookup"><span data-stu-id="7e3d1-116">Mixed managed/unmanaged C++ assemblies built for .NET Framework version 2.0 are less susceptible to these problems, having the same reduced risk as applications using unmanaged DLLs that violate the operating system's rules.</span></span>  <span data-ttu-id="7e3d1-117">Například pokud vstupní bod nespravované knihovny DLL `DllMain` volá `CoCreateInstance` , aby získal spravovaný objekt, který byl vystaven modelu COM, výsledkem je pokus o spuštění spravovaného kódu uvnitř zámku zavaděče.</span><span class="sxs-lookup"><span data-stu-id="7e3d1-117">For example, if an unmanaged DLL's `DllMain` entry point calls `CoCreateInstance` to obtain a managed object that has been exposed to COM, the result is an attempt to execute managed code inside the loader lock.</span></span> <span data-ttu-id="7e3d1-118">Další informace o problémech uzamknutí zavaděče v .NET Framework verze 2,0 a novějších naleznete v tématu [inicializace smíšených sestavení](/cpp/dotnet/initialization-of-mixed-assemblies).</span><span class="sxs-lookup"><span data-stu-id="7e3d1-118">For more information about loader lock issues in the .NET Framework version 2.0 and later, see [Initialization of Mixed Assemblies](/cpp/dotnet/initialization-of-mixed-assemblies).</span></span>  
  
## <a name="resolution"></a><span data-ttu-id="7e3d1-119">Řešení</span><span class="sxs-lookup"><span data-stu-id="7e3d1-119">Resolution</span></span>  
 <span data-ttu-id="7e3d1-120">V Visual C++ .NET 2002 a Visual C++ .NET 2003 by knihovny DLL zkompilované s `/clr` možností kompilátoru mohly při načtení způsobit nedeterministické zablokování; tento problém byl nazýván smíšeným načítáním knihovny DLL nebo problémem s zámkem zavaděče.</span><span class="sxs-lookup"><span data-stu-id="7e3d1-120">In Visual C++ .NET 2002 and Visual C++ .NET 2003, DLLs compiled with the `/clr` compiler option could non-deterministically deadlock when loaded; this issue was called the mixed DLL loading or loader lock issue.</span></span> <span data-ttu-id="7e3d1-121">V Visual C++ 2005 a novějších byly z smíšeného procesu načítání knihoven DLL odebrány téměř všechny determinismem, které nejsou součástí služby.</span><span class="sxs-lookup"><span data-stu-id="7e3d1-121">In Visual C++ 2005 and later, almost all non-determinism has been removed from the mixed DLL loading process.</span></span> <span data-ttu-id="7e3d1-122">Existuje však několik zbývajících scénářů, pro které může dojít k uzamknutí zavaděče (k deterministickému).</span><span class="sxs-lookup"><span data-stu-id="7e3d1-122">However, there are a few remaining scenarios for which loader lock can (deterministically) occur.</span></span> <span data-ttu-id="7e3d1-123">Podrobný účet příčin a řešení pro zbývající problémy zámků zavaděče naleznete v tématu [inicializace smíšených sestavení](/cpp/dotnet/initialization-of-mixed-assemblies).</span><span class="sxs-lookup"><span data-stu-id="7e3d1-123">For a detailed account of the causes and resolutions for the remaining loader lock issues, see [Initialization of Mixed Assemblies](/cpp/dotnet/initialization-of-mixed-assemblies).</span></span> <span data-ttu-id="7e3d1-124">Pokud toto téma neidentifikuje váš problém uzamknutí zavaděče, je nutné prostudovat zásobník vlákna, abyste zjistili, proč k uzamknutí zavaděče dojde, a jak problém vyřešit.</span><span class="sxs-lookup"><span data-stu-id="7e3d1-124">If that topic does not identify your loader lock problem, you have to examine the thread's stack to determine why the loader lock is occurring and how to correct the problem.</span></span> <span data-ttu-id="7e3d1-125">Podívejte se na trasování zásobníku pro vlákno, které aktivovalo Tento MDA.</span><span class="sxs-lookup"><span data-stu-id="7e3d1-125">Look at the stack trace for the thread that has activated this MDA.</span></span>  <span data-ttu-id="7e3d1-126">Vlákno se pokouší o neoprávněné volání spravovaného kódu, zatímco drží zámek zavaděče operačního systému.</span><span class="sxs-lookup"><span data-stu-id="7e3d1-126">The thread is attempting to illegally call into managed code while holding the operating system's loader lock.</span></span>  <span data-ttu-id="7e3d1-127">Pravděpodobně se v `DllMain` zásobníku zobrazuje i ekvivalentní vstupní bod knihovny DLL.</span><span class="sxs-lookup"><span data-stu-id="7e3d1-127">You will probably see a DLL's `DllMain` or equivalent entry point on the stack.</span></span>  <span data-ttu-id="7e3d1-128">Pravidla operačního systému pro to, co můžete právně dělat, se v tomto vstupním bodě poměrně omezí.</span><span class="sxs-lookup"><span data-stu-id="7e3d1-128">The operating system's rules for what you can legally do from inside such an entry point are quite limited.</span></span>  <span data-ttu-id="7e3d1-129">Tato pravidla vylučují jakékoli spravované spuštění.</span><span class="sxs-lookup"><span data-stu-id="7e3d1-129">These rules preclude any managed execution.</span></span>  
  
## <a name="effect-on-the-runtime"></a><span data-ttu-id="7e3d1-130">Vliv na modul runtime</span><span class="sxs-lookup"><span data-stu-id="7e3d1-130">Effect on the Runtime</span></span>  
 <span data-ttu-id="7e3d1-131">Obvykle se několik vláken uvnitř procesu zablokuje.</span><span class="sxs-lookup"><span data-stu-id="7e3d1-131">Typically, several threads inside the process will deadlock.</span></span>  <span data-ttu-id="7e3d1-132">Jedním z těchto vláken je pravděpodobně podproces zodpovědný za provedení uvolňování paměti, takže toto zablokování může mít významný dopad na celý proces.</span><span class="sxs-lookup"><span data-stu-id="7e3d1-132">One of those threads is likely to be a thread responsible for performing a garbage collection, so this deadlock can have a major impact on the entire process.</span></span>  <span data-ttu-id="7e3d1-133">Kromě toho zabrání žádné další operace, které vyžadují zámek zavaděče operačního systému, jako je načítání a uvolňování sestavení nebo knihoven DLL a spuštění nebo zastavení vláken.</span><span class="sxs-lookup"><span data-stu-id="7e3d1-133">Furthermore, it will prevent any additional operations that require the operating system's loader lock, like loading and unloading assemblies or DLLs and starting or stopping threads.</span></span>  
  
 <span data-ttu-id="7e3d1-134">V některých neobvyklých případech je také možné, že dojde k narušení přístupu nebo k podobným problémům v knihovnách DLL, které jsou volány před inicializací.</span><span class="sxs-lookup"><span data-stu-id="7e3d1-134">In some unusual cases, it is also possible for access violations or similar problems to be triggered in DLLs which are called before they have been initialized.</span></span>  
  
## <a name="output"></a><span data-ttu-id="7e3d1-135">Výstup</span><span class="sxs-lookup"><span data-stu-id="7e3d1-135">Output</span></span>  
 <span data-ttu-id="7e3d1-136">Tento MDA hlásí, že probíhá pokus o neoprávněné spravované spuštění.</span><span class="sxs-lookup"><span data-stu-id="7e3d1-136">This MDA reports that an illegal managed execution is being attempted.</span></span>  <span data-ttu-id="7e3d1-137">Je nutné prostudovat zásobník vlákna, abyste zjistili, proč k uzamknutí zavaděče dojde, a jak tento problém vyřešit.</span><span class="sxs-lookup"><span data-stu-id="7e3d1-137">You need to examine the thread's stack to determine why the loader lock is occurring and how to correct the problem.</span></span>  
  
## <a name="configuration"></a><span data-ttu-id="7e3d1-138">Konfigurace</span><span class="sxs-lookup"><span data-stu-id="7e3d1-138">Configuration</span></span>  
  
```xml  
<mdaConfig>  
  <assistants>  
    <loaderLock/>  
  </assistants>  
</mdaConfig>  
```  
  
## <a name="see-also"></a><span data-ttu-id="7e3d1-139">Viz také</span><span class="sxs-lookup"><span data-stu-id="7e3d1-139">See also</span></span>

- [<span data-ttu-id="7e3d1-140">Diagnostikování chyb pomocí asistentů spravovaného ladění</span><span class="sxs-lookup"><span data-stu-id="7e3d1-140">Diagnosing Errors with Managed Debugging Assistants</span></span>](diagnosing-errors-with-managed-debugging-assistants.md)
