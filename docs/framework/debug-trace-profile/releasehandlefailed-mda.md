---
title: releaseHandleFailed – pomocník spravovaného ladění (MDA)
description: Přečtěte si pomocníka spravovaného ladění releaseHandleFailed (MDA), který může být aktivovaný z důvodu nevracení prostředků nebo paměti v rozhraní .NET.
ms.date: 03/30/2017
helpviewer_keywords:
- managed debugging assistants (MDAs), handles
- release handle failed
- CriticalHandle class, run-time errors
- releaseHandleFailed MDA
- ReleaseHandle method
- SafeHandle class, run-time errors
- MDAs (managed debugging assistants), handles
ms.assetid: 44cd98ba-95e5-40a1-874d-e8e163612c51
ms.openlocfilehash: 167a304b4571aa35f758a2054caf6ae1c60a3c60
ms.sourcegitcommit: c23d9666ec75b91741da43ee3d91c317d68c7327
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 07/01/2020
ms.locfileid: "85803635"
---
# <a name="releasehandlefailed-mda"></a><span data-ttu-id="a6d64-103">releaseHandleFailed – pomocník spravovaného ladění (MDA)</span><span class="sxs-lookup"><span data-stu-id="a6d64-103">releaseHandleFailed MDA</span></span>
<span data-ttu-id="a6d64-104">`releaseHandleFailed`Je aktivován pomocník spravovaného ladění (MDA), který vývojářům oznamuje, když <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> Metoda třídy odvozená <xref:System.Runtime.InteropServices.SafeHandle> nebo <xref:System.Runtime.InteropServices.CriticalHandle> vrátí `false` .</span><span class="sxs-lookup"><span data-stu-id="a6d64-104">The `releaseHandleFailed` managed debugging assistant (MDA) is activated is to notify developers when the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method of a class derived from <xref:System.Runtime.InteropServices.SafeHandle> or <xref:System.Runtime.InteropServices.CriticalHandle> returns `false`.</span></span>  
  
## <a name="symptoms"></a><span data-ttu-id="a6d64-105">Příznaky</span><span class="sxs-lookup"><span data-stu-id="a6d64-105">Symptoms</span></span>  
 <span data-ttu-id="a6d64-106">Nevracení prostředků nebo paměti.</span><span class="sxs-lookup"><span data-stu-id="a6d64-106">Resource or memory leaks.</span></span>  <span data-ttu-id="a6d64-107">Pokud <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> Metoda třídy odvozená z <xref:System.Runtime.InteropServices.SafeHandle> nebo <xref:System.Runtime.InteropServices.CriticalHandle> dojde k chybě, pak prostředek zapouzdřený třídou nemusí být vydaný nebo vyčištěný.</span><span class="sxs-lookup"><span data-stu-id="a6d64-107">If the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method of the class deriving from <xref:System.Runtime.InteropServices.SafeHandle> or <xref:System.Runtime.InteropServices.CriticalHandle> fails, then the resource encapsulated by the class might not have been released or cleaned up.</span></span>  
  
## <a name="cause"></a><span data-ttu-id="a6d64-108">Příčina</span><span class="sxs-lookup"><span data-stu-id="a6d64-108">Cause</span></span>  
 <span data-ttu-id="a6d64-109"><xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A>Pokud uživatelé vytvoří třídy, které jsou odvozeny z nebo;, musí poskytnout implementaci metody <xref:System.Runtime.InteropServices.SafeHandle> <xref:System.Runtime.InteropServices.CriticalHandle> . tyto podmínky jsou proto specifické pro jednotlivé prostředky.</span><span class="sxs-lookup"><span data-stu-id="a6d64-109">Users must provide the implementation of the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method if they create classes that derive from <xref:System.Runtime.InteropServices.SafeHandle> or <xref:System.Runtime.InteropServices.CriticalHandle>; thus, the circumstances are specific to the individual resource.</span></span> <span data-ttu-id="a6d64-110">Požadavky jsou však následující:</span><span class="sxs-lookup"><span data-stu-id="a6d64-110">However, the requirements are as follows:</span></span>  
  
- <span data-ttu-id="a6d64-111"><xref:System.Runtime.InteropServices.SafeHandle>a <xref:System.Runtime.InteropServices.CriticalHandle> typy reprezentují obálky pro důležité prostředky procesu.</span><span class="sxs-lookup"><span data-stu-id="a6d64-111"><xref:System.Runtime.InteropServices.SafeHandle> and <xref:System.Runtime.InteropServices.CriticalHandle> types represent wrappers around vital process resources.</span></span> <span data-ttu-id="a6d64-112">Nevracení paměti by vedlo k tomu, že proces nebude v průběhu času použitelný.</span><span class="sxs-lookup"><span data-stu-id="a6d64-112">A memory leak would make the process unusable over time.</span></span>  
  
- <span data-ttu-id="a6d64-113"><xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A>Metoda nesmí selhat při provádění funkce.</span><span class="sxs-lookup"><span data-stu-id="a6d64-113">The <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method must not fail to perform its function.</span></span> <span data-ttu-id="a6d64-114">Jakmile proces získá takový prostředek, <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> je jediným způsobem, jak ho uvolnit.</span><span class="sxs-lookup"><span data-stu-id="a6d64-114">Once the process acquires such a resource, <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> is the only way to release it.</span></span> <span data-ttu-id="a6d64-115">Proto selhání implikuje nevracení prostředků.</span><span class="sxs-lookup"><span data-stu-id="a6d64-115">Therefore, failure implies resource leaks.</span></span>  
  
- <span data-ttu-id="a6d64-116">Jakákoli chyba, ke které dojde během provádění <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> , je překážkou vydání prostředku, je chyba v implementaci <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> samotné metody.</span><span class="sxs-lookup"><span data-stu-id="a6d64-116">Any failure that does occur during the execution of <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A>, impeding the release of the resource, is a bug in the implementation of the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method itself.</span></span> <span data-ttu-id="a6d64-117">Je odpovědností programátora zajistit, aby smlouva byla splněna, a to i v případě, že tento kód volá kód vytvořený někým jiným, aby mohl provést jeho funkci.</span><span class="sxs-lookup"><span data-stu-id="a6d64-117">It is the responsibility of the programmer to ensure that the contract is fulfilled, even if that code calls code authored by someone else to perform its function.</span></span>  
  
## <a name="resolution"></a><span data-ttu-id="a6d64-118">Řešení</span><span class="sxs-lookup"><span data-stu-id="a6d64-118">Resolution</span></span>  
 <span data-ttu-id="a6d64-119">Kód, který používá konkrétní <xref:System.Runtime.InteropServices.SafeHandle> typ (nebo <xref:System.Runtime.InteropServices.CriticalHandle> ), který vyvolal oznámení MDA, by měl být zkontrolován a hledat místa, kde je hodnota nezpracovaného popisovače extrahována z <xref:System.Runtime.InteropServices.SafeHandle> a zkopírována jinde.</span><span class="sxs-lookup"><span data-stu-id="a6d64-119">The code that uses the specific <xref:System.Runtime.InteropServices.SafeHandle> (or <xref:System.Runtime.InteropServices.CriticalHandle>) type that raised the MDA notification should be reviewed, looking for places where the raw handle value is extracted from the <xref:System.Runtime.InteropServices.SafeHandle> and copied elsewhere.</span></span> <span data-ttu-id="a6d64-120">Toto je Obvyklá příčina selhání v rámci <xref:System.Runtime.InteropServices.SafeHandle> nebo <xref:System.Runtime.InteropServices.CriticalHandle> implementace, protože použití nezpracovaného popisovače je již nesledováno modulem runtime.</span><span class="sxs-lookup"><span data-stu-id="a6d64-120">This is the usual cause of failures within <xref:System.Runtime.InteropServices.SafeHandle> or <xref:System.Runtime.InteropServices.CriticalHandle> implementations, because the usage of the raw handle value is then no longer tracked by the runtime.</span></span> <span data-ttu-id="a6d64-121">Pokud je kopie nezpracovaného popisovače následně zavřena, může způsobit selhání pozdějšího <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> volání, protože došlo k pokusu o ukončení u stejného popisovače, který je nyní neplatný.</span><span class="sxs-lookup"><span data-stu-id="a6d64-121">If the raw handle copy is subsequently closed, it can cause a later <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> call to fail because the close is attempted on the same handle, which is now invalid.</span></span>  
  
 <span data-ttu-id="a6d64-122">Existuje několik způsobů, jak se může vyskytnout nesprávné duplikace popisovače:</span><span class="sxs-lookup"><span data-stu-id="a6d64-122">There are a number of ways in which incorrect handle duplication can occur:</span></span>  
  
- <span data-ttu-id="a6d64-123">Vyhledejte volání <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="a6d64-123">Look for calls to the <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> method.</span></span> <span data-ttu-id="a6d64-124">Volání této metody by mělo být více než zřídka vzácné a všechny nalezené by měly být uzavřeny voláním <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> metody a.</span><span class="sxs-lookup"><span data-stu-id="a6d64-124">Calls to this method should be exceedingly rare, and any that you find should be surrounded by calls to the <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> and <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> methods.</span></span> <span data-ttu-id="a6d64-125">Tyto metody určují oblast kódu, ve které je možné bezpečně použít hodnotu nezpracovaného popisovače.</span><span class="sxs-lookup"><span data-stu-id="a6d64-125">These latter methods specify the region of code in which the raw handle value may be safely used.</span></span> <span data-ttu-id="a6d64-126">Mimo tuto oblast, nebo pokud se počet odkazů nikdy nezvyšuje na prvním místě, může být hodnota popisovače na základě volání <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> nebo <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> do jiného vlákna zrušena kdykoli.</span><span class="sxs-lookup"><span data-stu-id="a6d64-126">Outside this region, or if the reference count is never incremented in the first place, the handle value can be invalidated at any time by a call to <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> or <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> on another thread.</span></span> <span data-ttu-id="a6d64-127">Jakmile budou všechna použití <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> sledována, měli byste postupovat podle cesty, kterou nezpracovaný popisovač trvá, aby nedošlo k předání do některé součásti, která bude nakonec volat `CloseHandle` nebo jiné nativní metody nízké úrovně, která uvolní popisovač.</span><span class="sxs-lookup"><span data-stu-id="a6d64-127">Once all uses of <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> have been tracked down, you should follow the path the raw handle takes to ensure it is not handed off to some component that will eventually call `CloseHandle` or another low-level native method that will release the handle.</span></span>  
  
- <span data-ttu-id="a6d64-128">Zajistěte, aby popisovač používal kód, který se používá k inicializaci <xref:System.Runtime.InteropServices.SafeHandle> s platnou hodnotou nezpracovaného popisovače.</span><span class="sxs-lookup"><span data-stu-id="a6d64-128">Ensure that the code that is used to initialize the <xref:System.Runtime.InteropServices.SafeHandle> with a valid raw handle value owns the handle.</span></span> <span data-ttu-id="a6d64-129">Vytvoříte-li <xref:System.Runtime.InteropServices.SafeHandle> kolem popisovače, váš kód nevlastní bez nastavení `ownsHandle` parametru `false` v základním konstruktoru, pak se <xref:System.Runtime.InteropServices.SafeHandle> může pokusit o uzavření popisovače a vlastník reálného popisovače, což vede k chybě v <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> případě, že <xref:System.Runtime.InteropServices.SafeHandle> ztratí rasy.</span><span class="sxs-lookup"><span data-stu-id="a6d64-129">If you form a <xref:System.Runtime.InteropServices.SafeHandle> around a handle your code does not own without setting the `ownsHandle` parameter to `false` in the base constructor, then both the <xref:System.Runtime.InteropServices.SafeHandle> and the real handle owner can try to close the handle, leading to an error in <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> if the <xref:System.Runtime.InteropServices.SafeHandle> loses the race.</span></span>  
  
- <span data-ttu-id="a6d64-130">Pokud <xref:System.Runtime.InteropServices.SafeHandle> je zařazování mezi doménami aplikace, potvrďte, že <xref:System.Runtime.InteropServices.SafeHandle> odvozená odvozená byla označena jako serializovatelný.</span><span class="sxs-lookup"><span data-stu-id="a6d64-130">When a <xref:System.Runtime.InteropServices.SafeHandle> is marshaled between application domains, confirm the <xref:System.Runtime.InteropServices.SafeHandle> derivation being used has been marked as serializable.</span></span> <span data-ttu-id="a6d64-131">Ve výjimečných případech, kdy byla Třída odvozena z <xref:System.Runtime.InteropServices.SafeHandle> byla provedena serializovatelný, by měla implementovat <xref:System.Runtime.Serialization.ISerializable> rozhraní nebo použít jednu z dalších technik pro řízení serializace a deserializace procesu ručně.</span><span class="sxs-lookup"><span data-stu-id="a6d64-131">In the rare cases where a class derived from <xref:System.Runtime.InteropServices.SafeHandle> has been made serializable, it should implement the <xref:System.Runtime.Serialization.ISerializable> interface or use one of the other techniques for controlling the serialization and deserialization process manually.</span></span> <span data-ttu-id="a6d64-132">To je nutné, protože výchozí akce serializace je vytvoření bitové kopie hodnoty uzavřeného nezpracovaného popisovače, což vede k tomu, že dvě <xref:System.Runtime.InteropServices.SafeHandle> instance mají za následek stejný popisovač.</span><span class="sxs-lookup"><span data-stu-id="a6d64-132">This is required because the default serialization action is to create a bitwise clone of the enclosed raw handle value, resulting in two <xref:System.Runtime.InteropServices.SafeHandle> instances thinking they own the same handle.</span></span> <span data-ttu-id="a6d64-133">Oba se v <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> určitém bodě pokusí zavolat na stejný popisovač.</span><span class="sxs-lookup"><span data-stu-id="a6d64-133">Both will try to call <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> on the same handle at some point.</span></span> <span data-ttu-id="a6d64-134">Druhý <xref:System.Runtime.InteropServices.SafeHandle> postup se nezdaří.</span><span class="sxs-lookup"><span data-stu-id="a6d64-134">The second <xref:System.Runtime.InteropServices.SafeHandle> to do this will fail.</span></span> <span data-ttu-id="a6d64-135">Správný postup při serializaci <xref:System.Runtime.InteropServices.SafeHandle> je zavolat `DuplicateHandle` funkci nebo podobnou funkci pro váš typ nativního popisovače, aby bylo možné vytvořit odlišnou kopii zákonného popisovače.</span><span class="sxs-lookup"><span data-stu-id="a6d64-135">The correct course of action when serializing a <xref:System.Runtime.InteropServices.SafeHandle> is to call the `DuplicateHandle` function or a similar function for your native handle type to make a distinct legal handle copy.</span></span> <span data-ttu-id="a6d64-136">Pokud typ popisovače tuto podporu nepodporuje, <xref:System.Runtime.InteropServices.SafeHandle> nelze zabalení typu provést serializovatelný.</span><span class="sxs-lookup"><span data-stu-id="a6d64-136">If your handle type does not support this then the <xref:System.Runtime.InteropServices.SafeHandle> type wrapping it cannot be made serializable.</span></span>  
  
- <span data-ttu-id="a6d64-137">Je možné sledovat, kde je popisovač uzavřený včas, což vede k selhání při <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> konečném volání metody, vložením zarážky ladicího programu na nativní rutinu, která se používá k uvolnění popisovače, například `CloseHandle` funkce.</span><span class="sxs-lookup"><span data-stu-id="a6d64-137">It may be possible to track where a handle is being closed early, leading to a failure when the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method is finally called, by placing a debugger breakpoint on the native routine used to release the handle, for example the `CloseHandle` function.</span></span> <span data-ttu-id="a6d64-138">To nemusí být možné v případě zátěžových scénářů nebo dokonce středně velkých funkčních testů z důvodu těžkého provozu, na který tyto rutiny často řeší.</span><span class="sxs-lookup"><span data-stu-id="a6d64-138">This may not be possible for stress scenarios or even medium-sized functional tests due to the heavy traffic such routines often deal with.</span></span> <span data-ttu-id="a6d64-139">Může vám pomáhat při instrumentaci kódu, který volá nativní metodu vydání, za účelem zachycení identity volajícího nebo pravděpodobně úplného trasování zásobníku a hodnoty vydávaného popisovače.</span><span class="sxs-lookup"><span data-stu-id="a6d64-139">It may help to instrument the code that calls the native release method, in order to capture the identity of the caller, or possibly a full stack trace, and the value of the handle being released.</span></span>  <span data-ttu-id="a6d64-140">Hodnota popisovače může být porovnána s hodnotou hlášenou v rámci této aplikace MDA.</span><span class="sxs-lookup"><span data-stu-id="a6d64-140">The handle value can be compared with the value reported by this MDA.</span></span>  
  
- <span data-ttu-id="a6d64-141">Všimněte si, že některé typy nativních popisovačů, jako jsou všechny popisovače Win32, které mohou být vydány prostřednictvím `CloseHandle` funkce, sdílejí stejný obor názvů obslužné rutiny.</span><span class="sxs-lookup"><span data-stu-id="a6d64-141">Note that some native handle types, such as all the Win32 handles that can be released via the `CloseHandle` function, share the same handle namespace.</span></span> <span data-ttu-id="a6d64-142">Chybné vydání jednoho typu popisovače může způsobit problémy s jiným.</span><span class="sxs-lookup"><span data-stu-id="a6d64-142">An erroneous release of one handle type can cause problems with another.</span></span> <span data-ttu-id="a6d64-143">Například náhodné ukončení zpracování událostí Win32 dvakrát může vést k předčasnému zavření nesouvisejícího popisovače souboru.</span><span class="sxs-lookup"><span data-stu-id="a6d64-143">For instance, accidentally closing a Win32 event handle twice might lead to an apparently unrelated file handle being closed prematurely.</span></span> <span data-ttu-id="a6d64-144">K tomu dojde, když je ovladač uvolněn a hodnota popisovače bude k dispozici pro sledování jiného prostředku, potenciálně jiného typu.</span><span class="sxs-lookup"><span data-stu-id="a6d64-144">This happens when the handle is released and the handle value becomes available for use to track another resource, potentially of another type.</span></span> <span data-ttu-id="a6d64-145">Pokud k tomu dojde a následuje chybnou druhou verzí, může být neověřen popisovač nesouvisejícího vlákna.</span><span class="sxs-lookup"><span data-stu-id="a6d64-145">If this happens and is followed by an erroneous second release, the handle of an unrelated thread might be invalidated.</span></span>  
  
## <a name="effect-on-the-runtime"></a><span data-ttu-id="a6d64-146">Vliv na modul runtime</span><span class="sxs-lookup"><span data-stu-id="a6d64-146">Effect on the Runtime</span></span>  
 <span data-ttu-id="a6d64-147">Tento MDA nemá žádný vliv na CLR.</span><span class="sxs-lookup"><span data-stu-id="a6d64-147">This MDA has no effect on the CLR.</span></span>  
  
## <a name="output"></a><span data-ttu-id="a6d64-148">Výstup</span><span class="sxs-lookup"><span data-stu-id="a6d64-148">Output</span></span>  
 <span data-ttu-id="a6d64-149">Zpráva oznamující, že <xref:System.Runtime.InteropServices.SafeHandle> <xref:System.Runtime.InteropServices.CriticalHandle> popisovač nebo se nepodařilo správně uvolnit.</span><span class="sxs-lookup"><span data-stu-id="a6d64-149">A message indicating that a <xref:System.Runtime.InteropServices.SafeHandle> or a <xref:System.Runtime.InteropServices.CriticalHandle> failed to properly release the handle.</span></span> <span data-ttu-id="a6d64-150">Příklad:</span><span class="sxs-lookup"><span data-stu-id="a6d64-150">For example:</span></span>  
  
```output
"A SafeHandle or CriticalHandle of type 'MyBrokenSafeHandle'
failed to properly release the handle with value 0x0000BEEF. This
usually indicates that the handle was released incorrectly via
another means (such as extracting the handle using DangerousGetHandle
and closing it directly or building another SafeHandle around it."  
```  
  
## <a name="configuration"></a><span data-ttu-id="a6d64-151">Konfigurace</span><span class="sxs-lookup"><span data-stu-id="a6d64-151">Configuration</span></span>  
  
```xml  
<mdaConfig>  
  <assistants>  
    <releaseHandleFailed/>  
  </assistants>  
</mdaConfig>  
```  
  
## <a name="example"></a><span data-ttu-id="a6d64-152">Příklad</span><span class="sxs-lookup"><span data-stu-id="a6d64-152">Example</span></span>  
 <span data-ttu-id="a6d64-153">Následuje příklad kódu, který může aktivovat `releaseHandleFailed` MDA.</span><span class="sxs-lookup"><span data-stu-id="a6d64-153">The following is a code example that can activate the `releaseHandleFailed` MDA.</span></span>  
  
```csharp
bool ReleaseHandle()  
{  
    // Calling the Win32 CloseHandle function to release the
    // native handle wrapped by this SafeHandle. This method returns
    // false on failure, but should only fail if the input is invalid
    // (which should not happen here). The method specifically must not
    // fail simply because of lack of resources or other transient
    // failures beyond the user’s control. That would make it unacceptable
    // to call CloseHandle as part of the implementation of this method.  
    return CloseHandle(handle);  
}  
```  
  
## <a name="see-also"></a><span data-ttu-id="a6d64-154">Viz také:</span><span class="sxs-lookup"><span data-stu-id="a6d64-154">See also</span></span>

- <xref:System.Runtime.InteropServices.MarshalAsAttribute>
- [<span data-ttu-id="a6d64-155">Diagnostikování chyb pomocí asistentů spravovaného ladění</span><span class="sxs-lookup"><span data-stu-id="a6d64-155">Diagnosing Errors with Managed Debugging Assistants</span></span>](diagnosing-errors-with-managed-debugging-assistants.md)
- [<span data-ttu-id="a6d64-156">Zařazování spolupráce</span><span class="sxs-lookup"><span data-stu-id="a6d64-156">Interop Marshaling</span></span>](../interop/interop-marshaling.md)
