---
title: Typy kolekcí v kontraktech dat
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- collection types [WCF], data contracts
- data contracts [WCF], collection types
- collection types [WCF]
ms.assetid: 9b45b28e-0a82-4ea3-8c33-ec0094aff9d5
ms.openlocfilehash: a10b7c5295407cfbb36446581a4b75670e37bc6a
ms.sourcegitcommit: cdb295dd1db589ce5169ac9ff096f01fd0c2da9d
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 06/09/2020
ms.locfileid: "84579746"
---
# <a name="collection-types-in-data-contracts"></a><span data-ttu-id="26a61-102">Typy kolekcí v kontraktech dat</span><span class="sxs-lookup"><span data-stu-id="26a61-102">Collection Types in Data Contracts</span></span>

<span data-ttu-id="26a61-103">*Kolekce* je seznam položek určitého typu.</span><span class="sxs-lookup"><span data-stu-id="26a61-103">A *collection* is a list of items of a certain type.</span></span> <span data-ttu-id="26a61-104">V .NET Framework mohou být takové seznamy vyjádřeny pomocí polí nebo různých typů (obecný seznam, obecné <xref:System.ComponentModel.BindingList%601> , <xref:System.Collections.Specialized.StringCollection> nebo <xref:System.Collections.ArrayList> ).</span><span class="sxs-lookup"><span data-stu-id="26a61-104">In the .NET Framework, such lists can be represented using arrays or a variety of other types (Generic List, Generic <xref:System.ComponentModel.BindingList%601>, <xref:System.Collections.Specialized.StringCollection>, or <xref:System.Collections.ArrayList>).</span></span> <span data-ttu-id="26a61-105">Kolekce může například obsahovat seznam adres pro daného zákazníka.</span><span class="sxs-lookup"><span data-stu-id="26a61-105">For example, a collection may hold a list of Addresses for a given Customer.</span></span> <span data-ttu-id="26a61-106">Tyto kolekce se nazývají *kolekce seznamů*bez ohledu na jejich skutečný typ.</span><span class="sxs-lookup"><span data-stu-id="26a61-106">These collections are called *list collections*, regardless of their actual type.</span></span>

<span data-ttu-id="26a61-107">Existuje speciální forma kolekce, která představuje přidružení mezi jednou položkou (klíč) a jinou hodnotou ("value").</span><span class="sxs-lookup"><span data-stu-id="26a61-107">A special form of collection exists that represents an association between one item (the "key") and another (the "value").</span></span> <span data-ttu-id="26a61-108">V .NET Framework představují tyto typy jako <xref:System.Collections.Hashtable> a obecný slovník.</span><span class="sxs-lookup"><span data-stu-id="26a61-108">In the .NET Framework, these are represented by types such as <xref:System.Collections.Hashtable> and the generic dictionary.</span></span> <span data-ttu-id="26a61-109">Například kolekce přidružení může mapovat město ("klíč") na jeho naplnění ("value").</span><span class="sxs-lookup"><span data-stu-id="26a61-109">For example, an association collection may map a city ("key") to its population ("value").</span></span> <span data-ttu-id="26a61-110">Tyto kolekce se nazývají *kolekce slovníku*bez ohledu na jejich skutečný typ.</span><span class="sxs-lookup"><span data-stu-id="26a61-110">These collections are called *dictionary collections*, regardless of their actual type.</span></span>

<span data-ttu-id="26a61-111">Kolekce získají zvláštní zacházení v modelu kontraktu dat.</span><span class="sxs-lookup"><span data-stu-id="26a61-111">Collections receive special treatment in the data contract model.</span></span>

<span data-ttu-id="26a61-112">Typy, které implementují <xref:System.Collections.IEnumerable> rozhraní, včetně polí a obecných kolekcí, se rozpoznávají jako kolekce.</span><span class="sxs-lookup"><span data-stu-id="26a61-112">Types that implement the <xref:System.Collections.IEnumerable> interface, including arrays and generic collections, are recognized as collections.</span></span> <span data-ttu-id="26a61-113">Typy, které implementují <xref:System.Collections.IDictionary> Obecná rozhraní nebo, <xref:System.Collections.Generic.IDictionary%602> jsou kolekce slovníku; všichni ostatní jsou kolekce seznamů.</span><span class="sxs-lookup"><span data-stu-id="26a61-113">Of those, types that implement the <xref:System.Collections.IDictionary> or Generic <xref:System.Collections.Generic.IDictionary%602> interfaces are dictionary collections; all others are list collections.</span></span>

<span data-ttu-id="26a61-114">Další požadavky na typy kolekce, jako je například volání metody `Add` a konstruktor bez parametrů, jsou podrobněji popsány v následujících částech.</span><span class="sxs-lookup"><span data-stu-id="26a61-114">Additional requirements on collection types, such as having a method called `Add` and a parameterless constructor, are discussed in detail in the following sections.</span></span> <span data-ttu-id="26a61-115">Tím zajistíte, že typy kolekcí mohou být serializovány i deserializovány.</span><span class="sxs-lookup"><span data-stu-id="26a61-115">This ensures that collection types can be both serialized and deserialized.</span></span> <span data-ttu-id="26a61-116">To znamená, že některé kolekce nejsou přímo podporovány, například obecné <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> (protože nemá žádný konstruktor bez parametrů).</span><span class="sxs-lookup"><span data-stu-id="26a61-116">This means that some collections are not directly supported, such as the Generic <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> (because it has no parameterless constructor).</span></span> <span data-ttu-id="26a61-117">Informace o obcházení těchto omezení naleznete v části "použití typů rozhraní kolekce a kolekcí jen pro čtení" dále v tomto tématu.</span><span class="sxs-lookup"><span data-stu-id="26a61-117">However, for information about circumventing these restrictions, see the section "Using Collection Interface Types and Read-Only Collections" later in this topic.</span></span>

<span data-ttu-id="26a61-118">Typy obsažené v kolekcích musí být typy kontraktů dat, nebo by měly být jinak serializovatelný.</span><span class="sxs-lookup"><span data-stu-id="26a61-118">The types contained in collections must be data contract types, or be otherwise serializable.</span></span> <span data-ttu-id="26a61-119">Další informace najdete v tématu [typy podporované serializátorem kontraktu dat](types-supported-by-the-data-contract-serializer.md).</span><span class="sxs-lookup"><span data-stu-id="26a61-119">For more information, see [Types Supported by the Data Contract Serializer](types-supported-by-the-data-contract-serializer.md).</span></span>

<span data-ttu-id="26a61-120">Další informace o tom, co je a co se nepovažuje za platnou kolekci, a také o tom, jak jsou kolekce serializovány, najdete v části informace o serializaci kolekcí v tématu "Rozšířená pravidla shromažďování" v tomto tématu.</span><span class="sxs-lookup"><span data-stu-id="26a61-120">For more information about what is and what is not considered a valid collection, as well as about how collections are serialized, see the information about serializing collections in the "Advanced Collection Rules" section of this topic.</span></span>

## <a name="interchangeable-collections"></a><span data-ttu-id="26a61-121">Zaměnitelné kolekce</span><span class="sxs-lookup"><span data-stu-id="26a61-121">Interchangeable Collections</span></span>

<span data-ttu-id="26a61-122">Všechny kolekce seznamů stejného typu se považují za stejné kontrakty dat (pokud nejsou přizpůsobené pomocí <xref:System.Runtime.Serialization.CollectionDataContractAttribute> atributu, jak je popsáno dále v tomto tématu).</span><span class="sxs-lookup"><span data-stu-id="26a61-122">All list collections of the same type are considered to have the same data contract (unless they are customized using the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute, as discussed later in this topic).</span></span> <span data-ttu-id="26a61-123">Například následující kontrakty dat jsou ekvivalentní.</span><span class="sxs-lookup"><span data-stu-id="26a61-123">Thus, for example, the following data contracts are equivalent.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#0](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#0)]
[!code-vb[c_collection_types_in_data_contracts#0](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#0)]

<span data-ttu-id="26a61-124">Obě kontrakty dat vedou jako výsledek XML podobně jako následující kód.</span><span class="sxs-lookup"><span data-stu-id="26a61-124">Both data contracts result in XML similar to the following code.</span></span>

```xml
<PurchaseOrder>
    <customerName>...</customerName>
    <items>
        <Item>...</Item>
        <Item>...</Item>
        <Item>...</Item>
        ...
    </items>
    <comments>
        <string>...</string>
        <string>...</string>
        <string>...</string>
        ...
    </comments>
</PurchaseOrder>
```

<span data-ttu-id="26a61-125">V rámci kolekce můžete použít například typ kolekce optimalizovaný pro výkon serveru a typ kolekce, který je zaměřený na vázání na součásti uživatelského rozhraní na klientovi.</span><span class="sxs-lookup"><span data-stu-id="26a61-125">Collection interchangeability allows you to use, for example, a collection type optimized for performance on the server and a collection type designed to be bound to user interface components on the client.</span></span>

<span data-ttu-id="26a61-126">Podobně jako u kolekcí seznamů jsou všechny kolekce slovníku, které mají stejné typy klíčů a hodnot, považovány za stejné kontrakty dat (Pokud se nejedná o vlastní <xref:System.Runtime.Serialization.CollectionDataContractAttribute> atribut).</span><span class="sxs-lookup"><span data-stu-id="26a61-126">Similar to list collections, all dictionary collections that have the same key and value types are considered to have the same data contract (unless customized by the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute).</span></span>

<span data-ttu-id="26a61-127">Pouze takové typy kontraktů dat se týkají rovnocennosti kolekcí, nikoli typů .NET.</span><span class="sxs-lookup"><span data-stu-id="26a61-127">Only the data contract type matters as far as collection equivalence is concerned, not .NET types.</span></span> <span data-ttu-id="26a61-128">To znamená, že kolekce typ1 je považována za rovnocennou pro kolekci typ2, pokud mají typ1 a typ2 stejné kontrakty dat.</span><span class="sxs-lookup"><span data-stu-id="26a61-128">That is, a collection of Type1 is considered equivalent to a collection of Type2 if Type1 and Type2 have equivalent data contracts.</span></span>

<span data-ttu-id="26a61-129">Neobecné kolekce se považují za stejné kontrakty dat jako obecné kolekce typu `Object` .</span><span class="sxs-lookup"><span data-stu-id="26a61-129">Non-generic collections are considered to have the same data contract as generic collections of type `Object`.</span></span> <span data-ttu-id="26a61-130">(Například kontrakty dat pro <xref:System.Collections.ArrayList> a obecné <xref:System.Collections.Generic.List%601> `Object` jsou stejné.)</span><span class="sxs-lookup"><span data-stu-id="26a61-130">(For example, the data contracts for <xref:System.Collections.ArrayList> and Generic <xref:System.Collections.Generic.List%601> of `Object` are the same.)</span></span>

## <a name="using-collection-interface-types-and-read-only-collections"></a><span data-ttu-id="26a61-131">Použití typů rozhraní kolekce a kolekcí jen pro čtení</span><span class="sxs-lookup"><span data-stu-id="26a61-131">Using Collection Interface Types and Read-Only Collections</span></span>

<span data-ttu-id="26a61-132">Typy rozhraní kolekce ( <xref:System.Collections.IEnumerable> , <xref:System.Collections.IDictionary> , obecná <xref:System.Collections.Generic.IDictionary%602> nebo rozhraní odvozená z těchto rozhraní) se také považují za kontrakty dat kolekce, které jsou ekvivalentní kontraktům dat kolekce pro skutečné typy kolekcí.</span><span class="sxs-lookup"><span data-stu-id="26a61-132">Collection interface types (<xref:System.Collections.IEnumerable>, <xref:System.Collections.IDictionary>, generic <xref:System.Collections.Generic.IDictionary%602>, or interfaces derived from these interfaces) are also considered as having collection data contracts, equivalent to collection data contracts for actual collection types.</span></span> <span data-ttu-id="26a61-133">Proto je možné deklarovat typ serializovaný jako typ rozhraní kolekce a výsledky jsou stejné, jako kdyby byl použit skutečný typ kolekce.</span><span class="sxs-lookup"><span data-stu-id="26a61-133">Thus, it is possible to declare the type being serialized as a collection interface type and the results are the same as if an actual collection type had been used.</span></span> <span data-ttu-id="26a61-134">Například následující kontrakty dat jsou ekvivalentní.</span><span class="sxs-lookup"><span data-stu-id="26a61-134">For example, the following data contracts are equivalent.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#1](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#1)]
[!code-vb[c_collection_types_in_data_contracts#1](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#1)]

<span data-ttu-id="26a61-135">Při serializaci, když je deklarovaný typ rozhraní, může být samotný typ používané instance libovolný typ, který implementuje toto rozhraní.</span><span class="sxs-lookup"><span data-stu-id="26a61-135">During serialization, when the declared type is an interface, the actual instance type used can be any type that implements that interface.</span></span> <span data-ttu-id="26a61-136">Výše popsaná omezení (s konstruktorem bez parametrů a `Add` metodou) se nevztahují.</span><span class="sxs-lookup"><span data-stu-id="26a61-136">Restrictions discussed previously (having a parameterless constructor and an `Add` method) do not apply.</span></span> <span data-ttu-id="26a61-137">Můžete například nastavit adresy v Customer2 na instanci obecné <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> adresy, i když nemůžete přímo deklarovat datový člen typu Generic <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> .</span><span class="sxs-lookup"><span data-stu-id="26a61-137">For example, you can set addresses in Customer2 to an instance of Generic <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> of Address, even though you cannot directly declare a data member of type Generic <xref:System.Collections.ObjectModel.ReadOnlyCollection%601>.</span></span>

<span data-ttu-id="26a61-138">Při deserializaci, když deklarovaný typ je rozhraní, modul serializace zvolí typ, který implementuje deklarované rozhraní a vytvoří instanci typu.</span><span class="sxs-lookup"><span data-stu-id="26a61-138">During deserialization, when the declared type is an interface, the serialization engine chooses a type that implements the declared interface, and the type is instantiated.</span></span> <span data-ttu-id="26a61-139">Mechanismus známých typů (popsaný v tématu [známé typy kontraktů dat](data-contract-known-types.md)) nemá žádný vliv. Volba typu je integrována do WCF.</span><span class="sxs-lookup"><span data-stu-id="26a61-139">The known types mechanism (described in [Data Contract Known Types](data-contract-known-types.md)) has no effect here; the choice of type is built into WCF.</span></span>

## <a name="customizing-collection-types"></a><span data-ttu-id="26a61-140">Přizpůsobení typů kolekcí</span><span class="sxs-lookup"><span data-stu-id="26a61-140">Customizing Collection Types</span></span>

<span data-ttu-id="26a61-141">Typy kolekce lze přizpůsobit pomocí <xref:System.Runtime.Serialization.CollectionDataContractAttribute> atributu, který má několik použití.</span><span class="sxs-lookup"><span data-stu-id="26a61-141">You can customize collection types by using the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute, which has several uses.</span></span>

<span data-ttu-id="26a61-142">Všimněte si, že přizpůsobení typů kolekce ohrožuje zarovnávání kolekce, takže je obecně doporučeno vyhnout se použití tohoto atributu, kdykoli je to možné.</span><span class="sxs-lookup"><span data-stu-id="26a61-142">Note that customizing collection types compromises collection interchangeability, so it is generally recommended to avoid applying this attribute whenever possible.</span></span> <span data-ttu-id="26a61-143">Další informace o tomto problému najdete v části Rozšířená pravidla shromažďování informací dále v tomto tématu.</span><span class="sxs-lookup"><span data-stu-id="26a61-143">For more information about this issue, see the "Advanced Collection Rules" section later in this topic.</span></span>

### <a name="collection-data-contract-naming"></a><span data-ttu-id="26a61-144">Vyjmenovávání kontraktů dat kolekce</span><span class="sxs-lookup"><span data-stu-id="26a61-144">Collection Data Contract Naming</span></span>

<span data-ttu-id="26a61-145">Pravidla pro pojmenování typů kolekcí jsou podobná těm pro pojmenování běžných typů kontraktů dat, jak je popsáno v tématu [názvy kontraktů dat](data-contract-names.md), i když některé důležité rozdíly existují:</span><span class="sxs-lookup"><span data-stu-id="26a61-145">The rules for naming collection types are similar to those for naming regular data contract types, as described in [Data Contract Names](data-contract-names.md), although some important differences exist:</span></span>

- <span data-ttu-id="26a61-146"><xref:System.Runtime.Serialization.CollectionDataContractAttribute>Atribut slouží k přizpůsobení názvu namísto <xref:System.Runtime.Serialization.DataContractAttribute> atributu.</span><span class="sxs-lookup"><span data-stu-id="26a61-146">The <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute is used to customize the name, instead of the <xref:System.Runtime.Serialization.DataContractAttribute> attribute.</span></span> <span data-ttu-id="26a61-147"><xref:System.Runtime.Serialization.CollectionDataContractAttribute>Atribut má také `Name` vlastnosti a `Namespace` .</span><span class="sxs-lookup"><span data-stu-id="26a61-147">The <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute also has `Name` and `Namespace` properties.</span></span>

- <span data-ttu-id="26a61-148">Pokud <xref:System.Runtime.Serialization.CollectionDataContractAttribute> atribut použit není, výchozí název a obor názvů pro typy kolekcí závisí na názvech a oborech názvů typů obsažených v kolekci.</span><span class="sxs-lookup"><span data-stu-id="26a61-148">When the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute is not applied, the default name and namespace for collection types depend on the names and namespaces of types contained within the collection.</span></span> <span data-ttu-id="26a61-149">Nejsou ovlivněny názvem a oborem názvů samotného typu kolekce.</span><span class="sxs-lookup"><span data-stu-id="26a61-149">They are not affected by the name and namespace of the collection type itself.</span></span> <span data-ttu-id="26a61-150">Příklad naleznete v následujících typech.</span><span class="sxs-lookup"><span data-stu-id="26a61-150">For an example, see the following types.</span></span>

  ```csharp
  public CustomerList1 : Collection<string> {}
  public StringList1 : Collection<string> {}
  ```

<span data-ttu-id="26a61-151">Oba typy název kontraktu dat jsou "ArrayOfstring", nikoli "CustomerList1" nebo "StringList1".</span><span class="sxs-lookup"><span data-stu-id="26a61-151">Both types’ data contract name is "ArrayOfstring" and not "CustomerList1" or "StringList1".</span></span> <span data-ttu-id="26a61-152">To znamená, že serializace některého z těchto typů na kořenové úrovni vrátí XML podobně jako následující kód.</span><span class="sxs-lookup"><span data-stu-id="26a61-152">This means that serializing any one of these types at the root level yields XML similar to the following code.</span></span>

```xml
<ArrayOfstring>
    <string>...</string>
    <string>...</string>
    <string>...</string>
    ...
</ArrayOfstring>
```

<span data-ttu-id="26a61-153">Toto pravidlo pojmenování bylo zvoleno, aby se zajistilo, že jakýkoli nepřizpůsobený typ, který představuje seznam řetězců, má stejný kontrakt dat a reprezentace XML.</span><span class="sxs-lookup"><span data-stu-id="26a61-153">This naming rule was chosen to ensure that any non-customized type that represents a list of strings has the same data contract and XML representation.</span></span> <span data-ttu-id="26a61-154">Díky tomu je možné proměnit kolekci.</span><span class="sxs-lookup"><span data-stu-id="26a61-154">This makes collection interchangeability possible.</span></span> <span data-ttu-id="26a61-155">V tomto příkladu jsou CustomerList1 a StringList1 úplně zaměnitelné.</span><span class="sxs-lookup"><span data-stu-id="26a61-155">In this example, CustomerList1 and StringList1 are completely interchangeable.</span></span>

<span data-ttu-id="26a61-156">Nicméně při <xref:System.Runtime.Serialization.CollectionDataContractAttribute> použití atributu se kolekce stala přizpůsobenou kontraktem dat kolekce, a to i v případě, že u atributu nejsou nastaveny žádné vlastnosti.</span><span class="sxs-lookup"><span data-stu-id="26a61-156">However, when the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute is applied, the collection becomes a customized collection data contract, even if no properties are set on the attribute.</span></span> <span data-ttu-id="26a61-157">Název a obor názvů kontraktu dat kolekce závisí na samotném typu kolekce.</span><span class="sxs-lookup"><span data-stu-id="26a61-157">The name and namespace of the collection data contract then depend on the collection type itself.</span></span> <span data-ttu-id="26a61-158">Příklad naleznete v následujícím typu.</span><span class="sxs-lookup"><span data-stu-id="26a61-158">For an example, see the following type.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#2](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#2)]
[!code-vb[c_collection_types_in_data_contracts#2](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#2)]

<span data-ttu-id="26a61-159">Při serializaci je výsledný kód XML podobný následujícímu.</span><span class="sxs-lookup"><span data-stu-id="26a61-159">When serialized, the resulting XML is similar to the following.</span></span>

```xml
<CustomerList2>
    <string>...</string>
    <string>...</string>
    <string>...</string>
    ...
</CustomerList2>
```

<span data-ttu-id="26a61-160">Všimněte si, že to již není ekvivalentem reprezentace XML nepřizpůsobených typů.</span><span class="sxs-lookup"><span data-stu-id="26a61-160">Notice that this is no longer equivalent to the XML representation of the non-customized types.</span></span>

- <span data-ttu-id="26a61-161">Můžete použít `Name` `Namespace` vlastnosti a k dalšímu přizpůsobení názvů.</span><span class="sxs-lookup"><span data-stu-id="26a61-161">You can use the `Name` and `Namespace` properties to further customize the naming.</span></span> <span data-ttu-id="26a61-162">Podívejte se na následující třídu.</span><span class="sxs-lookup"><span data-stu-id="26a61-162">See the following class.</span></span>

  [!code-csharp[c_collection_types_in_data_contracts#3](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#3)]
  [!code-vb[c_collection_types_in_data_contracts#3](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#3)]

<span data-ttu-id="26a61-163">Výsledný kód XML je podobný následujícímu.</span><span class="sxs-lookup"><span data-stu-id="26a61-163">The resulting XML is similar to the following.</span></span>

```xml
<cust_list>
    <string>...</string>
    <string>...</string>
    <string>...</string>
    ...
</cust_list>
```

<span data-ttu-id="26a61-164">Další informace najdete v části Rozšířená pravidla shromažďování informací dále v tomto tématu.</span><span class="sxs-lookup"><span data-stu-id="26a61-164">For more information, see the "Advanced Collection Rules" section later in this topic.</span></span>

### <a name="customizing-the-repeating-element-name-in-list-collections"></a><span data-ttu-id="26a61-165">Přizpůsobení opakujícího se názvu elementu v kolekcích seznamu</span><span class="sxs-lookup"><span data-stu-id="26a61-165">Customizing the Repeating Element Name in List Collections</span></span>

<span data-ttu-id="26a61-166">Kolekce seznamů obsahují opakující se položky.</span><span class="sxs-lookup"><span data-stu-id="26a61-166">List collections contain repeating entries.</span></span> <span data-ttu-id="26a61-167">Obvykle je každá opakující se položka reprezentovaná jako element s názvem podle názvu kontraktu dat typu obsaženého v kolekci.</span><span class="sxs-lookup"><span data-stu-id="26a61-167">Normally, each repeating entry is represented as an element named according to the data contract name of the type contained in the collection.</span></span>

<span data-ttu-id="26a61-168">V `CustomerList` příkladech kolekce obsahovaly řetězce.</span><span class="sxs-lookup"><span data-stu-id="26a61-168">In the `CustomerList` examples, the collections contained strings.</span></span> <span data-ttu-id="26a61-169">Název kontraktu dat pro primitivní typ řetězce je "String", takže opakující se element byl " \<string> ".</span><span class="sxs-lookup"><span data-stu-id="26a61-169">The data contract name for the string primitive type is "string", so the repeating element was "\<string>".</span></span>

<span data-ttu-id="26a61-170">Nicméně pomocí <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ItemName%2A> vlastnosti u <xref:System.Runtime.Serialization.CollectionDataContractAttribute> atributu lze tento opakující se název elementu přizpůsobit.</span><span class="sxs-lookup"><span data-stu-id="26a61-170">However, using the <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ItemName%2A> property on the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute, this repeating element name can be customized.</span></span> <span data-ttu-id="26a61-171">Příklad naleznete v následujícím typu.</span><span class="sxs-lookup"><span data-stu-id="26a61-171">For an example, see the following type.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#4](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#4)]
[!code-vb[c_collection_types_in_data_contracts#4](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#4)]

<span data-ttu-id="26a61-172">Výsledný kód XML je podobný následujícímu.</span><span class="sxs-lookup"><span data-stu-id="26a61-172">The resulting XML is similar to the following.</span></span>

```xml
<CustomerList4>
    <customer>...</customer>
    <customer>...</customer>
    <customer>...</customer>
    ...
</CustomerList4>
```

<span data-ttu-id="26a61-173">Obor názvů opakujícího se elementu je vždy stejný jako obor názvů kontraktu dat kolekce, který lze přizpůsobit pomocí `Namespace` vlastnosti, jak je popsáno výše.</span><span class="sxs-lookup"><span data-stu-id="26a61-173">The namespace of the repeating element is always the same as the namespace of the collection data contract, which can be customized using the `Namespace` property, as described previously.</span></span>

### <a name="customizing-dictionary-collections"></a><span data-ttu-id="26a61-174">Přizpůsobení kolekcí slovníku</span><span class="sxs-lookup"><span data-stu-id="26a61-174">Customizing Dictionary Collections</span></span>

<span data-ttu-id="26a61-175">Kolekce slovníku jsou v podstatě seznamy položek, kde každá položka má klíč následovaný hodnotou.</span><span class="sxs-lookup"><span data-stu-id="26a61-175">Dictionary collections are essentially lists of entries, where each entry has a key followed by a value.</span></span> <span data-ttu-id="26a61-176">Stejně jako u běžných seznamů můžete změnit název prvku, který odpovídá opakujícímu se elementu pomocí <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ItemName%2A> Vlastnosti.</span><span class="sxs-lookup"><span data-stu-id="26a61-176">Just as with regular lists, you can change the element name that corresponds to the repeating element by using the <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ItemName%2A> property.</span></span>

<span data-ttu-id="26a61-177">Kromě toho můžete změnit názvy elementů, které reprezentují klíč a hodnotu pomocí <xref:System.Runtime.Serialization.CollectionDataContractAttribute.KeyName%2A> <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ValueName%2A> vlastností a.</span><span class="sxs-lookup"><span data-stu-id="26a61-177">Additionally, you can change the element names that represent the key and the value by using the <xref:System.Runtime.Serialization.CollectionDataContractAttribute.KeyName%2A> and <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ValueName%2A> properties.</span></span> <span data-ttu-id="26a61-178">Obory názvů pro tyto prvky jsou stejné jako obor názvů kontraktu dat kolekce.</span><span class="sxs-lookup"><span data-stu-id="26a61-178">The namespaces for these elements are the same as the namespace of the collection data contract.</span></span>

<span data-ttu-id="26a61-179">Příklad naleznete v následujícím typu.</span><span class="sxs-lookup"><span data-stu-id="26a61-179">For an example, see the following type.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#5](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#5)]
[!code-vb[c_collection_types_in_data_contracts#5](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#5)]

<span data-ttu-id="26a61-180">Při serializaci je výsledný kód XML podobný následujícímu.</span><span class="sxs-lookup"><span data-stu-id="26a61-180">When serialized, the resulting XML is similar to the following.</span></span>

```xml
<CountriesOrRegionsWithCapitals>
    <entry>
        <countryorregion>USA</countryorregion>
        <capital>Washington</capital>
    </entry>
    <entry>
        <countryorregion>France</countryorregion>
        <capital>Paris</capital>
    </entry>
    ...
</CountriesOrRegionsWithCapitals>
```

<span data-ttu-id="26a61-181">Další informace o kolekcích slovníků najdete v části Rozšířená pravidla shromažďování informací dále v tomto tématu.</span><span class="sxs-lookup"><span data-stu-id="26a61-181">For more information about dictionary collections, see the "Advanced Collection Rules" section later in this topic.</span></span>

## <a name="collections-and-known-types"></a><span data-ttu-id="26a61-182">Kolekce a známé typy</span><span class="sxs-lookup"><span data-stu-id="26a61-182">Collections and Known Types</span></span>

<span data-ttu-id="26a61-183">Nemusíte přidávat typy kolekcí ke známým typům, pokud se používají polymorfní místo jiných kolekcí nebo rozhraní kolekcí.</span><span class="sxs-lookup"><span data-stu-id="26a61-183">You do not need to add collection types to known types when used polymorphically in place of other collections or collection interfaces.</span></span> <span data-ttu-id="26a61-184">Například pokud deklarujete datový člen typu <xref:System.Collections.IEnumerable> a použijete jej k odeslání instance <xref:System.Collections.ArrayList> , není nutné přidávat <xref:System.Collections.ArrayList> do známých typů.</span><span class="sxs-lookup"><span data-stu-id="26a61-184">For example, if you declare a data member of type <xref:System.Collections.IEnumerable> and use it to send an instance of <xref:System.Collections.ArrayList>, you do not need to add <xref:System.Collections.ArrayList> to known types.</span></span>

<span data-ttu-id="26a61-185">Při použití kolekcí, které jsou polymorfní místo typů kolekce, je nutné je přidat ke známým typům.</span><span class="sxs-lookup"><span data-stu-id="26a61-185">When you use collections polymorphically in place of non-collection types, they must be added to known types.</span></span> <span data-ttu-id="26a61-186">Například pokud deklarujete datový člen typu `Object` a použijete jej k odeslání instance <xref:System.Collections.ArrayList> , přidejte <xref:System.Collections.ArrayList> do známých typů.</span><span class="sxs-lookup"><span data-stu-id="26a61-186">For example, if you declare a data member of type `Object` and use it to send an instance of <xref:System.Collections.ArrayList>, add <xref:System.Collections.ArrayList> to known types.</span></span>

<span data-ttu-id="26a61-187">To vám neumožňuje serializovat žádnou ekvivalentní kolekci polymorfní.</span><span class="sxs-lookup"><span data-stu-id="26a61-187">This does not allow you to serialize any equivalent collection polymorphically.</span></span> <span data-ttu-id="26a61-188">Například při přidání <xref:System.Collections.ArrayList> do seznamu známých typů v předchozím příkladu vám to neumožňuje přiřadit `Array of Object` třídu, i když má ekvivalentní kontrakt dat.</span><span class="sxs-lookup"><span data-stu-id="26a61-188">For example, when you add <xref:System.Collections.ArrayList> to the list of known types in the preceding example, this does not let you assign the `Array of Object` class, even though it has an equivalent data contract.</span></span> <span data-ttu-id="26a61-189">To se neliší od chování běžných známých typů při serializaci pro typy, které nejsou kolekcemi, ale je obzvláště důležité pochopit v případě kolekcí, protože je velmi běžné, aby kolekce byly ekvivalentní.</span><span class="sxs-lookup"><span data-stu-id="26a61-189">This is no different from regular known types behavior on serialization for non-collection types, but it is especially important to understand in the case of collections because it is very common for collections to be equivalent.</span></span>

<span data-ttu-id="26a61-190">Během serializace může být v daném oboru pro daný kontrakt dat znám pouze jeden typ a stejné kolekce mají stejné kontrakty dat.</span><span class="sxs-lookup"><span data-stu-id="26a61-190">During serialization, only one type can be known in any given scope for a given data contract, and equivalent collections all have the same data contracts.</span></span> <span data-ttu-id="26a61-191">To znamená, že v předchozím příkladu nelze přidat obojí <xref:System.Collections.ArrayList> a `Array of Object` ke známým typům ve stejném oboru.</span><span class="sxs-lookup"><span data-stu-id="26a61-191">This means that, in the previous example, you cannot add both <xref:System.Collections.ArrayList> and `Array of Object` to known types at the same scope.</span></span> <span data-ttu-id="26a61-192">Tento postup je stejný jako chování známých typů pro typy bez kolekce, ale je obzvláště důležité pochopit pro kolekce.</span><span class="sxs-lookup"><span data-stu-id="26a61-192">Again, this is equivalent to known types behavior for non-collection types, but it is especially important to understand for collections.</span></span>

<span data-ttu-id="26a61-193">Pro obsah kolekcí můžou být také požadovány známé typy.</span><span class="sxs-lookup"><span data-stu-id="26a61-193">Known types may also be required for contents of collections.</span></span> <span data-ttu-id="26a61-194">Například pokud <xref:System.Collections.ArrayList> ve skutečnosti obsahuje instance `Type1` a `Type2` , oba tyto typy by měly být přidány do známých typů.</span><span class="sxs-lookup"><span data-stu-id="26a61-194">For example, if an <xref:System.Collections.ArrayList> actually contains instances of `Type1` and `Type2`, both of these types should be added to known types.</span></span>

<span data-ttu-id="26a61-195">Následující příklad ukazuje správně vytvořený graf objektů pomocí kolekcí a známých typů.</span><span class="sxs-lookup"><span data-stu-id="26a61-195">The following example shows a properly constructed object graph using collections and known types.</span></span> <span data-ttu-id="26a61-196">Příklad je trochu contrived, protože ve skutečné aplikaci byste normálně nedefinovali následující datové členy jako `Object` , a proto nemají žádné známé problémy typu a polymorfismus.</span><span class="sxs-lookup"><span data-stu-id="26a61-196">The example is somewhat contrived, because in an actual application you would normally not define the following data members as `Object`, and thus do not have any known type/polymorphism issues.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#6](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#6)]
[!code-vb[c_collection_types_in_data_contracts#6](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#6)]

<span data-ttu-id="26a61-197">Pokud je deklarovaný typ typem kolekce, je při deserializaci vytvořena instance deklarovaného typu bez ohledu na typ, který byl skutečně odeslán.</span><span class="sxs-lookup"><span data-stu-id="26a61-197">On deserialization, if the declared type is a collection type, the declared type is instantiated regardless of the type that was actually sent.</span></span> <span data-ttu-id="26a61-198">Pokud je deklarovaný typ rozhraní kolekce, pak deserializátor vybere typ, který má být vytvořen bez ohledu na známé typy.</span><span class="sxs-lookup"><span data-stu-id="26a61-198">If the declared type is a collection interface, the deserializer picks a type to be instantiated with no regard to known types.</span></span>

<span data-ttu-id="26a61-199">V případě deserializace, pokud deklarovaný typ není typem kolekce, ale je odesílán typ kolekce, je typ odpovídajícího typu kolekce vyzvednut ze seznamu známých typů.</span><span class="sxs-lookup"><span data-stu-id="26a61-199">Also on deserialization, if the declared type is not a collection type but a collection type is being sent, a matching collection type is picked out of the known types list.</span></span> <span data-ttu-id="26a61-200">Je možné přidat typy rozhraní kolekce do seznamu známých typů při deserializaci.</span><span class="sxs-lookup"><span data-stu-id="26a61-200">It is possible to add collection interface types to the list of known types on deserialization.</span></span> <span data-ttu-id="26a61-201">V tomto případě modul deserializace znovu vybere typ, který má být vytvořen.</span><span class="sxs-lookup"><span data-stu-id="26a61-201">In this case, the deserialization engine again picks a type to be instantiated.</span></span>

## <a name="collections-and-the-netdatacontractserializer-class"></a><span data-ttu-id="26a61-202">Kolekce a třída NetDataContractSerializer</span><span class="sxs-lookup"><span data-stu-id="26a61-202">Collections and the NetDataContractSerializer Class</span></span>

<span data-ttu-id="26a61-203">Pokud <xref:System.Runtime.Serialization.NetDataContractSerializer> je třída používána, nevlastní typy kolekce (bez <xref:System.Runtime.Serialization.CollectionDataContractAttribute> atributu), které nejsou pole, ztratí jejich zvláštní význam.</span><span class="sxs-lookup"><span data-stu-id="26a61-203">When the <xref:System.Runtime.Serialization.NetDataContractSerializer> class is in use, non-customized collection types (without the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute) that are not arrays lose their special meaning.</span></span>

<span data-ttu-id="26a61-204">Nepřizpůsobené typy kolekce označené <xref:System.SerializableAttribute> atributem mohou být nadále serializovány <xref:System.Runtime.Serialization.NetDataContractSerializer> třídou podle <xref:System.SerializableAttribute> atributu nebo <xref:System.Runtime.Serialization.ISerializable> pravidel rozhraní.</span><span class="sxs-lookup"><span data-stu-id="26a61-204">Non-customized collection types marked with the <xref:System.SerializableAttribute> attribute can still be serialized by the <xref:System.Runtime.Serialization.NetDataContractSerializer> class according to the <xref:System.SerializableAttribute> attribute or the <xref:System.Runtime.Serialization.ISerializable> interface rules.</span></span>

<span data-ttu-id="26a61-205">Přizpůsobené typy kolekce, rozhraní kolekce a pole jsou stále považovány za kolekce, i když <xref:System.Runtime.Serialization.NetDataContractSerializer> je třída používána.</span><span class="sxs-lookup"><span data-stu-id="26a61-205">Customized collection types, collection interfaces, and arrays are still treated as collections, even when the <xref:System.Runtime.Serialization.NetDataContractSerializer> class is in use.</span></span>

## <a name="collections-and-schema"></a><span data-ttu-id="26a61-206">Kolekce a schéma</span><span class="sxs-lookup"><span data-stu-id="26a61-206">Collections and Schema</span></span>

<span data-ttu-id="26a61-207">Všechny ekvivalentní kolekce mají stejnou reprezentaci ve schématu XSD (XML Schema Definition Language).</span><span class="sxs-lookup"><span data-stu-id="26a61-207">All equivalent collections have the same representation in XML Schema definition language (XSD) schema.</span></span> <span data-ttu-id="26a61-208">Z tohoto důvodu obvykle nezískáte stejný typ kolekce ve vygenerovaném klientském kódu jako ten na serveru.</span><span class="sxs-lookup"><span data-stu-id="26a61-208">Because of this, you normally do not get the same collection type in the generated client code as the one on the server.</span></span> <span data-ttu-id="26a61-209">Například server může používat kontrakt dat s obecným <xref:System.Collections.Generic.List%601> datovým členem typu Integer, ale v generovaném kódu klienta se stejný datový člen může stát polem celých čísel.</span><span class="sxs-lookup"><span data-stu-id="26a61-209">For example, the server may use a data contract with a Generic <xref:System.Collections.Generic.List%601> of Integer data member, but in the generated client code the same data member may become an array of integers.</span></span>

<span data-ttu-id="26a61-210">Kolekce slovníku jsou označeny pomocí anotace schématu specifické pro WCF, která značí, že se jedná o slovníky. v opačném případě jsou nerozlišovatelné z jednoduchých seznamů, které obsahují položky s klíčem a hodnotou.</span><span class="sxs-lookup"><span data-stu-id="26a61-210">Dictionary collections are marked with a WCF-specific schema annotation that indicate that they are dictionaries; otherwise, they are indistinguishable from simple lists that contain entries with a key and a value.</span></span> <span data-ttu-id="26a61-211">Přesný popis toho, jak se kolekce reprezentují ve schématu kontraktu dat, najdete v tématu [referenční informace schématu kontraktu dat](data-contract-schema-reference.md).</span><span class="sxs-lookup"><span data-stu-id="26a61-211">For an exact description of how collections are represented in data contract schema, see [Data Contract Schema Reference](data-contract-schema-reference.md).</span></span>

<span data-ttu-id="26a61-212">Ve výchozím nastavení nejsou typy pro nepřizpůsobené kolekce v importovaném kódu generovány.</span><span class="sxs-lookup"><span data-stu-id="26a61-212">By default, types are not generated for non-customized collections in imported code.</span></span> <span data-ttu-id="26a61-213">Datové členy typů kolekcí seznamu jsou importovány jako pole a datové členy typů kolekce slovníku jsou importovány jako obecný slovník.</span><span class="sxs-lookup"><span data-stu-id="26a61-213">Data members of list collection types are imported as arrays, and data members of dictionary collection types are imported as Generic Dictionary.</span></span>

<span data-ttu-id="26a61-214">Pro vlastní kolekce jsou však vygenerovány samostatné typy označené <xref:System.Runtime.Serialization.CollectionDataContractAttribute> atributem.</span><span class="sxs-lookup"><span data-stu-id="26a61-214">However, for customized collections, separate types are generated, marked with the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute.</span></span> <span data-ttu-id="26a61-215">(Přizpůsobený typ kolekce ve schématu je jeden, který nepoužívá výchozí obor názvů, název, název opakující se elementu nebo názvy elementů a hodnot.) Tyto typy jsou prázdné typy, které jsou odvozeny z obecného <xref:System.Collections.Generic.List%601> pro typy seznamu a obecný slovník pro typy slovníku.</span><span class="sxs-lookup"><span data-stu-id="26a61-215">(A customized collection type in the schema is one that does not use the default namespace, name, repeating element name, or key/value element names.) These types are empty types that derive from Generic <xref:System.Collections.Generic.List%601> for list types and Generic Dictionary for dictionary types.</span></span>

<span data-ttu-id="26a61-216">Na serveru můžete například mít následující typy.</span><span class="sxs-lookup"><span data-stu-id="26a61-216">For example, you may have the following types on the server.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#7](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#7)]
[!code-vb[c_collection_types_in_data_contracts#7](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#7)]

<span data-ttu-id="26a61-217">Když se schéma exportuje a znovu naimportuje zpátky, vygenerovaný kód klienta je podobný následujícímu (pole se zobrazují místo vlastností pro usnadnění čtení).</span><span class="sxs-lookup"><span data-stu-id="26a61-217">When the schema is exported and imported back again, the generated client code is similar to the following (fields are shown instead of properties for ease of reading).</span></span>

[!code-csharp[c_collection_types_in_data_contracts#8](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#8)]
[!code-vb[c_collection_types_in_data_contracts#8](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#8)]

<span data-ttu-id="26a61-218">Můžete chtít použít různé typy v generovaném kódu, než je výchozí.</span><span class="sxs-lookup"><span data-stu-id="26a61-218">You may want to use different types in generated code than the default ones.</span></span> <span data-ttu-id="26a61-219">Například můžete chtít použít obecný <xref:System.ComponentModel.BindingList%601> místo regulárních polí pro datové členy, aby bylo snazší je navazovat na součásti uživatelského rozhraní.</span><span class="sxs-lookup"><span data-stu-id="26a61-219">For example, you may want to use Generic <xref:System.ComponentModel.BindingList%601> instead of regular arrays for your data members to make it easier to bind them to user interface components.</span></span>

<span data-ttu-id="26a61-220">Chcete-li zvolit typy kolekce, které mají být vygenerovány, předejte seznam typů kolekcí, které chcete použít, do <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A> vlastnosti <xref:System.Runtime.Serialization.ImportOptions> objektu při importu schématu.</span><span class="sxs-lookup"><span data-stu-id="26a61-220">To choose collection types to generate, pass a list of collection types you want to use into the <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A> property of the <xref:System.Runtime.Serialization.ImportOptions> object when importing schema.</span></span> <span data-ttu-id="26a61-221">Tyto typy se nazývají *odkazované typy kolekcí*.</span><span class="sxs-lookup"><span data-stu-id="26a61-221">These types are called *referenced collection types*.</span></span>

<span data-ttu-id="26a61-222">Při odkazování na obecné typy musí být buď plně otevřené obecné nebo plně uzavřené obecné typy.</span><span class="sxs-lookup"><span data-stu-id="26a61-222">When generic types are being referenced, they must either be fully-open generics or fully-closed generics.</span></span>

> [!NOTE]
> <span data-ttu-id="26a61-223">Při použití nástroje Svcutil. exe lze tento odkaz provést pomocí přepínače příkazového řádku **/CollectionType** (krátký tvar: **/CT**).</span><span class="sxs-lookup"><span data-stu-id="26a61-223">When using the Svcutil.exe tool, this reference can be accomplished by using the **/collectionType** command-line switch (short form: **/ct**).</span></span> <span data-ttu-id="26a61-224">Mějte na paměti, že musíte také zadat sestavení pro odkazované typy kolekcí pomocí přepínače **/reference** (krátký tvar: **/r**).</span><span class="sxs-lookup"><span data-stu-id="26a61-224">Keep in mind that you must also specify the assembly for the referenced collection types using the **/reference** switch (short form: **/r**).</span></span> <span data-ttu-id="26a61-225">Pokud je typ obecný, musí následovat zadní uvozovka a počet obecných parametrů.</span><span class="sxs-lookup"><span data-stu-id="26a61-225">If the type is generic, it must be followed by a back quote and the number of generic parameters.</span></span> <span data-ttu-id="26a61-226">Zpětná uvozovka ( \` ) se Nepleťe s znakem jednoduché uvozovky (').</span><span class="sxs-lookup"><span data-stu-id="26a61-226">The back quote (\`) is not to be confused with the single quote (‘) character.</span></span> <span data-ttu-id="26a61-227">Můžete zadat více odkazovaných typů kolekce pomocí přepínače **/CollectionType** více než jednou.</span><span class="sxs-lookup"><span data-stu-id="26a61-227">You can specify multiple referenced collection types by using the **/collectionType** switch more than once.</span></span>

<span data-ttu-id="26a61-228">Například pokud chcete, aby všechny seznamy byly importovány jako obecné <xref:System.Collections.Generic.List%601> .</span><span class="sxs-lookup"><span data-stu-id="26a61-228">For example, to cause all lists to be imported as Generic <xref:System.Collections.Generic.List%601>.</span></span>

```console
svcutil.exe MyService.wsdl MyServiceSchema.xsd /r:C:\full_path_to_system_dll\System.dll /ct:System.Collections.Generic.List`1
```

<span data-ttu-id="26a61-229">Při importu libovolné kolekce se prohledají tento seznam odkazovaných typů kolekce a v případě, že se najde, použije se nejlepší kolekce, a to buď jako typ datového členu (pro nepřizpůsobené kolekce), nebo jako základní typ, který se má odvodit (pro přizpůsobené kolekce).</span><span class="sxs-lookup"><span data-stu-id="26a61-229">When importing any collection, this list of referenced collection types is scanned, and the best-matching collection is used if one is found, either as a data member type (for non-customized collections) or as a base type to derive from (for customized collections).</span></span> <span data-ttu-id="26a61-230">Slovníky se shodují jenom se slovníky, zatímco seznamy se shodují se seznamy.</span><span class="sxs-lookup"><span data-stu-id="26a61-230">Dictionaries are only matched against dictionaries, while lists are matched against lists.</span></span>

<span data-ttu-id="26a61-231">Například pokud přidáte obecné <xref:System.ComponentModel.BindingList%601> a <xref:System.Collections.Hashtable> do seznamu odkazovaných typů, vygenerovaný kód klienta pro předchozí příklad je podobný následujícímu.</span><span class="sxs-lookup"><span data-stu-id="26a61-231">For example, if you add the Generic <xref:System.ComponentModel.BindingList%601> and <xref:System.Collections.Hashtable> to the list of referenced types, the generated client code for the preceding example is similar to the following.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#9](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#9)]
[!code-vb[c_collection_types_in_data_contracts#9](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#9)]

<span data-ttu-id="26a61-232">Typy rozhraní kolekce lze zadat jako součást vašich odkazovaných typů kolekce, ale nelze zadat neplatné typy kolekcí (například ty, které neobsahují `Add` metodu ani veřejný konstruktor).</span><span class="sxs-lookup"><span data-stu-id="26a61-232">You can specify collection interface types as part of your referenced collection types, but you cannot specify invalid collection types (such as ones with no `Add` method or public constructor).</span></span>

<span data-ttu-id="26a61-233">Uzavřený obecný objekt je považován za nejlepší shodu.</span><span class="sxs-lookup"><span data-stu-id="26a61-233">A closed generic is considered to be the best match.</span></span> <span data-ttu-id="26a61-234">(Neobecné typy jsou považovány za ekvivalent k uzavřeným obecným typům `Object` ).</span><span class="sxs-lookup"><span data-stu-id="26a61-234">(Non-generic types are considered equivalent to closed generics of `Object`).</span></span> <span data-ttu-id="26a61-235">Pokud například obecné typy <xref:System.Collections.Generic.List%601> <xref:System.DateTime> , obecné <xref:System.ComponentModel.BindingList%601> (otevřené Obecné) a <xref:System.Collections.ArrayList> jsou odkazované typy kolekce, je vygenerováno následující.</span><span class="sxs-lookup"><span data-stu-id="26a61-235">For example, if the types Generic <xref:System.Collections.Generic.List%601> of <xref:System.DateTime>, Generic <xref:System.ComponentModel.BindingList%601> (open generic), and <xref:System.Collections.ArrayList> are the referenced collection types, the following is generated.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#10](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#10)]
[!code-vb[c_collection_types_in_data_contracts#10](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#10)]

<span data-ttu-id="26a61-236">V případě kolekcí seznamů jsou podporovány pouze případy v následující tabulce.</span><span class="sxs-lookup"><span data-stu-id="26a61-236">For list collections, only the cases in the following table are supported.</span></span>

|<span data-ttu-id="26a61-237">Odkazovaný typ</span><span class="sxs-lookup"><span data-stu-id="26a61-237">Referenced type</span></span>|<span data-ttu-id="26a61-238">Rozhraní implementované odkazovaným typem</span><span class="sxs-lookup"><span data-stu-id="26a61-238">Interface implemented by referenced type</span></span>|<span data-ttu-id="26a61-239">Příklad</span><span class="sxs-lookup"><span data-stu-id="26a61-239">Example</span></span>|<span data-ttu-id="26a61-240">Typ se považuje za:</span><span class="sxs-lookup"><span data-stu-id="26a61-240">Type treated as:</span></span>|
|---------------------|----------------------------------------------|-------------|----------------------|
|<span data-ttu-id="26a61-241">Neobecný nebo uzavřený obecný (libovolný počet parametrů)</span><span class="sxs-lookup"><span data-stu-id="26a61-241">Non-generic or closed generic (any number of parameters)</span></span>|<span data-ttu-id="26a61-242">Neobecné</span><span class="sxs-lookup"><span data-stu-id="26a61-242">Non-generic</span></span>|`MyType : IList`<br /><br /> <span data-ttu-id="26a61-243">nebo</span><span class="sxs-lookup"><span data-stu-id="26a61-243">or</span></span><br /><br /> `MyType<T> : IList`<br /><br /> <span data-ttu-id="26a61-244">kde T =`int`</span><span class="sxs-lookup"><span data-stu-id="26a61-244">where T= `int`</span></span>|<span data-ttu-id="26a61-245">Uzavřený obecný příklad `Object` (například `IList<object>` )</span><span class="sxs-lookup"><span data-stu-id="26a61-245">Closed generic of `Object` (for example, `IList<object>`)</span></span>|
|<span data-ttu-id="26a61-246">Neobecný nebo uzavřený obecný (libovolný počet parametrů, které se nutně neshodují s typem kolekce)</span><span class="sxs-lookup"><span data-stu-id="26a61-246">Non-generic or closed generic (any number of parameters that do not necessarily match the collection type)</span></span>|<span data-ttu-id="26a61-247">Uzavřený obecný</span><span class="sxs-lookup"><span data-stu-id="26a61-247">Closed generic</span></span>|`MyType : IList<string>`<br /><br /> <span data-ttu-id="26a61-248">nebo</span><span class="sxs-lookup"><span data-stu-id="26a61-248">or</span></span><br /><br /> <span data-ttu-id="26a61-249">`MyType<T> : IList<string>`kde T =`int`</span><span class="sxs-lookup"><span data-stu-id="26a61-249">`MyType<T> : IList<string>` where T=`int`</span></span>|<span data-ttu-id="26a61-250">Uzavřený obecný (například `IList<string>` )</span><span class="sxs-lookup"><span data-stu-id="26a61-250">Closed generic (for example, `IList<string>`)</span></span>|
|<span data-ttu-id="26a61-251">Uzavřený obecný s libovolným počtem parametrů</span><span class="sxs-lookup"><span data-stu-id="26a61-251">Closed generic with any number of parameters</span></span>|<span data-ttu-id="26a61-252">Otevřete obecné pomocí některého z parametrů typu.</span><span class="sxs-lookup"><span data-stu-id="26a61-252">Open generic using any one of the type’s parameters</span></span>|`MyType<T,U,V> : IList<U>`<br /><br /> <span data-ttu-id="26a61-253">kde T = `int` , U = `string` , V =`bool`</span><span class="sxs-lookup"><span data-stu-id="26a61-253">where T=`int`, U=`string`, V=`bool`</span></span>|<span data-ttu-id="26a61-254">Uzavřený obecný (například `IList<string>` )</span><span class="sxs-lookup"><span data-stu-id="26a61-254">Closed generic (for example, `IList<string>`)</span></span>|
|<span data-ttu-id="26a61-255">Otevřít obecný s jedním parametrem</span><span class="sxs-lookup"><span data-stu-id="26a61-255">Open generic with one parameter</span></span>|<span data-ttu-id="26a61-256">Otevření obecného pomocí parametru typu</span><span class="sxs-lookup"><span data-stu-id="26a61-256">Open generic using the type’s parameter</span></span>|<span data-ttu-id="26a61-257">`MyType<T> : IList<T>`, T je otevřený</span><span class="sxs-lookup"><span data-stu-id="26a61-257">`MyType<T> : IList<T>`, T is open</span></span>|<span data-ttu-id="26a61-258">Otevřený obecný (například `IList<T>` )</span><span class="sxs-lookup"><span data-stu-id="26a61-258">Open generic (for example, `IList<T>`)</span></span>|

<span data-ttu-id="26a61-259">Pokud typ implementuje více než jedno rozhraní kolekce seznamů, platí následující omezení:</span><span class="sxs-lookup"><span data-stu-id="26a61-259">If a type implements more than one list collection interface, the following restrictions apply:</span></span>

- <span data-ttu-id="26a61-260">Pokud typ implementuje obecné <xref:System.Collections.Generic.IEnumerable%601> (nebo jeho odvozená rozhraní) několikrát pro různé typy, typ není považován za platný odkazový typ kolekce a je ignorován.</span><span class="sxs-lookup"><span data-stu-id="26a61-260">If the type implements Generic <xref:System.Collections.Generic.IEnumerable%601> (or its derived interfaces) multiple times for different types, the type is not considered a valid referenced collection type and is ignored.</span></span> <span data-ttu-id="26a61-261">To platí i v případě, že některé implementace jsou neplatné nebo používají otevřené obecné typy.</span><span class="sxs-lookup"><span data-stu-id="26a61-261">This is true even if some implementations are invalid or use open generics.</span></span> <span data-ttu-id="26a61-262">Například typ, který implementuje Generic <xref:System.Collections.Generic.IEnumerable%601> of `int` a Generic <xref:System.Collections.Generic.IEnumerable%601> Of T, by nikdy neměl být použit jako odkazovaná kolekce `int` nebo jakýkoli jiný typ, bez ohledu na to, zda typ obsahuje `Add` metodu `int` , nebo metoda, která `Add` přijímá parametr typu T nebo obojí.</span><span class="sxs-lookup"><span data-stu-id="26a61-262">For example, a type that implements Generic <xref:System.Collections.Generic.IEnumerable%601> of `int` and Generic <xref:System.Collections.Generic.IEnumerable%601> of T would never be used as a referenced collection of `int` or any other type, regardless of whether the type has an `Add` method accepting `int` or an `Add` method accepting a parameter of type T, or both.</span></span>

- <span data-ttu-id="26a61-263">Pokud typ implementuje rozhraní pro obecné kolekce a také <xref:System.Collections.IList> , typ se nikdy nepoužívá jako odkazový typ kolekce, pokud obecné rozhraní kolekce není uzavřeným obecným typem <xref:System.Object> .</span><span class="sxs-lookup"><span data-stu-id="26a61-263">If the type implements a generic collection interface as well as <xref:System.Collections.IList>, the type is never used as a referenced collection type unless the generic collection interface is a closed generic of type <xref:System.Object>.</span></span>

<span data-ttu-id="26a61-264">V případě kolekcí slovníků jsou podporovány pouze případy v následující tabulce.</span><span class="sxs-lookup"><span data-stu-id="26a61-264">For dictionary collections, only the cases in the following table are supported.</span></span>

|<span data-ttu-id="26a61-265">Odkazovaný typ</span><span class="sxs-lookup"><span data-stu-id="26a61-265">Referenced type</span></span>|<span data-ttu-id="26a61-266">Rozhraní implementované odkazovaným typem</span><span class="sxs-lookup"><span data-stu-id="26a61-266">Interface implemented by referenced type</span></span>|<span data-ttu-id="26a61-267">Příklad</span><span class="sxs-lookup"><span data-stu-id="26a61-267">Example</span></span>|<span data-ttu-id="26a61-268">Typ se považuje za</span><span class="sxs-lookup"><span data-stu-id="26a61-268">Type treated as</span></span>|
|---------------------|----------------------------------------------|-------------|---------------------|
|<span data-ttu-id="26a61-269">Neobecný nebo uzavřený obecný (libovolný počet parametrů)</span><span class="sxs-lookup"><span data-stu-id="26a61-269">Non-generic or closed generic (any number of parameters)</span></span>|<xref:System.Collections.IDictionary>|`MyType : IDictionary`<br /><br /> <span data-ttu-id="26a61-270">nebo</span><span class="sxs-lookup"><span data-stu-id="26a61-270">or</span></span><br /><br /> <span data-ttu-id="26a61-271">`MyType<T> : IDictionary`kde T =`int`</span><span class="sxs-lookup"><span data-stu-id="26a61-271">`MyType<T> : IDictionary` where T=`int`</span></span>|<span data-ttu-id="26a61-272">Uzavřený obecný`IDictionary<object,object>`</span><span class="sxs-lookup"><span data-stu-id="26a61-272">Closed generic `IDictionary<object,object>`</span></span>|
|<span data-ttu-id="26a61-273">Uzavřený obecný (libovolný počet parametrů)</span><span class="sxs-lookup"><span data-stu-id="26a61-273">Closed generic (any number of parameters)</span></span>|<span data-ttu-id="26a61-274"><xref:System.Collections.Generic.IDictionary%602>, uzavřeno</span><span class="sxs-lookup"><span data-stu-id="26a61-274"><xref:System.Collections.Generic.IDictionary%602>, closed</span></span>|<span data-ttu-id="26a61-275">`MyType<T> : IDictionary<string, bool>`kde T =`int`</span><span class="sxs-lookup"><span data-stu-id="26a61-275">`MyType<T> : IDictionary<string, bool>` where T=`int`</span></span>|<span data-ttu-id="26a61-276">Uzavřený obecný (například `IDIctionary<string,bool>` )</span><span class="sxs-lookup"><span data-stu-id="26a61-276">Closed generic (for example, `IDIctionary<string,bool>`)</span></span>|
|<span data-ttu-id="26a61-277">Uzavřený obecný (libovolný počet parametrů)</span><span class="sxs-lookup"><span data-stu-id="26a61-277">Closed generic (any number of parameters)</span></span>|<span data-ttu-id="26a61-278">Generic <xref:System.Collections.Generic.IDictionary%602> , jedna z hodnot klíč nebo value je uzavřená, druhá je otevřená a používá jeden z parametrů typu.</span><span class="sxs-lookup"><span data-stu-id="26a61-278">Generic <xref:System.Collections.Generic.IDictionary%602>, one of either key or value is closed, the other is open and uses one of type’s parameters</span></span>|<span data-ttu-id="26a61-279">`MyType<T,U,V> : IDictionary<string,V>`kde T = `int` , U = `float` , V =`bool`</span><span class="sxs-lookup"><span data-stu-id="26a61-279">`MyType<T,U,V> : IDictionary<string,V>` where T=`int`, U=`float`,V=`bool`</span></span><br /><br /> <span data-ttu-id="26a61-280">nebo</span><span class="sxs-lookup"><span data-stu-id="26a61-280">or</span></span><br /><br /> <span data-ttu-id="26a61-281">`MyType<Z> : IDictionary<Z,bool>`kde Z =`string`</span><span class="sxs-lookup"><span data-stu-id="26a61-281">`MyType<Z> : IDictionary<Z,bool>` where Z=`string`</span></span>|<span data-ttu-id="26a61-282">Uzavřený obecný (například `IDictionary<string,bool>` )</span><span class="sxs-lookup"><span data-stu-id="26a61-282">Closed generic (For example, `IDictionary<string,bool>`)</span></span>|
|<span data-ttu-id="26a61-283">Uzavřený obecný (libovolný počet parametrů)</span><span class="sxs-lookup"><span data-stu-id="26a61-283">Closed generic (any number of parameters)</span></span>|<span data-ttu-id="26a61-284">Generic <xref:System.Collections.Generic.IDictionary%602> , klíč i hodnota jsou otevřené a každá používá jeden z parametrů typu.</span><span class="sxs-lookup"><span data-stu-id="26a61-284">Generic <xref:System.Collections.Generic.IDictionary%602>, both key and value are open and each uses one of the type’s parameters</span></span>|<span data-ttu-id="26a61-285">`MyType<T,U,V> : IDictionary<V,U>`kde T = `int` , U = `bool` , V =`string`</span><span class="sxs-lookup"><span data-stu-id="26a61-285">`MyType<T,U,V> : IDictionary<V,U>` where T=`int`, U=`bool`, V=`string`</span></span>|<span data-ttu-id="26a61-286">Uzavřený obecný (například `IDictionary<string,bool>` )</span><span class="sxs-lookup"><span data-stu-id="26a61-286">Closed generic (for example, `IDictionary<string,bool>`)</span></span>|
|<span data-ttu-id="26a61-287">Otevřít obecný (dva parametry)</span><span class="sxs-lookup"><span data-stu-id="26a61-287">Open generic (two parameters)</span></span>|<span data-ttu-id="26a61-288">Obecné <xref:System.Collections.Generic.IDictionary%602> , otevřít, používá obecné parametry typu v pořadí, ve kterém se zobrazují.</span><span class="sxs-lookup"><span data-stu-id="26a61-288">Generic <xref:System.Collections.Generic.IDictionary%602>, open, uses both of the type’s generic parameters in the order they appear</span></span>|<span data-ttu-id="26a61-289">`MyType<K,V> : IDictionary<K,V>`, K a V otevřené</span><span class="sxs-lookup"><span data-stu-id="26a61-289">`MyType<K,V> : IDictionary<K,V>`, K and V both open</span></span>|<span data-ttu-id="26a61-290">Otevřený obecný (například `IDictionary<K,V>` )</span><span class="sxs-lookup"><span data-stu-id="26a61-290">Open generic (for example, `IDictionary<K,V>`)</span></span>|

<span data-ttu-id="26a61-291">Pokud typ implementuje jak i <xref:System.Collections.IDictionary> Obecné <xref:System.Collections.Generic.IDictionary%602> , <xref:System.Collections.Generic.IDictionary%602> je považována pouze obecná.</span><span class="sxs-lookup"><span data-stu-id="26a61-291">If the type implements both <xref:System.Collections.IDictionary> and Generic <xref:System.Collections.Generic.IDictionary%602>, only Generic <xref:System.Collections.Generic.IDictionary%602> is considered.</span></span>

<span data-ttu-id="26a61-292">Odkazy na částečné obecné typy se nepodporují.</span><span class="sxs-lookup"><span data-stu-id="26a61-292">Referencing partial generic types is not supported.</span></span>

<span data-ttu-id="26a61-293">Duplicity nejsou povoleny, například nelze přidat jak obecné, tak i <xref:System.Collections.Generic.List%601> `Integer` obecnou kolekci `Integer` do <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A> , protože díky tomu není možné určit, která z nich se má použít, když se ve schématu najde seznam celých čísel.</span><span class="sxs-lookup"><span data-stu-id="26a61-293">Duplicates are not allowed, for example, you cannot add both the Generic <xref:System.Collections.Generic.List%601> of `Integer` and the Generic Collection of `Integer` to <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A>, because this makes it impossible to determine which one to use when a list of integers is found in the schema.</span></span> <span data-ttu-id="26a61-294">Duplicity jsou zjištěny pouze v případě, že ve schématu existuje typ, který zpřístupňuje problém s duplicitami.</span><span class="sxs-lookup"><span data-stu-id="26a61-294">Duplicates are detected only if there is a type in the schema that exposes the duplicates problem.</span></span> <span data-ttu-id="26a61-295">Například pokud importované schéma neobsahuje seznam celých čísel, může mít jak obecné, tak i <xref:System.Collections.Generic.List%601> `Integer` obecnou kolekci `Integer` v <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A> , ale ani to nemá žádný vliv.</span><span class="sxs-lookup"><span data-stu-id="26a61-295">For example, if the schema being imported does not contain lists of integers, it is allowed to have both the Generic <xref:System.Collections.Generic.List%601> of `Integer` and the Generic Collection of `Integer` in the <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A>, but neither has any effect.</span></span>

## <a name="advanced-collection-rules"></a><span data-ttu-id="26a61-296">Rozšířená pravidla shromažďování</span><span class="sxs-lookup"><span data-stu-id="26a61-296">Advanced Collection Rules</span></span>

### <a name="serializing-collections"></a><span data-ttu-id="26a61-297">Serializace kolekcí</span><span class="sxs-lookup"><span data-stu-id="26a61-297">Serializing Collections</span></span>

<span data-ttu-id="26a61-298">Následuje seznam pravidel shromažďování pro serializaci:</span><span class="sxs-lookup"><span data-stu-id="26a61-298">The following is a list of collection rules for serialization:</span></span>

- <span data-ttu-id="26a61-299">Kombinování typů kolekcí (mají kolekce kolekcí) je povoleno.</span><span class="sxs-lookup"><span data-stu-id="26a61-299">Combining collection types (having collections of collections) is allowed.</span></span> <span data-ttu-id="26a61-300">Vícenásobná pole jsou považována za kolekce kolekcí.</span><span class="sxs-lookup"><span data-stu-id="26a61-300">Jagged arrays are treated as collections of collections.</span></span> <span data-ttu-id="26a61-301">Multidimenzionální pole nejsou podporována.</span><span class="sxs-lookup"><span data-stu-id="26a61-301">Multidimensional arrays are not supported.</span></span>

- <span data-ttu-id="26a61-302">Pole bajtů a polí pro <xref:System.Xml.XmlNode> jsou speciální typy pole, které jsou považovány za primitivní, nikoli pro kolekce.</span><span class="sxs-lookup"><span data-stu-id="26a61-302">Arrays of byte and arrays of <xref:System.Xml.XmlNode> are special array types that are treated as primitives, not collections.</span></span> <span data-ttu-id="26a61-303">Serializace pole bajtů v jednom elementu XML, který obsahuje blok dat kódovaných ve formátu base64, namísto samostatného prvku pro každý bajt.</span><span class="sxs-lookup"><span data-stu-id="26a61-303">Serializing an array of byte results in a single XML element that contains a chunk of Base64-encoded data, instead of a separate element for each byte.</span></span> <span data-ttu-id="26a61-304">Další informace o tom <xref:System.Xml.XmlNode> , jak se vychází z pole, najdete [v tématu Typy XML a ADO.NET v kontraktech dat](xml-and-ado-net-types-in-data-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="26a61-304">For more information about how an array of <xref:System.Xml.XmlNode> is treated, see [XML and ADO.NET Types in Data Contracts](xml-and-ado-net-types-in-data-contracts.md).</span></span> <span data-ttu-id="26a61-305">Tyto speciální typy se samozřejmě můžou zúčastnit v kolekcích: pole bajtů má za následek více elementů XML, přičemž každý z nich obsahuje blok dat kódovaných ve formátu base64.</span><span class="sxs-lookup"><span data-stu-id="26a61-305">Of course, these special types can themselves participate in collections: an array of array of byte results in multiple XML elements, with each containing a chunk of Base64-encoded data.</span></span>

- <span data-ttu-id="26a61-306">Pokud <xref:System.Runtime.Serialization.DataContractAttribute> je atribut použit pro typ kolekce, je typ považován za běžný typ kontraktu dat, nikoli jako kolekce.</span><span class="sxs-lookup"><span data-stu-id="26a61-306">If the <xref:System.Runtime.Serialization.DataContractAttribute> attribute is applied to a collection type, the type is treated as a regular data contract type, not as a collection.</span></span>

- <span data-ttu-id="26a61-307">Pokud typ kolekce implementuje <xref:System.Xml.Serialization.IXmlSerializable> rozhraní, platí následující pravidla pro daný typ `myType:IList<string>, IXmlSerializable` :</span><span class="sxs-lookup"><span data-stu-id="26a61-307">If a collection type implements the <xref:System.Xml.Serialization.IXmlSerializable> interface, the following rules apply, given a type `myType:IList<string>, IXmlSerializable`:</span></span>

  - <span data-ttu-id="26a61-308">Pokud je deklarovaný typ `IList<string>` , typ je serializován jako seznam.</span><span class="sxs-lookup"><span data-stu-id="26a61-308">If the declared type is `IList<string>`, the type is serialized as a list.</span></span>

  - <span data-ttu-id="26a61-309">Je-li deklarovaný typ `myType` , je serializován jako `IXmlSerializable` .</span><span class="sxs-lookup"><span data-stu-id="26a61-309">If the declared type is `myType`, it is serialized as `IXmlSerializable`.</span></span>

  - <span data-ttu-id="26a61-310">Pokud je deklarovaný typ `IXmlSerializable` , je serializován jako `IXmlSerializable` , ale pouze v případě, že přidáte `myType` do seznamu známých typů.</span><span class="sxs-lookup"><span data-stu-id="26a61-310">If the declared type is `IXmlSerializable`, it is serialized as `IXmlSerializable`, but only if you add `myType` to the list of known types.</span></span>

- <span data-ttu-id="26a61-311">Kolekce jsou serializovány a deserializovány pomocí metod, které jsou uvedeny v následující tabulce.</span><span class="sxs-lookup"><span data-stu-id="26a61-311">Collections are serialized and deserialized using the methods shown in the following table.</span></span>

|<span data-ttu-id="26a61-312">Implementace typu kolekce</span><span class="sxs-lookup"><span data-stu-id="26a61-312">Collection type implements</span></span>|<span data-ttu-id="26a61-313">Metody, které jsou volány při serializaci</span><span class="sxs-lookup"><span data-stu-id="26a61-313">Method(s) called on serialization</span></span>|<span data-ttu-id="26a61-314">Metody, které jsou volány při deserializaci</span><span class="sxs-lookup"><span data-stu-id="26a61-314">Method(s) called on deserialization</span></span>|
|--------------------------------|-----------------------------------------|-------------------------------------------|
|<span data-ttu-id="26a61-315">Obecněji<xref:System.Collections.Generic.IDictionary%602></span><span class="sxs-lookup"><span data-stu-id="26a61-315">Generic <xref:System.Collections.Generic.IDictionary%602></span></span>|<span data-ttu-id="26a61-316">`get_Keys`, `get_Values`</span><span class="sxs-lookup"><span data-stu-id="26a61-316">`get_Keys`, `get_Values`</span></span>|<span data-ttu-id="26a61-317">Obecné přidání</span><span class="sxs-lookup"><span data-stu-id="26a61-317">Generic Add</span></span>|
|<xref:System.Collections.IDictionary>|<span data-ttu-id="26a61-318">`get_Keys`, `get_Values`</span><span class="sxs-lookup"><span data-stu-id="26a61-318">`get_Keys`, `get_Values`</span></span>|`Add`|
|<span data-ttu-id="26a61-319">Obecněji<xref:System.Collections.Generic.IList%601></span><span class="sxs-lookup"><span data-stu-id="26a61-319">Generic <xref:System.Collections.Generic.IList%601></span></span>|<span data-ttu-id="26a61-320">Obecný <xref:System.Collections.Generic.IList%601> indexer</span><span class="sxs-lookup"><span data-stu-id="26a61-320">Generic <xref:System.Collections.Generic.IList%601> indexer</span></span>|<span data-ttu-id="26a61-321">Obecné přidání</span><span class="sxs-lookup"><span data-stu-id="26a61-321">Generic Add</span></span>|
|<span data-ttu-id="26a61-322">Obecněji<xref:System.Collections.Generic.ICollection%601></span><span class="sxs-lookup"><span data-stu-id="26a61-322">Generic <xref:System.Collections.Generic.ICollection%601></span></span>|<span data-ttu-id="26a61-323">Čítače</span><span class="sxs-lookup"><span data-stu-id="26a61-323">Enumerator</span></span>|<span data-ttu-id="26a61-324">Obecné přidání</span><span class="sxs-lookup"><span data-stu-id="26a61-324">Generic Add</span></span>|
|<xref:System.Collections.IList>|<span data-ttu-id="26a61-325"><xref:System.Collections.IList>Indexer</span><span class="sxs-lookup"><span data-stu-id="26a61-325"><xref:System.Collections.IList> Indexer</span></span>|`Add`|
|<span data-ttu-id="26a61-326">Obecněji<xref:System.Collections.Generic.IEnumerable%601></span><span class="sxs-lookup"><span data-stu-id="26a61-326">Generic <xref:System.Collections.Generic.IEnumerable%601></span></span>|`GetEnumerator`|<span data-ttu-id="26a61-327">Nestatická metoda `Add` s názvem, která přijímá jeden parametr příslušného typu (typ obecného parametru nebo jeden z jeho základních typů).</span><span class="sxs-lookup"><span data-stu-id="26a61-327">A non-static method called `Add` that takes one parameter of the appropriate type (the type of the generic parameter or one of its base types).</span></span> <span data-ttu-id="26a61-328">Taková metoda musí existovat, aby serializátor považoval typ kolekce jako kolekci během serializace i deserializace.</span><span class="sxs-lookup"><span data-stu-id="26a61-328">Such a method must exist for the serializer to treat a collection type as a collection during both serialization and deserialization.</span></span>|
|<span data-ttu-id="26a61-329"><xref:System.Collections.IEnumerable>(a tedy <xref:System.Collections.ICollection> z něj odvozeno)</span><span class="sxs-lookup"><span data-stu-id="26a61-329"><xref:System.Collections.IEnumerable> (and thus <xref:System.Collections.ICollection>, which derives from it)</span></span>|`GetEnumerator`|<span data-ttu-id="26a61-330">Nestatická metoda `Add` s názvem, která přijímá jeden parametr typu `Object` .</span><span class="sxs-lookup"><span data-stu-id="26a61-330">A non-static method called `Add` that takes one parameter of type `Object`.</span></span> <span data-ttu-id="26a61-331">Taková metoda musí existovat, aby serializátor považoval typ kolekce jako kolekci během serializace i deserializace.</span><span class="sxs-lookup"><span data-stu-id="26a61-331">Such a method must exist for the serializer to treat a collection type as a collection during both serialization and deserialization.</span></span>|

<span data-ttu-id="26a61-332">V předchozí tabulce jsou uvedena rozhraní kolekce v sestupném pořadí podle priority.</span><span class="sxs-lookup"><span data-stu-id="26a61-332">The preceding table lists collection interfaces in descending order of precedence.</span></span> <span data-ttu-id="26a61-333">To například znamená, že pokud typ implementuje jak i <xref:System.Collections.IList> Obecné <xref:System.Collections.Generic.IEnumerable%601> , kolekce je serializována a deserializována podle <xref:System.Collections.IList> pravidel:</span><span class="sxs-lookup"><span data-stu-id="26a61-333">This means, for example, that if a type implements both <xref:System.Collections.IList> and Generic <xref:System.Collections.Generic.IEnumerable%601>, the collection is serialized and deserialized according to the <xref:System.Collections.IList> rules:</span></span>

- <span data-ttu-id="26a61-334">Při deserializaci jsou všechny kolekce deserializovány nejprve vytvořením instance typu voláním konstruktoru bez parametrů, který musí být přítomen pro serializátor, aby při serializaci a deserializaci považoval typ kolekce za kolekci.</span><span class="sxs-lookup"><span data-stu-id="26a61-334">At deserialization, all collections are deserialized by first creating an instance of the type by calling the parameterless constructor, which must be present for the serializer to treat a collection type as a collection during both serialization and deserialization.</span></span>

- <span data-ttu-id="26a61-335">Je-li stejné obecné rozhraní kolekce implementováno více než jednou (například pokud typ implementuje jak obecné, <xref:System.Collections.Generic.ICollection%601> `Integer` tak obecné <xref:System.Collections.Generic.ICollection%601> z <xref:System.String> ) a není nalezeno žádné rozhraní s vyšší prioritou, kolekce není považována za platnou kolekci.</span><span class="sxs-lookup"><span data-stu-id="26a61-335">If the same generic collection interface is implemented more than once (for example, if a type implements both Generic <xref:System.Collections.Generic.ICollection%601> of `Integer` and Generic <xref:System.Collections.Generic.ICollection%601> of <xref:System.String>) and no higher-precedence interface is found, the collection is not treated as a valid collection.</span></span>

- <span data-ttu-id="26a61-336">Typy kolekcí mohou mít <xref:System.SerializableAttribute> atribut použit a mohou implementovat <xref:System.Runtime.Serialization.ISerializable> rozhraní.</span><span class="sxs-lookup"><span data-stu-id="26a61-336">Collection types can have the <xref:System.SerializableAttribute> attribute applied to them and can implement the <xref:System.Runtime.Serialization.ISerializable> interface.</span></span> <span data-ttu-id="26a61-337">Obě tyto parametry jsou ignorovány.</span><span class="sxs-lookup"><span data-stu-id="26a61-337">Both of these are ignored.</span></span> <span data-ttu-id="26a61-338">Nicméně pokud typ zcela nesplňuje požadavky typu kolekce (například `Add` Metoda chybí), typ není považován za typ kolekce, a proto <xref:System.SerializableAttribute> atribut a <xref:System.Runtime.Serialization.ISerializable> rozhraní slouží k určení, zda lze typ serializovat.</span><span class="sxs-lookup"><span data-stu-id="26a61-338">However, if the type does not fully meet collection type requirements (for example, the `Add` method is missing), the type is not considered a collection type, and thus the <xref:System.SerializableAttribute> attribute and the <xref:System.Runtime.Serialization.ISerializable> interface are used to determine whether the type can be serialized.</span></span>

- <span data-ttu-id="26a61-339">Použití <xref:System.Runtime.Serialization.CollectionDataContractAttribute> atributu na kolekci pro přizpůsobení odebere <xref:System.SerializableAttribute> předchozí nouzový mechanismus.</span><span class="sxs-lookup"><span data-stu-id="26a61-339">Applying the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute to a collection to customize it removes the <xref:System.SerializableAttribute> preceding fallback mechanism.</span></span> <span data-ttu-id="26a61-340">Místo toho, pokud přizpůsobená kolekce nesplňuje požadavky typu kolekce, <xref:System.Runtime.Serialization.InvalidDataContractException> je vyvolána výjimka.</span><span class="sxs-lookup"><span data-stu-id="26a61-340">Instead, if a customized collection does not meet collection type requirements, an <xref:System.Runtime.Serialization.InvalidDataContractException> exception is thrown.</span></span> <span data-ttu-id="26a61-341">Řetězec výjimky často obsahuje informace, které vysvětlují, proč daný typ není považován za platnou kolekci (žádná `Add` metoda, žádný konstruktor bez parametrů atd.), takže je často vhodné použít <xref:System.Runtime.Serialization.CollectionDataContractAttribute> atribut pro účely ladění.</span><span class="sxs-lookup"><span data-stu-id="26a61-341">The exception string often contains information that explains why a given type is not considered a valid collection (no `Add` method, no parameterless constructor, and so on), so it is often useful to apply the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute for debugging purposes.</span></span>

### <a name="collection-naming"></a><span data-ttu-id="26a61-342">Pojmenovávání kolekcí</span><span class="sxs-lookup"><span data-stu-id="26a61-342">Collection Naming</span></span>

<span data-ttu-id="26a61-343">Následuje seznam pravidel pro pojmenovávání kolekcí:</span><span class="sxs-lookup"><span data-stu-id="26a61-343">The following is a list of collection naming rules:</span></span>

- <span data-ttu-id="26a61-344">Výchozí obor názvů pro všechny kontrakty dat kolekce slovníku, stejně jako pro kontrakty dat kolekce, které obsahují primitivní typy, je, `http://schemas.microsoft.com/2003/10/Serialization/Arrays` Pokud není přepsán pomocí oboru názvů.</span><span class="sxs-lookup"><span data-stu-id="26a61-344">The default namespace for all dictionary collection data contracts, as well as for list collection data contracts that contain primitive types, is `http://schemas.microsoft.com/2003/10/Serialization/Arrays` unless overridden using Namespace.</span></span> <span data-ttu-id="26a61-345">Typy, které jsou mapovány na předdefinované typy XSD a také `char` typy, `Timespan` a, `Guid` jsou považovány za primitivní prvky pro tento účel.</span><span class="sxs-lookup"><span data-stu-id="26a61-345">Types that map to built-in XSD types, as well as `char`, `Timespan`, and `Guid` types, are considered primitives for this purpose.</span></span>

- <span data-ttu-id="26a61-346">Výchozí obor názvů pro typy kolekce, které obsahují neprimitivní typy, pokud není přepsán pomocí oboru názvů, je stejný jako obor názvů kontraktu dat typu obsaženého v kolekci.</span><span class="sxs-lookup"><span data-stu-id="26a61-346">The default namespace for collection types that contain non-primitive types, unless it is overridden using Namespace, is the same as the data contract namespace of the type contained in the collection.</span></span>

- <span data-ttu-id="26a61-347">Výchozí název pro kontrakty dat kolekce list, pokud není přepsán pomocí názvu, je řetězec "ArrayOf" v kombinaci s názvem kontraktu dat typu obsaženým v kolekci.</span><span class="sxs-lookup"><span data-stu-id="26a61-347">The default name for list collection data contracts, unless overridden using Name, is the string "ArrayOf" combined with the data contract name of the type contained in the collection.</span></span> <span data-ttu-id="26a61-348">Například název kontraktu dat pro obecný seznam celých čísel je "ArrayOfint".</span><span class="sxs-lookup"><span data-stu-id="26a61-348">For example, the data contract name for a Generic List of Integers is "ArrayOfint".</span></span> <span data-ttu-id="26a61-349">Mějte na paměti, že název kontraktu dat `Object` je "anyType", takže název kontraktu dat neobecných seznamů, jako <xref:System.Collections.ArrayList> je "ArrayOfanyType".</span><span class="sxs-lookup"><span data-stu-id="26a61-349">Keep in mind that the data contract name of `Object` is "anyType", so the data contract name of non-generic lists like <xref:System.Collections.ArrayList> is "ArrayOfanyType".</span></span>

<span data-ttu-id="26a61-350">Výchozí název kontraktů dat kolekce slovníku, pokud není přepsán pomocí `Name` , je řetězec "ArrayOfKeyValueOf" v kombinaci s názvem kontraktu dat typu klíče následovaným názvem kontraktu dat typu hodnoty.</span><span class="sxs-lookup"><span data-stu-id="26a61-350">The default name for dictionary collection data contracts, unless overridden using `Name`, is the string "ArrayOfKeyValueOf" combined with the data contract name of the key type followed by the data contract name of the value type.</span></span> <span data-ttu-id="26a61-351">Například název kontraktu dat pro obecný slovník typu řetězec a celé číslo je "ArrayOfKeyValueOfstringint".</span><span class="sxs-lookup"><span data-stu-id="26a61-351">For example, the data contract name for a Generic Dictionary of String and Integer is "ArrayOfKeyValueOfstringint".</span></span> <span data-ttu-id="26a61-352">Kromě toho, pokud klíč nebo typ hodnoty nejsou primitivní typy, připojí se k názvu hodnota hash oboru názvů kontraktů dat pro obory názvů kontraktů dat.</span><span class="sxs-lookup"><span data-stu-id="26a61-352">Additionally, if either the key or the value types are not primitive types, a namespace hash of the data contract namespaces of the key and value types is appended to the name.</span></span> <span data-ttu-id="26a61-353">Další informace o hodnotách hash oboru názvů najdete v tématu [názvy kontraktů dat](data-contract-names.md).</span><span class="sxs-lookup"><span data-stu-id="26a61-353">For more information about namespace hashes, see [Data Contract Names](data-contract-names.md).</span></span>

<span data-ttu-id="26a61-354">Každý kontrakt dat kolekce slovníku má doprovodnou kontrakt dat, který reprezentuje jednu položku ve slovníku.</span><span class="sxs-lookup"><span data-stu-id="26a61-354">Each dictionary collection data contract has a companion data contract that represents one entry in the dictionary.</span></span> <span data-ttu-id="26a61-355">Jeho název je stejný jako u kontraktu dat slovníku, s výjimkou předpony "ArrayOf" a jeho obor názvů je stejný jako u kontraktu dat slovníku.</span><span class="sxs-lookup"><span data-stu-id="26a61-355">Its name is the same as for the dictionary data contract, except for the "ArrayOf" prefix, and its namespace is the same as for the dictionary data contract.</span></span> <span data-ttu-id="26a61-356">Například kontrakt dat "KeyValueofstringint" ve slovníku "ArrayOfKeyValueOfstringint" představuje jednu položku ve slovníku.</span><span class="sxs-lookup"><span data-stu-id="26a61-356">For example, for the "ArrayOfKeyValueOfstringint" dictionary data contract, the "KeyValueofstringint" data contract represents one entry in the dictionary.</span></span> <span data-ttu-id="26a61-357">Název této kontraktu dat můžete přizpůsobit pomocí `ItemName` vlastnosti, jak je popsáno v následující části.</span><span class="sxs-lookup"><span data-stu-id="26a61-357">You can customize the name of this data contract by using the `ItemName` property, as described in the next section.</span></span>

<span data-ttu-id="26a61-358">Pravidla pojmenování obecných typů, jak je popsáno v tématu [názvy kontraktů dat](data-contract-names.md), se plně vztahují na typy kolekcí; To znamená, že můžete použít složené závorky v názvu k označení parametrů obecného typu.</span><span class="sxs-lookup"><span data-stu-id="26a61-358">Generic type naming rules, as described in [Data Contract Names](data-contract-names.md), fully apply to collection types; that is, you can use curly braces within Name to indicate generic type parameters.</span></span> <span data-ttu-id="26a61-359">Čísla v rámci složených závorek však odkazují na Obecné parametry a nikoli na typy obsažené v kolekci.</span><span class="sxs-lookup"><span data-stu-id="26a61-359">However, numbers within the braces refer to generic parameters and not types contained within the collection.</span></span>

## <a name="collection-customization"></a><span data-ttu-id="26a61-360">Přizpůsobení kolekce</span><span class="sxs-lookup"><span data-stu-id="26a61-360">Collection Customization</span></span>

<span data-ttu-id="26a61-361">Následující použití <xref:System.Runtime.Serialization.CollectionDataContractAttribute> atributu je zakázáno a výsledkem je <xref:System.Runtime.Serialization.InvalidDataContractException> výjimka:</span><span class="sxs-lookup"><span data-stu-id="26a61-361">The following uses of the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute are forbidden and result in an <xref:System.Runtime.Serialization.InvalidDataContractException> exception:</span></span>

- <span data-ttu-id="26a61-362">Použití <xref:System.Runtime.Serialization.DataContractAttribute> atributu na typ, na který byl <xref:System.Runtime.Serialization.CollectionDataContractAttribute> atribut použit, nebo na jeden z jeho odvozených typů.</span><span class="sxs-lookup"><span data-stu-id="26a61-362">Applying the <xref:System.Runtime.Serialization.DataContractAttribute> attribute to a type to which the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute has been applied, or to one of its derived types.</span></span>

- <span data-ttu-id="26a61-363">Použití <xref:System.Runtime.Serialization.CollectionDataContractAttribute> atributu na typ, který implementuje <xref:System.Xml.Serialization.IXmlSerializable> rozhraní.</span><span class="sxs-lookup"><span data-stu-id="26a61-363">Applying the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute to a type that implements the <xref:System.Xml.Serialization.IXmlSerializable> interface.</span></span>

- <span data-ttu-id="26a61-364">Použití <xref:System.Runtime.Serialization.CollectionDataContractAttribute> atributu pro typ, který není kolekce.</span><span class="sxs-lookup"><span data-stu-id="26a61-364">Applying the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute to a non-collection type.</span></span>

- <span data-ttu-id="26a61-365">Pokus o nastavení <xref:System.Runtime.Serialization.CollectionDataContractAttribute.KeyName%2A> nebo <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ValueName%2A> <xref:System.Runtime.Serialization.CollectionDataContractAttribute> použití atributu použitého pro jiný typ než slovník.</span><span class="sxs-lookup"><span data-stu-id="26a61-365">Attempting to set <xref:System.Runtime.Serialization.CollectionDataContractAttribute.KeyName%2A> or <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ValueName%2A> on a <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute applied to a non-dictionary type.</span></span>

### <a name="polymorphism-rules"></a><span data-ttu-id="26a61-366">Pravidla polymorfismu</span><span class="sxs-lookup"><span data-stu-id="26a61-366">Polymorphism Rules</span></span>

<span data-ttu-id="26a61-367">Jak už jsme uvedli, přizpůsobení kolekcí pomocí <xref:System.Runtime.Serialization.CollectionDataContractAttribute> atributu může narušit zaměnitelné kolekce.</span><span class="sxs-lookup"><span data-stu-id="26a61-367">As previously mentioned, customizing collections by using the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute may interfere with collection interchangeability.</span></span> <span data-ttu-id="26a61-368">Dva přizpůsobené typy kolekce lze považovat za ekvivalentní pouze v případě, že se shodují jejich název, obor názvů, název položky a také názvy klíčů a hodnot (Pokud se jedná o kolekce slovníku).</span><span class="sxs-lookup"><span data-stu-id="26a61-368">Two customized collection types can only be considered equivalent if their name, namespace, item name, as well as key and value names (if these are dictionary collections) match.</span></span>

<span data-ttu-id="26a61-369">Z důvodu přizpůsobení je možné neúmyslně použít jeden kontrakt dat kolekce, kde je očekáván další.</span><span class="sxs-lookup"><span data-stu-id="26a61-369">Due to customizations, it is possible to inadvertently use one collection data contract where another is expected.</span></span> <span data-ttu-id="26a61-370">To by mělo být zabráněno.</span><span class="sxs-lookup"><span data-stu-id="26a61-370">This should be avoided.</span></span> <span data-ttu-id="26a61-371">Podívejte se na následující typy.</span><span class="sxs-lookup"><span data-stu-id="26a61-371">See the following types.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#11](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#11)]
[!code-vb[c_collection_types_in_data_contracts#11](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#11)]

<span data-ttu-id="26a61-372">V takovém případě `Marks1` může být přiřazena instance `testMarks` .</span><span class="sxs-lookup"><span data-stu-id="26a61-372">In this case, an instance of `Marks1` can be assigned to `testMarks`.</span></span> <span data-ttu-id="26a61-373">Nicméně `Marks2` by neměl být použit, protože jeho kontrakt dat není považován za ekvivalent `IList<int>` kontraktu dat.</span><span class="sxs-lookup"><span data-stu-id="26a61-373">However, `Marks2` should not be used because its data contract is not considered equivalent to the `IList<int>` data contract.</span></span> <span data-ttu-id="26a61-374">Název kontraktu dat je "Marks2", nikoli "ArrayOfint" a název opakujícího se elementu je " \<mark> ", a nikoli " \<int> ".</span><span class="sxs-lookup"><span data-stu-id="26a61-374">The data contract name is "Marks2" and not "ArrayOfint", and the repeating element name is "\<mark>" and not "\<int>".</span></span>

<span data-ttu-id="26a61-375">Pravidla v následující tabulce platí pro polymorfní přiřazení kolekcí.</span><span class="sxs-lookup"><span data-stu-id="26a61-375">The rules in the following table apply to polymorphic assignment of collections.</span></span>

|<span data-ttu-id="26a61-376">Deklarovaný typ</span><span class="sxs-lookup"><span data-stu-id="26a61-376">Declared type</span></span>|<span data-ttu-id="26a61-377">Přiřazení nepřizpůsobené kolekce</span><span class="sxs-lookup"><span data-stu-id="26a61-377">Assigning a non-customized collection</span></span>|<span data-ttu-id="26a61-378">Přiřazení přizpůsobené kolekce</span><span class="sxs-lookup"><span data-stu-id="26a61-378">Assigning a customized collection</span></span>|
|-------------------|--------------------------------------------|---------------------------------------|
|<span data-ttu-id="26a61-379">Objekt</span><span class="sxs-lookup"><span data-stu-id="26a61-379">Object</span></span>|<span data-ttu-id="26a61-380">Název kontraktu je serializován.</span><span class="sxs-lookup"><span data-stu-id="26a61-380">Contract name is serialized.</span></span>|<span data-ttu-id="26a61-381">Název kontraktu je serializován.</span><span class="sxs-lookup"><span data-stu-id="26a61-381">Contract name is serialized.</span></span><br /><br /> <span data-ttu-id="26a61-382">Vlastní nastavení se používá.</span><span class="sxs-lookup"><span data-stu-id="26a61-382">Customization is used.</span></span>|
|<span data-ttu-id="26a61-383">Rozhraní kolekce</span><span class="sxs-lookup"><span data-stu-id="26a61-383">Collection interface</span></span>|<span data-ttu-id="26a61-384">Název kontraktu není serializován.</span><span class="sxs-lookup"><span data-stu-id="26a61-384">Contract name is not serialized.</span></span>|<span data-ttu-id="26a61-385">Název kontraktu není serializován.</span><span class="sxs-lookup"><span data-stu-id="26a61-385">Contract name is not serialized.</span></span><br /><br /> <span data-ttu-id="26a61-386">Vlastní nastavení se nepoužívá.\*</span><span class="sxs-lookup"><span data-stu-id="26a61-386">Customization is not used.\*</span></span>|
|<span data-ttu-id="26a61-387">Přizpůsobená kolekce</span><span class="sxs-lookup"><span data-stu-id="26a61-387">Non-customized collection</span></span>|<span data-ttu-id="26a61-388">Název kontraktu není serializován.</span><span class="sxs-lookup"><span data-stu-id="26a61-388">Contract name is not serialized.</span></span>|<span data-ttu-id="26a61-389">Název kontraktu je serializován.</span><span class="sxs-lookup"><span data-stu-id="26a61-389">Contract name is serialized.</span></span><br /><br /> <span data-ttu-id="26a61-390">Používá se přizpůsobení. \* \*</span><span class="sxs-lookup"><span data-stu-id="26a61-390">Customization is used.\*\*</span></span>|
|<span data-ttu-id="26a61-391">Přizpůsobená kolekce</span><span class="sxs-lookup"><span data-stu-id="26a61-391">Customized collection</span></span>|<span data-ttu-id="26a61-392">Název kontraktu je serializován.</span><span class="sxs-lookup"><span data-stu-id="26a61-392">Contract name is serialized.</span></span> <span data-ttu-id="26a61-393">Vlastní nastavení se nepoužívá.\*\*</span><span class="sxs-lookup"><span data-stu-id="26a61-393">Customization is not used.\*\*</span></span>|<span data-ttu-id="26a61-394">Název kontraktu je serializován.</span><span class="sxs-lookup"><span data-stu-id="26a61-394">Contract name is serialized.</span></span><br /><br /> <span data-ttu-id="26a61-395">Používá se přizpůsobení přiřazeného typu.\*\*</span><span class="sxs-lookup"><span data-stu-id="26a61-395">Customization of the assigned type is used.\*\*</span></span>|

<span data-ttu-id="26a61-396">\*U <xref:System.Runtime.Serialization.NetDataContractSerializer> třídy se v tomto případě používá přizpůsobení.</span><span class="sxs-lookup"><span data-stu-id="26a61-396">\*With the <xref:System.Runtime.Serialization.NetDataContractSerializer> class, customization is used in this case.</span></span> <span data-ttu-id="26a61-397"><xref:System.Runtime.Serialization.NetDataContractSerializer>Třída také v tomto případě serializace skutečný název typu, takže deserializace funguje podle očekávání.</span><span class="sxs-lookup"><span data-stu-id="26a61-397">The <xref:System.Runtime.Serialization.NetDataContractSerializer> class also serializes the actual type name in this case, so deserialization works as expected.</span></span>

<span data-ttu-id="26a61-398">\*\*Tyto případy mají za následek neplatné instance schématu, takže by se měly vyhnout.</span><span class="sxs-lookup"><span data-stu-id="26a61-398">\*\*These cases result in schema-invalid instances and thus should be avoided.</span></span>

<span data-ttu-id="26a61-399">V případech, kdy je název kontraktu serializován, by měl být přiřazený typ kolekce v seznamu známých typů.</span><span class="sxs-lookup"><span data-stu-id="26a61-399">In the cases where the contract name is serialized, the assigned collection type should be in the known types list.</span></span> <span data-ttu-id="26a61-400">Opak je také true: v případech, kde není název serializován, není nutné přidat typ do seznamu známých typů.</span><span class="sxs-lookup"><span data-stu-id="26a61-400">The opposite is also true: in the cases where the name is not serialized, adding the type to the known types list is not required.</span></span>

<span data-ttu-id="26a61-401">Pole odvozeného typu lze přiřadit poli základního typu.</span><span class="sxs-lookup"><span data-stu-id="26a61-401">An array of a derived type can be assigned to an array of a base type.</span></span> <span data-ttu-id="26a61-402">V tomto případě je název kontraktu pro odvozený typ serializován pro každý opakující se element.</span><span class="sxs-lookup"><span data-stu-id="26a61-402">In this case, the contract name for the derived type is serialized for each repeating element.</span></span> <span data-ttu-id="26a61-403">Například pokud typ `Book` je odvozen z typu `LibraryItem` , můžete přiřadit pole `Book` k poli `LibraryItem` .</span><span class="sxs-lookup"><span data-stu-id="26a61-403">For example, if a type `Book` derives from the type `LibraryItem`, you can assign an array of `Book` to an array of `LibraryItem`.</span></span> <span data-ttu-id="26a61-404">To se nevztahuje na jiné typy kolekcí.</span><span class="sxs-lookup"><span data-stu-id="26a61-404">This does not apply to other collection types.</span></span> <span data-ttu-id="26a61-405">Například nemůžete přiřadit `Generic List of Book` k `Generic List of LibraryItem` .</span><span class="sxs-lookup"><span data-stu-id="26a61-405">For example, you cannot assign a `Generic List of Book` to a `Generic List of LibraryItem`.</span></span> <span data-ttu-id="26a61-406">Můžete však přiřadit `Generic List of LibraryItem` instance, které obsahují `Book` instance.</span><span class="sxs-lookup"><span data-stu-id="26a61-406">You can, however, assign a `Generic List of LibraryItem` that contains `Book` instances.</span></span> <span data-ttu-id="26a61-407">V poli i v případě, že se jedná o případ bez pole, `Book` by měl být v seznamu známých typů.</span><span class="sxs-lookup"><span data-stu-id="26a61-407">In both the array and the non-array case, `Book` should be in the known types list.</span></span>

## <a name="collections-and-object-reference-preservation"></a><span data-ttu-id="26a61-408">Zachování kolekcí a objektů odkazů na objekty</span><span class="sxs-lookup"><span data-stu-id="26a61-408">Collections and Object Reference Preservation</span></span>

<span data-ttu-id="26a61-409">Když serializátor funguje v režimu, kde zachovává odkazy na objekty, vztahuje se na kolekce i zachování odkazů na objekty.</span><span class="sxs-lookup"><span data-stu-id="26a61-409">When a serializer functions in a mode where it preserves object references, object reference preservation also applies to collections.</span></span> <span data-ttu-id="26a61-410">Konkrétně je zachována identita objektu pro celou kolekci i pro jednotlivé položky obsažené v kolekcích.</span><span class="sxs-lookup"><span data-stu-id="26a61-410">Specifically, object identity is preserved for both entire collections and individual items contained in collections.</span></span> <span data-ttu-id="26a61-411">U slovníků je identita objektu zachovaná pro objekty dvojice klíč/hodnota a jednotlivé objekty klíče a hodnoty.</span><span class="sxs-lookup"><span data-stu-id="26a61-411">For dictionaries, object identity is preserved both for the key/value pair objects and the individual key and value objects.</span></span>

## <a name="see-also"></a><span data-ttu-id="26a61-412">Viz také</span><span class="sxs-lookup"><span data-stu-id="26a61-412">See also</span></span>

- <xref:System.Runtime.Serialization.CollectionDataContractAttribute>
