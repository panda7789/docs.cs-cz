---
title: Typy XML a ADO.NET v kontraktech dat
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
ms.assetid: c2ce8461-3c15-4c41-8c81-1cb78f5b59a6
ms.openlocfilehash: 975d4f4f37bbbd895cab4e87686f15017e90f382
ms.sourcegitcommit: cdb295dd1db589ce5169ac9ff096f01fd0c2da9d
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 06/09/2020
ms.locfileid: "84600072"
---
# <a name="xml-and-adonet-types-in-data-contracts"></a><span data-ttu-id="b91c2-102">Typy XML a ADO.NET v kontraktech dat</span><span class="sxs-lookup"><span data-stu-id="b91c2-102">XML and ADO.NET Types in Data Contracts</span></span>
<span data-ttu-id="b91c2-103">Model kontraktu dat Windows Communication Foundation (WCF) podporuje určité typy, které přímo reprezentují XML.</span><span class="sxs-lookup"><span data-stu-id="b91c2-103">The Windows Communication Foundation (WCF) data contract model supports certain types that represent XML directly.</span></span> <span data-ttu-id="b91c2-104">Pokud jsou tyto typy serializovány do XML, serializátor zapisuje obsah XML těchto typů bez dalšího zpracování.</span><span class="sxs-lookup"><span data-stu-id="b91c2-104">When these types are serialized to XML, the serializer writes out the XML contents of these types without any further processing.</span></span> <span data-ttu-id="b91c2-105">Podporované typy jsou <xref:System.Xml.XmlElement> , pole <xref:System.Xml.XmlNode> (ale ne `XmlNode` samotného typu) a také typy, které implementují <xref:System.Xml.Serialization.IXmlSerializable> .</span><span class="sxs-lookup"><span data-stu-id="b91c2-105">Supported types are <xref:System.Xml.XmlElement>, arrays of <xref:System.Xml.XmlNode> (but not the `XmlNode` type itself), as well as types that implement <xref:System.Xml.Serialization.IXmlSerializable>.</span></span> <span data-ttu-id="b91c2-106"><xref:System.Data.DataSet>Typ a a <xref:System.Data.DataTable> také typové datové sady jsou běžně používány při programování databáze.</span><span class="sxs-lookup"><span data-stu-id="b91c2-106">The <xref:System.Data.DataSet> and <xref:System.Data.DataTable> type, as well as typed datasets, are commonly used in database programming.</span></span> <span data-ttu-id="b91c2-107">Tyto typy implementují `IXmlSerializable` rozhraní a jsou proto serializovatelné v modelu kontraktu dat.</span><span class="sxs-lookup"><span data-stu-id="b91c2-107">These types implement the `IXmlSerializable` interface and are therefore serializable in the data contract model.</span></span> <span data-ttu-id="b91c2-108">Některé zvláštní okolnosti pro tyto typy jsou uvedené na konci tohoto tématu.</span><span class="sxs-lookup"><span data-stu-id="b91c2-108">Some special considerations for these types are listed at the end of this topic.</span></span>  
  
## <a name="xml-types"></a><span data-ttu-id="b91c2-109">Typy XML</span><span class="sxs-lookup"><span data-stu-id="b91c2-109">XML Types</span></span>  
  
### <a name="xml-element"></a><span data-ttu-id="b91c2-110">XML – element</span><span class="sxs-lookup"><span data-stu-id="b91c2-110">Xml Element</span></span>  
 <span data-ttu-id="b91c2-111">`XmlElement`Typ je serializován pomocí jeho obsahu XML.</span><span class="sxs-lookup"><span data-stu-id="b91c2-111">The `XmlElement` type is serialized using its XML contents.</span></span> <span data-ttu-id="b91c2-112">Například pomocí následujícího typu.</span><span class="sxs-lookup"><span data-stu-id="b91c2-112">For example, using the following type.</span></span>  
  
 [!code-csharp[DataContractAttribute#4](../../../../samples/snippets/csharp/VS_Snippets_CFX/datacontractattribute/cs/overview.cs#4)]
 [!code-vb[DataContractAttribute#4](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/datacontractattribute/vb/overview.vb#4)]  
  
 <span data-ttu-id="b91c2-113">To je serializováno do XML následujícím způsobem:</span><span class="sxs-lookup"><span data-stu-id="b91c2-113">This is serialized to XML as follows:</span></span>  
  
```xml  
<MyDataContract xmlns="http://schemas.contoso.com">  
    <myDataMember>  
        <myElement xmlns="" myAttribute="myValue">  
            myContents  
        </myElement>  
    </myDataMember>  
</MyDataContract>  
```  
  
 <span data-ttu-id="b91c2-114">Všimněte si, že prvek datového člena obálky `<myDataMember>` je stále přítomen.</span><span class="sxs-lookup"><span data-stu-id="b91c2-114">Notice that a wrapper data member element `<myDataMember>` is still present.</span></span> <span data-ttu-id="b91c2-115">Neexistuje žádný způsob, jak tento prvek odebrat v modelu kontraktu dat.</span><span class="sxs-lookup"><span data-stu-id="b91c2-115">There is no way of removing this element in the data contract model.</span></span> <span data-ttu-id="b91c2-116">Serializátory, které zpracovávají tento model ( <xref:System.Runtime.Serialization.DataContractSerializer> a <xref:System.Runtime.Serialization.NetDataContractSerializer> ), mohou do tohoto prvku obálky generovat speciální atributy.</span><span class="sxs-lookup"><span data-stu-id="b91c2-116">The serializers that handle this model (the <xref:System.Runtime.Serialization.DataContractSerializer> and <xref:System.Runtime.Serialization.NetDataContractSerializer>) may emit special attributes into this wrapper element.</span></span> <span data-ttu-id="b91c2-117">Tyto atributy zahrnují standardní atribut instance schématu XML "Nil" (povoluje se `XmlElement` `null` ) a atribut "Type" (umožňující `XmlElement` použití polymorfní).</span><span class="sxs-lookup"><span data-stu-id="b91c2-117">These attributes include the standard XML Schema Instance "nil" attribute (allowing the `XmlElement` to be `null`) and the "type" attribute (allowing `XmlElement` to be used polymorphically).</span></span> <span data-ttu-id="b91c2-118">Následující atributy XML jsou také specifické pro WCF: "ID", "ref", "Type" a "Assembly".</span><span class="sxs-lookup"><span data-stu-id="b91c2-118">Also, the following XML attributes are specific to WCF: "Id", "Ref", "Type" and "Assembly".</span></span> <span data-ttu-id="b91c2-119">Tyto atributy mohou být vygenerovány pro podporu pomocí `XmlElement` s povoleným režimem uchování grafu objektů nebo s <xref:System.Runtime.Serialization.NetDataContractSerializer> .</span><span class="sxs-lookup"><span data-stu-id="b91c2-119">These attributes may be emitted to support using the `XmlElement` with the object graph preservation mode enabled, or with the <xref:System.Runtime.Serialization.NetDataContractSerializer>.</span></span> <span data-ttu-id="b91c2-120">(Další informace o režimu uchování grafu objektů naleznete v tématu [serializace a deserializace](serialization-and-deserialization.md).)</span><span class="sxs-lookup"><span data-stu-id="b91c2-120">(For more information about the object graph preservation mode, see [Serialization and Deserialization](serialization-and-deserialization.md).)</span></span>  
  
 <span data-ttu-id="b91c2-121">Pole nebo kolekce `XmlElement` jsou povoleny a jsou zpracovávány jako jiné pole nebo kolekce.</span><span class="sxs-lookup"><span data-stu-id="b91c2-121">Arrays or collections of `XmlElement` are allowed and are handled as any other array or collection.</span></span> <span data-ttu-id="b91c2-122">To znamená, že je k dispozici element obálky pro celou kolekci a samostatný prvek obálky (podobný `<myDataMember>` v předchozím příkladu) pro každý `XmlElement` v poli.</span><span class="sxs-lookup"><span data-stu-id="b91c2-122">That is, there is a wrapper element for the entire collection, and a separate wrapper element (similar to `<myDataMember>` in the preceding example) for each `XmlElement` in the array.</span></span>  
  
 <span data-ttu-id="b91c2-123">Při deserializaci `XmlElement` vytvoří deserializátor z příchozího XML.</span><span class="sxs-lookup"><span data-stu-id="b91c2-123">On deserialization, an `XmlElement` is created by the deserializer from the incoming XML.</span></span> <span data-ttu-id="b91c2-124">Deserializace poskytne platnou nadřazenou položku <xref:System.Xml.XmlDocument> .</span><span class="sxs-lookup"><span data-stu-id="b91c2-124">A valid parent <xref:System.Xml.XmlDocument> is provided by the deserializer.</span></span>  
  
 <span data-ttu-id="b91c2-125">Ujistěte se, že fragment XML, který je deserializován na, `XmlElement` definuje všechny předpony, které používá a nespoléhá na jakékoli definice předpony z nadřazených prvků.</span><span class="sxs-lookup"><span data-stu-id="b91c2-125">Make sure that the XML fragment that is deserialized to an `XmlElement` defines all prefixes that it uses and does not rely on any prefix definitions from ancestor elements.</span></span> <span data-ttu-id="b91c2-126">Jedná se o problém pouze v případě, že používáte `DataContractSerializer` pro přístup k XML z jiného zdroje (nejedná se o `DataContractSerializer` ).</span><span class="sxs-lookup"><span data-stu-id="b91c2-126">This is a concern only when using the `DataContractSerializer` to access XML from a different (non-`DataContractSerializer`) source.</span></span>  
  
 <span data-ttu-id="b91c2-127">Při použití s `DataContractSerializer` , `XmlElement` může být přiřazena polymorfní, ale pouze pro datový člen typu <xref:System.Object> .</span><span class="sxs-lookup"><span data-stu-id="b91c2-127">When used with the `DataContractSerializer`, the `XmlElement` may be assigned polymorphically, but only to a data member of type <xref:System.Object>.</span></span> <span data-ttu-id="b91c2-128">I když to implementuje <xref:System.Collections.IEnumerable> , `XmlElement` nelze použít jako typ kolekce a nelze jej přiřadit <xref:System.Collections.IEnumerable> datovému členu.</span><span class="sxs-lookup"><span data-stu-id="b91c2-128">Even though it implements <xref:System.Collections.IEnumerable>, an `XmlElement` cannot be used as a collection type and cannot be assigned to an <xref:System.Collections.IEnumerable> data member.</span></span> <span data-ttu-id="b91c2-129">Stejně jako u všech polymorfních přiřazení `DataContractSerializer` emituje název kontraktu dat ve výsledném souboru XML – v tomto případě je to "XmlElement" v http://schemas.datacontract.org/2004/07/System.Xml oboru názvů "".</span><span class="sxs-lookup"><span data-stu-id="b91c2-129">As with all polymorphic assignments, the `DataContractSerializer` emits the data contract name in the resulting XML – in this case, it is "XmlElement" in the "http://schemas.datacontract.org/2004/07/System.Xml" namespace.</span></span>  
  
 <span data-ttu-id="b91c2-130">S `NetDataContractSerializer` , je podporováno jakékoli platné polymorfní přiřazení `XmlElement` (do `Object` nebo `IEnumerable` ).</span><span class="sxs-lookup"><span data-stu-id="b91c2-130">With the `NetDataContractSerializer`, any valid polymorphic assignment of `XmlElement` (to `Object` or `IEnumerable`) is supported.</span></span>  
  
 <span data-ttu-id="b91c2-131">Nepokoušejte se použít žádný ze serializátorů s typy odvozenými z, bez `XmlElement` ohledu na to, zda jsou přiřazeny polymorfní nebo ne.</span><span class="sxs-lookup"><span data-stu-id="b91c2-131">Do not attempt to use either of the serializers with types derived from `XmlElement`, whether they are assigned polymorphically or not.</span></span>  
  
### <a name="array-of-xmlnode"></a><span data-ttu-id="b91c2-132">Pole XmlNode</span><span class="sxs-lookup"><span data-stu-id="b91c2-132">Array of XmlNode</span></span>  
 <span data-ttu-id="b91c2-133">Použití polí <xref:System.Xml.XmlNode> je velmi podobné použití `XmlElement` .</span><span class="sxs-lookup"><span data-stu-id="b91c2-133">Using arrays of <xref:System.Xml.XmlNode> is very similar to using `XmlElement`.</span></span> <span data-ttu-id="b91c2-134">Použití polí z `XmlNode` poskytuje větší flexibilitu než použití `XmlElement` .</span><span class="sxs-lookup"><span data-stu-id="b91c2-134">Using arrays of `XmlNode` gives you more flexibility than using `XmlElement`.</span></span> <span data-ttu-id="b91c2-135">Do prvku obtékání datového člena můžete napsat více prvků.</span><span class="sxs-lookup"><span data-stu-id="b91c2-135">You can write multiple elements inside the data member wrapping element.</span></span> <span data-ttu-id="b91c2-136">Můžete také vložit obsah jiný než prvky uvnitř elementu obtékání datového členu, jako jsou komentáře XML.</span><span class="sxs-lookup"><span data-stu-id="b91c2-136">You can also inject content other than elements inside of the data member wrapping element, such as XML comments.</span></span> <span data-ttu-id="b91c2-137">Nakonec můžete vložit atributy do prvku členu data zalamování.</span><span class="sxs-lookup"><span data-stu-id="b91c2-137">Finally, you can put attributes into the wrapping data member element.</span></span> <span data-ttu-id="b91c2-138">To lze dosáhnout naplněním pole `XmlNode` se specifickými odvozenými třídami `XmlNode` , jako je <xref:System.Xml.XmlAttribute> například `XmlElement` nebo <xref:System.Xml.XmlComment> .</span><span class="sxs-lookup"><span data-stu-id="b91c2-138">All this can be achieved by populating the array of `XmlNode` with specific derived classes of `XmlNode` such as <xref:System.Xml.XmlAttribute>, `XmlElement` or <xref:System.Xml.XmlComment>.</span></span> <span data-ttu-id="b91c2-139">Například pomocí následujícího typu.</span><span class="sxs-lookup"><span data-stu-id="b91c2-139">For example, using the following type.</span></span>  
  
 [!code-csharp[DataContractAttribute#5](../../../../samples/snippets/csharp/VS_Snippets_CFX/datacontractattribute/cs/overview.cs#5)]
 [!code-vb[DataContractAttribute#5](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/datacontractattribute/vb/overview.vb#5)]  
  
 <span data-ttu-id="b91c2-140">Při serializaci je výsledný kód XML podobný následujícímu kódu.</span><span class="sxs-lookup"><span data-stu-id="b91c2-140">When serialized, the resulting XML is similar to the following code.</span></span>  
  
```xml  
<MyDataContract xmlns="http://schemas.contoso.com">  
  <myDataMember myAttribute="myValue">  
     <!--myComment-->  
     <myElement xmlns="" myAttribute="myValue">  
 myContents  
     </myElement>  
     <myElement xmlns="" myAttribute="myValue">  
       myContents  
     </myElement>  
  </myDataMember>  
</MyDataContract>  
```  
  
 <span data-ttu-id="b91c2-141">Všimněte si, že prvek obálky datového člena `<myDataMember>` obsahuje atribut, komentář a dva prvky.</span><span class="sxs-lookup"><span data-stu-id="b91c2-141">Note that the data member wrapper element `<myDataMember>` contains an attribute, a comment, and two elements.</span></span> <span data-ttu-id="b91c2-142">Jedná se o čtyři `XmlNode` instance, které byly serializovány.</span><span class="sxs-lookup"><span data-stu-id="b91c2-142">These are the four `XmlNode` instances that were serialized.</span></span>  
  
 <span data-ttu-id="b91c2-143">Pole `XmlNode` , jehož výsledkem je neplatný kód XML, nelze serializovat.</span><span class="sxs-lookup"><span data-stu-id="b91c2-143">An array of `XmlNode` that results in invalid XML cannot be serialized.</span></span> <span data-ttu-id="b91c2-144">Například pole dvou `XmlNode` instancí, kde je první z nich `XmlElement` , a druhý je <xref:System.Xml.XmlAttribute> neplatný, protože tato sekvence neodpovídá žádné platné instanci XML (k dispozici není místo pro připojení atributu).</span><span class="sxs-lookup"><span data-stu-id="b91c2-144">For example, an array of two `XmlNode` instances where the first one is an `XmlElement` and the second one is an <xref:System.Xml.XmlAttribute> is invalid, because this sequence does not correspond to any valid XML instance (there is no place to attach the attribute to).</span></span>  
  
 <span data-ttu-id="b91c2-145">Při deserializaci pole `XmlNode` uzlů se vytvoří uzly a naplní se informace z příchozího XML.</span><span class="sxs-lookup"><span data-stu-id="b91c2-145">On deserialization of an array of `XmlNode`, nodes are created and populated with information from the incoming XML.</span></span> <span data-ttu-id="b91c2-146">Deserializace poskytne platnou nadřazenou položku <xref:System.Xml.XmlDocument> .</span><span class="sxs-lookup"><span data-stu-id="b91c2-146">A valid parent <xref:System.Xml.XmlDocument> is provided by the deserializer.</span></span> <span data-ttu-id="b91c2-147">Všechny uzly jsou deserializovány, včetně všech atributů na prvku souhrnný datový člen, ale s výjimkou atributů, které jsou umístěny v rámci služby WCF serializátory (například atributy používané pro indikaci polymorfního přiřazení).</span><span class="sxs-lookup"><span data-stu-id="b91c2-147">All nodes are deserialized, including any attributes on the wrapper data member element, but excluding the attributes placed there by the WCF serializers (such as the attributes used to indicate polymorphic assignment).</span></span> <span data-ttu-id="b91c2-148">Upozornění na definování všech předpon oboru názvů v fragmentu XML se vztahuje na deserializaci polí `XmlNode` stejně jako na deserializaci `XmlElement` .</span><span class="sxs-lookup"><span data-stu-id="b91c2-148">The caveat about defining all namespace prefixes in the XML fragment applies to the deserialization of arrays of `XmlNode` just like it does to deserializing `XmlElement`.</span></span>  
  
 <span data-ttu-id="b91c2-149">Při použití serializátorů se zapnutým uchováváním grafu objektů je rovnost objektů zachovaná pouze na úrovni `XmlNode` polí, nikoli v jednotlivých `XmlNode` instancích.</span><span class="sxs-lookup"><span data-stu-id="b91c2-149">When using the serializers with object graph preservation turned on, object equality is only preserved on the level of `XmlNode` arrays, not individual `XmlNode` instances.</span></span>  
  
 <span data-ttu-id="b91c2-150">Nepokoušejte se serializovat pole, `XmlNode` kde jeden nebo více uzlů je nastaveno na `null` .</span><span class="sxs-lookup"><span data-stu-id="b91c2-150">Do not attempt to serialize an array of `XmlNode` where one or more of the nodes is set to `null`.</span></span> <span data-ttu-id="b91c2-151">Je povoleno, aby celý člen pole byl `null` , ale ne pro všechny uživatele `XmlNode` obsažené v poli.</span><span class="sxs-lookup"><span data-stu-id="b91c2-151">It is permitted for the entire array member to be `null`, but not for any individual `XmlNode` contained in the array.</span></span> <span data-ttu-id="b91c2-152">Pokud je celý člen pole null, prvek datového členu obálky obsahuje speciální atribut, který označuje, že je null.</span><span class="sxs-lookup"><span data-stu-id="b91c2-152">If the entire array member is null, the wrapper data member element contains a special attribute that indicates that it is null.</span></span> <span data-ttu-id="b91c2-153">Při deserializaci se celý člen pole také stal hodnotou null.</span><span class="sxs-lookup"><span data-stu-id="b91c2-153">On deserialization, the entire array member also becomes null.</span></span>  
  
 <span data-ttu-id="b91c2-154">`XmlNode`Serializátor je speciálně ošetřená pouze regulárními poli.</span><span class="sxs-lookup"><span data-stu-id="b91c2-154">Only regular arrays of `XmlNode` are treated specially by the serializer.</span></span> <span data-ttu-id="b91c2-155">Datové členy deklarované jako jiné typy kolekce, které obsahují `XmlNode` nebo datové členy deklarované jako pole typů odvozených z `XmlNode` , nejsou zpracovány speciálně.</span><span class="sxs-lookup"><span data-stu-id="b91c2-155">Data members declared as other collection types that contain `XmlNode`, or data members declared as arrays of types derived from `XmlNode`, are not treated specially.</span></span> <span data-ttu-id="b91c2-156">Proto jsou obvykle neserializovatelné, pokud také nesplňují jedno z dalších kritérií pro serializaci.</span><span class="sxs-lookup"><span data-stu-id="b91c2-156">Thus, they are normally not serializable unless they also meet one of the other criteria for serializing.</span></span>  
  
 <span data-ttu-id="b91c2-157">Pole nebo kolekce polí pro `XmlNode` jsou povoleny.</span><span class="sxs-lookup"><span data-stu-id="b91c2-157">Arrays or collections of arrays of `XmlNode` are allowed.</span></span> <span data-ttu-id="b91c2-158">K dispozici je prvek obálky pro celou kolekci a samostatný prvek obálky (podobně jako `<myDataMember>` v předchozím příkladu) pro každé pole `XmlNode` ve vnějším poli nebo kolekci.</span><span class="sxs-lookup"><span data-stu-id="b91c2-158">There is a wrapper element for the entire collection, and a separate wrapper element (similar to `<myDataMember>` in the preceding example) for each array of `XmlNode` in the outer array or collection.</span></span>  
  
 <span data-ttu-id="b91c2-159">Naplnění datového člena typu <xref:System.Array> `Object` nebo `Array` `IEnumerable` s `XmlNode` instancemi nevede k tomu, že datový člen bude považován za `Array` `XmlNode` instance.</span><span class="sxs-lookup"><span data-stu-id="b91c2-159">Populating a data member of type <xref:System.Array> of `Object` or `Array` of `IEnumerable` with `XmlNode` instances does not result in the data member being treated as an `Array` of `XmlNode` instances.</span></span> <span data-ttu-id="b91c2-160">Každý člen pole je serializován samostatně.</span><span class="sxs-lookup"><span data-stu-id="b91c2-160">Each array member is serialized separately.</span></span>  
  
 <span data-ttu-id="b91c2-161">Při použití s `DataContractSerializer` polem lze s poli `XmlNode` přiřadit polymorfní, ale pouze pro datový člen typu `Object` .</span><span class="sxs-lookup"><span data-stu-id="b91c2-161">When used with the `DataContractSerializer`, arrays of `XmlNode` can be assigned polymorphically, but only to a data member of type `Object`.</span></span> <span data-ttu-id="b91c2-162">I když to implementuje `IEnumerable` , pole `XmlNode` nemůže být použito jako typ kolekce a musí být přiřazeno `IEnumerable` datovému členu.</span><span class="sxs-lookup"><span data-stu-id="b91c2-162">Even though it implements `IEnumerable`, an array of `XmlNode` cannot be used as a collection type and be assigned to an `IEnumerable` data member.</span></span> <span data-ttu-id="b91c2-163">Stejně jako u všech polymorfních přiřazení `DataContractSerializer` vygeneruje název kontraktu dat ve výsledném souboru XML – v tomto případě je to "ArrayOfXmlNode" v http://schemas.datacontract.org/2004/07/System.Xml oboru názvů "".</span><span class="sxs-lookup"><span data-stu-id="b91c2-163">As with all polymorphic assignments, the `DataContractSerializer` emits the data contract name in the resulting XML – in this case, it is "ArrayOfXmlNode" in the "http://schemas.datacontract.org/2004/07/System.Xml" namespace.</span></span> <span data-ttu-id="b91c2-164">Při použití s `NetDataContractSerializer` , je podporováno jakékoli platné přiřazení `XmlNode` pole.</span><span class="sxs-lookup"><span data-stu-id="b91c2-164">When used with the `NetDataContractSerializer`, any valid assignment of an `XmlNode` array is supported.</span></span>  
  
### <a name="schema-considerations"></a><span data-ttu-id="b91c2-165">Otázky schématu</span><span class="sxs-lookup"><span data-stu-id="b91c2-165">Schema Considerations</span></span>  
 <span data-ttu-id="b91c2-166">Podrobnosti o mapování schématu typů XML najdete v tématu Referenční informace o [schématu kontraktu dat](data-contract-schema-reference.md).</span><span class="sxs-lookup"><span data-stu-id="b91c2-166">For details about the schema mapping of XML types, see [Data Contract Schema Reference](data-contract-schema-reference.md).</span></span> <span data-ttu-id="b91c2-167">V této části najdete souhrn důležitých bodů.</span><span class="sxs-lookup"><span data-stu-id="b91c2-167">This section provides a summary of the important points.</span></span>  
  
 <span data-ttu-id="b91c2-168">Datový člen typu `XmlElement` je namapován na element definovaný pomocí následujícího anonymního typu.</span><span class="sxs-lookup"><span data-stu-id="b91c2-168">A data member of type `XmlElement` is mapped to an element defined using the following anonymous type.</span></span>  
  
```xml  
<xsd:complexType>  
   <xsd:sequence>  
      <xsd:any minOccurs="0" processContents="lax" />  
   </xsd:sequence>  
</xsd:complexType>  
```  
  
 <span data-ttu-id="b91c2-169">Datový člen typu pole `XmlNode` je namapován na element definovaný pomocí následujícího anonymního typu.</span><span class="sxs-lookup"><span data-stu-id="b91c2-169">A data member of type Array of `XmlNode` is mapped to an element defined using the following anonymous type.</span></span>  
  
```xml  
<xsd:complexType mixed="true">  
   <xsd:sequence>  
      <xsd:any minOccurs="0" maxOccurs="unbounded" processContents="lax" />  
   </xsd:sequence>  
   <xsd:anyAttribute/>  
</xsd:complexType>  
```  
  
## <a name="types-implementing-the-ixmlserializable-interface"></a><span data-ttu-id="b91c2-170">Typy implementující rozhraní IXmlSerializable</span><span class="sxs-lookup"><span data-stu-id="b91c2-170">Types Implementing the IXmlSerializable Interface</span></span>  
 <span data-ttu-id="b91c2-171">Typy, které implementují `IXmlSerializable` rozhraní, jsou plně podporovány rozhraním `DataContractSerializer` .</span><span class="sxs-lookup"><span data-stu-id="b91c2-171">Types that implement the `IXmlSerializable` interface are fully supported by the `DataContractSerializer`.</span></span> <span data-ttu-id="b91c2-172"><xref:System.Xml.Serialization.XmlSchemaProviderAttribute>Atribut by měl být vždy použit pro tyto typy pro kontrolu jejich schématu.</span><span class="sxs-lookup"><span data-stu-id="b91c2-172">The <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> attribute should always be applied to these types to control their schema.</span></span>  
  
 <span data-ttu-id="b91c2-173">Existují tři různé typy, které implementují `IXmlSerializable` : typy, které představují libovolný obsah, typy, které představují jeden element a starší <xref:System.Data.DataSet> typy.</span><span class="sxs-lookup"><span data-stu-id="b91c2-173">There are three varieties of types that implement `IXmlSerializable`: types that represent arbitrary content, types that represent a single element, and legacy <xref:System.Data.DataSet> types.</span></span>  
  
- <span data-ttu-id="b91c2-174">Typy obsahu používají metodu poskytovatele schématu určenou `XmlSchemaProviderAttribute` atributem.</span><span class="sxs-lookup"><span data-stu-id="b91c2-174">Content types use a schema provider method specified by the `XmlSchemaProviderAttribute` attribute.</span></span> <span data-ttu-id="b91c2-175">Metoda nevrací hodnotu `null` a <xref:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny%2A> vlastnost na atributu je ponechána na výchozí hodnotě `false` .</span><span class="sxs-lookup"><span data-stu-id="b91c2-175">The method does not return `null`, and the <xref:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny%2A> property on the attribute is left at its default value of `false`.</span></span> <span data-ttu-id="b91c2-176">Toto je nejběžnější využití `IXmlSerializable` typů.</span><span class="sxs-lookup"><span data-stu-id="b91c2-176">This is the most common usage of `IXmlSerializable` types.</span></span>  
  
- <span data-ttu-id="b91c2-177">Typy prvků se používají, když `IXmlSerializable` typ musí řídit svůj vlastní název kořenového elementu.</span><span class="sxs-lookup"><span data-stu-id="b91c2-177">Element types are used when an `IXmlSerializable` type must control its own root element name.</span></span> <span data-ttu-id="b91c2-178">Chcete-li označit typ jako typ prvku, buď nastavte <xref:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny%2A> vlastnost u <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> atributu na `true` hodnotu nebo z metody poskytovatele schématu vraťte hodnotu null.</span><span class="sxs-lookup"><span data-stu-id="b91c2-178">To mark a type as an element type, either set the <xref:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny%2A> property on the <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> attribute to `true` or return null from the schema provider method.</span></span> <span data-ttu-id="b91c2-179">Použití metody poskytovatele schématu je pro typy prvků nepovinné – místo názvu metody v zadejte hodnotu null `XmlSchemaProviderAttribute` .</span><span class="sxs-lookup"><span data-stu-id="b91c2-179">Having a schema provider method is optional for element types – you may specify null instead of the method name in the `XmlSchemaProviderAttribute`.</span></span> <span data-ttu-id="b91c2-180">Nicméně pokud `IsAny` je `true` a je určena metoda poskytovatele schématu, metoda musí vracet hodnotu null.</span><span class="sxs-lookup"><span data-stu-id="b91c2-180">However, if `IsAny` is `true` and a schema provider method is specified, the method must return null.</span></span>  
  
- <span data-ttu-id="b91c2-181">Zastaralé <xref:System.Data.DataSet> typy jsou `IXmlSerializable` typy, které nejsou označeny `XmlSchemaProviderAttribute` atributem.</span><span class="sxs-lookup"><span data-stu-id="b91c2-181">Legacy <xref:System.Data.DataSet> types are `IXmlSerializable` types that are not marked with the `XmlSchemaProviderAttribute` attribute.</span></span> <span data-ttu-id="b91c2-182">Místo toho spoléhají na <xref:System.Xml.Serialization.IXmlSerializable.GetSchema%2A> metodu generování schématu.</span><span class="sxs-lookup"><span data-stu-id="b91c2-182">Instead, they rely on the <xref:System.Xml.Serialization.IXmlSerializable.GetSchema%2A> method for schema generation.</span></span> <span data-ttu-id="b91c2-183">Tento model se používá pro `DataSet` typ a jeho typová datová sada je odvozena od třídy v dřívějších verzích .NET Framework, ale je nyní zastaralá a je podporována pouze z dřívějších verzí.</span><span class="sxs-lookup"><span data-stu-id="b91c2-183">This pattern is used for the `DataSet` type and its typed dataset derives a class in earlier versions of the .NET Framework, but is now obsolete and is supported only for legacy reasons.</span></span> <span data-ttu-id="b91c2-184">Nespoléhejte na tento model a vždy použít `XmlSchemaProviderAttribute` pro vaše `IXmlSerializable` typy.</span><span class="sxs-lookup"><span data-stu-id="b91c2-184">Do not rely on this pattern and always apply the `XmlSchemaProviderAttribute` to your `IXmlSerializable` types.</span></span>  
  
### <a name="ixmlserializable-content-types"></a><span data-ttu-id="b91c2-185">Typy obsahu IXmlSerializable</span><span class="sxs-lookup"><span data-stu-id="b91c2-185">IXmlSerializable Content Types</span></span>  
 <span data-ttu-id="b91c2-186">Při serializaci datového členu typu, který implementuje `IXmlSerializable` a je typ obsahu definovaný dříve, serializátor zapíše prvek obálky pro datový člen a předá řízení <xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A> metodě.</span><span class="sxs-lookup"><span data-stu-id="b91c2-186">When serializing a data member of a type that implements `IXmlSerializable` and is a content type as defined previously, the serializer writes the wrapper element for the data member and pass control to the <xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A> method.</span></span> <span data-ttu-id="b91c2-187"><xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A>Implementace může zapisovat libovolné XML, včetně přidání atributů do prvku obálky.</span><span class="sxs-lookup"><span data-stu-id="b91c2-187">The <xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A> implementation can write any XML, including adding attributes to the wrapper element.</span></span> <span data-ttu-id="b91c2-188">Po `WriteXml` dokončení se serializátor uzavře s prvkem.</span><span class="sxs-lookup"><span data-stu-id="b91c2-188">After `WriteXml` is done, the serializer closes the element.</span></span>  
  
 <span data-ttu-id="b91c2-189">Při deserializaci datového členu typu, který implementuje `IXmlSerializable` a je typ obsahu tak, jak byl definován dříve, odregistruje Nástroj pro čtení XML v prvku obálky pro datový člen a předá řízení <xref:System.Xml.Serialization.IXmlSerializable.ReadXml%2A> metodě.</span><span class="sxs-lookup"><span data-stu-id="b91c2-189">When deserializing a data member of a type that implements `IXmlSerializable` and is a content type as defined previously, the deserializer positions the XML reader on the wrapper element for the data member and pass control to the <xref:System.Xml.Serialization.IXmlSerializable.ReadXml%2A> method.</span></span> <span data-ttu-id="b91c2-190">Metoda musí číst celý element, včetně počátečních a koncových značek.</span><span class="sxs-lookup"><span data-stu-id="b91c2-190">The method must read the entire element, including the start and end tags.</span></span> <span data-ttu-id="b91c2-191">Ujistěte se, že váš `ReadXml` kód zpracovává případ, kde je element prázdný.</span><span class="sxs-lookup"><span data-stu-id="b91c2-191">Make sure your `ReadXml` code handles the case where the element is empty.</span></span> <span data-ttu-id="b91c2-192">Navíc by vaše `ReadXml` implementace neměla spoléhat na prvek obálky s názvem, který je pojmenován určitým způsobem.</span><span class="sxs-lookup"><span data-stu-id="b91c2-192">Additionally, your `ReadXml` implementation should not rely on the wrapper element being named a particular way.</span></span> <span data-ttu-id="b91c2-193">Název je zvolen serializátorem se může lišit.</span><span class="sxs-lookup"><span data-stu-id="b91c2-193">The name is chosen by the serializer can vary.</span></span>  
  
 <span data-ttu-id="b91c2-194">Je povoleno přiřazovat `IXmlSerializable` typy obsahu polymorfní, například datovým členům typu <xref:System.Object> .</span><span class="sxs-lookup"><span data-stu-id="b91c2-194">It is permitted to assign `IXmlSerializable` content types polymorphically, for example, to data members of type <xref:System.Object>.</span></span> <span data-ttu-id="b91c2-195">Je také povoleno, aby instance typu měly hodnotu null.</span><span class="sxs-lookup"><span data-stu-id="b91c2-195">It is also permitted for the type instances to be null.</span></span> <span data-ttu-id="b91c2-196">Nakonec je možné použít `IXmlSerializable` typy s povolenou možností zachování grafu objektů a s <xref:System.Runtime.Serialization.NetDataContractSerializer> .</span><span class="sxs-lookup"><span data-stu-id="b91c2-196">Finally, it is possible to use `IXmlSerializable` types with object graph preservation enabled and with the <xref:System.Runtime.Serialization.NetDataContractSerializer>.</span></span> <span data-ttu-id="b91c2-197">Všechny tyto funkce vyžadují serializátor WCF k připojení určitých atributů k elementu obálky ("Nil" a "Type" v oboru názvů instance schématu XML a "ID", "ref", "Type" a "Assembly" v oboru názvů specifického pro WCF).</span><span class="sxs-lookup"><span data-stu-id="b91c2-197">All these features require the WCF serializer to attach certain attributes into the wrapper element ("nil" and "type" in the XML Schema Instance namespace and "Id", "Ref", "Type" and "Assembly" in a WCF-specific namespace).</span></span>  
  
#### <a name="attributes-to-ignore-when-implementing-readxml"></a><span data-ttu-id="b91c2-198">Atributy, které se mají ignorovat při implementaci ReadXml</span><span class="sxs-lookup"><span data-stu-id="b91c2-198">Attributes to Ignore when Implementing ReadXml</span></span>  
 <span data-ttu-id="b91c2-199">Před předáním řízení vašemu `ReadXml` kódu deserializátor prověřuje XML element, detekuje tyto speciální atributy XML a na nich funguje.</span><span class="sxs-lookup"><span data-stu-id="b91c2-199">Before passing control to your `ReadXml` code, the deserializer examines the XML element, detects these special XML attributes, and acts on them.</span></span> <span data-ttu-id="b91c2-200">Například pokud je "Nil" `true` , hodnota null je deserializována a není `ReadXml` volána.</span><span class="sxs-lookup"><span data-stu-id="b91c2-200">For example, if "nil" is `true`, a null value is deserialized and `ReadXml` is not called.</span></span> <span data-ttu-id="b91c2-201">Pokud je zjištěn polymorfismu, obsah elementu je deserializován, jako by byl jiný typ.</span><span class="sxs-lookup"><span data-stu-id="b91c2-201">If polymorphism is detected, the contents of the element are deserialized as if it was a different type.</span></span> <span data-ttu-id="b91c2-202">Je volána implementace polymorfního přiřazeného typu `ReadXml` .</span><span class="sxs-lookup"><span data-stu-id="b91c2-202">The polymorphically assigned type’s implementation of `ReadXml` is called.</span></span> <span data-ttu-id="b91c2-203">V každém případě `ReadXml` by implementace měla ignorovat tyto speciální atributy, protože jsou zpracovávány deserializací.</span><span class="sxs-lookup"><span data-stu-id="b91c2-203">In any case, a `ReadXml` implementation should ignore these special attributes because they are handled by the deserializer.</span></span>  
  
### <a name="schema-considerations-for-ixmlserializable-content-types"></a><span data-ttu-id="b91c2-204">Otázky schématu pro typy obsahu IXmlSerializable</span><span class="sxs-lookup"><span data-stu-id="b91c2-204">Schema Considerations for IXmlSerializable Content Types</span></span>  
 <span data-ttu-id="b91c2-205">Při exportování schématu `IXmlSerializable` typu obsahu je volána metoda poskytovatele schématu.</span><span class="sxs-lookup"><span data-stu-id="b91c2-205">When exporting schema an `IXmlSerializable` content type, the schema provider method is called.</span></span> <span data-ttu-id="b91c2-206"><xref:System.Xml.Schema.XmlSchemaSet>Metoda je předána metodě poskytovatele schématu.</span><span class="sxs-lookup"><span data-stu-id="b91c2-206">An <xref:System.Xml.Schema.XmlSchemaSet> is passed to the schema provider method.</span></span> <span data-ttu-id="b91c2-207">Metoda může do sady schémat přidat libovolné platné schéma.</span><span class="sxs-lookup"><span data-stu-id="b91c2-207">The method can add any valid schema to the schema set.</span></span> <span data-ttu-id="b91c2-208">Sada schémat obsahuje schéma, které je již známo v době, kdy dojde k exportu schématu.</span><span class="sxs-lookup"><span data-stu-id="b91c2-208">The schema set contains the schema that is already known at the time when schema export occurs.</span></span> <span data-ttu-id="b91c2-209">Pokud metoda poskytovatele schématu musí do sady schémat přidat položku, musí určit, zda objekt <xref:System.Xml.Schema.XmlSchema> s odpovídajícím oborem názvů již v sadě existuje.</span><span class="sxs-lookup"><span data-stu-id="b91c2-209">When the schema provider method must add an item to the schema set, it must determine if an <xref:System.Xml.Schema.XmlSchema> with the appropriate namespace already exists in the set.</span></span> <span data-ttu-id="b91c2-210">V takovém případě metoda poskytovatele schématu musí přidat novou položku do existující `XmlSchema` .</span><span class="sxs-lookup"><span data-stu-id="b91c2-210">If it does, the schema provider method must add the new item to the existing `XmlSchema`.</span></span> <span data-ttu-id="b91c2-211">V opačném případě musí vytvořit novou `XmlSchema` instanci.</span><span class="sxs-lookup"><span data-stu-id="b91c2-211">Otherwise, it must create a new `XmlSchema` instance.</span></span> <span data-ttu-id="b91c2-212">To je důležité `IXmlSerializable` , pokud jsou používána pole typů.</span><span class="sxs-lookup"><span data-stu-id="b91c2-212">This is important if arrays of `IXmlSerializable` types are being used.</span></span> <span data-ttu-id="b91c2-213">Například pokud máte `IXmlSerializable` typ, který bude exportován jako typ "A" v oboru názvů "B", je možné, že v době, kdy se metoda poskytovatele schématu nazývá sada schémat, již obsahuje schéma pro "b" pro uchování typu "ArrayOfA".</span><span class="sxs-lookup"><span data-stu-id="b91c2-213">For example, if you have an `IXmlSerializable` type that gets exported as type "A" in namespace "B", it is possible that by the time the schema provider method is called the schema set already contains the schema for "B" to hold the "ArrayOfA" type.</span></span>  
  
 <span data-ttu-id="b91c2-214">Kromě přidávání typů do <xref:System.Xml.Schema.XmlSchemaSet> metody musí metoda poskytovatele schématu pro typy obsahu vracet hodnotu, která není null.</span><span class="sxs-lookup"><span data-stu-id="b91c2-214">In addition to adding types to the <xref:System.Xml.Schema.XmlSchemaSet>, the schema provider method for content types must return a non-null value.</span></span> <span data-ttu-id="b91c2-215">Může vrátit <xref:System.Xml.XmlQualifiedName> , který určuje název typu schématu, který má být použit pro daný `IXmlSerializable` typ.</span><span class="sxs-lookup"><span data-stu-id="b91c2-215">It can return an <xref:System.Xml.XmlQualifiedName> that specifies the name of the schema type to use for the given `IXmlSerializable` type.</span></span> <span data-ttu-id="b91c2-216">Tento kvalifikovaný název slouží také jako název kontraktu dat a obor názvů pro daný typ.</span><span class="sxs-lookup"><span data-stu-id="b91c2-216">This qualified name also serves as the data contract name and namespace for the type.</span></span> <span data-ttu-id="b91c2-217">Je povoleno vrátit typ, který neexistuje v sadě schémat ihned při návratu metody poskytovatele schématu.</span><span class="sxs-lookup"><span data-stu-id="b91c2-217">It is permitted to return a type that does not exist in the schema set immediately when the schema provider method returns.</span></span> <span data-ttu-id="b91c2-218">Očekává se však, že v době, kdy jsou exportovány všechny související typy ( <xref:System.Runtime.Serialization.XsdDataContractExporter.Export%2A> Metoda je volána pro všechny relevantní typy v <xref:System.Runtime.Serialization.XsdDataContractExporter> a <xref:System.Runtime.Serialization.XsdDataContractExporter.Schemas%2A> je k dispozici vlastnost), typ existuje v sadě schémat.</span><span class="sxs-lookup"><span data-stu-id="b91c2-218">However, it is expected that by the time all related types are exported (the <xref:System.Runtime.Serialization.XsdDataContractExporter.Export%2A> method is called for all relevant types on the <xref:System.Runtime.Serialization.XsdDataContractExporter> and the <xref:System.Runtime.Serialization.XsdDataContractExporter.Schemas%2A> property is accessed), the type exists in the schema set.</span></span> <span data-ttu-id="b91c2-219">Přístup k `Schemas` vlastnosti před provedením všech relevantních `Export` volání může mít za následek <xref:System.Xml.Schema.XmlSchemaException> .</span><span class="sxs-lookup"><span data-stu-id="b91c2-219">Accessing the `Schemas` property before all relevant `Export` calls have been made can result in an <xref:System.Xml.Schema.XmlSchemaException>.</span></span> <span data-ttu-id="b91c2-220">Další informace o procesu exportu naleznete v tématu [Export schémat ze tříd](exporting-schemas-from-classes.md).</span><span class="sxs-lookup"><span data-stu-id="b91c2-220">For more information about the export process, see [Exporting Schemas from Classes](exporting-schemas-from-classes.md).</span></span>  
  
 <span data-ttu-id="b91c2-221">Metoda poskytovatele schématu může také vrátit hodnotu, <xref:System.Xml.Schema.XmlSchemaType> která má být použita.</span><span class="sxs-lookup"><span data-stu-id="b91c2-221">The schema provider method can also return the <xref:System.Xml.Schema.XmlSchemaType> to use.</span></span> <span data-ttu-id="b91c2-222">Typ může nebo nemusí být anonymní.</span><span class="sxs-lookup"><span data-stu-id="b91c2-222">The type may or may not be anonymous.</span></span> <span data-ttu-id="b91c2-223">Pokud je anonymní, schéma pro `IXmlSerializable` typ je exportováno jako anonymní typ pokaždé, když `IXmlSerializable` je typ použit jako datový člen.</span><span class="sxs-lookup"><span data-stu-id="b91c2-223">If it is anonymous, the schema for the `IXmlSerializable` type is exported as an anonymous type every time the `IXmlSerializable` type is used as a data member.</span></span> <span data-ttu-id="b91c2-224">`IXmlSerializable`Typ má stále název kontraktu dat a obor názvů.</span><span class="sxs-lookup"><span data-stu-id="b91c2-224">The `IXmlSerializable` type still has a data contract name and namespace.</span></span> <span data-ttu-id="b91c2-225">(Tato vlastnost je určena jak je popsáno v tématu [názvy kontraktů dat](data-contract-names.md) s výjimkou toho, že <xref:System.Runtime.Serialization.DataContractAttribute> atribut nelze použít k přizpůsobení názvu.) Pokud není anonymní, musí být jedním z typů v `XmlSchemaSet` .</span><span class="sxs-lookup"><span data-stu-id="b91c2-225">(This is determined as described in [Data Contract Names](data-contract-names.md) except that the <xref:System.Runtime.Serialization.DataContractAttribute> attribute cannot be used to customize the name.) If it is not anonymous, it must be one of the types in the `XmlSchemaSet`.</span></span> <span data-ttu-id="b91c2-226">Tento případ je ekvivalentem vrácení `XmlQualifiedName` typu.</span><span class="sxs-lookup"><span data-stu-id="b91c2-226">This case is equivalent to returning the `XmlQualifiedName` of the type.</span></span>  
  
 <span data-ttu-id="b91c2-227">Kromě toho je pro daný typ exportována globální deklarace elementu.</span><span class="sxs-lookup"><span data-stu-id="b91c2-227">Additionally, a global element declaration is exported for the type.</span></span> <span data-ttu-id="b91c2-228">Pokud pro daný typ není <xref:System.Xml.Serialization.XmlRootAttribute> použit atribut, má element stejný název a obor názvů jako kontrakt dat a jeho vlastnost "nillable" má hodnotu true.</span><span class="sxs-lookup"><span data-stu-id="b91c2-228">If the type does not have the <xref:System.Xml.Serialization.XmlRootAttribute> attribute applied to it, the element has the same name and namespace as the data contract, and its "nillable" property is true.</span></span> <span data-ttu-id="b91c2-229">Jedinou výjimkou je obor názvů schématu (" http://www.w3.org/2001/XMLSchema ") – Pokud je kontrakt dat typu v tomto oboru názvů, odpovídající globální element je v prázdném oboru názvů, protože je zakázáno přidávat nové prvky do oboru názvů schématu.</span><span class="sxs-lookup"><span data-stu-id="b91c2-229">The only exception to this is the schema namespace ("http://www.w3.org/2001/XMLSchema") – if the type’s data contract is in this namespace, the corresponding global element is in the blank namespace because it is forbidden to add new elements to the schema namespace.</span></span> <span data-ttu-id="b91c2-230">`XmlRootAttribute`Je-li pro typ použit atribut, je deklarace globálního prvku exportována pomocí následujících <xref:System.Xml.Serialization.XmlRootAttribute.ElementName%2A> vlastností: <xref:System.Xml.Serialization.XmlRootAttribute.Namespace%2A> a <xref:System.Xml.Serialization.XmlRootAttribute.IsNullable%2A> .</span><span class="sxs-lookup"><span data-stu-id="b91c2-230">If the type has the `XmlRootAttribute` attribute applied to it, the global element declaration is exported using the following: <xref:System.Xml.Serialization.XmlRootAttribute.ElementName%2A>, <xref:System.Xml.Serialization.XmlRootAttribute.Namespace%2A> and <xref:System.Xml.Serialization.XmlRootAttribute.IsNullable%2A> properties.</span></span> <span data-ttu-id="b91c2-231">Výchozí hodnoty jsou nastavené `XmlRootAttribute` na název kontraktu dat, prázdný obor názvů a "nillable".</span><span class="sxs-lookup"><span data-stu-id="b91c2-231">The defaults with `XmlRootAttribute` applied are the data contract name, a blank namespace and "nillable" being true.</span></span>  
  
 <span data-ttu-id="b91c2-232">Stejná pravidla deklarace globálních prvků se vztahují na typy datových sad typu Legacy.</span><span class="sxs-lookup"><span data-stu-id="b91c2-232">The same global element declaration rules apply to legacy dataset types.</span></span> <span data-ttu-id="b91c2-233">Všimněte si, že `XmlRootAttribute` deklarace globálních prvků nelze přepsat přidáním vlastního kódu, buď přidaných na `XmlSchemaSet` metodu pomocí metody poskytovatele schématu nebo prostřednictvím `GetSchema` pro typy starších datových sad.</span><span class="sxs-lookup"><span data-stu-id="b91c2-233">Note that the `XmlRootAttribute` cannot override global element declarations added through custom code, either added to the `XmlSchemaSet` using the schema provider method or through `GetSchema` for legacy dataset types.</span></span>  
  
### <a name="ixmlserializable-element-types"></a><span data-ttu-id="b91c2-234">IXmlSerializable – typy prvků</span><span class="sxs-lookup"><span data-stu-id="b91c2-234">IXmlSerializable Element Types</span></span>  
 <span data-ttu-id="b91c2-235">`IXmlSerializable`typy prvků mají buď `IsAny` vlastnost nastavenou na, `true` nebo mají návrat metody poskytovatele schématu `null` .</span><span class="sxs-lookup"><span data-stu-id="b91c2-235">`IXmlSerializable` element types have either the `IsAny` property set to `true` or have their schema provider method return `null`.</span></span>  
  
 <span data-ttu-id="b91c2-236">Serializace a deserializace typu elementu je velmi podobná serializaci a deserializaci typu obsahu.</span><span class="sxs-lookup"><span data-stu-id="b91c2-236">Serializing and deserializing an element type is very similar to serializing and deserializing a content type.</span></span> <span data-ttu-id="b91c2-237">Existují však některé důležité rozdíly:</span><span class="sxs-lookup"><span data-stu-id="b91c2-237">However, there are some important differences:</span></span>  
  
- <span data-ttu-id="b91c2-238">`WriteXml`Implementace se očekává, že zapíše přesně jeden prvek (což může samozřejmě obsahovat více podřízených elementů).</span><span class="sxs-lookup"><span data-stu-id="b91c2-238">The `WriteXml` implementation is expected to write exactly one element (which could of course contain multiple child elements).</span></span> <span data-ttu-id="b91c2-239">Neměl by zapisovat atributy mimo tento jediný element, více elementů na stejné úrovni nebo smíšený obsah.</span><span class="sxs-lookup"><span data-stu-id="b91c2-239">It should not be writing attributes outside of this single element, multiple sibling elements or mixed content.</span></span> <span data-ttu-id="b91c2-240">Element může být prázdný.</span><span class="sxs-lookup"><span data-stu-id="b91c2-240">The element may be empty.</span></span>  
  
- <span data-ttu-id="b91c2-241">`ReadXml`Implementace by neměla číst prvek obálky.</span><span class="sxs-lookup"><span data-stu-id="b91c2-241">The `ReadXml` implementation should not read the wrapper element.</span></span> <span data-ttu-id="b91c2-242">Očekává se, že si přečtete jeden prvek, který `WriteXml` vytvoří.</span><span class="sxs-lookup"><span data-stu-id="b91c2-242">It is expected to read the one element that `WriteXml` produces.</span></span>  
  
- <span data-ttu-id="b91c2-243">Při pravidelném serializaci typu elementu (například jako datový člen v kontraktu dat) vytvoří serializátor výstup prvku obálky před voláním `WriteXml` jako s typy obsahu.</span><span class="sxs-lookup"><span data-stu-id="b91c2-243">When serializing an element type regularly (for example, as a data member in a data contract), the serializer outputs a wrapper element before calling `WriteXml`, as with content types.</span></span> <span data-ttu-id="b91c2-244">Při serializaci typu elementu na nejvyšší úrovni však serializátor obvykle nevytváří Obálkový prvek vůbec kolem elementu, který `WriteXml` zapisuje, pokud kořenový název a obor názvů nebyl explicitně zadán při vytváření serializátoru v `DataContractSerializer` `NetDataContractSerializer` konstruktorech nebo.</span><span class="sxs-lookup"><span data-stu-id="b91c2-244">However, when serializing an element type at the top level, the serializer does not normally output a wrapper element at all around the element that `WriteXml` writes, unless a root name and namespace were explicitly specified when constructing the serializer in the `DataContractSerializer` or `NetDataContractSerializer` constructors.</span></span> <span data-ttu-id="b91c2-245">Další informace naleznete v tématu [serializace a deserializace](serialization-and-deserialization.md).</span><span class="sxs-lookup"><span data-stu-id="b91c2-245">For more information, see [Serialization and Deserialization](serialization-and-deserialization.md).</span></span>  
  
- <span data-ttu-id="b91c2-246">Při serializaci typu prvku na nejvyšší úrovni bez zadání kořenového názvu a oboru názvů v době konstrukce <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteStartObject%2A> a <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteEndObject%2A> v podstatě neprovede žádné <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObjectContent%2A> volání `WriteXml` .</span><span class="sxs-lookup"><span data-stu-id="b91c2-246">When serializing an element type at the top level without specifying the root name and namespace at construction time, <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteStartObject%2A> and <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteEndObject%2A> essentially does nothing and <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObjectContent%2A> calls `WriteXml`.</span></span> <span data-ttu-id="b91c2-247">V tomto režimu nemůže být serializovaný objekt null a nelze jej polymorfním přiřadit.</span><span class="sxs-lookup"><span data-stu-id="b91c2-247">In this mode, the object being serialized cannot be null and cannot be polymorphically assigned.</span></span> <span data-ttu-id="b91c2-248">Také zachování grafu objektů nelze povolit a nelze jej `NetDataContractSerializer` použít.</span><span class="sxs-lookup"><span data-stu-id="b91c2-248">Also, object graph preservation cannot enabled and the `NetDataContractSerializer` cannot be used.</span></span>  
  
- <span data-ttu-id="b91c2-249">Při deserializaci typu elementu na nejvyšší úrovni bez zadání kořenového názvu a oboru názvů v době konstrukce, <xref:System.Runtime.Serialization.XmlObjectSerializer.IsStartObject%2A> vrátí, `true` Pokud může najít začátek libovolného elementu.</span><span class="sxs-lookup"><span data-stu-id="b91c2-249">When deserializing an element type at the top level without specifying the root name and namespace at construction time, <xref:System.Runtime.Serialization.XmlObjectSerializer.IsStartObject%2A> returns `true` if it can find the start of any element.</span></span> <span data-ttu-id="b91c2-250"><xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A>se `verifyObjectName` sadou parametrů se `true` chová stejně jako `IsStartObject` před skutečným čtením objektu.</span><span class="sxs-lookup"><span data-stu-id="b91c2-250"><xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> with the `verifyObjectName` parameter set to `true` behaves in the same way as `IsStartObject` before actually reading the object.</span></span> <span data-ttu-id="b91c2-251">`ReadObject`poté předává řízení `ReadXml` metodě.</span><span class="sxs-lookup"><span data-stu-id="b91c2-251">`ReadObject` then passes control to `ReadXml` method.</span></span>  
  
 <span data-ttu-id="b91c2-252">Schéma exportované pro typy elementů je stejné jako pro typ, `XmlElement` jak je popsáno v předchozí části, s výjimkou, že metoda poskytovatele schématu může přidat jakékoli další schéma <xref:System.Xml.Schema.XmlSchemaSet> jako s typy obsahu.</span><span class="sxs-lookup"><span data-stu-id="b91c2-252">The schema exported for element types is the same as for the `XmlElement` type as described in an earlier section, except that the schema provider method can add any additional schema to the <xref:System.Xml.Schema.XmlSchemaSet> as with content types.</span></span> <span data-ttu-id="b91c2-253">Použití `XmlRootAttribute` atributu s typy prvků není povoleno a deklarace globálních prvků nejsou pro tyto typy nikdy generovány.</span><span class="sxs-lookup"><span data-stu-id="b91c2-253">Using the `XmlRootAttribute` attribute with element types is not allowed, and global element declarations are never emitted for these types.</span></span>  
  
### <a name="differences-from-the-xmlserializer"></a><span data-ttu-id="b91c2-254">Rozdíly mezi objektem XmlSerializer</span><span class="sxs-lookup"><span data-stu-id="b91c2-254">Differences from the XmlSerializer</span></span>  
 <span data-ttu-id="b91c2-255">`IXmlSerializable`Rozhraní a `XmlSchemaProviderAttribute` `XmlRootAttribute` atributy a jsou také srozumitelné pomocí <xref:System.Xml.Serialization.XmlSerializer> .</span><span class="sxs-lookup"><span data-stu-id="b91c2-255">The `IXmlSerializable` interface and the `XmlSchemaProviderAttribute` and `XmlRootAttribute` attributes are also understood by the <xref:System.Xml.Serialization.XmlSerializer> .</span></span> <span data-ttu-id="b91c2-256">Existují však určité rozdíly v tom, jak jsou tyto aplikace zpracovány v modelu kontraktu dat.</span><span class="sxs-lookup"><span data-stu-id="b91c2-256">However, there are some differences in how these are treated in the data contract model.</span></span> <span data-ttu-id="b91c2-257">Důležité rozdíly jsou shrnuty v následujících:</span><span class="sxs-lookup"><span data-stu-id="b91c2-257">The important differences are summarized in the following:</span></span>  
  
- <span data-ttu-id="b91c2-258">Metoda poskytovatele schématu musí být veřejná, aby ji bylo možné použít v `XmlSerializer` , ale nemusí být veřejná, aby ji bylo možné použít v modelu kontraktu dat.</span><span class="sxs-lookup"><span data-stu-id="b91c2-258">The schema provider method must be public to be usable in the `XmlSerializer`, but does not have to be public to be usable in the data contract model.</span></span>  
  
- <span data-ttu-id="b91c2-259">Metoda poskytovatele schématu je volána, když `IsAny` je hodnota true v modelu kontraktu dat, ale ne s `XmlSerializer` .</span><span class="sxs-lookup"><span data-stu-id="b91c2-259">The schema provider method is called when `IsAny` is true in the data contract model but not with the `XmlSerializer`.</span></span>  
  
- <span data-ttu-id="b91c2-260">Pokud `XmlRootAttribute` atribut není k dispozici pro obsah nebo starší typy datových sad, `XmlSerializer` exportuje deklaraci globálního prvku v prázdném oboru názvů.</span><span class="sxs-lookup"><span data-stu-id="b91c2-260">When the `XmlRootAttribute` attribute is not present for content or legacy dataset types, the `XmlSerializer` exports a global element declaration in the blank namespace.</span></span> <span data-ttu-id="b91c2-261">V modelu kontraktu dat se používá obor názvů obvykle obor názvů kontraktu dat, jak je popsáno výše.</span><span class="sxs-lookup"><span data-stu-id="b91c2-261">In the data contract model, the namespace used is normally the data contract namespace as described earlier.</span></span>  
  
 <span data-ttu-id="b91c2-262">Pamatujte na tyto rozdíly při vytváření typů, které se používají v obou technologiích serializace.</span><span class="sxs-lookup"><span data-stu-id="b91c2-262">Be aware of these differences when creating types that are used with both serialization technologies.</span></span>  
  
### <a name="importing-ixmlserializable-schema"></a><span data-ttu-id="b91c2-263">Importuje se schéma IXmlSerializable.</span><span class="sxs-lookup"><span data-stu-id="b91c2-263">Importing IXmlSerializable Schema</span></span>  
 <span data-ttu-id="b91c2-264">Při importu schématu vygenerovaného z `IXmlSerializable` typů existuje několik možností:</span><span class="sxs-lookup"><span data-stu-id="b91c2-264">When importing a schema generated from `IXmlSerializable` types, there are a few possibilities:</span></span>  
  
- <span data-ttu-id="b91c2-265">Vygenerované schéma může být platné schéma kontraktu dat, jak je popsáno v tématu [referenční informace schématu kontraktu dat](data-contract-schema-reference.md).</span><span class="sxs-lookup"><span data-stu-id="b91c2-265">The generated schema may be a valid data contract schema as described in [Data Contract Schema Reference](data-contract-schema-reference.md).</span></span> <span data-ttu-id="b91c2-266">V takovém případě se schéma dá importovat jako běžné a jsou vygenerované běžné typy kontraktů dat.</span><span class="sxs-lookup"><span data-stu-id="b91c2-266">In this case, schema can be imported as usual and regular data contract types are generated.</span></span>  
  
- <span data-ttu-id="b91c2-267">Vygenerované schéma nesmí být platným schématem kontraktu dat.</span><span class="sxs-lookup"><span data-stu-id="b91c2-267">The generated schema may not be a valid data contract schema.</span></span> <span data-ttu-id="b91c2-268">Například metoda poskytovatele schématu může generovat schéma, které zahrnuje atributy XML, které nejsou podporovány v modelu kontraktu dat.</span><span class="sxs-lookup"><span data-stu-id="b91c2-268">For example, your schema provider method may generate schema that involves XML attributes which are not supported in the data contract model.</span></span> <span data-ttu-id="b91c2-269">V takovém případě můžete schéma importovat jako `IXmlSerializable` typy.</span><span class="sxs-lookup"><span data-stu-id="b91c2-269">In this case, you can import the schema as `IXmlSerializable` types.</span></span> <span data-ttu-id="b91c2-270">Tento režim importu není ve výchozím nastavení zapnutý, ale dá se snadno povolit – například s `/importXmlTypes` přepínačem příkazového řádku, který se nachází v nástroji pro podporu [metadat ServiceModel (Svcutil. exe)](../servicemodel-metadata-utility-tool-svcutil-exe.md).</span><span class="sxs-lookup"><span data-stu-id="b91c2-270">This import mode is not on by default but can easily be enabled – for example, with the `/importXmlTypes` command-line switch to the [ServiceModel Metadata Utility Tool (Svcutil.exe)](../servicemodel-metadata-utility-tool-svcutil-exe.md).</span></span> <span data-ttu-id="b91c2-271">Tato informace je podrobněji popsána v tématu [Import schématu pro generování tříd](importing-schema-to-generate-classes.md).</span><span class="sxs-lookup"><span data-stu-id="b91c2-271">This is described in detail in the [Importing Schema to Generate Classes](importing-schema-to-generate-classes.md).</span></span> <span data-ttu-id="b91c2-272">Všimněte si, že je nutné pracovat přímo s XML pro vaše instance typu.</span><span class="sxs-lookup"><span data-stu-id="b91c2-272">Note that you must work directly with the XML for your type instances.</span></span> <span data-ttu-id="b91c2-273">Je také vhodné zvážit použití jiné technologie serializace, která podporuje širší škálu schématu – viz téma o použití `XmlSerializer` .</span><span class="sxs-lookup"><span data-stu-id="b91c2-273">You may also consider using a different serialization technology that supports a wider range of schema – see the topic on using the `XmlSerializer`.</span></span>  
  
- <span data-ttu-id="b91c2-274">Můžete chtít znovu použít stávající `IXmlSerializable` typy na proxy místo generování nových.</span><span class="sxs-lookup"><span data-stu-id="b91c2-274">You may want to reuse your existing `IXmlSerializable` types in the proxy instead of generating new ones.</span></span> <span data-ttu-id="b91c2-275">V tomto případě lze pomocí odkazovaného typu, který je popsán v tématu Import schématu pro generování typů, použít k označení typu pro opakované použití.</span><span class="sxs-lookup"><span data-stu-id="b91c2-275">In this case, the referenced types feature described in the Importing Schema to Generate Types topic can be used to indicate the type to reuse.</span></span> <span data-ttu-id="b91c2-276">To odpovídá použití `/reference` přepínače na Svcutil. exe, který určuje sestavení, které obsahuje typy pro opakované použití.</span><span class="sxs-lookup"><span data-stu-id="b91c2-276">This corresponds to using the `/reference` switch on svcutil.exe, which specifies the assembly that contains the types to reuse.</span></span>  
  
## <a name="representing-arbitrary-xml-in-data-contracts"></a><span data-ttu-id="b91c2-277">Reprezentace libovolného XML v kontraktech dat</span><span class="sxs-lookup"><span data-stu-id="b91c2-277">Representing Arbitrary XML in Data Contracts</span></span>  
 <span data-ttu-id="b91c2-278">Pole `XmlElement` `XmlNode` a `IXmlSerializable` typy umožňují vložit libovolný kód XML do modelu kontraktu dat.</span><span class="sxs-lookup"><span data-stu-id="b91c2-278">The `XmlElement`, Array of `XmlNode` and `IXmlSerializable` types allow you to inject arbitrary XML into the data contract model.</span></span> <span data-ttu-id="b91c2-279">`DataContractSerializer`A `NetDataContractSerializer` předá tento obsah XML zapisovači XML, který se používá, bez rušivého vlivu procesu.</span><span class="sxs-lookup"><span data-stu-id="b91c2-279">The `DataContractSerializer` and `NetDataContractSerializer` pass this XML content on to the XML writer in use, without interfering in the process.</span></span> <span data-ttu-id="b91c2-280">Zapisovače XML však může vyhovět určitým omezením v XML, která zapisuje.</span><span class="sxs-lookup"><span data-stu-id="b91c2-280">However, the XML writers may enforce certain restrictions on the XML that they write.</span></span> <span data-ttu-id="b91c2-281">Konkrétně tady jsou některé důležité příklady:</span><span class="sxs-lookup"><span data-stu-id="b91c2-281">Specifically, here are some important examples:</span></span>  
  
- <span data-ttu-id="b91c2-282">Zapisovače XML obvykle nepovoluje deklaraci dokumentu XML (například \<?xml version=’1.0’ ?> ) v průběhu psaní jiného dokumentu.</span><span class="sxs-lookup"><span data-stu-id="b91c2-282">The XML writers do not typically allow an XML document declaration (for example, \<?xml version=’1.0’ ?>) in the middle of writing another document.</span></span> <span data-ttu-id="b91c2-283">Nemůžete získat úplný dokument XML a serializovat ho jako `Array` `XmlNode` datový člen.</span><span class="sxs-lookup"><span data-stu-id="b91c2-283">You cannot take a full XML document and serialize it as an `Array` of `XmlNode` data member.</span></span> <span data-ttu-id="b91c2-284">Chcete-li to provést, musíte buď oddělit deklaraci dokumentu, nebo použít vlastní schéma kódování pro reprezentaci.</span><span class="sxs-lookup"><span data-stu-id="b91c2-284">To do this, you have to either strip out the document declaration or use your own encoding scheme to represent it.</span></span>  
  
- <span data-ttu-id="b91c2-285">Všechny zapisovače XML dodávané pomocí WCF odmítnou instrukce pro zpracování XML ( \<? … ?> ) a definice typu dokumentu ( \<! … > ), protože nejsou ve zprávách SOAP povoleny.</span><span class="sxs-lookup"><span data-stu-id="b91c2-285">All of the XML writers supplied with WCF reject XML processing instructions (\<? … ?>) and document type definitions (\<! … >), because they are not allowed in SOAP messages.</span></span> <span data-ttu-id="b91c2-286">K tomuto omezení můžete využít vlastní mechanizmus kódování.</span><span class="sxs-lookup"><span data-stu-id="b91c2-286">Again, you can use your own encoding mechanism to get around this restriction.</span></span> <span data-ttu-id="b91c2-287">Pokud je musíte zahrnout do výsledné XML, můžete napsat vlastní kodér, který používá zapisovače XML, které je podporují.</span><span class="sxs-lookup"><span data-stu-id="b91c2-287">If you must include these in your resultant XML, you can write a custom encoder that uses XML writers that support them.</span></span>  
  
- <span data-ttu-id="b91c2-288">Při implementaci `WriteXml` , vyhněte se volání <xref:System.Xml.XmlWriter.WriteRaw%2A> metody do zapisovače XML.</span><span class="sxs-lookup"><span data-stu-id="b91c2-288">When implementing `WriteXml`, avoid calling <xref:System.Xml.XmlWriter.WriteRaw%2A> method on the XML writer.</span></span> <span data-ttu-id="b91c2-289">WCF používá nejrůznější kódování XML (včetně binárních), je velmi obtížné nebo nemožné použít `WriteRaw` tak, aby byl výsledek použitelný v jakémkoli kódování.</span><span class="sxs-lookup"><span data-stu-id="b91c2-289">WCF uses a variety of XML encodings (including binary), it is very difficult or impossible to use `WriteRaw` such that the result is usable in any encoding.</span></span>  
  
- <span data-ttu-id="b91c2-290">Při implementaci `WriteXml` , vyhněte se <xref:System.Xml.XmlWriter.WriteEntityRef%2A> použití <xref:System.Xml.XmlWriter.WriteNmToken%2A> metod a, které nejsou podporovány u zapisovačů XML dodaných pomocí WCF.</span><span class="sxs-lookup"><span data-stu-id="b91c2-290">When implementing `WriteXml`, avoid using the <xref:System.Xml.XmlWriter.WriteEntityRef%2A> and <xref:System.Xml.XmlWriter.WriteNmToken%2A> methods that are unsupported on the XML writers supplied with WCF.</span></span>  
  
## <a name="using-dataset-typed-dataset-and-datatable"></a><span data-ttu-id="b91c2-291">Použití datové sady, typované datové sady a DataTable</span><span class="sxs-lookup"><span data-stu-id="b91c2-291">Using DataSet, Typed DataSet and DataTable</span></span>  
 <span data-ttu-id="b91c2-292">Použití těchto typů je plně podporováno v modelu kontraktu dat.</span><span class="sxs-lookup"><span data-stu-id="b91c2-292">Using these types is fully supported in the data contract model.</span></span> <span data-ttu-id="b91c2-293">Při použití těchto typů Vezměte v úvahu následující body:</span><span class="sxs-lookup"><span data-stu-id="b91c2-293">When using these types, consider the following points:</span></span>  
  
- <span data-ttu-id="b91c2-294">Schéma pro tyto typy (zejména <xref:System.Data.DataSet> a jeho typové odvozené třídy) nemusí spolupracovat s některými platformami, které nepatří do WCF, nebo může při použití s těmito platformami způsobit špatnou použitelnost.</span><span class="sxs-lookup"><span data-stu-id="b91c2-294">The schema for these types (especially <xref:System.Data.DataSet> and its typed derived classes) may not be interoperable with some non-WCF platforms, or may result in poor usability when used with these platforms.</span></span> <span data-ttu-id="b91c2-295">Kromě toho může použití `DataSet` typu mít vliv na výkon.</span><span class="sxs-lookup"><span data-stu-id="b91c2-295">Additionally, using the `DataSet` type may have performance implications.</span></span> <span data-ttu-id="b91c2-296">Nakonec může být obtížnější aplikaci v budoucnu napravit.</span><span class="sxs-lookup"><span data-stu-id="b91c2-296">Finally, it may make it more difficult for you to version your application in the future.</span></span> <span data-ttu-id="b91c2-297">Zvažte možnost použití explicitně definovaných typů kontraktů dat místo `DataSet` typů ve smlouvách.</span><span class="sxs-lookup"><span data-stu-id="b91c2-297">Consider using explicitly defined data contract types instead of `DataSet` types in your contracts.</span></span>  
  
- <span data-ttu-id="b91c2-298">Při importu `DataSet` nebo `DataTable` schématu je důležité odkázat na tyto typy.</span><span class="sxs-lookup"><span data-stu-id="b91c2-298">When importing `DataSet` or `DataTable` schema, it is important to reference these types.</span></span> <span data-ttu-id="b91c2-299">Pomocí nástroje příkazového řádku Svcutil. exe lze dosáhnout toho, že do přepínače předáte název sestavení System. data. dll `/reference` .</span><span class="sxs-lookup"><span data-stu-id="b91c2-299">With the Svcutil.exe command-line tool, this can be accomplished by passing the System.Data.dll assembly name to the `/reference` switch.</span></span> <span data-ttu-id="b91c2-300">Pokud importujete schéma typované datové sady, musíte odkazovat na typ typované datové sady.</span><span class="sxs-lookup"><span data-stu-id="b91c2-300">If importing typed dataset schema, you must reference the typed dataset’s type.</span></span> <span data-ttu-id="b91c2-301">Pomocí Svcutil. exe předejte do přepínače umístění sestavení typové datové sady `/reference` .</span><span class="sxs-lookup"><span data-stu-id="b91c2-301">With Svcutil.exe, pass the location of the typed dataset’s assembly to the `/reference` switch.</span></span> <span data-ttu-id="b91c2-302">Další informace o odkazování typů naleznete v tématu [Import schématu pro generování tříd](importing-schema-to-generate-classes.md).</span><span class="sxs-lookup"><span data-stu-id="b91c2-302">For more information about referencing types, see the [Importing Schema to Generate Classes](importing-schema-to-generate-classes.md).</span></span>  
  
 <span data-ttu-id="b91c2-303">Podpora typových datových sad v modelu kontraktu dat je omezená.</span><span class="sxs-lookup"><span data-stu-id="b91c2-303">Support for typed DataSets in the data contract model is limited.</span></span> <span data-ttu-id="b91c2-304">Typové datové sady lze serializovat a deserializovat a mohou exportovat své schéma.</span><span class="sxs-lookup"><span data-stu-id="b91c2-304">Typed DataSets can be serialized and deserialized and can export their schema.</span></span> <span data-ttu-id="b91c2-305">Import schématu kontraktu dat ale nemůže ze schématu generovat nové typy datových sad, protože můžou znovu použít jenom ty existující.</span><span class="sxs-lookup"><span data-stu-id="b91c2-305">However, the Data Contract schema import is unable to generate new typed DataSet types from the schema, as it can only reuse existing ones.</span></span> <span data-ttu-id="b91c2-306">Pomocí `/r` přepínače v Svcutil. exe můžete odkazovat na existující typovou datovou sadu.</span><span class="sxs-lookup"><span data-stu-id="b91c2-306">You can point to an existing typed DataSet by using the `/r` switch on Svcutil.exe.</span></span> <span data-ttu-id="b91c2-307">Pokud se pokusíte použít Svcutil. exe bez `/r` přepínače u služby, která používá typovou datovou sadu, je automaticky vybrán alternativní serializátor (XmlSerializer).</span><span class="sxs-lookup"><span data-stu-id="b91c2-307">If you attempt to use a Svcutil.exe without the `/r` switch on a service that uses a typed dataset, an alternative serializer (XmlSerializer) is automatically selected.</span></span> <span data-ttu-id="b91c2-308">Pokud je nutné použít DataContractSerializer a musí generovat datové sady ze schématu, můžete použít následující postup: vygenerujte typové typy datových sad (pomocí nástroje XSD. exe s `/d` přepínačem ve službě), zkompilujte typy a pak na ně nasměrujte pomocí `/r` přepínače v Svcutil. exe.</span><span class="sxs-lookup"><span data-stu-id="b91c2-308">If you must use the DataContractSerializer and must generate DataSets from schema, you can use the following procedure: generate the typed DataSet types (by using the Xsd.exe tool with the `/d` switch on the service), compile the types, and then point to them using the `/r` switch on Svcutil.exe.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="b91c2-309">Viz také</span><span class="sxs-lookup"><span data-stu-id="b91c2-309">See also</span></span>

- <xref:System.Runtime.Serialization.DataContractSerializer>
- <xref:System.Xml.Serialization.IXmlSerializable>
- [<span data-ttu-id="b91c2-310">Použití kontraktů dat</span><span class="sxs-lookup"><span data-stu-id="b91c2-310">Using Data Contracts</span></span>](using-data-contracts.md)
- [<span data-ttu-id="b91c2-311">Typy podporované serializátorem kontraktu dat</span><span class="sxs-lookup"><span data-stu-id="b91c2-311">Types Supported by the Data Contract Serializer</span></span>](types-supported-by-the-data-contract-serializer.md)
