---
title: Používání třídy Message
description: Přečtěte si o třídě zprávy, která je základem pro WCF. Je nutné programovat pomocí třídy zpráv přímo pouze v některých pokročilých scénářích.
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
ms.assetid: d1d62bfb-2aa3-4170-b6f8-c93d3afdbbed
ms.openlocfilehash: f806e257cfd3ccc5118a5783e2eda48eef4ba0bf
ms.sourcegitcommit: 358a28048f36a8dca39a9fe6e6ac1f1913acadd5
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 06/23/2020
ms.locfileid: "85246490"
---
# <a name="using-the-message-class"></a><span data-ttu-id="cc2e1-104">Používání třídy Message</span><span class="sxs-lookup"><span data-stu-id="cc2e1-104">Using the Message Class</span></span>
<span data-ttu-id="cc2e1-105"><xref:System.ServiceModel.Channels.Message>Třída je zásadní pro Windows Communication Foundation (WCF).</span><span class="sxs-lookup"><span data-stu-id="cc2e1-105">The <xref:System.ServiceModel.Channels.Message> class is fundamental to Windows Communication Foundation (WCF).</span></span> <span data-ttu-id="cc2e1-106">Veškerá komunikace mezi klienty a službami nakonec vede k <xref:System.ServiceModel.Channels.Message> posílání a přijímání instancí.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-106">All communication between clients and services ultimately results in <xref:System.ServiceModel.Channels.Message> instances being sent and received.</span></span>  
  
 <span data-ttu-id="cc2e1-107">Nebudete obvykle pracovat s <xref:System.ServiceModel.Channels.Message> třídou přímo.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-107">You would not usually interact with the <xref:System.ServiceModel.Channels.Message> class directly.</span></span> <span data-ttu-id="cc2e1-108">Místo toho se k popisu příchozích a odchozích zpráv používají konstrukce modelu služby WCF, například kontrakty dat, kontrakty zpráv a kontrakty operací.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-108">Instead, WCF service model constructs, such as data contracts, message contracts, and operation contracts, are used to describe incoming and outgoing messages.</span></span> <span data-ttu-id="cc2e1-109">V některých pokročilých scénářích však můžete programovat přímo pomocí <xref:System.ServiceModel.Channels.Message> třídy.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-109">However, in some advanced scenarios you can program using the <xref:System.ServiceModel.Channels.Message> class directly.</span></span> <span data-ttu-id="cc2e1-110">Například může být vhodné použít <xref:System.ServiceModel.Channels.Message> třídu:</span><span class="sxs-lookup"><span data-stu-id="cc2e1-110">For example, you might want to use the <xref:System.ServiceModel.Channels.Message> class:</span></span>  
  
- <span data-ttu-id="cc2e1-111">Pokud potřebujete alternativní způsob vytváření obsahu odchozí zprávy (například vytvoření zprávy přímo ze souboru na disku) místo serializace .NET Framework objektů.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-111">When you need an alternative way of creating outgoing message contents (for example, creating a message directly from a file on disk) instead of serializing .NET Framework objects.</span></span>  
  
- <span data-ttu-id="cc2e1-112">Pokud potřebujete alternativní způsob použití příchozího obsahu zprávy (například pokud chcete použít transformaci XSLT na nezpracovaný obsah XML) místo deserializace do objektů .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-112">When you need an alternative way of using incoming message contents (for example, when you want to apply an XSLT transformation to the raw XML contents) instead of deserializing into .NET Framework objects.</span></span>  
  
- <span data-ttu-id="cc2e1-113">Pokud potřebujete, aby se zprávy všeobecně vyrovnaly bez ohledu na obsah zpráv (například při směrování nebo předávání zpráv při sestavování směrovače, Vyrovnávání zatížení nebo systému pro publikování a odběr).</span><span class="sxs-lookup"><span data-stu-id="cc2e1-113">When you need to deal with messages in a general way regardless of message contents (for example, when routing or forwarding messages when building a router, load-balancer, or a publish-subscribe system).</span></span>  
  
 <span data-ttu-id="cc2e1-114">Před použitím <xref:System.ServiceModel.Channels.Message> třídy se seznamte s architekturou přenosu dat WCF v [přenos dat přehled architektury](data-transfer-architectural-overview.md).</span><span class="sxs-lookup"><span data-stu-id="cc2e1-114">Before using the <xref:System.ServiceModel.Channels.Message> class, familiarize yourself with the WCF data transfer architecture in [Data Transfer Architectural Overview](data-transfer-architectural-overview.md).</span></span>  
  
 <span data-ttu-id="cc2e1-115"><xref:System.ServiceModel.Channels.Message>Pro data je kontejner pro obecné účely, ale jeho návrh úzce sleduje návrh zprávy v protokolu SOAP.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-115">A <xref:System.ServiceModel.Channels.Message> is a general-purpose container for data, but its design closely follows the design of a message in the SOAP protocol.</span></span> <span data-ttu-id="cc2e1-116">Stejně jako v protokolu SOAP, zpráva obsahuje i tělo zprávy a záhlaví.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-116">Just like in SOAP, a message has both a message body and headers.</span></span> <span data-ttu-id="cc2e1-117">Tělo zprávy obsahuje skutečná data datové části, zatímco hlavičky obsahují další pojmenované datové kontejnery.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-117">The message body contains the actual payload data, while the headers contain additional named data containers.</span></span> <span data-ttu-id="cc2e1-118">Pravidla pro čtení a zápis těla a záhlaví jsou odlišná, například hlavičky jsou v paměti vždy uloženy do vyrovnávací paměti a mohou být v libovolném pořadí k dispozici v libovolném pořadí, zatímco tělo může být načteno pouze jednou a může být použito jako datový proud.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-118">The rules for reading and writing the body and the headers are different, for example, the headers are always buffered in memory and may be accessed in any order any number of times, while the body may be read only once and may be streamed.</span></span> <span data-ttu-id="cc2e1-119">V normálním případě při použití protokolu SOAP je tělo zprávy namapováno na tělo protokolu SOAP a hlavičky zprávy jsou namapovány na hlavičky protokolu SOAP.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-119">Normally, when using SOAP, the message body is mapped to the SOAP body and the message headers are mapped to the SOAP headers.</span></span>  
  
## <a name="using-the-message-class-in-operations"></a><span data-ttu-id="cc2e1-120">Použití třídy zpráv v operacích</span><span class="sxs-lookup"><span data-stu-id="cc2e1-120">Using the Message Class in Operations</span></span>  
 <span data-ttu-id="cc2e1-121">Třídu můžete použít <xref:System.ServiceModel.Channels.Message> jako vstupní parametr operace, návratovou hodnotu operace nebo obojí.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-121">You can use the <xref:System.ServiceModel.Channels.Message> class as an input parameter of an operation, the return value of an operation, or both.</span></span> <span data-ttu-id="cc2e1-122">Pokud <xref:System.ServiceModel.Channels.Message> se použije kdekoli v operaci, platí následující omezení:</span><span class="sxs-lookup"><span data-stu-id="cc2e1-122">If <xref:System.ServiceModel.Channels.Message> is used anywhere in an operation, the following restrictions apply:</span></span>  
  
- <span data-ttu-id="cc2e1-123">Operace nemůže mít žádné `out` parametry ani `ref` .</span><span class="sxs-lookup"><span data-stu-id="cc2e1-123">The operation cannot have any `out` or `ref` parameters.</span></span>  
  
- <span data-ttu-id="cc2e1-124">Nemůžete mít více než jeden `input` parametr.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-124">There cannot be more than one `input` parameter.</span></span> <span data-ttu-id="cc2e1-125">Pokud je parametr přítomen, musí být buď zpráva nebo typ kontraktu zprávy.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-125">If the parameter is present, it must be either Message or a message contract type.</span></span>  
  
- <span data-ttu-id="cc2e1-126">Návratový typ musí být buď `void` , `Message` nebo typ kontraktu zprávy.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-126">The return type must be either `void`, `Message`, or a message contract type.</span></span>  
  
 <span data-ttu-id="cc2e1-127">Následující příklad kódu obsahuje platný kontrakt operace.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-127">The following code example contains a valid operation contract.</span></span>  
  
 [!code-csharp[C_UsingTheMessageClass#1](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_usingthemessageclass/cs/source.cs#1)]
 [!code-vb[C_UsingTheMessageClass#1](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_usingthemessageclass/vb/source.vb#1)]  
  
## <a name="creating-basic-messages"></a><span data-ttu-id="cc2e1-128">Vytváření základních zpráv</span><span class="sxs-lookup"><span data-stu-id="cc2e1-128">Creating Basic Messages</span></span>  
 <span data-ttu-id="cc2e1-129"><xref:System.ServiceModel.Channels.Message>Třída poskytuje statické `CreateMessage` metody továrny, které lze použít k vytvoření základních zpráv.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-129">The <xref:System.ServiceModel.Channels.Message> class provides static `CreateMessage` factory methods that you can use to create basic messages.</span></span>  
  
 <span data-ttu-id="cc2e1-130">Všechna `CreateMessage` přetížení přebírají parametr verze typu <xref:System.ServiceModel.Channels.MessageVersion> , který označuje verze SOAP a WS-Addressing, které mají být použity pro zprávu.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-130">All `CreateMessage` overloads take a version parameter of type <xref:System.ServiceModel.Channels.MessageVersion> that indicates the SOAP and WS-Addressing versions to use for the message.</span></span> <span data-ttu-id="cc2e1-131">Pokud chcete použít stejné verze protokolů jako příchozí zprávy, můžete použít <xref:System.ServiceModel.OperationContext.IncomingMessageVersion%2A> vlastnost u <xref:System.ServiceModel.OperationContext> instance získané z <xref:System.ServiceModel.OperationContext.Current%2A> Vlastnosti.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-131">If you want to use the same protocol versions as the incoming message, you can use the <xref:System.ServiceModel.OperationContext.IncomingMessageVersion%2A> property on the <xref:System.ServiceModel.OperationContext> instance obtained from the <xref:System.ServiceModel.OperationContext.Current%2A> property.</span></span> <span data-ttu-id="cc2e1-132">Většina `CreateMessage` přetížení má také řetězcový parametr, který označuje akci SOAP, která se má použít pro zprávu.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-132">Most `CreateMessage` overloads also have a string parameter that indicates the SOAP action to use for the message.</span></span> <span data-ttu-id="cc2e1-133">Verze se dá nastavit tak, aby `None` se zakázalo generování obálky protokolu SOAP. zpráva se skládá jenom z těla.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-133">Version can be set to `None` to disable SOAP envelope generation; the message consists of only the body.</span></span>  
  
## <a name="creating-messages-from-objects"></a><span data-ttu-id="cc2e1-134">Vytváření zpráv z objektů</span><span class="sxs-lookup"><span data-stu-id="cc2e1-134">Creating Messages from Objects</span></span>  
 <span data-ttu-id="cc2e1-135">Základní `CreateMessage` přetížení, které přijímá pouze verzi a akci, vytvoří zprávu s prázdným textem.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-135">The most basic `CreateMessage` overload that takes only a version and an action creates a message with an empty body.</span></span> <span data-ttu-id="cc2e1-136">Jiné přetížení přebírá další <xref:System.Object> parametr. tím se vytvoří zpráva, jejíž tělo je serializovaná reprezentace daného objektu.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-136">Another overload takes an additional <xref:System.Object> parameter; this creates a message whose body is the serialized representation of the given object.</span></span> <span data-ttu-id="cc2e1-137"><xref:System.Runtime.Serialization.DataContractSerializer>Pro serializaci použijte výchozí nastavení.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-137">Use the <xref:System.Runtime.Serialization.DataContractSerializer> with default settings for serialization.</span></span> <span data-ttu-id="cc2e1-138">Pokud chcete použít jiný serializátor nebo chcete nakonfigurovat jiné nastavení `DataContractSerializer` , použijte `CreateMessage` přetížení, které také převezme `XmlObjectSerializer` parametr.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-138">If you want to use a different serializer, or you want the `DataContractSerializer` configured differently, use the `CreateMessage` overload that also takes an `XmlObjectSerializer` parameter.</span></span>  
  
 <span data-ttu-id="cc2e1-139">Například chcete-li vrátit objekt ve zprávě, můžete použít následující kód.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-139">For example, to return an object in a message, you can use the following code.</span></span>  
  
 [!code-csharp[C_UsingTheMessageClass#2](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_usingthemessageclass/cs/source.cs#2)]
 [!code-vb[C_UsingTheMessageClass#2](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_usingthemessageclass/vb/source.vb#2)]  
  
## <a name="creating-messages-from-xml-readers"></a><span data-ttu-id="cc2e1-140">Vytváření zpráv z čtecích zařízení XML</span><span class="sxs-lookup"><span data-stu-id="cc2e1-140">Creating Messages from XML Readers</span></span>  
 <span data-ttu-id="cc2e1-141">Existují `CreateMessage` přetížení, která přijímají <xref:System.Xml.XmlReader> nebo <xref:System.Xml.XmlDictionaryReader> pro tělo místo objektu.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-141">There are `CreateMessage` overloads that take an <xref:System.Xml.XmlReader> or an <xref:System.Xml.XmlDictionaryReader> for the body instead of an object.</span></span> <span data-ttu-id="cc2e1-142">V tomto případě tělo zprávy obsahuje kód XML, který je výsledkem čtení z předaného čtecího modulu XML.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-142">In this case, the body of the message contains the XML that results from reading from the passed XML reader.</span></span> <span data-ttu-id="cc2e1-143">Například následující kód vrátí zprávu s obsahem textu načteného ze souboru XML.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-143">For example, the following code returns a message with body contents read from an XML file.</span></span>  
  
 [!code-csharp[C_UsingTheMessageClass#3](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_usingthemessageclass/cs/source.cs#3)]
 [!code-vb[C_UsingTheMessageClass#3](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_usingthemessageclass/vb/source.vb#3)]  
  
 <span data-ttu-id="cc2e1-144">Kromě toho existují `CreateMessage` přetížení, která přijímají <xref:System.Xml.XmlReader> nebo <xref:System.Xml.XmlDictionaryReader> který představuje celou zprávu, a ne jenom tělo.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-144">Additionally, there are `CreateMessage` overloads that take an <xref:System.Xml.XmlReader> or an <xref:System.Xml.XmlDictionaryReader> that represents the entire message and not just the body.</span></span> <span data-ttu-id="cc2e1-145">Tato přetížení také přebírají celočíselný `maxSizeOfHeaders` parametr.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-145">These overloads also take an integer `maxSizeOfHeaders` parameter.</span></span> <span data-ttu-id="cc2e1-146">Hlavičky jsou vždy uloženy do vyrovnávací paměti ihned po vytvoření zprávy a tento parametr omezuje velikost vyrovnávací paměti, která je provedena.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-146">Headers are always buffered into memory as soon as the message is created, and this parameter limits the amount of buffering that takes place.</span></span> <span data-ttu-id="cc2e1-147">Je důležité nastavit tento parametr na bezpečnou hodnotu, pokud XML pochází z nedůvěryhodného zdroje, aby se zmírnila možnost útoku DOS (Denial of Service).</span><span class="sxs-lookup"><span data-stu-id="cc2e1-147">It is important to set this parameter to a safe value if the XML is coming from an untrusted source to mitigate the possibility of a denial of service attack.</span></span> <span data-ttu-id="cc2e1-148">Verze zprávy SOAP a WS-Addressing, kterou čtečka XML představuje, musí odpovídat verzím uvedeným pomocí parametru Version.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-148">The SOAP and WS-Addressing versions of the message the XML reader represents must match the versions indicated using the version parameter.</span></span>  
  
## <a name="creating-messages-with-bodywriter"></a><span data-ttu-id="cc2e1-149">Vytváření zpráv pomocí BodyWriter</span><span class="sxs-lookup"><span data-stu-id="cc2e1-149">Creating Messages with BodyWriter</span></span>  
 <span data-ttu-id="cc2e1-150">Jedno `CreateMessage` Přetížení přebírá `BodyWriter` instanci, která popisuje tělo zprávy.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-150">One `CreateMessage` overload takes a `BodyWriter` instance to describe the body of the message.</span></span> <span data-ttu-id="cc2e1-151">`BodyWriter`Je abstraktní třída, která může být odvozena pro přizpůsobení způsobu vytvoření těla zprávy.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-151">A `BodyWriter` is an abstract class that can be derived to customize how message bodies are created.</span></span> <span data-ttu-id="cc2e1-152">Můžete vytvořit vlastní `BodyWriter` odvozenou třídu pro popis těla zprávy vlastním způsobem.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-152">You can create your own `BodyWriter` derived class to describe message bodies in a custom way.</span></span> <span data-ttu-id="cc2e1-153">Musíte přepsat `BodyWriter.OnWriteBodyContents` metodu, která přijímá. <xref:System.Xml.XmlDictionaryWriter> Tato metoda zodpovídá za vypsání těla.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-153">You must override the `BodyWriter.OnWriteBodyContents` method that takes an <xref:System.Xml.XmlDictionaryWriter>; this method is responsible for writing out the body.</span></span>  
  
 <span data-ttu-id="cc2e1-154">Zapisovače textu lze ukládat do vyrovnávací paměti nebo bez vyrovnávací paměti (streamované).</span><span class="sxs-lookup"><span data-stu-id="cc2e1-154">Body writers can be buffered or non-buffered (streamed).</span></span> <span data-ttu-id="cc2e1-155">Zapisovače těla obsahu ve vyrovnávací paměti může kdykoliv vypsat svůj obsah, zatímco streamované objekty můžou obsah jenom jednou zapsat.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-155">Buffered body writers can write out their contents any number of times, while streamed ones can write out their contents only once.</span></span> <span data-ttu-id="cc2e1-156">`IsBuffered`Vlastnost označuje, zda je zapisovač textu zprávy ukládán do vyrovnávací paměti.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-156">The `IsBuffered` property indicates whether a body writer is buffered or not.</span></span> <span data-ttu-id="cc2e1-157">Můžete jej nastavit pro zapisovač těla voláním chráněného `BodyWriter` konstruktoru, který přebírá `isBuffered` logický parametr.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-157">You can set this for your body writer by calling the protected `BodyWriter` constructor that takes an `isBuffered` boolean parameter.</span></span> <span data-ttu-id="cc2e1-158">Autoři textu podporují vytvoření zapisovače těla zprávy z neuloženého zapisovače těla.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-158">Body writers support creating a buffered body writer from a non-buffered body writer.</span></span> <span data-ttu-id="cc2e1-159">Můžete přepsat `OnCreateBufferedCopy` metodu pro přizpůsobení tohoto procesu.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-159">You can override the `OnCreateBufferedCopy` method to customize this process.</span></span> <span data-ttu-id="cc2e1-160">Ve výchozím nastavení je použita vyrovnávací paměť, která obsahuje kód XML vrácený funkcí `OnWriteBodyContents` .</span><span class="sxs-lookup"><span data-stu-id="cc2e1-160">By default, an in-memory buffer that contains the XML returned by `OnWriteBodyContents` is used.</span></span> <span data-ttu-id="cc2e1-161">`OnCreateBufferedCopy`přebírá `maxBufferSize` celočíselný parametr; Pokud přepíšete tuto metodu, nemusíte vytvářet vyrovnávací paměti větší, než je tato maximální velikost.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-161">`OnCreateBufferedCopy` takes a `maxBufferSize` integer parameter; if you override this method, you must not create buffers larger than this maximum size.</span></span>  
  
 <span data-ttu-id="cc2e1-162">`BodyWriter`Třída poskytuje `WriteBodyContents` `CreateBufferedCopy` metody a, které jsou v podstatě tenké obálky kolem `OnWriteBodyContents` a `OnCreateBufferedCopy` metody, v uvedeném pořadí.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-162">The `BodyWriter` class provides the `WriteBodyContents` and `CreateBufferedCopy` methods, which are essentially thin wrappers around `OnWriteBodyContents` and `OnCreateBufferedCopy` methods, respectively.</span></span> <span data-ttu-id="cc2e1-163">Tyto metody provádějí kontrolu stavu, aby se zajistilo, že zapisovači těla bez vyrovnávací paměti není k dispozici více než jednou.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-163">These methods perform state checking to ensure that a non-buffered body writer is not accessed more than once.</span></span> <span data-ttu-id="cc2e1-164">Tyto metody jsou volány přímo pouze při vytváření vlastních `Message` odvozených tříd založených na `BodyWriters` .</span><span class="sxs-lookup"><span data-stu-id="cc2e1-164">These methods are called directly only when creating custom `Message` derived classes based on `BodyWriters`.</span></span>  
  
## <a name="creating-fault-messages"></a><span data-ttu-id="cc2e1-165">Vytváření zpráv o chybách</span><span class="sxs-lookup"><span data-stu-id="cc2e1-165">Creating Fault Messages</span></span>  
 <span data-ttu-id="cc2e1-166">Můžete použít určitá `CreateMessage` přetížení k vytvoření zpráv o chybách protokolu SOAP.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-166">You can use certain `CreateMessage` overloads to create SOAP fault messages.</span></span> <span data-ttu-id="cc2e1-167">Nejzákladnější z nich přebírá <xref:System.ServiceModel.Channels.MessageFault> objekt, který popisuje chybu.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-167">The most basic of these takes a <xref:System.ServiceModel.Channels.MessageFault> object that describes the fault.</span></span> <span data-ttu-id="cc2e1-168">Další přetížení jsou k dispozici pro usnadnění.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-168">Other overloads are provided for convenience.</span></span> <span data-ttu-id="cc2e1-169">První takové přetížení získá `FaultCode` řetězec důvod a a vytvoří `MessageFault` pomocí `MessageFault.CreateFault` těchto informací.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-169">The first such overload takes a `FaultCode` and a reason string and creates a `MessageFault` using `MessageFault.CreateFault` using this information.</span></span> <span data-ttu-id="cc2e1-170">Druhé přetížení přebírá objekt detail a také ho předává `CreateFault` spolu s kódem chyby a důvodem.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-170">The other overload takes a detail object and also passes it to `CreateFault` together with the fault code and the reason.</span></span> <span data-ttu-id="cc2e1-171">Například následující operace vrátí chybu.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-171">For example, the following operation returns a fault.</span></span>  
  
 [!code-csharp[C_UsingTheMessageClass#4](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_usingthemessageclass/cs/source.cs#4)]
 [!code-vb[C_UsingTheMessageClass#4](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_usingthemessageclass/vb/source.vb#4)]  
  
## <a name="extracting-message-body-data"></a><span data-ttu-id="cc2e1-172">Extrakce dat těla zprávy</span><span class="sxs-lookup"><span data-stu-id="cc2e1-172">Extracting Message Body Data</span></span>  
 <span data-ttu-id="cc2e1-173">`Message`Třída podporuje více způsobů extrakce informací z těla.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-173">The `Message` class supports multiple ways of extracting information from its body.</span></span> <span data-ttu-id="cc2e1-174">Tyto kategorie je možné klasifikovat v následujících kategoriích:</span><span class="sxs-lookup"><span data-stu-id="cc2e1-174">These can be classified into the following categories:</span></span>  
  
- <span data-ttu-id="cc2e1-175">Získání celého textu zprávy zapsaného najednou do zapisovače XML.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-175">Getting the entire message body written out at once to an XML writer.</span></span> <span data-ttu-id="cc2e1-176">To se označuje jako *zápis zprávy*.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-176">This is referred to as *writing a message*.</span></span>  
  
- <span data-ttu-id="cc2e1-177">Získání čtecího modulu XML přes tělo zprávy</span><span class="sxs-lookup"><span data-stu-id="cc2e1-177">Getting an XML reader over the message body.</span></span> <span data-ttu-id="cc2e1-178">To vám umožní později získat přístup k hlavnímu textu zprávy podle potřeby.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-178">This enables you to later access the message body piece-by-piece as required.</span></span> <span data-ttu-id="cc2e1-179">Tento postup se označuje jako *čtení zprávy*.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-179">This is referred to as *reading a message*.</span></span>  
  
- <span data-ttu-id="cc2e1-180">Celou zprávu, včetně jejího těla, lze zkopírovat do vyrovnávací paměti typu v paměti <xref:System.ServiceModel.Channels.MessageBuffer> .</span><span class="sxs-lookup"><span data-stu-id="cc2e1-180">The entire message, including its body, can be copied to an in-memory buffer of the <xref:System.ServiceModel.Channels.MessageBuffer> type.</span></span> <span data-ttu-id="cc2e1-181">Tento postup se označuje jako *kopírování zprávy*.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-181">This is referred to as *copying a message*.</span></span>  
  
 <span data-ttu-id="cc2e1-182">K obsahu můžete přistupovat `Message` jenom jednou, a to bez ohledu na to, jak k němu přistupuje.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-182">You can access the body of a `Message` only once, regardless of how it is accessed.</span></span> <span data-ttu-id="cc2e1-183">Objekt zprávy má `State` vlastnost, která je zpočátku nastavena na hodnotu vytvořeno.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-183">A message object has a `State` property, which is initially set to Created.</span></span> <span data-ttu-id="cc2e1-184">Tři metody přístupu popsané v předchozím seznamu nastaví stav na zapsat, číst a kopírovat, v uvedeném pořadí.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-184">The three access methods described in the preceding list set the state to Written, Read, and Copied, respectively.</span></span> <span data-ttu-id="cc2e1-185">Kromě toho `Close` může metoda nastavit stav na uzavřeno, pokud již není požadován obsah textu zprávy.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-185">Additionally, a `Close` method can set the state to Closed when the message body contents are no longer required.</span></span> <span data-ttu-id="cc2e1-186">Tělo zprávy lze použít pouze ve stavu vytvořeno a neexistuje žádný způsob, jak se vrátit do stavu Created po změně stavu.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-186">The message body can be accessed only in the Created state, and there is no way to go back to the Created state after the state has changed.</span></span>  
  
## <a name="writing-messages"></a><span data-ttu-id="cc2e1-187">Zápis zpráv</span><span class="sxs-lookup"><span data-stu-id="cc2e1-187">Writing Messages</span></span>  
 <span data-ttu-id="cc2e1-188"><xref:System.ServiceModel.Channels.Message.WriteBodyContents%28System.Xml.XmlDictionaryWriter%29>Metoda zapisuje obsah těla dané `Message` instance do daného zapisovače XML.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-188">The <xref:System.ServiceModel.Channels.Message.WriteBodyContents%28System.Xml.XmlDictionaryWriter%29> method writes out the body contents of a given `Message` instance to a given XML writer.</span></span> <span data-ttu-id="cc2e1-189"><xref:System.ServiceModel.Channels.Message.WriteBody%2A>Metoda se shoduje s tím rozdílem, že obklopuje obsah těla v příslušném prvku obálky (například <`soap:body`>).</span><span class="sxs-lookup"><span data-stu-id="cc2e1-189">The <xref:System.ServiceModel.Channels.Message.WriteBody%2A> method does the same, except that it encloses the body contents in the appropriate wrapper element (for example, <`soap:body`>).</span></span> <span data-ttu-id="cc2e1-190">Nakonec <xref:System.ServiceModel.Channels.Message.WriteMessage%2A> zapíše celou zprávu, včetně obálky s obálkami protokolu SOAP a záhlaví.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-190">Finally, <xref:System.ServiceModel.Channels.Message.WriteMessage%2A> writes out the entire message, including the wrapping SOAP envelope and the headers.</span></span> <span data-ttu-id="cc2e1-191">Pokud je protokol SOAP vypnutý ( <xref:System.ServiceModel.Channels.Message.Version> je <xref:System.ServiceModel.Channels.MessageVersion.None?displayProperty=nameWithType> ), všechny tři metody mají stejnou věc: zapisují obsah textu zprávy.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-191">If SOAP is turned off (<xref:System.ServiceModel.Channels.Message.Version> is <xref:System.ServiceModel.Channels.MessageVersion.None?displayProperty=nameWithType>), all three methods do the same thing: they write out the message body contents.</span></span>  
  
 <span data-ttu-id="cc2e1-192">Například následující kód zapíše tělo příchozí zprávy do souboru.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-192">For example, the following code writes out the body of an incoming message to a file.</span></span>  
  
 [!code-csharp[C_UsingTheMessageClass#5](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_usingthemessageclass/cs/source.cs#5)]
 [!code-vb[C_UsingTheMessageClass#5](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_usingthemessageclass/vb/source.vb#5)]  
  
 <span data-ttu-id="cc2e1-193">Dvě další pomocné metody zapisují určité značky počátečního elementu SOAP.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-193">Two additional helper methods write out certain SOAP start element tags.</span></span> <span data-ttu-id="cc2e1-194">Tyto metody nepřístupují k tělo zprávy, takže nemění stav zprávy.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-194">These methods do not access the message body and so they do not change the message state.</span></span> <span data-ttu-id="cc2e1-195">Zde jsou některé z nich:</span><span class="sxs-lookup"><span data-stu-id="cc2e1-195">These include:</span></span>  
  
- <span data-ttu-id="cc2e1-196"><xref:System.ServiceModel.Channels.Message.WriteStartBody%2A>zapíše element počáteční text, například `<soap:Body>` .</span><span class="sxs-lookup"><span data-stu-id="cc2e1-196"><xref:System.ServiceModel.Channels.Message.WriteStartBody%2A> writes the start body element, for example, `<soap:Body>`.</span></span>  
  
- <span data-ttu-id="cc2e1-197"><xref:System.ServiceModel.Channels.Message.WriteStartEnvelope%2A>zapisuje spouštěcí obálku, například `<soap:Envelope>` .</span><span class="sxs-lookup"><span data-stu-id="cc2e1-197"><xref:System.ServiceModel.Channels.Message.WriteStartEnvelope%2A> writes the start envelope element, for example, `<soap:Envelope>`.</span></span>  
  
 <span data-ttu-id="cc2e1-198">Chcete-li zapsat odpovídající značky elementu end, zavolejte `WriteEndElement` na odpovídající ZAPISOVAČ XML.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-198">To write the corresponding end element tags, call `WriteEndElement` on the corresponding XML writer.</span></span> <span data-ttu-id="cc2e1-199">Tyto metody jsou volány pouze zřídka.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-199">These methods are rarely called directly.</span></span>  
  
## <a name="reading-messages"></a><span data-ttu-id="cc2e1-200">Čtení zpráv</span><span class="sxs-lookup"><span data-stu-id="cc2e1-200">Reading Messages</span></span>  
 <span data-ttu-id="cc2e1-201">Hlavní způsob, jak číst tělo zprávy, je zavolat <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents%2A> .</span><span class="sxs-lookup"><span data-stu-id="cc2e1-201">The primary way to read a message body is to call <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents%2A>.</span></span> <span data-ttu-id="cc2e1-202">Vrátíte se zpátky <xref:System.Xml.XmlDictionaryReader> , který můžete použít ke čtení textu zprávy.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-202">You get back an <xref:System.Xml.XmlDictionaryReader> that you can use to read the message body.</span></span> <span data-ttu-id="cc2e1-203">Všimněte si, že <xref:System.ServiceModel.Channels.Message> přechody do stavu čtení hned po <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents%2A> volání, a ne při použití vráceného čtecího modulu XML.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-203">Note that the <xref:System.ServiceModel.Channels.Message> transitions to the Read state as soon as <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents%2A> is called, and not when you use the returned XML reader.</span></span>  
  
 <span data-ttu-id="cc2e1-204"><xref:System.ServiceModel.Channels.Message.GetBody%2A>Metoda také umožňuje přístup k tělo zprávy jako typový objekt.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-204">The <xref:System.ServiceModel.Channels.Message.GetBody%2A> method also enables you to access the message body as a typed object.</span></span> <span data-ttu-id="cc2e1-205">Interně používá tato metoda `GetReaderAtBodyContents` , a proto také přechází stav zprávy do <xref:System.ServiceModel.Channels.MessageState.Read> stavu (viz <xref:System.ServiceModel.Channels.Message.State%2A> vlastnost).</span><span class="sxs-lookup"><span data-stu-id="cc2e1-205">Internally, this method uses `GetReaderAtBodyContents`, and so it also transitions the message state to the <xref:System.ServiceModel.Channels.MessageState.Read> state (see the <xref:System.ServiceModel.Channels.Message.State%2A> property).</span></span>  
  
 <span data-ttu-id="cc2e1-206">Je vhodné kontrolovat <xref:System.ServiceModel.Channels.Message.IsEmpty%2A> vlastnost, v takovém případě je tělo zprávy prázdné a <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents%2A> vyvolá <xref:System.InvalidOperationException> .</span><span class="sxs-lookup"><span data-stu-id="cc2e1-206">It is good practice to check the <xref:System.ServiceModel.Channels.Message.IsEmpty%2A> property, in which case the message body is empty and <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents%2A> throws an <xref:System.InvalidOperationException>.</span></span> <span data-ttu-id="cc2e1-207">Pokud se jedná o přijatou zprávu (například odpověď), můžete také ověřit <xref:System.ServiceModel.Channels.Message.IsFault%2A> , zda zpráva obsahuje chybu.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-207">Also, if it is a received message (for example, the reply), you may also want to check <xref:System.ServiceModel.Channels.Message.IsFault%2A>, which indicates whether the message contains a fault.</span></span>  
  
 <span data-ttu-id="cc2e1-208">Nejzákladnější přetížení <xref:System.ServiceModel.Channels.Message.GetBody%2A> deserializace tělo zprávy do instance typu (označená obecným parametrem) s použitím <xref:System.Runtime.Serialization.DataContractSerializer> konfigurace s výchozím nastavením a <xref:System.Runtime.Serialization.DataContractSerializer.MaxItemsInObjectGraph%2A> zakázanou kvótou.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-208">The most basic overload of <xref:System.ServiceModel.Channels.Message.GetBody%2A> deserializes the message body into an instance of a type (indicated by the generic parameter) using a <xref:System.Runtime.Serialization.DataContractSerializer> configured with the default settings and with the <xref:System.Runtime.Serialization.DataContractSerializer.MaxItemsInObjectGraph%2A> quota disabled.</span></span> <span data-ttu-id="cc2e1-209">Pokud chcete použít jiný Serializační modul nebo nakonfigurovat `DataContractSerializer` nevýchozí způsob, použijte <xref:System.ServiceModel.Channels.Message.GetBody%2A> přetížení, které přijímá <xref:System.Runtime.Serialization.XmlObjectSerializer> .</span><span class="sxs-lookup"><span data-stu-id="cc2e1-209">If you want to use a different serialization engine, or configure the `DataContractSerializer` in a non-default way, use the <xref:System.ServiceModel.Channels.Message.GetBody%2A> overload that takes an <xref:System.Runtime.Serialization.XmlObjectSerializer>.</span></span>  
  
 <span data-ttu-id="cc2e1-210">Například následující kód extrahuje data z textu zprávy, který obsahuje serializovaný `Person` objekt, a vytiskne jméno osoby.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-210">For example, the following code extracts data from a message body that contains a serialized `Person` object and prints out the person’s name.</span></span>  
  
 [!code-csharp[C_UsingTheMessageClass#6](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_usingthemessageclass/cs/source.cs#6)]
 [!code-vb[C_UsingTheMessageClass#6](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_usingthemessageclass/vb/source.vb#6)]  
  
## <a name="copying-a-message-into-a-buffer"></a><span data-ttu-id="cc2e1-211">Kopírování zprávy do vyrovnávací paměti</span><span class="sxs-lookup"><span data-stu-id="cc2e1-211">Copying a Message into a Buffer</span></span>  
 <span data-ttu-id="cc2e1-212">Někdy je nutné mít přístup k tělo zprávy více než jednou, například k přeposílání stejné zprávy do více cílů v rámci systému odběratele vydavatele.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-212">Sometimes it is necessary to access the message body more than once, for example, to forward the same message to multiple destinations as part of a publisher-subscriber system.</span></span> <span data-ttu-id="cc2e1-213">V takovém případě je nutné ukládat celou zprávu (včetně těla) do vyrovnávací paměti.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-213">In this case, it is necessary to buffer the entire message (including the body) in memory.</span></span> <span data-ttu-id="cc2e1-214">Můžete to provést voláním metody <xref:System.ServiceModel.Channels.Message.CreateBufferedCopy%28System.Int32%29> .</span><span class="sxs-lookup"><span data-stu-id="cc2e1-214">You can do this by calling <xref:System.ServiceModel.Channels.Message.CreateBufferedCopy%28System.Int32%29>.</span></span> <span data-ttu-id="cc2e1-215">Tato metoda přebírá celočíselný parametr, který představuje maximální velikost vyrovnávací paměti, a vytváří vyrovnávací paměť, která není větší než tato velikost.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-215">This method takes an integer parameter that represents the maximum buffer size, and creates a buffer not larger than this size.</span></span> <span data-ttu-id="cc2e1-216">Pokud zpráva pochází z nedůvěryhodného zdroje, je nutné ji nastavit na bezpečnou hodnotu.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-216">It is important to set this to a safe value if the message is coming from an untrusted source.</span></span>  
  
 <span data-ttu-id="cc2e1-217">Vyrovnávací paměť se vrátí jako <xref:System.ServiceModel.Channels.MessageBuffer> instance.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-217">The buffer is returned as a <xref:System.ServiceModel.Channels.MessageBuffer> instance.</span></span> <span data-ttu-id="cc2e1-218">K datům ve vyrovnávací paměti se můžete dostat několika způsoby.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-218">You can access data in the buffer in several ways.</span></span> <span data-ttu-id="cc2e1-219">Hlavním způsobem je zavolat <xref:System.ServiceModel.Channels.Message.CreateMessage%2A> na vytvoření `Message` instancí z vyrovnávací paměti.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-219">The primary way is to call <xref:System.ServiceModel.Channels.Message.CreateMessage%2A> to create `Message` instances from the buffer.</span></span>  
  
 <span data-ttu-id="cc2e1-220">Dalším způsobem, jak získat přístup k datům ve vyrovnávací paměti, je implementovat <xref:System.Xml.XPath.IXPathNavigable> rozhraní, které <xref:System.ServiceModel.Channels.MessageBuffer> Třída implementuje pro přímý přístup k základnímu XML.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-220">Another way to access the data in the buffer is to implement the <xref:System.Xml.XPath.IXPathNavigable> interface that the <xref:System.ServiceModel.Channels.MessageBuffer> class implements to access the underlying XML directly.</span></span> <span data-ttu-id="cc2e1-221">Některá <xref:System.ServiceModel.Channels.MessageBuffer.CreateNavigator%2A> přetížení umožňují vytvářet <xref:System.Xml.XPath> navigátory chráněné kvótou uzlu, což omezuje počet uzlů XML, které mohou být navštíveny.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-221">Some <xref:System.ServiceModel.Channels.MessageBuffer.CreateNavigator%2A> overloads allow you to create <xref:System.Xml.XPath> navigators protected by a node quota, limiting the number of XML nodes that can be visited.</span></span> <span data-ttu-id="cc2e1-222">To pomáhá zabránit útokům DOS (Denial of Service) na základě zdlouhavého času zpracování.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-222">This helps prevent denial of service attacks based on lengthy processing time.</span></span> <span data-ttu-id="cc2e1-223">Tato nabídka je ve výchozím nastavení zakázaná.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-223">This quote is disabled by default.</span></span> <span data-ttu-id="cc2e1-224">Některá `CreateNavigator` přetížení umožňují určit, jak se má v XML zpracovat prázdné místo pomocí <xref:System.Xml.XmlSpace> výčtu s výchozím nastavením `XmlSpace.None` .</span><span class="sxs-lookup"><span data-stu-id="cc2e1-224">Some `CreateNavigator` overloads allow you to specify how white space should be handled in the XML using the <xref:System.Xml.XmlSpace> enumeration, with the default being `XmlSpace.None`.</span></span>  
  
 <span data-ttu-id="cc2e1-225">Konečný způsob, jak získat přístup k obsahu vyrovnávací paměti zpráv, je napsat svůj obsah do datového proudu pomocí <xref:System.ServiceModel.Channels.Message.WriteMessage%2A> .</span><span class="sxs-lookup"><span data-stu-id="cc2e1-225">A final way to access the contents of a message buffer is to write out its contents to a stream using <xref:System.ServiceModel.Channels.Message.WriteMessage%2A>.</span></span>  
  
 <span data-ttu-id="cc2e1-226">Následující příklad demonstruje proces práce s `MessageBuffer` : příchozí zpráva je předána více příjemcům a poté zaznamenána do souboru.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-226">The following example demonstrates the process of working with a `MessageBuffer`: an incoming message is forwarded to multiple recipients, and then logged to a file.</span></span> <span data-ttu-id="cc2e1-227">Bez ukládání do vyrovnávací paměti není to možné, protože tělo zprávy je pak možné použít pouze jednou.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-227">Without buffering, this is not possible, because the message body can then be accessed only once.</span></span>  
  
 [!code-csharp[C_UsingTheMessageClass#7](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_usingthemessageclass/cs/source.cs#7)]
 [!code-vb[C_UsingTheMessageClass#7](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_usingthemessageclass/vb/source.vb#7)]  
  
 <span data-ttu-id="cc2e1-228">`MessageBuffer`Třída obsahuje další členy, které se zaznamenaly.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-228">The `MessageBuffer` class has other members worth noting.</span></span> <span data-ttu-id="cc2e1-229"><xref:System.ServiceModel.Channels.MessageBuffer.Close%2A>Metodu lze volat pro uvolnění prostředků, pokud již není požadován obsah vyrovnávací paměti.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-229">The <xref:System.ServiceModel.Channels.MessageBuffer.Close%2A> method can be called to free resources when the buffer contents are no longer required.</span></span> <span data-ttu-id="cc2e1-230"><xref:System.ServiceModel.Channels.MessageBuffer.BufferSize%2A>Vlastnost vrací velikost přidělené vyrovnávací paměti.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-230">The <xref:System.ServiceModel.Channels.MessageBuffer.BufferSize%2A> property returns the size of the allocated buffer.</span></span> <span data-ttu-id="cc2e1-231"><xref:System.ServiceModel.Channels.MessageBuffer.MessageContentType%2A>Vlastnost vrátí typ obsahu MIME zprávy.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-231">The <xref:System.ServiceModel.Channels.MessageBuffer.MessageContentType%2A> property returns the MIME content type of the message.</span></span>  
  
## <a name="accessing-the-message-body-for-debugging"></a><span data-ttu-id="cc2e1-232">Přístup k textu zprávy pro ladění</span><span class="sxs-lookup"><span data-stu-id="cc2e1-232">Accessing the Message Body for Debugging</span></span>  
 <span data-ttu-id="cc2e1-233">Pro účely ladění můžete zavolat <xref:System.ServiceModel.Channels.Message.ToString%2A> metodu pro získání reprezentace zprávy jako řetězce.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-233">For debugging purposes, you can call the <xref:System.ServiceModel.Channels.Message.ToString%2A> method to get a representation of the message as a string.</span></span> <span data-ttu-id="cc2e1-234">Tato reprezentace obecně odpovídá způsobu, jakým by zpráva vypadala v případě, že byla kódována pomocí textového kodéru, s tím rozdílem, že kód XML by byl pro lidské čitelnosti lépe naformátován.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-234">This representation generally matches the way a message would look on the wire if it were encoded with the text encoder, except that the XML would be better formatted for human readability.</span></span> <span data-ttu-id="cc2e1-235">Jedinou výjimkou je tělo zprávy.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-235">The one exception to this is the message body.</span></span> <span data-ttu-id="cc2e1-236">Tělo lze číst pouze jednou a `ToString` nezmění stav zprávy.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-236">The body can be read only once, and `ToString` does not change the message state.</span></span> <span data-ttu-id="cc2e1-237">Proto metoda nemusí `ToString` být schopna získat přístup k textu a může nahradit zástupný symbol (například "..."). nebo tři tečky) místo textu zprávy.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-237">Therefore, the `ToString` method might not be able to access the body and might substitute a placeholder (for example, "…" or three dots) instead of the message body.</span></span> <span data-ttu-id="cc2e1-238">Proto nepoužívejte `ToString` k protokolování zpráv, pokud je obsah zprávy důležitý.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-238">Therefore, do not use `ToString` to log messages if the body content of the messages is important.</span></span>  
  
## <a name="accessing-other-message-parts"></a><span data-ttu-id="cc2e1-239">Přístup k ostatním částem zprávy</span><span class="sxs-lookup"><span data-stu-id="cc2e1-239">Accessing Other Message Parts</span></span>  
 <span data-ttu-id="cc2e1-240">K dispozici jsou různé vlastnosti pro přístup k informacím o jiné zprávě než obsah těla.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-240">Various properties are provided to access information about the message other than its body contents.</span></span> <span data-ttu-id="cc2e1-241">Tyto zprávy však nelze volat, jakmile byla zpráva zavřena:</span><span class="sxs-lookup"><span data-stu-id="cc2e1-241">However, these cannot be called once the message has been closed:</span></span>  
  
- <span data-ttu-id="cc2e1-242"><xref:System.ServiceModel.Channels.Message.Headers%2A>Vlastnost představuje záhlaví zpráv.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-242">The <xref:System.ServiceModel.Channels.Message.Headers%2A> property represents the message headers.</span></span> <span data-ttu-id="cc2e1-243">Další informace najdete v části práce se záhlavími dále v tomto tématu.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-243">See the section on "Working with Headers" later in this topic.</span></span>  
  
- <span data-ttu-id="cc2e1-244"><xref:System.ServiceModel.Channels.Message.Properties%2A>Vlastnost představuje vlastnosti zprávy, které jsou částmi pojmenovaných dat připojených ke zprávě, která obecně není generována při odeslání zprávy.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-244">The <xref:System.ServiceModel.Channels.Message.Properties%2A> property represents the message properties, which are pieces of named data attached to the message that do not generally get emitted when the message is sent.</span></span> <span data-ttu-id="cc2e1-245">Další informace najdete v části práce s vlastnostmi dále v tomto tématu.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-245">See the section on "Working with Properties" later in this topic.</span></span>  
  
- <span data-ttu-id="cc2e1-246"><xref:System.ServiceModel.Channels.Message.Version%2A>Vlastnost označuje verzi SOAP a WS-Addressing, která je přidružená ke zprávě, nebo `None` Pokud je protokol SOAP zakázán.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-246">The <xref:System.ServiceModel.Channels.Message.Version%2A> property indicates the SOAP and WS-Addressing version associated with the message, or `None` if SOAP is disabled.</span></span>  
  
- <span data-ttu-id="cc2e1-247"><xref:System.ServiceModel.Channels.Message.IsFault%2A>Vlastnost vrátí, `true` zda je zpráva chybová zpráva protokolu SOAP.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-247">The <xref:System.ServiceModel.Channels.Message.IsFault%2A> property returns `true` if the message is a SOAP fault message.</span></span>  
  
- <span data-ttu-id="cc2e1-248"><xref:System.ServiceModel.Channels.Message.IsEmpty%2A>Vlastnost vrátí, `true` zda je zpráva prázdná.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-248">The <xref:System.ServiceModel.Channels.Message.IsEmpty%2A> property returns `true` if the message is empty.</span></span>  
  
 <span data-ttu-id="cc2e1-249">Metodu lze použít <xref:System.ServiceModel.Channels.Message.GetBodyAttribute%28System.String%2CSystem.String%29> pro přístup k určitému atributu u prvku obálky těla (například `<soap:Body>` ) identifikovaného určitým názvem a oborem názvů.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-249">You can use the <xref:System.ServiceModel.Channels.Message.GetBodyAttribute%28System.String%2CSystem.String%29> method to access a particular attribute on the body wrapper element (for example, `<soap:Body>`) identified by a particular name and namespace.</span></span> <span data-ttu-id="cc2e1-250">Pokud takový atribut není nalezen, `null` je vrácen.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-250">If such an attribute is not found, `null` is returned.</span></span> <span data-ttu-id="cc2e1-251">Tuto metodu lze volat pouze v případě, že `Message` je ve stavu Created (když tělo zprávy ještě neproběhlo).</span><span class="sxs-lookup"><span data-stu-id="cc2e1-251">This method can be called only when the `Message` is in the Created state (when the message body has not yet been accessed).</span></span>  
  
## <a name="working-with-headers"></a><span data-ttu-id="cc2e1-252">Práce se záhlavími</span><span class="sxs-lookup"><span data-stu-id="cc2e1-252">Working with Headers</span></span>  
 <span data-ttu-id="cc2e1-253">`Message`Může obsahovat libovolný počet jmenovaných fragmentů XML nazývaných *hlavičky*.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-253">A `Message` can contain any number of named XML fragments, called *headers*.</span></span> <span data-ttu-id="cc2e1-254">Jednotlivé fragmenty jsou normálně mapovány na hlavičku SOAP.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-254">Each fragment normally maps to a SOAP header.</span></span> <span data-ttu-id="cc2e1-255">Záhlaví jsou k dispozici prostřednictvím `Headers` vlastnosti typu <xref:System.ServiceModel.Channels.MessageHeaders> .</span><span class="sxs-lookup"><span data-stu-id="cc2e1-255">Headers are accessed through the `Headers` property of type <xref:System.ServiceModel.Channels.MessageHeaders>.</span></span> <span data-ttu-id="cc2e1-256"><xref:System.ServiceModel.Channels.MessageHeaders>je kolekce <xref:System.ServiceModel.Channels.MessageHeaderInfo> objektů a k jednotlivým hlavičkám lze přistupovat prostřednictvím jejího <xref:System.Collections.IEnumerable> rozhraní nebo prostřednictvím indexeru.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-256"><xref:System.ServiceModel.Channels.MessageHeaders> is a collection of <xref:System.ServiceModel.Channels.MessageHeaderInfo> objects, and individual headers can be accessed through its <xref:System.Collections.IEnumerable> interface or through its indexer.</span></span> <span data-ttu-id="cc2e1-257">Například následující kód uvádí názvy všech hlaviček v `Message` .</span><span class="sxs-lookup"><span data-stu-id="cc2e1-257">For example, the following code lists the names of all the headers in a `Message`.</span></span>  
  
 [!code-csharp[C_UsingTheMessageClass#8](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_usingthemessageclass/cs/source.cs#8)]
 [!code-vb[C_UsingTheMessageClass#8](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_usingthemessageclass/vb/source.vb#8)]  
  
#### <a name="adding-removing-finding-headers"></a><span data-ttu-id="cc2e1-258">Přidávání, odebírání a hledání hlaviček</span><span class="sxs-lookup"><span data-stu-id="cc2e1-258">Adding, Removing, Finding Headers</span></span>  
 <span data-ttu-id="cc2e1-259">Novou hlavičku můžete na konci všech existujících hlaviček přidat pomocí <xref:System.ServiceModel.Channels.MessageHeaders.Add%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-259">You can add a new header at the end of all existing headers using the <xref:System.ServiceModel.Channels.MessageHeaders.Add%2A> method.</span></span> <span data-ttu-id="cc2e1-260">Můžete použít <xref:System.ServiceModel.Channels.MessageHeaders.Insert%2A> metodu pro vložení záhlaví do konkrétního indexu.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-260">You can use the <xref:System.ServiceModel.Channels.MessageHeaders.Insert%2A> method to insert a header at a particular index.</span></span> <span data-ttu-id="cc2e1-261">Existující záhlaví jsou pro vloženou položku posunuty.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-261">Existing headers are shifted for the inserted item.</span></span> <span data-ttu-id="cc2e1-262">Záhlaví jsou uspořádána podle jejich indexu a první dostupný index je 0.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-262">Headers are ordered according to their index, and the first available index is 0.</span></span> <span data-ttu-id="cc2e1-263">Pomocí různých <xref:System.ServiceModel.Channels.MessageHeaders.CopyHeadersFrom%2A> přetížení metod můžete přidat záhlaví z jiné `Message` `MessageHeaders` instance nebo.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-263">You can use the various <xref:System.ServiceModel.Channels.MessageHeaders.CopyHeadersFrom%2A> method overloads to add headers from a different `Message` or `MessageHeaders` instance.</span></span> <span data-ttu-id="cc2e1-264">Některá přetížení kopírují jednu jednotlivou hlavičku, zatímco ostatní si je zkopírují.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-264">Some overloads copy one individual header, while others copy all of them.</span></span> <span data-ttu-id="cc2e1-265"><xref:System.ServiceModel.Channels.MessageHeaders.Clear%2A>Metoda odebere všechny hlavičky.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-265">The <xref:System.ServiceModel.Channels.MessageHeaders.Clear%2A> method removes all headers.</span></span> <span data-ttu-id="cc2e1-266"><xref:System.ServiceModel.Channels.MessageHeaders.RemoveAt%2A>Metoda odebere hlavičku na konkrétní index (posune všechna záhlaví za ní).</span><span class="sxs-lookup"><span data-stu-id="cc2e1-266">The <xref:System.ServiceModel.Channels.MessageHeaders.RemoveAt%2A> method removes a header at a particular index (shifting all headers after it).</span></span> <span data-ttu-id="cc2e1-267"><xref:System.ServiceModel.Channels.MessageHeaders.RemoveAll%2A>Metoda odebere všechny hlavičky s určitým názvem a oborem názvů.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-267">The <xref:System.ServiceModel.Channels.MessageHeaders.RemoveAll%2A> method removes all headers with a particular name and namespace.</span></span>  
  
 <span data-ttu-id="cc2e1-268">Načte konkrétní hlavičku pomocí <xref:System.ServiceModel.Channels.MessageHeaders.FindHeader%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-268">Retrieve a particular header using the <xref:System.ServiceModel.Channels.MessageHeaders.FindHeader%2A> method.</span></span> <span data-ttu-id="cc2e1-269">Tato metoda získá název a obor názvů záhlaví, které má být nalezeno, a vrátí jeho index.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-269">This method takes the name and namespace of the header to find, and returns its index.</span></span> <span data-ttu-id="cc2e1-270">Pokud se hlavička vyskytuje více než jednou, je vyvolána výjimka.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-270">If the header occurs more than once, an exception is thrown.</span></span> <span data-ttu-id="cc2e1-271">Pokud záhlaví není nalezeno, vrátí-1.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-271">If the header is not found, it returns -1.</span></span>  
  
 <span data-ttu-id="cc2e1-272">V modelu záhlaví SOAP mohou hlavičky mít `Actor` hodnotu, která určuje zamýšleného příjemce hlavičky.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-272">In the SOAP header model, headers can have an `Actor` value that specifies the intended recipient of the header.</span></span> <span data-ttu-id="cc2e1-273">Nejzákladnější `FindHeader` přetížení vyhledává pouze hlavičky určené pro konečného příjemce zprávy.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-273">The most basic `FindHeader` overload searches only headers intended for the ultimate receiver of the message.</span></span> <span data-ttu-id="cc2e1-274">Další přetížení však umožňuje určit, které `Actor` hodnoty budou zahrnuty ve vyhledávání.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-274">However, another overload enables you to specify which `Actor` values are included in the search.</span></span> <span data-ttu-id="cc2e1-275">Další informace najdete v tématu specifikace SOAP.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-275">For more information, see the SOAP specification.</span></span>  
  
 <span data-ttu-id="cc2e1-276"><xref:System.ServiceModel.Channels.MessageHeaders.CopyTo%28System.ServiceModel.Channels.MessageHeaderInfo%5B%5D%2CSystem.Int32%29>K dispozici je metoda kopírování hlaviček z <xref:System.ServiceModel.Channels.MessageHeaders> kolekce do pole <xref:System.ServiceModel.Channels.MessageHeaderInfo> objektů.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-276">A <xref:System.ServiceModel.Channels.MessageHeaders.CopyTo%28System.ServiceModel.Channels.MessageHeaderInfo%5B%5D%2CSystem.Int32%29> method is provided to copy headers from a <xref:System.ServiceModel.Channels.MessageHeaders> collection to an array of <xref:System.ServiceModel.Channels.MessageHeaderInfo> objects.</span></span>  
  
 <span data-ttu-id="cc2e1-277">Pro přístup k datům XML v hlavičce můžete volat <xref:System.ServiceModel.Channels.MessageHeaders.GetReaderAtHeader%2A> a vracet čtecí modul XML pro konkrétní rejstřík hlaviček.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-277">To access the XML data in a header, you can call <xref:System.ServiceModel.Channels.MessageHeaders.GetReaderAtHeader%2A> and return an XML reader for the specific header index.</span></span> <span data-ttu-id="cc2e1-278">Pokud chcete deserializovat obsah hlavičky do objektu, použijte <xref:System.ServiceModel.Channels.MessageHeaders.GetHeader%60%601%28System.Int32%29> nebo jedno z dalších přetížení.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-278">If you want to deserialize the header contents into an object, use <xref:System.ServiceModel.Channels.MessageHeaders.GetHeader%60%601%28System.Int32%29> or one of the other overloads.</span></span> <span data-ttu-id="cc2e1-279">Většina základních přetížení deserializace hlaviček pomocí <xref:System.Runtime.Serialization.DataContractSerializer> nakonfigurovaného výchozího způsobu.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-279">The most basic overloads deserialize headers using the <xref:System.Runtime.Serialization.DataContractSerializer> configured in the default way.</span></span> <span data-ttu-id="cc2e1-280">Pokud chcete použít jiný serializátor nebo jinou konfiguraci `DataContractSerializer` , použijte jedno z přetížení, které přijímá `XmlObjectSerializer` .</span><span class="sxs-lookup"><span data-stu-id="cc2e1-280">If you want to use a different serializer or a different configuration of the `DataContractSerializer`, use one of the overloads that take an `XmlObjectSerializer`.</span></span> <span data-ttu-id="cc2e1-281">Existují také přetížení, která přijímají název hlavičky, obor názvů a volitelně seznam `Actor` hodnot namísto indexu. Jedná se o kombinaci `FindHeader` a `GetHeader` .</span><span class="sxs-lookup"><span data-stu-id="cc2e1-281">There are also overloads that take the header name, namespace, and optionally a list of `Actor` values instead of an index; this is a combination of `FindHeader` and `GetHeader`.</span></span>  
  
## <a name="working-with-properties"></a><span data-ttu-id="cc2e1-282">Práce s vlastnostmi</span><span class="sxs-lookup"><span data-stu-id="cc2e1-282">Working with Properties</span></span>  
 <span data-ttu-id="cc2e1-283">`Message`Instance může obsahovat libovolný počet pojmenovaných objektů libovolných typů.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-283">A `Message` instance can contain an arbitrary number of named objects of arbitrary types.</span></span> <span data-ttu-id="cc2e1-284">Tato kolekce je k dispozici prostřednictvím `Properties` vlastnosti typu `MessageProperties` .</span><span class="sxs-lookup"><span data-stu-id="cc2e1-284">This collection is accessed through the `Properties` property of type `MessageProperties`.</span></span> <span data-ttu-id="cc2e1-285">Kolekce implementuje <xref:System.Collections.Generic.IDictionary%602> rozhraní a funguje jako mapování z <xref:System.String> na <xref:System.Object> .</span><span class="sxs-lookup"><span data-stu-id="cc2e1-285">The collection implements the <xref:System.Collections.Generic.IDictionary%602> interface and acts as a mapping from <xref:System.String> to <xref:System.Object>.</span></span> <span data-ttu-id="cc2e1-286">Hodnoty vlastností se obvykle nemapují přímo na žádnou část zprávy na lince, ale místo toho poskytují různé pomocné parametry zpracování zpráv pro různé kanály v zásobníku kanálů WCF nebo v <xref:System.ServiceModel.Channels.MessageHeaders.CopyTo%28System.ServiceModel.Channels.MessageHeaderInfo%5B%5D%2CSystem.Int32%29> rozhraní služby.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-286">Normally, property values do not map directly to any part of the message on the wire, but rather provide various message processing hints to the various channels in the WCF channel stack or to the <xref:System.ServiceModel.Channels.MessageHeaders.CopyTo%28System.ServiceModel.Channels.MessageHeaderInfo%5B%5D%2CSystem.Int32%29> service framework.</span></span> <span data-ttu-id="cc2e1-287">Příklad najdete v tématu [Přehled architektury přenos dat](data-transfer-architectural-overview.md).</span><span class="sxs-lookup"><span data-stu-id="cc2e1-287">For an example, see [Data Transfer Architectural Overview](data-transfer-architectural-overview.md).</span></span>  
  
## <a name="inheriting-from-the-message-class"></a><span data-ttu-id="cc2e1-288">Dědění z třídy Message</span><span class="sxs-lookup"><span data-stu-id="cc2e1-288">Inheriting from the Message Class</span></span>  
 <span data-ttu-id="cc2e1-289">Pokud předdefinované typy zpráv vytvořené pomocí `CreateMessage` nesplňují vaše požadavky, vytvořte třídu, která je odvozena z `Message` třídy.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-289">If the built-in message types created using `CreateMessage` do not meet your requirements, create a class that derives from the `Message` class.</span></span>  
  
### <a name="defining-the-message-body-contents"></a><span data-ttu-id="cc2e1-290">Definice obsahu textu zprávy</span><span class="sxs-lookup"><span data-stu-id="cc2e1-290">Defining the Message Body Contents</span></span>  
 <span data-ttu-id="cc2e1-291">Existují tři primární techniky pro přístup k datům v těle zprávy: zápis, čtení a zkopírování do vyrovnávací paměti.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-291">Three primary techniques exist for accessing data within a message body: writing, reading, and copying it to a buffer.</span></span> <span data-ttu-id="cc2e1-292">Tyto operace nakonec vedou k <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%2A> <xref:System.ServiceModel.Channels.Message.OnGetReaderAtBodyContents%2A> volání metod, a v <xref:System.ServiceModel.Channels.Message.OnCreateBufferedCopy%2A> odvozené třídě `Message` .</span><span class="sxs-lookup"><span data-stu-id="cc2e1-292">These operations ultimately result in the <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%2A>, <xref:System.ServiceModel.Channels.Message.OnGetReaderAtBodyContents%2A>, and <xref:System.ServiceModel.Channels.Message.OnCreateBufferedCopy%2A> methods being called, respectively, on your derived class of `Message`.</span></span> <span data-ttu-id="cc2e1-293">Základní `Message` třída zaručuje, že pro každou instanci je volána pouze jedna z těchto metod `Message` a že není volána více než jednou.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-293">The base `Message` class guarantees that only one of these methods is called for each `Message` instance, and that it is not called more than once.</span></span> <span data-ttu-id="cc2e1-294">Základní třída také zajišťuje, že metody nejsou volány na uzavřenou zprávu.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-294">The base class also ensures that the methods are not called on a closed message.</span></span> <span data-ttu-id="cc2e1-295">Stav zprávy ve vaší implementaci není nutné sledovat.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-295">There is no need to track the message state in your implementation.</span></span>  
  
 <span data-ttu-id="cc2e1-296"><xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%2A>je abstraktní metoda a musí být implementována.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-296"><xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%2A> is an abstract method and must be implemented.</span></span> <span data-ttu-id="cc2e1-297">Nejzákladnější způsob, jak definovat obsah těla zprávy, je napsat pomocí této metody.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-297">The most basic way to define the body contents of your message is to write using this method.</span></span> <span data-ttu-id="cc2e1-298">Například následující zpráva obsahuje 100 000 náhodných čísel od 1 do 20.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-298">For example, the following message contains 100,000 random numbers from 1 to 20.</span></span>  
  
 [!code-csharp[C_UsingTheMessageClass#9](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_usingthemessageclass/cs/source.cs#9)]
 [!code-vb[C_UsingTheMessageClass#9](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_usingthemessageclass/vb/source.vb#9)]  
  
 <span data-ttu-id="cc2e1-299"><xref:System.ServiceModel.Channels.Message.OnGetReaderAtBodyContents>Metody a <xref:System.ServiceModel.Channels.Message.OnCreateBufferedCopy%2A> mají výchozí implementace, které fungují ve většině případů.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-299">The <xref:System.ServiceModel.Channels.Message.OnGetReaderAtBodyContents> and <xref:System.ServiceModel.Channels.Message.OnCreateBufferedCopy%2A> methods have default implementations that work for most cases.</span></span> <span data-ttu-id="cc2e1-300">Výchozí implementace implementují <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%2A> , ukládají výsledky do vyrovnávací paměti a pracují s výslednou vyrovnávací pamětí.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-300">The default implementations call <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%2A>, buffer the results, and work with the resulting buffer.</span></span> <span data-ttu-id="cc2e1-301">V některých případech to ale nemusí být dostatečné.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-301">However, in some cases this may not be enough.</span></span> <span data-ttu-id="cc2e1-302">V předchozím příkladu čte zpráva výsledky v 100 000 prvcích XML, které se ukládají do vyrovnávací paměti, což nemusí být žádoucí.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-302">In the preceding example, reading the message results in 100,000 XML elements being buffered, which might not be desirable.</span></span> <span data-ttu-id="cc2e1-303">Můžete chtít přepsat <xref:System.ServiceModel.Channels.Message.OnGetReaderAtBodyContents> a vrátit vlastní <xref:System.Xml.XmlDictionaryReader> odvozenou třídu, která bude obsluhovat náhodná čísla.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-303">You might want to override <xref:System.ServiceModel.Channels.Message.OnGetReaderAtBodyContents> to return a custom <xref:System.Xml.XmlDictionaryReader> derived class that serves up random numbers.</span></span> <span data-ttu-id="cc2e1-304">Pak můžete přepsat <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%2A> pro použití čtecího modulu, který <xref:System.ServiceModel.Channels.Message.OnGetReaderAtBodyContents> Metoda vrátí, jak je znázorněno v následujícím příkladu.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-304">You can then override <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%2A> to use the reader that the <xref:System.ServiceModel.Channels.Message.OnGetReaderAtBodyContents> method returns, as shown in the following example.</span></span>  
  
 [!code-csharp[C_UsingTheMessageClass#10](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_usingthemessageclass/cs/source.cs#10)]
 [!code-vb[C_UsingTheMessageClass#10](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_usingthemessageclass/vb/source.vb#10)]  
  
 <span data-ttu-id="cc2e1-305">Podobně můžete chtít přepsat `OnCreateBufferedCopy` pro vrácení vlastní `MessageBuffer` odvozené třídy.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-305">Similarly, you might want to override `OnCreateBufferedCopy` to return your own `MessageBuffer` derived class.</span></span>  
  
 <span data-ttu-id="cc2e1-306">Kromě poskytování obsahu textu zprávy musí třída odvozená vaše zpráva také přepsat `Version` `Headers` vlastnosti, a `Properties` .</span><span class="sxs-lookup"><span data-stu-id="cc2e1-306">In addition to providing message body contents, your message derived class must also override the `Version`, `Headers`, and `Properties` properties.</span></span>  
  
 <span data-ttu-id="cc2e1-307">Všimněte si, že pokud vytvoříte kopii zprávy, kopie použije záhlaví zprávy z původní.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-307">Note that if you create a copy of a message, the copy uses the message headers from the original.</span></span>  
  
### <a name="other-members-that-can-be-overridden"></a><span data-ttu-id="cc2e1-308">Další členové, kteří mohou být přepsáni</span><span class="sxs-lookup"><span data-stu-id="cc2e1-308">Other Members that Can Be Overridden</span></span>  
 <span data-ttu-id="cc2e1-309">Můžete přepsat <xref:System.ServiceModel.Channels.Message.OnWriteStartEnvelope%2A> <xref:System.ServiceModel.Channels.Message.OnWriteStartHeaders%2A> metody, a a <xref:System.ServiceModel.Channels.Message.OnWriteStartBody%2A> určit tak, jak mají být zapsány počáteční značky na obálku protokolu SOAP, hlavičky protokolu SOAP a prvky těla protokolu SOAP. Tyto obvykle odpovídají `<soap:Envelope>` , `<soap:Header>` a `<soap:Body>` .</span><span class="sxs-lookup"><span data-stu-id="cc2e1-309">You can override the <xref:System.ServiceModel.Channels.Message.OnWriteStartEnvelope%2A>, <xref:System.ServiceModel.Channels.Message.OnWriteStartHeaders%2A>, and <xref:System.ServiceModel.Channels.Message.OnWriteStartBody%2A> methods to specify how the SOAP envelope, SOAP headers, and SOAP body element start tags are written out. These normally correspond to `<soap:Envelope>`, `<soap:Header>`, and `<soap:Body>`.</span></span> <span data-ttu-id="cc2e1-310">Tyto metody by obvykle neměly zapisovat cokoli, pokud se <xref:System.ServiceModel.Channels.Message.Version> vlastnost vrátí <xref:System.ServiceModel.Channels.MessageVersion.None> .</span><span class="sxs-lookup"><span data-stu-id="cc2e1-310">These methods should normally not write anything out if the <xref:System.ServiceModel.Channels.Message.Version> property returns <xref:System.ServiceModel.Channels.MessageVersion.None>.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="cc2e1-311">Výchozí implementace `OnGetReaderAtBodyContents` volání `OnWriteStartEnvelope` a `OnWriteStartBody` před voláním `OnWriteBodyContents` a ukládání výsledků do vyrovnávací paměti.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-311">The default implementation of `OnGetReaderAtBodyContents` calls `OnWriteStartEnvelope` and `OnWriteStartBody` before calling `OnWriteBodyContents` and buffering the results.</span></span> <span data-ttu-id="cc2e1-312">Hlavičky nejsou zapsány.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-312">Headers are not written out.</span></span>  
  
 <span data-ttu-id="cc2e1-313">Přepsat <xref:System.ServiceModel.Channels.Message.OnWriteMessage%2A> metodu pro změnu způsobu, jakým je celá zpráva vytvořena z různých částí.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-313">Override the <xref:System.ServiceModel.Channels.Message.OnWriteMessage%2A> method to change the way the entire message is constructed from its various pieces.</span></span> <span data-ttu-id="cc2e1-314">`OnWriteMessage`Metoda je volána z <xref:System.ServiceModel.Channels.Message.WriteMessage%2A> a z výchozí <xref:System.ServiceModel.Channels.Message.OnCreateBufferedCopy%2A> implementace.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-314">The `OnWriteMessage` method is called from <xref:System.ServiceModel.Channels.Message.WriteMessage%2A> and from the default <xref:System.ServiceModel.Channels.Message.OnCreateBufferedCopy%2A> implementation.</span></span> <span data-ttu-id="cc2e1-315">Všimněte si, že přepsání <xref:System.ServiceModel.Channels.Message.WriteMessage%2A> není osvědčeným postupem.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-315">Note that overriding <xref:System.ServiceModel.Channels.Message.WriteMessage%2A> is not a best practice.</span></span> <span data-ttu-id="cc2e1-316">Je lepší přepsat vhodné `On` metody (například,, <xref:System.ServiceModel.Channels.Message.OnWriteStartEnvelope%2A> <xref:System.ServiceModel.Channels.Message.OnWriteStartHeaders%2A> a <xref:System.ServiceModel.Channels.BodyWriter.OnWriteBodyContents%2A> .</span><span class="sxs-lookup"><span data-stu-id="cc2e1-316">It is better to override the appropriate `On` methods (for example, <xref:System.ServiceModel.Channels.Message.OnWriteStartEnvelope%2A>, <xref:System.ServiceModel.Channels.Message.OnWriteStartHeaders%2A>, and <xref:System.ServiceModel.Channels.BodyWriter.OnWriteBodyContents%2A>.</span></span>  
  
 <span data-ttu-id="cc2e1-317">Přepsáním <xref:System.ServiceModel.Channels.Message.OnBodyToString%2A> přepište způsob reprezentace textu zprávy během ladění.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-317">Override <xref:System.ServiceModel.Channels.Message.OnBodyToString%2A> to override how your message body is represented during debugging.</span></span> <span data-ttu-id="cc2e1-318">Výchozí hodnota je reprezentovat jako tři tečky ("...").</span><span class="sxs-lookup"><span data-stu-id="cc2e1-318">The default is to represent it as three dots ("…").</span></span> <span data-ttu-id="cc2e1-319">Všimněte si, že tuto metodu lze volat několikrát, pokud je stav zprávy cokoli jiného než uzavřeno.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-319">Note that this method can be called multiple times when the message state is anything other than Closed.</span></span> <span data-ttu-id="cc2e1-320">Implementace této metody by nikdy neměla způsobit žádnou akci, kterou je nutné provést pouze jednou (například čtení z datového proudu jen pro odesílání).</span><span class="sxs-lookup"><span data-stu-id="cc2e1-320">An implementation of this method should never cause any action that must be performed only once (such as reading from a forward-only stream).</span></span>  
  
 <span data-ttu-id="cc2e1-321">Přepište <xref:System.ServiceModel.Channels.Message.OnGetBodyAttribute%2A> metodu tak, aby povolovala přístup k atributům prvku SOAP body.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-321">Override the <xref:System.ServiceModel.Channels.Message.OnGetBodyAttribute%2A> method to allow access to attributes on the SOAP body element.</span></span> <span data-ttu-id="cc2e1-322">Tuto metodu lze volat libovolným počtem, ale `Message` základní typ zaručuje, že je volána pouze v případě, že je zpráva ve stavu Created (čas vytvoření).</span><span class="sxs-lookup"><span data-stu-id="cc2e1-322">This method can be called any number of times, but the `Message` base type guarantees that it is only called when the message is in the Created state.</span></span> <span data-ttu-id="cc2e1-323">Není nutné kontrolovat stav implementace.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-323">It is not required to check the state in an implementation.</span></span> <span data-ttu-id="cc2e1-324">Výchozí implementace vždy vrátí `null` , což znamená, že element tělo neobsahuje žádné atributy.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-324">The default implementation always returns `null`, which indicates that there are no attributes on the body element.</span></span>  
  
 <span data-ttu-id="cc2e1-325">Pokud `Message` objekt musí provést jakékoli speciální vyčištění, když tělo zprávy již není vyžadováno, můžete přepsat <xref:System.ServiceModel.Channels.Message.OnClose%2A> .</span><span class="sxs-lookup"><span data-stu-id="cc2e1-325">If your `Message` object must do any special cleanup when the message body is no longer required, you can override <xref:System.ServiceModel.Channels.Message.OnClose%2A>.</span></span> <span data-ttu-id="cc2e1-326">Výchozí implementace neprovádí žádnou akci.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-326">The default implementation does nothing.</span></span>  
  
 <span data-ttu-id="cc2e1-327">`IsEmpty`Vlastnosti a `IsFault` lze přepsat.</span><span class="sxs-lookup"><span data-stu-id="cc2e1-327">The `IsEmpty` and `IsFault` properties can be overridden.</span></span> <span data-ttu-id="cc2e1-328">Ve výchozím nastavení obě vrátí `false` .</span><span class="sxs-lookup"><span data-stu-id="cc2e1-328">By default, both return `false`.</span></span>
