---
title: Objemná data a vysílání datových proudů
description: Seznamte se s důležitými informacemi o komunikaci založené na XML WCF, kodérech a streamovaná data, včetně přenosu binárních dat.
ms.date: 03/30/2017
ms.assetid: ab2851f5-966b-4549-80ab-c94c5c0502d2
ms.openlocfilehash: 2eb57e2f57bebb2e765ea798b3dff27e0187e8c7
ms.sourcegitcommit: 358a28048f36a8dca39a9fe6e6ac1f1913acadd5
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 06/23/2020
ms.locfileid: "85246581"
---
# <a name="large-data-and-streaming"></a><span data-ttu-id="bc3c8-103">Objemná data a vysílání datových proudů</span><span class="sxs-lookup"><span data-stu-id="bc3c8-103">Large Data and Streaming</span></span>

<span data-ttu-id="bc3c8-104">Windows Communication Foundation (WCF) je komunikační infrastruktura založená na jazyce XML.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-104">Windows Communication Foundation (WCF) is an XML-based communications infrastructure.</span></span> <span data-ttu-id="bc3c8-105">Vzhledem k tomu, že data XML jsou obvykle kódována ve standardním textovém formátu definovaném ve [specifikaci XML 1,0](https://www.w3.org/TR/REC-xml/), jsou obvykle zapojeni vývojáři a architekti propojených systémů, které se týkají zátěže (nebo velikosti) zpráv odesílaných v síti a kódování XML založeného na textu, což má za následek zvláštní výzvy pro efektivní přenos binárních dat.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-105">Because XML data is commonly encoded in the standard text format defined in the [XML 1.0 specification](https://www.w3.org/TR/REC-xml/), connected systems developers and architects are typically concerned about the wire footprint (or size) of messages sent across the network, and the text-based encoding of XML poses special challenges for the efficient transfer of binary data.</span></span>  
  
## <a name="basic-considerations"></a><span data-ttu-id="bc3c8-106">Základní požadavky</span><span class="sxs-lookup"><span data-stu-id="bc3c8-106">Basic Considerations</span></span>  
 <span data-ttu-id="bc3c8-107">Pokud chcete poskytnout informace o následujících informacích o WCF, Tato část popisuje některé obecné aspekty a důležité informace pro kódování, binární data a streamování, které se obecně vztahují na infrastrukturu připojených systémů.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-107">To provide background information about the following information for WCF, this section highlights some general concerns and considerations for encodings, binary data, and streaming that generally apply to connected systems infrastructures.</span></span>  
  
### <a name="encoding-data-text-vs-binary"></a><span data-ttu-id="bc3c8-108">Data kódování: text oproti binárnímu souboru</span><span class="sxs-lookup"><span data-stu-id="bc3c8-108">Encoding Data: Text vs. Binary</span></span>  
 <span data-ttu-id="bc3c8-109">Obvykle vyjadřují obavy vývojářů, jako je vnímání kódu XML v porovnání s binárními formáty z důvodu opakovaného charakteru počátečních značek a koncových značek, že kódování numerických hodnot je považováno za podstatně větší, protože je vyjádřeno v textových hodnotách a že binární data nelze vyjádřit efektivně, protože musí být speciálně kódována pro vkládání do textového formátu.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-109">Commonly expressed developer concerns include the perception that XML has significant overhead when compared to binary formats due to the repetitive nature of start tags and end tags, that the encoding of numerical values is considered to be significantly larger because they are expressed in text values, and that binary data cannot be expressed efficiently because it must be specially encoded for embedding into a text format.</span></span>  
  
 <span data-ttu-id="bc3c8-110">I když je mnoho z těchto a podobných otázek platných, skutečný rozdíl mezi zprávami kódovanými v jazyce XML v prostředí webových služeb XML a binárními zprávami ve starším prostředí vzdáleného volání procedur (RPC) jsou často mnohem méně významné, než by bylo možné navrhnout počáteční pozornost.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-110">While many of these and similar concerns are valid, the actual difference between XML-text encoded messages in an XML Web services environment and binary-encoded messages in a legacy remote procedure call (RPC) environment is often much less significant than the initial consideration might suggest.</span></span>  
  
 <span data-ttu-id="bc3c8-111">I když zprávy kódované v jazyce XML jsou transparentní a "čitelné", binární zprávy jsou často poměrně zakryté porovnáním a obtížné dekódovat bez nástrojů.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-111">While XML-text encoded messages are transparent and "human readable", binary messages are often fairly obscure in comparison and difficult to decode without tools.</span></span> <span data-ttu-id="bc3c8-112">Tento rozdíl v čitelnosti vede k přehlédnout, že binární zprávy také často obsahují vložená metadata v datové části, což zvyšuje režii stejně jako textové zprávy XML.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-112">This difference in legibility leads one to overlook that binary messages also often carry inline metadata in the payload, which adds overhead just as with XML text messages.</span></span> <span data-ttu-id="bc3c8-113">To platí konkrétně pro binární formáty, které se zaměřují na poskytování možností volného spojení a dynamického vyvolání.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-113">This is specifically true for binary formats that aim to provide loose-coupling and dynamic invocation capabilities.</span></span>  
  
 <span data-ttu-id="bc3c8-114">Binární formáty však obvykle přenášejí takové popisné informace o metadatech v "hlavičce", která také deklaruje rozložení dat pro následující záznamy dat.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-114">However, binary formats commonly carry such descriptive metadata information in a "header," which also declares the data layout for the following data records.</span></span> <span data-ttu-id="bc3c8-115">Datová část pak následuje za deklarací Common metadata Block s minimální další režií.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-115">The payload then follows this common metadata block declaration with minimal further overhead.</span></span> <span data-ttu-id="bc3c8-116">Naproti tomu XML uzavře každou datovou položku v elementu nebo atributu tak, aby se nadřazené metadata opakovaně zahrnutá pro každý serializovaný objekt datové části.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-116">In contrast, XML encloses each data item in an element or attribute so that the enclosing metadata is repetitively included for each serialized payload object.</span></span> <span data-ttu-id="bc3c8-117">V důsledku toho je velikost jednoho serializovaného objektu datové části podobná při porovnávání textu s binárními reprezentacemi, které je třeba vyjádřit pro obě, ale v binárním formátu jsou přínosy z popisu sdílených metadat s každým dalším objektem datové části, který se přenáší z důvodu nižší celkové režie.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-117">As a result, the size of a single serialized payload object is similar when comparing text to binary representations as some descriptive metadata must be expressed for both, but the binary format benefits from the shared metadata description with each additional payload object that is transferred due to the lower overall overhead.</span></span>  
  
 <span data-ttu-id="bc3c8-118">U některých datových typů, jako jsou třeba čísla, může být Nevýhodou použití binárního číselné reprezentace s pevnou velikostí, jako je například 128 desítkový typ místo prostého textu, protože reprezentace v podobě prostého textu může být menší než několik bajtů.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-118">Still, for certain data types, such as numbers, there might be a disadvantage to using fixed-size, binary numerical representations, such as a 128-bit decimal type instead of plain text, as the plain text representation might be several bytes smaller.</span></span> <span data-ttu-id="bc3c8-119">Textová data také mohou mít výhody z typicky flexibilního flexibilního kódování textu XML, zatímco některé binární formáty mohou být ve výchozím nastavení 16bitové nebo na32elné Unicode, které se nevztahují na binární formát XML .NET.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-119">Text data also might have size benefits from the typically more flexible XML text encoding choices, while some binary formats might default to 16-bit or even 32-bit Unicode, which does not apply to the .NET Binary XML Format.</span></span>  
  
 <span data-ttu-id="bc3c8-120">V důsledku toho se rozhoduje, že mezi textem a binárním souborem není poměrně snadné, protože binární zprávy jsou vždycky menší než textové zprávy XML.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-120">As a result, deciding between text or binary is not quite as easy as assuming that binary messages are always smaller than XML-text messages.</span></span>  
  
 <span data-ttu-id="bc3c8-121">Nejasnou výhodou textových zpráv XML je, že jsou založené na standardech a nabízejí nejširší možnosti pro interoperabilitu a podporu platforem.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-121">A clear advantage of XML-text messages is that they are standards-based and offer the broadest choice of interoperability options and platform support.</span></span> <span data-ttu-id="bc3c8-122">Další informace najdete v části "kódování" dále v tomto tématu.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-122">For more information, see the "Encodings" section later in this topic.</span></span>  
  
### <a name="binary-content"></a><span data-ttu-id="bc3c8-123">Binární obsah</span><span class="sxs-lookup"><span data-stu-id="bc3c8-123">Binary Content</span></span>  
 <span data-ttu-id="bc3c8-124">Jedna oblast, kde jsou binární kódování nadřazené kódování založenému na textu, pokud jde o výslednou velikost zprávy, jsou velké binární datové položky, jako jsou obrázky, videa, zvukové klipy nebo jakákoli jiná forma neprůhledných binárních dat, která musí být vyměněna mezi službami a jejich příjemci.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-124">One area where binary encodings are superior to text-based encodings in terms of the resulting message size are large binary data items such as pictures, videos, sound clips, or any other form of opaque, binary data that must be exchanged between services and their consumers.</span></span> <span data-ttu-id="bc3c8-125">Aby se tyto typy dat vešly do textu XML, společný přístup je kódování pomocí kódování Base64.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-125">To fit these types of data into XML text, the common approach is to encode them using the Base64 encoding.</span></span>  
  
 <span data-ttu-id="bc3c8-126">V řetězci zakódovaném ve formátu base64 každý znak představuje 6 bitů původních 8 bitových dat, což 4:3 vede ke zvýšení poměru znaků pro kódování Base64 a nepočítá se navíc k vypočítávání znaků nadbytečného formátování (návrat na řádku nebo LF), které jsou běžně přidané podle konvence.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-126">In a Base64-encoded string, each character represents 6-bits of the original 8-bit data, which results in a 4:3 encoding-overhead ratio for Base64, not counting extra formatting characters (carriage return/line feed) that are commonly added by convention.</span></span> <span data-ttu-id="bc3c8-127">I když význam rozdílů mezi XML a binárním kódováním obvykle závisí na scénáři, velikost větší než 33% při přenosu datové části 500-MB obvykle není přijatelná.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-127">While the significance of the differences between XML and binary encodings typically depends on the scenario, a size gain of more than 33% when transmitting a 500-MB payload is usually not acceptable.</span></span>  
  
 <span data-ttu-id="bc3c8-128">Aby se tato režie při kódování nezobrazovala, Standard MTOM (Message reoptimization) umožňuje přenesení velké datové prvky, které jsou obsaženy ve zprávě, a jejich předání jako binární data bez jakéhokoli speciálního kódování.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-128">To avoid this encoding overhead, the Message Transmission Optimization Mechanism (MTOM) standard allows for externalizing large data elements that are contained in a message and carrying them with the message as binary data without any special encoding.</span></span> <span data-ttu-id="bc3c8-129">U MTOM se zprávy vyměňují podobným způsobem jako e-mailové zprávy protokolu SMTP (Simple Mail Transfer Protocol) s přílohami nebo vloženým obsahem (obrázky a další vložený obsah). Zprávy MTOM se zabalí jako části s částmi MIME nebo související s kořenovou částí, která je skutečnou zprávou SOAP.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-129">With MTOM, messages are exchanged in a similar fashion to Simple Mail Transfer Protocol (SMTP) email messages with attachments or embedded content (pictures and other embedded content); MTOM messages are packaged as multipart/related MIME sequences with the root part being the actual SOAP message.</span></span>  
  
 <span data-ttu-id="bc3c8-130">Zpráva SOAP protokolu MTOM je upravena ze své nekódované verze, takže speciální značky prvků, které odkazují na příslušné části MIME, přebírají místo původních prvků ve zprávě, která obsahovala binární data.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-130">An MTOM SOAP message is modified from its un-encoded version so that special element tags that refer to the respective MIME parts take the place of the original elements in the message that contained binary data.</span></span> <span data-ttu-id="bc3c8-131">V důsledku toho zpráva SOAP odkazuje na binární obsah tak, že odkazuje na části MIME, které s ním jsou odesílány, ale jinak pouze textová data XML.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-131">As a result, the SOAP message refers to binary content by pointing to the MIME parts sent with it, but otherwise just carries XML text data.</span></span> <span data-ttu-id="bc3c8-132">Vzhledem k tomu, že je tento model úzce zarovnán s dobře zavedeným modelem SMTP, existuje široká podpora nástrojů pro kódování a dekódování zpráv MTOM na mnoha platformách, což usnadňuje možnost volby.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-132">Because this model is closely aligned with the well-established SMTP model, there is broad tooling support to encode and decode MTOM messages on many platforms, which makes it an extremely interoperable choice.</span></span>  
  
 <span data-ttu-id="bc3c8-133">Stejně jako u Base64 také přináší MTOM s určitou režií pro formát MIME, takže výhody použití MTOM se zobrazují jenom v případě, že velikost binárního datového elementu přesáhne 1 KB.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-133">Still, as with Base64, MTOM also comes with some necessary overhead for the MIME format, so that advantages of using MTOM are only seen when the size of a binary data element exceeds about 1 KB.</span></span> <span data-ttu-id="bc3c8-134">Kvůli režii mohou být zprávy kódované pomocí MTOM větší než zprávy, které používají kódování Base64 pro binární data, pokud binární datová část zůstane pod touto prahovou hodnotou.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-134">Due to the overhead, MTOM-encoded messages might be larger than messages that use Base64 encoding for binary data, if the binary payload remains under that threshold.</span></span> <span data-ttu-id="bc3c8-135">Další informace najdete v části "kódování" dále v tomto tématu.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-135">For more information, see the "Encodings" section later in this topic.</span></span>  
  
### <a name="large-data-content"></a><span data-ttu-id="bc3c8-136">Obsah velkého objemu dat</span><span class="sxs-lookup"><span data-stu-id="bc3c8-136">Large Data Content</span></span>  
 <span data-ttu-id="bc3c8-137">V případě nenáročného z provozu představuje dřív zmíněná datová část 500 MB také skvělou místní výzvu pro službu a klienta.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-137">Wire-footprint aside, the previously mentioned 500-MB payload also poses a great local challenge at for the service and the client.</span></span> <span data-ttu-id="bc3c8-138">Ve výchozím nastavení WCF zpracovává zprávy v *režimu vyrovnávací paměti*.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-138">By default, WCF processes messages in *buffered mode*.</span></span> <span data-ttu-id="bc3c8-139">To znamená, že celý obsah zprávy je přítomen v paměti před odesláním nebo po jeho přijetí.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-139">This means that the entire content of a message is present in memory before it is sent or after it is received.</span></span> <span data-ttu-id="bc3c8-140">I když je to dobrá strategie pro většinu scénářů a je nutná pro zasílání zpráv, jako jsou digitální podpisy a spolehlivé doručování, mohou velké zprávy vyčerpat prostředky systému.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-140">While that is a good strategy for most scenarios, and necessary for messaging features such as digital signatures and reliable delivery, large messages could exhaust a system's resources.</span></span>  
  
 <span data-ttu-id="bc3c8-141">Tato strategie se zabývat velkými datovými částmi je streamování.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-141">The strategy to deal with large payloads is streaming.</span></span> <span data-ttu-id="bc3c8-142">I když se zprávy, zejména ty vyjádřené ve formátu XML, považují za poměrně kompaktní datové balíčky, může se stát, že velikost zprávy je větší a podobá se souvislému datovému streamu většímu než datový balíček.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-142">While messages, especially those expressed in XML, are commonly thought of as being relatively compact data packages, a message might be multiple gigabytes in size and resemble a continuous data stream more than a data package.</span></span> <span data-ttu-id="bc3c8-143">Když se data přenesou v režimu streamování místo v režimu vyrovnávací paměti, odesílatel vytvoří obsah zprávy, která je k dispozici příjemci ve formě datového proudu, a infrastruktura zpráv nepřetržitě předává data od odesílatele k příjemci, jakmile bude k dispozici.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-143">When data is transferred in streaming mode instead of buffered mode, the sender makes the contents of the message body available to the recipient in the form of a stream and the message infrastructure continuously forwards the data from sender to receiver as it becomes available.</span></span>  
  
 <span data-ttu-id="bc3c8-144">Nejběžnější scénář, ve kterém dochází k takovým velkým datovým přenosům dat, jsou přenosy binárních datových objektů, které:</span><span class="sxs-lookup"><span data-stu-id="bc3c8-144">The most common scenario in which such large data content transfers occur are transfers of binary data objects that:</span></span>  
  
- <span data-ttu-id="bc3c8-145">Nelze ji snadno rozdělit do sekvence zpráv.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-145">Cannot be easily broken up into a message sequence.</span></span>  
  
- <span data-ttu-id="bc3c8-146">Musí být doručen včas.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-146">Must be delivered in a timely manner.</span></span>  
  
- <span data-ttu-id="bc3c8-147">Nejsou k dispozici v celém rozsahu při zahájení přenosu.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-147">Are not available in their entirety when the transfer is initiated.</span></span>  
  
 <span data-ttu-id="bc3c8-148">V případě dat, která tato omezení nemají, je obvykle lepší odesílat sekvence zpráv v rámci rozsahu relace než jedna velká zpráva.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-148">For data that does not have these constraints, it is typically better to send sequences of messages within the scope of a session than one large message.</span></span> <span data-ttu-id="bc3c8-149">Další informace najdete v části streamovaná data dále v tomto tématu.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-149">For more information, see the "Streaming Data" section later in this topic.</span></span>  
  
 <span data-ttu-id="bc3c8-150">Když posíláte velké objemy dat, budete muset nastavit `maxAllowedContentLength` nastavení IIS (Další informace najdete v tématu [Konfigurace omezení požadavků IIS](https://docs.microsoft.com/iis/configuration/system.webServer/security/requestFiltering/requestLimits/)) a `maxReceivedMessageSize` Nastavení vazby (například [System. ServiceModel. BasicHttpBinding. MaxReceivedMessageSize](xref:System.ServiceModel.HttpBindingBase.MaxReceivedMessageSize%2A) nebo <xref:System.ServiceModel.NetTcpBinding.MaxReceivedMessageSize%2A> ).</span><span class="sxs-lookup"><span data-stu-id="bc3c8-150">When sending large amounts of data you will need to set the `maxAllowedContentLength` IIS setting (for more information see [Configuring IIS Request Limits](https://docs.microsoft.com/iis/configuration/system.webServer/security/requestFiltering/requestLimits/)) and the `maxReceivedMessageSize` binding setting (for example [System.ServiceModel.BasicHttpBinding.MaxReceivedMessageSize](xref:System.ServiceModel.HttpBindingBase.MaxReceivedMessageSize%2A) or <xref:System.ServiceModel.NetTcpBinding.MaxReceivedMessageSize%2A>).</span></span> <span data-ttu-id="bc3c8-151">`maxAllowedContentLength`Výchozí hodnota vlastnosti je 28,6 MB a `maxReceivedMessageSize` vlastnost je nastavená na 64 KB.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-151">The `maxAllowedContentLength` property defaults to 28.6 MB and the `maxReceivedMessageSize` property defaults to 64KB.</span></span>  
  
## <a name="encodings"></a><span data-ttu-id="bc3c8-152">Kódování</span><span class="sxs-lookup"><span data-stu-id="bc3c8-152">Encodings</span></span>  
 <span data-ttu-id="bc3c8-153">*Kódování* definuje sadu pravidel o tom, jak prezentovat zprávy na lince.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-153">An *encoding* defines a set of rules about how to present messages on the wire.</span></span> <span data-ttu-id="bc3c8-154">*Kodér* implementuje takové kódování a zodpovídá na straně odesilatele pro zapnutí v paměti <xref:System.ServiceModel.Channels.Message> do bajtového datového proudu nebo vyrovnávací paměti bajtů, které lze odeslat přes síť.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-154">An *encoder* implements such an encoding and is responsible, on the sender side, for turning an in-memory <xref:System.ServiceModel.Channels.Message> into a byte stream or byte buffer that can be sent across the network.</span></span> <span data-ttu-id="bc3c8-155">Kodér na straně přijímače zapíná sekvenci bajtů do zprávy v paměti.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-155">On the receiver side, the encoder turns a sequence of bytes into an in-memory message.</span></span>  
  
 <span data-ttu-id="bc3c8-156">WCF zahrnuje tři kodéry a v případě potřeby umožňuje psát a připojovat vlastní kodéry.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-156">WCF includes three encoders and allows you to write and plug in your own encoders, if necessary.</span></span>  
  
 <span data-ttu-id="bc3c8-157">Každá standardní vazba obsahuje předem nakonfigurovaný kodér, přičemž vazby s předponou NET \* používají binární kodér (zahrnutím <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement> třídy), zatímco <xref:System.ServiceModel.BasicHttpBinding> <xref:System.ServiceModel.WSHttpBinding> třídy a používají ve výchozím nastavení kodér textových zpráv (prostřednictvím <xref:System.ServiceModel.Channels.TextMessageEncodingBindingElement> třídy).</span><span class="sxs-lookup"><span data-stu-id="bc3c8-157">Each of the standard bindings includes a preconfigured encoder, whereby the bindings with the Net\* prefix use the binary encoder (by including the <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement> class) while the <xref:System.ServiceModel.BasicHttpBinding> and <xref:System.ServiceModel.WSHttpBinding> classes use the text message encoder (by means of the <xref:System.ServiceModel.Channels.TextMessageEncodingBindingElement> class) by default.</span></span>  
  
|<span data-ttu-id="bc3c8-158">Element vazby kodéru</span><span class="sxs-lookup"><span data-stu-id="bc3c8-158">Encoder binding element</span></span>|<span data-ttu-id="bc3c8-159">Description</span><span class="sxs-lookup"><span data-stu-id="bc3c8-159">Description</span></span>|  
|-----------------------------|-----------------|  
|<xref:System.ServiceModel.Channels.TextMessageEncodingBindingElement>|<span data-ttu-id="bc3c8-160">Kodér textu zprávy je výchozím kodérem pro všechny vazby založené na protokolu HTTP a vhodnou volbou pro všechny vlastní vazby, kde je interoperabilita nejvyššími obavy.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-160">The text message encoder is the default encoder for all HTTP-based bindings and the appropriate choice for all custom bindings where interoperability is the highest concern.</span></span> <span data-ttu-id="bc3c8-161">Tento kodér čte a zapisuje standardní textové zprávy protokolu SOAP 1.1/SOAP 1,2 bez speciálního zpracování pro binární data.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-161">This encoder reads and writes standard SOAP 1.1/SOAP 1.2 text messages with no special handling for binary data.</span></span> <span data-ttu-id="bc3c8-162">Pokud <xref:System.ServiceModel.Channels.MessageVersion?displayProperty=nameWithType> je vlastnost zprávy nastavena na, je obálka <xref:System.ServiceModel.Channels.MessageVersion.None?displayProperty=nameWithType> protokolu SOAP vynechána z výstupu a je serializován pouze obsah textu zprávy.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-162">If the <xref:System.ServiceModel.Channels.MessageVersion?displayProperty=nameWithType> property of a message is set to <xref:System.ServiceModel.Channels.MessageVersion.None?displayProperty=nameWithType>, the SOAP envelope wrapper is omitted from the output and only the message body content is serialized.</span></span>|  
|<xref:System.ServiceModel.Channels.MtomMessageEncodingBindingElement>|<span data-ttu-id="bc3c8-163">Kodér zpráv MTOM je textový kodér, který implementuje speciální zpracování pro binární data a ve výchozím nastavení se v žádném ze standardních vazeb nepoužívá, protože se jedná o výhradně nástroj pro optimalizaci velkých a malých písmen.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-163">The MTOM message encoder is a text encoder that implements special handling for binary data and is not used by default in any of the standard bindings because it is strictly a case-by-case optimization utility.</span></span> <span data-ttu-id="bc3c8-164">Pokud zpráva obsahuje binární data, která překročí prahovou hodnotu, která má za důsledek kódování MTOM, data se externě přidělí na část MIME za obálkou zprávy.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-164">If the message contains binary data that exceeds a threshold where MTOM encoding yields a benefit, the data is externalized into a MIME part following the message envelope.</span></span> <span data-ttu-id="bc3c8-165">Viz povolení MTOM později v této části.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-165">See Enabling MTOM later in this section.</span></span>|  
|<xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement>|<span data-ttu-id="bc3c8-166">Binární kodér zpráv je výchozím kodérem pro vazby NET \* a vhodným výběrem, pokud jsou obě komunikující strany založené na službě WCF.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-166">The binary message encoder is the default encoder for the Net\* bindings and the appropriate choice whenever both communicating parties are based on WCF.</span></span> <span data-ttu-id="bc3c8-167">Kodér binárních zpráv používá binární formát XML, který je specifický pro společnost Microsoft, binární reprezentace pro XML Information Sets (Infosets), která obvykle poskytuje menší nároky, než je ekvivalent XML 1,0 reprezentace a kódování binárních dat jako datový proud bajtů.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-167">The binary message encoder uses the .NET Binary XML Format, a Microsoft-specific binary representation for XML Information Sets (Infosets) that generally yields a smaller footprint than the equivalent XML 1.0 representation and encodes binary data as a byte stream.</span></span>|  
  
 <span data-ttu-id="bc3c8-168">Kódování textové zprávy je obvykle nejlepší volbou pro jakoukoli komunikační cestu, která vyžaduje interoperabilitu, zatímco kódování binárních zpráv je nejlepší volbou pro jakoukoli jinou komunikační cestu.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-168">Text message encoding is typically the best choice for any communication path that requires interoperability, while binary message encoding is the best choice for any other communication path.</span></span> <span data-ttu-id="bc3c8-169">Kódování binárních zpráv obvykle dává menší velikost zpráv v porovnání s textem pro jednu zprávu a postupně i menší velikosti zpráv po dobu trvání relace komunikace.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-169">Binary message encoding typically yields smaller message sizes compared to text for a single message and progressively even smaller message sizes over the duration of a communication session.</span></span> <span data-ttu-id="bc3c8-170">Na rozdíl od kódování textu nemusí binární kódování používat speciální zpracování pro binární data, jako je například použití Base64, ale představuje bajty jako bajty.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-170">Unlike text encoding, binary encoding does not have to use special handling for binary data, such as using Base64, but represents bytes as bytes.</span></span>  
  
 <span data-ttu-id="bc3c8-171">Pokud vaše řešení nepotřebuje spolupráci, ale přesto chcete použít přenos pomocí protokolu HTTP, můžete vytvořit <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement> do vlastní vazby, která <xref:System.ServiceModel.Channels.HttpTransportBindingElement> pro přenos používá třídu.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-171">If your solution does not require interoperability, but you still want to use HTTP transport, you can compose the <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement> into a custom binding that uses the <xref:System.ServiceModel.Channels.HttpTransportBindingElement> class for the transport.</span></span> <span data-ttu-id="bc3c8-172">Pokud určitý počet klientů v rámci služby vyžaduje interoperabilitu, doporučujeme, abyste vystavili paralelní koncové body, které mají odpovídající možnosti přenosu a kódování pro příslušné klienty.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-172">If a number of clients on your service require interoperability, it is recommended that you expose parallel endpoints that each has the appropriate transport and encoding choices for the respective clients enabled.</span></span>  
  
### <a name="enabling-mtom"></a><span data-ttu-id="bc3c8-173">Povolení MTOM</span><span class="sxs-lookup"><span data-stu-id="bc3c8-173">Enabling MTOM</span></span>  
 <span data-ttu-id="bc3c8-174">Je-li interoperabilita požadavek a je třeba odeslat velké binární údaje, je kódování zpráv MTOM alternativní strategií kódování, kterou lze povolit u standard <xref:System.ServiceModel.BasicHttpBinding> nebo vazeb nastavením <xref:System.ServiceModel.WSHttpBinding> příslušné `MessageEncoding` vlastnosti na <xref:System.ServiceModel.WSMessageEncoding.Mtom> nebo pomocí sestavení a <xref:System.ServiceModel.Channels.MtomMessageEncodingBindingElement> <xref:System.ServiceModel.Channels.CustomBinding> .</span><span class="sxs-lookup"><span data-stu-id="bc3c8-174">When interoperability is a requirement and large binary data must be sent, then MTOM message encoding is the alternative encoding strategy that you can enable on the standard <xref:System.ServiceModel.BasicHttpBinding> or <xref:System.ServiceModel.WSHttpBinding> bindings by setting the respective `MessageEncoding` property to <xref:System.ServiceModel.WSMessageEncoding.Mtom> or by composing the <xref:System.ServiceModel.Channels.MtomMessageEncodingBindingElement> into a <xref:System.ServiceModel.Channels.CustomBinding>.</span></span> <span data-ttu-id="bc3c8-175">Následující příklad kódu extrahovaný z ukázky [kódování MTOM](../samples/mtom-encoding.md) ukazuje, jak povolit MTOM v konfiguraci.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-175">The following example code, extracted from the [MTOM Encoding](../samples/mtom-encoding.md) sample demonstrates how to enable MTOM in configuration.</span></span>  
  
```xml  
<system.serviceModel>  
     …  
    <bindings>  
      <wsHttpBinding>  
        <binding name="ExampleBinding" messageEncoding="Mtom"/>  
      </wsHttpBinding>  
    </bindings>  
     …  
</system.serviceModel>  
```  
  
 <span data-ttu-id="bc3c8-176">Jak bylo zmíněno dříve, rozhodnutí o použití kódování MTOM závisí na objemu dat, který odesíláte.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-176">As mentioned earlier, the decision to use MTOM encoding depends on the data volume you are sending.</span></span> <span data-ttu-id="bc3c8-177">Kromě toho, protože MTOM je povolen na úrovni vazby, povolení MTOM má vliv na všechny operace v daném koncovém bodu.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-177">Also, because MTOM is enabled at the binding level, enabling MTOM affects all operations on a given endpoint.</span></span>  
  
 <span data-ttu-id="bc3c8-178">Vzhledem k tomu, že kodér MTOM vždy vygeneruje zprávu MIME/s více částmi ve formátu MTOM bez ohledu na to, zda binární data končí externě, měli byste obecně povolit pouze MTOM pro koncové body, které vyměňují zprávy s více než 1 KB binárních dat.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-178">Because the MTOM encoder always emits an MTOM-encoded MIME/multi-part message regardless of whether binary data ends up being externalized, you should generally only enable MTOM for endpoints that exchange messages with more than 1 KB of binary data.</span></span> <span data-ttu-id="bc3c8-179">Kontrakty služby navržené pro použití s koncovými body s podporou MTOM by měly být, pokud je to možné, omezené na určení takových operací přenosu dat.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-179">Also, the service contracts designed for use with MTOM-enabled endpoints should, when possible, be constrained to specifying such data transfer operations.</span></span> <span data-ttu-id="bc3c8-180">Související funkce řízení by se měly nacházet v samostatné smlouvě.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-180">Related control functionality should reside on a separate contract.</span></span> <span data-ttu-id="bc3c8-181">Toto pravidlo pouze pro MTOM se vztahuje pouze na zprávy odeslané prostřednictvím koncového bodu s povoleným MTOM. Kodér MTOM může dekódovat a analyzovat i příchozí zprávy, které nepatří do MTOM.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-181">This "MTOM-only" rule applies only to messages sent through an MTOM-enabled endpoint; the MTOM-encoder can decode and parse incoming non-MTOM messages as well.</span></span>  
  
 <span data-ttu-id="bc3c8-182">Použití kodéru MTOM je v souladu se všemi ostatními funkcemi WCF.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-182">Using the MTOM encoder conforms with all other WCF features.</span></span> <span data-ttu-id="bc3c8-183">Všimněte si, že toto pravidlo nemusí být možné sledovat ve všech případech, například když je vyžadována podpora relace.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-183">Note that it may not be possible to observe this rule in all cases, such as when session support is required.</span></span>  
  
### <a name="programming-model"></a><span data-ttu-id="bc3c8-184">Programovací model</span><span class="sxs-lookup"><span data-stu-id="bc3c8-184">Programming Model</span></span>  
 <span data-ttu-id="bc3c8-185">Bez ohledu na to, který ze tří vestavěných kodérů používáte ve vaší aplikaci, je programovací prostředí identické s ohledem na přenos binárních dat.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-185">Regardless of which of the three built-in encoders you use in your application, the programming experience is identical with regards to transferring binary data.</span></span> <span data-ttu-id="bc3c8-186">Rozdíl je v tom, jak WCF zpracovává data na základě jejich datových typů.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-186">The difference is in how WCF handles the data based on their data types.</span></span>  
  
```csharp
[DataContract]  
class MyData  
{  
    [DataMember]  
    byte[] binaryBuffer;  
    [DataMember]  
    string someStringData;  
}
```  
  
 <span data-ttu-id="bc3c8-187">Při použití nástroje MTOM je předchozí kontrakt dat serializován podle následujících pravidel:</span><span class="sxs-lookup"><span data-stu-id="bc3c8-187">When using MTOM, the preceding data contract is serialized according to the following rules:</span></span>  
  
- <span data-ttu-id="bc3c8-188">Pokud `binaryBuffer` není `null` a samostatně obsahuje dostatek dat pro zarovnání režijních nákladů na MTOM (hlavičky MIME atd.) ve srovnání s kódováním base64, data jsou externá a přenesená se zprávou jako binární část MIME.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-188">If `binaryBuffer` is not `null` and individually contains enough data to justify the MTOM externalization overhead (MIME headers, and so on) when compared to Base64 encoding, the data is externalized and carried with the message as a binary MIME part.</span></span> <span data-ttu-id="bc3c8-189">Pokud prahová hodnota není překročena, data budou kódována jako base64.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-189">If the threshold is not exceeded, the data is encoded as Base64.</span></span>  
  
- <span data-ttu-id="bc3c8-190">Řetězec (a všechny ostatní typy, které nejsou binární), jsou vždy reprezentovány jako řetězec uvnitř těla zprávy bez ohledu na velikost.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-190">The string (and all other types that are not binary) is always represented as a string inside the message body, regardless of size.</span></span>  
  
 <span data-ttu-id="bc3c8-191">Účinek na kódování MTOM je stejný, ať už používáte explicitní kontrakt dat, jak je znázorněno v předchozím příkladu, použít seznam parametrů v operaci, mít vnořené kontrakty dat nebo přenést objekt kontraktu dat do kolekce.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-191">The effect on the MTOM encoding is the same whether you use an explicit data contract, as shown in the preceding example, use a parameter list in an operation, have nested data contracts, or transfer a data contract object inside a collection.</span></span> <span data-ttu-id="bc3c8-192">Bajtová pole jsou vždy kandidáti na optimalizaci a jsou optimalizována, pokud jsou splněny mezní hodnoty optimalizace.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-192">Byte arrays are always candidates for optimization and are optimized if the optimization thresholds are being met.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="bc3c8-193"><xref:System.IO.Stream?displayProperty=nameWithType>V kontraktech dat byste neměli používat odvozené typy.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-193">You should not be using <xref:System.IO.Stream?displayProperty=nameWithType> derived types inside of data contracts.</span></span> <span data-ttu-id="bc3c8-194">Data streamu by se měla sdělit pomocí modelu streamování, který je vysvětlen v následujících částech streamování dat.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-194">Stream data should be communicated using the streaming model, explained in the following "Streaming Data" section.</span></span>  
  
## <a name="streaming-data"></a><span data-ttu-id="bc3c8-195">Streamování dat</span><span class="sxs-lookup"><span data-stu-id="bc3c8-195">Streaming Data</span></span>  
 <span data-ttu-id="bc3c8-196">Pokud máte velké množství dat, která se mají přenést, je režim přenosu streamování ve službě WCF vhodná alternativa k výchozímu chování ukládání zpráv do vyrovnávací paměti a jejich zpracování v celé paměti.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-196">When you have a large amount of data to transfer, the streaming transfer mode in WCF is a feasible alternative to the default behavior of buffering and processing messages in memory in their entirety.</span></span>  
  
 <span data-ttu-id="bc3c8-197">Jak už bylo zmíněno dříve, povolte streamování jenom pro velké zprávy (s textovým nebo binárním obsahem), pokud se data nedají rozdělit, pokud se tato zpráva musí doručit včas, nebo pokud nejsou data při zahájení přenosu ještě plně dostupná.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-197">As mentioned earlier, enable streaming only for large messages (with text or binary content) if the data cannot be segmented, if the message must be delivered in a timely fashion, or if the data is not yet fully available when the transfer is initiated.</span></span>  
  
### <a name="restrictions"></a><span data-ttu-id="bc3c8-198">Omezení</span><span class="sxs-lookup"><span data-stu-id="bc3c8-198">Restrictions</span></span>  
 <span data-ttu-id="bc3c8-199">Pokud je povolené streamování, nemůžete použít významný počet funkcí WCF:</span><span class="sxs-lookup"><span data-stu-id="bc3c8-199">You cannot use a significant number of WCF features when streaming is enabled:</span></span>  
  
- <span data-ttu-id="bc3c8-200">Digitální podpisy pro tělo zprávy nelze provést, protože vyžadují výpočet hodnoty hash přes celý obsah zprávy.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-200">Digital signatures for the message body cannot be performed because they require computing a hash over the entire message contents.</span></span> <span data-ttu-id="bc3c8-201">U streamování není obsah po vytvoření a odeslání hlaviček zpráv plně dostupný, a proto nelze vypočítat digitální podpis.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-201">With streaming, the content is not fully available when the message headers are constructed and sent and, therefore, a digital signature cannot be computed.</span></span>  
  
- <span data-ttu-id="bc3c8-202">Šifrování závisí na digitálních podpisech, aby bylo možné ověřit, zda byla data znovu správně vytvořena.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-202">Encryption depends on digital signatures to verify that the data has been reconstructed correctly.</span></span>  
  
- <span data-ttu-id="bc3c8-203">Spolehlivé relace musí ukládat zprávy na straně klienta pro opětovné doručení, pokud dojde ke ztrátě zprávy v přenosu, a před jejich předáním do implementace služby musí obsahovat zprávy, aby bylo zachováno pořadí zpráv v případě, že zprávy jsou přijímány mimo sekvenci.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-203">Reliable sessions must buffer sent messages on the client for redelivery if a message gets lost in transfer and must hold messages on the service before handing them to the service implementation to preserve message order in case messages are received out-of-sequence.</span></span>  
  
 <span data-ttu-id="bc3c8-204">Z důvodu těchto funkčních omezení můžete pro streamování použít jenom možnosti zabezpečení na úrovni přenosu a nemůžete zapnout spolehlivé relace.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-204">Because of these functional constraints, you can use only transport-level security options for streaming and you cannot turn on reliable sessions.</span></span> <span data-ttu-id="bc3c8-205">Streamování je dostupné jenom u následujících vazeb definovaných systémem:</span><span class="sxs-lookup"><span data-stu-id="bc3c8-205">Streaming is only available with the following system-defined bindings:</span></span>  
  
- <xref:System.ServiceModel.BasicHttpBinding>  
  
- <xref:System.ServiceModel.NetTcpBinding>  
  
- <xref:System.ServiceModel.NetNamedPipeBinding>  
  
- <xref:System.ServiceModel.WebHttpBinding>  
  
 <span data-ttu-id="bc3c8-206">Vzhledem k tomu, že základní přenosy <xref:System.ServiceModel.NetTcpBinding> a <xref:System.ServiceModel.NetNamedPipeBinding> mají na rozdíl od http podporu spolehlivého doručování a připojení na základě připojení, jsou tyto dvě vazby v praxi jenom minimálními vlivy na tato omezení.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-206">Because the underlying transports of <xref:System.ServiceModel.NetTcpBinding> and <xref:System.ServiceModel.NetNamedPipeBinding> have inherent reliable delivery and connection-based session support, unlike HTTP, these two bindings are only minimally affected by these constraints, in practice.</span></span>  
  
 <span data-ttu-id="bc3c8-207">Pro přenos služby Řízení front zpráv (MSMQ) není služba streaming dostupná a nedá se použít s <xref:System.ServiceModel.NetMsmqBinding> <xref:System.ServiceModel.MsmqIntegration.MsmqIntegrationBinding> třídou nebo.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-207">Streaming is not available with the Message Queuing (MSMQ) transport and so cannot be used with the <xref:System.ServiceModel.NetMsmqBinding> or the <xref:System.ServiceModel.MsmqIntegration.MsmqIntegrationBinding> class.</span></span> <span data-ttu-id="bc3c8-208">Přenos v rámci služby Řízení front zpráv podporuje pouze datové přenosy s omezenou velikostí zprávy, zatímco u všech ostatních přenosů není pro většinu scénářů k dispozici žádná praktická omezení velikosti zpráv.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-208">The Message Queuing transport only supports buffered data transfers with a constrained message size, while all other transports do not have any practical message size limit for the vast majority of scenarios.</span></span>  
  
 <span data-ttu-id="bc3c8-209">Streamování není k dispozici ani při použití přenosu rovnocenného kanálu, takže není k dispozici v <xref:System.ServiceModel.NetPeerTcpBinding> .</span><span class="sxs-lookup"><span data-stu-id="bc3c8-209">Streaming is also not available when using the Peer Channel transport, so is not available with the <xref:System.ServiceModel.NetPeerTcpBinding>.</span></span>  
  
#### <a name="streaming-and-sessions"></a><span data-ttu-id="bc3c8-210">Streamování a relace</span><span class="sxs-lookup"><span data-stu-id="bc3c8-210">Streaming and Sessions</span></span>  
 <span data-ttu-id="bc3c8-211">Může dojít k neočekávanému chování při volání streamování s vazbou založenou na relacích.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-211">You may get unexpected behavior when streaming calls with a session-based binding.</span></span> <span data-ttu-id="bc3c8-212">Všechna volání streamování se provádějí pomocí jednoho kanálu (kanálu Datagram), který nepodporuje relace ani v případě, že použitá vazba je nakonfigurovaná tak, aby používala relace.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-212">All streaming calls are made through a single channel (the datagram channel) that does not support sessions even if the binding being used is configured to use sessions.</span></span> <span data-ttu-id="bc3c8-213">Pokud více klientů provede volání do stejného objektu služby přes vazbu založenou na relaci a režim souběžnosti objektu služby je nastaven na hodnotu Single a kontextový režim instance je nastaven na PerSession, musí všechna volání projít kanálem datagramu a takže se zpracovává pouze jedno volání.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-213">If multiple clients make streaming calls to the same service object over a session-based binding and the service object's concurrency mode is set to single and its instance context mode is set to PerSession, all calls must go through the datagram channel and so only one call is processed at a time.</span></span> <span data-ttu-id="bc3c8-214">Jeden nebo více klientů může vyprší časový limit. Tento problém můžete obejít tak, že nastavíte kontextový režim instance objektu služby na PerCall nebo souběžnost na násobek.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-214">One or more clients may then time out. You can work around this issue by either setting the service object's Instance Context Mode to PerCall or Concurrency to Multiple.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="bc3c8-215">MaxConcurrentSessions nemá v tomto případě žádný účinek, protože je k dispozici pouze jedna "relace".</span><span class="sxs-lookup"><span data-stu-id="bc3c8-215">MaxConcurrentSessions has no effect in this case because there is only one "session" available.</span></span>  
  
### <a name="enabling-streaming"></a><span data-ttu-id="bc3c8-216">Povolení streamování</span><span class="sxs-lookup"><span data-stu-id="bc3c8-216">Enabling Streaming</span></span>  
 <span data-ttu-id="bc3c8-217">Streamování můžete povolit následujícími způsoby:</span><span class="sxs-lookup"><span data-stu-id="bc3c8-217">You can enable streaming in the following ways:</span></span>  
  
- <span data-ttu-id="bc3c8-218">Odesílat a přijímat požadavky v režimu streamování a přijímat a vracet odpovědi v režimu vyrovnávací paměti ( <xref:System.ServiceModel.TransferMode.StreamedRequest> ).</span><span class="sxs-lookup"><span data-stu-id="bc3c8-218">Send and accept requests in streaming mode, and accept and return responses in buffered mode (<xref:System.ServiceModel.TransferMode.StreamedRequest>).</span></span>  
  
- <span data-ttu-id="bc3c8-219">Odesílat a přijímat požadavky v režimu vyrovnávací paměti a přijímat a vracet odpovědi v režimu streamování ( <xref:System.ServiceModel.TransferMode.StreamedResponse> ).</span><span class="sxs-lookup"><span data-stu-id="bc3c8-219">Send and accept requests in buffered mode, and accept and return responses in streamed mode (<xref:System.ServiceModel.TransferMode.StreamedResponse>).</span></span>  
  
- <span data-ttu-id="bc3c8-220">Posílání a přijímání požadavků a odpovědí v režimu streamování v obou směrech.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-220">Send and receive requests and responses in streamed mode in both directions.</span></span> <span data-ttu-id="bc3c8-221">(<xref:System.ServiceModel.TransferMode.Streamed>).</span><span class="sxs-lookup"><span data-stu-id="bc3c8-221">(<xref:System.ServiceModel.TransferMode.Streamed>).</span></span>  
  
 <span data-ttu-id="bc3c8-222">Streamování můžete zakázat nastavením režimu přenosu na <xref:System.ServiceModel.TransferMode.Buffered> , což je výchozí nastavení u všech vazeb.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-222">You can disable streaming by setting the transfer mode to <xref:System.ServiceModel.TransferMode.Buffered>, which is the default setting on all bindings.</span></span> <span data-ttu-id="bc3c8-223">Následující kód ukazuje, jak nastavit režim přenosu v konfiguraci.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-223">The following code shows how to set the transfer mode in configuration.</span></span>  
  
```xml  
<system.serviceModel>  
     …  
    <bindings>  
      <basicHttpBinding>  
        <binding name="ExampleBinding" transferMode="Streamed"/>  
      </basicHttpBinding>  
    </bindings>  
     …  
</system.serviceModel>  
```  
  
 <span data-ttu-id="bc3c8-224">Při vytváření instance vazby v kódu musíte nastavit `TransferMode` vlastnost příslušné vazby (nebo element vazby přenosu, pokud vytváříte vlastní vazbu) na jednu z dříve zmíněných hodnot.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-224">When you instantiate your binding in code, you must set the respective `TransferMode` property of the binding (or the transport binding element if you are composing a custom binding) to one of the previously mentioned values.</span></span>  
  
 <span data-ttu-id="bc3c8-225">Můžete zapnout streamování pro žádosti a odpovědi nebo pro oba směry nezávisle na kterékoli straně komunikujících stran, aniž by to ovlivnilo funkčnost.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-225">You can turn on streaming for requests and replies or for both directions independently at either side of the communicating parties without affecting functionality.</span></span> <span data-ttu-id="bc3c8-226">Měli byste ale vždycky předpokládat, že velikost přenesených dat je tak významná, že povolení streamování je oprávněné v obou koncových bodech komunikačního propojení.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-226">However, you should always assume that the transferred data size is so significant that enabling streaming is justified on both endpoints of a communication link.</span></span> <span data-ttu-id="bc3c8-227">Pro komunikaci mezi platformami, kde jeden z koncových bodů není implementován pomocí služby WCF, bude možnost používat streamování záviset na funkcích streamování platformy.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-227">For cross-platform communication where one of the endpoints is not implemented with WCF, the ability to use streaming depends on the platform's streaming capabilities.</span></span> <span data-ttu-id="bc3c8-228">Další výjimečnou výjimkou může být scénář založený na spotřebě paměti, kdy klient nebo služba musí minimalizovat svou pracovní sadu a může poskytovat jenom malé velikosti vyrovnávací paměti.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-228">Another rare exception might be a memory-consumption driven scenario where a client or service must minimize its working set and can only afford small buffer sizes.</span></span>  
  
### <a name="enabling-asynchronous-streaming"></a><span data-ttu-id="bc3c8-229">Povolení asynchronního streamování</span><span class="sxs-lookup"><span data-stu-id="bc3c8-229">Enabling Asynchronous Streaming</span></span>  
 <span data-ttu-id="bc3c8-230">Pokud chcete povolit asynchronní streamování, přidejte <xref:System.ServiceModel.Description.DispatcherSynchronizationBehavior> do hostitele služby chování koncového bodu a nastavte jeho <xref:System.ServiceModel.Description.DispatcherSynchronizationBehavior.AsynchronousSendEnabled%2A> vlastnost na `true` .</span><span class="sxs-lookup"><span data-stu-id="bc3c8-230">To enable asynchronous streaming, add the  <xref:System.ServiceModel.Description.DispatcherSynchronizationBehavior> endpoint behavior to the service host and set its <xref:System.ServiceModel.Description.DispatcherSynchronizationBehavior.AsynchronousSendEnabled%2A> property to `true`.</span></span> <span data-ttu-id="bc3c8-231">Na straně odeslání jsme také přidali možnost skutečného asynchronního streamování.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-231">We have also added the capability of true asynchronous streaming on the send side.</span></span> <span data-ttu-id="bc3c8-232">To zlepšuje škálovatelnost služby ve scénářích, ve kterých je streamování zpráv do více klientů, jejichž čtení je pravděpodobně způsobeno zahlcením sítě nebo vůbec nečte.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-232">This improves scalability of the service in scenarios where it is streaming messages to multiple clients some of which are slow in reading possibly due to network congestion or are not reading at all.</span></span> <span data-ttu-id="bc3c8-233">V těchto scénářích teď Neblokujte jednotlivá vlákna na službě na klienta.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-233">In these scenarios we now do not block individual threads on the service per client.</span></span> <span data-ttu-id="bc3c8-234">Tím je zajištěno, že služba bude schopna zpracovat mnoho dalších klientů, což zlepšuje škálovatelnost služby.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-234">This ensures that the service is able to process many more clients thereby improving the scalability of the service.</span></span>  
  
### <a name="programming-model-for-streamed-transfers"></a><span data-ttu-id="bc3c8-235">Programovací model pro streamované přenosy</span><span class="sxs-lookup"><span data-stu-id="bc3c8-235">Programming Model for Streamed Transfers</span></span>  
 <span data-ttu-id="bc3c8-236">Programovací model pro streamování je jednoduchý.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-236">The programming model for streaming is straightforward.</span></span> <span data-ttu-id="bc3c8-237">Pro příjem dat odeslaných datovým proudem zadejte kontrakt operace, který má jeden <xref:System.IO.Stream> typový vstupní parametr.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-237">For receiving streamed data, specify an operation contract that has a single <xref:System.IO.Stream> typed input parameter.</span></span> <span data-ttu-id="bc3c8-238">Pokud chcete vracet data z datového proudu, vraťte <xref:System.IO.Stream> odkaz.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-238">For returning streamed data, return a <xref:System.IO.Stream> reference.</span></span>  
  
```csharp
[ServiceContract(Namespace="http://Microsoft.ServiceModel.Samples")]  
public interface IStreamedService  
{  
    [OperationContract]  
    Stream Echo(Stream data);  
    [OperationContract]  
    Stream RequestInfo(string query);  
    [OperationContract(OneWay=true)]  
    void ProvideInfo(Stream data);  
}  
```  
  
 <span data-ttu-id="bc3c8-239">Operace `Echo` v předchozím příkladu přijme a vrátí datový proud a měl by být proto použit ve vazbě s <xref:System.ServiceModel.TransferMode.Streamed> .</span><span class="sxs-lookup"><span data-stu-id="bc3c8-239">The operation `Echo` in the preceding example receives and returns a stream and should therefore be used on a binding with <xref:System.ServiceModel.TransferMode.Streamed>.</span></span> <span data-ttu-id="bc3c8-240">Pro operaci `RequestInfo` <xref:System.ServiceModel.TransferMode.StreamedResponse> je nejvhodnější, protože vrací pouze <xref:System.IO.Stream> .</span><span class="sxs-lookup"><span data-stu-id="bc3c8-240">For the operation `RequestInfo`, <xref:System.ServiceModel.TransferMode.StreamedResponse> is best suited, because it only returns a <xref:System.IO.Stream>.</span></span> <span data-ttu-id="bc3c8-241">Jednosměrná operace je vhodná pro <xref:System.ServiceModel.TransferMode.StreamedRequest> .</span><span class="sxs-lookup"><span data-stu-id="bc3c8-241">The one-way operation is best suited for <xref:System.ServiceModel.TransferMode.StreamedRequest>.</span></span>  
  
 <span data-ttu-id="bc3c8-242">Všimněte si, že přidání druhého parametru do následujících `Echo` nebo `ProvideInfo` operací způsobí, že se model služby vrátí zpět k strategii s vyrovnávací pamětí a použije reprezentace v serializaci datového proudu v době běhu.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-242">Note that adding a second parameter to the following `Echo` or `ProvideInfo` operations causes the service model to revert back to a buffered strategy and use the run-time serialization representation of the stream.</span></span> <span data-ttu-id="bc3c8-243">Pouze operace s jedním vstupním parametrem vstupního datového proudu jsou kompatibilní s koncovým datovým proudem požadavků.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-243">Only operations with a single input stream parameter are compatible with end-to-end request streaming.</span></span>  
  
 <span data-ttu-id="bc3c8-244">Toto pravidlo platí podobně jako u kontraktů zpráv.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-244">This rule similarly applies to message contracts.</span></span> <span data-ttu-id="bc3c8-245">Jak je znázorněno v následujícím kontraktu zprávy, můžete mít v kontraktu zprávy pouze jednoho člena těla, který je datový proud.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-245">As shown in the following message contract, you can have only a single body member in your message contract that is a stream.</span></span> <span data-ttu-id="bc3c8-246">Pokud chcete spolu s datovým proudem sdělit další informace, musí být tyto informace přenesené do záhlaví zpráv.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-246">If you want to communicate additional information with the stream, this information must be a carried in message headers.</span></span> <span data-ttu-id="bc3c8-247">Tělo zprávy je exkluzivně vyhrazené pro obsah datového proudu.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-247">The message body is exclusively reserved for the stream content.</span></span>  
  
```csharp
[MessageContract]  
public class UploadStreamMessage  
{  
   [MessageHeader]  
   public string appRef;  
   [MessageBodyMember]  
   public Stream data;  
}
```  
  
 <span data-ttu-id="bc3c8-248">Konec přenosů streamování a zpráva se zavře, když datový proud dosáhne konce souboru (EOF).</span><span class="sxs-lookup"><span data-stu-id="bc3c8-248">Streamed transfers end and the message is closed when the stream reaches the end of file (EOF).</span></span> <span data-ttu-id="bc3c8-249">Při odesílání zprávy (vrácení hodnoty nebo vyvolání operace) můžete předat <xref:System.IO.FileStream> a infrastruktura WCF následně vyžádat všechna data z tohoto datového proudu, dokud datový proud nebude kompletně načten a dosaženo koncem souboru.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-249">When sending a message (returning a value or invoking an operation), you can pass a <xref:System.IO.FileStream> and the WCF infrastructure subsequently pulls all the data from that stream until the stream has been completely read and reached EOF.</span></span> <span data-ttu-id="bc3c8-250">Chcete-li přenést streamovaná data pro zdroj, který neobsahuje žádnou takovou předem vytvořenou <xref:System.IO.Stream> odvozenou třídu, vytvořte takovou třídu, překrývají tuto třídu přes zdroj datového proudu a použijte ji jako argument nebo návratovou hodnotu.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-250">To transfer streamed data for the source that no such pre-built <xref:System.IO.Stream> derived class exists, construct such a class, overlay that class over your stream source, and use that as the argument or return value.</span></span>  
  
 <span data-ttu-id="bc3c8-251">Při příjmu zprávy vytvoří WCF datový proud prostřednictvím obsahu zprávy kódovaného ve formátu Base64 (nebo příslušné části MIME při použití MTOM) a datový proud dosáhne hodnoty EOF při čtení obsahu.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-251">When receiving a message, WCF constructs a stream over the Base64-encoded message body content (or the respective MIME part if using MTOM) and the stream reaches EOF when the content has been read.</span></span>  
  
 <span data-ttu-id="bc3c8-252">Streamování na úrovni přenosu funguje i u všech dalších typů kontraktů zpráv (seznamů parametrů, argumentů kontraktů dat a explicitního kontraktu zprávy), ale protože serializace a deserializace těchto zapisovaných zpráv vyžaduje ukládání do vyrovnávací paměti serializátorem, není vhodné tyto varianty použít.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-252">Transport-level streaming also works with any other message contract type (parameter lists, data contract arguments, and explicit message contract), but because the serialization and deserialization of such typed messages requires buffering by the serializer, using such contract variants is not advisable.</span></span>  
  
### <a name="special-security-considerations-for-large-data"></a><span data-ttu-id="bc3c8-253">Zvláštní důležité požadavky na zabezpečení pro velké objemy dat</span><span class="sxs-lookup"><span data-stu-id="bc3c8-253">Special Security Considerations for Large Data</span></span>  
 <span data-ttu-id="bc3c8-254">Všechny vazby umožňují omezit velikost příchozích zpráv, aby nedocházelo k útokům DOS (Denial-of-Service).</span><span class="sxs-lookup"><span data-stu-id="bc3c8-254">All bindings allow you to constrain the size of incoming messages to prevent denial-of-service attacks.</span></span> <span data-ttu-id="bc3c8-255"><xref:System.ServiceModel.BasicHttpBinding>Například zpřístupňuje vlastnost [System. ServiceModel. BasicHttpBinding. MaxReceivedMessageSize](xref:System.ServiceModel.HttpBindingBase.MaxReceivedMessageSize%2A) , která se váže na velikost příchozí zprávy, a tak také vymezí maximální množství paměti, ke které dojde při zpracování zprávy.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-255">The <xref:System.ServiceModel.BasicHttpBinding>, for example, exposes a [System.ServiceModel.BasicHttpBinding.MaxReceivedMessageSize](xref:System.ServiceModel.HttpBindingBase.MaxReceivedMessageSize%2A) property that bounds the size of the incoming message, and so also bounds the maximum amount of memory that is accessed when processing the message.</span></span> <span data-ttu-id="bc3c8-256">Tato jednotka je nastavena v bajtech s výchozí hodnotou 65 536 bajtů.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-256">This unit is set in bytes with a default value of 65,536 bytes.</span></span>  
  
 <span data-ttu-id="bc3c8-257">Bezpečnostní hrozba, která je specifická pro scénář rozsáhlého streamování dat, provokes odepření služby tím, že způsobí, že data budou ukládána do vyrovnávací paměti, když příjemce očekává streamování.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-257">A security threat that is specific to the large data streaming scenario provokes a denial of service by causing data to be buffered when the receiver expects it to be streamed.</span></span> <span data-ttu-id="bc3c8-258">Například technologie WCF vždycky ukládá do vyrovnávací paměti hlavičky SOAP zprávy a útočník tak může vytvořit velkou škodlivou zprávu, která se skládá výhradně z hlaviček k vynucení ukládání dat do vyrovnávací paměti.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-258">For example, WCF always buffers the SOAP headers of a message, and so an attacker may construct a large malicious message that consists entirely of headers to force the data to be buffered.</span></span> <span data-ttu-id="bc3c8-259">Pokud je povoleno streamování, `MaxReceivedMessageSize` může být nastaveno na velmi velkou hodnotu, protože přijímač nikdy neočekává, že celá zpráva bude ukládána do vyrovnávací paměti najednou.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-259">When streaming is enabled, the `MaxReceivedMessageSize` may be set to an extremely large value, because the receiver never expects the entire message to be buffered in memory at once.</span></span> <span data-ttu-id="bc3c8-260">Pokud je do vyrovnávací paměti služby WCF vynuceně ukládat zprávy, dojde k přetečení paměti.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-260">If WCF is forced to buffer the message, a memory overflow occurs.</span></span>  
  
 <span data-ttu-id="bc3c8-261">Proto omezení maximální velikosti příchozích zpráv není v tomto případě dostatečné.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-261">Therefore, restricting the maximum incoming message size is not enough in this case.</span></span> <span data-ttu-id="bc3c8-262">`MaxBufferSize`Vlastnost je vyžadována k omezení paměti, kterou jsou vyrovnávací paměti WCF.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-262">The `MaxBufferSize` property is required to constrain the memory that WCF buffers.</span></span> <span data-ttu-id="bc3c8-263">Je důležité nastavit tuto hodnotu jako bezpečnou (nebo zachovat výchozí hodnotu) při streamování.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-263">It is important to set this to a safe value (or keep it at the default value) when streaming.</span></span> <span data-ttu-id="bc3c8-264">Předpokládejme například, že vaše služba musí přijímat soubory o velikosti až 4 GB a ukládat je na místní disk.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-264">For example, suppose your service must receive files up to 4 GB in size and store them on the local disk.</span></span> <span data-ttu-id="bc3c8-265">Předpokládejme také, že vaše paměť je omezená takovým způsobem, že můžete najednou ukládat jenom 64 KB dat.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-265">Suppose also that your memory is constrained in such a way that you can only buffer 64 KB of data at a time.</span></span> <span data-ttu-id="bc3c8-266">Pak byste nastavili na `MaxReceivedMessageSize` 4 GB a `MaxBufferSize` až 64 KB.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-266">Then you would set the `MaxReceivedMessageSize` to 4 GB and `MaxBufferSize` to 64 KB.</span></span> <span data-ttu-id="bc3c8-267">V rámci vaší implementace služby je také potřeba zajistit, abyste si přečetli jenom z příchozího datového proudu v blocích 64 – KB a nepřečetli další blok dat, než se předchozí zapsal na disk a zahodil z paměti.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-267">Also, in your service implementation, you must ensure that you read only from the incoming stream in 64-KB chunks and do not read the next chunk before the previous one has been written to disk and discarded from memory.</span></span>  
  
 <span data-ttu-id="bc3c8-268">Je také důležité pochopit, že tato kvóta omezuje pouze ukládání do vyrovnávací paměti prováděné službou WCF a nemůže chránit proti ukládání do vyrovnávací paměti, které provádíte ve vlastní službě nebo implementaci klientů.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-268">It is also important to understand that this quota only limits the buffering done by WCF and cannot protect you against any buffering that you do in your own service or client implementation.</span></span> <span data-ttu-id="bc3c8-269">Další informace o dalších požadavcích na zabezpečení najdete v tématu [požadavky na zabezpečení pro data](security-considerations-for-data.md).</span><span class="sxs-lookup"><span data-stu-id="bc3c8-269">For more information about additional security considerations, see [Security Considerations for Data](security-considerations-for-data.md).</span></span>  
  
> [!NOTE]
> <span data-ttu-id="bc3c8-270">Rozhodnutí použít buď vyrovnávací paměť, nebo přenos streamování je místní rozhodnutí koncového bodu.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-270">The decision to use either buffered or streamed transfers is a local decision of the endpoint.</span></span> <span data-ttu-id="bc3c8-271">V případě přenosů HTTP se režim přenosu nešíří mezi připojeními nebo proxy servery a dalšími zprostředkovateli.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-271">For HTTP transports, the transfer mode does not propagate across a connection or to proxy servers and other intermediaries.</span></span> <span data-ttu-id="bc3c8-272">Nastavení režimu přenosu se neprojeví v popisu rozhraní služby.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-272">Setting the transfer mode is not reflected in the description of the service interface.</span></span> <span data-ttu-id="bc3c8-273">Po vygenerování klienta WCF ke službě musíte upravit konfigurační soubor pro služby, které mají být použity s datovým proudem přenosů, a nastavit režim.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-273">After generating a WCF client to a service, you must edit the configuration file for services intended to be used with streamed transfers to set the mode.</span></span> <span data-ttu-id="bc3c8-274">Pro přenosy TCP a pojmenovaného kanálu je Přenosový režim šířen jako kontrolní výraz zásady.</span><span class="sxs-lookup"><span data-stu-id="bc3c8-274">For TCP and named pipe transports, the transfer mode is propagated as a policy assertion.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="bc3c8-275">Viz také</span><span class="sxs-lookup"><span data-stu-id="bc3c8-275">See also</span></span>

- [<span data-ttu-id="bc3c8-276">Postupy: Povolení streamování</span><span class="sxs-lookup"><span data-stu-id="bc3c8-276">How to: Enable Streaming</span></span>](how-to-enable-streaming.md)
