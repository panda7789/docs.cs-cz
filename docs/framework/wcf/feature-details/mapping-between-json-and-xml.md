---
title: Mapování mezi JSON a XML
ms.date: 03/30/2017
ms.assetid: 22ee1f52-c708-4024-bbf0-572e0dae64af
ms.openlocfilehash: 55812ad15d1f38bb0c295e6895dfff329035206d
ms.sourcegitcommit: 927b7ea6b2ea5a440c8f23e3e66503152eb85591
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 04/16/2020
ms.locfileid: "81464068"
---
# <a name="mapping-between-json-and-xml"></a><span data-ttu-id="d91ea-102">Mapování mezi JSON a XML</span><span class="sxs-lookup"><span data-stu-id="d91ea-102">Mapping Between JSON and XML</span></span>
<span data-ttu-id="d91ea-103">Čtenáři a autoři <xref:System.Runtime.Serialization.Json.JsonReaderWriterFactory> vytvořené poskytují XML API přes JavaScript zápis objektu (JSON) obsah.</span><span class="sxs-lookup"><span data-stu-id="d91ea-103">The readers and writers produced by the <xref:System.Runtime.Serialization.Json.JsonReaderWriterFactory> provide an XML API over JavaScript Object Notation (JSON) content.</span></span> <span data-ttu-id="d91ea-104">JSON kóduje data pomocí podmnožiny literál objektu JavaScriptu.</span><span class="sxs-lookup"><span data-stu-id="d91ea-104">JSON encodes data using a subset of the object literals of JavaScript.</span></span> <span data-ttu-id="d91ea-105">Čtenáři a autoři vyrobené v této továrně se také používají při json obsah je <xref:System.ServiceModel.Channels.WebMessageEncodingBindingElement> odesílán nebo přijímán Windows Communication Foundation (WCF) aplikace pomocí nebo <xref:System.ServiceModel.WebHttpBinding>.</span><span class="sxs-lookup"><span data-stu-id="d91ea-105">The readers and writers produced by this factory are also used when JSON content is being sent or received by Windows Communication Foundation (WCF) applications using the <xref:System.ServiceModel.Channels.WebMessageEncodingBindingElement> or the <xref:System.ServiceModel.WebHttpBinding>.</span></span>

<span data-ttu-id="d91ea-106">Při inicializování s obsahem JSON se čtečka JSON chová stejným způsobem jako textová čtečka XML přes instanci XML.</span><span class="sxs-lookup"><span data-stu-id="d91ea-106">When initialized with JSON content, the JSON reader behaves in the same way that a textual XML reader does over an instance of XML.</span></span> <span data-ttu-id="d91ea-107">Zapisovač JSON, když dostal posloupnost volání, která na textové matné čtečce XML vytvoří určitou instanci XML, zapíše obsah JSON.</span><span class="sxs-lookup"><span data-stu-id="d91ea-107">The JSON writer, when given a sequence of calls that on a textual XML reader produces a certain XML instance, writes out JSON content.</span></span> <span data-ttu-id="d91ea-108">Mapování mezi touto instancí XML a obsahem JSON je popsáno v tomto tématu pro použití v pokročilých scénářích.</span><span class="sxs-lookup"><span data-stu-id="d91ea-108">The mapping between this instance of XML and the JSON content is described in this topic for use in advanced scenarios.</span></span>

<span data-ttu-id="d91ea-109">Interně json je reprezentován jako xml infoset při zpracování WCF.</span><span class="sxs-lookup"><span data-stu-id="d91ea-109">Internally, JSON is represented as an XML infoset when processed by WCF.</span></span> <span data-ttu-id="d91ea-110">Obvykle se nemusíte zabývat touto vnitřní reprezentací, protože mapování je pouze logické: JSON obvykle není fyzicky převeden na XML v paměti nebo převeden na JSON z XML.</span><span class="sxs-lookup"><span data-stu-id="d91ea-110">Normally you do not have to be concerned with this internal representation as the mapping is only a logical one: JSON is normally not physically converted to XML in memory or converted to JSON from XML.</span></span> <span data-ttu-id="d91ea-111">Mapování znamená, že rozhraní XML API se používají pro přístup k obsahu JSON.</span><span class="sxs-lookup"><span data-stu-id="d91ea-111">The mapping means that XML APIs are used to access JSON content.</span></span>

<span data-ttu-id="d91ea-112">Když WCF používá JSON, obvyklý <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> scénář je, že <xref:System.ServiceModel.Description.WebScriptEnablingBehavior> je automaticky zapojen <xref:System.ServiceModel.Description.WebHttpBehavior> chování nebo chování v případě potřeby.</span><span class="sxs-lookup"><span data-stu-id="d91ea-112">When WCF uses JSON, the usual scenario is that the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> is automatically plugged in by the <xref:System.ServiceModel.Description.WebScriptEnablingBehavior> behavior, or by the <xref:System.ServiceModel.Description.WebHttpBehavior> behavior when appropriate.</span></span> <span data-ttu-id="d91ea-113">Rozumí <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> mapování mezi JSON a xml infoset a chová, jako by se zabývá JSON přímo.</span><span class="sxs-lookup"><span data-stu-id="d91ea-113">The <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> understands the mapping between JSON and the XML infoset and acts as if it is dealing with JSON directly.</span></span> <span data-ttu-id="d91ea-114">(Je možné použít <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> s libovolnou čtečku XML nebo zapisovatel, s vědomím, že XML odpovídá následující mapování.)</span><span class="sxs-lookup"><span data-stu-id="d91ea-114">(It is possible to use the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> with any XML reader or writer, with the understanding that the XML conforms to the following mapping.)</span></span>

<span data-ttu-id="d91ea-115">V pokročilých scénářích může být nutné získat přímý přístup k následujícímu mapování.</span><span class="sxs-lookup"><span data-stu-id="d91ea-115">In advanced scenarios, it may become necessary to directly access the following mapping.</span></span> <span data-ttu-id="d91ea-116">Tyto scénáře nastat, pokud chcete serializovat a rekonstruovat JSON vlastní způsoby, bez spoléhání se na <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer>, nebo při práci s typem <xref:System.ServiceModel.Channels.Message> přímo pro zprávy obsahující JSON.</span><span class="sxs-lookup"><span data-stu-id="d91ea-116">These scenarios occur when you want to serialize and deserialize JSON in custom ways, without relying on the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer>, or when dealing with the <xref:System.ServiceModel.Channels.Message> type directly for messages containing JSON.</span></span> <span data-ttu-id="d91ea-117">Mapování JSON-XML se používá také pro protokolování zpráv.</span><span class="sxs-lookup"><span data-stu-id="d91ea-117">The JSON-XML mapping is also used for message logging.</span></span> <span data-ttu-id="d91ea-118">Při použití funkce protokolování zpráv v WCF, JSON zprávy jsou zaznamenány jako XML podle mapování popsaného v další části.</span><span class="sxs-lookup"><span data-stu-id="d91ea-118">When using the message logging feature in WCF, JSON messages is logged as XML according to the mapping described in the next section.</span></span>

<span data-ttu-id="d91ea-119">Chcete-li objasnit pojem mapování, následující příklad je dokumentu JSON.</span><span class="sxs-lookup"><span data-stu-id="d91ea-119">To clarify the concept of a mapping, the following example is of a JSON document.</span></span>

```json
{"product":"pencil","price":12}
```

<span data-ttu-id="d91ea-120">Chcete-li číst tento dokument JSON pomocí jednoho z čtenářů <xref:System.Xml.XmlDictionaryReader> výše uvedených, použijte stejnou posloupnost volání jako byste číst následující dokument XML.</span><span class="sxs-lookup"><span data-stu-id="d91ea-120">To read this JSON document using one of the readers previously mentioned, use the same sequence of <xref:System.Xml.XmlDictionaryReader> calls as you would to read the following XML document.</span></span>

```xml
<root type="object">
    <product type="string">pencil</product>
    <price type="number">12</price>
</root>
```

<span data-ttu-id="d91ea-121">Kromě toho pokud zpráva JSON v příkladu je přijatwcf a zaznamenány, uvidíte fragment XML v předchozím protokolu.</span><span class="sxs-lookup"><span data-stu-id="d91ea-121">Furthermore, if the JSON message in the example is received by WCF and logged, you would see the XML fragment in the preceding log.</span></span>

## <a name="mapping-between-json-and-the-xml-infoset"></a><span data-ttu-id="d91ea-122">Mapování mezi jazykem JSON a informační sadou XML</span><span class="sxs-lookup"><span data-stu-id="d91ea-122">Mapping Between JSON and the XML Infoset</span></span>

<span data-ttu-id="d91ea-123">Formálně je mapování mezi JSON, jak je popsáno v [RFC 4627](https://www.ietf.org/rfc/rfc4627.txt) (s výjimkou určitých omezení uvolněná a některá další omezení přidána) a XML infoset (a ne textové XML), jak je popsáno v [XML Information Set](https://www.w3.org/TR/2004/REC-xml-infoset-20040204/).</span><span class="sxs-lookup"><span data-stu-id="d91ea-123">Formally, the mapping is between JSON as described in [RFC 4627](https://www.ietf.org/rfc/rfc4627.txt) (except with certain restrictions relaxed and certain other restrictions added) and the XML infoset (and not textual XML) as described in [XML Information Set](https://www.w3.org/TR/2004/REC-xml-infoset-20040204/).</span></span> <span data-ttu-id="d91ea-124">Definice *informačních položek* a polí v [hranaté závorce].</span><span class="sxs-lookup"><span data-stu-id="d91ea-124">See this topic for the definitions of *information items* and fields in [square brackets].</span></span>

<span data-ttu-id="d91ea-125">Prázdný dokument JSON se mapuje na prázdný dokument XML a prázdný dokument XML se mapuje na prázdný dokument JSON.</span><span class="sxs-lookup"><span data-stu-id="d91ea-125">A blank JSON document maps to a blank XML document, and a blank XML document maps to a blank JSON document.</span></span> <span data-ttu-id="d91ea-126">V mapování XML na JSON nejsou povoleny předchozí prázdné znaky a koncové prázdné znaky za dokumentem.</span><span class="sxs-lookup"><span data-stu-id="d91ea-126">On the XML to JSON mapping, preceding white space and trailing white space after the document are not allowed.</span></span>

<span data-ttu-id="d91ea-127">Mapování je definováno mezi položkou informace o dokumentu (DII) nebo položkou informací o prvku (EII) a jsonem.</span><span class="sxs-lookup"><span data-stu-id="d91ea-127">The mapping is defined between either a Document Information Item (DII) or an Element Information Item (EII) and JSON.</span></span> <span data-ttu-id="d91ea-128">EII nebo DII [document element] vlastnost, se označuje jako kořenový prvek JSON.</span><span class="sxs-lookup"><span data-stu-id="d91ea-128">The EII, or the DII’s [document element] property, is referred to as the Root JSON Element.</span></span> <span data-ttu-id="d91ea-129">Všimněte si, že fragmenty dokumentu (XML s více kořenovými prvky) nejsou v tomto mapování podporovány.</span><span class="sxs-lookup"><span data-stu-id="d91ea-129">Note that document fragments (XML with multiple root elements) are not supported in this mapping.</span></span>

<span data-ttu-id="d91ea-130">Příklad: Následující dokument:</span><span class="sxs-lookup"><span data-stu-id="d91ea-130">Example: The following document:</span></span>

```xml
<?xml version="1.0"?>
<root type="number">42</root>
```

<span data-ttu-id="d91ea-131">A následující prvek:</span><span class="sxs-lookup"><span data-stu-id="d91ea-131">And the following element:</span></span>

```xml
<root type="number">42</root>
```

<span data-ttu-id="d91ea-132">Oba mají mapování na JSON.</span><span class="sxs-lookup"><span data-stu-id="d91ea-132">Both have a mapping to JSON.</span></span> <span data-ttu-id="d91ea-133">Prvek `root` <> je kořenový prvek JSON v obou případech.</span><span class="sxs-lookup"><span data-stu-id="d91ea-133">The <`root`> element is the Root JSON Element in both cases.</span></span>

<span data-ttu-id="d91ea-134">Kromě toho by se v případě DII mělo zvážit:</span><span class="sxs-lookup"><span data-stu-id="d91ea-134">Furthermore, in the case of a DII, the following should be considered:</span></span>

- <span data-ttu-id="d91ea-135">Některé položky v seznamu [podřízené] nesmí být k dispozici.</span><span class="sxs-lookup"><span data-stu-id="d91ea-135">Some items in the [children] list must not be present.</span></span> <span data-ttu-id="d91ea-136">Nespoléhejte na tuto skutečnost při čtení XML mapované z JSON.</span><span class="sxs-lookup"><span data-stu-id="d91ea-136">Do not rely on this fact when reading XML mapped from JSON.</span></span>

- <span data-ttu-id="d91ea-137">Seznam [podřízené] obsahuje žádné položky informací o komentářích.</span><span class="sxs-lookup"><span data-stu-id="d91ea-137">The [children] list holds no comment information items.</span></span>

- <span data-ttu-id="d91ea-138">Seznam [podřízených] neobsahuje žádné položky informací DTD.</span><span class="sxs-lookup"><span data-stu-id="d91ea-138">The [children] list holds no DTD information items.</span></span>

- <span data-ttu-id="d91ea-139">Seznam [podřízených] neobsahuje žádné položky `<?xml…>` informací o osobních údajích (prohlášení není považováno za informační položku PI)</span><span class="sxs-lookup"><span data-stu-id="d91ea-139">The [children] list holds no personal Information (PI) information items (the `<?xml…>` declaration is not considered a PI information item)</span></span>

- <span data-ttu-id="d91ea-140">Sada [notations] je prázdná.</span><span class="sxs-lookup"><span data-stu-id="d91ea-140">The [notations] set is empty.</span></span>

- <span data-ttu-id="d91ea-141">Sada [neanalyzovaných entit] je prázdná.</span><span class="sxs-lookup"><span data-stu-id="d91ea-141">The [unparsed entities] set is empty.</span></span>

<span data-ttu-id="d91ea-142">Příklad: Následující dokument nemá žádné mapování na JSON, protože [children] obsahuje PI a komentář.</span><span class="sxs-lookup"><span data-stu-id="d91ea-142">Example: The following document has no mapping to JSON because [children] holds a PI and a comment.</span></span>

```xml
<?xml version="1.0"?>
<!--comment--><?pi?>
<root type="number">42</root>
```

<span data-ttu-id="d91ea-143">EII pro kořenový prvek JSON má následující charakteristiky:</span><span class="sxs-lookup"><span data-stu-id="d91ea-143">The EII for the Root JSON Element has the following characteristics:</span></span>

- <span data-ttu-id="d91ea-144">[místní název] má hodnotu "root".</span><span class="sxs-lookup"><span data-stu-id="d91ea-144">[local name] has the value "root".</span></span>

- <span data-ttu-id="d91ea-145">[název oboru názvů] nemá žádnou hodnotu.</span><span class="sxs-lookup"><span data-stu-id="d91ea-145">[namespace name] has no value.</span></span>

- <span data-ttu-id="d91ea-146">[prefix] nemá žádnou hodnotu.</span><span class="sxs-lookup"><span data-stu-id="d91ea-146">[prefix] has no value.</span></span>

- <span data-ttu-id="d91ea-147">[podřízené] mohou obsahovat buď EII (které představují vnitřní prvky, jak je popsáno dále) nebo CII (položky informací o charakteru, jak je popsáno dále), nebo žádný z nich, ale ne obojí.</span><span class="sxs-lookup"><span data-stu-id="d91ea-147">[children] may either contain EIIs (which represent Inner Elements as described further) or CIIs (Character Information Items as described further) or none of these, but not both.</span></span>

- <span data-ttu-id="d91ea-148">[atributy] mohou obsahovat následující volitelné položky informací o atributech (AII)</span><span class="sxs-lookup"><span data-stu-id="d91ea-148">[attributes] may contain the following optional attribute information items (AIIs)</span></span>

- <span data-ttu-id="d91ea-149">Atribut typu JSON ("typ"),jak je popsáno dále.</span><span class="sxs-lookup"><span data-stu-id="d91ea-149">The JSON Type Attribute ("type") as described further.</span></span> <span data-ttu-id="d91ea-150">Tento atribut se používá k zachování typu JSON (řetězec, číslo, logická hodnota, objekt, pole nebo null) v mapovaném XML.</span><span class="sxs-lookup"><span data-stu-id="d91ea-150">This attribute is used to preserve the JSON type (string, number, boolean, object, array or null) in the mapped XML.</span></span>

- <span data-ttu-id="d91ea-151">Atribut název kontraktu\_\_dat ("typ"), jak je popsáno dále.</span><span class="sxs-lookup"><span data-stu-id="d91ea-151">The Data Contract Name Attribute ("\_\_type") as described further.</span></span> <span data-ttu-id="d91ea-152">Tento atribut může být přítomen pouze v případě, že atribut typu JSON je také přítomen a jeho [normalizovaná hodnota] je "objekt".</span><span class="sxs-lookup"><span data-stu-id="d91ea-152">This attribute is can only be present if the JSON type attribute is also present and its [normalized value] is "object".</span></span> <span data-ttu-id="d91ea-153">Tento atribut používá `DataContractJsonSerializer` k zachování informací o typu datové smlouvy – například v polymorfních případech, kdy je odvozený typ serializován a kde se očekává základní typ.</span><span class="sxs-lookup"><span data-stu-id="d91ea-153">This attribute is used by the `DataContractJsonSerializer` to preserve data contract type information - for example, in polymorphic cases where a derived type is serialized and where a base type is expected.</span></span> <span data-ttu-id="d91ea-154">Pokud nepracujete s `DataContractJsonSerializer`, ve většině případů je tento atribut ignorován.</span><span class="sxs-lookup"><span data-stu-id="d91ea-154">If you are not working with the `DataContractJsonSerializer`, in most cases, this attribute is ignored.</span></span>

- <span data-ttu-id="d91ea-155">[in-scope namespaces] obsahuje vazbu "xml" na `http://www.w3.org/XML/1998/namespace` nařízeno specifikací infoset.</span><span class="sxs-lookup"><span data-stu-id="d91ea-155">[in-scope namespaces] contains the binding of "xml" to `http://www.w3.org/XML/1998/namespace` as mandated by the infoset specification.</span></span>

- <span data-ttu-id="d91ea-156">[children], [attributes] a [in-scope namespaces] nesmí mít žádné jiné položky než jak bylo uvedeno dříve a [atributy oboru názvů] nesmí mít žádné členy, ale při čtení XML mapovaného z JSON se na tyto skutečnosti nespoléhají.</span><span class="sxs-lookup"><span data-stu-id="d91ea-156">[children], [attributes] and [in-scope namespaces] must not have any items other than as specified previously and [namespace attributes] must have no members, but do not rely on these facts when reading XML mapped from JSON.</span></span>

<span data-ttu-id="d91ea-157">Příklad: Následující dokument nemá žádné mapování na JSON, protože [atributy oboru názvů] není prázdný.</span><span class="sxs-lookup"><span data-stu-id="d91ea-157">Example: The following document has no mapping to JSON because [namespace attributes] is not empty.</span></span>

```xml
<?xml version="1.0"?>
<root xmlns:a="myattributevalue">42</root>
```

<span data-ttu-id="d91ea-158">AII pro atribut typu JSON má následující charakteristiky:</span><span class="sxs-lookup"><span data-stu-id="d91ea-158">The AII for the JSON Type Attribute has the following characteristics:</span></span>

- <span data-ttu-id="d91ea-159">[název oboru názvů] nemá žádnou hodnotu.</span><span class="sxs-lookup"><span data-stu-id="d91ea-159">[namespace name] has no value.</span></span>
- <span data-ttu-id="d91ea-160">[prefix] nemá žádnou hodnotu.</span><span class="sxs-lookup"><span data-stu-id="d91ea-160">[prefix] has no value.</span></span>
- <span data-ttu-id="d91ea-161">[místní název] je "typ".</span><span class="sxs-lookup"><span data-stu-id="d91ea-161">[local name] is "type".</span></span>
- <span data-ttu-id="d91ea-162">[normalizovaná hodnota] je jednou z možných hodnot typu popsaných v následující části.</span><span class="sxs-lookup"><span data-stu-id="d91ea-162">[normalized value] is one of the possible type values described in the following section.</span></span>
- <span data-ttu-id="d91ea-163">[zadáno] `true`je .</span><span class="sxs-lookup"><span data-stu-id="d91ea-163">[specified] is `true`.</span></span>
- <span data-ttu-id="d91ea-164">[typ atributu] nemá žádnou hodnotu.</span><span class="sxs-lookup"><span data-stu-id="d91ea-164">[attribute type] has no value.</span></span>
- <span data-ttu-id="d91ea-165">[reference] nemá žádnou hodnotu.</span><span class="sxs-lookup"><span data-stu-id="d91ea-165">[references] has no value.</span></span>

<span data-ttu-id="d91ea-166">AII pro atribut název smlouvy dat má následující charakteristiky:</span><span class="sxs-lookup"><span data-stu-id="d91ea-166">The AII for the Data Contract Name Attribute has the following characteristics:</span></span>

- <span data-ttu-id="d91ea-167">[název oboru názvů] nemá žádnou hodnotu.</span><span class="sxs-lookup"><span data-stu-id="d91ea-167">[namespace name] has no value.</span></span>
- <span data-ttu-id="d91ea-168">[prefix] nemá žádnou hodnotu.</span><span class="sxs-lookup"><span data-stu-id="d91ea-168">[prefix] has no value.</span></span>
- <span data-ttu-id="d91ea-169">[místní název]\_\_je " typ" (dvě podtržítka a pak "typ").</span><span class="sxs-lookup"><span data-stu-id="d91ea-169">[local name] is "\_\_type" (two underscores and then "type").</span></span>
- <span data-ttu-id="d91ea-170">[normalizovaná hodnota] je libovolný platný řetězec Unicode – mapování tohoto řetězce na JSON je popsáno v následující části.</span><span class="sxs-lookup"><span data-stu-id="d91ea-170">[normalized value] is any valid Unicode string – the mapping of this string to JSON is described in the following section.</span></span>
- <span data-ttu-id="d91ea-171">[zadáno] `true`je .</span><span class="sxs-lookup"><span data-stu-id="d91ea-171">[specified] is `true`.</span></span>
- <span data-ttu-id="d91ea-172">[typ atributu] nemá žádnou hodnotu.</span><span class="sxs-lookup"><span data-stu-id="d91ea-172">[attribute type] has no value.</span></span>
- <span data-ttu-id="d91ea-173">[reference] nemá žádnou hodnotu.</span><span class="sxs-lookup"><span data-stu-id="d91ea-173">[references] has no value.</span></span>

<span data-ttu-id="d91ea-174">Vnitřní prvky obsažené v kořenovém prvku JSON nebo jiné vnitřní prvky mají následující vlastnosti:</span><span class="sxs-lookup"><span data-stu-id="d91ea-174">Inner elements contained within the Root JSON Element or other inner elements have the following characteristics:</span></span>

- <span data-ttu-id="d91ea-175">[místní název] může mít libovolnou hodnotu, jak je popsáno dále.</span><span class="sxs-lookup"><span data-stu-id="d91ea-175">[local name] may have any value as described further.</span></span>
- <span data-ttu-id="d91ea-176">[název oboru názvů], [prefix], [children], [atributy], [atributy oboru názvů] a [in-scope namespaces] podléhají stejným pravidlům jako kořenový prvek JSON.</span><span class="sxs-lookup"><span data-stu-id="d91ea-176">[namespace name], [prefix], [children], [attributes], [namespace attributes], and [in-scope namespaces] are subject to the same rules as the Root JSON Element.</span></span>

<span data-ttu-id="d91ea-177">V root JSON element a vnitřní prvky Atribut typu JSON definuje mapování JSON a možné [podřízené] a jejich interpretace.</span><span class="sxs-lookup"><span data-stu-id="d91ea-177">In both the Root JSON Element and the inner elements, the JSON Type Attribute defines the mapping to JSON and the possible [children] and their interpretation.</span></span> <span data-ttu-id="d91ea-178">Atribut [normalizované hodnoty] rozlišuje malá a velká písmena a musí být malá písmena a nesmí obsahovat prázdné znaky.</span><span class="sxs-lookup"><span data-stu-id="d91ea-178">The attribute’s [normalized value] is case-sensitive and must be lowercase, and cannot contain white space.</span></span>

|<span data-ttu-id="d91ea-179">[normalizovaná hodnota] AII atributu typu JSON</span><span class="sxs-lookup"><span data-stu-id="d91ea-179">[normalized value] of JSON Type Attribute’s AII</span></span>|<span data-ttu-id="d91ea-180">Povolené [děti] odpovídajícího EI</span><span class="sxs-lookup"><span data-stu-id="d91ea-180">Allowed [children] of the corresponding EII</span></span>|<span data-ttu-id="d91ea-181">Mapování na JSON</span><span class="sxs-lookup"><span data-stu-id="d91ea-181">Mapping to JSON</span></span>|
|---------------------------------------------------------|---------------------------------------------------|---------------------|
|<span data-ttu-id="d91ea-182">`string`(nebo nepřítomnost typu JSON AII)</span><span class="sxs-lookup"><span data-stu-id="d91ea-182">`string` (or absence of the JSON type AII)</span></span><br /><br /> <span data-ttu-id="d91ea-183">A `string` a absence typu JSON AII jsou `string` stejné dělá výchozí.</span><span class="sxs-lookup"><span data-stu-id="d91ea-183">A `string` and the absence of the JSON type AII are the same makes `string` the default.</span></span><br /><br /> <span data-ttu-id="d91ea-184">Takže `<root> string1</root>` mapy na JSON `string` "string1".</span><span class="sxs-lookup"><span data-stu-id="d91ea-184">So, `<root> string1</root>` maps to the JSON `string` "string1".</span></span>|<span data-ttu-id="d91ea-185">0 nebo více CII</span><span class="sxs-lookup"><span data-stu-id="d91ea-185">0 or more CIIs</span></span>|<span data-ttu-id="d91ea-186">A JSON `string` (JSON RFC, oddíl 2.5).</span><span class="sxs-lookup"><span data-stu-id="d91ea-186">A JSON `string` (JSON RFC, section 2.5).</span></span> <span data-ttu-id="d91ea-187">Každý `char` je znak, který odpovídá [kód znaku] z CII.</span><span class="sxs-lookup"><span data-stu-id="d91ea-187">Each `char` is a character that corresponds to the [character code] from the CII.</span></span> <span data-ttu-id="d91ea-188">Pokud nejsou k dispozici žádné CII, mapuje se na prázdný JSON `string`.</span><span class="sxs-lookup"><span data-stu-id="d91ea-188">If there are no CIIs, it maps to an empty JSON `string`.</span></span><br /><br /> <span data-ttu-id="d91ea-189">Příklad: Následující prvek se mapuje na fragment JSON:</span><span class="sxs-lookup"><span data-stu-id="d91ea-189">Example: The following element maps to a JSON fragment:</span></span><br /><br /> `<root type="string">42</root>`<br /><br /> <span data-ttu-id="d91ea-190">Fragment JSON je "42".</span><span class="sxs-lookup"><span data-stu-id="d91ea-190">The JSON fragment is "42".</span></span><br /><br /> <span data-ttu-id="d91ea-191">Při mapování XML na JSON znaky, které musí být uvozeny mapování mazemi na uvozené znaky, všechny ostatní mapovat na znaky, které nejsou uvozeny.</span><span class="sxs-lookup"><span data-stu-id="d91ea-191">On XML to JSON mapping, characters that must be escaped map to escaped characters, all others map to characters that are not escaped.</span></span> <span data-ttu-id="d91ea-192">Znak "/" je zvláštní – je uvozen, i když nemusí\\být (zapsán jako " /").</span><span class="sxs-lookup"><span data-stu-id="d91ea-192">The "/" character is special – it is escaped even though it does not have to be (written out as "\\/").</span></span><br /><br /> <span data-ttu-id="d91ea-193">Příklad: Následující prvek se mapuje na fragment JSON.</span><span class="sxs-lookup"><span data-stu-id="d91ea-193">Example: The following element maps to a JSON fragment.</span></span><br /><br /> `<root type="string">the "da/ta"</root>`<br /><br /> <span data-ttu-id="d91ea-194">Fragment JSON je \\"da\\/ta\\"".</span><span class="sxs-lookup"><span data-stu-id="d91ea-194">The JSON fragment is "the \\"da\\/ta\\"".</span></span><br /><br /> <span data-ttu-id="d91ea-195">Při mapování JSON na XML všechny řídicí znaky a znaky, které nejsou uvozeny mapování správně odpovídající [kód znaku].</span><span class="sxs-lookup"><span data-stu-id="d91ea-195">On JSON to XML mapping, any escaped characters and characters that are not escaped map correctly to the corresponding [character code].</span></span><br /><br /> <span data-ttu-id="d91ea-196">Příklad: Fragment JSON "\u0041BC", mapuje na následující element XML.</span><span class="sxs-lookup"><span data-stu-id="d91ea-196">Example: The JSON fragment "\u0041BC", maps to the following XML element.</span></span><br /><br /> `<root type="string">ABC</root>`<br /><br /> <span data-ttu-id="d91ea-197">Řetězec může být obklopen prázdné místo ('ws' v části 2 JSON RFC), který není získat mapovány na XML.</span><span class="sxs-lookup"><span data-stu-id="d91ea-197">The string can be surrounded by white space ('ws' in section 2 of the JSON RFC) that does not get mapped to XML.</span></span><br /><br /> <span data-ttu-id="d91ea-198">Příklad: Fragment JSON "ABC", (před první dvojitou uvozovkou jsou mezery), mapuje se na následující element XML.</span><span class="sxs-lookup"><span data-stu-id="d91ea-198">Example: The JSON fragment           "ABC", (there are spaces before the first double quote), maps to the following XML element.</span></span><br /><br /> `<root type="string">ABC</root>`<br /><br /> <span data-ttu-id="d91ea-199">Jakékoli prázdné místo ve formátu XML mapuje na prázdné místo v JSON.</span><span class="sxs-lookup"><span data-stu-id="d91ea-199">Any white space in XML maps to white space in JSON.</span></span><br /><br /> <span data-ttu-id="d91ea-200">Příklad: Následující element XML se mapuje na fragment JSON.</span><span class="sxs-lookup"><span data-stu-id="d91ea-200">Example: The following XML element maps to a JSON fragment.</span></span><br /><br /> `<root type="string">  A BC      </root>`<br /><br /> <span data-ttu-id="d91ea-201">Fragment JSON je " Bc ".</span><span class="sxs-lookup"><span data-stu-id="d91ea-201">The JSON fragment is " A BC ".</span></span>|
|`number`|<span data-ttu-id="d91ea-202">1 nebo více CII</span><span class="sxs-lookup"><span data-stu-id="d91ea-202">1 or more CIIs</span></span>|<span data-ttu-id="d91ea-203">JSON `number` (JSON RFC, sekce 2.4), případně obklopený mezerami.</span><span class="sxs-lookup"><span data-stu-id="d91ea-203">A JSON `number` (JSON RFC, section 2.4), possibly surrounded by white space.</span></span> <span data-ttu-id="d91ea-204">Každý znak v kombinaci number/white space je znak, který odpovídá [kód znaku] z CII.</span><span class="sxs-lookup"><span data-stu-id="d91ea-204">Each character in the number/white space combination is a character that corresponds to the [character code] from the CII.</span></span><br /><br /> <span data-ttu-id="d91ea-205">Příklad: Následující prvek se mapuje na fragment JSON.</span><span class="sxs-lookup"><span data-stu-id="d91ea-205">Example: The following element maps to a JSON fragment.</span></span><br /><br /> `<root type="number">    42</root>`<br /><br /> <span data-ttu-id="d91ea-206">Fragment JSON je 42</span><span class="sxs-lookup"><span data-stu-id="d91ea-206">The JSON fragment is    42</span></span><br /><br /> <span data-ttu-id="d91ea-207">(Prázdné místo je zachováno).</span><span class="sxs-lookup"><span data-stu-id="d91ea-207">(White space is preserved).</span></span>|
|`boolean`|<span data-ttu-id="d91ea-208">4 nebo 5 CII (což odpovídá `true` nebo `false`), případně obklopeno dalšími nebílými CII.</span><span class="sxs-lookup"><span data-stu-id="d91ea-208">4 or 5 CIIs (which corresponds to `true` or `false`), possibly surrounded by additional white-space CIIs.</span></span>|<span data-ttu-id="d91ea-209">Sekvence CII, která odpovídá řetězci "true", je `true`mapována na literál a sekvence CII, která odpovídá `false`řetězci "false", je mapována na literál .</span><span class="sxs-lookup"><span data-stu-id="d91ea-209">A CII sequence that corresponds to the string "true" is mapped to the literal `true`, and a CII sequence that corresponds to the string "false" is mapped to the literal `false`.</span></span> <span data-ttu-id="d91ea-210">Okolní prázdné místo je zachováno.</span><span class="sxs-lookup"><span data-stu-id="d91ea-210">Surrounding white space is preserved.</span></span><br /><br /> <span data-ttu-id="d91ea-211">Příklad: Následující prvek se mapuje na fragment JSON.</span><span class="sxs-lookup"><span data-stu-id="d91ea-211">Example: The following element maps to a JSON fragment.</span></span><br /><br /> `<root type="boolean"> false</root>`<br /><br /> <span data-ttu-id="d91ea-212">Fragment JSON `false`je .</span><span class="sxs-lookup"><span data-stu-id="d91ea-212">The JSON fragment is `false`.</span></span>|
|`null`|<span data-ttu-id="d91ea-213">Nic není povoleno.</span><span class="sxs-lookup"><span data-stu-id="d91ea-213">None allowed.</span></span>|<span data-ttu-id="d91ea-214">Literál `null`.</span><span class="sxs-lookup"><span data-stu-id="d91ea-214">The literal `null`.</span></span> <span data-ttu-id="d91ea-215">Na JSON na XML `null` mapování, může být obklopen prázdné místo ('ws' v části 2), který není získat mapovány na XML.</span><span class="sxs-lookup"><span data-stu-id="d91ea-215">On JSON to XML mapping, the `null` may be surrounded by white space (‘ws’ in section 2) that does not get mapped to XML.</span></span><br /><br /> <span data-ttu-id="d91ea-216">Příklad: Následující prvek se mapuje na fragment JSON.</span><span class="sxs-lookup"><span data-stu-id="d91ea-216">Example: The following element maps to a JSON fragment.</span></span><br /><br /> `<root type="null"/>`<br /><br /> <span data-ttu-id="d91ea-217">– nebo –</span><span class="sxs-lookup"><span data-stu-id="d91ea-217">or</span></span><br /><br /> `<root type="null"></root>`<br /><br /> <span data-ttu-id="d91ea-218">:</span><span class="sxs-lookup"><span data-stu-id="d91ea-218">:</span></span><br /><br /> <span data-ttu-id="d91ea-219">Fragment JSON v obou `Null`případech je .</span><span class="sxs-lookup"><span data-stu-id="d91ea-219">The JSON fragment in both cases is `Null`.</span></span>|
|`object`|<span data-ttu-id="d91ea-220">0 nebo více EII.</span><span class="sxs-lookup"><span data-stu-id="d91ea-220">0 or more EIIs.</span></span>|<span data-ttu-id="d91ea-221">A `begin-object` (levá složená závorka) podle bodu 2.2 JSON RFC, následovaná záznamem člena pro každou EII, jak je popsáno dále.</span><span class="sxs-lookup"><span data-stu-id="d91ea-221">A `begin-object` (left curly brace) as in section 2.2 of the JSON RFC, followed by a member record for each EII as described further.</span></span> <span data-ttu-id="d91ea-222">Pokud existuje více než jeden EII, existují oddělovače hodnot (čárky) mezi záznamy členů.</span><span class="sxs-lookup"><span data-stu-id="d91ea-222">If there is more than one EII, there are value-separators (commas) between the member records.</span></span> <span data-ttu-id="d91ea-223">To vše následuje koncový objekt (pravá složená závorka).</span><span class="sxs-lookup"><span data-stu-id="d91ea-223">All this is followed by an end-object (right curly brace).</span></span><br /><br /> <span data-ttu-id="d91ea-224">Příklad: Následující prvek se mapuje na fragment JSON.</span><span class="sxs-lookup"><span data-stu-id="d91ea-224">Example: The following element maps to the JSON fragment.</span></span><br /><br /> `<root type="object">`<br /><br /> `<type1 type="string">aaa\</type1>`<br /><br /> `<type2 type="string">bbb\</type2>`<br /><br /> `</root >`<br /><br /> <span data-ttu-id="d91ea-225">Fragment JSON `{"type1":"aaa","type2":"bbb"}`je .</span><span class="sxs-lookup"><span data-stu-id="d91ea-225">The JSON fragment is `{"type1":"aaa","type2":"bbb"}`.</span></span><br /><br /> <span data-ttu-id="d91ea-226">Pokud je atribut typu datové smlouvy k dispozici v mapování XML na JSON, je na začátek vložen další záznam člena.</span><span class="sxs-lookup"><span data-stu-id="d91ea-226">If the Data Contract Type Attribute is present on XML to JSON mapping, then an additional Member Record is inserted at the beginning.</span></span> <span data-ttu-id="d91ea-227">Jeho název je [místní název] atributu typ\_\_datové smlouvy ("typ"), a jeho hodnota je atribut [normalizované hodnoty].</span><span class="sxs-lookup"><span data-stu-id="d91ea-227">Its name is the [local name] of the Data Contract Type Attribute ("\_\_type"), and its value is the attribute's [normalized value].</span></span> <span data-ttu-id="d91ea-228">Naopak na JSON na XML mapování, pokud název prvního členského záznamu je [místní název] atributu\_\_typu datové smlouvy (to znamená " typ"), odpovídající atribut typu datové smlouvy je k dispozici v mapovaném XML, ale odpovídající EII není k dispozici.</span><span class="sxs-lookup"><span data-stu-id="d91ea-228">Conversely, on JSON to XML mapping, if the first member-record’s name is the [local name] of the Data Contract Type Attribute (that is, "\_\_type"), a corresponding Data Contract Type Attribute is present in the mapped XML, but a corresponding EII is not present.</span></span> <span data-ttu-id="d91ea-229">Všimněte si, že tento záznam člena musí dojít nejprve v objektu JSON pro toto speciální mapování použít.</span><span class="sxs-lookup"><span data-stu-id="d91ea-229">Note that this member record must occur first in the JSON object for this special mapping to apply.</span></span> <span data-ttu-id="d91ea-230">To představuje odklon od obvyklého zpracování JSON, kde pořadí záznamů členů není významné.</span><span class="sxs-lookup"><span data-stu-id="d91ea-230">This represents a departure from usual JSON processing, where the order of member records is not significant.</span></span><br /><br /> <span data-ttu-id="d91ea-231">Příklad:</span><span class="sxs-lookup"><span data-stu-id="d91ea-231">Example:</span></span><br /><br /> <span data-ttu-id="d91ea-232">Následující fragment JSON se mapuje na XML.</span><span class="sxs-lookup"><span data-stu-id="d91ea-232">The following JSON fragment maps to XML.</span></span><br /><br /> `{"__type":"Person","name":"John"}`<br /><br /> <span data-ttu-id="d91ea-233">Xml je následující kód.</span><span class="sxs-lookup"><span data-stu-id="d91ea-233">The XML is the following code.</span></span><br /><br /> `<root type="object" __type="Person">   <name type="string">John</name> </root>`<br /><br /> <span data-ttu-id="d91ea-234">Všimněte \_ \_si, že typ AII \_ \_je k dispozici, ale neexistuje žádný typ EII.</span><span class="sxs-lookup"><span data-stu-id="d91ea-234">Notice that the \_\_type AII is present, but there is no \_\_type EII.</span></span><br /><br /> <span data-ttu-id="d91ea-235">Však pokud pořadí v JSON je obrácený, jak je znázorněno v následujícím příkladu.</span><span class="sxs-lookup"><span data-stu-id="d91ea-235">However, if the order in the JSON is reversed as shown in the following example.</span></span><br /><br /> `{"name":"John","\_\_type":"Person"}`<br /><br /> <span data-ttu-id="d91ea-236">Zobrazí se odpovídající kód XML.</span><span class="sxs-lookup"><span data-stu-id="d91ea-236">The corresponding XML is shown.</span></span><br /><br /> `<root type="object">   <name type="string">John</name>   <__type type="string">Person</__type> </root>`<br /><br /> <span data-ttu-id="d91ea-237">To znamená, \_že _type přestává mít zvláštní význam a mapuje na EII jako obvykle, ne NaII.</span><span class="sxs-lookup"><span data-stu-id="d91ea-237">That is, \__type ceases to have special meaning and maps to an EII as usual, not AII.</span></span><br /><br /> <span data-ttu-id="d91ea-238">Pravidla pro aii [normalizovanou hodnotu] při mapování na hodnotu JSON jsou stejná jako pro řetězce JSON zadaná v řádku "řetězec" této tabulky.</span><span class="sxs-lookup"><span data-stu-id="d91ea-238">Escaping/unescaping rules for the AII’s [normalized value] when mapped to a JSON value are the same as for JSON strings, specified in the "string" row of this table.</span></span><br /><br /> <span data-ttu-id="d91ea-239">Příklad:</span><span class="sxs-lookup"><span data-stu-id="d91ea-239">Example:</span></span><br /><br /> `<root type="object" __type="\abc" />`<br /><br /> <span data-ttu-id="d91ea-240">na předchozí příklad lze mapovat na následující JSON.</span><span class="sxs-lookup"><span data-stu-id="d91ea-240">to the previous example can be mapped to the following JSON.</span></span><br /><br /> `{"__type":"\\abc"}`<br /><br /> <span data-ttu-id="d91ea-241">Při mapování XML na JSON nesmí být první [místní název]\_\_eII "type".</span><span class="sxs-lookup"><span data-stu-id="d91ea-241">On an XML to JSON mapping, the first EII’s [local name] must not be "\_\_type".</span></span><br /><br /> <span data-ttu-id="d91ea-242">Prázdné znaky`ws`( ) se nikdy nevygenerují při mapování XML na JSON pro objekty a jsou ignorovány v mapování JSON na XML.</span><span class="sxs-lookup"><span data-stu-id="d91ea-242">White space (`ws`) is never generated on XML to JSON mapping for objects and is ignored on JSON to XML mapping.</span></span><br /><br /> <span data-ttu-id="d91ea-243">Příklad: Následující fragment JSON se mapuje na element XML.</span><span class="sxs-lookup"><span data-stu-id="d91ea-243">Example: The following JSON fragment maps to an XML element.</span></span><br /><br /> `{ "ccc" : "aaa", "ddd" :"bbb"}`<br /><br /> <span data-ttu-id="d91ea-244">Element XML je zobrazen v následujícím kódu.</span><span class="sxs-lookup"><span data-stu-id="d91ea-244">The XML element is shown in the following code.</span></span><br /><br /> `<root type="object">    <ccc type="string">aaa</ccc>    <ddd type="string">bbb</bar> </root >`|
|<span data-ttu-id="d91ea-245">pole</span><span class="sxs-lookup"><span data-stu-id="d91ea-245">array</span></span>|<span data-ttu-id="d91ea-246">0 nebo více EII</span><span class="sxs-lookup"><span data-stu-id="d91ea-246">0 or more EIIs</span></span>|<span data-ttu-id="d91ea-247">Počáteční pole (levá hranatá závorka) podle bodu 2.3 JSON RFC, následovaná záznamem pole pro každou EII, jak je popsáno dále.</span><span class="sxs-lookup"><span data-stu-id="d91ea-247">A begin-array (left square bracket) as in section 2.3 of the JSON RFC, followed by an array record for each EII as described further.</span></span> <span data-ttu-id="d91ea-248">Pokud existuje více než jeden EII, existují oddělovače hodnot (čárky) mezi záznamy pole.</span><span class="sxs-lookup"><span data-stu-id="d91ea-248">If there is more than one EII, there are value-separators (commas) between the array records.</span></span> <span data-ttu-id="d91ea-249">To vše následuje koncové pole.</span><span class="sxs-lookup"><span data-stu-id="d91ea-249">All this is followed by an end-array.</span></span><br /><br /> <span data-ttu-id="d91ea-250">Příklad: Následující element XML se mapuje na fragment JSON.</span><span class="sxs-lookup"><span data-stu-id="d91ea-250">Example: The following XML element maps to a JSON fragment.</span></span><br /><br /> `<root type="array"/>    <item type="string">aaa</item>    <item type="string">bbb</item> </root >`<br /><br /> <span data-ttu-id="d91ea-251">Fragment JSON je`["aaa","bbb"]`</span><span class="sxs-lookup"><span data-stu-id="d91ea-251">The JSON fragment is `["aaa","bbb"]`</span></span><br /><br /> <span data-ttu-id="d91ea-252">Prázdné znaky`ws`( ) se nikdy nevygenerují při mapování XML na JSON pro pole a jsou ignorovány v mapování JSON na XML.</span><span class="sxs-lookup"><span data-stu-id="d91ea-252">White space (`ws`) is never generated on XML to JSON mapping for arrays and is ignored on JSON to XML mapping.</span></span><br /><br /> <span data-ttu-id="d91ea-253">Příklad: Fragment JSON.</span><span class="sxs-lookup"><span data-stu-id="d91ea-253">Example: A JSON fragment.</span></span><br /><br />`["aaa", "bbb"]`<br /><br /> <span data-ttu-id="d91ea-254">Element XML, na který se mapuje.</span><span class="sxs-lookup"><span data-stu-id="d91ea-254">The XML element that it maps to.</span></span><br /><br /> `<root type="array"/>    <item type="string">aaa</item>    <item type="string">bbb</item> </root >`|

<span data-ttu-id="d91ea-255">Záznamy členů fungují takto:</span><span class="sxs-lookup"><span data-stu-id="d91ea-255">Member Records work as follows:</span></span>

- <span data-ttu-id="d91ea-256">[místní název] vnitřního prvku `string` se mapuje na část, která je definována `member` v části 2.2 JSON RFC.</span><span class="sxs-lookup"><span data-stu-id="d91ea-256">Inner element’s [local name] maps to the `string` part of the `member` as defined in section 2.2 of the JSON RFC.</span></span>

<span data-ttu-id="d91ea-257">Příklad: Následující prvek se mapuje na fragment JSON.</span><span class="sxs-lookup"><span data-stu-id="d91ea-257">Example: The following element maps to a JSON fragment.</span></span>

```xml
<root type="object">
    <myLocalName type="string">aaa</myLocalName>
</root>
```

<span data-ttu-id="d91ea-258">Zobrazí se následující fragment JSON.</span><span class="sxs-lookup"><span data-stu-id="d91ea-258">The following JSON fragment is displayed.</span></span>

```json
{"myLocalName":"aaa"}
```

- <span data-ttu-id="d91ea-259">V mapování XML na JSON jsou uvozeny znaky, které musí být uvozeny v JSON a ostatní nejsou uvozeny.</span><span class="sxs-lookup"><span data-stu-id="d91ea-259">On the XML to JSON mapping, the characters that must be escaped in JSON are escaped, and the others are not escaped.</span></span> <span data-ttu-id="d91ea-260">Znak "/", i když není znak, který musí být uvozen, je přesto uvozen (nemusí být uvozen na mapování Xml JSON).</span><span class="sxs-lookup"><span data-stu-id="d91ea-260">The "/" character, even though it is not a character that must be escaped, is escaped nevertheless (it does not have to be escaped on JSON to XML mapping).</span></span> <span data-ttu-id="d91ea-261">To je nutné pro podporu `DateTime` formátu ASP.NET AJAX pro data v JSON.</span><span class="sxs-lookup"><span data-stu-id="d91ea-261">This is required to support the ASP.NET AJAX format for `DateTime` data in JSON.</span></span>

- <span data-ttu-id="d91ea-262">Při mapování JSON na XML jsou všechny znaky (včetně neuvozených `string` znaků, pokud je to nutné) převzaty do tvaru a, který vytváří [místní název].</span><span class="sxs-lookup"><span data-stu-id="d91ea-262">On the JSON to XML mapping, all characters (including the not escaped characters, if necessary) are taken to form a `string` that produces a [local name].</span></span>

- <span data-ttu-id="d91ea-263">Vnitřní prvky [děti] mapovat na hodnotu v `JSON Type Attribute` bodě 2.2, podle stejně jako pro `Root JSON Element`.</span><span class="sxs-lookup"><span data-stu-id="d91ea-263">Inner elements [children] map to the value in section 2.2, according to the `JSON Type Attribute` just like for the `Root JSON Element`.</span></span> <span data-ttu-id="d91ea-264">Více úrovní vnoření EII (včetně vnoření v rámci polí) jsou povoleny.</span><span class="sxs-lookup"><span data-stu-id="d91ea-264">Multiple levels of nesting of EIIs (including nesting within arrays) are allowed.</span></span>

<span data-ttu-id="d91ea-265">Příklad: Následující prvek se mapuje na fragment JSON.</span><span class="sxs-lookup"><span data-stu-id="d91ea-265">Example: The following element maps to a JSON fragment.</span></span>

```xml
<root type="object">
    <myLocalName1 type="string">myValue1</myLocalName1>
    <myLocalName2 type="number">2</myLocalName2>
    <myLocalName3 type="object">
        <myNestedName1 type="boolean">true</myNestedName1>
        <myNestedName2 type="null"/>
    </myLocalName3>
</root >
```

<span data-ttu-id="d91ea-266">Následující fragment JSON je to, co mapuje.</span><span class="sxs-lookup"><span data-stu-id="d91ea-266">The following JSON fragment is what it maps to.</span></span>

```json
{"myLocalName1":"myValue1","myLocalName2":2,"myLocalName3":{"myNestedName1":true,"myNestedName2":null}}
```

> [!NOTE]
> <span data-ttu-id="d91ea-267">V předchozím mapování není žádný krok kódování XML.</span><span class="sxs-lookup"><span data-stu-id="d91ea-267">There is no XML encoding step in the preceding mapping.</span></span> <span data-ttu-id="d91ea-268">Proto WCF podporuje pouze dokumenty JSON, kde všechny znaky v názvech klíčů jsou platné znaky v názvech elementů XML.</span><span class="sxs-lookup"><span data-stu-id="d91ea-268">Therefore, WCF only supports JSON documents where all characters in key names are valid characters in XML element names.</span></span> <span data-ttu-id="d91ea-269">Například dokument JSON {"<":"a"} není podporován, protože < není platný název elementu XML.</span><span class="sxs-lookup"><span data-stu-id="d91ea-269">For example, the JSON document {"<":"a"} is not supported because < is not a valid name for an XML element.</span></span>

<span data-ttu-id="d91ea-270">Reverzní situace (znaky platné v JAZYCE XML, ale ne v JSON) nezpůsobí žádné problémy, protože předchozí mapování zahrnuje Kroky uvození/neunikání JSON.</span><span class="sxs-lookup"><span data-stu-id="d91ea-270">The reverse situation (characters valid in XML but not in JSON) does not cause any problems because the preceding mapping includes JSON escaping/unescaping steps.</span></span>

<span data-ttu-id="d91ea-271">Array Records fungují následovně:</span><span class="sxs-lookup"><span data-stu-id="d91ea-271">Array Records work as follows:</span></span>

- <span data-ttu-id="d91ea-272">Vnitřní prvek [místní název] je "položka".</span><span class="sxs-lookup"><span data-stu-id="d91ea-272">Inner element’s [local name] is "item".</span></span>

- <span data-ttu-id="d91ea-273">Vnitřní element je [podřízené] mapovat na hodnotu v části 2.3, podle Atribut typu JSON, jak je pro root JSON element.</span><span class="sxs-lookup"><span data-stu-id="d91ea-273">Inner element’s [children] map to the value in section 2.3, according to the JSON Type Attribute as is does for the Root JSON Element.</span></span> <span data-ttu-id="d91ea-274">Více úrovní vnoření EII (včetně vnoření v rámci objektů) jsou povoleny.</span><span class="sxs-lookup"><span data-stu-id="d91ea-274">Multiple levels of nesting of EIIs (including nesting within objects) are allowed.</span></span>

<span data-ttu-id="d91ea-275">Příklad: Následující prvek se mapuje na fragment JSON.</span><span class="sxs-lookup"><span data-stu-id="d91ea-275">Example: The following element maps to a JSON fragment.</span></span>

```xml
<root type="array">
    <item type="string">myValue1</item>
    <item type="number">2</item>
    <item type="array">
    <item type="boolean">true</item>
    <item type="null"/></item>
</root>
```

<span data-ttu-id="d91ea-276">Následuje fragment JSON.</span><span class="sxs-lookup"><span data-stu-id="d91ea-276">The following is the JSON fragment.</span></span>

```json
["myValue1",2,[true,null]]
```

## <a name="see-also"></a><span data-ttu-id="d91ea-277">Viz také</span><span class="sxs-lookup"><span data-stu-id="d91ea-277">See also</span></span>

- <xref:System.Runtime.Serialization.Json.JsonReaderWriterFactory>
- <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer>
- [<span data-ttu-id="d91ea-278">Samostatná serializace JSON</span><span class="sxs-lookup"><span data-stu-id="d91ea-278">Stand-Alone JSON Serialization</span></span>](stand-alone-json-serialization.md)
