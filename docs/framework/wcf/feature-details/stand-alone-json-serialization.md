---
title: Samostatná serializace JSON pomocí datacontractjsonserializer
ms.date: 03/30/2017
ms.assetid: 312bd7b2-1300-4b12-801e-ebe742bd2287
ms.openlocfilehash: 36945f2d42f22ef3aa4f27bcbe403466f124a279
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 03/12/2020
ms.locfileid: "79184413"
---
# <a name="stand-alone-json-serialization-using-datacontractjsonserializer"></a><span data-ttu-id="8b743-102">Samostatná serializace JSON pomocí datacontractjsonserializer</span><span class="sxs-lookup"><span data-stu-id="8b743-102">Stand-Alone JSON Serialization using DataContractJsonSerializer</span></span>

> [!NOTE]
> <span data-ttu-id="8b743-103">Tento článek <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer>je o .</span><span class="sxs-lookup"><span data-stu-id="8b743-103">This article is about <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer>.</span></span> <span data-ttu-id="8b743-104">Pro většinu scénářů, které zahrnují serializaci a rekonstrukci json, doporučujeme api v [oboru názvů System.Text.Json](../../../standard/serialization/system-text-json-overview.md).</span><span class="sxs-lookup"><span data-stu-id="8b743-104">For most scenarios that involve serializing and deserializing JSON, we recommend the APIs in the [System.Text.Json namespace](../../../standard/serialization/system-text-json-overview.md).</span></span>

<span data-ttu-id="8b743-105">JSON (JavaScript Object Notation) je formát dat, který je speciálně navržen pro použití kódem JavaScriptu běžícím na webových stránkách uvnitř prohlížeče.</span><span class="sxs-lookup"><span data-stu-id="8b743-105">JSON (JavaScript Object Notation) is a data format that is specifically designed to be used by JavaScript code running on Web pages inside the browser.</span></span> <span data-ttu-id="8b743-106">Jedná se o výchozí formát dat používaný službami ASP.NET AJAX vytvořenými v nadaci WCF (Windows Communication Foundation).</span><span class="sxs-lookup"><span data-stu-id="8b743-106">It is the default data format used by ASP.NET AJAX services created in Windows Communication Foundation (WCF).</span></span>

<span data-ttu-id="8b743-107">Tento formát lze také použít při vytváření služeb AJAX bez integrace s ASP.NET - v tomto případě je XML výchozí, ale JSON lze zvolit.</span><span class="sxs-lookup"><span data-stu-id="8b743-107">This format can also be used when creating AJAX services without integrating with ASP.NET - in this case, XML is the default but JSON can be chosen.</span></span>

<span data-ttu-id="8b743-108">Nakonec pokud požadujete podporu JSON, ale nevytváříte službu <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> AJAX, umožňuje přímo serializovat objekty .NET do dat JSON a rekonstruovat tato data zpět do instancí typů .NET.</span><span class="sxs-lookup"><span data-stu-id="8b743-108">Finally, if you require JSON support but are not creating an AJAX service, the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> makes it possible to directly serialize .NET objects into JSON data and to deserialize such data back into instances of .NET types.</span></span> <span data-ttu-id="8b743-109">Popis, jak to provést, naleznete v [tématu Jak: Serializovat a rekonstruovat json data](../../../../docs/framework/wcf/feature-details/how-to-serialize-and-deserialize-json-data.md).</span><span class="sxs-lookup"><span data-stu-id="8b743-109">For a description of how to do this, see [How to: Serialize and Deserialize JSON Data](../../../../docs/framework/wcf/feature-details/how-to-serialize-and-deserialize-json-data.md).</span></span>

<span data-ttu-id="8b743-110">Při práci s JSON jsou podporovány stejné typy .NET, s několika <xref:System.Runtime.Serialization.DataContractSerializer>výjimkami, jak jsou podporovány .</span><span class="sxs-lookup"><span data-stu-id="8b743-110">When working with JSON, the same .NET types are supported, with a few exceptions, as are supported by the <xref:System.Runtime.Serialization.DataContractSerializer>.</span></span> <span data-ttu-id="8b743-111">Seznam podporovaných typů naleznete v [tématu Typy podporované serializátorem datových smluv](../../../../docs/framework/wcf/feature-details/types-supported-by-the-data-contract-serializer.md).</span><span class="sxs-lookup"><span data-stu-id="8b743-111">For a list of the types supported, see [Types Supported by the Data Contract Serializer](../../../../docs/framework/wcf/feature-details/types-supported-by-the-data-contract-serializer.md).</span></span> <span data-ttu-id="8b743-112">To zahrnuje většinu primitivních typů, většinu typů polí a <xref:System.Runtime.Serialization.DataContractAttribute> kolekcí, stejně jako komplexní typy, které používají a <xref:System.Runtime.Serialization.DataMemberAttribute>.</span><span class="sxs-lookup"><span data-stu-id="8b743-112">This includes most primitive types, most array and collection types, as well as complex types that use the <xref:System.Runtime.Serialization.DataContractAttribute> and <xref:System.Runtime.Serialization.DataMemberAttribute>.</span></span>

## <a name="mapping-net-types-to-json-types"></a><span data-ttu-id="8b743-113">Mapování typů .NET na typy JSON</span><span class="sxs-lookup"><span data-stu-id="8b743-113">Mapping .NET types to JSON Types</span></span>

<span data-ttu-id="8b743-114">V následující tabulce je uvedena shoda mezi typy .NET a JSON/JavaScript, pokud jsou mapovány postupy serializace a deserializace.</span><span class="sxs-lookup"><span data-stu-id="8b743-114">The following table shows the correspondence between .NET types and JSON/JavaScript types when mapped by serialization and deserialization procedures.</span></span>

|<span data-ttu-id="8b743-115">Typy rozhraní .NET</span><span class="sxs-lookup"><span data-stu-id="8b743-115">.NET Types</span></span>|<span data-ttu-id="8b743-116">JSON/JavaScript</span><span class="sxs-lookup"><span data-stu-id="8b743-116">JSON/JavaScript</span></span>|<span data-ttu-id="8b743-117">Poznámky</span><span class="sxs-lookup"><span data-stu-id="8b743-117">Notes</span></span>|
|----------------|----------------------|-----------|
|<span data-ttu-id="8b743-118">Všechny číselné typy, například <xref:System.Int32>, <xref:System.Decimal> nebo<xref:System.Double></span><span class="sxs-lookup"><span data-stu-id="8b743-118">All numeric types, for example <xref:System.Int32>, <xref:System.Decimal> or <xref:System.Double></span></span>|<span data-ttu-id="8b743-119">Číslo</span><span class="sxs-lookup"><span data-stu-id="8b743-119">Number</span></span>|<span data-ttu-id="8b743-120">Zvláštní hodnoty, `Double.NaN` `Double.PositiveInfinity` například , a `Double.NegativeInfinity` nejsou podporovány a výsledkem je neplatný JSON.</span><span class="sxs-lookup"><span data-stu-id="8b743-120">Special values such as  `Double.NaN`, `Double.PositiveInfinity` and `Double.NegativeInfinity` are not supported and result in invalid JSON.</span></span>|
|<xref:System.Enum>|<span data-ttu-id="8b743-121">Číslo</span><span class="sxs-lookup"><span data-stu-id="8b743-121">Number</span></span>|<span data-ttu-id="8b743-122">Viz "Výčty a JSON" dále v tomto tématu.</span><span class="sxs-lookup"><span data-stu-id="8b743-122">See "Enumerations and JSON" later in this topic.</span></span>|
|<xref:System.Boolean>|<span data-ttu-id="8b743-123">Logická hodnota</span><span class="sxs-lookup"><span data-stu-id="8b743-123">Boolean</span></span>|--|
|<span data-ttu-id="8b743-124"><xref:System.String>, <xref:System.Char></span><span class="sxs-lookup"><span data-stu-id="8b743-124"><xref:System.String>, <xref:System.Char></span></span>|<span data-ttu-id="8b743-125">Řetězec</span><span class="sxs-lookup"><span data-stu-id="8b743-125">String</span></span>|--|
|<span data-ttu-id="8b743-126"><xref:System.TimeSpan>, <xref:System.Guid>, <xref:System.Uri></span><span class="sxs-lookup"><span data-stu-id="8b743-126"><xref:System.TimeSpan>, <xref:System.Guid>, <xref:System.Uri></span></span>|<span data-ttu-id="8b743-127">Řetězec</span><span class="sxs-lookup"><span data-stu-id="8b743-127">String</span></span>|<span data-ttu-id="8b743-128">Formát těchto typů v JSON je stejný jako v XML (v podstatě TimeSpan ve formátu ISO 8601 Duration, GUID v "12345678-ABCD-ABCD-ABCD-1234567890AB" formátu a URI ve své přirozené formě řetězce jako "http://www.example.com").</span><span class="sxs-lookup"><span data-stu-id="8b743-128">The format of these types in JSON is the same as in XML (essentially, TimeSpan in the ISO 8601 Duration format, GUID in the "12345678-ABCD-ABCD-ABCD-1234567890AB" format and URI in its natural string form like "http://www.example.com").</span></span> <span data-ttu-id="8b743-129">Přesné informace naleznete v [tématu Data Contract Schema Reference](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md).</span><span class="sxs-lookup"><span data-stu-id="8b743-129">For precise information, see [Data Contract Schema Reference](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md).</span></span>|
|<xref:System.Xml.XmlQualifiedName>|<span data-ttu-id="8b743-130">Řetězec</span><span class="sxs-lookup"><span data-stu-id="8b743-130">String</span></span>|<span data-ttu-id="8b743-131">Formát je "name:namespace" (cokoli před první dvojtečka je název).</span><span class="sxs-lookup"><span data-stu-id="8b743-131">The format is "name:namespace" (anything before the first colon is the name).</span></span> <span data-ttu-id="8b743-132">Název nebo obor názvů mohou chybět.</span><span class="sxs-lookup"><span data-stu-id="8b743-132">Either the name or the namespace can be missing.</span></span> <span data-ttu-id="8b743-133">Pokud neexistuje žádný obor názvů dvojtečka může být vynechána také.</span><span class="sxs-lookup"><span data-stu-id="8b743-133">If there is no namespace the colon can be omitted as well.</span></span>|
|<span data-ttu-id="8b743-134"><xref:System.Array>typu<xref:System.Byte></span><span class="sxs-lookup"><span data-stu-id="8b743-134"><xref:System.Array> of type <xref:System.Byte></span></span>|<span data-ttu-id="8b743-135">Pole čísel</span><span class="sxs-lookup"><span data-stu-id="8b743-135">Array of numbers</span></span>|<span data-ttu-id="8b743-136">Každé číslo představuje hodnotu jednoho bajtu.</span><span class="sxs-lookup"><span data-stu-id="8b743-136">Each number represents the value of one byte.</span></span>|
|<xref:System.DateTime>|<span data-ttu-id="8b743-137">DateTime nebo Řetězec</span><span class="sxs-lookup"><span data-stu-id="8b743-137">DateTime or String</span></span>|<span data-ttu-id="8b743-138">Viz Dates/Times a JSON dále v tomto tématu.</span><span class="sxs-lookup"><span data-stu-id="8b743-138">See Dates/Times and JSON later in this topic.</span></span>|
|<xref:System.DateTimeOffset>|<span data-ttu-id="8b743-139">Komplexní typ</span><span class="sxs-lookup"><span data-stu-id="8b743-139">Complex type</span></span>|<span data-ttu-id="8b743-140">Viz Dates/Times a JSON dále v tomto tématu.</span><span class="sxs-lookup"><span data-stu-id="8b743-140">See Dates/Times and JSON later in this topic.</span></span>|
|<span data-ttu-id="8b743-141">Typy XML a<xref:System.Xml.XmlElement>ADO.NET ( ,</span><span class="sxs-lookup"><span data-stu-id="8b743-141">XML and ADO.NET types (<xref:System.Xml.XmlElement>,</span></span><br /><br /> <span data-ttu-id="8b743-142"><xref:System.Xml.Linq.XElement>.</span><span class="sxs-lookup"><span data-stu-id="8b743-142"><xref:System.Xml.Linq.XElement>.</span></span> <span data-ttu-id="8b743-143">Pole , <xref:System.Xml.XmlNode></span><span class="sxs-lookup"><span data-stu-id="8b743-143">Arrays of <xref:System.Xml.XmlNode>,</span></span><br /><br /> <span data-ttu-id="8b743-144"><xref:System.Runtime.Serialization.ISerializable>,</span><span class="sxs-lookup"><span data-stu-id="8b743-144"><xref:System.Runtime.Serialization.ISerializable>,</span></span><br /><br /> <span data-ttu-id="8b743-145"><xref:System.Data.DataSet>).</span><span class="sxs-lookup"><span data-stu-id="8b743-145"><xref:System.Data.DataSet>).</span></span>|<span data-ttu-id="8b743-146">Řetězec</span><span class="sxs-lookup"><span data-stu-id="8b743-146">String</span></span>|<span data-ttu-id="8b743-147">Podívejte se na část Typy XML a JSON v tomto tématu.</span><span class="sxs-lookup"><span data-stu-id="8b743-147">See the XML Types and JSON section of this topic.</span></span>|
|<xref:System.DBNull>|<span data-ttu-id="8b743-148">Prázdný komplexní typ</span><span class="sxs-lookup"><span data-stu-id="8b743-148">Empty complex type</span></span>|--|
|<span data-ttu-id="8b743-149">Kolekce, slovníky a pole</span><span class="sxs-lookup"><span data-stu-id="8b743-149">Collections, dictionaries, and arrays</span></span>|<span data-ttu-id="8b743-150">Pole</span><span class="sxs-lookup"><span data-stu-id="8b743-150">Array</span></span>|<span data-ttu-id="8b743-151">V tomto tématu najdete v části Kolekce, Slovníky a Pole.</span><span class="sxs-lookup"><span data-stu-id="8b743-151">See the Collections, Dictionaries, and Arrays section of this topic.</span></span>|
|<span data-ttu-id="8b743-152">Komplexní typy (s použitým <xref:System.Runtime.Serialization.DataContractAttribute> nebo <xref:System.SerializableAttribute> aplikovaným)</span><span class="sxs-lookup"><span data-stu-id="8b743-152">Complex types (with the <xref:System.Runtime.Serialization.DataContractAttribute> or <xref:System.SerializableAttribute> applied)</span></span>|<span data-ttu-id="8b743-153">Komplexní typ</span><span class="sxs-lookup"><span data-stu-id="8b743-153">Complex type</span></span>|<span data-ttu-id="8b743-154">Datové členy se stanou členy komplexního typu JavaScript.</span><span class="sxs-lookup"><span data-stu-id="8b743-154">Data members become members of the JavaScript complex type.</span></span>|
|<span data-ttu-id="8b743-155">Komplexní typy implementace <xref:System.Runtime.Serialization.ISerializable> rozhraní)</span><span class="sxs-lookup"><span data-stu-id="8b743-155">Complex types implementing the <xref:System.Runtime.Serialization.ISerializable> interface)</span></span>|<span data-ttu-id="8b743-156">Komplexní typ</span><span class="sxs-lookup"><span data-stu-id="8b743-156">Complex type</span></span>|<span data-ttu-id="8b743-157">Stejné jako u jiných <xref:System.Runtime.Serialization.ISerializable> typů komplex, ale některé typy nejsou podporovány – viz iSerializable Support část rozšířené informace části tohoto tématu.</span><span class="sxs-lookup"><span data-stu-id="8b743-157">Same as other complex types but some <xref:System.Runtime.Serialization.ISerializable> types are not supported – see the ISerializable Support part of the Advanced Information section of this topic.</span></span>|
|<span data-ttu-id="8b743-158">`Null`hodnota pro libovolný typ</span><span class="sxs-lookup"><span data-stu-id="8b743-158">`Null` value for any type</span></span>|<span data-ttu-id="8b743-159">Null</span><span class="sxs-lookup"><span data-stu-id="8b743-159">Null</span></span>|<span data-ttu-id="8b743-160">Nullable typy jsou také podporovány a mapování JSON stejným způsobem jako typy s nulou.</span><span class="sxs-lookup"><span data-stu-id="8b743-160">Nullable types are also supported and map to JSON in the same way as non-nullable types.</span></span>|

### <a name="enumerations-and-json"></a><span data-ttu-id="8b743-161">Výčty a JSON</span><span class="sxs-lookup"><span data-stu-id="8b743-161">Enumerations and JSON</span></span>

<span data-ttu-id="8b743-162">Hodnoty členů výčtu jsou považovány za čísla v JSON, což se liší od způsobu, jakým jsou zpracovány ve smlouvách dat, kde jsou zahrnuty jako názvy členů.</span><span class="sxs-lookup"><span data-stu-id="8b743-162">Enumeration member values are treated as numbers in JSON, which is different from how they are treated in data contracts, where they are included as member names.</span></span> <span data-ttu-id="8b743-163">Další informace o zpracování smlouvy o datech naleznete v [tématu Typy výčtu v datových kontraktech](../../../../docs/framework/wcf/feature-details/enumeration-types-in-data-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="8b743-163">For more information about the data contract treatment, see [Enumeration Types in Data Contracts](../../../../docs/framework/wcf/feature-details/enumeration-types-in-data-contracts.md).</span></span>

- <span data-ttu-id="8b743-164">Například pokud máte `public enum Color {red, green, blue, yellow, pink}`, `yellow` serializace vytvoří číslo 3 a ne řetězec "žlutá".</span><span class="sxs-lookup"><span data-stu-id="8b743-164">For example, if you have `public enum Color {red, green, blue, yellow, pink}`, serializing `yellow` produces the number 3 and not the string "yellow".</span></span>

- <span data-ttu-id="8b743-165">Všechny `enum` členy jsou serializovatelné.</span><span class="sxs-lookup"><span data-stu-id="8b743-165">All `enum` members are serializable.</span></span> <span data-ttu-id="8b743-166">Atributy <xref:System.Runtime.Serialization.EnumMemberAttribute> <xref:System.NonSerializedAttribute> a jsou ignorovány, pokud jsou použity.</span><span class="sxs-lookup"><span data-stu-id="8b743-166">The <xref:System.Runtime.Serialization.EnumMemberAttribute> and the <xref:System.NonSerializedAttribute> attributes are ignored if used.</span></span>

- <span data-ttu-id="8b743-167">Je možné rekonstruovat neexistující `enum` hodnotu - například hodnotu 87 lze rekonstruovat do předchozího výčtu Color, i když není definován žádný odpovídající název barvy.</span><span class="sxs-lookup"><span data-stu-id="8b743-167">It is possible to deserialize a nonexistent `enum` value - for example, the value 87 can be deserialized into the previous Color enum even though there is no corresponding color name defined.</span></span>

- <span data-ttu-id="8b743-168">Příznaky `enum` nejsou zvláštní a je zacházeno stejně jako všechny ostatní `enum`.</span><span class="sxs-lookup"><span data-stu-id="8b743-168">A flags `enum` is not special and is treated the same as any other `enum`.</span></span>

### <a name="datestimes-and-json"></a><span data-ttu-id="8b743-169">Termíny/časy a JSON</span><span class="sxs-lookup"><span data-stu-id="8b743-169">Dates/Times and JSON</span></span>

<span data-ttu-id="8b743-170">Formát JSON přímo nepodporuje data a časy.</span><span class="sxs-lookup"><span data-stu-id="8b743-170">The JSON format does not directly support dates and times.</span></span> <span data-ttu-id="8b743-171">Nicméně, oni jsou velmi běžně používané a ASP.NET AJAX poskytuje speciální podporu pro tyto typy.</span><span class="sxs-lookup"><span data-stu-id="8b743-171">However, they are very commonly used and ASP.NET AJAX provides special support for these types.</span></span> <span data-ttu-id="8b743-172">Při použití ASP.NET proxy kódů AJAX <xref:System.DateTime> typ v rozhraní `DateTime` .NET plně odpovídá typu v jazyce JavaScript.</span><span class="sxs-lookup"><span data-stu-id="8b743-172">When using ASP.NET AJAX proxies, the <xref:System.DateTime> type in .NET fully corresponds to the `DateTime` type in JavaScript.</span></span>

- <span data-ttu-id="8b743-173">Pokud nepoužíváte ASP.NET, <xref:System.DateTime> je typ v JSON reprezentován jako řetězec se speciálním formátem, který je popsán v části Rozšířené informace tohoto tématu.</span><span class="sxs-lookup"><span data-stu-id="8b743-173">When not using ASP.NET, a <xref:System.DateTime> type is represented in JSON as a string with a special format that is described in the Advanced Information section of this topic.</span></span>

- <span data-ttu-id="8b743-174"><xref:System.DateTimeOffset>je reprezentován v JSON jako komplexní typ: {"DateTime":dateTime,"OffsetMinutes":offsetMinutes}.</span><span class="sxs-lookup"><span data-stu-id="8b743-174"><xref:System.DateTimeOffset> is represented in JSON as a complex type: {"DateTime":dateTime,"OffsetMinutes":offsetMinutes}.</span></span> <span data-ttu-id="8b743-175">Člen `offsetMinutes` je posun místního času od greenwichského středního času (GMT), který je nyní také označován jako koordinovaný světový čas (UTC), přidružený k umístění události zájmu.</span><span class="sxs-lookup"><span data-stu-id="8b743-175">The `offsetMinutes` member is the local time offset from Greenwich Mean Time (GMT), also now referred to as Coordinated Universal Time (UTC), associated with the location of the event of interest.</span></span> <span data-ttu-id="8b743-176">Člen `dateTime` představuje instanci v době, kdy došlo k `DateTime` události zájmu (opět se stane v Jazyce JavaScript, když ASP.NET AJAX je používán a řetězec, když není).</span><span class="sxs-lookup"><span data-stu-id="8b743-176">The `dateTime` member represents the instance in time when the event of interest occurred (again, it becomes a `DateTime` in JavaScript when ASP.NET AJAX is in use and a string when it is not).</span></span> <span data-ttu-id="8b743-177">Při serializaci `dateTime` je člen vždy serializován v GMT.</span><span class="sxs-lookup"><span data-stu-id="8b743-177">On serialization, the `dateTime` member is always serialized in GMT.</span></span> <span data-ttu-id="8b743-178">Takže, pokud popisuje 3:00 AM `dateTime` New York čas, má časovou `offsetMinutes` složku 8:00 AM a jsou 300 (minus 300 minut nebo 5 hodin od GMT).</span><span class="sxs-lookup"><span data-stu-id="8b743-178">So, if describing 3:00 AM New York time, `dateTime` has a time component of 8:00 AM and `offsetMinutes` are 300 (minus 300 minutes or 5 hours from GMT).</span></span>

  > [!NOTE]
  > <span data-ttu-id="8b743-179"><xref:System.DateTime>a <xref:System.DateTimeOffset> objekty, při serializování do JSON, pouze zachovat informace o přesnostmi milisekund.</span><span class="sxs-lookup"><span data-stu-id="8b743-179"><xref:System.DateTime> and <xref:System.DateTimeOffset> objects, when serialized to JSON, only preserve information to millisecond precision.</span></span> <span data-ttu-id="8b743-180">Hodnoty podmisekund (mikro/nanosekundy) jsou během serializace ztraceny.</span><span class="sxs-lookup"><span data-stu-id="8b743-180">Sub-millisecond values (micro/nanoseconds) are lost during serialization.</span></span>

### <a name="xml-types-and-json"></a><span data-ttu-id="8b743-181">Typy XML a JSON</span><span class="sxs-lookup"><span data-stu-id="8b743-181">XML Types and JSON</span></span>

<span data-ttu-id="8b743-182">Typy XML se stanou řetězci JSON.</span><span class="sxs-lookup"><span data-stu-id="8b743-182">XML types become JSON strings.</span></span>

- <span data-ttu-id="8b743-183">Například pokud datový člen "q" typu \<XElement obsahuje abc/>, JSON\<je {"q":" abc/>"}.</span><span class="sxs-lookup"><span data-stu-id="8b743-183">For example, if a data member "q" of type XElement contains \<abc/>, the JSON is {"q":"\<abc/>"}.</span></span>

- <span data-ttu-id="8b743-184">Existují některá zvláštní pravidla, která určují, jak je kód XML zabalen – další informace naleznete v části Upřesnit informace dále v tomto tématu.</span><span class="sxs-lookup"><span data-stu-id="8b743-184">There are some special rules that specify how XML is wrapped - for more information, see the Advanced Information section later in this topic.</span></span>

- <span data-ttu-id="8b743-185">Pokud používáte ASP.NET AJAX a nechcete používat řetězce v jazyce JavaScript, ale <xref:System.ServiceModel.Web.WebGetAttribute.ResponseFormat%2A> chcete místo <xref:System.ServiceModel.Web.WebGetAttribute> toho <xref:System.ServiceModel.Web.WebInvokeAttribute.ResponseFormat%2A> xml dom, <xref:System.ServiceModel.Web.WebInvokeAttribute>nastavte vlastnost xml na nebo vlastnost XML na .</span><span class="sxs-lookup"><span data-stu-id="8b743-185">If you are using ASP.NET AJAX and do not want to use strings in the JavaScript, but want the XML DOM instead, set the <xref:System.ServiceModel.Web.WebGetAttribute.ResponseFormat%2A> property to XML on <xref:System.ServiceModel.Web.WebGetAttribute> or the <xref:System.ServiceModel.Web.WebInvokeAttribute.ResponseFormat%2A> property to XML on the <xref:System.ServiceModel.Web.WebInvokeAttribute>.</span></span>

### <a name="collections-dictionaries-and-arrays"></a><span data-ttu-id="8b743-186">Kolekce, slovníky a pole</span><span class="sxs-lookup"><span data-stu-id="8b743-186">Collections, Dictionaries and Arrays</span></span>

<span data-ttu-id="8b743-187">Všechny kolekce, slovníky a pole jsou reprezentovány v JSON jako pole.</span><span class="sxs-lookup"><span data-stu-id="8b743-187">All collections, dictionaries, and arrays are represented in JSON as arrays.</span></span>

- <span data-ttu-id="8b743-188">Jakékoli vlastní nastavení, které používá <xref:System.Runtime.Serialization.CollectionDataContractAttribute> je ignorována v reprezentaci JSON.</span><span class="sxs-lookup"><span data-stu-id="8b743-188">Any customization that uses the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> is ignored in the JSON representation.</span></span>

- <span data-ttu-id="8b743-189">Slovníky nejsou způsob, jak pracovat přímo s JSON.</span><span class="sxs-lookup"><span data-stu-id="8b743-189">Dictionaries are not a way to work directly with JSON.</span></span> <span data-ttu-id="8b743-190">Slovník\<řetězec, objekt> nemusí být podporovány stejným způsobem wcf podle očekávání z práce s jinými technologiemi JSON.</span><span class="sxs-lookup"><span data-stu-id="8b743-190">Dictionary\<string,object> may not be supported in the same way in WCF as expected from working with other JSON technologies.</span></span> <span data-ttu-id="8b743-191">Například pokud "abc" je mapována na "xyz" a "def" je mapována na 42 ve slovníku, reprezentace JSON není {"abc":"xyz","def":42} ale je [{"Key":"abc","Value":"xyz"},{"Key":"def","Value":42}] místo.</span><span class="sxs-lookup"><span data-stu-id="8b743-191">For example, if "abc" is mapped to "xyz" and "def" is mapped to 42 in a dictionary, the JSON representation is not {"abc":"xyz","def":42} but is [{"Key":"abc","Value":"xyz"},{"Key":"def","Value":42}] instead.</span></span>

- <span data-ttu-id="8b743-192">Pokud byste chtěli pracovat se společností JSON přímo (dynamicky přistupovat ke klíčům a hodnotám, aniž byste předem definovali pevnou smlouvu), máte několik možností:</span><span class="sxs-lookup"><span data-stu-id="8b743-192">If you would like to work with JSON directly (accessing keys and values dynamically, without pre-defining a rigid contract), you have several options:</span></span>

  - <span data-ttu-id="8b743-193">Zvažte použití [slabě typované ho json serializace (AJAX)](../../../../docs/framework/wcf/samples/weakly-typed-json-serialization-sample.md) ukázka.</span><span class="sxs-lookup"><span data-stu-id="8b743-193">Consider using the [Weakly-typed JSON Serialization (AJAX)](../../../../docs/framework/wcf/samples/weakly-typed-json-serialization-sample.md) sample.</span></span>

  - <span data-ttu-id="8b743-194">Zvažte <xref:System.Runtime.Serialization.ISerializable> použití konstruktorů rozhraní a deserializace – tyto dva mechanismy umožňují přístup k párům klíčů a hodnot JSON při serializaci a deserializaci, ale nefungují v případě částečnédůvěryhodnosti.</span><span class="sxs-lookup"><span data-stu-id="8b743-194">Consider using the <xref:System.Runtime.Serialization.ISerializable> interface and deserialization constructors - these two mechanisms allow you to access JSON key/value pairs on serialization and deserialization respectively, but do not work in partial trust scenarios.</span></span>

  - <span data-ttu-id="8b743-195">Zvažte práci s [mapování mezi JSON a XML](../../../../docs/framework/wcf/feature-details/mapping-between-json-and-xml.md) namísto použití serializátoru.</span><span class="sxs-lookup"><span data-stu-id="8b743-195">Consider working with the [Mapping Between JSON and XML](../../../../docs/framework/wcf/feature-details/mapping-between-json-and-xml.md) instead of using a serializer.</span></span>

  - <span data-ttu-id="8b743-196">*Polymorfismus* v kontextu serializace odkazuje na schopnost serializovat odvozený typ, kde se očekává jeho základní typ.</span><span class="sxs-lookup"><span data-stu-id="8b743-196">*Polymorphism* in the context of serialization refers to the ability to serialize a derived type where its base type is expected.</span></span> <span data-ttu-id="8b743-197">Existují speciální pravidla specifická pro JSON při použití kolekcí polymorfně, když <xref:System.Object>například přiřazení kolekce .</span><span class="sxs-lookup"><span data-stu-id="8b743-197">There are special JSON-specific rules when using collections polymorphically, when, for example, assigning a collection to an <xref:System.Object>.</span></span> <span data-ttu-id="8b743-198">Tento problém je podrobněji popsán v části Rozšířené informace dále v tomto tématu.</span><span class="sxs-lookup"><span data-stu-id="8b743-198">This issue is more fully discussed in the Advanced Information section later in this topic.</span></span>

## <a name="additional-details"></a><span data-ttu-id="8b743-199">Další podrobnosti</span><span class="sxs-lookup"><span data-stu-id="8b743-199">Additional Details</span></span>

### <a name="order-of-data-members"></a><span data-ttu-id="8b743-200">Pořadí datových členů</span><span class="sxs-lookup"><span data-stu-id="8b743-200">Order of Data Members</span></span>

<span data-ttu-id="8b743-201">Pořadí datových členů není důležité při použití JSON.</span><span class="sxs-lookup"><span data-stu-id="8b743-201">Order of data members is not important when using JSON.</span></span> <span data-ttu-id="8b743-202">Konkrétně i <xref:System.Runtime.Serialization.DataMemberAttribute.Order%2A> v případě, že je nastavena, JSON data lze stále rekonstruovat v libovolném pořadí.</span><span class="sxs-lookup"><span data-stu-id="8b743-202">Specifically, even if <xref:System.Runtime.Serialization.DataMemberAttribute.Order%2A> is set, JSON data can still be deserialized in any order.</span></span>

### <a name="json-types"></a><span data-ttu-id="8b743-203">Typy JSON</span><span class="sxs-lookup"><span data-stu-id="8b743-203">JSON Types</span></span>

<span data-ttu-id="8b743-204">Typ JSON nemusí odpovídat předchozí tabulce při rekonstrukci.</span><span class="sxs-lookup"><span data-stu-id="8b743-204">The JSON type does not have to match the preceding table on deserialization.</span></span> <span data-ttu-id="8b743-205">Například `Int` obvykle mapuje na číslo JSON, ale může být také úspěšně rekonstruovat z řetězce JSON tak dlouho, dokud tento řetězec obsahuje platné číslo.</span><span class="sxs-lookup"><span data-stu-id="8b743-205">For example, an `Int` normally maps to a JSON number, but it can also be successfully deserialized from a JSON string as long as that string contains a valid number.</span></span> <span data-ttu-id="8b743-206">To znamená, že oba {"q":42} a {"q":"42"} jsou platné, pokud existuje `Int` datový člen s názvem "q".</span><span class="sxs-lookup"><span data-stu-id="8b743-206">That is, both {"q":42} and {"q":"42"} are valid if there is an `Int` data member called "q".</span></span>

### <a name="polymorphism"></a><span data-ttu-id="8b743-207">Polymorfismus</span><span class="sxs-lookup"><span data-stu-id="8b743-207">Polymorphism</span></span>

<span data-ttu-id="8b743-208">Polymorfní serializace se skládá ze schopnosti serializovat odvozený typ, kde se očekává jeho základní typ.</span><span class="sxs-lookup"><span data-stu-id="8b743-208">Polymorphic serialization consists of the ability to serialize a derived type where its base type is expected.</span></span> <span data-ttu-id="8b743-209">To je podporováno pro serializaci JSON wcf srovnatelné se způsobem, jakým je podporována serializace XML.</span><span class="sxs-lookup"><span data-stu-id="8b743-209">This is supported for JSON serialization by WCF comparable to the way XML serialization is supported.</span></span> <span data-ttu-id="8b743-210">Můžete například serializovat, `MyDerivedType` `MyBaseType` kde se očekává, `Int` nebo `Object` serializovat, kde se očekává.</span><span class="sxs-lookup"><span data-stu-id="8b743-210">For example, you can serialize `MyDerivedType` where `MyBaseType` is expected, or serialize `Int` where `Object` is expected.</span></span>

<span data-ttu-id="8b743-211">Informace o typu mohou být ztraceny při rekonstrukci odvozeného typu, pokud je očekáván základní typ, pokud nerekonstruujete komplexní typ.</span><span class="sxs-lookup"><span data-stu-id="8b743-211">Type information may be lost when deserializing a derived type if the base type is expected, unless you are deserializing a complex type.</span></span> <span data-ttu-id="8b743-212">Například pokud <xref:System.Uri> je serializován, kde <xref:System.Object> se očekává, výsledkem je řetězec JSON.</span><span class="sxs-lookup"><span data-stu-id="8b743-212">For example, if <xref:System.Uri> is serialized where <xref:System.Object> is expected, it results in a JSON string.</span></span> <span data-ttu-id="8b743-213">Pokud je tento řetězec pak <xref:System.Object>reserializován <xref:System.String> zpět do , je vrácena .NET.</span><span class="sxs-lookup"><span data-stu-id="8b743-213">If this string is then deserialized back into <xref:System.Object>, a .NET <xref:System.String> is returned.</span></span> <span data-ttu-id="8b743-214">Deserializer neví, že řetězec byl původně typu <xref:System.Uri>.</span><span class="sxs-lookup"><span data-stu-id="8b743-214">The deserializer does not know that the string was initially of type <xref:System.Uri>.</span></span> <span data-ttu-id="8b743-215">Obecně platí, <xref:System.Object>že při očekávání jsou všechny řetězce JSON deserializovány jako řetězce .NET a všechna pole JSON používaná k serializaci <xref:System.Array> kolekcí.NET, slovníků a polí jsou deserializována jako typ <xref:System.Object>.NET bez ohledu na to, jaký byl skutečný původní typ.</span><span class="sxs-lookup"><span data-stu-id="8b743-215">Generally, when expecting <xref:System.Object>, all JSON strings are deserialized as .NET strings, and all JSON arrays used to serialize .NET collections, dictionaries, and arrays are deserialized as .NET <xref:System.Array> of type <xref:System.Object>, regardless of what the actual original type had been.</span></span> <span data-ttu-id="8b743-216">Logická hodnota JSON se <xref:System.Boolean>mapuje na rozhraní .NET .</span><span class="sxs-lookup"><span data-stu-id="8b743-216">A JSON boolean maps to a .NET <xref:System.Boolean>.</span></span> <span data-ttu-id="8b743-217">Však při <xref:System.Object>očekávání , JSON čísla jsou <xref:System.Int32>reserializovány jako buď .NET , <xref:System.Decimal> nebo <xref:System.Double>, kde je automaticky vybral nejvhodnější typ.</span><span class="sxs-lookup"><span data-stu-id="8b743-217">However when expecting an <xref:System.Object>, JSON numbers are deserialized as either .NET <xref:System.Int32>, <xref:System.Decimal> or <xref:System.Double>, where the most appropriate type is automatically picked.</span></span>

<span data-ttu-id="8b743-218">Při dekontování do <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> typu rozhraní, deklarovat typ byl objekt.</span><span class="sxs-lookup"><span data-stu-id="8b743-218">When deserializing into an interface type, the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> deserializes as if the declared type were object.</span></span>

<span data-ttu-id="8b743-219">Při práci s vlastní základnu a <xref:System.Runtime.Serialization.KnownTypeAttribute>odvozené typy, pomocí , <xref:System.ServiceModel.ServiceKnownTypeAttribute> nebo ekvivalentní mechanismus je obvykle vyžadováno.</span><span class="sxs-lookup"><span data-stu-id="8b743-219">When working with your own base and derived types, using the <xref:System.Runtime.Serialization.KnownTypeAttribute>, <xref:System.ServiceModel.ServiceKnownTypeAttribute> or an equivalent mechanism is normally required.</span></span> <span data-ttu-id="8b743-220">Například pokud máte operaci, která `Animal` má vrácenou hodnotu `Cat` a ve `Animal`skutečnosti vrátí instanci (odvozené z ), měli byste buď použít <xref:System.Runtime.Serialization.KnownTypeAttribute>, na `Animal` typ nebo <xref:System.ServiceModel.ServiceKnownTypeAttribute> na operaci a určit `Cat` typ v těchto atributech.</span><span class="sxs-lookup"><span data-stu-id="8b743-220">For example, if you have an operation that has an `Animal` return value and it actually returns an instance of `Cat` (derived from `Animal`), you should either apply the <xref:System.Runtime.Serialization.KnownTypeAttribute>, to the `Animal` type or the <xref:System.ServiceModel.ServiceKnownTypeAttribute> to the operation and specify the `Cat` type in these attributes.</span></span> <span data-ttu-id="8b743-221">Další informace naleznete v [tématu Data Contract Known Types](../../../../docs/framework/wcf/feature-details/data-contract-known-types.md).</span><span class="sxs-lookup"><span data-stu-id="8b743-221">For more information, see [Data Contract Known Types](../../../../docs/framework/wcf/feature-details/data-contract-known-types.md).</span></span>

<span data-ttu-id="8b743-222">Podrobnosti o tom, jak polymorfní serializace funguje a diskuse o některých omezení, které musí být respektovány při jeho použití, naleznete v části Rozšířené informace dále v tomto tématu.</span><span class="sxs-lookup"><span data-stu-id="8b743-222">For details of how polymorphic serialization works and a discussion of some of the limitations that must be respected when using it, see the Advanced Information section later in this topic.</span></span>

### <a name="versioning"></a><span data-ttu-id="8b743-223">Správa verzí</span><span class="sxs-lookup"><span data-stu-id="8b743-223">Versioning</span></span>

<span data-ttu-id="8b743-224">Funkce správy verzí kontraktu <xref:System.Runtime.Serialization.IExtensibleDataObject> dat, včetně rozhraní, jsou plně podporovány v JSON.</span><span class="sxs-lookup"><span data-stu-id="8b743-224">The data contract versioning features, including the <xref:System.Runtime.Serialization.IExtensibleDataObject> interface, are fully supported in JSON.</span></span> <span data-ttu-id="8b743-225">Kromě toho je ve většině případů možné rekonstruovat typ v jednom formátu (například XML) a pak jej serializovat do jiného formátu <xref:System.Runtime.Serialization.IExtensibleDataObject>(například JSON) a stále zachovat data v .</span><span class="sxs-lookup"><span data-stu-id="8b743-225">Furthermore, in most cases it is possible to deserialize a type in one format (for example, XML) and then serialize it into another format (for example, JSON) and still preserve the data in <xref:System.Runtime.Serialization.IExtensibleDataObject>.</span></span> <span data-ttu-id="8b743-226">Další informace naleznete v [tématu Forward-Compatible Data Contracts](../../../../docs/framework/wcf/feature-details/forward-compatible-data-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="8b743-226">For more information, see [Forward-Compatible Data Contracts](../../../../docs/framework/wcf/feature-details/forward-compatible-data-contracts.md).</span></span> <span data-ttu-id="8b743-227">Nezapomeňte, že JSON je neuspořádaný, takže všechny informace o objednávce jsou ztraceny.</span><span class="sxs-lookup"><span data-stu-id="8b743-227">Remember that JSON is unordered so any order information is lost.</span></span> <span data-ttu-id="8b743-228">Kromě toho JSON nepodporuje více párů klíč/hodnota se stejným názvem klíče.</span><span class="sxs-lookup"><span data-stu-id="8b743-228">Furthermore, JSON does not support multiple key/value pairs with the same key name.</span></span> <span data-ttu-id="8b743-229">Nakonec jsou všechny <xref:System.Runtime.Serialization.IExtensibleDataObject> operace na ze své podstaty polymorfní <xref:System.Object>- to je jejich odvozený typ jsou přiřazeny , základní typ pro všechny typy.</span><span class="sxs-lookup"><span data-stu-id="8b743-229">Finally, all operations on <xref:System.Runtime.Serialization.IExtensibleDataObject> are inherently polymorphic - that is their derived type are assigned to <xref:System.Object>, the base type for all types.</span></span>

## <a name="json-in-urls"></a><span data-ttu-id="8b743-230">JSON v adresách URL</span><span class="sxs-lookup"><span data-stu-id="8b743-230">JSON in URLs</span></span>

<span data-ttu-id="8b743-231">Při použití ASP.NET koncové body AJAX se <xref:System.ServiceModel.Web.WebGetAttribute> slovesem HTTP GET (pomocí atributu) se příchozí parametry zobrazí v adrese URL požadavku namísto textu zprávy.</span><span class="sxs-lookup"><span data-stu-id="8b743-231">When using ASP.NET AJAX endpoints with the HTTP GET verb (using the <xref:System.ServiceModel.Web.WebGetAttribute> attribute), incoming parameters appear in the request URL instead of the message body.</span></span> <span data-ttu-id="8b743-232">JSON je podporován i v url požadavku, takže pokud `Int` máte operaci, `Person` která má s názvem "číslo" a komplexní typ s názvem "p", může se adresa URL podobat následující adrese URL.</span><span class="sxs-lookup"><span data-stu-id="8b743-232">JSON is supported even in the request URL, so if you have an operation that takes an `Int` called "number" and a `Person` complex type called "p", the URL may resemble the following URL.</span></span>

```html
http://example.com/myservice.svc/MyOperation?number=7&p={"name":"John","age":42}
```

<span data-ttu-id="8b743-233">Pokud používáte ovládací prvek ASP.NET AJAX Script Manager a proxy pro volání služby, tato adresa URL je automaticky generována proxy serverem a není vidět.</span><span class="sxs-lookup"><span data-stu-id="8b743-233">If you are using an ASP.NET AJAX Script Manager control and proxy to call the service, this URL is automatically generated by the proxy and is not seen.</span></span> <span data-ttu-id="8b743-234">JSON nelze použít v adresách URL na non-ASP.NET koncové body AJAX.</span><span class="sxs-lookup"><span data-stu-id="8b743-234">JSON cannot be used in URLs on non-ASP.NET AJAX endpoints.</span></span>

## <a name="advanced-information"></a><span data-ttu-id="8b743-235">Pokročilé informace</span><span class="sxs-lookup"><span data-stu-id="8b743-235">Advanced information</span></span>

### <a name="iserializable-support"></a><span data-ttu-id="8b743-236">ISerializable Podpora</span><span class="sxs-lookup"><span data-stu-id="8b743-236">ISerializable Support</span></span>

#### <a name="supported-and-unsupported-iserializable-types"></a><span data-ttu-id="8b743-237">Podporované a nepodporované iSerializable typy</span><span class="sxs-lookup"><span data-stu-id="8b743-237">Supported and Unsupported ISerializable Types</span></span>

<span data-ttu-id="8b743-238">Obecně platí, že <xref:System.Runtime.Serialization.ISerializable> typy, které implementují rozhraní jsou plně podporovány při serializaci/deserializaci JSON.</span><span class="sxs-lookup"><span data-stu-id="8b743-238">In general, types that implement the <xref:System.Runtime.Serialization.ISerializable> interface are fully supported when serializing/deserializing JSON.</span></span> <span data-ttu-id="8b743-239">Některé z těchto typů (včetně některých typů rozhraní .NET Framework) jsou však implementovány takovým způsobem, že aspekty serializace specifické pro JSON způsobí, že nebudou správně rekonstruovány:</span><span class="sxs-lookup"><span data-stu-id="8b743-239">However, some of these types (including some .NET Framework types) are implemented in such a way that the JSON-specific serialization aspects cause them to not deserialize correctly:</span></span>

- <span data-ttu-id="8b743-240">S <xref:System.Runtime.Serialization.ISerializable>, typ jednotlivých datových členů není nikdy znám předem.</span><span class="sxs-lookup"><span data-stu-id="8b743-240">With <xref:System.Runtime.Serialization.ISerializable>, the type of individual data members is never known in advance.</span></span> <span data-ttu-id="8b743-241">To vede k polymorfní situaci podobné deserializaci typů do objektu.</span><span class="sxs-lookup"><span data-stu-id="8b743-241">This leads to a polymorphic situation similar to deserializing types into an object.</span></span> <span data-ttu-id="8b743-242">Jak již bylo zmíněno dříve, může to vést ke ztrátě informací o typu v JSON.</span><span class="sxs-lookup"><span data-stu-id="8b743-242">As mentioned before, this may lead to loss of type information in JSON.</span></span> <span data-ttu-id="8b743-243">Například typ, který serializuje `enum` v <xref:System.Runtime.Serialization.ISerializable> jeho implementaci a pokusí se rekonstruovat `enum` zpět přímo do (bez řádného přetypovávání) selže, protože `enum` je serializován pomocí čísel v JSON a JSON čísla rekonstruovat do vestavěných .NET číselné typy (Int32, decimal nebo Double).</span><span class="sxs-lookup"><span data-stu-id="8b743-243">For example, a type that serializes an `enum` in its <xref:System.Runtime.Serialization.ISerializable> implementation and attempts to deserialize back directly into an `enum` (without proper casts) fails, because an `enum` is serialized using numbers in JSON and JSON numbers deserialize into built-in .NET numeric types (Int32, Decimal or Double).</span></span> <span data-ttu-id="8b743-244">Takže skutečnost, že číslo bývalo hodnotou, `enum` je ztraceno.</span><span class="sxs-lookup"><span data-stu-id="8b743-244">So the fact that the number used to be an `enum` value is lost.</span></span>

- <span data-ttu-id="8b743-245">Typ, <xref:System.Runtime.Serialization.ISerializable> který závisí na určitém pořadí deserializace v jeho konstruktoru deserializace může také selhat rekonstruovat některá data JSON, protože většina serializátory JSON nezaručují žádné konkrétní pořadí.</span><span class="sxs-lookup"><span data-stu-id="8b743-245">An <xref:System.Runtime.Serialization.ISerializable> type that depends on a particular order of deserialization in its deserialization constructor may also fail to deserialize some JSON data, because most JSON serializers do not guarantee any specific order.</span></span>

#### <a name="factory-types"></a><span data-ttu-id="8b743-246">Tovární typy</span><span class="sxs-lookup"><span data-stu-id="8b743-246">Factory Types</span></span>

<span data-ttu-id="8b743-247">Zatímco <xref:System.Runtime.Serialization.IObjectReference> rozhraní je podporováno v JSON obecně, všechny typy, které vyžadují funkci "tovární <xref:System.Runtime.Serialization.IObjectReference.GetRealObject%28System.Runtime.Serialization.StreamingContext%29> typ" (vrácení instance jiného typu než typ, který implementuje rozhraní) nejsou podporovány.</span><span class="sxs-lookup"><span data-stu-id="8b743-247">While the <xref:System.Runtime.Serialization.IObjectReference> interface is supported in JSON in general, any types that require the "factory type" feature (returning an instance of a different type from <xref:System.Runtime.Serialization.IObjectReference.GetRealObject%28System.Runtime.Serialization.StreamingContext%29> than the type that implements the interface) are not supported.</span></span>

### <a name="datetime-wire-format"></a><span data-ttu-id="8b743-248">Formát datatime drátu</span><span class="sxs-lookup"><span data-stu-id="8b743-248">DateTime Wire Format</span></span>

<span data-ttu-id="8b743-249"><xref:System.DateTime>hodnoty se zobrazí jako řetězce JSON ve formě "/Date(700000+0500)/", kde první číslo (700000 v příkladu je uvedeno) je počet milisekund v časovém pásmu GMT, pravidelný čas (neletní) od půlnoci, 1.</span><span class="sxs-lookup"><span data-stu-id="8b743-249"><xref:System.DateTime> values appear as JSON strings in the form of "/Date(700000+0500)/", where the first number (700000 in the example provided) is the number of milliseconds in the GMT time zone, regular (non-daylight savings) time since midnight, January 1, 1970.</span></span> <span data-ttu-id="8b743-250">Číslo může být záporné, aby představovalo dřívější časy.</span><span class="sxs-lookup"><span data-stu-id="8b743-250">The number may be negative to represent earlier times.</span></span> <span data-ttu-id="8b743-251">Část, která se skládá z "+0500" v příkladu je <xref:System.DateTimeKind.Local> volitelné a označuje, že čas je druhu - to znamená, by měl být převeden na místní časové pásmo na deserializaci.</span><span class="sxs-lookup"><span data-stu-id="8b743-251">The part that consists of "+0500" in the example is optional and indicates that the time is of the <xref:System.DateTimeKind.Local> kind - that is, should be converted to the local time zone on deserialization.</span></span> <span data-ttu-id="8b743-252">Pokud chybí, čas je reserializován <xref:System.DateTimeKind.Utc>jako .</span><span class="sxs-lookup"><span data-stu-id="8b743-252">If it is absent, the time is deserialized as <xref:System.DateTimeKind.Utc>.</span></span> <span data-ttu-id="8b743-253">Skutečné číslo ("0500" v tomto příkladu) a jeho znaménko (+ nebo -) jsou ignorovány.</span><span class="sxs-lookup"><span data-stu-id="8b743-253">The actual number ("0500" in this example) and its sign (+ or -) are ignored.</span></span>

<span data-ttu-id="8b743-254">Při <xref:System.DateTime>serializace <xref:System.DateTimeKind.Local> <xref:System.DateTimeKind.Unspecified> , a časy jsou <xref:System.DateTimeKind.Utc> zapsány s posunem a je zapsán bez.</span><span class="sxs-lookup"><span data-stu-id="8b743-254">When serializing <xref:System.DateTime>, <xref:System.DateTimeKind.Local> and <xref:System.DateTimeKind.Unspecified> times are written with an offset, and <xref:System.DateTimeKind.Utc> is written without.</span></span>

<span data-ttu-id="8b743-255">ASP.NET kód javascriptu klienta AJAX automaticky převede tyto řetězce na instance JavaScriptu. `DateTime`</span><span class="sxs-lookup"><span data-stu-id="8b743-255">The ASP.NET AJAX client JavaScript code automatically converts such strings into JavaScript `DateTime` instances.</span></span> <span data-ttu-id="8b743-256">Pokud existují jiné řetězce, které mají podobný formulář, které nejsou typu <xref:System.DateTime> v .NET, jsou převedeny také.</span><span class="sxs-lookup"><span data-stu-id="8b743-256">If there are other strings that have a similar form that are not of type <xref:System.DateTime> in .NET, they are converted as well.</span></span>

<span data-ttu-id="8b743-257">Převod probíhá pouze v případě, že jsou uvozeny znaky "/" (to znamená, že JSON vypadá jako "\\/Date(700000+0500)\\/"), a z tohoto důvodu kodér JSON WCF (povolený <xref:System.ServiceModel.WebHttpBinding>) vždy unikne znaku "/".</span><span class="sxs-lookup"><span data-stu-id="8b743-257">The conversion only takes place if the "/" characters are escaped (that is, the JSON looks like "\\/Date(700000+0500)\\/"), and for this reason WCF's JSON encoder (enabled by the <xref:System.ServiceModel.WebHttpBinding>) always escapes the "/" character.</span></span>

### <a name="xml-in-json-strings"></a><span data-ttu-id="8b743-258">XML v řetězcích JSON</span><span class="sxs-lookup"><span data-stu-id="8b743-258">XML in JSON Strings</span></span>

#### <a name="xmlelement"></a><span data-ttu-id="8b743-259">Xmlelement</span><span class="sxs-lookup"><span data-stu-id="8b743-259">XmlElement</span></span>

<span data-ttu-id="8b743-260"><xref:System.Xml.XmlElement>je serializován tak, jak je, bez obalu.</span><span class="sxs-lookup"><span data-stu-id="8b743-260"><xref:System.Xml.XmlElement> is serialized as is, with no wrapping.</span></span> <span data-ttu-id="8b743-261">Například datový člen "x" <xref:System.Xml.XmlElement> typu, který obsahuje \<abc/> je reprezentován takto:</span><span class="sxs-lookup"><span data-stu-id="8b743-261">For example, data member "x" of type <xref:System.Xml.XmlElement> that contains \<abc/> is represented as follows:</span></span>

```json
{"x":"<abc/>"}
```

#### <a name="arrays-of-xmlnode"></a><span data-ttu-id="8b743-262">Pole xmlnode</span><span class="sxs-lookup"><span data-stu-id="8b743-262">Arrays of XmlNode</span></span>

<span data-ttu-id="8b743-263"><xref:System.Array>objekty <xref:System.Xml.XmlNode> typu jsou zabaleny do prvku nazvaného ArrayOfXmlNode ve standardním oboru názvů datové smlouvy pro daný typ.</span><span class="sxs-lookup"><span data-stu-id="8b743-263"><xref:System.Array> objects of type <xref:System.Xml.XmlNode> are wrapped in an element called ArrayOfXmlNode in the standard data contract namespace for the type.</span></span> <span data-ttu-id="8b743-264">Pokud "x" je pole, které obsahuje uzel atributu "N" v oboru názvů "ns", který obsahuje "hodnotu" a uzel prázdného prvku "M", reprezentace je následující.</span><span class="sxs-lookup"><span data-stu-id="8b743-264">If "x" is an array that contains attribute node "N" in namespace "ns" that contains "value" and an empty element node "M", the representation is as follows.</span></span>

```json
{"x":"<ArrayOfXmlNode xmlns=\"http://schemas.datacontract.org/2004/07/System.Xml\" a:N=\"value\" xmlns:a=\"ns\"><M/></ArrayOfXmlNode>"}
```

 <span data-ttu-id="8b743-265">Atributy v prázdném oboru názvů na začátku polí XmlNode (před ostatními prvky) nejsou podporovány.</span><span class="sxs-lookup"><span data-stu-id="8b743-265">Attributes in the empty namespace at the beginning of XmlNode arrays (before other elements) are unsupported.</span></span>

#### <a name="ixmlserializable-types-including-xelement-and-dataset"></a><span data-ttu-id="8b743-266">Typy IXmlSerializable včetně XElement a DataSet</span><span class="sxs-lookup"><span data-stu-id="8b743-266">IXmlSerializable Types including XElement and DataSet</span></span>

<span data-ttu-id="8b743-267"><xref:System.Runtime.Serialization.ISerializable>typy rozdělují na "typy obsahu", "Typy datových sad" a "typy prvků".</span><span class="sxs-lookup"><span data-stu-id="8b743-267"><xref:System.Runtime.Serialization.ISerializable> types subdivide into "content types", "DataSet types" and "element types".</span></span> <span data-ttu-id="8b743-268">Definice těchto typů naleznete v tématu [XML a ADO.NET Typy v datových kontraktech](../../../../docs/framework/wcf/feature-details/xml-and-ado-net-types-in-data-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="8b743-268">For definitions of these types, see [XML and ADO.NET Types in Data Contracts](../../../../docs/framework/wcf/feature-details/xml-and-ado-net-types-in-data-contracts.md).</span></span>

<span data-ttu-id="8b743-269">"Content" a "DataSet" typy jsou <xref:System.Array> serializovány podobné objekty <xref:System.Xml.XmlNode> popsané v předchozí části.</span><span class="sxs-lookup"><span data-stu-id="8b743-269">"Content" and "DataSet" types are serialized similar to <xref:System.Array> objects of <xref:System.Xml.XmlNode> discussed in the previous section.</span></span> <span data-ttu-id="8b743-270">Jsou zabaleny do prvku, jehož název a obor názvů odpovídá názvu datové smlouvy a oboru názvů daného typu.</span><span class="sxs-lookup"><span data-stu-id="8b743-270">They are wrapped in an element whose name and namespace corresponds to the data contract name and namespace of the type in question.</span></span>

<span data-ttu-id="8b743-271">"Element" typy, <xref:System.Xml.Linq.XElement> jako jsou serializovány, jak je, podobně jako <xref:System.Xml.XmlElement> dříve popsány v tomto tématu.</span><span class="sxs-lookup"><span data-stu-id="8b743-271">"Element" types such as <xref:System.Xml.Linq.XElement> are serialized as is, similar to <xref:System.Xml.XmlElement> previously discussed in this topic.</span></span>

### <a name="polymorphism"></a><span data-ttu-id="8b743-272">Polymorfismus</span><span class="sxs-lookup"><span data-stu-id="8b743-272">Polymorphism</span></span>

#### <a name="preserving-type-information"></a><span data-ttu-id="8b743-273">Zachování informací o typu</span><span class="sxs-lookup"><span data-stu-id="8b743-273">Preserving Type Information</span></span>

<span data-ttu-id="8b743-274">Jak již bylo uvedeno dříve, polymorfismus je podporován v JSON s určitými omezeními.</span><span class="sxs-lookup"><span data-stu-id="8b743-274">As stated earlier, polymorphism is supported in JSON with some limitations.</span></span> <span data-ttu-id="8b743-275">JavaScript je slabě napsaný jazyk a identita typu obvykle není problém.</span><span class="sxs-lookup"><span data-stu-id="8b743-275">JavaScript is a weakly-typed language and type identity is normally not an issue.</span></span> <span data-ttu-id="8b743-276">Však při použití JSON komunikovat mezi systémem silného typu (.NET) a slabě napsaný systém (JavaScript), je však užitečné zachovat identitu typu.</span><span class="sxs-lookup"><span data-stu-id="8b743-276">However, when using JSON to communicate between a strongly-typed system (.NET) and a weakly-typed system (JavaScript), it is useful to preserve type identity.</span></span> <span data-ttu-id="8b743-277">Například typy s názvy datových smluv "Čtverec" a "Kruh" jsou odvozeny od typu s názvem kontraktu dat "Shape".</span><span class="sxs-lookup"><span data-stu-id="8b743-277">For example, types with data contract names "Square" and "Circle" derive from a type with a data contract name of "Shape".</span></span> <span data-ttu-id="8b743-278">Pokud "Circle" je odeslána z .NET do JavaScriptu a je později vrácena do .NET metoda, která očekává "Shape", je užitečné pro stranu .NET vědět, že dotyčný objekt byl původně "Circle" - jinak všechny informace specifické pro odvozený typ (například , "radius" datový člen na "Kruh") může být ztracena.</span><span class="sxs-lookup"><span data-stu-id="8b743-278">If "Circle" is sent from .NET to JavaScript and is later returned to a .NET method that expects "Shape", it is useful for the .NET side to know that the object in question was originally a "Circle" - otherwise any information specific to the derived type (for example, "radius" data member on "Circle") may be lost.</span></span>

<span data-ttu-id="8b743-279">Chcete-li zachovat identitu typu, při serializaci složitých typů do JSON lze přidat "nápovědu typu" a deserializátor rozpozná nápovědu a funguje odpovídajícím způsobem.</span><span class="sxs-lookup"><span data-stu-id="8b743-279">To preserve type identity, when serializing complex types to JSON a "type hint" can be added, and the deserializer recognizes the hint and acts appropriately.</span></span> <span data-ttu-id="8b743-280">"Nápověda typu" je pár klíčů/hodnot JSON s\_\_názvem klíče "type" (dvě podtržítka následovaná slovem "typ").</span><span class="sxs-lookup"><span data-stu-id="8b743-280">The "type hint" is a JSON key/value pair with the key name of "\_\_type" (two underscores followed by the word "type").</span></span> <span data-ttu-id="8b743-281">Hodnota je řetězec JSON ve formuláři "DataContractName:DataContractNamespace" (cokoli až do prvnídvojtečky je název).</span><span class="sxs-lookup"><span data-stu-id="8b743-281">The value is a JSON string of the form "DataContractName:DataContractNamespace" (anything up to the first colon is the name).</span></span> <span data-ttu-id="8b743-282">Pomocí předchozího příkladu "Circle" lze serializovat následujícím způsobem.</span><span class="sxs-lookup"><span data-stu-id="8b743-282">Using the earlier example, "Circle" can be serialized as follows.</span></span>

```json
{"__type":"Circle:http://example.com/myNamespace","x":50,"y":70,"radius":10}
```

<span data-ttu-id="8b743-283">Nápověda typu je velmi `xsi:type` podobná atributu definovanému standardem instance schématu XML a použitá při serializaci/deserializaci XML.</span><span class="sxs-lookup"><span data-stu-id="8b743-283">The type hint is very similar to the `xsi:type` attribute defined by the XML Schema Instance standard and used when serializing/deserializing XML.</span></span>

<span data-ttu-id="8b743-284">Datové členy\_\_nazývané "typ" jsou zakázány z důvodu možného konfliktu s nápovědou typu.</span><span class="sxs-lookup"><span data-stu-id="8b743-284">Data members called "\_\_type" are forbidden due to potential conflict with the type hint.</span></span>

#### <a name="reducing-the-size-of-type-hints"></a><span data-ttu-id="8b743-285">Zmenšení velikosti návažek typu</span><span class="sxs-lookup"><span data-stu-id="8b743-285">Reducing the Size of Type Hints</span></span>

<span data-ttu-id="8b743-286">Chcete-li zmenšit velikost zpráv JSON, výchozí`http://schemas.datacontract.org/2004/07/`předpona oboru názvů datové smlouvy ( ) je nahrazena znakem "#".</span><span class="sxs-lookup"><span data-stu-id="8b743-286">To reduce the size of JSON messages, the default data contract namespace prefix (`http://schemas.datacontract.org/2004/07/`) is replaced with the "#" character.</span></span> <span data-ttu-id="8b743-287">(Chcete-li toto nahrazení reverzibilní, je použito pravidlo úniku: pokud\\obor názvů začíná znaky "#" nebo " , jsou připojeny s extra znakem "\\).</span><span class="sxs-lookup"><span data-stu-id="8b743-287">(To make this replacement reversible, an escaping rule is used: if the namespace starts with the "#" or "\\" characters, they are appended with an extra "\\" character).</span></span> <span data-ttu-id="8b743-288">Pokud je tedy "Circle" typem v oboru názvů .NET "MyApp.Shapes", `http://schemas.datacontract.org/2004/07/MyApp`je jeho výchozí obor názvů datové smlouvy .</span><span class="sxs-lookup"><span data-stu-id="8b743-288">Thus, if "Circle" is a type in the .NET namespace "MyApp.Shapes", its default data contract namespace is `http://schemas.datacontract.org/2004/07/MyApp`.</span></span> <span data-ttu-id="8b743-289">Tvary a reprezentace JSON jsou následující.</span><span class="sxs-lookup"><span data-stu-id="8b743-289">Shapes and the JSON representation is as follows.</span></span>

```json
{"__type":"Circle:#MyApp.Shapes","x":50,"y":70,"radius":10}
```

<span data-ttu-id="8b743-290">Jak zkrácené (#MyApp.Shapes) a úplnéhttp://schemas.datacontract.org/2004/07/MyApp.Shapes) (názvy jsou chápány na deserializaci.</span><span class="sxs-lookup"><span data-stu-id="8b743-290">Both the truncated (#MyApp.Shapes) and the full (http://schemas.datacontract.org/2004/07/MyApp.Shapes) names is understood on deserialization.</span></span>

#### <a name="type-hint-position-in-json-objects"></a><span data-ttu-id="8b743-291">Pozice nápovědy typu v objektech JSON</span><span class="sxs-lookup"><span data-stu-id="8b743-291">Type Hint Position in JSON Objects</span></span>

<span data-ttu-id="8b743-292">Všimněte si, že nápověda typu se musí zobrazit jako první v reprezentaci JSON.</span><span class="sxs-lookup"><span data-stu-id="8b743-292">Note that the type hint must appear first in the JSON representation.</span></span> <span data-ttu-id="8b743-293">Toto je jediný případ, kdy pořadí párů klíč/hodnota je důležité při zpracování JSON.</span><span class="sxs-lookup"><span data-stu-id="8b743-293">This is the only case where order of key/value pairs is important in JSON processing.</span></span> <span data-ttu-id="8b743-294">Například následující není platný způsob, jak určit nápovědu typu.</span><span class="sxs-lookup"><span data-stu-id="8b743-294">For example, the following is not a valid way to specify the type hint.</span></span>

```json
{"x":50,"y":70,"radius":10,"__type":"Circle:#MyApp.Shapes"}
```

<span data-ttu-id="8b743-295">Oba <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> používané WCF a ASP.NET ajax klientské stránky vždy vyzařují typ nápovědy jako první.</span><span class="sxs-lookup"><span data-stu-id="8b743-295">Both the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> used by WCF and ASP.NET AJAX client pages always emit the type hint first.</span></span>

#### <a name="type-hints-apply-only-to-complex-types"></a><span data-ttu-id="8b743-296">Rady pro typ platí pouze pro složité typy</span><span class="sxs-lookup"><span data-stu-id="8b743-296">Type Hints Apply Only to Complex Types</span></span>

<span data-ttu-id="8b743-297">Neexistuje žádný způsob, jak vyzařovat nápovědu typu pro nesložité typy.</span><span class="sxs-lookup"><span data-stu-id="8b743-297">There is no way to emit a type hint for non-complex types.</span></span> <span data-ttu-id="8b743-298">Například pokud operace má <xref:System.Object> návratový typ, ale vrátí Circle, reprezentace JSON může být, jak je uvedeno dříve a informace o typu je zachována.</span><span class="sxs-lookup"><span data-stu-id="8b743-298">For example, if an operation has an <xref:System.Object> return type but returns a Circle, the JSON representation can be as shown earlier and the type information is preserved.</span></span> <span data-ttu-id="8b743-299">Však pokud uri je vrácena, reprezentace JSON je řetězec a skutečnost, že řetězec slouží k reprezentaci Uri je ztracena.</span><span class="sxs-lookup"><span data-stu-id="8b743-299">However, if Uri is returned, the JSON representation is a string and the fact that the string used to represent a Uri is lost.</span></span> <span data-ttu-id="8b743-300">To platí nejen pro primitivní typy, ale také pro kolekce a pole.</span><span class="sxs-lookup"><span data-stu-id="8b743-300">This applies not only to primitive types but also to collections and arrays.</span></span>

#### <a name="when-are-type-hints-emitted"></a><span data-ttu-id="8b743-301">Když jsou vyzařovány rady typu</span><span class="sxs-lookup"><span data-stu-id="8b743-301">When Are Type Hints Emitted</span></span>

<span data-ttu-id="8b743-302">Typ rady mohou výrazně zvětšit velikost zprávy (jedním ze způsobů, jak to zmírnit, je použít kratší obory názvů smlouvy dat, pokud je to možné).</span><span class="sxs-lookup"><span data-stu-id="8b743-302">Type hints may increase message size significantly (one way to mitigate this is to use shorter data contract namespaces if possible).</span></span> <span data-ttu-id="8b743-303">Proto následující pravidla určují, zda jsou emitovány rady typu:</span><span class="sxs-lookup"><span data-stu-id="8b743-303">Therefore, the following rules govern whether type hints are emitted:</span></span>

- <span data-ttu-id="8b743-304">Při použití ASP.NET AJAX, typ rady jsou vždy vydávány, kdykoli je to možné, i v případě, že neexistuje žádná základní/odvozené přiřazení - například i v případě, že Circle je přiřazen circle.</span><span class="sxs-lookup"><span data-stu-id="8b743-304">When using ASP.NET AJAX, type hints are always emitted whenever possible, even if there is no base/derived assignment - for example, even if a Circle is assigned to a Circle.</span></span> <span data-ttu-id="8b743-305">(To je nutné plně povolit proces volání ze slabě typovaného prostředí JSON do prostředí silného typu .NET bez překvapivé ztráty informací.)</span><span class="sxs-lookup"><span data-stu-id="8b743-305">(This is required to fully enable the process of calling from the weakly-typed JSON environment into the strongly-typed .NET environment with no surprising loss of information.)</span></span>

- <span data-ttu-id="8b743-306">Při použití služby AJAX bez ASP.NET integrace, typ rady jsou vydávány pouze v případě, že je základní/odvozené přiřazení - to znamená, že je vydáván při Circle je přiřazen k Shape nebo <xref:System.Object> ale ne při přiřazení circle.</span><span class="sxs-lookup"><span data-stu-id="8b743-306">When using AJAX services with no ASP.NET integration, type hints are only emitted when there is a base/derived assignment - that is, emitted when Circle is assigned to Shape or <xref:System.Object> but not when assigned to Circle.</span></span> <span data-ttu-id="8b743-307">To poskytuje minimální informace potřebné ke správné implementaci klienta Jazyka JavaScript, čímž se zlepší výkon, ale nechrání před ztrátou informací o typu v nesprávně navržených klientech.</span><span class="sxs-lookup"><span data-stu-id="8b743-307">This provides the minimum information required to correctly implement a JavaScript client, thus improving performance, but does not protect against type information loss in incorrectly-designed clients.</span></span> <span data-ttu-id="8b743-308">Pokud se chcete vyhnout řešení tohoto problému na straně klienta, vyhněte se základním/odvozeným přiřazením na serveru.</span><span class="sxs-lookup"><span data-stu-id="8b743-308">Avoid base/derived assignments altogether on the server if you want to avoid dealing with this issue on the client.</span></span>

- <span data-ttu-id="8b743-309">Při použití <xref:System.Runtime.Serialization.DataContractSerializer> typu `alwaysEmitTypeInformation` umožňuje parametr konstruktoru vybrat mezi předchozími dvěma režimy, přičemž výchozí je "`false`" (pouze vyzařují rady typu v případě potřeby).</span><span class="sxs-lookup"><span data-stu-id="8b743-309">When using the <xref:System.Runtime.Serialization.DataContractSerializer> type, the `alwaysEmitTypeInformation` constructor parameter allows you to choose between the preceding two modes, with the default being "`false`" (only emit type hints when required).</span></span>

#### <a name="duplicate-data-member-names"></a><span data-ttu-id="8b743-310">Duplicitní názvy datových členů</span><span class="sxs-lookup"><span data-stu-id="8b743-310">Duplicate Data Member Names</span></span>

<span data-ttu-id="8b743-311">Informace o odvozeném typu je k dispozici ve stejném objektu JSON spolu s informacemi o základním typu a může dojít v libovolném pořadí.</span><span class="sxs-lookup"><span data-stu-id="8b743-311">Derived type information is present in the same JSON object together with base type information, and can occur in any order.</span></span> <span data-ttu-id="8b743-312">Například `Shape` mohou být reprezentovány následujícím způsobem.</span><span class="sxs-lookup"><span data-stu-id="8b743-312">For example, `Shape` may be represented as follows.</span></span>

```json
{"__type":"Shape:#MyApp.Shapes","x":50,"y":70}
```

<span data-ttu-id="8b743-313">Vzhledem k tomu, Circle mohou být zastoupeny takto.</span><span class="sxs-lookup"><span data-stu-id="8b743-313">Whereas Circle may be represented as follows.</span></span>

```json
{"__type":"Circle:#MyApp.Shapes","x":50, "radius":10,"y":70}
```

<span data-ttu-id="8b743-314">Pokud základní `Shape` typ také obsahoval datový`radius`člen s názvem " ", vede to ke kolizi při serializaci (protože objekty JSON nemohou mít `Shape.radius` `Circle.radius`opakující se názvy klíčů) a deserializaci (protože není jasné, zda "poloměr" odkazuje na nebo ).</span><span class="sxs-lookup"><span data-stu-id="8b743-314">If the base `Shape` type also contained a data member called "`radius`", this leads to a collision on both serialization (because JSON objects cannot have repeating key names) and deserialization (because it is unclear whether "radius" refers to `Shape.radius` or `Circle.radius`).</span></span> <span data-ttu-id="8b743-315">Proto zatímco koncept "vlastnost skrývání" (datové členy se stejným názvem na základě a odvozené třídy) se obecně nedoporučuje ve třídách smlouvy dat, je ve skutečnosti zakázáno v případě JSON.</span><span class="sxs-lookup"><span data-stu-id="8b743-315">Therefore, while the concept of "property hiding" (data members of the same name on based and derived classes) is generally not recommended in data contract classes, it is actually forbidden in the case of JSON.</span></span>

#### <a name="polymorphism-and-ixmlserializable-types"></a><span data-ttu-id="8b743-316">Polymorfismus a iXmlSerializable typy</span><span class="sxs-lookup"><span data-stu-id="8b743-316">Polymorphism and IXmlSerializable Types</span></span>

<span data-ttu-id="8b743-317"><xref:System.Xml.Serialization.IXmlSerializable>typy mohou být polymorfně přiřazeny k sobě jako obvykle, pokud jsou splněny požadavky známé typy, v souladu s obvyklými pravidly smlouvy dat.</span><span class="sxs-lookup"><span data-stu-id="8b743-317"><xref:System.Xml.Serialization.IXmlSerializable> types may be polymorphically assigned to each other as usual as long as Known Types requirements are met, according to usual data contract rules.</span></span> <span data-ttu-id="8b743-318">Serializace <xref:System.Xml.Serialization.IXmlSerializable> typu namísto <xref:System.Object> výsledků ke ztrátě informací o typu jako výsledek je řetězec JSON.</span><span class="sxs-lookup"><span data-stu-id="8b743-318">However, serializing an <xref:System.Xml.Serialization.IXmlSerializable> type in place of <xref:System.Object> results in loss of type information as the result is a JSON string.</span></span>

#### <a name="polymorphism-and-certain-interface-types"></a><span data-ttu-id="8b743-319">Polymorfismus a určité typy rozhraní</span><span class="sxs-lookup"><span data-stu-id="8b743-319">Polymorphism and Certain Interface Types</span></span>

<span data-ttu-id="8b743-320">Je zakázáno serializovat typ kolekce nebo typ, <xref:System.Xml.Serialization.IXmlSerializable> který implementuje, kde <xref:System.Xml.Serialization.IXmlSerializable> se <xref:System.Object>očekává typ bez kolekce, který není (s výjimkou) .</span><span class="sxs-lookup"><span data-stu-id="8b743-320">It is forbidden to serialize a collection type or a type that implements <xref:System.Xml.Serialization.IXmlSerializable> where a non-collection type that is not <xref:System.Xml.Serialization.IXmlSerializable> (except for <xref:System.Object>) is expected.</span></span> <span data-ttu-id="8b743-321">Například vlastní rozhraní `IMyInterface` s názvem `MyType` a <xref:System.Collections.Generic.IEnumerable%601> typ, `int` `IMyInterface`který implementuje typ a .</span><span class="sxs-lookup"><span data-stu-id="8b743-321">For example, a custom interface called `IMyInterface` and a type `MyType` that implement both <xref:System.Collections.Generic.IEnumerable%601> of type `int` and `IMyInterface`.</span></span> <span data-ttu-id="8b743-322">Je zakázáno `MyType` vrátit se z operace, jejíž návratový typ je `IMyInterface`.</span><span class="sxs-lookup"><span data-stu-id="8b743-322">It is forbidden to return `MyType` from an operation whose return type is `IMyInterface`.</span></span> <span data-ttu-id="8b743-323">Důvodem `MyType` je, že musí být serializován jako pole JSON a vyžaduje nápovědu typu a jak je uvedeno dříve, nelze zahrnout nápovědu typu s poli, pouze se složitými typy.</span><span class="sxs-lookup"><span data-stu-id="8b743-323">This is because `MyType` must be serialized as a JSON array and requires a type hint, and as stated before you cannot include a type hint with arrays, only with complex types.</span></span>

#### <a name="known-types-and-configuration"></a><span data-ttu-id="8b743-324">Známé typy a konfigurace</span><span class="sxs-lookup"><span data-stu-id="8b743-324">Known Types and Configuration</span></span>

<span data-ttu-id="8b743-325">Všechny známé typy mechanismy používané <xref:System.Runtime.Serialization.DataContractSerializer> jsou také podporovány <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer>stejným způsobem .</span><span class="sxs-lookup"><span data-stu-id="8b743-325">All of the Known Type mechanisms used by the <xref:System.Runtime.Serialization.DataContractSerializer> are also supported in the same way by the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer>.</span></span> <span data-ttu-id="8b743-326">Oba serializátory číst stejný konfigurační prvek, [ \<dataContractSerializer>](../../../../docs/framework/configure-apps/file-schema/wcf/datacontractserializer-of-system-runtime-serialization.md) v [ \<system.runtime.serialization>](../../../../docs/framework/configure-apps/file-schema/wcf/system-runtime-serialization.md), chcete-li zjistit známé typy přidané prostřednictvím konfiguračního souboru.</span><span class="sxs-lookup"><span data-stu-id="8b743-326">Both serializers read the same configuration element, [\<dataContractSerializer>](../../../../docs/framework/configure-apps/file-schema/wcf/datacontractserializer-of-system-runtime-serialization.md) in [\<system.runtime.serialization>](../../../../docs/framework/configure-apps/file-schema/wcf/system-runtime-serialization.md), to discover known types added through a configuration file.</span></span>

#### <a name="collections-assigned-to-object"></a><span data-ttu-id="8b743-327">Kolekce přiřazené k objektu</span><span class="sxs-lookup"><span data-stu-id="8b743-327">Collections Assigned to Object</span></span>

<span data-ttu-id="8b743-328">Kolekce přiřazené Object jsou serializovány, jako <xref:System.Collections.Generic.IEnumerable%601>by se jedná o kolekce, které implementují : pole JSON s každou položkou, která má nápovědu typu, pokud se jedná o komplexní typ.</span><span class="sxs-lookup"><span data-stu-id="8b743-328">Collections assigned to Object are serialized as if they are collections that implement <xref:System.Collections.Generic.IEnumerable%601>: a JSON array with each entry that has a type hint if it is a complex type.</span></span> <span data-ttu-id="8b743-329">Například <xref:System.Collections.Generic.List%601> typ `Shape` přiřazený <xref:System.Object> k vypadá takto.</span><span class="sxs-lookup"><span data-stu-id="8b743-329">For example, a <xref:System.Collections.Generic.List%601> of type `Shape` assigned to <xref:System.Object> looks like the following.</span></span>

```json
[{"__type":"Shape:#MyApp.Shapes","x":50,"y":70},
{"__type":"Shape:#MyApp.Shapes","x":58,"y":73},
{"__type":"Shape:#MyApp.Shapes","x":41,"y":32}]
```

<span data-ttu-id="8b743-330">Při deserialikace zpět do <xref:System.Object>:</span><span class="sxs-lookup"><span data-stu-id="8b743-330">When deserialized back into <xref:System.Object>:</span></span>

- <span data-ttu-id="8b743-331">`Shape`musí být v seznamu Známé typy.</span><span class="sxs-lookup"><span data-stu-id="8b743-331">`Shape` must be in the Known Types list.</span></span> <span data-ttu-id="8b743-332">S <xref:System.Collections.Generic.List%601> typu `Shape` ve známých typů nemá žádný vliv.</span><span class="sxs-lookup"><span data-stu-id="8b743-332">Having <xref:System.Collections.Generic.List%601> of type `Shape` in known types has no effect.</span></span> <span data-ttu-id="8b743-333">Všimněte si, že `Shape` není třeba přidávat do známých typů na serializaci v tomto případě - to se provádí automaticky.</span><span class="sxs-lookup"><span data-stu-id="8b743-333">Note that you do not have to add `Shape` to known types on serialization in this case - this is done automatically.</span></span>

- <span data-ttu-id="8b743-334">Kolekce je deserializována <xref:System.Array> jako <xref:System.Object> typ, který obsahuje `Shape` instance.</span><span class="sxs-lookup"><span data-stu-id="8b743-334">The collection is deserialized as an <xref:System.Array> of type <xref:System.Object> that contains `Shape` instances.</span></span>

#### <a name="derived-collections-assigned-to-base-collections"></a><span data-ttu-id="8b743-335">Odvozené kolekce přiřazené k základním kolekcím</span><span class="sxs-lookup"><span data-stu-id="8b743-335">Derived Collections Assigned to Base Collections</span></span>

<span data-ttu-id="8b743-336">Při odvozené kolekce je přiřazena k základní kolekci, kolekce je obvykle serializován, jako kdyby se jednalo o kolekci základního typu.</span><span class="sxs-lookup"><span data-stu-id="8b743-336">When a derived collection is assigned to a base collection, the collection is usually serialized as if it was a collection of the base type.</span></span> <span data-ttu-id="8b743-337">Pokud však typ položky odvozené kolekce nelze přiřadit k typu položky základní kolekce, je vyvolána výjimka.</span><span class="sxs-lookup"><span data-stu-id="8b743-337">However, if the item type of the derived collection cannot be assigned to the item type of the base collection, an exception is thrown.</span></span>

#### <a name="type-hints-and-dictionaries"></a><span data-ttu-id="8b743-338">Nápovědy k typu a slovníky</span><span class="sxs-lookup"><span data-stu-id="8b743-338">Type Hints and Dictionaries</span></span>

<span data-ttu-id="8b743-339">Pokud je slovník přiřazen <xref:System.Object>k aplikaci , každá položka klíče a hodnoty ve <xref:System.Object> slovníku je považována za přiřazenou a získá nápovědu k typu.</span><span class="sxs-lookup"><span data-stu-id="8b743-339">When a dictionary is assigned to an <xref:System.Object>, each Key and Value entry in the dictionary is treated as if it was assigned to <xref:System.Object> and gets a type hint.</span></span>

<span data-ttu-id="8b743-340">Při serializaci typů slovníku, JSON objekt, který obsahuje "Klíč" a `alwaysEmitTypeInformation` "Hodnota" členy není ovlivněna nastavení a obsahuje pouze nápovědu typu, pokud předchozí pravidla kolekce vyžadují.</span><span class="sxs-lookup"><span data-stu-id="8b743-340">When serializing dictionary types, the JSON object that contains the "Key" and "Value" members is unaffected by the `alwaysEmitTypeInformation` setting and only contains a type hint when the preceding collection rules require it.</span></span>

### <a name="valid-json-key-names"></a><span data-ttu-id="8b743-341">Platné názvy klíčů JSON</span><span class="sxs-lookup"><span data-stu-id="8b743-341">Valid JSON Key Names</span></span>

<span data-ttu-id="8b743-342">Serializátor XML kóduje názvy klíčů, které nejsou platnými názvy XML.</span><span class="sxs-lookup"><span data-stu-id="8b743-342">The serializer XML-encodes key names that are not valid XML names.</span></span> <span data-ttu-id="8b743-343">Například datový člen s názvem "123" by měl kódovaný název,\_například\_\_" x0031 x0032\_\_x0033\_", protože "123" je neplatný název prvku XML (začíná číslicí).</span><span class="sxs-lookup"><span data-stu-id="8b743-343">For example, a data member with the name of "123" would have an encoded name such as "\_x0031\_\_x0032\_\_x0033\_" because "123" is an invalid XML element name (starts with a digit).</span></span> <span data-ttu-id="8b743-344">Podobná situace může nastat s některými mezinárodními znakovými sadami, které nejsou platné v názvech XML.</span><span class="sxs-lookup"><span data-stu-id="8b743-344">A similar situation may arise with some international character sets not valid in XML names.</span></span> <span data-ttu-id="8b743-345">Vysvětlení tohoto vlivu xml na zpracování JSON naleznete v [tématu Mapování mezi json a XML](../../../../docs/framework/wcf/feature-details/mapping-between-json-and-xml.md).</span><span class="sxs-lookup"><span data-stu-id="8b743-345">For an explanation of this effect of XML on JSON processing, see [Mapping Between JSON and XML](../../../../docs/framework/wcf/feature-details/mapping-between-json-and-xml.md).</span></span>

## <a name="see-also"></a><span data-ttu-id="8b743-346">Viz také</span><span class="sxs-lookup"><span data-stu-id="8b743-346">See also</span></span>

- [<span data-ttu-id="8b743-347">Podpora formátu JSON a dalších formátů přenosu dat</span><span class="sxs-lookup"><span data-stu-id="8b743-347">Support for JSON and Other Data Transfer Formats</span></span>](../../../../docs/framework/wcf/feature-details/support-for-json-and-other-data-transfer-formats.md)
