---
title: Samostatná serializace JSON pomocí DataContractJsonSerializer
ms.date: 03/30/2017
ms.assetid: 312bd7b2-1300-4b12-801e-ebe742bd2287
ms.openlocfilehash: 6bd075405a3bca0cc64dda90225526096b6fa8e3
ms.sourcegitcommit: 71b8f5a2108a0f1a4ef1d8d75c5b3e129ec5ca1e
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 05/29/2020
ms.locfileid: "84202393"
---
# <a name="stand-alone-json-serialization-using-datacontractjsonserializer"></a><span data-ttu-id="30528-102">Samostatná serializace JSON pomocí DataContractJsonSerializer</span><span class="sxs-lookup"><span data-stu-id="30528-102">Stand-Alone JSON Serialization using DataContractJsonSerializer</span></span>

> [!NOTE]
> <span data-ttu-id="30528-103">Tento článek se týká <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> .</span><span class="sxs-lookup"><span data-stu-id="30528-103">This article is about <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer>.</span></span> <span data-ttu-id="30528-104">Pro většinu scénářů, které zahrnují serializaci a deserializaci JSON, doporučujeme rozhraní API v [oboru názvů System. text. JSON](../../../standard/serialization/system-text-json-overview.md).</span><span class="sxs-lookup"><span data-stu-id="30528-104">For most scenarios that involve serializing and deserializing JSON, we recommend the APIs in the [System.Text.Json namespace](../../../standard/serialization/system-text-json-overview.md).</span></span>

<span data-ttu-id="30528-105">JSON (JavaScript Object Notation) je formát dat, který je speciálně navržený tak, aby se používal v kódu JavaScriptu běžícím na webových stránkách v prohlížeči.</span><span class="sxs-lookup"><span data-stu-id="30528-105">JSON (JavaScript Object Notation) is a data format that is specifically designed to be used by JavaScript code running on Web pages inside the browser.</span></span> <span data-ttu-id="30528-106">Je to výchozí formát dat používaný službami ASP.NET AJAX vytvořenými v Windows Communication Foundation (WCF).</span><span class="sxs-lookup"><span data-stu-id="30528-106">It is the default data format used by ASP.NET AJAX services created in Windows Communication Foundation (WCF).</span></span>

<span data-ttu-id="30528-107">Tento formát lze použít také při vytváření služeb AJAX bez integrace s ASP.NET – v tomto případě je XML výchozí, ale může být zvolena hodnota JSON.</span><span class="sxs-lookup"><span data-stu-id="30528-107">This format can also be used when creating AJAX services without integrating with ASP.NET - in this case, XML is the default but JSON can be chosen.</span></span>

<span data-ttu-id="30528-108">Nakonec, pokud požadujete podporu JSON, ale nevytváříte službu AJAX, <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> umožňuje přímo serializovat objekty .NET do dat JSON a deserializovat taková data zpátky do instancí typů .NET.</span><span class="sxs-lookup"><span data-stu-id="30528-108">Finally, if you require JSON support but are not creating an AJAX service, the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> makes it possible to directly serialize .NET objects into JSON data and to deserialize such data back into instances of .NET types.</span></span> <span data-ttu-id="30528-109">Popis toho, jak to provést, naleznete v tématu [How to: serializovat a deserializovat data JSON](../../../../docs/framework/wcf/feature-details/how-to-serialize-and-deserialize-json-data.md).</span><span class="sxs-lookup"><span data-stu-id="30528-109">For a description of how to do this, see [How to: Serialize and Deserialize JSON Data](../../../../docs/framework/wcf/feature-details/how-to-serialize-and-deserialize-json-data.md).</span></span>

<span data-ttu-id="30528-110">Při práci s JSON jsou podporovány stejné typy rozhraní .NET, s několika výjimkami, jak jsou podporovány v <xref:System.Runtime.Serialization.DataContractSerializer> .</span><span class="sxs-lookup"><span data-stu-id="30528-110">When working with JSON, the same .NET types are supported, with a few exceptions, as are supported by the <xref:System.Runtime.Serialization.DataContractSerializer>.</span></span> <span data-ttu-id="30528-111">Seznam podporovaných typů najdete v tématu [typy podporované serializátorem kontraktu dat](../../../../docs/framework/wcf/feature-details/types-supported-by-the-data-contract-serializer.md).</span><span class="sxs-lookup"><span data-stu-id="30528-111">For a list of the types supported, see [Types Supported by the Data Contract Serializer](../../../../docs/framework/wcf/feature-details/types-supported-by-the-data-contract-serializer.md).</span></span> <span data-ttu-id="30528-112">To zahrnuje většinu primitivních typů, většinu typů polí a kolekcí a také komplexní typy, které používají <xref:System.Runtime.Serialization.DataContractAttribute> a <xref:System.Runtime.Serialization.DataMemberAttribute> .</span><span class="sxs-lookup"><span data-stu-id="30528-112">This includes most primitive types, most array and collection types, as well as complex types that use the <xref:System.Runtime.Serialization.DataContractAttribute> and <xref:System.Runtime.Serialization.DataMemberAttribute>.</span></span>

## <a name="mapping-net-types-to-json-types"></a><span data-ttu-id="30528-113">Mapování typů .NET na typy JSON</span><span class="sxs-lookup"><span data-stu-id="30528-113">Mapping .NET types to JSON Types</span></span>

<span data-ttu-id="30528-114">Následující tabulka ukazuje korespondenci mezi typy rozhraní .NET a typy JSON/JavaScript, pokud jsou mapovány postupy serializace a deserializace.</span><span class="sxs-lookup"><span data-stu-id="30528-114">The following table shows the correspondence between .NET types and JSON/JavaScript types when mapped by serialization and deserialization procedures.</span></span>

|<span data-ttu-id="30528-115">Typy .NET</span><span class="sxs-lookup"><span data-stu-id="30528-115">.NET Types</span></span>|<span data-ttu-id="30528-116">JSON/JavaScript</span><span class="sxs-lookup"><span data-stu-id="30528-116">JSON/JavaScript</span></span>|<span data-ttu-id="30528-117">Poznámky</span><span class="sxs-lookup"><span data-stu-id="30528-117">Notes</span></span>|
|----------------|----------------------|-----------|
|<span data-ttu-id="30528-118">Všechny číselné typy, například <xref:System.Int32> <xref:System.Decimal> nebo<xref:System.Double></span><span class="sxs-lookup"><span data-stu-id="30528-118">All numeric types, for example <xref:System.Int32>, <xref:System.Decimal> or <xref:System.Double></span></span>|<span data-ttu-id="30528-119">Číslo</span><span class="sxs-lookup"><span data-stu-id="30528-119">Number</span></span>|<span data-ttu-id="30528-120">Speciální hodnoty jako `Double.NaN` , `Double.PositiveInfinity` a `Double.NegativeInfinity` nejsou podporovány a mají za následek neplatný formát JSON.</span><span class="sxs-lookup"><span data-stu-id="30528-120">Special values such as  `Double.NaN`, `Double.PositiveInfinity` and `Double.NegativeInfinity` are not supported and result in invalid JSON.</span></span>|
|<xref:System.Enum>|<span data-ttu-id="30528-121">Číslo</span><span class="sxs-lookup"><span data-stu-id="30528-121">Number</span></span>|<span data-ttu-id="30528-122">Viz část "výčty a JSON" dále v tomto tématu.</span><span class="sxs-lookup"><span data-stu-id="30528-122">See "Enumerations and JSON" later in this topic.</span></span>|
|<xref:System.Boolean>|<span data-ttu-id="30528-123">Logická hodnota</span><span class="sxs-lookup"><span data-stu-id="30528-123">Boolean</span></span>|--|
|<span data-ttu-id="30528-124"><xref:System.String>, <xref:System.Char></span><span class="sxs-lookup"><span data-stu-id="30528-124"><xref:System.String>, <xref:System.Char></span></span>|<span data-ttu-id="30528-125">Řetězec</span><span class="sxs-lookup"><span data-stu-id="30528-125">String</span></span>|--|
|<span data-ttu-id="30528-126"><xref:System.TimeSpan>, <xref:System.Guid>, <xref:System.Uri></span><span class="sxs-lookup"><span data-stu-id="30528-126"><xref:System.TimeSpan>, <xref:System.Guid>, <xref:System.Uri></span></span>|<span data-ttu-id="30528-127">Řetězec</span><span class="sxs-lookup"><span data-stu-id="30528-127">String</span></span>|<span data-ttu-id="30528-128">Formát těchto typů ve formátu JSON je stejný jako v jazyce XML (v podstatě se jedná o časový interval ve formátu ISO 8601 Duration, identifikátor GUID ve formátu "12345678-ABCD-ABCD-ABCD-1234567890AB" a identifikátor URI ve formě přirozeného řetězce, jako je " http://www.example.com ").</span><span class="sxs-lookup"><span data-stu-id="30528-128">The format of these types in JSON is the same as in XML (essentially, TimeSpan in the ISO 8601 Duration format, GUID in the "12345678-ABCD-ABCD-ABCD-1234567890AB" format and URI in its natural string form like "http://www.example.com").</span></span> <span data-ttu-id="30528-129">Podrobné informace najdete v tématu [referenční informace o schématu kontraktu dat](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md).</span><span class="sxs-lookup"><span data-stu-id="30528-129">For precise information, see [Data Contract Schema Reference](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md).</span></span>|
|<xref:System.Xml.XmlQualifiedName>|<span data-ttu-id="30528-130">Řetězec</span><span class="sxs-lookup"><span data-stu-id="30528-130">String</span></span>|<span data-ttu-id="30528-131">Formát je "název: obor názvů" (cokoli před první dvojtečkou je název).</span><span class="sxs-lookup"><span data-stu-id="30528-131">The format is "name:namespace" (anything before the first colon is the name).</span></span> <span data-ttu-id="30528-132">Název nebo obor názvů může chybět.</span><span class="sxs-lookup"><span data-stu-id="30528-132">Either the name or the namespace can be missing.</span></span> <span data-ttu-id="30528-133">Pokud obor názvů neexistuje, může být dvojtečka také vynechána.</span><span class="sxs-lookup"><span data-stu-id="30528-133">If there is no namespace the colon can be omitted as well.</span></span>|
|<span data-ttu-id="30528-134"><xref:System.Array>typu<xref:System.Byte></span><span class="sxs-lookup"><span data-stu-id="30528-134"><xref:System.Array> of type <xref:System.Byte></span></span>|<span data-ttu-id="30528-135">Pole čísel</span><span class="sxs-lookup"><span data-stu-id="30528-135">Array of numbers</span></span>|<span data-ttu-id="30528-136">Každé číslo představuje hodnotu jednoho bajtu.</span><span class="sxs-lookup"><span data-stu-id="30528-136">Each number represents the value of one byte.</span></span>|
|<xref:System.DateTime>|<span data-ttu-id="30528-137">DateTime nebo String</span><span class="sxs-lookup"><span data-stu-id="30528-137">DateTime or String</span></span>|<span data-ttu-id="30528-138">Viz data a časy a JSON později v tomto tématu.</span><span class="sxs-lookup"><span data-stu-id="30528-138">See Dates/Times and JSON later in this topic.</span></span>|
|<xref:System.DateTimeOffset>|<span data-ttu-id="30528-139">Komplexní typ</span><span class="sxs-lookup"><span data-stu-id="30528-139">Complex type</span></span>|<span data-ttu-id="30528-140">Viz data a časy a JSON později v tomto tématu.</span><span class="sxs-lookup"><span data-stu-id="30528-140">See Dates/Times and JSON later in this topic.</span></span>|
|<span data-ttu-id="30528-141">Typy XML a ADO.NET ( <xref:System.Xml.XmlElement> ,</span><span class="sxs-lookup"><span data-stu-id="30528-141">XML and ADO.NET types (<xref:System.Xml.XmlElement>,</span></span><br /><br /> <span data-ttu-id="30528-142"><xref:System.Xml.Linq.XElement>.</span><span class="sxs-lookup"><span data-stu-id="30528-142"><xref:System.Xml.Linq.XElement>.</span></span> <span data-ttu-id="30528-143">Pole <xref:System.Xml.XmlNode> ,</span><span class="sxs-lookup"><span data-stu-id="30528-143">Arrays of <xref:System.Xml.XmlNode>,</span></span><br /><br /> <span data-ttu-id="30528-144"><xref:System.Runtime.Serialization.ISerializable>,</span><span class="sxs-lookup"><span data-stu-id="30528-144"><xref:System.Runtime.Serialization.ISerializable>,</span></span><br /><br /> <span data-ttu-id="30528-145"><xref:System.Data.DataSet>).</span><span class="sxs-lookup"><span data-stu-id="30528-145"><xref:System.Data.DataSet>).</span></span>|<span data-ttu-id="30528-146">Řetězec</span><span class="sxs-lookup"><span data-stu-id="30528-146">String</span></span>|<span data-ttu-id="30528-147">Další informace najdete v části Typy XML a JSON tohoto tématu.</span><span class="sxs-lookup"><span data-stu-id="30528-147">See the XML Types and JSON section of this topic.</span></span>|
|<xref:System.DBNull>|<span data-ttu-id="30528-148">Prázdný komplexní typ</span><span class="sxs-lookup"><span data-stu-id="30528-148">Empty complex type</span></span>|--|
|<span data-ttu-id="30528-149">Kolekce, slovníky a pole</span><span class="sxs-lookup"><span data-stu-id="30528-149">Collections, dictionaries, and arrays</span></span>|<span data-ttu-id="30528-150">Pole</span><span class="sxs-lookup"><span data-stu-id="30528-150">Array</span></span>|<span data-ttu-id="30528-151">Viz část kolekce, slovníky a pole tohoto tématu.</span><span class="sxs-lookup"><span data-stu-id="30528-151">See the Collections, Dictionaries, and Arrays section of this topic.</span></span>|
|<span data-ttu-id="30528-152">Komplexní typy (s <xref:System.Runtime.Serialization.DataContractAttribute> použitím nebo <xref:System.SerializableAttribute> )</span><span class="sxs-lookup"><span data-stu-id="30528-152">Complex types (with the <xref:System.Runtime.Serialization.DataContractAttribute> or <xref:System.SerializableAttribute> applied)</span></span>|<span data-ttu-id="30528-153">Komplexní typ</span><span class="sxs-lookup"><span data-stu-id="30528-153">Complex type</span></span>|<span data-ttu-id="30528-154">Datové členy se stanou členy komplexního typu JavaScriptu.</span><span class="sxs-lookup"><span data-stu-id="30528-154">Data members become members of the JavaScript complex type.</span></span>|
|<span data-ttu-id="30528-155">Komplexní typy implementující <xref:System.Runtime.Serialization.ISerializable> rozhraní)</span><span class="sxs-lookup"><span data-stu-id="30528-155">Complex types implementing the <xref:System.Runtime.Serialization.ISerializable> interface)</span></span>|<span data-ttu-id="30528-156">Komplexní typ</span><span class="sxs-lookup"><span data-stu-id="30528-156">Complex type</span></span>|<span data-ttu-id="30528-157">Stejné jako u jiných složitých typů, ale některé <xref:System.Runtime.Serialization.ISerializable> typy nejsou podporované – Podívejte se na část podpora ISerializable v části Rozšířené informace v tomto tématu.</span><span class="sxs-lookup"><span data-stu-id="30528-157">Same as other complex types but some <xref:System.Runtime.Serialization.ISerializable> types are not supported – see the ISerializable Support part of the Advanced Information section of this topic.</span></span>|
|<span data-ttu-id="30528-158">`Null`hodnota pro libovolný typ</span><span class="sxs-lookup"><span data-stu-id="30528-158">`Null` value for any type</span></span>|<span data-ttu-id="30528-159">Null</span><span class="sxs-lookup"><span data-stu-id="30528-159">Null</span></span>|<span data-ttu-id="30528-160">Podporují se i typy hodnot s možnou hodnotou null a mapují se na JSON stejným způsobem jako typy hodnot, které nejsou null.</span><span class="sxs-lookup"><span data-stu-id="30528-160">Nullable value types are also supported and map to JSON in the same way as non-nullable value types.</span></span>|

### <a name="enumerations-and-json"></a><span data-ttu-id="30528-161">Výčty a JSON</span><span class="sxs-lookup"><span data-stu-id="30528-161">Enumerations and JSON</span></span>

<span data-ttu-id="30528-162">Hodnoty členů výčtu jsou považovány za čísla ve formátu JSON, což se liší od toho, jak se zpracovávají v kontraktech dat, kde jsou zahrnuty jako názvy členů.</span><span class="sxs-lookup"><span data-stu-id="30528-162">Enumeration member values are treated as numbers in JSON, which is different from how they are treated in data contracts, where they are included as member names.</span></span> <span data-ttu-id="30528-163">Další informace o zpracování kontraktu dat najdete v tématu [výčtové typy v kontraktech dat](../../../../docs/framework/wcf/feature-details/enumeration-types-in-data-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="30528-163">For more information about the data contract treatment, see [Enumeration Types in Data Contracts](../../../../docs/framework/wcf/feature-details/enumeration-types-in-data-contracts.md).</span></span>

- <span data-ttu-id="30528-164">Například pokud máte `public enum Color {red, green, blue, yellow, pink}` , serializace `yellow` vytvoří číslo 3, nikoli řetězec "Yellow".</span><span class="sxs-lookup"><span data-stu-id="30528-164">For example, if you have `public enum Color {red, green, blue, yellow, pink}`, serializing `yellow` produces the number 3 and not the string "yellow".</span></span>

- <span data-ttu-id="30528-165">Všichni `enum` Členové jsou serializovatelný.</span><span class="sxs-lookup"><span data-stu-id="30528-165">All `enum` members are serializable.</span></span> <span data-ttu-id="30528-166"><xref:System.Runtime.Serialization.EnumMemberAttribute>A <xref:System.NonSerializedAttribute> atributy jsou ignorovány, pokud jsou použity.</span><span class="sxs-lookup"><span data-stu-id="30528-166">The <xref:System.Runtime.Serialization.EnumMemberAttribute> and the <xref:System.NonSerializedAttribute> attributes are ignored if used.</span></span>

- <span data-ttu-id="30528-167">Je možné deserializovat neexistující `enum` hodnotu, například hodnotu 87 lze deserializovat do předchozího výčtu barev i v případě, že není definován žádný odpovídající název barvy.</span><span class="sxs-lookup"><span data-stu-id="30528-167">It is possible to deserialize a nonexistent `enum` value - for example, the value 87 can be deserialized into the previous Color enum even though there is no corresponding color name defined.</span></span>

- <span data-ttu-id="30528-168">Příznaky `enum` nejsou speciální a jsou ošetřeny stejným způsobem jako jiné `enum` .</span><span class="sxs-lookup"><span data-stu-id="30528-168">A flags `enum` is not special and is treated the same as any other `enum`.</span></span>

### <a name="datestimes-and-json"></a><span data-ttu-id="30528-169">Data a časy a JSON</span><span class="sxs-lookup"><span data-stu-id="30528-169">Dates/Times and JSON</span></span>

<span data-ttu-id="30528-170">Formát JSON přímo nepodporuje data a časy.</span><span class="sxs-lookup"><span data-stu-id="30528-170">The JSON format does not directly support dates and times.</span></span> <span data-ttu-id="30528-171">Jsou však velmi často používány a ASP.NET AJAX poskytuje speciální podporu pro tyto typy.</span><span class="sxs-lookup"><span data-stu-id="30528-171">However, they are very commonly used and ASP.NET AJAX provides special support for these types.</span></span> <span data-ttu-id="30528-172">Při použití proxy ASP.NET AJAX je <xref:System.DateTime> typ v .NET plně odpovídající `DateTime` typu v JavaScriptu.</span><span class="sxs-lookup"><span data-stu-id="30528-172">When using ASP.NET AJAX proxies, the <xref:System.DateTime> type in .NET fully corresponds to the `DateTime` type in JavaScript.</span></span>

- <span data-ttu-id="30528-173">Pokud nepoužíváte ASP.NET, <xref:System.DateTime> je typ reprezentován ve formátu JSON jako řetězec se speciálním formátem, který je popsán v části Rozšířené informace v tomto tématu.</span><span class="sxs-lookup"><span data-stu-id="30528-173">When not using ASP.NET, a <xref:System.DateTime> type is represented in JSON as a string with a special format that is described in the Advanced Information section of this topic.</span></span>

- <span data-ttu-id="30528-174"><xref:System.DateTimeOffset>je reprezentován ve formátu JSON jako komplexní typ: {"DateTime":d ateTime, "OffsetMinutes": offsetMinutes}.</span><span class="sxs-lookup"><span data-stu-id="30528-174"><xref:System.DateTimeOffset> is represented in JSON as a complex type: {"DateTime":dateTime,"OffsetMinutes":offsetMinutes}.</span></span> <span data-ttu-id="30528-175">`offsetMinutes`Členem je místní časový posun od střední hodnoty času (GMT), který se teď označuje jako koordinovaný světový čas (UTC), který je přidružený k umístění události zájmu.</span><span class="sxs-lookup"><span data-stu-id="30528-175">The `offsetMinutes` member is the local time offset from Greenwich Mean Time (GMT), also now referred to as Coordinated Universal Time (UTC), associated with the location of the event of interest.</span></span> <span data-ttu-id="30528-176">`dateTime`Člen představuje instanci v čase, kdy došlo k události zájmu (znovu se spustí `DateTime` v JavaScriptu, když se ASP.NET AJAX používá a řetězec, pokud není).</span><span class="sxs-lookup"><span data-stu-id="30528-176">The `dateTime` member represents the instance in time when the event of interest occurred (again, it becomes a `DateTime` in JavaScript when ASP.NET AJAX is in use and a string when it is not).</span></span> <span data-ttu-id="30528-177">Při serializaci `dateTime` je člen vždy serializován v GMT.</span><span class="sxs-lookup"><span data-stu-id="30528-177">On serialization, the `dateTime` member is always serialized in GMT.</span></span> <span data-ttu-id="30528-178">Takže pokud je to pro čas 3:00 až Praha, `dateTime` má časovou komponentu 8:00 a `offsetMinutes` je 300 (minus 300 minuty nebo 5 hodin od GMT).</span><span class="sxs-lookup"><span data-stu-id="30528-178">So, if describing 3:00 AM New York time, `dateTime` has a time component of 8:00 AM and `offsetMinutes` are 300 (minus 300 minutes or 5 hours from GMT).</span></span>

  > [!NOTE]
  > <span data-ttu-id="30528-179"><xref:System.DateTime>a <xref:System.DateTimeOffset> objekty, při serializaci do formátu JSON, zachovávají pouze informace na přesnost milisekund.</span><span class="sxs-lookup"><span data-stu-id="30528-179"><xref:System.DateTime> and <xref:System.DateTimeOffset> objects, when serialized to JSON, only preserve information to millisecond precision.</span></span> <span data-ttu-id="30528-180">Během serializace dojde ke ztrátě hodnot dílčích milisekund (mikro/nanosekunds).</span><span class="sxs-lookup"><span data-stu-id="30528-180">Sub-millisecond values (micro/nanoseconds) are lost during serialization.</span></span>

### <a name="xml-types-and-json"></a><span data-ttu-id="30528-181">Typy XML a JSON</span><span class="sxs-lookup"><span data-stu-id="30528-181">XML Types and JSON</span></span>

<span data-ttu-id="30528-182">Typy XML se stávají řetězcem JSON.</span><span class="sxs-lookup"><span data-stu-id="30528-182">XML types become JSON strings.</span></span>

- <span data-ttu-id="30528-183">Například pokud datový člen "q" typu XElement obsahuje \<abc/> , je JSON {"q": " \<abc/> "}.</span><span class="sxs-lookup"><span data-stu-id="30528-183">For example, if a data member "q" of type XElement contains \<abc/>, the JSON is {"q":"\<abc/>"}.</span></span>

- <span data-ttu-id="30528-184">Existují určitá zvláštní pravidla, která určují, jak je XML zabaleno. Další informace najdete v části Rozšířené informace dále v tomto tématu.</span><span class="sxs-lookup"><span data-stu-id="30528-184">There are some special rules that specify how XML is wrapped - for more information, see the Advanced Information section later in this topic.</span></span>

- <span data-ttu-id="30528-185">Pokud používáte ASP.NET AJAX a nechcete používat řetězce v JavaScriptu, ale chcete místo toho použít XML DOM, nastavte <xref:System.ServiceModel.Web.WebGetAttribute.ResponseFormat%2A> vlastnost na XML <xref:System.ServiceModel.Web.WebGetAttribute> nebo na <xref:System.ServiceModel.Web.WebInvokeAttribute.ResponseFormat%2A> vlastnost na XML v <xref:System.ServiceModel.Web.WebInvokeAttribute> .</span><span class="sxs-lookup"><span data-stu-id="30528-185">If you are using ASP.NET AJAX and do not want to use strings in the JavaScript, but want the XML DOM instead, set the <xref:System.ServiceModel.Web.WebGetAttribute.ResponseFormat%2A> property to XML on <xref:System.ServiceModel.Web.WebGetAttribute> or the <xref:System.ServiceModel.Web.WebInvokeAttribute.ResponseFormat%2A> property to XML on the <xref:System.ServiceModel.Web.WebInvokeAttribute>.</span></span>

### <a name="collections-dictionaries-and-arrays"></a><span data-ttu-id="30528-186">Kolekce, slovníky a pole</span><span class="sxs-lookup"><span data-stu-id="30528-186">Collections, Dictionaries and Arrays</span></span>

<span data-ttu-id="30528-187">Všechny kolekce, slovníky a pole jsou ve formátu JSON vyjádřené jako pole.</span><span class="sxs-lookup"><span data-stu-id="30528-187">All collections, dictionaries, and arrays are represented in JSON as arrays.</span></span>

- <span data-ttu-id="30528-188">Jakékoli vlastní nastavení, které používá, <xref:System.Runtime.Serialization.CollectionDataContractAttribute> se ignoruje v reprezentaci JSON.</span><span class="sxs-lookup"><span data-stu-id="30528-188">Any customization that uses the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> is ignored in the JSON representation.</span></span>

- <span data-ttu-id="30528-189">Slovníky nejsou způsobem, jak pracovat přímo s JSON.</span><span class="sxs-lookup"><span data-stu-id="30528-189">Dictionaries are not a way to work directly with JSON.</span></span> <span data-ttu-id="30528-190">Slovník \<string,object> nemusí být podporován stejným způsobem ve službě WCF podle očekávání od práce s jinými technologiemi JSON.</span><span class="sxs-lookup"><span data-stu-id="30528-190">Dictionary\<string,object> may not be supported in the same way in WCF as expected from working with other JSON technologies.</span></span> <span data-ttu-id="30528-191">Například pokud je "ABC" mapován na "xyz" a "def", ve slovníku se namapuje na 42, reprezentace JSON není {"ABC": "xyz", "def": 42}, ale jedná se o [{"klíč": "ABC", "value": "xyz"}, {"Key": "def", "value": 42}] namísto.</span><span class="sxs-lookup"><span data-stu-id="30528-191">For example, if "abc" is mapped to "xyz" and "def" is mapped to 42 in a dictionary, the JSON representation is not {"abc":"xyz","def":42} but is [{"Key":"abc","Value":"xyz"},{"Key":"def","Value":42}] instead.</span></span>

- <span data-ttu-id="30528-192">Pokud chcete pracovat s JSON přímo (dynamicky přistupovat k klíčům a hodnotám, aniž byste museli předem definovat pevný kontrakt), máte několik možností:</span><span class="sxs-lookup"><span data-stu-id="30528-192">If you would like to work with JSON directly (accessing keys and values dynamically, without pre-defining a rigid contract), you have several options:</span></span>

  - <span data-ttu-id="30528-193">Zvažte použití ukázky [Neslabě typovaného serializace JSON (AJAX)](../../../../docs/framework/wcf/samples/weakly-typed-json-serialization-sample.md) .</span><span class="sxs-lookup"><span data-stu-id="30528-193">Consider using the [Weakly-typed JSON Serialization (AJAX)](../../../../docs/framework/wcf/samples/weakly-typed-json-serialization-sample.md) sample.</span></span>

  - <span data-ttu-id="30528-194">Zvažte použití <xref:System.Runtime.Serialization.ISerializable> konstruktorů rozhraní a deserializace – tyto dva mechanismy vám umožní přístup k párů klíč/hodnota JSON na serializaci a deserializaci, ale nefungují v scénářích s částečnou důvěryhodností.</span><span class="sxs-lookup"><span data-stu-id="30528-194">Consider using the <xref:System.Runtime.Serialization.ISerializable> interface and deserialization constructors - these two mechanisms allow you to access JSON key/value pairs on serialization and deserialization respectively, but do not work in partial trust scenarios.</span></span>

  - <span data-ttu-id="30528-195">Zvažte práci s [mapováním mezi JSON a XML](../../../../docs/framework/wcf/feature-details/mapping-between-json-and-xml.md) namísto použití serializátoru.</span><span class="sxs-lookup"><span data-stu-id="30528-195">Consider working with the [Mapping Between JSON and XML](../../../../docs/framework/wcf/feature-details/mapping-between-json-and-xml.md) instead of using a serializer.</span></span>

  - <span data-ttu-id="30528-196">*Polymorfismus* v kontextu serializace odkazuje na schopnost serializovat odvozený typ, kde je očekáván jeho základní typ.</span><span class="sxs-lookup"><span data-stu-id="30528-196">*Polymorphism* in the context of serialization refers to the ability to serialize a derived type where its base type is expected.</span></span> <span data-ttu-id="30528-197">Existují zvláštní pravidla specifická pro JSON při použití kolekcí polymorfní, kdy například přiřadíte kolekci k <xref:System.Object> .</span><span class="sxs-lookup"><span data-stu-id="30528-197">There are special JSON-specific rules when using collections polymorphically, when, for example, assigning a collection to an <xref:System.Object>.</span></span> <span data-ttu-id="30528-198">Tento problém je podrobněji popsán v části Rozšířené informace dále v tomto tématu.</span><span class="sxs-lookup"><span data-stu-id="30528-198">This issue is more fully discussed in the Advanced Information section later in this topic.</span></span>

## <a name="additional-details"></a><span data-ttu-id="30528-199">Další podrobnosti</span><span class="sxs-lookup"><span data-stu-id="30528-199">Additional Details</span></span>

### <a name="order-of-data-members"></a><span data-ttu-id="30528-200">Pořadí datových členů</span><span class="sxs-lookup"><span data-stu-id="30528-200">Order of Data Members</span></span>

<span data-ttu-id="30528-201">Pořadí datových členů není při použití JSON důležité.</span><span class="sxs-lookup"><span data-stu-id="30528-201">Order of data members is not important when using JSON.</span></span> <span data-ttu-id="30528-202">Konkrétně i v případě <xref:System.Runtime.Serialization.DataMemberAttribute.Order%2A> , že je nastavená, můžete data JSON dál deserializovat v libovolném pořadí.</span><span class="sxs-lookup"><span data-stu-id="30528-202">Specifically, even if <xref:System.Runtime.Serialization.DataMemberAttribute.Order%2A> is set, JSON data can still be deserialized in any order.</span></span>

### <a name="json-types"></a><span data-ttu-id="30528-203">Typy JSON</span><span class="sxs-lookup"><span data-stu-id="30528-203">JSON Types</span></span>

<span data-ttu-id="30528-204">Typ JSON nemusí odpovídat předchozí tabulce v deserializaci.</span><span class="sxs-lookup"><span data-stu-id="30528-204">The JSON type does not have to match the preceding table on deserialization.</span></span> <span data-ttu-id="30528-205">Například `Int` obvykle se mapuje na číslo JSON, ale lze jej také úspěšně deserializovat z řetězce JSON, pokud tento řetězec obsahuje platné číslo.</span><span class="sxs-lookup"><span data-stu-id="30528-205">For example, an `Int` normally maps to a JSON number, but it can also be successfully deserialized from a JSON string as long as that string contains a valid number.</span></span> <span data-ttu-id="30528-206">To znamená, že obě {"q": 42} a {"q": "42"} jsou platné, pokud existuje `Int` datový člen s názvem "q".</span><span class="sxs-lookup"><span data-stu-id="30528-206">That is, both {"q":42} and {"q":"42"} are valid if there is an `Int` data member called "q".</span></span>

### <a name="polymorphism"></a><span data-ttu-id="30528-207">Polymorfismus</span><span class="sxs-lookup"><span data-stu-id="30528-207">Polymorphism</span></span>

<span data-ttu-id="30528-208">Polymorfní serializace je tvořena možností serializace odvozeného typu, kde je očekáván jeho základní typ.</span><span class="sxs-lookup"><span data-stu-id="30528-208">Polymorphic serialization consists of the ability to serialize a derived type where its base type is expected.</span></span> <span data-ttu-id="30528-209">To je podporováno pro serializaci JSON pomocí WCF srovnatelné se způsobem, jakým je podporována serializace XML.</span><span class="sxs-lookup"><span data-stu-id="30528-209">This is supported for JSON serialization by WCF comparable to the way XML serialization is supported.</span></span> <span data-ttu-id="30528-210">Například můžete serializovat `MyDerivedType` `MyBaseType` , kde je očekáváno, kde je očekáváno, kde `Int` `Object` je očekáváno, kde je očekáváno.</span><span class="sxs-lookup"><span data-stu-id="30528-210">For example, you can serialize `MyDerivedType` where `MyBaseType` is expected, or serialize `Int` where `Object` is expected.</span></span>

<span data-ttu-id="30528-211">Při deserializaci odvozeného typu může dojít ke ztrátě informací o typu, pokud se očekává základní typ, pokud neprovádíte deserializaci komplexního typu.</span><span class="sxs-lookup"><span data-stu-id="30528-211">Type information may be lost when deserializing a derived type if the base type is expected, unless you are deserializing a complex type.</span></span> <span data-ttu-id="30528-212">Například pokud <xref:System.Uri> je serializován <xref:System.Object> , kde je očekáváno, je výsledkem řetězec JSON.</span><span class="sxs-lookup"><span data-stu-id="30528-212">For example, if <xref:System.Uri> is serialized where <xref:System.Object> is expected, it results in a JSON string.</span></span> <span data-ttu-id="30528-213">Pokud je tento řetězec následně deserializován zpět do <xref:System.Object> , <xref:System.String> je vrácena technologie .NET.</span><span class="sxs-lookup"><span data-stu-id="30528-213">If this string is then deserialized back into <xref:System.Object>, a .NET <xref:System.String> is returned.</span></span> <span data-ttu-id="30528-214">Deserializátor neví, že řetězec byl původně typu <xref:System.Uri> .</span><span class="sxs-lookup"><span data-stu-id="30528-214">The deserializer does not know that the string was initially of type <xref:System.Uri>.</span></span> <span data-ttu-id="30528-215">Obecně, pokud je očekáváno <xref:System.Object> , všechny řetězce JSON jsou deserializovány jako řetězce .NET a všechna pole JSON používaná k serializaci kolekcí .NET, slovníky a pole jsou deserializovány jako rozhraní .NET <xref:System.Array> typu <xref:System.Object> bez ohledu na to, co byl skutečný původní typ.</span><span class="sxs-lookup"><span data-stu-id="30528-215">Generally, when expecting <xref:System.Object>, all JSON strings are deserialized as .NET strings, and all JSON arrays used to serialize .NET collections, dictionaries, and arrays are deserialized as .NET <xref:System.Array> of type <xref:System.Object>, regardless of what the actual original type had been.</span></span> <span data-ttu-id="30528-216">Logická hodnota JSON se mapuje na rozhraní .NET <xref:System.Boolean> .</span><span class="sxs-lookup"><span data-stu-id="30528-216">A JSON boolean maps to a .NET <xref:System.Boolean>.</span></span> <span data-ttu-id="30528-217">Pokud však očekáváte <xref:System.Object> , jsou deserializována čísla JSON buď jako rozhraní .NET <xref:System.Int32> , <xref:System.Decimal> nebo <xref:System.Double> , kde je nejvhodnější typ automaticky vybrán.</span><span class="sxs-lookup"><span data-stu-id="30528-217">However when expecting an <xref:System.Object>, JSON numbers are deserialized as either .NET <xref:System.Int32>, <xref:System.Decimal> or <xref:System.Double>, where the most appropriate type is automatically picked.</span></span>

<span data-ttu-id="30528-218">Při deserializaci do typu rozhraní jsou <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> deserializace, jako by byl deklarovaný typ Object.</span><span class="sxs-lookup"><span data-stu-id="30528-218">When deserializing into an interface type, the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> deserializes as if the declared type were object.</span></span>

<span data-ttu-id="30528-219">Při práci s vlastními základními a odvozenými typy použijte <xref:System.Runtime.Serialization.KnownTypeAttribute> <xref:System.ServiceModel.ServiceKnownTypeAttribute> nebo je obvykle vyžadován ekvivalentní mechanismus.</span><span class="sxs-lookup"><span data-stu-id="30528-219">When working with your own base and derived types, using the <xref:System.Runtime.Serialization.KnownTypeAttribute>, <xref:System.ServiceModel.ServiceKnownTypeAttribute> or an equivalent mechanism is normally required.</span></span> <span data-ttu-id="30528-220">Například pokud máte operaci, která má `Animal` návratovou hodnotu a ve skutečnosti vrátí instanci `Cat` (odvozenou od `Animal` ), měli byste buď použít <xref:System.Runtime.Serialization.KnownTypeAttribute> , na `Animal` typ nebo na <xref:System.ServiceModel.ServiceKnownTypeAttribute> operaci a zadat `Cat` typ v těchto atributech.</span><span class="sxs-lookup"><span data-stu-id="30528-220">For example, if you have an operation that has an `Animal` return value and it actually returns an instance of `Cat` (derived from `Animal`), you should either apply the <xref:System.Runtime.Serialization.KnownTypeAttribute>, to the `Animal` type or the <xref:System.ServiceModel.ServiceKnownTypeAttribute> to the operation and specify the `Cat` type in these attributes.</span></span> <span data-ttu-id="30528-221">Další informace najdete v tématu [známé typy kontraktu dat](../../../../docs/framework/wcf/feature-details/data-contract-known-types.md).</span><span class="sxs-lookup"><span data-stu-id="30528-221">For more information, see [Data Contract Known Types](../../../../docs/framework/wcf/feature-details/data-contract-known-types.md).</span></span>

<span data-ttu-id="30528-222">Podrobnosti o tom, jak polymorfní serializace funguje a diskuzi o některých omezeních, která musí být při použití dodržena, najdete v části Rozšířené informace dále v tomto tématu.</span><span class="sxs-lookup"><span data-stu-id="30528-222">For details of how polymorphic serialization works and a discussion of some of the limitations that must be respected when using it, see the Advanced Information section later in this topic.</span></span>

### <a name="versioning"></a><span data-ttu-id="30528-223">Správa verzí</span><span class="sxs-lookup"><span data-stu-id="30528-223">Versioning</span></span>

<span data-ttu-id="30528-224">Funkce pro správu verzí kontraktů dat, včetně <xref:System.Runtime.Serialization.IExtensibleDataObject> rozhraní, jsou ve formátu JSON plně podporované.</span><span class="sxs-lookup"><span data-stu-id="30528-224">The data contract versioning features, including the <xref:System.Runtime.Serialization.IExtensibleDataObject> interface, are fully supported in JSON.</span></span> <span data-ttu-id="30528-225">Ve většině případů je také možné deserializovat typ v jednom formátu (například XML) a potom jej serializovat do jiného formátu (například JSON) a zachovat data v <xref:System.Runtime.Serialization.IExtensibleDataObject> .</span><span class="sxs-lookup"><span data-stu-id="30528-225">Furthermore, in most cases it is possible to deserialize a type in one format (for example, XML) and then serialize it into another format (for example, JSON) and still preserve the data in <xref:System.Runtime.Serialization.IExtensibleDataObject>.</span></span> <span data-ttu-id="30528-226">Další informace najdete v tématu [kontrakty dat kompatibilní s dopředné](../../../../docs/framework/wcf/feature-details/forward-compatible-data-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="30528-226">For more information, see [Forward-Compatible Data Contracts](../../../../docs/framework/wcf/feature-details/forward-compatible-data-contracts.md).</span></span> <span data-ttu-id="30528-227">Mějte na paměti, že kód JSON je Neseřazený, takže dojde ke ztrátě informací o objednávkách.</span><span class="sxs-lookup"><span data-stu-id="30528-227">Remember that JSON is unordered so any order information is lost.</span></span> <span data-ttu-id="30528-228">Kromě toho JSON nepodporuje více párů klíč/hodnota se stejným názvem klíče.</span><span class="sxs-lookup"><span data-stu-id="30528-228">Furthermore, JSON does not support multiple key/value pairs with the same key name.</span></span> <span data-ttu-id="30528-229">Nakonec všechny operace na <xref:System.Runtime.Serialization.IExtensibleDataObject> jsou ve své podstatě polymorfní – to je jejich odvozený typ, který je přiřazený k <xref:System.Object> základnímu typu pro všechny typy.</span><span class="sxs-lookup"><span data-stu-id="30528-229">Finally, all operations on <xref:System.Runtime.Serialization.IExtensibleDataObject> are inherently polymorphic - that is their derived type are assigned to <xref:System.Object>, the base type for all types.</span></span>

## <a name="json-in-urls"></a><span data-ttu-id="30528-230">JSON v adresách URL</span><span class="sxs-lookup"><span data-stu-id="30528-230">JSON in URLs</span></span>

<span data-ttu-id="30528-231">Při použití koncových bodů ASP.NET AJAX s příkazem HTTP GET (s <xref:System.ServiceModel.Web.WebGetAttribute> atributem) se příchozí parametry zobrazí v adrese URL namísto textu zprávy.</span><span class="sxs-lookup"><span data-stu-id="30528-231">When using ASP.NET AJAX endpoints with the HTTP GET verb (using the <xref:System.ServiceModel.Web.WebGetAttribute> attribute), incoming parameters appear in the request URL instead of the message body.</span></span> <span data-ttu-id="30528-232">JSON se podporuje i v adrese URL požadavku, takže pokud máte operaci, která přebírá `Int` "číslo" a `Person` komplexní typ s názvem "p", adresa URL může vypadat jako následující adresa URL.</span><span class="sxs-lookup"><span data-stu-id="30528-232">JSON is supported even in the request URL, so if you have an operation that takes an `Int` called "number" and a `Person` complex type called "p", the URL may resemble the following URL.</span></span>

```html
http://example.com/myservice.svc/MyOperation?number=7&p={"name":"John","age":42}
```

<span data-ttu-id="30528-233">Pokud ke volání služby používáte ovládací prvek Správce skriptů ASP.NET AJAX a proxy server, tato adresa URL se automaticky vygeneruje proxy serverem a nezobrazuje se.</span><span class="sxs-lookup"><span data-stu-id="30528-233">If you are using an ASP.NET AJAX Script Manager control and proxy to call the service, this URL is automatically generated by the proxy and is not seen.</span></span> <span data-ttu-id="30528-234">JSON se nedá použít v adresách URL v koncových bodech non-ASP.NET AJAX.</span><span class="sxs-lookup"><span data-stu-id="30528-234">JSON cannot be used in URLs on non-ASP.NET AJAX endpoints.</span></span>

## <a name="advanced-information"></a><span data-ttu-id="30528-235">Rozšířené informace</span><span class="sxs-lookup"><span data-stu-id="30528-235">Advanced information</span></span>

### <a name="iserializable-support"></a><span data-ttu-id="30528-236">Podpora ISerializable</span><span class="sxs-lookup"><span data-stu-id="30528-236">ISerializable Support</span></span>

#### <a name="supported-and-unsupported-iserializable-types"></a><span data-ttu-id="30528-237">Podporované a nepodporované typy ISerializable</span><span class="sxs-lookup"><span data-stu-id="30528-237">Supported and Unsupported ISerializable Types</span></span>

<span data-ttu-id="30528-238">Obecně platí, že typy, které implementují <xref:System.Runtime.Serialization.ISerializable> rozhraní, jsou plně podporované při serializaci nebo deserializaci JSON.</span><span class="sxs-lookup"><span data-stu-id="30528-238">In general, types that implement the <xref:System.Runtime.Serialization.ISerializable> interface are fully supported when serializing/deserializing JSON.</span></span> <span data-ttu-id="30528-239">Nicméně některé z těchto typů (včetně některých typů .NET Framework) jsou implementovány takovým způsobem, že aspekty serializace specifické pro JSON způsobují, že nejsou správně deserializovat:</span><span class="sxs-lookup"><span data-stu-id="30528-239">However, some of these types (including some .NET Framework types) are implemented in such a way that the JSON-specific serialization aspects cause them to not deserialize correctly:</span></span>

- <span data-ttu-id="30528-240">V systému se <xref:System.Runtime.Serialization.ISerializable> typ jednotlivých datových členů nikdy neoznačuje jako předem.</span><span class="sxs-lookup"><span data-stu-id="30528-240">With <xref:System.Runtime.Serialization.ISerializable>, the type of individual data members is never known in advance.</span></span> <span data-ttu-id="30528-241">To vede k polymorfní situaci, která je podobná deserializaci typů do objektu.</span><span class="sxs-lookup"><span data-stu-id="30528-241">This leads to a polymorphic situation similar to deserializing types into an object.</span></span> <span data-ttu-id="30528-242">Jak bylo zmíněno dříve, může to vést ke ztrátě informací o typu ve formátu JSON.</span><span class="sxs-lookup"><span data-stu-id="30528-242">As mentioned before, this may lead to loss of type information in JSON.</span></span> <span data-ttu-id="30528-243">Například typ, který serializace `enum` v jeho <xref:System.Runtime.Serialization.ISerializable> implementaci a pokusí se o deserializaci přímo do `enum` (bez správných přetypování), se nezdařil, protože `enum` je serializovaná pomocí čísel JSON a JSON čísla deserializována do předdefinovaných číselných typů .NET (Int32, Decimal nebo Double).</span><span class="sxs-lookup"><span data-stu-id="30528-243">For example, a type that serializes an `enum` in its <xref:System.Runtime.Serialization.ISerializable> implementation and attempts to deserialize back directly into an `enum` (without proper casts) fails, because an `enum` is serialized using numbers in JSON and JSON numbers deserialize into built-in .NET numeric types (Int32, Decimal or Double).</span></span> <span data-ttu-id="30528-244">Fakt, že číslo použité k `enum` hodnotě je ztraceno.</span><span class="sxs-lookup"><span data-stu-id="30528-244">So the fact that the number used to be an `enum` value is lost.</span></span>

- <span data-ttu-id="30528-245"><xref:System.Runtime.Serialization.ISerializable>Typ, který závisí na určitém pořadí deserializace v jeho konstruktoru deserializace, může také dojít k chybě při deserializaci některých dat JSON, protože většina serializátorů JSON nezaručuje konkrétní pořadí.</span><span class="sxs-lookup"><span data-stu-id="30528-245">An <xref:System.Runtime.Serialization.ISerializable> type that depends on a particular order of deserialization in its deserialization constructor may also fail to deserialize some JSON data, because most JSON serializers do not guarantee any specific order.</span></span>

#### <a name="factory-types"></a><span data-ttu-id="30528-246">Typy továrny</span><span class="sxs-lookup"><span data-stu-id="30528-246">Factory Types</span></span>

<span data-ttu-id="30528-247">I když <xref:System.Runtime.Serialization.IObjectReference> je rozhraní ve formátu JSON podporováno obecně, všechny typy, které vyžadují funkci "typ objektu pro vytváření" (vracející instance jiného typu <xref:System.Runtime.Serialization.IObjectReference.GetRealObject%28System.Runtime.Serialization.StreamingContext%29> než typ, který implementuje rozhraní), nejsou podporovány.</span><span class="sxs-lookup"><span data-stu-id="30528-247">While the <xref:System.Runtime.Serialization.IObjectReference> interface is supported in JSON in general, any types that require the "factory type" feature (returning an instance of a different type from <xref:System.Runtime.Serialization.IObjectReference.GetRealObject%28System.Runtime.Serialization.StreamingContext%29> than the type that implements the interface) are not supported.</span></span>

### <a name="datetime-wire-format"></a><span data-ttu-id="30528-248">Formát vedení data a času</span><span class="sxs-lookup"><span data-stu-id="30528-248">DateTime Wire Format</span></span>

<span data-ttu-id="30528-249"><xref:System.DateTime>hodnoty se zobrazí jako řetězce JSON ve formátu "/Date (700000 + 0500)/", kde první číslo (700000 v zadaném příkladu) je počet milisekund v časovém pásmu GMT, běžný (neletní) čas od půlnoci 1. ledna 1970.</span><span class="sxs-lookup"><span data-stu-id="30528-249"><xref:System.DateTime> values appear as JSON strings in the form of "/Date(700000+0500)/", where the first number (700000 in the example provided) is the number of milliseconds in the GMT time zone, regular (non-daylight savings) time since midnight, January 1, 1970.</span></span> <span data-ttu-id="30528-250">Počet může být záporný, aby představoval předchozí časy.</span><span class="sxs-lookup"><span data-stu-id="30528-250">The number may be negative to represent earlier times.</span></span> <span data-ttu-id="30528-251">Část, která se skládá z "+ 0500" v příkladu je volitelná a označuje, že doba je <xref:System.DateTimeKind.Local> typu – to znamená, že by mělo být převedeno na místní časové pásmo Při deserializaci.</span><span class="sxs-lookup"><span data-stu-id="30528-251">The part that consists of "+0500" in the example is optional and indicates that the time is of the <xref:System.DateTimeKind.Local> kind - that is, should be converted to the local time zone on deserialization.</span></span> <span data-ttu-id="30528-252">Pokud chybí, čas je deserializován jako <xref:System.DateTimeKind.Utc> .</span><span class="sxs-lookup"><span data-stu-id="30528-252">If it is absent, the time is deserialized as <xref:System.DateTimeKind.Utc>.</span></span> <span data-ttu-id="30528-253">Skutečný počet ("0500" v tomto příkladu) a jeho znaménko (+ nebo-) se ignorují.</span><span class="sxs-lookup"><span data-stu-id="30528-253">The actual number ("0500" in this example) and its sign (+ or -) are ignored.</span></span>

<span data-ttu-id="30528-254">Při serializaci <xref:System.DateTime> <xref:System.DateTimeKind.Local> a <xref:System.DateTimeKind.Unspecified> časy jsou zapisovány s posunem a jsou <xref:System.DateTimeKind.Utc> zapsány bez.</span><span class="sxs-lookup"><span data-stu-id="30528-254">When serializing <xref:System.DateTime>, <xref:System.DateTimeKind.Local> and <xref:System.DateTimeKind.Unspecified> times are written with an offset, and <xref:System.DateTimeKind.Utc> is written without.</span></span>

<span data-ttu-id="30528-255">Kód JavaScriptu klienta ASP.NET AJAX tyto řetězce automaticky převede na instance JavaScriptu `DateTime` .</span><span class="sxs-lookup"><span data-stu-id="30528-255">The ASP.NET AJAX client JavaScript code automatically converts such strings into JavaScript `DateTime` instances.</span></span> <span data-ttu-id="30528-256">Pokud existují další řetězce, které mají podobný tvar, který není typu <xref:System.DateTime> v rozhraní .NET, jsou převedeny také.</span><span class="sxs-lookup"><span data-stu-id="30528-256">If there are other strings that have a similar form that are not of type <xref:System.DateTime> in .NET, they are converted as well.</span></span>

<span data-ttu-id="30528-257">Převod probíhá pouze v případě, že znaky "/" jsou uvozeny řídicím znakem (to znamená, že JSON vypadá jako " \\ /Date (700000 + 0500) \\ /") a z tohoto důvodu se vždy označí jako kodér JSON služby WCF (povolený <xref:System.ServiceModel.WebHttpBinding> ) znak "/".</span><span class="sxs-lookup"><span data-stu-id="30528-257">The conversion only takes place if the "/" characters are escaped (that is, the JSON looks like "\\/Date(700000+0500)\\/"), and for this reason WCF's JSON encoder (enabled by the <xref:System.ServiceModel.WebHttpBinding>) always escapes the "/" character.</span></span>

### <a name="xml-in-json-strings"></a><span data-ttu-id="30528-258">XML v řetězcích JSON</span><span class="sxs-lookup"><span data-stu-id="30528-258">XML in JSON Strings</span></span>

#### <a name="xmlelement"></a><span data-ttu-id="30528-259">Třída</span><span class="sxs-lookup"><span data-stu-id="30528-259">XmlElement</span></span>

<span data-ttu-id="30528-260"><xref:System.Xml.XmlElement>je serializován tak, jak je, bez zabalení.</span><span class="sxs-lookup"><span data-stu-id="30528-260"><xref:System.Xml.XmlElement> is serialized as is, with no wrapping.</span></span> <span data-ttu-id="30528-261">Například datový člen "x" typu <xref:System.Xml.XmlElement> , který obsahuje, \<abc/> je reprezentován následujícím způsobem:</span><span class="sxs-lookup"><span data-stu-id="30528-261">For example, data member "x" of type <xref:System.Xml.XmlElement> that contains \<abc/> is represented as follows:</span></span>

```json
{"x":"<abc/>"}
```

#### <a name="arrays-of-xmlnode"></a><span data-ttu-id="30528-262">Pole XmlNode</span><span class="sxs-lookup"><span data-stu-id="30528-262">Arrays of XmlNode</span></span>

<span data-ttu-id="30528-263"><xref:System.Array>objekty typu <xref:System.Xml.XmlNode> jsou zabaleny do elementu s názvem ArrayOfXmlNode v oboru názvů kontraktu Standard data pro daný typ.</span><span class="sxs-lookup"><span data-stu-id="30528-263"><xref:System.Array> objects of type <xref:System.Xml.XmlNode> are wrapped in an element called ArrayOfXmlNode in the standard data contract namespace for the type.</span></span> <span data-ttu-id="30528-264">Pokud "x" je pole, které obsahuje uzel atributu "N" v oboru názvů "NS", který obsahuje "value" a prázdný uzel elementu "M", reprezentace je následující.</span><span class="sxs-lookup"><span data-stu-id="30528-264">If "x" is an array that contains attribute node "N" in namespace "ns" that contains "value" and an empty element node "M", the representation is as follows.</span></span>

```json
{"x":"<ArrayOfXmlNode xmlns=\"http://schemas.datacontract.org/2004/07/System.Xml\" a:N=\"value\" xmlns:a=\"ns\"><M/></ArrayOfXmlNode>"}
```

 <span data-ttu-id="30528-265">Atributy v prázdném oboru názvů na začátku polí XmlNode (před jinými prvky) nejsou podporovány.</span><span class="sxs-lookup"><span data-stu-id="30528-265">Attributes in the empty namespace at the beginning of XmlNode arrays (before other elements) are unsupported.</span></span>

#### <a name="ixmlserializable-types-including-xelement-and-dataset"></a><span data-ttu-id="30528-266">Typy IXmlSerializable včetně XElement a DataSet</span><span class="sxs-lookup"><span data-stu-id="30528-266">IXmlSerializable Types including XElement and DataSet</span></span>

<span data-ttu-id="30528-267"><xref:System.Runtime.Serialization.ISerializable>typy se rozdělují na typy obsahu, datové sady a typy prvků.</span><span class="sxs-lookup"><span data-stu-id="30528-267"><xref:System.Runtime.Serialization.ISerializable> types subdivide into "content types", "DataSet types" and "element types".</span></span> <span data-ttu-id="30528-268">Definice těchto typů naleznete [v tématu Typy XML a ADO.NET v kontraktech dat](../../../../docs/framework/wcf/feature-details/xml-and-ado-net-types-in-data-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="30528-268">For definitions of these types, see [XML and ADO.NET Types in Data Contracts](../../../../docs/framework/wcf/feature-details/xml-and-ado-net-types-in-data-contracts.md).</span></span>

<span data-ttu-id="30528-269">Typy "obsah" a "DataSet" jsou serializovány podobně jako <xref:System.Array> objekty <xref:System.Xml.XmlNode> popsané v předchozí části.</span><span class="sxs-lookup"><span data-stu-id="30528-269">"Content" and "DataSet" types are serialized similar to <xref:System.Array> objects of <xref:System.Xml.XmlNode> discussed in the previous section.</span></span> <span data-ttu-id="30528-270">Jsou zabaleny do elementu, jehož název a obor názvů odpovídají názvu kontraktu dat a oboru názvů příslušného typu.</span><span class="sxs-lookup"><span data-stu-id="30528-270">They are wrapped in an element whose name and namespace corresponds to the data contract name and namespace of the type in question.</span></span>

<span data-ttu-id="30528-271">Typy "element", jako <xref:System.Xml.Linq.XElement> je například, jsou serializovány tak, jak je <xref:System.Xml.XmlElement> uvedeno dříve v tomto tématu.</span><span class="sxs-lookup"><span data-stu-id="30528-271">"Element" types such as <xref:System.Xml.Linq.XElement> are serialized as is, similar to <xref:System.Xml.XmlElement> previously discussed in this topic.</span></span>

### <a name="polymorphism"></a><span data-ttu-id="30528-272">Polymorfismus</span><span class="sxs-lookup"><span data-stu-id="30528-272">Polymorphism</span></span>

#### <a name="preserving-type-information"></a><span data-ttu-id="30528-273">Zachování informací o typu</span><span class="sxs-lookup"><span data-stu-id="30528-273">Preserving Type Information</span></span>

<span data-ttu-id="30528-274">Jak bylo uvedeno dříve, polymorfismus je ve formátu JSON podporována s některými omezeními.</span><span class="sxs-lookup"><span data-stu-id="30528-274">As stated earlier, polymorphism is supported in JSON with some limitations.</span></span> <span data-ttu-id="30528-275">Jazyk JavaScript je nebezpečným jazykem a identita typu obvykle není problémem.</span><span class="sxs-lookup"><span data-stu-id="30528-275">JavaScript is a weakly-typed language and type identity is normally not an issue.</span></span> <span data-ttu-id="30528-276">Pokud ale používáte JSON ke komunikaci mezi systémem silného typu (.NET) a systémem slabě typovaného systému (JavaScript), je vhodné zachovat identitu typu.</span><span class="sxs-lookup"><span data-stu-id="30528-276">However, when using JSON to communicate between a strongly typed system (.NET) and a weakly-typed system (JavaScript), it is useful to preserve type identity.</span></span> <span data-ttu-id="30528-277">Například typy s názvy kontraktů dat "čtvercový" a "Circle" jsou odvozeny z typu s názvem kontraktu dat "tvar".</span><span class="sxs-lookup"><span data-stu-id="30528-277">For example, types with data contract names "Square" and "Circle" derive from a type with a data contract name of "Shape".</span></span> <span data-ttu-id="30528-278">Pokud je "kruh" odesílán z rozhraní .NET do JavaScriptu a později se vrátí na metodu .NET, která očekává "tvar", je užitečné, aby strana technologie .NET věděla, že daný objekt byl původně "kruhem" – jinak mohou být ztraceny všechny informace specifické pro odvozený typ (například datový člen "RADIUS" na "Circle").</span><span class="sxs-lookup"><span data-stu-id="30528-278">If "Circle" is sent from .NET to JavaScript and is later returned to a .NET method that expects "Shape", it is useful for the .NET side to know that the object in question was originally a "Circle" - otherwise any information specific to the derived type (for example, "radius" data member on "Circle") may be lost.</span></span>

<span data-ttu-id="30528-279">Chcete-li zachovat identitu typu při serializaci komplexních typů do formátu JSON, lze přidat "pomocný parametr" typu a deserializátor rozpoznává pomocný parametr a funguje správně.</span><span class="sxs-lookup"><span data-stu-id="30528-279">To preserve type identity, when serializing complex types to JSON a "type hint" can be added, and the deserializer recognizes the hint and acts appropriately.</span></span> <span data-ttu-id="30528-280">"Pomocný parametr typu" je dvojice klíč/hodnota JSON s názvem klíče \_ \_ typu "Type" (dvě podtržítka následovaná slovem "Type").</span><span class="sxs-lookup"><span data-stu-id="30528-280">The "type hint" is a JSON key/value pair with the key name of "\_\_type" (two underscores followed by the word "type").</span></span> <span data-ttu-id="30528-281">Hodnota je řetězec formátu JSON ve formátu "DataContract: DataContractNamespace" (cokoli až do první dvojtečky je název).</span><span class="sxs-lookup"><span data-stu-id="30528-281">The value is a JSON string of the form "DataContractName:DataContractNamespace" (anything up to the first colon is the name).</span></span> <span data-ttu-id="30528-282">Pomocí předchozího příkladu lze následujícím způsobem serializovat "kruh".</span><span class="sxs-lookup"><span data-stu-id="30528-282">Using the earlier example, "Circle" can be serialized as follows.</span></span>

```json
{"__type":"Circle:http://example.com/myNamespace","x":50,"y":70,"radius":10}
```

<span data-ttu-id="30528-283">Pomocný parametr typu se velmi podobá `xsi:type` atributu definovanému standardem instance schématu XML a používá se při serializaci nebo deserializaci kódu XML.</span><span class="sxs-lookup"><span data-stu-id="30528-283">The type hint is very similar to the `xsi:type` attribute defined by the XML Schema Instance standard and used when serializing/deserializing XML.</span></span>

<span data-ttu-id="30528-284">Datové členy s názvem " \_ \_ typ" jsou zakázány z důvodu možného konfliktu s pomocným parametrem typu.</span><span class="sxs-lookup"><span data-stu-id="30528-284">Data members called "\_\_type" are forbidden due to potential conflict with the type hint.</span></span>

#### <a name="reducing-the-size-of-type-hints"></a><span data-ttu-id="30528-285">Zmenšení velikosti parametrů typu</span><span class="sxs-lookup"><span data-stu-id="30528-285">Reducing the Size of Type Hints</span></span>

<span data-ttu-id="30528-286">Pro snížení velikosti zpráv JSON je výchozí předpona oboru názvů kontraktu dat ( `http://schemas.datacontract.org/2004/07/` ) nahrazena znakem "#".</span><span class="sxs-lookup"><span data-stu-id="30528-286">To reduce the size of JSON messages, the default data contract namespace prefix (`http://schemas.datacontract.org/2004/07/`) is replaced with the "#" character.</span></span> <span data-ttu-id="30528-287">(Aby toto nahrazení bylo vratné, použije se pravidlo pro uvozovací znaky: Pokud obor názvů začíná znaky "#" nebo " \\ ", připojí se znak navíc " \\ ".</span><span class="sxs-lookup"><span data-stu-id="30528-287">(To make this replacement reversible, an escaping rule is used: if the namespace starts with the "#" or "\\" characters, they are appended with an extra "\\" character).</span></span> <span data-ttu-id="30528-288">Proto pokud "Circle" je typ v oboru názvů .NET "MyApp. Shapes", jeho výchozí obor názvů kontraktu dat je `http://schemas.datacontract.org/2004/07/MyApp` .</span><span class="sxs-lookup"><span data-stu-id="30528-288">Thus, if "Circle" is a type in the .NET namespace "MyApp.Shapes", its default data contract namespace is `http://schemas.datacontract.org/2004/07/MyApp`.</span></span> <span data-ttu-id="30528-289">Tvary a reprezentace JSON jsou následující.</span><span class="sxs-lookup"><span data-stu-id="30528-289">Shapes and the JSON representation is as follows.</span></span>

```json
{"__type":"Circle:#MyApp.Shapes","x":50,"y":70,"radius":10}
```

<span data-ttu-id="30528-290">Zkrácení (#MyApp. Shapes) a úplný název ( <http://schemas.datacontract.org/2004/07/MyApp.Shapes> ) jsou srozumitelné Při deserializaci.</span><span class="sxs-lookup"><span data-stu-id="30528-290">Both the truncated (#MyApp.Shapes) and the full (<http://schemas.datacontract.org/2004/07/MyApp.Shapes>) names is understood on deserialization.</span></span>

#### <a name="type-hint-position-in-json-objects"></a><span data-ttu-id="30528-291">Pozice nápovědy typu v objektech JSON</span><span class="sxs-lookup"><span data-stu-id="30528-291">Type Hint Position in JSON Objects</span></span>

<span data-ttu-id="30528-292">Všimněte si, že pomocný parametr typu musí být uveden jako první v reprezentaci JSON.</span><span class="sxs-lookup"><span data-stu-id="30528-292">Note that the type hint must appear first in the JSON representation.</span></span> <span data-ttu-id="30528-293">Toto je jediný případ, ve kterém je pořadí párů klíč/hodnota důležité při zpracování JSON.</span><span class="sxs-lookup"><span data-stu-id="30528-293">This is the only case where order of key/value pairs is important in JSON processing.</span></span> <span data-ttu-id="30528-294">Například následující není platný způsob, jak zadat pomocný parametr typu.</span><span class="sxs-lookup"><span data-stu-id="30528-294">For example, the following is not a valid way to specify the type hint.</span></span>

```json
{"x":50,"y":70,"radius":10,"__type":"Circle:#MyApp.Shapes"}
```

<span data-ttu-id="30528-295">Jak se <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> používá na stránkách klienta WCF i ASP.NET AJAX, vždy nejprve vygeneruje pomocný parametr typu.</span><span class="sxs-lookup"><span data-stu-id="30528-295">Both the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> used by WCF and ASP.NET AJAX client pages always emit the type hint first.</span></span>

#### <a name="type-hints-apply-only-to-complex-types"></a><span data-ttu-id="30528-296">Parametry typu se použijí jenom pro komplexní typy.</span><span class="sxs-lookup"><span data-stu-id="30528-296">Type Hints Apply Only to Complex Types</span></span>

<span data-ttu-id="30528-297">Neexistuje žádný způsob, jak vygenerovat pomocný parametr typu pro nekomplexní typy.</span><span class="sxs-lookup"><span data-stu-id="30528-297">There is no way to emit a type hint for non-complex types.</span></span> <span data-ttu-id="30528-298">Například pokud má operace <xref:System.Object> návratový typ, ale vrátí kruh, reprezentace JSON může být jak je uvedeno výše a informace o typu jsou zachovány.</span><span class="sxs-lookup"><span data-stu-id="30528-298">For example, if an operation has an <xref:System.Object> return type but returns a Circle, the JSON representation can be as shown earlier and the type information is preserved.</span></span> <span data-ttu-id="30528-299">Pokud je však vrácen identifikátor URI, reprezentace JSON je řetězec a fakt, že řetězec použitý k reprezentaci identifikátoru URI je ztracen.</span><span class="sxs-lookup"><span data-stu-id="30528-299">However, if Uri is returned, the JSON representation is a string and the fact that the string used to represent a Uri is lost.</span></span> <span data-ttu-id="30528-300">To platí nejen pro primitivní typy, ale také pro kolekce a pole.</span><span class="sxs-lookup"><span data-stu-id="30528-300">This applies not only to primitive types but also to collections and arrays.</span></span>

#### <a name="when-are-type-hints-emitted"></a><span data-ttu-id="30528-301">Kdy jsou vygenerovány pomocné parametry typu</span><span class="sxs-lookup"><span data-stu-id="30528-301">When Are Type Hints Emitted</span></span>

<span data-ttu-id="30528-302">Pomocné parametry typu můžou výrazně zvýšit velikost zprávy (jedním ze způsobů, jak to zmírnit, je použití kratších oborů názvů kontraktů dat, pokud je to možné).</span><span class="sxs-lookup"><span data-stu-id="30528-302">Type hints may increase message size significantly (one way to mitigate this is to use shorter data contract namespaces if possible).</span></span> <span data-ttu-id="30528-303">Proto následující pravidla určují, zda jsou vygenerovány pomocné parametry typu:</span><span class="sxs-lookup"><span data-stu-id="30528-303">Therefore, the following rules govern whether type hints are emitted:</span></span>

- <span data-ttu-id="30528-304">Při použití ASP.NET AJAX jsou pomocné parametry typu vždy vydávány, kdykoli je to možné, i v případě, že není k dispozici žádné základní/odvozené přiřazení, a to i v případě, že je kruh přiřazený k kruhu.</span><span class="sxs-lookup"><span data-stu-id="30528-304">When using ASP.NET AJAX, type hints are always emitted whenever possible, even if there is no base/derived assignment - for example, even if a Circle is assigned to a Circle.</span></span> <span data-ttu-id="30528-305">(To je nutné k úplnému povolení procesu volání ze slabě typovaného prostředí JSON do prostředí .NET silného typu bez překvapivé ztráty informací.)</span><span class="sxs-lookup"><span data-stu-id="30528-305">(This is required to fully enable the process of calling from the weakly-typed JSON environment into the strongly typed .NET environment with no surprising loss of information.)</span></span>

- <span data-ttu-id="30528-306">Při použití služeb AJAX bez integrace ASP.NET jsou pomocné parametry generovány pouze v případě, že je k dispozici základní nebo odvozené přiřazení – to je vygenerováno při přiřazení kruhu k obrazci, <xref:System.Object> ale ne, je-li přiřazen k kruhu.</span><span class="sxs-lookup"><span data-stu-id="30528-306">When using AJAX services with no ASP.NET integration, type hints are only emitted when there is a base/derived assignment - that is, emitted when Circle is assigned to Shape or <xref:System.Object> but not when assigned to Circle.</span></span> <span data-ttu-id="30528-307">To poskytuje minimální informace potřebné k správné implementaci klienta jazyka JavaScript, což zvyšuje výkon, ale nechrání před ztrátou informací typu v nesprávně navržených klientech.</span><span class="sxs-lookup"><span data-stu-id="30528-307">This provides the minimum information required to correctly implement a JavaScript client, thus improving performance, but does not protect against type information loss in incorrectly-designed clients.</span></span> <span data-ttu-id="30528-308">Pokud se chcete vyhnout tomu, že se tento problém týká klienta, nepoužívejte na serveru zcela základní nebo odvozené přiřazení.</span><span class="sxs-lookup"><span data-stu-id="30528-308">Avoid base/derived assignments altogether on the server if you want to avoid dealing with this issue on the client.</span></span>

- <span data-ttu-id="30528-309">Při použití <xref:System.Runtime.Serialization.DataContractSerializer> typu `alwaysEmitTypeInformation` umožňuje parametr konstruktoru zvolit mezi předchozími dvěma režimy, přičemž výchozí hodnota je " `false` " (v případě potřeby pouze vygeneruje nápovědu typu).</span><span class="sxs-lookup"><span data-stu-id="30528-309">When using the <xref:System.Runtime.Serialization.DataContractSerializer> type, the `alwaysEmitTypeInformation` constructor parameter allows you to choose between the preceding two modes, with the default being "`false`" (only emit type hints when required).</span></span>

#### <a name="duplicate-data-member-names"></a><span data-ttu-id="30528-310">Duplicitní názvy datových členů</span><span class="sxs-lookup"><span data-stu-id="30528-310">Duplicate Data Member Names</span></span>

<span data-ttu-id="30528-311">Odvozené informace o typu jsou přítomny ve stejném objektu JSON spolu se základními informacemi o typu a můžou být v libovolném pořadí.</span><span class="sxs-lookup"><span data-stu-id="30528-311">Derived type information is present in the same JSON object together with base type information, and can occur in any order.</span></span> <span data-ttu-id="30528-312">Například `Shape` může být reprezentován následujícím způsobem.</span><span class="sxs-lookup"><span data-stu-id="30528-312">For example, `Shape` may be represented as follows.</span></span>

```json
{"__type":"Shape:#MyApp.Shapes","x":50,"y":70}
```

<span data-ttu-id="30528-313">Vzhledem k tomu, že kruh může být reprezentován následujícím způsobem.</span><span class="sxs-lookup"><span data-stu-id="30528-313">Whereas Circle may be represented as follows.</span></span>

```json
{"__type":"Circle:#MyApp.Shapes","x":50, "radius":10,"y":70}
```

<span data-ttu-id="30528-314">Pokud základní `Shape` typ také obsahovalo datový člen s názvem " `radius` ", to vede k kolizi v serializaci (protože objekty JSON nemohou mít opakující se názvy klíčů) a deserializaci (protože je nejasné, zda je "poloměr" odkazuje na `Shape.radius` nebo `Circle.radius` ).</span><span class="sxs-lookup"><span data-stu-id="30528-314">If the base `Shape` type also contained a data member called "`radius`", this leads to a collision on both serialization (because JSON objects cannot have repeating key names) and deserialization (because it is unclear whether "radius" refers to `Shape.radius` or `Circle.radius`).</span></span> <span data-ttu-id="30528-315">Proto v případě JSON není obecně doporučován koncept "skrývání vlastností" (datové členy se stejným názvem na bázi a odvozených tříd), je ve skutečnosti v případě JSON zakázaná.</span><span class="sxs-lookup"><span data-stu-id="30528-315">Therefore, while the concept of "property hiding" (data members of the same name on based and derived classes) is generally not recommended in data contract classes, it is actually forbidden in the case of JSON.</span></span>

#### <a name="polymorphism-and-ixmlserializable-types"></a><span data-ttu-id="30528-316">Polymorfismus a typy IXmlSerializable</span><span class="sxs-lookup"><span data-stu-id="30528-316">Polymorphism and IXmlSerializable Types</span></span>

<span data-ttu-id="30528-317"><xref:System.Xml.Serialization.IXmlSerializable>typy mohou být polymorfním způsobem přiřazeny jako obvykle, pokud jsou splněny požadavky na známé typy, podle obvyklých pravidel kontraktu dat.</span><span class="sxs-lookup"><span data-stu-id="30528-317"><xref:System.Xml.Serialization.IXmlSerializable> types may be polymorphically assigned to each other as usual as long as Known Types requirements are met, according to usual data contract rules.</span></span> <span data-ttu-id="30528-318">Nicméně serializace <xref:System.Xml.Serialization.IXmlSerializable> typu namísto <xref:System.Object> výsledků dojde ke ztrátě informací o typu, protože výsledkem je řetězec JSON.</span><span class="sxs-lookup"><span data-stu-id="30528-318">However, serializing an <xref:System.Xml.Serialization.IXmlSerializable> type in place of <xref:System.Object> results in loss of type information as the result is a JSON string.</span></span>

#### <a name="polymorphism-and-certain-interface-types"></a><span data-ttu-id="30528-319">Polymorfismus a určité typy rozhraní</span><span class="sxs-lookup"><span data-stu-id="30528-319">Polymorphism and Certain Interface Types</span></span>

<span data-ttu-id="30528-320">Je zakázáno serializovat typ kolekce nebo typ, který implementuje, <xref:System.Xml.Serialization.IXmlSerializable> kde je očekáván typ bez kolekce <xref:System.Xml.Serialization.IXmlSerializable> (s výjimkou <xref:System.Object> ).</span><span class="sxs-lookup"><span data-stu-id="30528-320">It is forbidden to serialize a collection type or a type that implements <xref:System.Xml.Serialization.IXmlSerializable> where a non-collection type that is not <xref:System.Xml.Serialization.IXmlSerializable> (except for <xref:System.Object>) is expected.</span></span> <span data-ttu-id="30528-321">Například vlastní rozhraní s názvem `IMyInterface` a typ `MyType` , který implementuje oba <xref:System.Collections.Generic.IEnumerable%601> typy `int` i `IMyInterface` .</span><span class="sxs-lookup"><span data-stu-id="30528-321">For example, a custom interface called `IMyInterface` and a type `MyType` that implement both <xref:System.Collections.Generic.IEnumerable%601> of type `int` and `IMyInterface`.</span></span> <span data-ttu-id="30528-322">Je zakázáno vracet `MyType` z operace, jejíž návratový typ je `IMyInterface` .</span><span class="sxs-lookup"><span data-stu-id="30528-322">It is forbidden to return `MyType` from an operation whose return type is `IMyInterface`.</span></span> <span data-ttu-id="30528-323">Důvodem je, že `MyType` musí být serializován jako pole JSON a vyžadovat pomocný parametr typu, jak je uvedeno před tím, než nelze zahrnout pomocný parametr typu s poli, pouze se složitými typy.</span><span class="sxs-lookup"><span data-stu-id="30528-323">This is because `MyType` must be serialized as a JSON array and requires a type hint, and as stated before you cannot include a type hint with arrays, only with complex types.</span></span>

#### <a name="known-types-and-configuration"></a><span data-ttu-id="30528-324">Známé typy a konfigurace</span><span class="sxs-lookup"><span data-stu-id="30528-324">Known Types and Configuration</span></span>

<span data-ttu-id="30528-325">Všechny známé mechanizmy typů, které používá, <xref:System.Runtime.Serialization.DataContractSerializer> jsou také podporovány stejným způsobem jako <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> .</span><span class="sxs-lookup"><span data-stu-id="30528-325">All of the Known Type mechanisms used by the <xref:System.Runtime.Serialization.DataContractSerializer> are also supported in the same way by the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer>.</span></span> <span data-ttu-id="30528-326">Serializátory čtou stejný element konfigurace [\<dataContractSerializer>](../../../../docs/framework/configure-apps/file-schema/wcf/datacontractserializer-of-system-runtime-serialization.md) v [\<system.runtime.serialization>](../../../../docs/framework/configure-apps/file-schema/wcf/system-runtime-serialization.md) , aby zjistily známé typy přidané prostřednictvím konfiguračního souboru.</span><span class="sxs-lookup"><span data-stu-id="30528-326">Both serializers read the same configuration element, [\<dataContractSerializer>](../../../../docs/framework/configure-apps/file-schema/wcf/datacontractserializer-of-system-runtime-serialization.md) in [\<system.runtime.serialization>](../../../../docs/framework/configure-apps/file-schema/wcf/system-runtime-serialization.md), to discover known types added through a configuration file.</span></span>

#### <a name="collections-assigned-to-object"></a><span data-ttu-id="30528-327">Kolekce přiřazené k objektu</span><span class="sxs-lookup"><span data-stu-id="30528-327">Collections Assigned to Object</span></span>

<span data-ttu-id="30528-328">Kolekce přiřazené k objektu jsou serializovány, jako by se jedná o kolekce, které implementují <xref:System.Collections.Generic.IEnumerable%601> : pole JSON se všemi položkami, které mají pomocný parametr typu, pokud se jedná o komplexní typ.</span><span class="sxs-lookup"><span data-stu-id="30528-328">Collections assigned to Object are serialized as if they are collections that implement <xref:System.Collections.Generic.IEnumerable%601>: a JSON array with each entry that has a type hint if it is a complex type.</span></span> <span data-ttu-id="30528-329">Například <xref:System.Collections.Generic.List%601> typ `Shape` přiřazeno může <xref:System.Object> vypadat jako následující.</span><span class="sxs-lookup"><span data-stu-id="30528-329">For example, a <xref:System.Collections.Generic.List%601> of type `Shape` assigned to <xref:System.Object> looks like the following.</span></span>

```json
[{"__type":"Shape:#MyApp.Shapes","x":50,"y":70},
{"__type":"Shape:#MyApp.Shapes","x":58,"y":73},
{"__type":"Shape:#MyApp.Shapes","x":41,"y":32}]
```

<span data-ttu-id="30528-330">Při deserializaci zpět do <xref:System.Object> :</span><span class="sxs-lookup"><span data-stu-id="30528-330">When deserialized back into <xref:System.Object>:</span></span>

- <span data-ttu-id="30528-331">`Shape`musí být v seznamu známých typů.</span><span class="sxs-lookup"><span data-stu-id="30528-331">`Shape` must be in the Known Types list.</span></span> <span data-ttu-id="30528-332">Existence <xref:System.Collections.Generic.List%601> typu `Shape` v známých typech nemá žádný vliv.</span><span class="sxs-lookup"><span data-stu-id="30528-332">Having <xref:System.Collections.Generic.List%601> of type `Shape` in known types has no effect.</span></span> <span data-ttu-id="30528-333">Všimněte si, že `Shape` v tomto případě není nutné přidávat do serializace známé typy – to je provedeno automaticky.</span><span class="sxs-lookup"><span data-stu-id="30528-333">Note that you do not have to add `Shape` to known types on serialization in this case - this is done automatically.</span></span>

- <span data-ttu-id="30528-334">Kolekce je deserializována jako <xref:System.Array> typ <xref:System.Object> , který obsahuje `Shape` instance.</span><span class="sxs-lookup"><span data-stu-id="30528-334">The collection is deserialized as an <xref:System.Array> of type <xref:System.Object> that contains `Shape` instances.</span></span>

#### <a name="derived-collections-assigned-to-base-collections"></a><span data-ttu-id="30528-335">Odvozené kolekce přiřazené ke základním kolekcím</span><span class="sxs-lookup"><span data-stu-id="30528-335">Derived Collections Assigned to Base Collections</span></span>

<span data-ttu-id="30528-336">Když je odvozená kolekce přiřazena ke základní kolekci, je kolekce obvykle serializována, jako by byla kolekcí základního typu.</span><span class="sxs-lookup"><span data-stu-id="30528-336">When a derived collection is assigned to a base collection, the collection is usually serialized as if it was a collection of the base type.</span></span> <span data-ttu-id="30528-337">Nicméně, pokud typ položky odvozené kolekce nemůže být přiřazen k typu položky základní kolekce, je vyvolána výjimka.</span><span class="sxs-lookup"><span data-stu-id="30528-337">However, if the item type of the derived collection cannot be assigned to the item type of the base collection, an exception is thrown.</span></span>

#### <a name="type-hints-and-dictionaries"></a><span data-ttu-id="30528-338">Zadání tipů a slovníků</span><span class="sxs-lookup"><span data-stu-id="30528-338">Type Hints and Dictionaries</span></span>

<span data-ttu-id="30528-339">Když je slovník přiřazen k <xref:System.Object> , každá položka klíče a hodnoty ve slovníku je považována za, jako by byla přiřazena k <xref:System.Object> a získá pomocný parametr typu.</span><span class="sxs-lookup"><span data-stu-id="30528-339">When a dictionary is assigned to an <xref:System.Object>, each Key and Value entry in the dictionary is treated as if it was assigned to <xref:System.Object> and gets a type hint.</span></span>

<span data-ttu-id="30528-340">Při serializaci typů slovníku není objekt JSON, který obsahuje členy "klíč" a "value", nijak ovlivněn `alwaysEmitTypeInformation` nastavením a obsahuje pouze pomocný parametr typu, pokud je vyžaduje předchozí pravidla shromažďování.</span><span class="sxs-lookup"><span data-stu-id="30528-340">When serializing dictionary types, the JSON object that contains the "Key" and "Value" members is unaffected by the `alwaysEmitTypeInformation` setting and only contains a type hint when the preceding collection rules require it.</span></span>

### <a name="valid-json-key-names"></a><span data-ttu-id="30528-341">Platné názvy klíčů JSON</span><span class="sxs-lookup"><span data-stu-id="30528-341">Valid JSON Key Names</span></span>

<span data-ttu-id="30528-342">Serializátor XML – zakóduje názvy klíčů, které nejsou platnými názvy XML.</span><span class="sxs-lookup"><span data-stu-id="30528-342">The serializer XML-encodes key names that are not valid XML names.</span></span> <span data-ttu-id="30528-343">Například datový člen s názvem "123" by měl kódovaný název, například " \_ x0031 \_ \_ x0032 \_ \_ x0033 \_ ", protože "123" je neplatný název elementu XML (začíná číslicí).</span><span class="sxs-lookup"><span data-stu-id="30528-343">For example, a data member with the name of "123" would have an encoded name such as "\_x0031\_\_x0032\_\_x0033\_" because "123" is an invalid XML element name (starts with a digit).</span></span> <span data-ttu-id="30528-344">Podobná situace může nastat v případě, že některé mezinárodní znakové sady nejsou platné v názvech XML.</span><span class="sxs-lookup"><span data-stu-id="30528-344">A similar situation may arise with some international character sets not valid in XML names.</span></span> <span data-ttu-id="30528-345">Vysvětlení tohoto účinku XML při zpracování JSON najdete v tématu [mapování mezi JSON a XML](../../../../docs/framework/wcf/feature-details/mapping-between-json-and-xml.md).</span><span class="sxs-lookup"><span data-stu-id="30528-345">For an explanation of this effect of XML on JSON processing, see [Mapping Between JSON and XML](../../../../docs/framework/wcf/feature-details/mapping-between-json-and-xml.md).</span></span>

## <a name="see-also"></a><span data-ttu-id="30528-346">Viz také</span><span class="sxs-lookup"><span data-stu-id="30528-346">See also</span></span>

- [<span data-ttu-id="30528-347">Podpora formátu JSON a dalších formátů přenosu dat</span><span class="sxs-lookup"><span data-stu-id="30528-347">Support for JSON and Other Data Transfer Formats</span></span>](../../../../docs/framework/wcf/feature-details/support-for-json-and-other-data-transfer-formats.md)
