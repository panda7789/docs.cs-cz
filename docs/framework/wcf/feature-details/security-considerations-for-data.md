---
title: Důležité informace o zabezpečení pro data
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
ms.assetid: a7eb98da-4a93-4692-8b59-9d670c79ffb2
ms.openlocfilehash: 8b54aea1409f2b4c0a3d39d215922ba62c2a3563
ms.sourcegitcommit: c4a15c6c4ecbb8a46ad4e67d9b3ab9b8b031d849
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 08/20/2020
ms.locfileid: "88656967"
---
# <a name="security-considerations-for-data"></a><span data-ttu-id="d5ec7-102">Důležité informace o zabezpečení pro data</span><span class="sxs-lookup"><span data-stu-id="d5ec7-102">Security Considerations for Data</span></span>

<span data-ttu-id="d5ec7-103">Při práci s daty v Windows Communication Foundation (WCF) musíte vzít v úvahu několik kategorií hrozeb.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-103">When dealing with data in Windows Communication Foundation (WCF), you must consider a number of threat categories.</span></span> <span data-ttu-id="d5ec7-104">V následující tabulce jsou uvedeny nejdůležitější třídy hrozeb, které se vztahují ke zpracování dat.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-104">The following table lists the most important threat classes that relate to data processing.</span></span> <span data-ttu-id="d5ec7-105">WCF nabízí nástroje, které tyto hrozby zmírnit.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-105">WCF provides tools to mitigate these threats.</span></span>

<span data-ttu-id="d5ec7-106">Při odepření nedůvěryhodných dat může tato data způsobit, že přijímající strana získá přístup k neúměrnému množství různých prostředků, jako jsou paměť, vlákna, dostupná připojení nebo cykly procesoru, a to díky zdlouhavým výpočtům.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-106">Denial of service When receiving untrusted data, the data may cause the receiving side to access a disproportionate amount of various resources, such as memory, threads, available connections, or processor cycles by causing lengthy computations.</span></span> <span data-ttu-id="d5ec7-107">Útok DOS na server může způsobit jeho chybu a nebude moct zpracovávat zprávy z jiných, legitimních klientů.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-107">A denial-of-service attack against a server may cause it to crash and be unable to process messages from other, legitimate clients.</span></span>

<span data-ttu-id="d5ec7-108">Škodlivá nedůvěryhodná data při spuštění kódu způsobí, že přijímající strana spustí kód, který nezamýšlel.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-108">Malicious code execution Incoming untrusted data causes the receiving side to run code it did not intend to.</span></span>

<span data-ttu-id="d5ec7-109">Zpřístupnění informací vzdálenému útočníkovi přinutí přijímající straně reagovat na své žádosti tak, aby bylo možné zveřejnit více informací, než je v úmyslu.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-109">Information disclosure The remote attacker forces the receiving party to respond to its requests in such a way as to disclose more information than it intends to.</span></span>

## <a name="user-provided-code-and-code-access-security"></a><span data-ttu-id="d5ec7-110">Uživatelem poskytnutý kód a zabezpečení přístupu kódu</span><span class="sxs-lookup"><span data-stu-id="d5ec7-110">User-Provided Code and Code Access Security</span></span>

<span data-ttu-id="d5ec7-111">Počet míst v infrastruktuře Windows Communication Foundation (WCF), které poskytuje uživatel.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-111">A number of places in the Windows Communication Foundation (WCF) infrastructure run code that is provided by the user.</span></span> <span data-ttu-id="d5ec7-112">Například <xref:System.Runtime.Serialization.DataContractSerializer> modul serializace může volat `set` přistupující objekty vlastnosti a `get` přistupující objekty.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-112">For example, the <xref:System.Runtime.Serialization.DataContractSerializer> serialization engine may call user-provided property `set` accessors and `get` accessors.</span></span> <span data-ttu-id="d5ec7-113">Infrastruktura kanálu WCF může také volat do uživatelem odvozených tříd <xref:System.ServiceModel.Channels.Message> třídy.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-113">The WCF channel infrastructure may also call into user-provided derived classes of the <xref:System.ServiceModel.Channels.Message> class.</span></span>

<span data-ttu-id="d5ec7-114">Je zodpovědný za autora kódu, aby se zajistilo, že neexistují žádné chyby zabezpečení.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-114">It is the responsibility of the code author to ensure that no security vulnerabilities exist.</span></span> <span data-ttu-id="d5ec7-115">Například pokud vytvoříte typ kontraktu dat s vlastností datového člena typu celé číslo a v `set` implementaci přistupující objekt přidělíte pole na základě hodnoty vlastnosti, vystavíte možnost útoku DOS, pokud škodlivá zpráva obsahuje extrémně velkou hodnotu pro tento datový člen.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-115">For example, if you create a data contract type with a data member property of type integer, and in the `set` accessor implementation allocate an array based on the property value, you expose the possibility of a denial-of-service attack if a malicious message contains an extremely large value for this data member.</span></span> <span data-ttu-id="d5ec7-116">Obecně se vyhněte jakémukoli přidělení na základě příchozích dat nebo zdlouhavého zpracování v uživatelsky poskytnutém kódu (zejména v případě, že může být zdlouhavé zpracování způsobeno malým množstvím příchozích dat).</span><span class="sxs-lookup"><span data-stu-id="d5ec7-116">In general, avoid any allocations based on incoming data or lengthy processing in user-provided code (especially if lengthy processing can be caused by a small amount of incoming data).</span></span> <span data-ttu-id="d5ec7-117">Při provádění analýzy zabezpečení uživatelsky zadaného kódu nezapomeňte také vzít v úvahu všechny případy selhání (tj. všechny větve kódu, kde jsou výjimky vyvolány).</span><span class="sxs-lookup"><span data-stu-id="d5ec7-117">When performing security analysis of user-provided code, make sure to also consider all failure cases (that is, all code branches where exceptions are thrown).</span></span>

<span data-ttu-id="d5ec7-118">Konečný příklad uživatelsky zadaného kódu je kód uvnitř implementace služby pro každou operaci.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-118">The ultimate example of user-provided code is the code inside your service implementation for each operation.</span></span> <span data-ttu-id="d5ec7-119">Zabezpečení vaší implementace služby je vaše zodpovědnost.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-119">The security of your service implementation is your responsibility.</span></span> <span data-ttu-id="d5ec7-120">Nechtěně Vytvářejte nezabezpečené implementace operací, které mohou vést k ohrožení zabezpečení při odepření služby.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-120">It is easy to inadvertently create insecure operation implementations that may result in denial-of-service vulnerabilities.</span></span> <span data-ttu-id="d5ec7-121">Například operace, která přebírá řetězec a vrátí seznam zákazníků z databáze, jejíž název začíná řetězcem.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-121">For example, an operation that takes a string and returns the list of customers from a database whose name starts with that string.</span></span> <span data-ttu-id="d5ec7-122">Pokud pracujete s velkou databází a předávaný řetězec je pouze jedno písmeno, váš kód se může pokusit vytvořit zprávu větší než veškerá dostupná paměť, což způsobí selhání celé služby.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-122">If you are working with a large database and the string being passed is just a single letter, your code may attempt to create a message larger than all available memory, causing the entire service to fail.</span></span> <span data-ttu-id="d5ec7-123">( <xref:System.OutOfMemoryException> Nelze obnovit .NET Framework a vždy má za následek ukončení aplikace.)</span><span class="sxs-lookup"><span data-stu-id="d5ec7-123">(An <xref:System.OutOfMemoryException> is not recoverable in the .NET Framework and always results in the termination of your application.)</span></span>

<span data-ttu-id="d5ec7-124">Měli byste zajistit, aby žádný škodlivý kód nebyl připojen do různých bodů rozšiřitelnosti.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-124">You should ensure that no malicious code is plugged in to the various extensibility points.</span></span> <span data-ttu-id="d5ec7-125">To je obzvláště důležité při spuštění v částečném vztahu důvěryhodnosti, v souvislosti s typy z částečně důvěryhodných sestavení nebo při vytváření komponent použitelných částečně důvěryhodným kódem.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-125">This is especially relevant when running under partial trust, dealing with types from partially-trusted assemblies, or creating components usable by partially-trusted code.</span></span> <span data-ttu-id="d5ec7-126">Další informace najdete v části "hrozby s částečným vztahem důvěryhodnosti" v pozdější části.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-126">For more information, see "Partial Trust Threats" in a later section.</span></span>

<span data-ttu-id="d5ec7-127">Všimněte si, že při spuštění v částečném vztahu důvěryhodnosti podporuje infrastruktura serializace kontraktů dat pouze omezené podmnožiny programovacího modelu kontraktu dat, například soukromé datové členy nebo typy s použitím <xref:System.SerializableAttribute> atributu nejsou podporovány.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-127">Note that when running in partial trust, the data contract serialization infrastructure supports only a limited subset of the data contract programming model - for example, private data members or types using the <xref:System.SerializableAttribute> attribute are not supported.</span></span> <span data-ttu-id="d5ec7-128">Další informace najdete v tématu [částečná důvěryhodnost](partial-trust.md).</span><span class="sxs-lookup"><span data-stu-id="d5ec7-128">For more information, see [Partial Trust](partial-trust.md).</span></span>

## <a name="avoiding-unintentional-information-disclosure"></a><span data-ttu-id="d5ec7-129">Zamezení neúmyslnému zpřístupnění informací</span><span class="sxs-lookup"><span data-stu-id="d5ec7-129">Avoiding Unintentional Information Disclosure</span></span>

<span data-ttu-id="d5ec7-130">Při navrhování serializovatelných typů s ohledem na zabezpečení je možné se vyzrazení informací.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-130">When designing serializable types with security in mind, information disclosure is a possible concern.</span></span>

<span data-ttu-id="d5ec7-131">Vezměte v úvahu následující body:</span><span class="sxs-lookup"><span data-stu-id="d5ec7-131">Consider the following points:</span></span>

- <span data-ttu-id="d5ec7-132"><xref:System.Runtime.Serialization.DataContractSerializer>Programovací model umožňuje vystavení privátních a interních dat mimo typ nebo sestavení během serializace.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-132">The <xref:System.Runtime.Serialization.DataContractSerializer> programming model allows the exposure of private and internal data outside of the type or assembly during serialization.</span></span> <span data-ttu-id="d5ec7-133">Kromě toho může být tvar typu vystaven během exportu schématu.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-133">Additionally, the shape of a type can be exposed during schema export.</span></span> <span data-ttu-id="d5ec7-134">Nezapomeňte pochopit projekci serializace typu.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-134">Be sure to understand your type's serialization projection.</span></span> <span data-ttu-id="d5ec7-135">Pokud nechcete, aby bylo cokoli vystaveno, zakažte jeho serializaci (například nepoužití <xref:System.Runtime.Serialization.DataMemberAttribute> atributu v případě kontraktu dat).</span><span class="sxs-lookup"><span data-stu-id="d5ec7-135">If you do not want anything exposed, disable serializing it (for example, by not applying the <xref:System.Runtime.Serialization.DataMemberAttribute> attribute in the case of a data contract).</span></span>

- <span data-ttu-id="d5ec7-136">Počítejte s tím, že stejný typ může mít více projekcí serializace v závislosti na používaném serializátoru.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-136">Be aware that the same type may have multiple serialization projections, depending on the serializer in use.</span></span> <span data-ttu-id="d5ec7-137">Stejný typ může vystavit jednu sadu dat při použití s <xref:System.Runtime.Serialization.DataContractSerializer> a jinou sadou dat při použití s <xref:System.Xml.Serialization.XmlSerializer> .</span><span class="sxs-lookup"><span data-stu-id="d5ec7-137">The same type may expose one set of data when used with the <xref:System.Runtime.Serialization.DataContractSerializer> and another set of data when used with the <xref:System.Xml.Serialization.XmlSerializer>.</span></span> <span data-ttu-id="d5ec7-138">Omylem s použitím špatného serializátoru může vést k odhalení informací.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-138">Accidentally using the wrong serializer may lead to information disclosure.</span></span>

- <span data-ttu-id="d5ec7-139">Použití <xref:System.Xml.Serialization.XmlSerializer> ve starším režimu vzdáleného volání procedur (RPC)/Encoded může neúmyslně zveřejnit tvar grafu objektů na straně odeslání na straně příjmu.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-139">Using the <xref:System.Xml.Serialization.XmlSerializer> in legacy remote procedure call (RPC)/encoded mode may unintentionally expose the shape of the object graph on the sending side to the receiving side.</span></span>

## <a name="preventing-denial-of-service-attacks"></a><span data-ttu-id="d5ec7-140">Zabránění útokům DOS (Denial-of-Service)</span><span class="sxs-lookup"><span data-stu-id="d5ec7-140">Preventing Denial-of-Service Attacks</span></span>

### <a name="quotas"></a><span data-ttu-id="d5ec7-141">Kvóty</span><span class="sxs-lookup"><span data-stu-id="d5ec7-141">Quotas</span></span>

<span data-ttu-id="d5ec7-142">Způsob, jakým přijímající strana přidělí značnou velikost paměti, je potenciální útok na útok DoS (Denial-of-Service).</span><span class="sxs-lookup"><span data-stu-id="d5ec7-142">Causing the receiving side to allocate a significant amount of memory is a potential denial-of-service attack.</span></span> <span data-ttu-id="d5ec7-143">I když se tato část soustředí na problémy s spotřebou paměti vznikající z velkých zpráv, může dojít k dalším útokům.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-143">While this section concentrates on memory consumption issues arising from large messages, other attacks may occur.</span></span> <span data-ttu-id="d5ec7-144">Zprávy mohou například používat neúměrné množství času zpracování.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-144">For example, messages may use a disproportionate amount of processing time.</span></span>

<span data-ttu-id="d5ec7-145">Útoky DoS (Denial-of-Service) jsou obvykle zmírňované pomocí kvót.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-145">Denial-of-service attacks are usually mitigated using quotas.</span></span> <span data-ttu-id="d5ec7-146">Při překročení kvóty <xref:System.ServiceModel.QuotaExceededException> je obvykle vyvolána výjimka.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-146">When a quota is exceeded, a <xref:System.ServiceModel.QuotaExceededException> exception is normally thrown.</span></span> <span data-ttu-id="d5ec7-147">Bez této kvóty může škodlivá zpráva způsobit přístup k veškeré dostupné paměti, výsledkem je <xref:System.OutOfMemoryException> výjimka nebo všechny dostupné zásobníky, které mají za následek přístup <xref:System.StackOverflowException> .</span><span class="sxs-lookup"><span data-stu-id="d5ec7-147">Without the quota, a malicious message may cause all available memory to be accessed, resulting in an <xref:System.OutOfMemoryException> exception, or all available stacks to be accessed, resulting in a <xref:System.StackOverflowException>.</span></span>

<span data-ttu-id="d5ec7-148">Scénář překročení kvóty je obnovitelný; Pokud se ve spuštěné službě vyskytne, zpráva, která se právě zpracovává, se zahodí a služba pokračuje v běhu a zpracovává další zprávy.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-148">The quota exceeded scenario is recoverable; if encountered in a running service, the message currently being processed is discarded and the service keeps running and processes further messages.</span></span> <span data-ttu-id="d5ec7-149">Scénáře nedostatku paměti a přetečení zásobníku ale nejsou obnovitelné kdekoli v .NET Framework; Služba se ukončí, pokud nalezne takové výjimky.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-149">The out-of-memory and stack overflow scenarios, however, are not recoverable anywhere in the .NET Framework; the service terminates if it encounters such exceptions.</span></span>

<span data-ttu-id="d5ec7-150">Kvóty v technologii WCF nezahrnují žádné předběžné přidělení.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-150">Quotas in WCF do not involve any pre-allocation.</span></span> <span data-ttu-id="d5ec7-151">Pokud <xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A> je například kvóta (v různých třídách) nastavená na 128 KB, neznamená to, že se pro každou zprávu automaticky přidělí 128 KB.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-151">For example, if the <xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A> quota (found on various classes) is set to 128 KB, it does not mean that 128 KB is automatically allocated for each message.</span></span> <span data-ttu-id="d5ec7-152">Skutečná přidělená částka závisí na skutečné velikosti příchozích zpráv.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-152">The actual amount allocated depends on the actual incoming message size.</span></span>

<span data-ttu-id="d5ec7-153">K dispozici je mnoho kvót na transportní vrstvě.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-153">Many quotas are available at the transport layer.</span></span> <span data-ttu-id="d5ec7-154">Jedná se o kvóty vynutilé konkrétním transportním kanálem, který se používá (HTTP, TCP atd.).</span><span class="sxs-lookup"><span data-stu-id="d5ec7-154">These are quotas enforced by the specific transport channel in use (HTTP, TCP, and so on).</span></span> <span data-ttu-id="d5ec7-155">I když toto téma popisuje některé z těchto kvót, jsou tyto kvóty podrobně popsané v části [přenosové kvóty](transport-quotas.md).</span><span class="sxs-lookup"><span data-stu-id="d5ec7-155">While this topic discusses some of these quotas, these quotas are described in detail in [Transport Quotas](transport-quotas.md).</span></span>

### <a name="hashtable-vulnerability"></a><span data-ttu-id="d5ec7-156">Zranitelnost zatřiďovací tabulky</span><span class="sxs-lookup"><span data-stu-id="d5ec7-156">Hashtable Vulnerability</span></span>

<span data-ttu-id="d5ec7-157">V případě, že kontrakty dat obsahují zatřiďovacími tabulkami nebo kolekce, existuje ohrožení zabezpečení.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-157">A vulnerability exists when data contracts contain hashtables or collections.</span></span> <span data-ttu-id="d5ec7-158">K tomuto problému dochází, pokud je do zatřiďovací tabulky vložen velký počet hodnot, kde velký počet těchto hodnot vygeneruje stejnou hodnotu hash.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-158">The problem occurs if a large number of values are inserted into a hashtable where a large number of those values generate the same hash value.</span></span> <span data-ttu-id="d5ec7-159">Tato možnost se dá použít jako útok DOS.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-159">This can be used as a DOS attack.</span></span>  <span data-ttu-id="d5ec7-160">Tuto chybu zabezpečení lze zmírnit nastavením kvóty vazby třídy MaxReceivedMessageSize.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-160">This vulnerability can be mitigated by setting the MaxReceivedMessageSize binding quota.</span></span> <span data-ttu-id="d5ec7-161">Při nastavování této kvóty je nutné dbát na to, aby tyto útoky nedocházelo.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-161">Care must be taken while setting this quota in order to prevent such attacks.</span></span> <span data-ttu-id="d5ec7-162">Tato kvóta přináší horní limit velikosti zprávy WCF.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-162">This quota puts an upper limit on the size of WCF message.</span></span> <span data-ttu-id="d5ec7-163">Kromě toho se vyhněte používání zatřiďovacími tabulkami nebo kolekcí v kontraktech dat.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-163">Additionally, avoid using hashtables or collections in your data contracts.</span></span>

## <a name="limiting-memory-consumption-without-streaming"></a><span data-ttu-id="d5ec7-164">Omezení spotřeby paměti bez streamování</span><span class="sxs-lookup"><span data-stu-id="d5ec7-164">Limiting Memory Consumption Without Streaming</span></span>

<span data-ttu-id="d5ec7-165">Model zabezpečení kolem velkých zpráv závisí na tom, jestli se streamování používá.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-165">The security model around large messages depends on whether streaming is in use.</span></span> <span data-ttu-id="d5ec7-166">V případě běžného nestreamového případu jsou zprávy ukládány do vyrovnávací paměti.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-166">In the basic, non-streamed case, messages are buffered into memory.</span></span> <span data-ttu-id="d5ec7-167">V takovém případě můžete použít <xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A> kvótu na <xref:System.ServiceModel.Channels.TransportBindingElement> vazbách poskytovaných systémem nebo k ochraně před velkými zprávami tím, že omezíte maximální velikost zprávy pro přístup.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-167">In this case, use the <xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A> quota on the <xref:System.ServiceModel.Channels.TransportBindingElement> or on the system-provided bindings to protect against large messages by limiting the maximum message size to access.</span></span> <span data-ttu-id="d5ec7-168">Všimněte si, že služba může zpracovávat více zpráv současně. v takovém případě jsou všechny v paměti.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-168">Note that a service may be processing multiple messages at the same time, in which case they are all in memory.</span></span> <span data-ttu-id="d5ec7-169">K zmírnění této hrozby použijte funkci omezování.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-169">Use the throttling feature to mitigate this threat.</span></span>

<span data-ttu-id="d5ec7-170">Všimněte si také, že `MaxReceivedMessageSize` není umístěn horní mez pro paměť na základě zpráv, ale omezuje ho v rámci konstantního faktoru.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-170">Also note that `MaxReceivedMessageSize` does not place an upper bound on per-message memory consumption, but limits it to within a constant factor.</span></span> <span data-ttu-id="d5ec7-171">Pokud je například `MaxReceivedMessageSize` přijata a pak deserializovat zpráva o velikosti 1 MB a potom deserializace, je nutné, aby objekt obsahoval další paměť, která má za následek celkovou spotřebu paměti po 1 MB.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-171">For example, if the `MaxReceivedMessageSize` is 1 MB and a 1-MB message is received and then deserialized, additional memory is required to contain the deserialized object graph, resulting in total memory consumption well over 1 MB.</span></span> <span data-ttu-id="d5ec7-172">Z tohoto důvodu Vyhněte se vytváření serializovatelných typů, které by mohly mít za následek značnou spotřebu paměti bez množství příchozích dat.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-172">For this reason, avoid creating serializable types that could result in significant memory consumption without much incoming data.</span></span> <span data-ttu-id="d5ec7-173">Například u kontraktu dat "MyContract" s 50mi volitelnými poli datových členů a dalšími 100 soukromými poli může být vytvořena instance XML konstrukce " \<MyContract/> ".</span><span class="sxs-lookup"><span data-stu-id="d5ec7-173">For example, a data contract "MyContract" with 50 optional data member fields and an additional 100 private fields could be instantiated with the XML construction "\<MyContract/>".</span></span> <span data-ttu-id="d5ec7-174">Výsledkem tohoto XML je paměť, která je k dispozici pro pole 150.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-174">This XML results in memory being accessed for 150 fields.</span></span> <span data-ttu-id="d5ec7-175">Všimněte si, že datové členy jsou ve výchozím nastavení volitelné.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-175">Note that data members are optional by default.</span></span> <span data-ttu-id="d5ec7-176">Pokud je takový typ součástí pole, je problém složený.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-176">The problem is compounded when such a type is part of an array.</span></span>

<span data-ttu-id="d5ec7-177">`MaxReceivedMessageSize` samotný není dostatek, aby nedocházelo k útokům DOS (Denial-of-Service).</span><span class="sxs-lookup"><span data-stu-id="d5ec7-177">`MaxReceivedMessageSize` alone is not enough to prevent all denial-of-service attacks.</span></span> <span data-ttu-id="d5ec7-178">Například deserializátor může být vynuceně deserializovat graf hluboko vnořeného objektu (objekt, který obsahuje jiný objekt, který obsahuje ještě jiný objekt, a tak dále) příchozí zprávou.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-178">For example, the deserializer may be forced to deserialize a deeply-nested object graph (an object that contains another object that contains yet another one, and so on) by an incoming message.</span></span> <span data-ttu-id="d5ec7-179"><xref:System.Runtime.Serialization.DataContractSerializer>Metody a volají jak <xref:System.Xml.Serialization.XmlSerializer> vnořeným způsobem pro deserializaci takových grafů.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-179">Both the <xref:System.Runtime.Serialization.DataContractSerializer> and the <xref:System.Xml.Serialization.XmlSerializer> call methods in a nested way to deserialize such graphs.</span></span> <span data-ttu-id="d5ec7-180">Hluboká vnořování volání metod může způsobit neobnovení <xref:System.StackOverflowException> .</span><span class="sxs-lookup"><span data-stu-id="d5ec7-180">Deep nesting of method calls may result in an unrecoverable <xref:System.StackOverflowException>.</span></span> <span data-ttu-id="d5ec7-181">Tato hrozba se snižuje tím, že nastaví <xref:System.ServiceModel.Configuration.XmlDictionaryReaderQuotasElement.MaxDepth%2A> kvótu pro omezení úrovně vnoření XML, jak je popsáno v části "používání XML bezpečně" dále v tématu.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-181">This threat is mitigated by setting the <xref:System.ServiceModel.Configuration.XmlDictionaryReaderQuotasElement.MaxDepth%2A> quota to limit the level of XML nesting, as discussed in the "Using XML Safely" section later in the topic.</span></span>

<span data-ttu-id="d5ec7-182">Nastavení dalších kvót na `MaxReceivedMessageSize` je obzvláště důležité při použití binárního kódování XML.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-182">Setting additional quotas to `MaxReceivedMessageSize` is especially important when using binary XML encoding.</span></span> <span data-ttu-id="d5ec7-183">Použití binárního kódování je poměrně stejné jako komprese: malá skupina bajtů v příchozí zprávě může představovat velké množství dat.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-183">Using binary encoding is somewhat equivalent to compression: a small group of bytes in the incoming message may represent a lot of data.</span></span> <span data-ttu-id="d5ec7-184">To znamená, že i zpráva přizpůsobující se do `MaxReceivedMessageSize` limitu může zabírat mnohem více paměti v plně rozbaleném formátu.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-184">Thus, even a message fitting into the `MaxReceivedMessageSize` limit may take up much more memory in fully expanded form.</span></span> <span data-ttu-id="d5ec7-185">Chcete-li zmírnit takové hrozby specifické pro XML, musí být všechny kvóty čtečky XML nastaveny správně, jak je popsáno v části "používání XML bezpečně" dále v tomto tématu.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-185">To mitigate such XML-specific threats, all of the XML reader quotas must be set correctly, as discussed in the "Using XML Safely" section later in this topic.</span></span>

## <a name="limiting-memory-consumption-with-streaming"></a><span data-ttu-id="d5ec7-186">Omezení spotřeby paměti pomocí streamování</span><span class="sxs-lookup"><span data-stu-id="d5ec7-186">Limiting Memory Consumption with Streaming</span></span>

<span data-ttu-id="d5ec7-187">Při streamování můžete použít malé `MaxReceivedMessageSize` nastavení pro ochranu před útoky DoS (Denial-of-Service).</span><span class="sxs-lookup"><span data-stu-id="d5ec7-187">When streaming, you may use a small `MaxReceivedMessageSize` setting to protect against denial-of-service attacks.</span></span> <span data-ttu-id="d5ec7-188">U streamování je ale možné použít složitější scénáře.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-188">However, more complicated scenarios are possible with streaming.</span></span> <span data-ttu-id="d5ec7-189">Například služba nahrání souborů akceptuje soubory větší než veškerá dostupná paměť.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-189">For example, a file upload service accepts files larger than all available memory.</span></span> <span data-ttu-id="d5ec7-190">V takovém případě nastavte `MaxReceivedMessageSize` na extrémně velkou hodnotu, očekává se, že téměř žádná data nejsou ukládána do vyrovnávací paměti a proudem zprávy přímo na disk.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-190">In this case, set the `MaxReceivedMessageSize` to an extremely large value, expecting that almost no data is buffered in memory and the message streams directly to disk.</span></span> <span data-ttu-id="d5ec7-191">Pokud by škodlivá zpráva mohla nějakým způsobem vynutit, aby WCF vynutilo data vyrovnávací paměti, místo jejich streamování v tomto případě už `MaxReceivedMessageSize` nechrání zprávu s přístupem k veškeré dostupné paměti.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-191">If a malicious message can somehow force WCF to buffer data instead of streaming it in this case, `MaxReceivedMessageSize` no longer protects against the message accessing all available memory.</span></span>

<span data-ttu-id="d5ec7-192">Pro zmírnění této hrozby existují specifická nastavení kvót u různých komponent zpracování dat WCF, které omezují ukládání do vyrovnávací paměti.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-192">To mitigate this threat, specific quota settings exist on various WCF data-processing components that limit buffering.</span></span> <span data-ttu-id="d5ec7-193">Nejdůležitější z nich je `MaxBufferSize` vlastnost u různých prvků vazby přenosu a standardních vazeb.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-193">The most important of these is the `MaxBufferSize` property on various transport binding elements and standard bindings.</span></span> <span data-ttu-id="d5ec7-194">Při streamování by měla být tato kvóta nastavena s ohledem na maximální velikost paměti, kterou jste ochotni přidělit na jednu zprávu.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-194">When streaming, this quota should be set taking into account the maximum amount of memory you are willing to allocate per message.</span></span> <span data-ttu-id="d5ec7-195">Stejně jako u platí `MaxReceivedMessageSize` , že nastavení nevloží absolutní maximum pro paměťovou spotřebu, ale omezuje ho pouze v rámci konstantního faktoru.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-195">As with `MaxReceivedMessageSize`, the setting does not put an absolute maximum on memory consumption but only limits it to within a constant factor.</span></span> <span data-ttu-id="d5ec7-196">Stejně jako u nástroje `MaxReceivedMessageSize` si pamatujte na možnost souběžného zpracování několika zpráv.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-196">Also, as with `MaxReceivedMessageSize`, be aware of the possibility of multiple messages being processed simultaneously.</span></span>

### <a name="maxbuffersize-details"></a><span data-ttu-id="d5ec7-197">Podrobnosti o MaxBufferSize</span><span class="sxs-lookup"><span data-stu-id="d5ec7-197">MaxBufferSize Details</span></span>

<span data-ttu-id="d5ec7-198">`MaxBufferSize`Vlastnost omezuje všechny hromadné vyrovnávací paměti WCF.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-198">The `MaxBufferSize` property limits any bulk buffering WCF does.</span></span> <span data-ttu-id="d5ec7-199">Například technologie WCF vždycky ukládá do vyrovnávací paměti hlavičku SOAP a chyby protokolu SOAP a také všechny části MIME, které se v přirozeném pořadí čtení ve zprávě mechanizmus pro optimalizaci přenosu zpráv (MTOM) nepoužívají.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-199">For example, WCF always buffers SOAP headers and SOAP faults, as well as any MIME parts found to be not in the natural reading order in an Message Transmission Optimization Mechanism (MTOM) message.</span></span> <span data-ttu-id="d5ec7-200">Toto nastavení omezuje velikost vyrovnávací paměti ve všech těchto případech.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-200">This setting limits the amount of buffering in all these cases.</span></span>

<span data-ttu-id="d5ec7-201">Služba WCF to dosahuje předáním `MaxBufferSize` hodnoty do různých komponent, které se mohou ukládat do vyrovnávací paměti.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-201">WCF accomplishes this by passing the `MaxBufferSize` value to the various components that may buffer.</span></span> <span data-ttu-id="d5ec7-202">Například některá <xref:System.ServiceModel.Channels.Message.CreateMessage%2A> přetížení <xref:System.ServiceModel.Channels.Message> třídy přebírají `maxSizeOfHeaders` parametr.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-202">For example, some <xref:System.ServiceModel.Channels.Message.CreateMessage%2A> overloads of the <xref:System.ServiceModel.Channels.Message> class take a `maxSizeOfHeaders` parameter.</span></span> <span data-ttu-id="d5ec7-203">Technologie WCF předá `MaxBufferSize` hodnotu tomuto parametru, aby omezila velikost vyrovnávací paměti hlaviček SOAP.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-203">WCF passes the `MaxBufferSize` value to this parameter to limit the amount of SOAP header buffering.</span></span> <span data-ttu-id="d5ec7-204">Je důležité nastavit tento parametr při <xref:System.ServiceModel.Channels.Message> přímém použití třídy.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-204">It is important to set this parameter when using the <xref:System.ServiceModel.Channels.Message> class directly.</span></span> <span data-ttu-id="d5ec7-205">Obecně platí, že při použití komponenty ve službě WCF, která přijímá parametry kvóty, je důležité pochopit dopady zabezpečení těchto parametrů a správně je nastavit.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-205">In general, when using a component in WCF that takes quota parameters, it is important to understand the security implications of these parameters and set them correctly.</span></span>

<span data-ttu-id="d5ec7-206">Kodér zpráv MTOM má také `MaxBufferSize` nastavení.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-206">The MTOM message encoder also has a `MaxBufferSize` setting.</span></span> <span data-ttu-id="d5ec7-207">Při použití standardních vazeb je tato hodnota nastavena automaticky na hodnotu transportní úrovně `MaxBufferSize` .</span><span class="sxs-lookup"><span data-stu-id="d5ec7-207">When using standard bindings, this is set automatically to the transport-level `MaxBufferSize` value.</span></span> <span data-ttu-id="d5ec7-208">Při použití prvku vazby kodéru zpráv MTOM k vytvoření vlastní vazby je však důležité nastavit `MaxBufferSize` vlastnost na bezpečnou hodnotu při použití streamování.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-208">However, when using the MTOM message encoder binding element to construct a custom binding, it is important to set the `MaxBufferSize` property to a safe value when streaming is used.</span></span>

## <a name="xml-based-streaming-attacks"></a><span data-ttu-id="d5ec7-209">Útoky streamování založené na XML</span><span class="sxs-lookup"><span data-stu-id="d5ec7-209">XML-Based Streaming Attacks</span></span>

<span data-ttu-id="d5ec7-210">`MaxBufferSize` samotný není dostačující pro zajištění, že se WCF nedá vynutit do vyrovnávací paměti, když se očekává streamování.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-210">`MaxBufferSize` alone is not enough to ensure that WCF cannot be forced into buffering when streaming is expected.</span></span> <span data-ttu-id="d5ec7-211">Například čtečky XML WCF vždy ukládají do vyrovnávací paměti celou počáteční značku XML elementu při počátečním čtení nového prvku.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-211">For example, the WCF XML readers always buffer the entire XML element start tag when starting to read a new element.</span></span> <span data-ttu-id="d5ec7-212">To se provádí tak, že se správně zpracovávají obory názvů a atributy.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-212">This is done so that namespaces and attributes are properly processed.</span></span> <span data-ttu-id="d5ec7-213">Pokud `MaxReceivedMessageSize` je nakonfigurován tak, aby byl velký (například pokud chcete povolit scénář přímého streamování velkých souborů), může být vytvořena škodlivá zpráva, kde je celá tělo zprávy velkým počátečním tagem elementu XML.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-213">If `MaxReceivedMessageSize` is configured to be large (for example, to enable a direct-to-disk large file streaming scenario), a malicious message may be constructed where the entire message body is a large XML element start tag.</span></span> <span data-ttu-id="d5ec7-214">Pokus o jeho čtení má za následek <xref:System.OutOfMemoryException> .</span><span class="sxs-lookup"><span data-stu-id="d5ec7-214">An attempt to read it results in an <xref:System.OutOfMemoryException>.</span></span> <span data-ttu-id="d5ec7-215">Toto je jeden z mnoha možných útoků DOS založených na jazyce XML, které je možné zmírnit pomocí kvót čtečky XML, popsané v části "používání XML bezpečně" dále v tomto tématu.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-215">This is one of many possible XML-based denial-of-service attacks that can all be mitigated using XML reader quotas, discussed in the "Using XML Safely" section later in this topic.</span></span> <span data-ttu-id="d5ec7-216">Při streamování je obzvláště důležité nastavit všechny tyto kvóty.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-216">When streaming, it is especially important to set all of these quotas.</span></span>

### <a name="mixing-streaming-and-buffering-programming-models"></a><span data-ttu-id="d5ec7-217">Kombinování streamování a programovacích modelů do vyrovnávací paměti</span><span class="sxs-lookup"><span data-stu-id="d5ec7-217">Mixing Streaming and Buffering Programming Models</span></span>

<span data-ttu-id="d5ec7-218">Mnoho možných útoků nastane z kombinování streamování a nestreamování programovacích modelů ve stejné službě.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-218">Many possible attacks arise from mixing streaming and non-streaming programming models in the same service.</span></span> <span data-ttu-id="d5ec7-219">Předpokládejme, že existuje kontrakt služby se dvěma operacemi: jedna <xref:System.IO.Stream> a druhá má pole nějakého vlastního typu.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-219">Suppose there is a service contract with two operations: one takes a <xref:System.IO.Stream> and another takes an array of some custom type.</span></span> <span data-ttu-id="d5ec7-220">Předpokládejme také, že `MaxReceivedMessageSize` je nastavena na velkou hodnotu, aby první operace mohla zpracovat velké datové proudy.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-220">Suppose also that `MaxReceivedMessageSize` is set to a large value to enable the first operation to process large streams.</span></span> <span data-ttu-id="d5ec7-221">To bohužel znamená, že velké zprávy se teď dají poslat druhé operaci zároveň a deserializace ukládá data v paměti jako pole před zavoláním operace.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-221">Unfortunately, this means that large messages can now be sent to the second operation as well, and the deserializer buffers data in memory as an array before the operation is called.</span></span> <span data-ttu-id="d5ec7-222">Toto je potenciální útok na útok typu DOS (Denial-of-Service): `MaxBufferSize` kvóta neomezuje velikost textu zprávy, což je to, s čím je deserializátor pracuje.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-222">This is a potential denial-of-service attack: the `MaxBufferSize` quota does not limit the size of the message body, which is what the deserializer works with.</span></span>

<span data-ttu-id="d5ec7-223">Z tohoto důvodu Vyhněte se kombinování operací založených na streamech a nestreamování v rámci stejné smlouvy.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-223">For this reason, avoid mixing stream-based and non-streamed operations in the same contract.</span></span> <span data-ttu-id="d5ec7-224">Pokud je nezbytně nutné kombinovat dva programovací modely, použijte následující opatření:</span><span class="sxs-lookup"><span data-stu-id="d5ec7-224">If you absolutely must mix the two programming models, use the following precautions:</span></span>

- <span data-ttu-id="d5ec7-225">Vypněte <xref:System.Runtime.Serialization.IExtensibleDataObject> funkci nastavením <xref:System.ServiceModel.ServiceBehaviorAttribute.IgnoreExtensionDataObject%2A> vlastnosti na <xref:System.ServiceModel.ServiceBehaviorAttribute> `true` .</span><span class="sxs-lookup"><span data-stu-id="d5ec7-225">Turn off the <xref:System.Runtime.Serialization.IExtensibleDataObject> feature by setting the <xref:System.ServiceModel.ServiceBehaviorAttribute.IgnoreExtensionDataObject%2A> property of the <xref:System.ServiceModel.ServiceBehaviorAttribute> to `true`.</span></span> <span data-ttu-id="d5ec7-226">Tím se zajistí, že se deserializovat jenom členové, kteří jsou součástí kontraktu.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-226">This ensures that only members that are a part of the contract are deserialized.</span></span>

- <span data-ttu-id="d5ec7-227">Nastavte <xref:System.Runtime.Serialization.DataContractSerializer.MaxItemsInObjectGraph%2A> vlastnost <xref:System.Runtime.Serialization.DataContractSerializer> na bezpečnou hodnotu.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-227">Set the <xref:System.Runtime.Serialization.DataContractSerializer.MaxItemsInObjectGraph%2A> property of the <xref:System.Runtime.Serialization.DataContractSerializer> to a safe value.</span></span> <span data-ttu-id="d5ec7-228">Tato kvóta je také k dispozici v <xref:System.ServiceModel.ServiceBehaviorAttribute> atributu nebo prostřednictvím konfigurace.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-228">This quota is also available on the <xref:System.ServiceModel.ServiceBehaviorAttribute> attribute or through configuration.</span></span> <span data-ttu-id="d5ec7-229">Tato kvóta omezuje počet objektů, které jsou deserializovány v jedné epizodě deserializace.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-229">This quota limits the number of objects that are deserialized in one deserialization episode.</span></span> <span data-ttu-id="d5ec7-230">Obvykle se každý parametr operace nebo část těla zprávy v kontraktu zprávy deserializovat v jedné epizodě.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-230">Normally, each operation parameter or message body part in a message contract is deserialized in one episode.</span></span> <span data-ttu-id="d5ec7-231">Při deserializaci polí se každá položka pole počítá jako samostatný objekt.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-231">When deserializing arrays, each array entry is counted as a separate object.</span></span>

- <span data-ttu-id="d5ec7-232">Nastavte všechny kvóty čtečky XML na bezpečné hodnoty.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-232">Set all of the XML reader quotas to safe values.</span></span> <span data-ttu-id="d5ec7-233">Věnujte pozornost <xref:System.Xml.XmlDictionaryReaderQuotas.MaxDepth%2A> , a <xref:System.Xml.XmlDictionaryReaderQuotas.MaxStringContentLength%2A> <xref:System.Xml.XmlDictionaryReaderQuotas.MaxArrayLength%2A> a vyhnete se řetězcům v operacích, které nestreamují.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-233">Pay attention to <xref:System.Xml.XmlDictionaryReaderQuotas.MaxDepth%2A>, <xref:System.Xml.XmlDictionaryReaderQuotas.MaxStringContentLength%2A>, and <xref:System.Xml.XmlDictionaryReaderQuotas.MaxArrayLength%2A> and avoid strings in non-streaming operations.</span></span>

- <span data-ttu-id="d5ec7-234">Projděte si seznam známých typů, přičemž mějte na paměti, že některé z nich lze kdykoli vytvořit. (Další informace naleznete v části "prevence načítání nezamýšlených typů" dále v tomto tématu).</span><span class="sxs-lookup"><span data-stu-id="d5ec7-234">Review the list of known types, keeping in mind that any one of them can be instantiated at any time (see the "Preventing Unintended Types from Being Loaded" section later in this topic).</span></span>

- <span data-ttu-id="d5ec7-235">Nepoužívejte žádné typy, které implementují <xref:System.Xml.Serialization.IXmlSerializable> rozhraní, které ukládá do vyrovnávací paměti velké množství dat.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-235">Do not use any types that implement the <xref:System.Xml.Serialization.IXmlSerializable> interface that buffer a lot of data.</span></span> <span data-ttu-id="d5ec7-236">Nepřidávat takové typy do seznamu známých typů.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-236">Do not add such types to the list of known types.</span></span>

- <span data-ttu-id="d5ec7-237">Nepoužívejte pole, <xref:System.Xml.XmlElement> pole <xref:System.Xml.XmlNode> <xref:System.Byte> nebo typy, které jsou implementovány <xref:System.Runtime.Serialization.ISerializable> ve smlouvě.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-237">Do not use the <xref:System.Xml.XmlElement>, <xref:System.Xml.XmlNode> arrays, <xref:System.Byte> arrays, or types that implement <xref:System.Runtime.Serialization.ISerializable> in a contract.</span></span>

- <span data-ttu-id="d5ec7-238">Nepoužívejte pole, <xref:System.Xml.XmlElement> pole <xref:System.Xml.XmlNode> <xref:System.Byte> nebo typy, které jsou implementovány <xref:System.Runtime.Serialization.ISerializable> v seznamu známých typů.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-238">Do not use the <xref:System.Xml.XmlElement>, <xref:System.Xml.XmlNode> arrays, <xref:System.Byte> arrays, or types that implement <xref:System.Runtime.Serialization.ISerializable> in the list of known types.</span></span>

<span data-ttu-id="d5ec7-239">Předchozí opatření platí v případě, že nestreamovaná operace používá <xref:System.Runtime.Serialization.DataContractSerializer> .</span><span class="sxs-lookup"><span data-stu-id="d5ec7-239">The preceding precautions apply when the non-streamed operation uses the <xref:System.Runtime.Serialization.DataContractSerializer>.</span></span> <span data-ttu-id="d5ec7-240">Nikdy nekombinujte streamování a nestreamující programovací modely na stejné službě, pokud používáte <xref:System.Xml.Serialization.XmlSerializer> , protože nemá ochranu <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior.MaxItemsInObjectGraph%2A> kvóty.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-240">Never mix streaming and non-streaming programming models on the same service if you are using the <xref:System.Xml.Serialization.XmlSerializer>, because it does not have the protection of the <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior.MaxItemsInObjectGraph%2A> quota.</span></span>

### <a name="slow-stream-attacks"></a><span data-ttu-id="d5ec7-241">Pomalé útoky přes Stream</span><span class="sxs-lookup"><span data-stu-id="d5ec7-241">Slow Stream Attacks</span></span>

<span data-ttu-id="d5ec7-242">Třída útoků s cílem odepření služby streamování nezahrnuje spotřebu paměti.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-242">A class of streaming denial-of-service attacks does not involve memory consumption.</span></span> <span data-ttu-id="d5ec7-243">Místo toho útok zahrnuje pomalý odesílatel nebo přijímač dat.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-243">Instead, the attack involves a slow sender or receiver of data.</span></span> <span data-ttu-id="d5ec7-244">Při čekání na odeslání nebo přijetí dat dojde k vyčerpání prostředků, jako jsou například vlákna a dostupná připojení.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-244">While waiting for the data to be sent or received, resources such as threads and available connections are exhausted.</span></span> <span data-ttu-id="d5ec7-245">Tato situace může nastat buď v důsledku zneužití škodlivého útoku, nebo z legitimního odesílatele nebo příjemce na pomalé síťové připojení.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-245">This situation could arise either as a result of a malicious attack or from a legitimate sender/receiver on a slow network connection.</span></span>

<span data-ttu-id="d5ec7-246">Pro zmírnění těchto útoků nastavte časový limit přenosu správně.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-246">To mitigate these attacks, set the transport time-outs correctly.</span></span> <span data-ttu-id="d5ec7-247">Další informace najdete v tématu [přenosové kvóty](transport-quotas.md).</span><span class="sxs-lookup"><span data-stu-id="d5ec7-247">For more information, see [Transport Quotas](transport-quotas.md).</span></span> <span data-ttu-id="d5ec7-248">V druhé době nikdy nepoužívejte `Read` synchronní `Write` operace ani operace při práci s datovými proudy ve službě WCF.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-248">Secondly, never use synchronous `Read` or `Write` operations when working with streams in WCF.</span></span>

## <a name="using-xml-safely"></a><span data-ttu-id="d5ec7-249">Bezpečné používání XML</span><span class="sxs-lookup"><span data-stu-id="d5ec7-249">Using XML Safely</span></span>

> [!NOTE]
> <span data-ttu-id="d5ec7-250">I když je tato část o souboru XML, informace se vztahují také na dokumenty JavaScript Object Notation (JSON).</span><span class="sxs-lookup"><span data-stu-id="d5ec7-250">Although this section is about XML, the information also applies to JavaScript Object Notation (JSON) documents.</span></span> <span data-ttu-id="d5ec7-251">Kvóty fungují podobně, a to pomocí [mapování mezi JSON a XML](mapping-between-json-and-xml.md).</span><span class="sxs-lookup"><span data-stu-id="d5ec7-251">The quotas work similarly, using [Mapping Between JSON and XML](mapping-between-json-and-xml.md).</span></span>

### <a name="secure-xml-readers"></a><span data-ttu-id="d5ec7-252">Zabezpečení čtecích zařízení XML</span><span class="sxs-lookup"><span data-stu-id="d5ec7-252">Secure XML Readers</span></span>

<span data-ttu-id="d5ec7-253">Informační sada XML tvoří základ všech zpracování zpráv ve službě WCF.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-253">The XML Infoset forms the basis of all message processing in WCF.</span></span> <span data-ttu-id="d5ec7-254">Při přijímání dat XML z nedůvěryhodného zdroje existuje řada možností útoku DOS, které je nutné zmírnit.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-254">When accepting XML data from an untrusted source, a number of denial-of-service attack possibilities exist that must be mitigated.</span></span> <span data-ttu-id="d5ec7-255">WCF poskytuje speciální zabezpečené čtecí zařízení XML.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-255">WCF provides special, secure XML readers.</span></span> <span data-ttu-id="d5ec7-256">Tito čtenáři se vytvářejí automaticky při použití některého ze standardních kódování ve službě WCF (text, Binary nebo MTOM).</span><span class="sxs-lookup"><span data-stu-id="d5ec7-256">These readers are created automatically when using one of the standard encodings in WCF (text, binary, or MTOM).</span></span>

<span data-ttu-id="d5ec7-257">Některé funkce zabezpečení u těchto čtecích zařízení jsou vždycky aktivní.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-257">Some of the security features on these readers are always active.</span></span> <span data-ttu-id="d5ec7-258">Čtenáři například nikdy nezpracovávají definice typu dokumentu (DTD), které jsou potenciálním zdrojem útoků DOS a by se nikdy neměly zobrazovat v legitimních zprávách SOAP.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-258">For example, the readers never process document type definitions (DTDs), which are a potential source of denial-of-service attacks and should never appear in legitimate SOAP messages.</span></span> <span data-ttu-id="d5ec7-259">K dalším funkcím zabezpečení patří kvóty čtecího zařízení, které je nutné nakonfigurovat, které jsou popsány v následující části.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-259">Other security features include reader quotas that must be configured, which are described in the following section.</span></span>

<span data-ttu-id="d5ec7-260">Při práci přímo s čtecími moduly XML (například při psaní vlastního kodéru nebo při práci přímo s <xref:System.ServiceModel.Channels.Message> třídou) vždy používejte zabezpečené čtecí zařízení WCF, pokud je pravděpodobné, že budete pracovat s nedůvěryhodnými daty.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-260">When working directly with XML readers (such as when writing your own custom encoder or when working directly with the <xref:System.ServiceModel.Channels.Message> class), always use the WCF secure readers when there is a chance of working with untrusted data.</span></span> <span data-ttu-id="d5ec7-261">Vytvořte zabezpečené čtecí zařízení voláním jednoho ze statických metod výrobní metody <xref:System.Xml.XmlDictionaryReader.CreateTextReader%2A> , <xref:System.Xml.XmlDictionaryReader.CreateBinaryReader%2A> nebo <xref:System.Xml.XmlDictionaryReader.CreateMtomReader%2A> na <xref:System.Xml.XmlDictionaryReader> třídu.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-261">Create the secure readers by calling one of the static factory method overloads of <xref:System.Xml.XmlDictionaryReader.CreateTextReader%2A>, <xref:System.Xml.XmlDictionaryReader.CreateBinaryReader%2A>, or <xref:System.Xml.XmlDictionaryReader.CreateMtomReader%2A> on the <xref:System.Xml.XmlDictionaryReader> class.</span></span> <span data-ttu-id="d5ec7-262">Při vytváření čtecího modulu předejte hodnoty zabezpečené kvóty.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-262">When creating a reader, pass in secure quota values.</span></span> <span data-ttu-id="d5ec7-263">Nevolejte `Create` přetížení metod.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-263">Do not call the `Create` method overloads.</span></span> <span data-ttu-id="d5ec7-264">Nevytvářejí čtečku WCF.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-264">These do not create a WCF reader.</span></span> <span data-ttu-id="d5ec7-265">Místo toho se vytvoří čtenář, který není chráněný funkcemi zabezpečení popsanými v této části.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-265">Instead, a reader is created that is not protected by the security features described in this section.</span></span>

### <a name="reader-quotas"></a><span data-ttu-id="d5ec7-266">Kvóty čtecího modulu</span><span class="sxs-lookup"><span data-stu-id="d5ec7-266">Reader Quotas</span></span>

<span data-ttu-id="d5ec7-267">Zabezpečené čtečky XML mají pět konfigurovatelných kvót.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-267">The secure XML readers have five configurable quotas.</span></span> <span data-ttu-id="d5ec7-268">Ty se obvykle konfigurují pomocí `ReaderQuotas` vlastnosti u elementů vazby kódování nebo standardních vazeb nebo pomocí <xref:System.Xml.XmlDictionaryReaderQuotas> objektu předaného při vytváření čtecího modulu.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-268">These are normally configured using the `ReaderQuotas` property on the encoding binding elements or standard bindings, or by using an <xref:System.Xml.XmlDictionaryReaderQuotas> object passed when creating a reader.</span></span>

#### <a name="maxbytesperread"></a><span data-ttu-id="d5ec7-269">MaxBytesPerRead</span><span class="sxs-lookup"><span data-stu-id="d5ec7-269">MaxBytesPerRead</span></span>

<span data-ttu-id="d5ec7-270">Tato kvóta omezuje počet bajtů, které jsou čteny v rámci jedné `Read` operace při čtení počáteční značky elementu a jejích atributů.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-270">This quota limits the number of bytes that are read in a single `Read` operation when reading the element start tag and its attributes.</span></span> <span data-ttu-id="d5ec7-271">(V nestreamované případech se název elementu sám nepočítá s kvótou.) <xref:System.Xml.XmlDictionaryReaderQuotas.MaxBytesPerRead%2A> je důležité z následujících důvodů:</span><span class="sxs-lookup"><span data-stu-id="d5ec7-271">(In non-streamed cases, the element name itself is not counted against the quota.) <xref:System.Xml.XmlDictionaryReaderQuotas.MaxBytesPerRead%2A> is important for the following reasons:</span></span>

- <span data-ttu-id="d5ec7-272">Název elementu a jeho atributy jsou při čtení vždy uloženy do vyrovnávací paměti.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-272">The element name and its attributes are always buffered in memory when they are being read.</span></span> <span data-ttu-id="d5ec7-273">Proto je důležité nastavit tuto kvótu správně v režimu streamování, aby se zabránilo nadměrnému ukládání do vyrovnávací paměti, když se očekává streamování.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-273">Therefore, it is important to set this quota correctly in streaming mode to prevent excessive buffering when streaming is expected.</span></span> <span data-ttu-id="d5ec7-274">`MaxDepth`Informace o skutečném objemu ukládání do vyrovnávací paměti najdete v části kvóta.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-274">See the `MaxDepth` quota section for information about the actual amount of buffering that takes place.</span></span>

- <span data-ttu-id="d5ec7-275">Příliš mnoho atributů XML může použít neúměrný čas zpracování, protože názvy atributů musí být zkontrolovány pro jedinečnost.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-275">Having too many XML attributes may use up disproportionate processing time because attribute names have to be checked for uniqueness.</span></span> <span data-ttu-id="d5ec7-276">`MaxBytesPerRead` snižuje riziko této hrozby.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-276">`MaxBytesPerRead` mitigates this threat.</span></span>

#### <a name="maxdepth"></a><span data-ttu-id="d5ec7-277">MaxDepth</span><span class="sxs-lookup"><span data-stu-id="d5ec7-277">MaxDepth</span></span>

<span data-ttu-id="d5ec7-278">Tato kvóta omezuje maximální hloubku vnořování prvků XML.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-278">This quota limits the maximum nesting depth of XML elements.</span></span> <span data-ttu-id="d5ec7-279">Například dokument " \<A> \<B> \<C/> \</B> \</A> " má vnořenou hloubku tři.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-279">For example, the document "\<A>\<B>\<C/>\</B>\</A>" has a nesting depth of three.</span></span> <span data-ttu-id="d5ec7-280"><xref:System.Xml.XmlDictionaryReaderQuotas.MaxDepth%2A> je důležité z následujících důvodů:</span><span class="sxs-lookup"><span data-stu-id="d5ec7-280"><xref:System.Xml.XmlDictionaryReaderQuotas.MaxDepth%2A> is important for the following reasons:</span></span>

- <span data-ttu-id="d5ec7-281">`MaxDepth` spolupracuje s `MaxBytesPerRead` : čtenář vždycky uchovává data v paměti pro aktuální prvek a všechny jeho nadřazené prvky, takže maximální spotřeba paměti čtecího zařízení je úměrná produktu těchto dvou nastavení.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-281">`MaxDepth` interacts with `MaxBytesPerRead`: the reader always keeps data in memory for the current element and all of its ancestors, so the maximum memory consumption of the reader is proportional to the product of these two settings.</span></span>

- <span data-ttu-id="d5ec7-282">Při deserializaci diagramu hluboko vnořeného objektu je pro deserializaci nucen přístup k celému zásobníku a vyvolat neobnovitelné <xref:System.StackOverflowException> .</span><span class="sxs-lookup"><span data-stu-id="d5ec7-282">When deserializing a deeply-nested object graph, the deserializer is forced to access the entire stack and throw an unrecoverable <xref:System.StackOverflowException>.</span></span> <span data-ttu-id="d5ec7-283">Mezi vnořenými a vnořenými objekty XML existuje přímá korelace pro <xref:System.Runtime.Serialization.DataContractSerializer> a <xref:System.Xml.Serialization.XmlSerializer> .</span><span class="sxs-lookup"><span data-stu-id="d5ec7-283">A direct correlation exists between XML nesting and object nesting for both the <xref:System.Runtime.Serialization.DataContractSerializer> and the <xref:System.Xml.Serialization.XmlSerializer>.</span></span> <span data-ttu-id="d5ec7-284">`MaxDepth`Tuto hrozbu můžete zmírnit pomocí této hrozby.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-284">Use `MaxDepth` to mitigate this threat.</span></span>

#### <a name="maxnametablecharcount"></a><span data-ttu-id="d5ec7-285">MaxNameTableCharCount</span><span class="sxs-lookup"><span data-stu-id="d5ec7-285">MaxNameTableCharCount</span></span>

<span data-ttu-id="d5ec7-286">Tato kvóta omezuje velikost *NameTable*čtenářů.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-286">This quota limits the size of the reader’s *nametable*.</span></span> <span data-ttu-id="d5ec7-287">NameTable obsahuje určité řetězce (například obory názvů a předpony), které byly zjištěny při zpracování dokumentu XML.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-287">The nametable contains certain strings (such as namespaces and prefixes) that are encountered when processing an XML document.</span></span> <span data-ttu-id="d5ec7-288">Vzhledem k tomu, že jsou tyto řetězce uloženy do vyrovnávací paměti, nastavte tuto kvótu tak, aby nedocházelo k nadměrnému ukládání do vyrovnávací paměti, pokud je</span><span class="sxs-lookup"><span data-stu-id="d5ec7-288">As these strings are buffered in memory, set this quota to prevent excessive buffering when streaming is expected.</span></span>

#### <a name="maxstringcontentlength"></a><span data-ttu-id="d5ec7-289">MaxStringContentLength</span><span class="sxs-lookup"><span data-stu-id="d5ec7-289">MaxStringContentLength</span></span>

<span data-ttu-id="d5ec7-290">Tato kvóta omezuje maximální velikost řetězce, kterou čtecí modul XML vrátí.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-290">This quota limits the maximum string size that the XML reader returns.</span></span> <span data-ttu-id="d5ec7-291">Tato kvóta neomezuje spotřebu paměti v samotném čtecím modulu XML, ale v komponentě, která používá čtecí modul.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-291">This quota does not limit memory consumption in the XML reader itself, but in the component that is using the reader.</span></span> <span data-ttu-id="d5ec7-292">Například pokud <xref:System.Runtime.Serialization.DataContractSerializer> používá čtecí modul zabezpečený s, neprovádí <xref:System.Xml.XmlDictionaryReaderQuotas.MaxStringContentLength%2A> deserializaci řetězce větší než tato kvóta.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-292">For example, when the <xref:System.Runtime.Serialization.DataContractSerializer> uses a reader secured with <xref:System.Xml.XmlDictionaryReaderQuotas.MaxStringContentLength%2A>, it does not deserialize strings larger than this quota.</span></span> <span data-ttu-id="d5ec7-293">Při <xref:System.Xml.XmlDictionaryReader> přímém použití třídy ne všechny metody respektují tuto kvótu, ale pouze metody, které jsou určeny konkrétně pro čtení řetězců, jako je například <xref:System.Xml.XmlDictionaryReader.ReadContentAsString%2A> metoda.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-293">When using the <xref:System.Xml.XmlDictionaryReader> class directly, not all methods respect this quota, but only the methods that are specifically designed to read strings, such as the <xref:System.Xml.XmlDictionaryReader.ReadContentAsString%2A> method.</span></span> <span data-ttu-id="d5ec7-294"><xref:System.Xml.XmlReader.Value%2A>Tato kvóta nemá vliv na vlastnost čtecího modulu, a proto by neměla být použita, pokud je tato kvóta potřebná.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-294">The <xref:System.Xml.XmlReader.Value%2A> property on the reader is not affected by this quota, and thus should not be used when the protection this quota provides is necessary.</span></span>

#### <a name="maxarraylength"></a><span data-ttu-id="d5ec7-295">MaxArrayLength</span><span class="sxs-lookup"><span data-stu-id="d5ec7-295">MaxArrayLength</span></span>

<span data-ttu-id="d5ec7-296">Tato kvóta omezuje maximální velikost pole primitivních elementů, které vrátí čtecí modul XML, včetně bajtových polí.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-296">This quota limits the maximum size of an array of primitives that the XML reader returns, including byte arrays.</span></span> <span data-ttu-id="d5ec7-297">Tato kvóta neomezuje spotřebu paměti v samotném čtecím modulu XML, ale v jakékoli součásti, která používá čtecí modul.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-297">This quota does not limit memory consumption in the XML reader itself, but in whatever component that is using the reader.</span></span> <span data-ttu-id="d5ec7-298">Například pokud <xref:System.Runtime.Serialization.DataContractSerializer> používá čtecí modul zabezpečený s, neprovádí <xref:System.Xml.XmlDictionaryReaderQuotas.MaxArrayLength%2A> deserializaci polí bajtů větší než tato kvóta.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-298">For example, when the <xref:System.Runtime.Serialization.DataContractSerializer> uses a reader secured with <xref:System.Xml.XmlDictionaryReaderQuotas.MaxArrayLength%2A>, it does not deserialize byte arrays larger than this quota.</span></span> <span data-ttu-id="d5ec7-299">Je důležité nastavit tuto kvótu při pokusu o smíchání streamování a programových modelů ve vyrovnávací paměti v rámci jedné smlouvy.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-299">It is important to set this quota when attempting to mix streaming and buffered programming models in a single contract.</span></span> <span data-ttu-id="d5ec7-300">Mějte na paměti, že při <xref:System.Xml.XmlDictionaryReader> přímém použití třídy jsou pouze metody, které jsou určeny konkrétně pro čtení polí libovolné velikosti určitých primitivních typů, například <xref:System.Xml.XmlDictionaryReader.ReadInt32Array%2A> , s ohledem na tuto kvótu.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-300">Keep in mind that when using the <xref:System.Xml.XmlDictionaryReader> class directly, only the methods that are specifically designed to read arrays of arbitrary size of certain primitive types, such as <xref:System.Xml.XmlDictionaryReader.ReadInt32Array%2A>, respect this quota.</span></span>

## <a name="threats-specific-to-the-binary-encoding"></a><span data-ttu-id="d5ec7-301">Hrozby specifické pro binární kódování</span><span class="sxs-lookup"><span data-stu-id="d5ec7-301">Threats Specific to the Binary Encoding</span></span>

<span data-ttu-id="d5ec7-302">Rozhraní WCF kódování XML podporuje funkci *řetězce slovníku* .</span><span class="sxs-lookup"><span data-stu-id="d5ec7-302">The binary XML encoding WCF supports includes a *dictionary strings* feature.</span></span> <span data-ttu-id="d5ec7-303">Velký řetězec může být kódovaný pouze v několika bajtech.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-303">A large string may be encoded using only a few bytes.</span></span> <span data-ttu-id="d5ec7-304">To umožňuje výrazné zvýšení výkonu, ale přináší nové hrozby při odepření služby, které je potřeba zmírnit.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-304">This enables significant performance gains, but introduces new denial-of-service threats that must be mitigated.</span></span>

<span data-ttu-id="d5ec7-305">Existují dva druhy slovníků: *statické* a *dynamické*.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-305">There are two kinds of dictionaries: *static* and *dynamic*.</span></span> <span data-ttu-id="d5ec7-306">Statický slovník je vestavěný seznam dlouhých řetězců, které mohou být reprezentovány pomocí krátkého kódu v binárním kódování.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-306">The static dictionary is a built-in list of long strings that may be represented using a short code in the binary encoding.</span></span> <span data-ttu-id="d5ec7-307">Tento seznam řetězců je opraven při vytvoření čtecího modulu a nelze jej upravit.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-307">This list of strings is fixed when the reader is created and cannot be modified.</span></span> <span data-ttu-id="d5ec7-308">Žádný z řetězců ve statickém slovníku, který služba WCF ve výchozím nastavení používá, je dostatečně velký, aby mohl představovat vážnou hrozbu pro odepření služby, i když je stále možné je použít při útoku na rozšíření slovníku.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-308">None of the strings in the static dictionary that WCF uses by default are sufficiently large to pose a serious denial-of-service threat, although they may still be used in a dictionary expansion attack.</span></span> <span data-ttu-id="d5ec7-309">V pokročilých scénářích, kde zadáváte vlastní statický slovník, buďte opatrní při zavádění velkých řetězců slovníku.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-309">In advanced scenarios where you supply your own static dictionary, be careful when introducing large dictionary strings.</span></span>

<span data-ttu-id="d5ec7-310">Funkce dynamického slovníku umožňuje zprávám definovat vlastní řetězce a přidružit je k krátkým kódům.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-310">The dynamic dictionaries feature allows messages to define their own strings and associate them with short codes.</span></span> <span data-ttu-id="d5ec7-311">Tyto mapování řetězců na kód jsou uchovávány v paměti během celé komunikační relace, takže následné zprávy nemusí znovu odesílat řetězce a mohou využívat již definované kódy.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-311">These string-to-code mappings are kept in memory during the entire communication session, such that subsequent messages do not have to resend the strings and can utilize codes that are already defined.</span></span> <span data-ttu-id="d5ec7-312">Tyto řetězce mohou mít libovolnou délku, a proto můžou představovat vážnou hrozbu, než jaké jsou ve statickém slovníku.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-312">These strings may be of arbitrary length and thus pose a more serious threat than those in the static dictionary.</span></span>

<span data-ttu-id="d5ec7-313">První hrozba, kterou je nutné zmírnit, je možnost dynamického slovníku (tabulka mapování řetězců na kód), která se přestává být příliš velká.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-313">The first threat that must be mitigated is the possibility of the dynamic dictionary (the string-to-code mapping table) becoming too large.</span></span> <span data-ttu-id="d5ec7-314">Tento slovník se může rozšířit v průběhu několika zpráv, takže `MaxReceivedMessageSize` kvóta nenabízí ochranu, protože platí jenom pro každou zprávu zvlášť.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-314">This dictionary may be expanded over the course of several messages, and so the `MaxReceivedMessageSize` quota offers no protection because it applies only to each message separately.</span></span> <span data-ttu-id="d5ec7-315">Proto <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement.MaxSessionSize%2A> existuje samostatná vlastnost v <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement> , která omezuje velikost slovníku.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-315">Therefore, a separate <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement.MaxSessionSize%2A> property exists on the <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement> that limits the size of the dictionary.</span></span>

<span data-ttu-id="d5ec7-316">Na rozdíl od většiny ostatních kvót platí tato kvóta i při psaní zpráv.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-316">Unlike most other quotas, this quota also applies when writing messages.</span></span> <span data-ttu-id="d5ec7-317">Pokud při čtení zprávy dojde k překročení, `QuotaExceededException` je vyvolána jako obvykle.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-317">If it is exceeded when reading a message, the `QuotaExceededException` is thrown as usual.</span></span> <span data-ttu-id="d5ec7-318">Pokud při zápisu zprávy dojde k překročení, budou všechny řetězce, které způsobují překročení kvóty, zapsány tak, jak jsou, bez použití funkce dynamického slovníku.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-318">If it is exceeded when writing a message, any strings that cause the quota to be exceeded are written as-is, without using the dynamic dictionaries feature.</span></span>

### <a name="dictionary-expansion-threats"></a><span data-ttu-id="d5ec7-319">Hrozby rozšíření slovníku</span><span class="sxs-lookup"><span data-stu-id="d5ec7-319">Dictionary Expansion Threats</span></span>

<span data-ttu-id="d5ec7-320">Významná třída binárních útoků vyplývají z rozšíření slovníku.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-320">A significant class of binary-specific attacks arises from dictionary expansion.</span></span> <span data-ttu-id="d5ec7-321">Malá zpráva v binárním formátu může v plně rozbaleném textovém formuláři přepínat na velmi velkou zprávu, pokud má rozsáhlé použití funkce řetězce slovníku.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-321">A small message in binary form may turn into a very large message in fully expanded textual form if it makes extensive use of the string dictionaries feature.</span></span> <span data-ttu-id="d5ec7-322">Faktor rozšíření pro řetězce dynamického slovníku je omezen <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement.MaxSessionSize%2A> kvótou, protože žádný řetězec dynamického slovníku nepřekračuje maximální velikost celého slovníku.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-322">The expansion factor for dynamic dictionary strings is limited by the <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement.MaxSessionSize%2A> quota, because no dynamic dictionary string exceeds the maximum size of the entire dictionary.</span></span>

<span data-ttu-id="d5ec7-323"><xref:System.Xml.XmlDictionaryReaderQuotas.MaxNameTableCharCount%2A>Vlastnosti, `MaxStringContentLength` a `MaxArrayLength` omezují jenom spotřebu paměti.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-323">The <xref:System.Xml.XmlDictionaryReaderQuotas.MaxNameTableCharCount%2A>, `MaxStringContentLength`, and `MaxArrayLength` properties only limit memory consumption.</span></span> <span data-ttu-id="d5ec7-324">Obvykle se nevyžadují ke zmírnění hrozeb v nestreamované míře, protože využití paměti je už omezené nástrojem `MaxReceivedMessageSize` .</span><span class="sxs-lookup"><span data-stu-id="d5ec7-324">They are normally not required to mitigate any threats in the non-streamed usage because memory usage is already limited by `MaxReceivedMessageSize`.</span></span> <span data-ttu-id="d5ec7-325">Počítá ale `MaxReceivedMessageSize` počet předem rozšiřujících bajtů.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-325">However, `MaxReceivedMessageSize` counts pre-expansion bytes.</span></span> <span data-ttu-id="d5ec7-326">Když se používá binární kódování, může využití paměti potenciálně přesahovat `MaxReceivedMessageSize` , protože je omezené jenom faktorem <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement.MaxSessionSize%2A> .</span><span class="sxs-lookup"><span data-stu-id="d5ec7-326">When binary encoding is in use, memory consumption could potentially go beyond `MaxReceivedMessageSize`, limited only by a factor of <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement.MaxSessionSize%2A>.</span></span> <span data-ttu-id="d5ec7-327">Z tohoto důvodu je důležité <xref:System.Xml.XmlDictionaryReaderQuotas.MaxStringContentLength%2A> při použití binárního kódování vždy nastavit všechny kvóty čtenářů (obzvláště).</span><span class="sxs-lookup"><span data-stu-id="d5ec7-327">For this reason, it is important to always set all of the reader quotas (especially <xref:System.Xml.XmlDictionaryReaderQuotas.MaxStringContentLength%2A>) when using the binary encoding.</span></span>

<span data-ttu-id="d5ec7-328">Při použití binárního kódování společně s rozhraním <xref:System.Runtime.Serialization.DataContractSerializer> `IExtensibleDataObject` může být rozhraní nepoužitelné k připojení útoku na rozšíření slovníku.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-328">When using binary encoding together with the <xref:System.Runtime.Serialization.DataContractSerializer>, the `IExtensibleDataObject` interface can be misused to mount a dictionary expansion attack.</span></span> <span data-ttu-id="d5ec7-329">Toto rozhraní v podstatě poskytuje neomezené úložiště pro libovolná data, která nejsou součástí smlouvy.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-329">This interface essentially provides unlimited storage for arbitrary data that is not a part of the contract.</span></span> <span data-ttu-id="d5ec7-330">Pokud kvóty nemůžou být nastavené na nízké úrovni, které `MaxSessionSize` vynásobené `MaxReceivedMessageSize` nepředstavuje problém, zakažte `IExtensibleDataObject` funkci při použití binárního kódování.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-330">If quotas cannot be set low enough such that `MaxSessionSize` multiplied by `MaxReceivedMessageSize` does not pose a problem, disable the `IExtensibleDataObject` feature when using the binary encoding.</span></span> <span data-ttu-id="d5ec7-331">Nastavte `IgnoreExtensionDataObject` vlastnost na `true` `ServiceBehaviorAttribute` atribut.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-331">Set the `IgnoreExtensionDataObject` property to `true` on the `ServiceBehaviorAttribute` attribute.</span></span> <span data-ttu-id="d5ec7-332">Alternativně Neimplementujte `IExtensibleDataObject` rozhraní.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-332">Alternatively, do not implement the `IExtensibleDataObject` interface.</span></span> <span data-ttu-id="d5ec7-333">Další informace najdete v tématu [kontrakty dat kompatibilní s dopředné](forward-compatible-data-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="d5ec7-333">For more information, see [Forward-Compatible Data Contracts](forward-compatible-data-contracts.md).</span></span>

### <a name="quotas-summary"></a><span data-ttu-id="d5ec7-334">Souhrn kvót</span><span class="sxs-lookup"><span data-stu-id="d5ec7-334">Quotas Summary</span></span>

<span data-ttu-id="d5ec7-335">Následující tabulka shrnuje doprovodné materiály k kvótám.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-335">The following table summarizes the guidance about quotas.</span></span>

|<span data-ttu-id="d5ec7-336">Stav</span><span class="sxs-lookup"><span data-stu-id="d5ec7-336">Condition</span></span>|<span data-ttu-id="d5ec7-337">Důležité kvóty k nastavení</span><span class="sxs-lookup"><span data-stu-id="d5ec7-337">Important quotas to set</span></span>|
|---------------|-----------------------------|
|<span data-ttu-id="d5ec7-338">Bez streamování nebo streamování malých zpráv, textu nebo kódování MTOM</span><span class="sxs-lookup"><span data-stu-id="d5ec7-338">No streaming or streaming small messages, text, or MTOM encoding</span></span>|<span data-ttu-id="d5ec7-339">`MaxReceivedMessageSize`, `MaxBytesPerRead` a `MaxDepth`</span><span class="sxs-lookup"><span data-stu-id="d5ec7-339">`MaxReceivedMessageSize`, `MaxBytesPerRead`, and `MaxDepth`</span></span>|
|<span data-ttu-id="d5ec7-340">Bez streamování nebo streamování malých zpráv, binární kódování</span><span class="sxs-lookup"><span data-stu-id="d5ec7-340">No streaming or streaming small messages, binary encoding</span></span>|<span data-ttu-id="d5ec7-341">`MaxReceivedMessageSize`, `MaxSessionSize` a všechny `ReaderQuotas`</span><span class="sxs-lookup"><span data-stu-id="d5ec7-341">`MaxReceivedMessageSize`, `MaxSessionSize`, and all `ReaderQuotas`</span></span>|
|<span data-ttu-id="d5ec7-342">Streamování velkých zpráv, textu nebo kódování MTOM</span><span class="sxs-lookup"><span data-stu-id="d5ec7-342">Streaming large messages, text, or MTOM encoding</span></span>|<span data-ttu-id="d5ec7-343">`MaxBufferSize` a vše `ReaderQuotas`</span><span class="sxs-lookup"><span data-stu-id="d5ec7-343">`MaxBufferSize` and all `ReaderQuotas`</span></span>|
|<span data-ttu-id="d5ec7-344">Streamování velkých zpráv, binární kódování</span><span class="sxs-lookup"><span data-stu-id="d5ec7-344">Streaming large messages, binary encoding</span></span>|<span data-ttu-id="d5ec7-345">`MaxBufferSize`, `MaxSessionSize` a všechny `ReaderQuotas`</span><span class="sxs-lookup"><span data-stu-id="d5ec7-345">`MaxBufferSize`, `MaxSessionSize`, and all `ReaderQuotas`</span></span>|

- <span data-ttu-id="d5ec7-346">Časové limity na úrovni přenosu musí být vždycky nastavené a nikdy nepoužívají synchronní čtení a zápisy, když se streamování používá, bez ohledu na to, jestli jsou streamované velké nebo malé zprávy.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-346">Transport-level time-outs must always be set and never use synchronous reads/writes when streaming is in use, regardless of whether you are streaming large or small messages.</span></span>

- <span data-ttu-id="d5ec7-347">Pokud je kvóta nejistá, nastavte ji na bezpečnou hodnotu, abyste ji nenechali otevřené.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-347">When in doubt about a quota, set it to a safe value rather than leaving it open.</span></span>

## <a name="preventing-malicious-code-execution"></a><span data-ttu-id="d5ec7-348">Zabránění spuštění škodlivého kódu</span><span class="sxs-lookup"><span data-stu-id="d5ec7-348">Preventing Malicious Code Execution</span></span>

<span data-ttu-id="d5ec7-349">Následující obecné třídy hrozeb mohou spustit kód a mít nezamýšlené účinky:</span><span class="sxs-lookup"><span data-stu-id="d5ec7-349">The following general classes of threats can execute code and have unintended effects:</span></span>

- <span data-ttu-id="d5ec7-350">Deserializátor načte škodlivý, nebezpečný nebo citlivý typ zabezpečení.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-350">The deserializer loads a malicious, unsafe, or security-sensitive type.</span></span>

- <span data-ttu-id="d5ec7-351">Příchozí zpráva způsobí, že deserializátor vytvoří instanci normálně bezpečného typu takovým způsobem, že má nezamýšlené důsledky.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-351">An incoming message causes the deserializer to construct an instance of a normally safe type in such a way that it has unintended consequences.</span></span>

<span data-ttu-id="d5ec7-352">Níže uvedené části popisují tyto třídy hrozeb.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-352">The following sections discuss these classes of threats further.</span></span>

## <a name="datacontractserializer"></a><span data-ttu-id="d5ec7-353">DataContractSerializer</span><span class="sxs-lookup"><span data-stu-id="d5ec7-353">DataContractSerializer</span></span>

<span data-ttu-id="d5ec7-354">(Informace o zabezpečení najdete v <xref:System.Xml.Serialization.XmlSerializer> příslušné dokumentaci.) Model zabezpečení pro <xref:System.Xml.Serialization.XmlSerializer> je podobný tomuto <xref:System.Runtime.Serialization.DataContractSerializer> : a liší se hlavně v podrobnostech.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-354">(For security information on the <xref:System.Xml.Serialization.XmlSerializer>, see the relevant documentation.) The security model for the <xref:System.Xml.Serialization.XmlSerializer> is similar to that of the <xref:System.Runtime.Serialization.DataContractSerializer>, and differs mostly in details.</span></span> <span data-ttu-id="d5ec7-355">Například <xref:System.Xml.Serialization.XmlIncludeAttribute> atribut se používá pro zahrnutí typu místo <xref:System.Runtime.Serialization.KnownTypeAttribute> atributu.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-355">For example, the <xref:System.Xml.Serialization.XmlIncludeAttribute> attribute is used for type inclusion instead of the <xref:System.Runtime.Serialization.KnownTypeAttribute> attribute.</span></span> <span data-ttu-id="d5ec7-356">Nicméně některé hrozby, které jsou jedinečné pro, <xref:System.Xml.Serialization.XmlSerializer> jsou popsány dále v tomto tématu.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-356">However, some threats unique to the <xref:System.Xml.Serialization.XmlSerializer> are discussed later in this topic.</span></span>

### <a name="preventing-unintended-types-from-being-loaded"></a><span data-ttu-id="d5ec7-357">Brání načtení nezamýšlených typů.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-357">Preventing Unintended Types from Being Loaded</span></span>

<span data-ttu-id="d5ec7-358">Načítání nezamýšleného typu může mít významné důsledky, zda je typ škodlivý nebo má pouze vedlejší účinky závislé na zabezpečení.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-358">Loading unintended types may have significant consequences, whether the type is malicious or just has security-sensitive side effects.</span></span> <span data-ttu-id="d5ec7-359">Typ může obsahovat zneužitou chybu zabezpečení, provádět akce závislé na zabezpečení v konstruktoru konstruktoru nebo třídy, mít velké paměťové nároky, které usnadňují útoky DoS (Denial of-Service), nebo může vyvolat neobnovitelná výjimky.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-359">A type may contain exploitable security vulnerability, perform security-sensitive actions in its constructor or class constructor, have a large memory footprint that facilitates denial-of-service attacks, or may throw non-recoverable exceptions.</span></span> <span data-ttu-id="d5ec7-360">Typy mohou mít konstruktory třídy, které jsou spuštěny ihned po načtení typu a před vytvořením všech instancí.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-360">Types may have class constructors that run as soon as the type is loaded and before any instances are created.</span></span> <span data-ttu-id="d5ec7-361">Z těchto důvodů je důležité řídit sadu typů, které může deserializace načítat.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-361">For these reasons, it is important to control the set of types that the deserializer may load.</span></span>

<span data-ttu-id="d5ec7-362"><xref:System.Runtime.Serialization.DataContractSerializer>Deserializace volně propojených způsobů.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-362">The <xref:System.Runtime.Serialization.DataContractSerializer> deserializes in a loosely coupled way.</span></span> <span data-ttu-id="d5ec7-363">Nikdy nečte typ Common Language Runtime (CLR) a názvy sestavení z příchozích dat.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-363">It never reads common language runtime (CLR) type and assembly names from the incoming data.</span></span> <span data-ttu-id="d5ec7-364">To se podobá chování <xref:System.Xml.Serialization.XmlSerializer> , ale liší se od chování <xref:System.Runtime.Serialization.NetDataContractSerializer> , <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> a <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter> .</span><span class="sxs-lookup"><span data-stu-id="d5ec7-364">This is similar to the behavior of the <xref:System.Xml.Serialization.XmlSerializer>, but differs from the behavior of the <xref:System.Runtime.Serialization.NetDataContractSerializer>, <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter>, and the <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter>.</span></span> <span data-ttu-id="d5ec7-365">Volné propojení přináší stupeň bezpečnosti, protože vzdálený útočník nemůže určit libovolný typ, který se má načíst, a to tak, že ve zprávě pojmenuje tento typ.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-365">Loose coupling introduces a degree of safety, because the remote attacker cannot indicate an arbitrary type to load just by naming that type in the message.</span></span>

<span data-ttu-id="d5ec7-366"><xref:System.Runtime.Serialization.DataContractSerializer>Vždy je povoleno načíst typ, který je v současné době očekáván podle kontraktu.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-366">The <xref:System.Runtime.Serialization.DataContractSerializer> is always allowed to load a type that is currently expected according to the contract.</span></span> <span data-ttu-id="d5ec7-367">Například Pokud kontrakt dat má datový člen typu `Customer` , <xref:System.Runtime.Serialization.DataContractSerializer> je povoleno načíst `Customer` typ Při deserializaci tohoto datového člena.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-367">For example, if a data contract has a data member of type `Customer`, the <xref:System.Runtime.Serialization.DataContractSerializer> is allowed to load the `Customer` type when it deserializes this data member.</span></span>

<span data-ttu-id="d5ec7-368">Navíc <xref:System.Runtime.Serialization.DataContractSerializer> podporuje polymorfismus.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-368">Additionally, the <xref:System.Runtime.Serialization.DataContractSerializer> supports polymorphism.</span></span> <span data-ttu-id="d5ec7-369">Datový člen může být deklarován jako <xref:System.Object> , ale příchozí data mohou obsahovat `Customer` instanci.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-369">A data member may be declared as <xref:System.Object>, but the incoming data may contain a `Customer` instance.</span></span> <span data-ttu-id="d5ec7-370">To je možné pouze v případě, že byl `Customer` typ pro deserializaci vytvořen pomocí jednoho z těchto mechanismů:</span><span class="sxs-lookup"><span data-stu-id="d5ec7-370">This is possible only if the `Customer` type has been made "known" to the deserializer through one of these mechanisms:</span></span>

- <span data-ttu-id="d5ec7-371"><xref:System.Runtime.Serialization.KnownTypeAttribute> atribut aplikovaný na typ.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-371"><xref:System.Runtime.Serialization.KnownTypeAttribute> attribute applied to a type.</span></span>

- <span data-ttu-id="d5ec7-372">`KnownTypeAttribute` atribut určující metodu, která vrátí seznam typů.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-372">`KnownTypeAttribute` attribute specifying a method that returns a list of types.</span></span>

- <span data-ttu-id="d5ec7-373">`ServiceKnownTypeAttribute` přidělen.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-373">`ServiceKnownTypeAttribute` attribute.</span></span>

- <span data-ttu-id="d5ec7-374">`KnownTypes`Konfigurační oddíl.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-374">The `KnownTypes` configuration section.</span></span>

- <span data-ttu-id="d5ec7-375">Seznam známých typů explicitně předaných <xref:System.Runtime.Serialization.DataContractSerializer> během konstrukce při přímém použití serializátoru.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-375">A list of known types explicitly passed to the <xref:System.Runtime.Serialization.DataContractSerializer> during construction, if using the serializer directly.</span></span>

<span data-ttu-id="d5ec7-376">Každý z těchto mechanismů zvyšuje plochu tím, že zavádí více typů, které může deserializace načíst.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-376">Each of these mechanisms increases the surface area by introducing more types that the deserializer can load.</span></span> <span data-ttu-id="d5ec7-377">Chcete-li zajistit, aby se do seznamu známých typů přidaly žádné škodlivé nebo nezamýšlené typy, proveďte kontrolu každého z těchto mechanismů.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-377">Control each of these mechanisms to ensure no malicious or unintended types are added to the known types list.</span></span>

<span data-ttu-id="d5ec7-378">Jakmile je známý typ v oboru, lze jej načíst kdykoli a instance typu lze vytvořit, i když je ve skutečnosti kontrakt nepoužívá.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-378">Once a known type is in scope, it can be loaded at any time, and instances of the type can be created, even if the contract forbids actually using it.</span></span> <span data-ttu-id="d5ec7-379">Předpokládejme například, že typ "MyDangerousType" se přidá do seznamu známých typů pomocí jednoho z mechanismů uvedených výše.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-379">For example, suppose the type "MyDangerousType" is added to the known types list using one of the mechanisms above.</span></span> <span data-ttu-id="d5ec7-380">To znamená, že:</span><span class="sxs-lookup"><span data-stu-id="d5ec7-380">This means that:</span></span>

- <span data-ttu-id="d5ec7-381">`MyDangerousType` je načten a jeho konstruktor třídy je spuštěn.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-381">`MyDangerousType` is loaded and its class constructor runs.</span></span>

- <span data-ttu-id="d5ec7-382">I při deserializaci kontraktu dat s řetězcovým datovým členem může škodlivá zpráva přesto způsobit `MyDangerousType` vytvoření instance.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-382">Even when deserializing a data contract with a string data member, a malicious message may still cause an instance of `MyDangerousType` to create.</span></span> <span data-ttu-id="d5ec7-383">Kód v, jako je například `MyDangerousType` setter vlastností, lze spustit.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-383">Code in `MyDangerousType`, such as property setters, may run.</span></span> <span data-ttu-id="d5ec7-384">Po dokončení se deserializátor pokusí přiřadit tuto instanci k řetězcovému datovému členu a selže s výjimkou.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-384">After this is done, the deserializer tries to assign this instance to the string data member and fail with an exception.</span></span>

<span data-ttu-id="d5ec7-385">Při psaní metody, která vrátí seznam známých typů nebo při předání seznamu přímo <xref:System.Runtime.Serialization.DataContractSerializer> konstruktoru, se ujistěte, že kód, který připravuje seznam, je zabezpečen a pracuje pouze s důvěryhodnými daty.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-385">When writing a method that returns a list of known types, or when passing a list directly to the <xref:System.Runtime.Serialization.DataContractSerializer> constructor, ensure that the code that prepares the list is secure and operates only on trusted data.</span></span>

<span data-ttu-id="d5ec7-386">Pokud zadáte známé typy v konfiguraci, zajistěte, aby byl konfigurační soubor zabezpečený.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-386">If specifying known types in configuration, ensure that the configuration file is secure.</span></span> <span data-ttu-id="d5ec7-387">Vždy používejte silné názvy v konfiguraci (zadáním veřejného klíče podepsaného sestavení, kde se nachází typ), ale nezadávejte verzi typu, který se má načíst.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-387">Always use strong names in configuration (by specifying the public key of the signed assembly where the type resides), but do not specify the version of the type to load.</span></span> <span data-ttu-id="d5ec7-388">Zavaděč typu automaticky vybere nejnovější verzi, pokud je to možné.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-388">The type loader automatically picks the latest version, if possible.</span></span> <span data-ttu-id="d5ec7-389">Pokud v konfiguraci zadáte konkrétní verzi, spustíte následující riziko: typ může mít chybu zabezpečení, která může být opravena v budoucí verzi, ale ohrožená verze je stále načtena, protože je explicitně zadána v konfiguraci.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-389">If you specify a particular version in configuration, you run the following risk: A type may have a security vulnerability that may be fixed in a future version, but the vulnerable version still loads because it is explicitly specified in configuration.</span></span>

<span data-ttu-id="d5ec7-390">Příliš mnoho známých typů má jiné důsledky: <xref:System.Runtime.Serialization.DataContractSerializer> vytvoří mezipaměť kódu serializace/deserializace v doméně aplikace s položkou pro každý typ, musí serializovat a deserializovat.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-390">Having too many known types has another consequence: The <xref:System.Runtime.Serialization.DataContractSerializer> creates a cache of serialization/deserialization code in the application domain, with an entry for each type it must serialize and deserialize.</span></span> <span data-ttu-id="d5ec7-391">Tato mezipaměť se nikdy nevymaže, dokud je spuštěná doména aplikace.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-391">This cache is never cleared as long as the application domain is running.</span></span> <span data-ttu-id="d5ec7-392">Proto útočník, který ví, že aplikace používá mnoho známých typů, může způsobit deserializaci všech těchto typů, což způsobí, že mezipaměť spotřebuje neúměrně velký objem paměti.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-392">Therefore, an attacker who is aware that an application uses many known types can cause the deserialization of all these types, causing the cache to consume a disproportionately large amount of memory.</span></span>

### <a name="preventing-types-from-being-in-an-unintended-state"></a><span data-ttu-id="d5ec7-393">Zabránění typům v nezamýšleném stavu</span><span class="sxs-lookup"><span data-stu-id="d5ec7-393">Preventing Types from Being in an Unintended State</span></span>

<span data-ttu-id="d5ec7-394">Typ může mít omezení Interní konzistence, která musí být vynutit.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-394">A type may have internal consistency constraints that must be enforced.</span></span> <span data-ttu-id="d5ec7-395">Je třeba dbát na to, abyste zabránili porušení těchto omezení během deserializace.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-395">Care must be taken to avoid breaking these constraints during deserialization.</span></span>

<span data-ttu-id="d5ec7-396">Následující příklad typu představuje stav mikrozámku na kosmické lodi a vynutilo omezení, že vnitřní i vnější dvířka nelze současně otevřít.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-396">The following example of a type represents the state of an airlock on a spacecraft, and enforces the constraint that both the inner and the outer doors cannot be open at the same time.</span></span>

[!code-csharp[DataContractAttribute#3](../../../../samples/snippets/csharp/VS_Snippets_CFX/datacontractattribute/cs/overview.cs#3)]
[!code-vb[DataContractAttribute#3](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/datacontractattribute/vb/overview.vb#3)]

<span data-ttu-id="d5ec7-397">Útočník může například odeslat škodlivou zprávu s ohledem na omezení a získat objekt do neplatného stavu, což může mít nepředvídatelné a nepředvídatelné následky.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-397">An attacker may send a malicious message like this, getting around the constraints and getting the object into an invalid state, which may have unintended and unpredictable consequences.</span></span>

```xml
<SpaceStationAirlock>
    <innerDoorOpen>true</innerDoorOpen>
    <outerDoorOpen>true</outerDoorOpen>
</SpaceStationAirlock>
```

<span data-ttu-id="d5ec7-398">Tato situace se může vyhnout tím, že se dozvíte o následujících bodech:</span><span class="sxs-lookup"><span data-stu-id="d5ec7-398">This situation can be avoided by being aware of the following points:</span></span>

- <span data-ttu-id="d5ec7-399">Když <xref:System.Runtime.Serialization.DataContractSerializer> deserializace většinu tříd, konstruktory se nespustí.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-399">When the <xref:System.Runtime.Serialization.DataContractSerializer> deserializes most classes, constructors do not run.</span></span> <span data-ttu-id="d5ec7-400">Proto nespoléhá na žádnou správu stavu provedenou v konstruktoru.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-400">Therefore, do not rely on any state management done in the constructor.</span></span>

- <span data-ttu-id="d5ec7-401">Pomocí zpětných volání zajistěte, aby byl objekt v platném stavu.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-401">Use callbacks to ensure that the object is in a valid state.</span></span> <span data-ttu-id="d5ec7-402">Zpětné volání označené <xref:System.Runtime.Serialization.OnDeserializedAttribute> atributem je obzvlášť užitečné, protože se spouští po deserializaci a má možnost kontrolovat a opravovat celkový stav.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-402">The callback marked with the <xref:System.Runtime.Serialization.OnDeserializedAttribute> attribute is especially useful because it runs after deserialization is complete and has a chance to examine and correct the overall state.</span></span> <span data-ttu-id="d5ec7-403">Další informace naleznete v tématu [zpětná volání serializace odolná proti verzi](version-tolerant-serialization-callbacks.md).</span><span class="sxs-lookup"><span data-stu-id="d5ec7-403">For more information, see [Version-Tolerant Serialization Callbacks](version-tolerant-serialization-callbacks.md).</span></span>

- <span data-ttu-id="d5ec7-404">Nenavrhujte typy kontraktů dat tak, aby spoléhaly na konkrétní pořadí, ve kterém musí být volána metoda set vlastnosti.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-404">Do not design data contract types to rely on any particular order in which property setters must be called.</span></span>

- <span data-ttu-id="d5ec7-405">Je nutné se starat o použití starších typů označených <xref:System.SerializableAttribute> atributem.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-405">Take care using legacy types marked with the <xref:System.SerializableAttribute> attribute.</span></span> <span data-ttu-id="d5ec7-406">Mnoho z nich bylo navrženo tak, aby spolupracovaly se .NET Framework Vzdálená komunikace pro použití s důvěryhodnými daty.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-406">Many of them were designed to work with .NET Framework remoting for use with trusted data only.</span></span> <span data-ttu-id="d5ec7-407">Existující typy označené pomocí tohoto atributu nemusí být navržené s ohledem na bezpečnost stavu.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-407">Existing types marked with this attribute may not have been designed with state safety in mind.</span></span>

- <span data-ttu-id="d5ec7-408">Nespoléhá se na <xref:System.Runtime.Serialization.DataMemberAttribute.IsRequired%2A> vlastnost <xref:System.Runtime.Serialization.DataMemberAttribute> atributu, aby bylo zaručeno, že data jsou v souladu se zabezpečením stavu.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-408">Do not rely on the <xref:System.Runtime.Serialization.DataMemberAttribute.IsRequired%2A> property of the <xref:System.Runtime.Serialization.DataMemberAttribute> attribute to guarantee presence of data as far as state safety is concerned.</span></span> <span data-ttu-id="d5ec7-409">Data by mohla být vždycky `null` , `zero` nebo `invalid` .</span><span class="sxs-lookup"><span data-stu-id="d5ec7-409">Data could always be `null`, `zero`, or `invalid`.</span></span>

- <span data-ttu-id="d5ec7-410">Nikdy nedůvěřovat objektu Graph deserializovatelné z nedůvěryhodného zdroje dat, aniž byste ho museli nejdřív ověřit.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-410">Never trust an object graph deserialized from an untrusted data source without validating it first.</span></span> <span data-ttu-id="d5ec7-411">Každý jednotlivý objekt může být v konzistentním stavu, ale graf objektu jako celku nemusí být.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-411">Each individual object may be in a consistent state, but the object graph as a whole may not be.</span></span> <span data-ttu-id="d5ec7-412">Kromě toho, i když je režim uchování grafu objektů zakázaný, deserializovaný graf může mít více odkazů na stejný objekt nebo obsahovat cyklické odkazy.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-412">Furthermore, even if the object graph preservation mode is disabled, the deserialized graph may have multiple references to the same object or have circular references.</span></span> <span data-ttu-id="d5ec7-413">Další informace naleznete v tématu [serializace a deserializace](serialization-and-deserialization.md).</span><span class="sxs-lookup"><span data-stu-id="d5ec7-413">For more information, see [Serialization and Deserialization](serialization-and-deserialization.md).</span></span>

### <a name="using-the-netdatacontractserializer-securely"></a><span data-ttu-id="d5ec7-414">Bezpečné použití NetDataContractSerializer</span><span class="sxs-lookup"><span data-stu-id="d5ec7-414">Using the NetDataContractSerializer Securely</span></span>

<span data-ttu-id="d5ec7-415"><xref:System.Runtime.Serialization.NetDataContractSerializer>Je Serializační modul, který používá těsné spojení s typy.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-415">The <xref:System.Runtime.Serialization.NetDataContractSerializer> is a serialization engine that uses tight coupling to types.</span></span> <span data-ttu-id="d5ec7-416">To je podobné jako <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> a <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter> .</span><span class="sxs-lookup"><span data-stu-id="d5ec7-416">This is similar to the <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> and the <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter>.</span></span> <span data-ttu-id="d5ec7-417">To znamená, že určuje, který typ instance se má vytvořit, čtením .NET Framework sestavení a názvu typu z příchozích dat.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-417">That is, it determines which type to instantiate by reading the .NET Framework assembly and type name from the incoming data.</span></span> <span data-ttu-id="d5ec7-418">I když je součástí WCF, není k dispozici žádný způsob, jak se zapojit do tohoto stroje serializace; vlastní kód musí být napsán.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-418">Although it is a part of WCF, there is no supplied way of plugging in this serialization engine; custom code must be written.</span></span> <span data-ttu-id="d5ec7-419">`NetDataContractSerializer`Je primárně k dispozici pro usnadnění migrace z .NET Framework vzdálené komunikace do WCF.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-419">The `NetDataContractSerializer` is provided primarily to ease migration from .NET Framework remoting to WCF.</span></span> <span data-ttu-id="d5ec7-420">Další informace naleznete v příslušném oddílu [serializace a deserializace](serialization-and-deserialization.md).</span><span class="sxs-lookup"><span data-stu-id="d5ec7-420">For more information, see the relevant section in [Serialization and Deserialization](serialization-and-deserialization.md).</span></span>

<span data-ttu-id="d5ec7-421">Vzhledem k tomu, že samotná zpráva může indikovat, že je možné načíst jakýkoli typ, <xref:System.Runtime.Serialization.NetDataContractSerializer> je mechanismus nezabezpečený a měl by být používán pouze s důvěryhodnými daty.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-421">Because the message itself may indicate any type can be loaded, the <xref:System.Runtime.Serialization.NetDataContractSerializer> mechanism is inherently insecure and should be used only with trusted data.</span></span> <span data-ttu-id="d5ec7-422">Další informace najdete v [příručce zabezpečení BinaryFormatter](../../../standard/serialization/binaryformatter-security-guide.md).</span><span class="sxs-lookup"><span data-stu-id="d5ec7-422">For more information, see the [BinaryFormatter security guide](../../../standard/serialization/binaryformatter-security-guide.md).</span></span>

<span data-ttu-id="d5ec7-423">I když se používá s důvěryhodnými daty, může příchozí data nedostatečně určovat typ, který se má načíst, zejména pokud <xref:System.Runtime.Serialization.NetDataContractSerializer.AssemblyFormat%2A> je vlastnost nastavená na <xref:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle.Simple> .</span><span class="sxs-lookup"><span data-stu-id="d5ec7-423">Even when used with trusted data, the incoming data may insufficiently specify the type to load, especially if the <xref:System.Runtime.Serialization.NetDataContractSerializer.AssemblyFormat%2A> property is set to <xref:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle.Simple>.</span></span> <span data-ttu-id="d5ec7-424">Každý, kdo má přístup k adresáři aplikace nebo do globální mezipaměti sestavení (GAC), může nahradit škodlivý typ místo, který by měl načíst.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-424">Anyone with access to the application’s directory or to the global assembly cache can substitute a malicious type in place of the one that is supposed to load.</span></span> <span data-ttu-id="d5ec7-425">Vždy zajistěte, aby zabezpečení adresáře aplikace a globální mezipaměti sestavení byla zajištěna správným nastavením oprávnění.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-425">Always ensure the security of your application’s directory and of the global assembly cache by correctly setting permissions.</span></span>

<span data-ttu-id="d5ec7-426">Obecně platí, že pokud povolíte částečně důvěryhodný přístup ke své `NetDataContractSerializer` instanci nebo jiným způsobem ovládat selektor náhradních ( <xref:System.Runtime.Serialization.ISurrogateSelector> ) nebo serializace ( <xref:System.Runtime.Serialization.SerializationBinder> ), kód může vycházet z Skvělé kontroly nad procesem serializace/deserializace.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-426">In general, if you allow partially trusted code access to your `NetDataContractSerializer` instance or otherwise control the surrogate selector (<xref:System.Runtime.Serialization.ISurrogateSelector>) or the serialization binder (<xref:System.Runtime.Serialization.SerializationBinder>), the code may exercise a great deal of control over the serialization/deserialization process.</span></span> <span data-ttu-id="d5ec7-427">Například může vkládat libovolný typ, vést k vyzrazení informací, manipulaci s výsledným grafem objektů nebo serializovanými daty nebo přetečení výsledného serializovaného datového proudu.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-427">For example, it may inject arbitrary types, lead to information disclosure, tamper with the resulting object graph or serialized data, or overflow the resultant serialized stream.</span></span>

<span data-ttu-id="d5ec7-428">Dalším problémem se zabezpečením `NetDataContractSerializer` je odmítnutí služby, což není hrozba při spuštění škodlivého kódu.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-428">Another security concern with the `NetDataContractSerializer` is a denial of service, not a malicious code execution threat.</span></span> <span data-ttu-id="d5ec7-429">Při použití rozhraní `NetDataContractSerializer` vždy nastavte <xref:System.Runtime.Serialization.NetDataContractSerializer.MaxItemsInObjectGraph%2A> kvótu na bezpečnou hodnotu.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-429">When using the `NetDataContractSerializer`, always set the <xref:System.Runtime.Serialization.NetDataContractSerializer.MaxItemsInObjectGraph%2A> quota to a safe value.</span></span> <span data-ttu-id="d5ec7-430">Je snadné vytvořit malou škodlivou zprávu, která přiděluje pole objektů, jejichž velikost je omezena pouze touto kvótou.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-430">It is easy to construct a small malicious message that allocates an array of objects whose size is limited only by this quota.</span></span>

### <a name="xmlserializer-specific-threats"></a><span data-ttu-id="d5ec7-431">Hrozby specifické pro XmlSerializer</span><span class="sxs-lookup"><span data-stu-id="d5ec7-431">XmlSerializer-Specific Threats</span></span>

<span data-ttu-id="d5ec7-432"><xref:System.Xml.Serialization.XmlSerializer>Model zabezpečení je podobný jako u <xref:System.Runtime.Serialization.DataContractSerializer> .</span><span class="sxs-lookup"><span data-stu-id="d5ec7-432">The <xref:System.Xml.Serialization.XmlSerializer> security model is similar to that of the <xref:System.Runtime.Serialization.DataContractSerializer>.</span></span> <span data-ttu-id="d5ec7-433">Pár hrozeb je ale jedinečný pro <xref:System.Xml.Serialization.XmlSerializer> .</span><span class="sxs-lookup"><span data-stu-id="d5ec7-433">A few threats, however, are unique to the <xref:System.Xml.Serialization.XmlSerializer>.</span></span>

<span data-ttu-id="d5ec7-434"><xref:System.Xml.Serialization.XmlSerializer>Generuje *sestavení serializace* za běhu, která obsahují kód, který skutečně serializace a deserializace; tato sestavení jsou vytvořena v adresáři dočasných souborů.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-434">The <xref:System.Xml.Serialization.XmlSerializer> generates *serialization assemblies* at runtime that contain code that actually serializes and deserializes; these assemblies are created in a temporary files directory.</span></span> <span data-ttu-id="d5ec7-435">Pokud má nějaký jiný proces nebo uživatel přístupová práva k tomuto adresáři, může přepsat kód serializace/deserializace s libovolným kódem.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-435">If some other process or user has access rights to that directory, they may overwrite the serialization/deserialization code with arbitrary code.</span></span> <span data-ttu-id="d5ec7-436"><xref:System.Xml.Serialization.XmlSerializer>Pak tento kód spustí pomocí svého kontextu zabezpečení namísto kódu serializace/deserializace.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-436">The <xref:System.Xml.Serialization.XmlSerializer> then runs this code using its security context, instead of the serialization/deserialization code.</span></span> <span data-ttu-id="d5ec7-437">Ujistěte se, že jsou oprávnění nastavena správně v adresáři dočasných souborů, aby k tomu nedocházelo.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-437">Make sure the permissions are set correctly on the temporary files directory to prevent this from happening.</span></span>

<span data-ttu-id="d5ec7-438"><xref:System.Xml.Serialization.XmlSerializer>Má také režim, ve kterém používá předem vygenerovaná sestavení serializace namísto jejich generování za běhu.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-438">The <xref:System.Xml.Serialization.XmlSerializer> also has a mode in which it uses pre-generated serialization assemblies instead of generating them at runtime.</span></span> <span data-ttu-id="d5ec7-439">Tento režim se spustí pokaždé, když <xref:System.Xml.Serialization.XmlSerializer> může najít vhodné sestavení serializace.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-439">This mode is triggered whenever the <xref:System.Xml.Serialization.XmlSerializer> can find a suitable serialization assembly.</span></span> <span data-ttu-id="d5ec7-440"><xref:System.Xml.Serialization.XmlSerializer>Kontroluje, zda bylo sestavení serializace podepsáno stejným klíčem, který byl použit k podepsání sestavení obsahujícího serializované typy.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-440">The <xref:System.Xml.Serialization.XmlSerializer> checks whether or not the serialization assembly was signed by the same key that was used to sign the assembly that contains the types being serialized.</span></span> <span data-ttu-id="d5ec7-441">To nabízí ochranu před škodlivými sestaveními, která jsou maskována jako sestavení serializace.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-441">This offers protection from malicious assemblies being disguised as serialization assemblies.</span></span> <span data-ttu-id="d5ec7-442">Nicméně pokud sestavení, které obsahuje vaše Serializovatelné typy, není podepsáno, <xref:System.Xml.Serialization.XmlSerializer> nemůže provést tuto kontrolu a použít jakékoli sestavení se správným názvem.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-442">However, if the assembly that contains your serializable types is not signed, the <xref:System.Xml.Serialization.XmlSerializer> cannot perform this check and uses any assembly with the correct name.</span></span> <span data-ttu-id="d5ec7-443">Díky tomu je možné spustit škodlivý kód.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-443">This makes running malicious code possible.</span></span> <span data-ttu-id="d5ec7-444">Vždy Podepište sestavení, která obsahují vaše Serializovatelné typy, nebo důkladně řízení přístupu k adresáři vaší aplikace a globální mezipaměti sestavení (GAC), aby nedocházelo k zavedení škodlivých sestavení.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-444">Always sign the assemblies that contain your serializable types, or tightly control access to your application’s directory and the global assembly cache to prevent the introduction of malicious assemblies.</span></span>

<span data-ttu-id="d5ec7-445"><xref:System.Xml.Serialization.XmlSerializer>Může to být podléhat útokům DOS (Denial of Service).</span><span class="sxs-lookup"><span data-stu-id="d5ec7-445">The <xref:System.Xml.Serialization.XmlSerializer> can be subject to a denial of service attack.</span></span> <span data-ttu-id="d5ec7-446">Nemá <xref:System.Xml.Serialization.XmlSerializer> `MaxItemsInObjectGraph` kvótu (jak je k dispozici v <xref:System.Runtime.Serialization.DataContractSerializer> ).</span><span class="sxs-lookup"><span data-stu-id="d5ec7-446">The <xref:System.Xml.Serialization.XmlSerializer> does not have a `MaxItemsInObjectGraph` quota (as is available on the <xref:System.Runtime.Serialization.DataContractSerializer>).</span></span> <span data-ttu-id="d5ec7-447">Proto deserializace libovolné množství objektů, které jsou omezeny pouze velikostí zprávy.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-447">Thus, it deserializes an arbitrary amount of objects, limited only by the message size.</span></span>

### <a name="partial-trust-threats"></a><span data-ttu-id="d5ec7-448">Hrozby s částečným vztahem důvěryhodnosti</span><span class="sxs-lookup"><span data-stu-id="d5ec7-448">Partial Trust Threats</span></span>

<span data-ttu-id="d5ec7-449">Všimněte si následujících otázek týkajících se hrozeb souvisejících s kódem spuštěným s částečnou důvěryhodností.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-449">Note the following concerns regarding threats related to code running with partial trust.</span></span> <span data-ttu-id="d5ec7-450">Tyto hrozby zahrnují škodlivý částečně důvěryhodný kód a také škodlivý částečně důvěryhodný kód v kombinaci s jinými scénáři útoku (například částečně důvěryhodný kód, který vytvoří konkrétní řetězec a poté je deserializace).</span><span class="sxs-lookup"><span data-stu-id="d5ec7-450">These threats include malicious partially-trusted code as well as malicious partially-trusted code in combination with other attack scenarios (for example, partially-trusted code that constructs a specific string and then deserializing it).</span></span>

- <span data-ttu-id="d5ec7-451">Při použití všech komponent serializace nikdy nehodnotte žádná oprávnění před tímto použitím, a to ani v případě, že celý scénář serializace spadá do rozsahu vašeho kontrolního výrazu a nepracujete s nedůvěryhodnými daty nebo objekty.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-451">When using any serialization components, never assert any permissions before such usage, even if the entire serialization scenario is within the scope of your assert, and you are not dealing with any untrusted data or objects.</span></span> <span data-ttu-id="d5ec7-452">Takové použití může vést k ohrožení zabezpečení.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-452">Such usage may lead to security vulnerabilities.</span></span>

- <span data-ttu-id="d5ec7-453">V případech, kdy částečně důvěryhodný kód má kontrolu nad procesem serializace, buď prostřednictvím bodů rozšiřitelnosti (náhrady), serializovaných typů, nebo prostřednictvím jiných prostředků, částečně důvěryhodný kód může způsobit, že serializátor vytvoří výstup velkého množství dat do serializovaného datového proudu, což může způsobit odepření služby (DoS) příjemci tohoto datového proudu.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-453">In cases where partially-trusted code has control over the serialization process, either through extensibility points (surrogates), types being serialized, or through other means, the partially-trusted code may cause the serializer to output a large amount of data into the serialized stream, which may cause Denial of Service (DoS) to the receiver of this stream.</span></span> <span data-ttu-id="d5ec7-454">Pokud provádíte serializaci dat určených pro cíl, který je citlivý na systémy DoS – hrozby, neserializovat částečně důvěryhodné typy nebo jinak umožnit částečně důvěryhodné serializaci řízení kódu.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-454">If you are serializing data intended for a target that is sensitive to DoS threats, do not serialize partially-trusted types or otherwise let partially-trusted code control serialization.</span></span>

- <span data-ttu-id="d5ec7-455">Pokud povolíte částečně důvěryhodnému přístupu ke své <xref:System.Runtime.Serialization.DataContractSerializer> instanci nebo jiným způsobem ovládat [náhrady u kontraktu dat](../extending/data-contract-surrogates.md), může dojít k skvělému řízení procesu serializace/deserializace.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-455">If you allow partially-trusted code access to your <xref:System.Runtime.Serialization.DataContractSerializer> instance or otherwise control the [Data Contract Surrogates](../extending/data-contract-surrogates.md), it may exercise a great deal of control over the serialization/deserialization process.</span></span> <span data-ttu-id="d5ec7-456">Například může vkládat libovolný typ, vést k vyzrazení informací, manipulaci s výsledným grafem objektů nebo serializovanými daty nebo přetečení výsledného serializovaného datového proudu.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-456">For example, it may inject arbitrary types, lead to information disclosure, tamper with the resulting object graph or serialized data, or overflow the resultant serialized stream.</span></span> <span data-ttu-id="d5ec7-457">Podobná <xref:System.Runtime.Serialization.NetDataContractSerializer> hrozba je popsaná v části "použití zabezpečeného NetDataContractSerializeru".</span><span class="sxs-lookup"><span data-stu-id="d5ec7-457">An equivalent <xref:System.Runtime.Serialization.NetDataContractSerializer> threat is described in the "Using the NetDataContractSerializer Securely" section.</span></span>

- <span data-ttu-id="d5ec7-458">Pokud <xref:System.Runtime.Serialization.DataContractAttribute> je atribut použit na typ (nebo typ označený jako, ale není <xref:System.SerializableAttribute> <xref:System.Runtime.Serialization.ISerializable> ), může deserializátor vytvořit instanci takového typu, i když jsou všechny konstruktory neveřejné nebo chráněné požadavky.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-458">If the <xref:System.Runtime.Serialization.DataContractAttribute> attribute is applied to a type (or the type marked as <xref:System.SerializableAttribute> but is not <xref:System.Runtime.Serialization.ISerializable>), the deserializer can create an instance of such a type even if all constructors are non-public or protected by demands.</span></span>

- <span data-ttu-id="d5ec7-459">Nikdy nedůvěřuje výsledku deserializace, pokud nejsou data pro deserializaci důvěryhodná a Vy jste si jisti, že všechny známé typy jsou typy, kterým důvěřujete.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-459">Never trust the result of deserialization unless the data to be deserialized is trusted and you are certain that all known types are types that you trust.</span></span> <span data-ttu-id="d5ec7-460">Všimněte si, že známé typy nejsou načteny z konfiguračního souboru aplikace (ale jsou načteny z konfiguračního souboru počítače) při spuštění v částečném vztahu důvěryhodnosti.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-460">Note that known types are not loaded from the application configuration file, (but are loaded from the computer configuration file) when running in partial trust.</span></span>

- <span data-ttu-id="d5ec7-461">Pokud předáte <xref:System.Runtime.Serialization.DataContractSerializer> instanci s náhradním přidaným do částečně důvěryhodného kódu, kód může změnit libovolně upravitelná nastavení v této zástupnosti.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-461">If you pass a <xref:System.Runtime.Serialization.DataContractSerializer> instance with a surrogate added to partially-trusted code, the code can change any modifiable settings on that surrogate.</span></span>

- <span data-ttu-id="d5ec7-462">Pro deserializovaný objekt, pokud čtecí modul XML (nebo data v něm) pochází z částečně důvěryhodného kódu, považovat výsledný deserializovaný objekt za nedůvěryhodná data.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-462">For a deserialized object, if the XML reader (or the data therein) comes from partially-trusted code, treat the resulting deserialized object as untrusted data.</span></span>

- <span data-ttu-id="d5ec7-463">Skutečnost, že <xref:System.Runtime.Serialization.ExtensionDataObject> typ nemá žádné veřejné členy, neznamená, že data v rámci tohoto typu jsou zabezpečená.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-463">The fact that the <xref:System.Runtime.Serialization.ExtensionDataObject> type has no public members does not mean that data within it is secure.</span></span> <span data-ttu-id="d5ec7-464">Například pokud provádíte deserializaci z privilegovaných zdrojů dat do objektu, ve kterém jsou uložena nějaká data, částečně důvěryhodný kód může číst data v objektu `ExtensionDataObject` pomocí serializace objektu.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-464">For example, if you deserialize from a privileged data source into an object in which some data resides, then hand that object to partially-trusted code, the partially-trusted code can read the data in the `ExtensionDataObject` by serializing the object.</span></span> <span data-ttu-id="d5ec7-465">Zvažte nastavení <xref:System.Runtime.Serialization.DataContractSerializer.IgnoreExtensionDataObject%2A> na `true` Při deserializaci z privilegovaného zdroje dat do objektu, který je později předán částečně důvěryhodnému kódu.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-465">Consider setting <xref:System.Runtime.Serialization.DataContractSerializer.IgnoreExtensionDataObject%2A> to `true` when deserializing from a privileged data source into an object that is later passed to partially-trusted code.</span></span>

- <span data-ttu-id="d5ec7-466"><xref:System.Runtime.Serialization.DataContractSerializer> a <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> podporují serializaci privátních, chráněných, interních a veřejných členů v úplném vztahu důvěryhodnosti.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-466"><xref:System.Runtime.Serialization.DataContractSerializer> and <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> support the serialization of private, protected, internal, and public members in full trust.</span></span> <span data-ttu-id="d5ec7-467">V částečném vztahu důvěryhodnosti však lze serializovat pouze veřejné členy.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-467">However, in partial trust, only public members can be serialized.</span></span> <span data-ttu-id="d5ec7-468"><xref:System.Security.SecurityException>Výjimka je vyvolána, pokud se aplikace pokusí serializovat neveřejný člen.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-468">A <xref:System.Security.SecurityException> is thrown if an application attempts to serialize a non-public member.</span></span>

    <span data-ttu-id="d5ec7-469">Pro umožnění serializace interních nebo chráněných interních členů v částečném vztahu důvěryhodnosti použijte <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> atribut Assembly.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-469">To allow internal or protected internal members to be serialized in partial trust, use the <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> assembly attribute.</span></span> <span data-ttu-id="d5ec7-470">Tento atribut umožňuje sestavení deklarovat, že jeho interní členy jsou viditelné pro některé jiné sestavení.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-470">This attribute allows an assembly to declare that its internal members are visible to some other assembly.</span></span> <span data-ttu-id="d5ec7-471">V tomto případě sestavení, které má serializovat své interní členy, deklaruje deklaraci, že jeho interní členové jsou System.Runtime.Serialization.dll.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-471">In this case, an assembly that wants to have its internal members serialized declares that its internal members are visible to System.Runtime.Serialization.dll.</span></span>

    <span data-ttu-id="d5ec7-472">Výhodou tohoto přístupu je, že nevyžaduje cestu pro generování zvýšeného kódu.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-472">The advantage of this approach is that it does not require an elevated code generation path.</span></span>

    <span data-ttu-id="d5ec7-473">Ve stejnou dobu existují dvě hlavní nevýhody.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-473">At the same time, there are two major disadvantages.</span></span>

    <span data-ttu-id="d5ec7-474">První nevýhodou je, že vlastnost opt-in <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> atributu je platná pro sestavení.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-474">The first disadvantage is that the opt-in property of the <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> attribute is assembly-wide.</span></span> <span data-ttu-id="d5ec7-475">To znamená, že nemůžete určit, že jeho interní členy mají serializovat pouze určitá třída.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-475">That is, you cannot specify that only a certain class can have its internal members serialized.</span></span> <span data-ttu-id="d5ec7-476">Samozřejmě si stále můžete zvolit, že nechcete serializovat konkrétní interní člen, pouhým přidáním <xref:System.Runtime.Serialization.DataMemberAttribute> atributu k tomuto členu.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-476">Of course, you can still choose not to serialize a specific internal member, by simply not adding a <xref:System.Runtime.Serialization.DataMemberAttribute> attribute to that member.</span></span> <span data-ttu-id="d5ec7-477">Podobně může vývojář také rozhodnout, že má místo soukromého nebo chráněného člena, a to s mírnými aspekty viditelnosti.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-477">Similarly, a developer can also choose to make a member internal rather than private or protected, with slight visibility concerns.</span></span>

    <span data-ttu-id="d5ec7-478">Druhým nevýhodou je, že stále nepodporuje soukromé nebo chráněné členy.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-478">The second disadvantage is that it still does not support private or protected members.</span></span>

    <span data-ttu-id="d5ec7-479">K ilustraci použití <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> atributu v částečném vztahu důvěryhodnosti zvažte následující program:</span><span class="sxs-lookup"><span data-stu-id="d5ec7-479">To illustrate the use of the <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> attribute in partial trust, consider the following program:</span></span>

    [!code-csharp[CDF_WCF_SecurityConsiderationsForData#1](../../../../samples/snippets/csharp/VS_Snippets_CFX/cdf_wcf_securityconsiderationsfordata/cs/program.cs#1)]

    <span data-ttu-id="d5ec7-480">V předchozím příkladu `PermissionsHelper.InternetZone` odpovídá poli <xref:System.Security.PermissionSet> pro částečnou důvěryhodnost.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-480">In the example above, `PermissionsHelper.InternetZone` corresponds to the <xref:System.Security.PermissionSet> for partial trust.</span></span> <span data-ttu-id="d5ec7-481">Nyní bez <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> atributu nebude aplikace úspěšná, bude aktivována <xref:System.Security.SecurityException> zpráva oznamující, že neveřejné členy nelze serializovat v částečném vztahu důvěryhodnosti.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-481">Now, without the <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> attribute, the application will fail, throwing a <xref:System.Security.SecurityException> indicating that non-public members cannot be serialized in partial trust.</span></span>

    <span data-ttu-id="d5ec7-482">Pokud však přidáme následující řádek do zdrojového souboru, program se úspěšně spustí.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-482">However, if we add the following line to the source file, the program runs successfully.</span></span>

    [!code-csharp[CDF_WCF_SecurityConsiderationsForData#2](../../../../samples/snippets/csharp/VS_Snippets_CFX/cdf_wcf_securityconsiderationsfordata/cs/program.cs#2)]

## <a name="other-state-management-concerns"></a><span data-ttu-id="d5ec7-483">Další aspekty správy stavů</span><span class="sxs-lookup"><span data-stu-id="d5ec7-483">Other State Management Concerns</span></span>

<span data-ttu-id="d5ec7-484">Další aspekty týkající se správy stavu objektů jsou zmínky o:</span><span class="sxs-lookup"><span data-stu-id="d5ec7-484">A few other concerns regarding object state management are worth mentioning:</span></span>

- <span data-ttu-id="d5ec7-485">Při použití programovacího modelu založeného na datových proudech s přenosem streamování dojde ke zpracování zprávy při doručení zprávy.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-485">When using the stream-based programming model with a streaming transport, processing of the message occurs as the message arrives.</span></span> <span data-ttu-id="d5ec7-486">Odesílatel zprávy může přerušit operaci odeslání uprostřed datového proudu, přičemž váš kód zůstane v nepředvídatelném stavu, pokud bylo očekáváno více obsahu.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-486">The sender of the message may abort the send operation in the middle of the stream, leaving your code in an unpredictable state if more content was expected.</span></span> <span data-ttu-id="d5ec7-487">Obecně platí, že se nespoléhá na dokončování datového proudu a neprovádějte žádné práce v operaci založené na datových proudech, které nelze vrátit zpět pro případ, že je datový proud přerušen.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-487">In general, do not rely on the stream being complete, and do not perform any work in a stream-based operation that cannot be rolled back in case the stream is aborted.</span></span> <span data-ttu-id="d5ec7-488">To platí také pro situaci, kdy může být zpráva po tělo streamování poškozena (například může chybět koncová značka pro obálku protokolu SOAP nebo může obsahovat druhý text zprávy).</span><span class="sxs-lookup"><span data-stu-id="d5ec7-488">This also applies to the situation where a message may be malformed after the streaming body (for example, it may be missing an end tag for the SOAP envelope or may have a second message body).</span></span>

- <span data-ttu-id="d5ec7-489">Použití `IExtensibleDataObject` funkce může způsobit vygenerování citlivých dat.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-489">Using the `IExtensibleDataObject` feature may cause sensitive data to be emitted.</span></span> <span data-ttu-id="d5ec7-490">Pokud přijímáte data z nedůvěryhodného zdroje do kontraktů dat s `IExtensibleObjectData` a později je znovu vygenerujete na zabezpečeném kanálu, kde jsou zprávy podepsány, může vám doručíme za data, o kterých víte, že nic neznáte.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-490">If you are accepting data from an untrusted source into data contracts with `IExtensibleObjectData` and later re-emitting it on a secure channel where messages are signed, you are potentially vouching for data you know nothing about.</span></span> <span data-ttu-id="d5ec7-491">Kromě toho je možné, že celkový stav, který odesíláte, může být neplatný, pokud se v účtu podrží známá i neznámá data.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-491">Moreover, the overall state you are sending may be invalid if you take both the known and unknown pieces of data into account.</span></span> <span data-ttu-id="d5ec7-492">Tuto situaci Vyhněte buď selektivním nastavením vlastnosti dat rozšíření na, `null` nebo selektivním zakázáním této `IExtensibleObjectData` funkce.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-492">Avoid this situation by either selectively setting the extension data property to `null` or by selectively disabling the `IExtensibleObjectData` feature.</span></span>

## <a name="schema-import"></a><span data-ttu-id="d5ec7-493">Import schématu</span><span class="sxs-lookup"><span data-stu-id="d5ec7-493">Schema Import</span></span>

<span data-ttu-id="d5ec7-494">Proces importu schématu pro generování typů se obvykle provádí pouze v době návrhu, například při použití nástroje pro vytváření [metadat (Svcutil.exe)](../servicemodel-metadata-utility-tool-svcutil-exe.md) ve webové službě k vygenerování klientské třídy.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-494">Normally, the process of importing schema to generate types happens only at design time, for example, when using the [ServiceModel Metadata Utility Tool (Svcutil.exe)](../servicemodel-metadata-utility-tool-svcutil-exe.md) on a Web service to generate a client class.</span></span> <span data-ttu-id="d5ec7-495">V pokročilejších scénářích ale můžete schéma zpracovat za běhu.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-495">However, in more advanced scenarios, you may process schema at runtime.</span></span> <span data-ttu-id="d5ec7-496">Uvědomte si, že pokud to uděláte, můžete si vystavit rizika při odepření služby.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-496">Be aware that doing so can expose you to denial-of-service risks.</span></span> <span data-ttu-id="d5ec7-497">Import některých schémat může trvat dlouhou dobu.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-497">Some schema may take a long time to be imported.</span></span> <span data-ttu-id="d5ec7-498">Nikdy nepoužívejte <xref:System.Xml.Serialization.XmlSerializer> komponentu importu schématu v takových scénářích, pokud jsou schémata pravděpodobně přicházející z nedůvěryhodného zdroje.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-498">Never use the <xref:System.Xml.Serialization.XmlSerializer> schema import component in such scenarios if schemas are possibly coming from an untrusted source.</span></span>

## <a name="threats-specific-to-aspnet-ajax-integration"></a><span data-ttu-id="d5ec7-499">Hrozby specifické pro integraci ASP.NET AJAX</span><span class="sxs-lookup"><span data-stu-id="d5ec7-499">Threats Specific to ASP.NET AJAX Integration</span></span>

<span data-ttu-id="d5ec7-500">Když uživatel implementuje <xref:System.ServiceModel.Description.WebScriptEnablingBehavior> nebo <xref:System.ServiceModel.Description.WebHttpBehavior> , WCF zpřístupňuje koncový bod, který může přijímat zprávy XML i JSON.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-500">When the user implements <xref:System.ServiceModel.Description.WebScriptEnablingBehavior> or <xref:System.ServiceModel.Description.WebHttpBehavior>, WCF exposes an endpoint that can accept both XML and JSON messages.</span></span> <span data-ttu-id="d5ec7-501">Existuje však pouze jedna sada kvót čtecího modulu, kterou používá čtečka XML i čtečka JSON.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-501">However, there is only one set of reader quotas, used both by the XML reader and the JSON reader.</span></span> <span data-ttu-id="d5ec7-502">Některá nastavení kvót můžou být vhodná pro jedno čtecí zařízení, ale jsou pro ně moc velká.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-502">Some quota settings may be appropriate for one reader but too large for the other.</span></span>

<span data-ttu-id="d5ec7-503">Při implementaci nástroje `WebScriptEnablingBehavior` má uživatel možnost vystavit proxy JavaScript na koncovém bodu.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-503">When implementing `WebScriptEnablingBehavior`, the user has the option to expose a JavaScript proxy at the endpoint.</span></span> <span data-ttu-id="d5ec7-504">Je potřeba vzít v úvahu následující problémy se zabezpečením:</span><span class="sxs-lookup"><span data-stu-id="d5ec7-504">The following security issues must be considered:</span></span>

- <span data-ttu-id="d5ec7-505">Informace o službě (názvy operací, názvy parametrů atd.) lze získat prozkoumáním proxy JavaScript.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-505">Information about the service (operation names, parameter names, and so on) can be obtained by examining the JavaScript proxy.</span></span>

- <span data-ttu-id="d5ec7-506">Při použití koncového bodu JavaScriptu můžou být citlivé a soukromé informace zachovány v mezipaměti klientského webového prohlížeče.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-506">When using the JavaScript endpoint, sensitive and private information might be retained in the client Web browser cache.</span></span>

## <a name="a-note-on-components"></a><span data-ttu-id="d5ec7-507">Poznámka k součástem</span><span class="sxs-lookup"><span data-stu-id="d5ec7-507">A Note on Components</span></span>

<span data-ttu-id="d5ec7-508">WCF je flexibilní a přizpůsobitelný systém.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-508">WCF is a flexible and customizable system.</span></span> <span data-ttu-id="d5ec7-509">Většina obsahu tohoto tématu se zaměřuje na nejběžnější scénáře použití WCF.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-509">Most of the contents of this topic focus on the most common WCF usage scenarios.</span></span> <span data-ttu-id="d5ec7-510">Je však možné napsat komponenty WCF poskytují mnoho různých způsobů.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-510">However, it is possible to compose components WCF provides in many different ways.</span></span> <span data-ttu-id="d5ec7-511">Je důležité pochopit důsledky zabezpečení při používání jednotlivých komponent.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-511">It is important to understand the security implications of using each component.</span></span> <span data-ttu-id="d5ec7-512">Zejména jde o toto:</span><span class="sxs-lookup"><span data-stu-id="d5ec7-512">In particular:</span></span>

- <span data-ttu-id="d5ec7-513">Pokud je nutné použít čtečky XML, použijte čtečky, které <xref:System.Xml.XmlDictionaryReader> Třída poskytuje, na rozdíl od ostatních čtenářů.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-513">When you must use XML readers, use the readers the <xref:System.Xml.XmlDictionaryReader> class provides as opposed to any other readers.</span></span> <span data-ttu-id="d5ec7-514">Bezpečná čtenáři se vytvářejí pomocí <xref:System.Xml.XmlDictionaryReader.CreateTextReader%2A> <xref:System.Xml.XmlDictionaryReader.CreateBinaryReader%2A> metod, a <xref:System.Xml.XmlDictionaryReader.CreateMtomReader%2A> .</span><span class="sxs-lookup"><span data-stu-id="d5ec7-514">Safe readers are created using <xref:System.Xml.XmlDictionaryReader.CreateTextReader%2A>, <xref:System.Xml.XmlDictionaryReader.CreateBinaryReader%2A>, or <xref:System.Xml.XmlDictionaryReader.CreateMtomReader%2A> methods.</span></span> <span data-ttu-id="d5ec7-515">Nepoužívejte <xref:System.Xml.XmlReader.Create%2A> metodu.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-515">Do not use the <xref:System.Xml.XmlReader.Create%2A> method.</span></span> <span data-ttu-id="d5ec7-516">Vždy nakonfigurujte čtečky s bezpečnými kvótami.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-516">Always configure the readers with safe quotas.</span></span> <span data-ttu-id="d5ec7-517">Serializační moduly ve službě WCF jsou zabezpečené pouze v případě, že se používají s zabezpečenými čtenáři XML ze služby WCF.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-517">The serialization engines in WCF are secure only when used with secure XML readers from WCF.</span></span>

- <span data-ttu-id="d5ec7-518">Při použití <xref:System.Runtime.Serialization.DataContractSerializer> k deserializaci potenciálně nedůvěryhodných dat vždy nastavte <xref:System.Runtime.Serialization.DataContractSerializer.MaxItemsInObjectGraph%2A> vlastnost.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-518">When using the <xref:System.Runtime.Serialization.DataContractSerializer> to deserialize potentially untrusted data, always set the <xref:System.Runtime.Serialization.DataContractSerializer.MaxItemsInObjectGraph%2A> property.</span></span>

- <span data-ttu-id="d5ec7-519">Při vytváření zprávy nastavte `maxSizeOfHeaders` parametr, pokud `MaxReceivedMessageSize` nenabízí dostatečnou ochranu.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-519">When creating a message, set the `maxSizeOfHeaders` parameter if `MaxReceivedMessageSize` does not offer enough protection.</span></span>

- <span data-ttu-id="d5ec7-520">Při vytváření kodéru vždy konfigurujte příslušné kvóty, například `MaxSessionSize` a `MaxBufferSize` .</span><span class="sxs-lookup"><span data-stu-id="d5ec7-520">When creating an encoder, always configure the relevant quotas, such as `MaxSessionSize` and `MaxBufferSize`.</span></span>

- <span data-ttu-id="d5ec7-521">Při použití filtru zpráv XPath nastavte, aby se <xref:System.ServiceModel.Dispatcher.XPathMessageFilter.NodeQuota%2A> omezil počet uzlů XML, na které se filtr navštíví.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-521">When using an XPath message filter, set the <xref:System.ServiceModel.Dispatcher.XPathMessageFilter.NodeQuota%2A> to limit the amount of XML nodes the filter visits.</span></span> <span data-ttu-id="d5ec7-522">Nepoužívejte výrazy XPath, jejichž výpočet může trvat dlouhou dobu, aniž by bylo nutné navštěvovat mnoho uzlů.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-522">Do not use XPath expressions that could take a long time to compute without visiting many nodes.</span></span>

- <span data-ttu-id="d5ec7-523">Obecně platí, že při použití libovolné komponenty, která přijímá kvótu, je potřeba pochopit její vliv na zabezpečení a nastavit ji na bezpečnou hodnotu.</span><span class="sxs-lookup"><span data-stu-id="d5ec7-523">In general, when using any component that accepts a quota, understand its security implications and set it to a safe value.</span></span>

## <a name="see-also"></a><span data-ttu-id="d5ec7-524">Viz také:</span><span class="sxs-lookup"><span data-stu-id="d5ec7-524">See also</span></span>

- <xref:System.Runtime.Serialization.DataContractSerializer>
- <xref:System.Xml.XmlDictionaryReader>
- <xref:System.Xml.Serialization.XmlSerializer>
- [<span data-ttu-id="d5ec7-525">Známé typy kontraktů dat</span><span class="sxs-lookup"><span data-stu-id="d5ec7-525">Data Contract Known Types</span></span>](data-contract-known-types.md)
