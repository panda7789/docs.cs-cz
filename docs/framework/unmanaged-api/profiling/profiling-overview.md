---
title: Přehled profilace
ms.date: 03/30/2017
helpviewer_keywords:
- managed code, profiling API support
- unmanaged code, combining with managed code in profiling
- notification threads [.NET Framework profiling]
- unmanaged code, profiling
- profiling API [.NET Framework], and COM
- profiling API [.NET Framework], unmanaged code profiling
- profilers, writing
- profiling API [.NET Framework], call stacks
- code profilers, writing
- profiling API [.NET Framework], security considerations
- profiling API [.NET Framework], managed code support
- common language runtime, profiling
- profiling API [.NET Framework], notification threads
- call stacks [.NET Framework profiling]
- profiling API [.NET Framework], stack depth
- common language runtime, writing a profiler
- profiling API [.NET Framework], information retrieval interfaces
- shadow stacks [.NET Framework profiling]
- COM, using in the profiling API
- stack snapshots [.NET Framework profiling]
- profiling API [.NET Framework], supported features
- profiling API [.NET Framework], overview
- security, profiling API considerations
- stack depth [.NET Framework profiling]
ms.assetid: 864c2344-71dc-46f9-96b2-ed59fb6427a8
ms.openlocfilehash: aa8bff374e9698d4b7e032428ec1bdc66901e05d
ms.sourcegitcommit: b11efd71c3d5ce3d9449c8d4345481b9f21392c6
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 01/29/2020
ms.locfileid: "76860912"
---
# <a name="profiling-overview"></a><span data-ttu-id="98348-102">Přehled profilace</span><span class="sxs-lookup"><span data-stu-id="98348-102">Profiling Overview</span></span>

<span data-ttu-id="98348-103">Profiler je nástroj, který monitoruje provádění jiné aplikace.</span><span class="sxs-lookup"><span data-stu-id="98348-103">A profiler is a tool that monitors the execution of another application.</span></span> <span data-ttu-id="98348-104">Profiler modulu CLR (Common Language Runtime) je dynamická knihovna (DLL), která se skládá z funkcí, které přijímají zprávy a odesílají zprávy do modulu CLR pomocí Profilování rozhraní API.</span><span class="sxs-lookup"><span data-stu-id="98348-104">A common language runtime (CLR) profiler is a dynamic link library (DLL) that consists of functions that receive messages from, and send messages to, the CLR by using the profiling API.</span></span> <span data-ttu-id="98348-105">Knihovna DLL profileru je načtena modulem CLR v době běhu.</span><span class="sxs-lookup"><span data-stu-id="98348-105">The profiler DLL is loaded by the CLR at run time.</span></span>

<span data-ttu-id="98348-106">Tradiční nástroje pro profilaci se zaměřují na měření spuštění aplikace.</span><span class="sxs-lookup"><span data-stu-id="98348-106">Traditional profiling tools focus on measuring the execution of the application.</span></span> <span data-ttu-id="98348-107">To znamená, že měří čas strávený v každé funkci nebo využití paměti aplikace v čase.</span><span class="sxs-lookup"><span data-stu-id="98348-107">That is, they measure the time that is spent in each function or the memory usage of the application over time.</span></span> <span data-ttu-id="98348-108">Rozhraní API profilování cílí na širší třídu diagnostických nástrojů, jako jsou například nástroje pro pokrytí kódu a dokonce i rozšířené pomůcky pro ladění.</span><span class="sxs-lookup"><span data-stu-id="98348-108">The profiling API targets a broader class of diagnostic tools such as code-coverage utilities and even advanced debugging aids.</span></span> <span data-ttu-id="98348-109">Tato použití jsou všechna Diagnostika v podstatě.</span><span class="sxs-lookup"><span data-stu-id="98348-109">These uses are all diagnostic in nature.</span></span> <span data-ttu-id="98348-110">Rozhraní API profilování nejen měří, ale také sleduje spuštění aplikace.</span><span class="sxs-lookup"><span data-stu-id="98348-110">The profiling API not only measures but also monitors the execution of an application.</span></span> <span data-ttu-id="98348-111">Z tohoto důvodu by rozhraní API profilování nemělo být nikdy používáno aplikací samotné a spuštění aplikace by nemělo záviset na (nebo být ovlivněno) profilerem.</span><span class="sxs-lookup"><span data-stu-id="98348-111">For this reason, the profiling API should never be used by the application itself, and the application’s execution should not depend on (or be affected by) the profiler.</span></span>

<span data-ttu-id="98348-112">Profilace aplikace CLR vyžaduje větší podporu než sestavení zkompilovaného strojového kódu v konvenci profilace.</span><span class="sxs-lookup"><span data-stu-id="98348-112">Profiling a CLR application requires more support than profiling conventionally compiled machine code.</span></span> <span data-ttu-id="98348-113">Důvodem je, že CLR zavádí koncepty, jako například domény aplikace, uvolňování paměti, spravované zpracování výjimek, kompilaci JIT (just-in-time) kódu (převod Microsoft Intermediate Language nebo MSIL, Code do nativního strojového kódu) a podobné funkce.</span><span class="sxs-lookup"><span data-stu-id="98348-113">This is because the CLR introduces concepts such as application domains, garbage collection, managed exception handling, just-in-time (JIT) compilation of code (converting Microsoft intermediate language, or MSIL, code into native machine code), and similar features.</span></span> <span data-ttu-id="98348-114">Konvenční mechanismy profilace nemůžou identifikovat nebo poskytnout užitečné informace o těchto funkcích.</span><span class="sxs-lookup"><span data-stu-id="98348-114">Conventional profiling mechanisms cannot identify or provide useful information about these features.</span></span> <span data-ttu-id="98348-115">Rozhraní API profilování poskytuje tyto chybějící informace efektivně s minimálním dopadem na výkon CLR a profilované aplikace.</span><span class="sxs-lookup"><span data-stu-id="98348-115">The profiling API provides this missing information efficiently, with minimal effect on the performance of the CLR and the profiled application.</span></span>

<span data-ttu-id="98348-116">Kompilace JIT za běhu nabízí dobré příležitosti pro profilování.</span><span class="sxs-lookup"><span data-stu-id="98348-116">JIT compilation at run time provides good opportunities for profiling.</span></span> <span data-ttu-id="98348-117">Rozhraní API profilování umožňuje profileru změnit datový proud kódu MSIL v paměti pro rutinu předtím, než je kompilace JIT zkompilována.</span><span class="sxs-lookup"><span data-stu-id="98348-117">The profiling API enables a profiler to change the in-memory MSIL code stream for a routine before it is JIT-compiled.</span></span> <span data-ttu-id="98348-118">Tímto způsobem může Profiler dynamicky přidat kód instrumentace k určitým rutinám, které potřebují hlubší šetření.</span><span class="sxs-lookup"><span data-stu-id="98348-118">In this manner, the profiler can dynamically add instrumentation code to particular routines that need deeper investigation.</span></span> <span data-ttu-id="98348-119">I když je tento přístup možný v konvenčních scénářích, je mnohem snazší implementovat CLR pomocí Profilování rozhraní API.</span><span class="sxs-lookup"><span data-stu-id="98348-119">Although this approach is possible in conventional scenarios, it is much easier to implement for the CLR by using the profiling API.</span></span>

## <a name="the-profiling-api"></a><span data-ttu-id="98348-120">Rozhraní API profilování</span><span class="sxs-lookup"><span data-stu-id="98348-120">The Profiling API</span></span>

<span data-ttu-id="98348-121">Rozhraní API profilování se obvykle používá k zápisu *profileru kódu*, což je program, který sleduje spuštění spravované aplikace.</span><span class="sxs-lookup"><span data-stu-id="98348-121">Typically, the profiling API is used to write a *code profiler*, which is a program that monitors the execution of a managed application.</span></span>

<span data-ttu-id="98348-122">Rozhraní API profileru používá profil DLL profileru, který se načte do stejného procesu jako aplikace, která se profiluje.</span><span class="sxs-lookup"><span data-stu-id="98348-122">The profiling API is used by a profiler DLL, which is loaded into the same process as the application that is being profiled.</span></span> <span data-ttu-id="98348-123">Knihovna DLL profileru implementuje rozhraní zpětného volání ([ICorProfilerCallback](icorprofilercallback-interface.md) v .NET Framework verze 1,0 a 1,1, [ICorProfilerCallback2](icorprofilercallback2-interface.md) ve verzi 2,0 a novější).</span><span class="sxs-lookup"><span data-stu-id="98348-123">The profiler DLL implements a callback interface ([ICorProfilerCallback](icorprofilercallback-interface.md) in the .NET Framework version 1.0 and 1.1, [ICorProfilerCallback2](icorprofilercallback2-interface.md) in version 2.0 and later).</span></span> <span data-ttu-id="98348-124">CLR volá metody v tomto rozhraní, aby upozornil Profiler událostí v profilované procesu.</span><span class="sxs-lookup"><span data-stu-id="98348-124">The CLR calls the methods in that interface to notify the profiler of events in the profiled process.</span></span> <span data-ttu-id="98348-125">Profiler může volat zpět do modulu runtime pomocí metod v rozhraních [ICorProfilerInfo](icorprofilerinfo-interface.md) a [ICorProfilerInfo2](icorprofilerinfo2-interface.md) k získání informací o stavu profilované aplikace.</span><span class="sxs-lookup"><span data-stu-id="98348-125">The profiler can call back into the runtime by using the methods in the [ICorProfilerInfo](icorprofilerinfo-interface.md) and [ICorProfilerInfo2](icorprofilerinfo2-interface.md) interfaces to obtain information about the state of the profiled application.</span></span>

> [!NOTE]
> <span data-ttu-id="98348-126">Pouze část shromažďování dat v rámci řešení profileru by měla být spuštěna ve stejném procesu jako profilovaná aplikace.</span><span class="sxs-lookup"><span data-stu-id="98348-126">Only the data-gathering part of the profiler solution should be running in the same process as the profiled application.</span></span> <span data-ttu-id="98348-127">Veškeré uživatelské rozhraní a analýzu dat by se měly provádět v samostatném procesu.</span><span class="sxs-lookup"><span data-stu-id="98348-127">All user interface and data analysis should be performed in a separate process.</span></span>

<span data-ttu-id="98348-128">Následující obrázek ukazuje, jak knihovna DLL profileru komunikuje s aplikací, která je profilovaná a CLR.</span><span class="sxs-lookup"><span data-stu-id="98348-128">The following illustration shows how the profiler DLL interacts with the application that is being profiled and the CLR.</span></span>

![Snímek obrazovky, který zobrazuje architekturu profilace.](./media/profiling-overview/profiling-architecture.png)

### <a name="the-notification-interfaces"></a><span data-ttu-id="98348-130">Rozhraní pro oznamování</span><span class="sxs-lookup"><span data-stu-id="98348-130">The Notification Interfaces</span></span>

<span data-ttu-id="98348-131">[ICorProfilerCallback](icorprofilercallback-interface.md) a [ICorProfilerCallback2](icorprofilercallback2-interface.md) lze považovat za rozhraní oznámení.</span><span class="sxs-lookup"><span data-stu-id="98348-131">[ICorProfilerCallback](icorprofilercallback-interface.md) and [ICorProfilerCallback2](icorprofilercallback2-interface.md) can be considered notification interfaces.</span></span> <span data-ttu-id="98348-132">Tato rozhraní se skládají z metod, jako jsou [ClassLoadStarted –](icorprofilercallback-classloadstarted-method.md), [ClassLoadFinished –](icorprofilercallback-classloadfinished-method.md)a [JITCompilationStarted –](icorprofilercallback-jitcompilationstarted-method.md).</span><span class="sxs-lookup"><span data-stu-id="98348-132">These interfaces consist of methods such as [ClassLoadStarted](icorprofilercallback-classloadstarted-method.md), [ClassLoadFinished](icorprofilercallback-classloadfinished-method.md), and [JITCompilationStarted](icorprofilercallback-jitcompilationstarted-method.md).</span></span> <span data-ttu-id="98348-133">Pokaždé, když CLR načte nebo uvolní třídu, zkompiluje funkci a tak dále, volá odpovídající metodu v rozhraní `ICorProfilerCallback` nebo `ICorProfilerCallback2` profileru.</span><span class="sxs-lookup"><span data-stu-id="98348-133">Each time the CLR loads or unloads a class, compiles a function, and so on, it calls the corresponding method in the profiler's `ICorProfilerCallback` or `ICorProfilerCallback2` interface.</span></span>

<span data-ttu-id="98348-134">Profiler může například měřit výkon kódu prostřednictvím dvou funkcí oznámení: [FunctionEnter2](functionenter2-function.md) a [FunctionLeave2 –](functionleave2-function.md).</span><span class="sxs-lookup"><span data-stu-id="98348-134">For example, a profiler could measure code performance through two notification functions: [FunctionEnter2](functionenter2-function.md) and [FunctionLeave2](functionleave2-function.md).</span></span> <span data-ttu-id="98348-135">Slouží pouze k časovému razítku každého oznámení, nashromáždí výsledky a vytvoří výstup seznamu, který označuje, které funkce při provádění aplikace spotřebují nejvíce času procesoru nebo hodin na zdi.</span><span class="sxs-lookup"><span data-stu-id="98348-135">It just time-stamps each notification, accumulates results, and outputs a list that indicates which functions consumed the most CPU or wall-clock time during the execution of the application.</span></span>

### <a name="the-information-retrieval-interfaces"></a><span data-ttu-id="98348-136">Rozhraní pro načítání informací</span><span class="sxs-lookup"><span data-stu-id="98348-136">The Information Retrieval Interfaces</span></span>

<span data-ttu-id="98348-137">Další hlavní rozhraní zapojená do profilace jsou [ICorProfilerInfo](icorprofilerinfo-interface.md) a [ICorProfilerInfo2](icorprofilerinfo2-interface.md).</span><span class="sxs-lookup"><span data-stu-id="98348-137">The other main interfaces involved in profiling are [ICorProfilerInfo](icorprofilerinfo-interface.md) and [ICorProfilerInfo2](icorprofilerinfo2-interface.md).</span></span> <span data-ttu-id="98348-138">Profiler volá tato rozhraní podle potřeby, aby získal další informace, které vám pomůžou s analýzou.</span><span class="sxs-lookup"><span data-stu-id="98348-138">The profiler calls these interfaces as required to obtain more information to help its analysis.</span></span> <span data-ttu-id="98348-139">Například vždy, když CLR volá funkci [FunctionEnter2](functionenter2-function.md) , poskytuje identifikátor funkce.</span><span class="sxs-lookup"><span data-stu-id="98348-139">For example, whenever the CLR calls the [FunctionEnter2](functionenter2-function.md) function, it supplies a function identifier.</span></span> <span data-ttu-id="98348-140">Profiler může získat další informace o této funkci voláním metody [ICorProfilerInfo2:: GetFunctionInfo2 –](icorprofilerinfo2-getfunctioninfo2-method.md) pro zjištění nadřazené třídy funkce, jejího názvu a tak dále.</span><span class="sxs-lookup"><span data-stu-id="98348-140">The profiler can get more information about that function by calling the [ICorProfilerInfo2::GetFunctionInfo2](icorprofilerinfo2-getfunctioninfo2-method.md) method to discover the function's parent class, its name, and so on.</span></span>

## <a name="supported-features"></a><span data-ttu-id="98348-141">Podporované funkce</span><span class="sxs-lookup"><span data-stu-id="98348-141">Supported Features</span></span>

<span data-ttu-id="98348-142">Rozhraní API profilování poskytuje informace o nejrůznějších událostech a akcích, ke kterým dochází v modulu CLR (Common Language Runtime).</span><span class="sxs-lookup"><span data-stu-id="98348-142">The profiling API provides information about a variety of events and actions that occur in the common language runtime.</span></span> <span data-ttu-id="98348-143">Tyto informace můžete použít k monitorování vnitřních pracovních postupů procesů a k analýze výkonu aplikace .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="98348-143">You can use this information to monitor the inner workings of processes and to analyze the performance of your .NET Framework application.</span></span>

<span data-ttu-id="98348-144">Rozhraní API profilování načte informace o následujících akcích a událostech, ke kterým dochází v modulu CLR:</span><span class="sxs-lookup"><span data-stu-id="98348-144">The profiling API retrieves information about the following actions and events that occur in the CLR:</span></span>

- <span data-ttu-id="98348-145">Události spuštění a vypnutí CLR</span><span class="sxs-lookup"><span data-stu-id="98348-145">CLR startup and shutdown events.</span></span>

- <span data-ttu-id="98348-146">Události vytvoření a vypnutí domény aplikace.</span><span class="sxs-lookup"><span data-stu-id="98348-146">Application domain creation and shutdown events.</span></span>

- <span data-ttu-id="98348-147">Události načítání a uvolňování sestavení</span><span class="sxs-lookup"><span data-stu-id="98348-147">Assembly loading and unloading events.</span></span>

- <span data-ttu-id="98348-148">Události načítání a uvolňování modulu</span><span class="sxs-lookup"><span data-stu-id="98348-148">Module loading and unloading events.</span></span>

- <span data-ttu-id="98348-149">Vytváření a zničení událostí modelu COM vtable.</span><span class="sxs-lookup"><span data-stu-id="98348-149">COM vtable creation and destruction events.</span></span>

- <span data-ttu-id="98348-150">Kompilace just-in-time (JIT) a události pro rozteč kódu.</span><span class="sxs-lookup"><span data-stu-id="98348-150">Just-in-time (JIT) compilation and code-pitching events.</span></span>

- <span data-ttu-id="98348-151">Události načítání a uvolňování třídy.</span><span class="sxs-lookup"><span data-stu-id="98348-151">Class loading and unloading events.</span></span>

- <span data-ttu-id="98348-152">Události vytvoření a zničení vlákna.</span><span class="sxs-lookup"><span data-stu-id="98348-152">Thread creation and destruction events.</span></span>

- <span data-ttu-id="98348-153">Události vstupu a výstupu funkce</span><span class="sxs-lookup"><span data-stu-id="98348-153">Function entry and exit events.</span></span>

- <span data-ttu-id="98348-154">Výjimky.</span><span class="sxs-lookup"><span data-stu-id="98348-154">Exceptions.</span></span>

- <span data-ttu-id="98348-155">Přechody mezi spravovaným a nespravovaným kódem.</span><span class="sxs-lookup"><span data-stu-id="98348-155">Transitions between managed and unmanaged code execution.</span></span>

- <span data-ttu-id="98348-156">Přechody mezi různými kontexty modulu runtime.</span><span class="sxs-lookup"><span data-stu-id="98348-156">Transitions between different runtime contexts.</span></span>

- <span data-ttu-id="98348-157">Informace o pozastaveních modulu runtime.</span><span class="sxs-lookup"><span data-stu-id="98348-157">Information about runtime suspensions.</span></span>

- <span data-ttu-id="98348-158">Informace o haldě běhové paměti a aktivitě uvolňování paměti.</span><span class="sxs-lookup"><span data-stu-id="98348-158">Information about the runtime memory heap and garbage collection activity.</span></span>

<span data-ttu-id="98348-159">Rozhraní API profilování se dá volat z libovolného (nespravovaného) jazyka kompatibilního s modelem COM.</span><span class="sxs-lookup"><span data-stu-id="98348-159">The profiling API can be called from any (non-managed) COM-compatible language.</span></span>

<span data-ttu-id="98348-160">Rozhraní API je efektivní z hlediska využití procesoru a paměti.</span><span class="sxs-lookup"><span data-stu-id="98348-160">The API is efficient with regard to CPU and memory consumption.</span></span> <span data-ttu-id="98348-161">Profilace nezahrnuje změny profilované aplikace, které jsou dostatečně významné, aby způsobily zavádějící výsledky.</span><span class="sxs-lookup"><span data-stu-id="98348-161">Profiling does not involve changes to the profiled application that are significant enough to cause misleading results.</span></span>

<span data-ttu-id="98348-162">Rozhraní API profilování je užitečné pro vzorkování i pro nástroje, které nejsou vzorkovací.</span><span class="sxs-lookup"><span data-stu-id="98348-162">The profiling API is useful to both sampling and non-sampling profilers.</span></span> <span data-ttu-id="98348-163">*Profiler vzorkování* kontroluje profil v pravidelných taktech, například 5 milisekund od sebe.</span><span class="sxs-lookup"><span data-stu-id="98348-163">A *sampling profiler* inspects the profile at regular clock ticks, say, at 5 milliseconds apart.</span></span> <span data-ttu-id="98348-164">*Profiler bez vzorkování* je informován o události synchronně s vláknem, které způsobuje událost.</span><span class="sxs-lookup"><span data-stu-id="98348-164">A *non-sampling profiler* is informed of an event synchronously with the thread that causes the event.</span></span>

### <a name="unsupported-functionality"></a><span data-ttu-id="98348-165">Nepodporované funkce</span><span class="sxs-lookup"><span data-stu-id="98348-165">Unsupported Functionality</span></span>

<span data-ttu-id="98348-166">Rozhraní API profilování nepodporuje následující funkce:</span><span class="sxs-lookup"><span data-stu-id="98348-166">The profiling API does not support the following functionality:</span></span>

- <span data-ttu-id="98348-167">Nespravovaný kód, který musí být profilovaná pomocí konvenčních metod Win32.</span><span class="sxs-lookup"><span data-stu-id="98348-167">Unmanaged code, which must be profiled using conventional Win32 methods.</span></span> <span data-ttu-id="98348-168">Profiler CLR ale obsahuje přechodné události pro určení hranic mezi spravovaným a nespravovaným kódem.</span><span class="sxs-lookup"><span data-stu-id="98348-168">However, the CLR profiler includes transition events to determine the boundaries between managed and unmanaged code.</span></span>

- <span data-ttu-id="98348-169">Vlastní úprava aplikací, které upravují jejich vlastní kód pro účely, jako je například programování orientované na jednotlivé aspekty.</span><span class="sxs-lookup"><span data-stu-id="98348-169">Self-modifying applications that modify their own code for purposes such as aspect-oriented programming.</span></span>

- <span data-ttu-id="98348-170">Kontrola hranic, protože rozhraní API profilování tyto informace neposkytuje.</span><span class="sxs-lookup"><span data-stu-id="98348-170">Bounds checking, because the profiling API does not provide this information.</span></span> <span data-ttu-id="98348-171">CLR poskytuje vnitřní podporu pro kontrolu hranic veškerého spravovaného kódu.</span><span class="sxs-lookup"><span data-stu-id="98348-171">The CLR provides intrinsic support for bounds checking of all managed code.</span></span>

- <span data-ttu-id="98348-172">Vzdálené profilování, které se nepodporuje z následujících důvodů:</span><span class="sxs-lookup"><span data-stu-id="98348-172">Remote profiling, which is not supported for the following reasons:</span></span>

  - <span data-ttu-id="98348-173">Vzdálené profilování rozšiřuje dobu provádění.</span><span class="sxs-lookup"><span data-stu-id="98348-173">Remote profiling extends execution time.</span></span> <span data-ttu-id="98348-174">Pokud používáte rozhraní profilování, je nutné minimalizovat dobu spuštění, aby se výsledky profilace neprojevily.</span><span class="sxs-lookup"><span data-stu-id="98348-174">When you use the profiling interfaces, you must minimize execution time so that profiling results will not be unduly affected.</span></span> <span data-ttu-id="98348-175">To platí zejména při monitorování výkonu provádění.</span><span class="sxs-lookup"><span data-stu-id="98348-175">This is especially true when execution performance is being monitored.</span></span> <span data-ttu-id="98348-176">Vzdálené profilování však není omezením, když jsou rozhraní profilování používána k monitorování využití paměti nebo k získání běhových informací o rámcích zásobníku, objektech a tak dále.</span><span class="sxs-lookup"><span data-stu-id="98348-176">However, remote profiling is not a limitation when the profiling interfaces are used to monitor memory usage or to obtain run-time information about stack frames, objects, and so on.</span></span>

  - <span data-ttu-id="98348-177">Profiler kódu CLR musí zaregistrovat jedno nebo více rozhraní zpětného volání s modulem runtime v místním počítači, na kterém je spuštěn profilovaná aplikace.</span><span class="sxs-lookup"><span data-stu-id="98348-177">The CLR code profiler must register one or more callback interfaces with the runtime on the local computer on which the profiled application is running.</span></span> <span data-ttu-id="98348-178">Tím se omezí možnost vytvářet Profiler vzdáleného kódu.</span><span class="sxs-lookup"><span data-stu-id="98348-178">This limits the ability to create a remote code profiler.</span></span>

- <span data-ttu-id="98348-179">Profilace v produkčním prostředí s požadavky na vysokou dostupnost.</span><span class="sxs-lookup"><span data-stu-id="98348-179">Profiling in production environments with high-availability requirements.</span></span> <span data-ttu-id="98348-180">Rozhraní API profilování bylo vytvořeno za účelem podpory diagnostiky při vývoji.</span><span class="sxs-lookup"><span data-stu-id="98348-180">The profiling API was created to support development-time diagnostics.</span></span> <span data-ttu-id="98348-181">Neprošlo přísným testováním vyžadovaným pro podporu produkčních prostředí.</span><span class="sxs-lookup"><span data-stu-id="98348-181">It has not undergone the rigorous testing required to support production environments.</span></span>

## <a name="notification-threads"></a><span data-ttu-id="98348-182">Vlákna oznámení</span><span class="sxs-lookup"><span data-stu-id="98348-182">Notification Threads</span></span>

<span data-ttu-id="98348-183">Ve většině případů vlákno, které generuje událost, také spouští oznámení.</span><span class="sxs-lookup"><span data-stu-id="98348-183">In most cases, the thread that generates an event also executes notifications.</span></span> <span data-ttu-id="98348-184">Taková oznámení (například [FunctionEnter –](functionenter-function.md) a [FunctionLeave –](functionleave-function.md)) nemusejí zadávat explicitní `ThreadID`.</span><span class="sxs-lookup"><span data-stu-id="98348-184">Such notifications (for example, [FunctionEnter](functionenter-function.md) and [FunctionLeave](functionleave-function.md)) do not need to supply the explicit `ThreadID`.</span></span> <span data-ttu-id="98348-185">Profiler se také může rozhodnout použít místní úložiště vlákna k ukládání a aktualizaci bloků analýz namísto indexování bloků analýzy v globálním úložišti, a to na základě `ThreadID` ovlivněného vlákna.</span><span class="sxs-lookup"><span data-stu-id="98348-185">Also, the profiler might decide to use thread-local storage to store and update its analysis blocks instead of indexing the analysis blocks in global storage, based on the `ThreadID` of the affected thread.</span></span>

<span data-ttu-id="98348-186">Všimněte si, že tato zpětná volání nejsou serializována.</span><span class="sxs-lookup"><span data-stu-id="98348-186">Note that these callbacks are not serialized.</span></span> <span data-ttu-id="98348-187">Uživatelé musí chránit svůj kód vytvořením datových struktur bezpečných pro přístup z více vláken a uzamknutím kódu profileru, pokud je to nutné, aby se zabránilo paralelnímu přístupu z více vláken</span><span class="sxs-lookup"><span data-stu-id="98348-187">Users must protect their code by creating thread-safe data structures and by locking the profiler code where necessary to prevent parallel access from multiple threads.</span></span> <span data-ttu-id="98348-188">Proto v některých případech můžete obdržet neobvyklou posloupnost zpětných volání.</span><span class="sxs-lookup"><span data-stu-id="98348-188">Therefore, in certain cases you can receive an unusual sequence of callbacks.</span></span> <span data-ttu-id="98348-189">Předpokládejme například, že spravovaná aplikace vytváří dvě vlákna, která spouštějí stejný kód.</span><span class="sxs-lookup"><span data-stu-id="98348-189">For example, assume that a managed application is spawning two threads that are executing identical code.</span></span> <span data-ttu-id="98348-190">V tomto případě je možné přijmout událost [ICorProfilerCallback:: JITCompilationStarted –](icorprofilercallback-jitcompilationstarted-method.md) pro určitou funkci z jednoho vlákna a zpětného volání `FunctionEnter` z druhého vlákna před příjmem zpětného volání [ICorProfilerCallback:: JITCompilationFinished –](icorprofilercallback-jitcompilationfinished-method.md) .</span><span class="sxs-lookup"><span data-stu-id="98348-190">In this case, it is possible to receive a [ICorProfilerCallback::JITCompilationStarted](icorprofilercallback-jitcompilationstarted-method.md) event for some function from one thread and a `FunctionEnter` callback from the other thread before receiving the [ICorProfilerCallback::JITCompilationFinished](icorprofilercallback-jitcompilationfinished-method.md) callback.</span></span> <span data-ttu-id="98348-191">V takovém případě bude uživatel obdržet `FunctionEnter` zpětného volání pro funkci, která pravděpodobně nebyla dosud plně zkompilována za běhu (just-in-time).</span><span class="sxs-lookup"><span data-stu-id="98348-191">In this case, the user will receive a `FunctionEnter` callback for a function that may not have been fully just-in-time (JIT) compiled yet.</span></span>

## <a name="security"></a><span data-ttu-id="98348-192">Zabezpečení –</span><span class="sxs-lookup"><span data-stu-id="98348-192">Security</span></span>

<span data-ttu-id="98348-193">Knihovna DLL profileru je nespravovaná knihovna DLL, která se spouští jako součást modulu pro spuštění společného jazykového modulu runtime.</span><span class="sxs-lookup"><span data-stu-id="98348-193">A profiler DLL is an unmanaged DLL that runs as part of the common language runtime execution engine.</span></span> <span data-ttu-id="98348-194">V důsledku toho kód v profileru DLL nepodléhá omezením zabezpečení přístupu spravovaného kódu.</span><span class="sxs-lookup"><span data-stu-id="98348-194">As a result, the code in the profiler DLL is not subject to the restrictions of managed code access security.</span></span> <span data-ttu-id="98348-195">Jediným omezením v knihovně DLL profileru jsou ta, která je uložená operačním systémem pro uživatele, který používá profilované aplikace.</span><span class="sxs-lookup"><span data-stu-id="98348-195">The only limitations on the profiler DLL are those imposed by the operating system on the user who is running the profiled application.</span></span>

<span data-ttu-id="98348-196">Autoři profileru by měli přijmout vhodná opatření, aby se předešlo problémům souvisejícím se zabezpečením.</span><span class="sxs-lookup"><span data-stu-id="98348-196">Profiler authors should take appropriate precautions to avoid security-related issues.</span></span> <span data-ttu-id="98348-197">Během instalace by se například měl profil DLL profileru přidat do seznamu řízení přístupu (ACL), aby ho uživatel se zlými úmysly nemohl změnit.</span><span class="sxs-lookup"><span data-stu-id="98348-197">For example, during installation, a profiler DLL should be added to an access control list (ACL) so that a malicious user cannot modify it.</span></span>

## <a name="combining-managed-and-unmanaged-code-in-a-code-profiler"></a><span data-ttu-id="98348-198">Kombinování spravovaného a nespravovaného kódu v profileru kódu</span><span class="sxs-lookup"><span data-stu-id="98348-198">Combining Managed and Unmanaged Code in a Code Profiler</span></span>

<span data-ttu-id="98348-199">Nesprávně napsaný profiler může způsobit cyklické odkazy na sebe sama, což vede k nepředvídatelnému chování.</span><span class="sxs-lookup"><span data-stu-id="98348-199">An incorrectly written profiler can cause circular references to itself, resulting in unpredictable behavior.</span></span>

<span data-ttu-id="98348-200">Kontrola rozhraní API profilování CLR může vytvořit dojem, že můžete napsat Profiler, který obsahuje spravované a nespravované součásti, které jsou vzájemně volány prostřednictvím zprostředkovatele komunikace s objekty COM nebo nepřímými voláními.</span><span class="sxs-lookup"><span data-stu-id="98348-200">A review of the CLR profiling API may create the impression that you can write a profiler that contains managed and unmanaged components that call each other through COM interop or indirect calls.</span></span>

<span data-ttu-id="98348-201">I když je to možné z perspektivy návrhu, rozhraní API profilování nepodporuje spravované součásti.</span><span class="sxs-lookup"><span data-stu-id="98348-201">Although this is possible from a design perspective, the profiling API does not support managed components.</span></span> <span data-ttu-id="98348-202">Profiler CLR musí být zcela nespravovaný.</span><span class="sxs-lookup"><span data-stu-id="98348-202">A CLR profiler must be completely unmanaged.</span></span> <span data-ttu-id="98348-203">Pokusy o kombinování spravovaného a nespravovaného kódu v profileru CLR můžou způsobit narušení přístupu, selhání programu nebo zablokování.</span><span class="sxs-lookup"><span data-stu-id="98348-203">Attempts to combine managed and unmanaged code in a CLR profiler may cause access violations, program failure, or deadlocks.</span></span> <span data-ttu-id="98348-204">Spravované součásti profileru spustí události zpět do jejich nespravovaných komponent, které by následně znovu volaly spravované komponenty, což vede k cyklickým odkazům.</span><span class="sxs-lookup"><span data-stu-id="98348-204">The managed components of the profiler will fire events back to their unmanaged components, which would subsequently call the managed components again, resulting in circular references.</span></span>

<span data-ttu-id="98348-205">Jediné místo, kde Profiler CLR může bezpečně volat spravovaný kód, je v těle metody jazyka MSIL (Microsoft Intermediate Language).</span><span class="sxs-lookup"><span data-stu-id="98348-205">The only location where a CLR profiler can call managed code safely is in the Microsoft intermediate language (MSIL) body of a method.</span></span> <span data-ttu-id="98348-206">Doporučený postup pro úpravu těla jazyka MSIL je použití metod rekompilace JIT v rozhraní [ICorProfilerCallback4](icorprofilercallback4-interface.md) .</span><span class="sxs-lookup"><span data-stu-id="98348-206">The recommended practice for modifying the MSIL body is to use the  JIT recompilation methods in the [ICorProfilerCallback4](icorprofilercallback4-interface.md) interface.</span></span>

<span data-ttu-id="98348-207">Je také možné použít starší metody instrumentace pro úpravu jazyka MSIL.</span><span class="sxs-lookup"><span data-stu-id="98348-207">It is also possible to use the older instrumentation methods to modify MSIL.</span></span> <span data-ttu-id="98348-208">Před dokončením kompilace funkce just-in-time (JIT) může Profiler vložit spravovaná volání do těla jazyka MSIL metody a následně je zkompilovat JIT (viz metoda [ICorProfilerInfo:: GetILFunctionBody –](icorprofilerinfo-getilfunctionbody-method.md) ).</span><span class="sxs-lookup"><span data-stu-id="98348-208">Before the just-in-time (JIT) compilation of a function is completed, the profiler can insert managed calls in the MSIL body of a method and then JIT-compile it (see the [ICorProfilerInfo::GetILFunctionBody](icorprofilerinfo-getilfunctionbody-method.md) method).</span></span> <span data-ttu-id="98348-209">Tato technika se dá úspěšně použít pro selektivní instrumentaci spravovaného kódu nebo pro shromažďování dat o statistice a výkonu o JIT.</span><span class="sxs-lookup"><span data-stu-id="98348-209">This technique can successfully be used for selective instrumentation of managed code, or to gather statistics and performance data about the JIT.</span></span>

<span data-ttu-id="98348-210">Případně může Profiler kódu vložit nativní háky v těle jazyka MSIL každé spravované funkce, která volá do nespravovaného kódu.</span><span class="sxs-lookup"><span data-stu-id="98348-210">Alternatively, a code profiler can insert native hooks in the MSIL body of every managed function that calls into unmanaged code.</span></span> <span data-ttu-id="98348-211">Tato technika se dá použít k instrumentaci a pokrytí.</span><span class="sxs-lookup"><span data-stu-id="98348-211">This technique can be used for instrumentation and coverage.</span></span> <span data-ttu-id="98348-212">Například Profiler kódu může vložit háky instrumentace po každém bloku MSIL, aby bylo zajištěno, že byl blok proveden.</span><span class="sxs-lookup"><span data-stu-id="98348-212">For example, a code profiler could insert instrumentation hooks after every MSIL block to ensure that the block has been executed.</span></span> <span data-ttu-id="98348-213">Modifikace těla jazyka MSIL metody je velmi jemná operace a existuje mnoho faktorů, které je třeba vzít v úvahu.</span><span class="sxs-lookup"><span data-stu-id="98348-213">The modification of the MSIL body of a method is a very delicate operation, and there are many factors that should be taken into consideration.</span></span>

## <a name="profiling-unmanaged-code"></a><span data-ttu-id="98348-214">Profilování nespravovaného kódu</span><span class="sxs-lookup"><span data-stu-id="98348-214">Profiling Unmanaged Code</span></span>

<span data-ttu-id="98348-215">Rozhraní API pro profilaci modulu CLR (Common Language Runtime) poskytuje minimální podporu pro profilování nespravovaného kódu.</span><span class="sxs-lookup"><span data-stu-id="98348-215">The common language runtime (CLR) profiling API provides minimal support for profiling unmanaged code.</span></span> <span data-ttu-id="98348-216">K dispozici jsou následující funkce:</span><span class="sxs-lookup"><span data-stu-id="98348-216">The following functionality is provided:</span></span>

- <span data-ttu-id="98348-217">Výčet řetězů zásobníku.</span><span class="sxs-lookup"><span data-stu-id="98348-217">Enumeration of stack chains.</span></span> <span data-ttu-id="98348-218">Tato funkce umožňuje profileru kódu určit hranici mezi spravovaným kódem a nespravovaným kódem.</span><span class="sxs-lookup"><span data-stu-id="98348-218">This feature enables a code profiler to determine the boundary between managed code and unmanaged code.</span></span>

- <span data-ttu-id="98348-219">Určení, zda řetěz zásobníku odpovídá spravovanému kódu nebo nativnímu kódu.</span><span class="sxs-lookup"><span data-stu-id="98348-219">Determination whether a stack chain corresponds to managed code or native code.</span></span>

<span data-ttu-id="98348-220">V .NET Framework verzích 1,0 a 1,1 jsou tyto metody k dispozici prostřednictvím dílčí sady v rámci procesu rozhraní API pro ladění CLR.</span><span class="sxs-lookup"><span data-stu-id="98348-220">In the .NET Framework versions 1.0 and 1.1, these methods are available through the in-process subset of the CLR debugging API.</span></span> <span data-ttu-id="98348-221">Jsou definovány v souboru CorDebug. idl.</span><span class="sxs-lookup"><span data-stu-id="98348-221">They are defined in the CorDebug.idl file.</span></span>

<span data-ttu-id="98348-222">V .NET Framework 2,0 a novějších můžete pro tuto funkci použít metodu [ICorProfilerInfo2::D ostacksnapshot](icorprofilerinfo2-dostacksnapshot-method.md) .</span><span class="sxs-lookup"><span data-stu-id="98348-222">In the .NET Framework 2.0 and later, you can use the [ICorProfilerInfo2::DoStackSnapshot](icorprofilerinfo2-dostacksnapshot-method.md) method for this functionality.</span></span>

## <a name="using-com"></a><span data-ttu-id="98348-223">Používání modelu COM</span><span class="sxs-lookup"><span data-stu-id="98348-223">Using COM</span></span>

<span data-ttu-id="98348-224">I když jsou rozhraní profilace definována jako rozhraní COM, modul CLR (Common Language Runtime) ve skutečnosti neinicializuje model COM pro použití těchto rozhraní.</span><span class="sxs-lookup"><span data-stu-id="98348-224">Although the profiling interfaces are defined as COM interfaces, the common language runtime (CLR) does not actually initialize COM to use these interfaces.</span></span> <span data-ttu-id="98348-225">Důvodem je, že nemusíte nastavovat model vláken pomocí funkce [CoInitialize](/windows/desktop/api/objbase/nf-objbase-coinitialize) předtím, než spravovaná aplikace měla možnost určit požadovaný model vláken.</span><span class="sxs-lookup"><span data-stu-id="98348-225">The reason is to avoid having to set the threading model by using the [CoInitialize](/windows/desktop/api/objbase/nf-objbase-coinitialize) function before the managed application has had a chance to specify its desired threading model.</span></span> <span data-ttu-id="98348-226">Podobně samotný Profiler by neměl volat `CoInitialize`, protože může vybrat model vláken, který je nekompatibilní s aplikací, která je profilovaná a může způsobit selhání aplikace.</span><span class="sxs-lookup"><span data-stu-id="98348-226">Similarly, the profiler itself should not call `CoInitialize`, because it may pick a threading model that is incompatible with the application being profiled and may cause the application to fail.</span></span>

## <a name="call-stacks"></a><span data-ttu-id="98348-227">Zásobníky volání</span><span class="sxs-lookup"><span data-stu-id="98348-227">Call Stacks</span></span>

<span data-ttu-id="98348-228">Rozhraní API profilování poskytuje dva způsoby, jak získat zásobníky volání: metodu snímku zásobníku, která umožňuje zhuštěné shromažďování zásobníků volání, a metodu stínového zásobníku, která sleduje zásobník volání při každém okamžitém běhu.</span><span class="sxs-lookup"><span data-stu-id="98348-228">The profiling API provides two ways to obtain call stacks: a stack snapshot method, which enables sparse gathering of call stacks, and a shadow stack method, which tracks the call stack at every instant.</span></span>

### <a name="stack-snapshot"></a><span data-ttu-id="98348-229">Snímek zásobníku</span><span class="sxs-lookup"><span data-stu-id="98348-229">Stack Snapshot</span></span>

<span data-ttu-id="98348-230">Snímek zásobníku je trasování zásobníku vlákna v okamžitém čase.</span><span class="sxs-lookup"><span data-stu-id="98348-230">A stack snapshot is a trace of the stack of a thread at an instant in time.</span></span> <span data-ttu-id="98348-231">Rozhraní API profilování podporuje trasování spravovaných funkcí v zásobníku, ale opustí trasování nespravovaných funkcí do vlastního zásobníku prohlížeč profileru.</span><span class="sxs-lookup"><span data-stu-id="98348-231">The profiling API supports the tracing of managed functions on the stack, but it leaves the tracing of unmanaged functions to the profiler's own stack walker.</span></span>

<span data-ttu-id="98348-232">Další informace o tom, jak profiler naprogramovat, aby provedl spravované zásobníky, najdete v části [ICorProfilerInfo2::D ostacksnapshot](icorprofilerinfo2-dostacksnapshot-method.md) v této dokumentaci a [v zásobníku profileru v .NET Framework 2,0: základy a mimo ni](https://docs.microsoft.com/previous-versions/dotnet/articles/bb264782(v=msdn.10)).</span><span class="sxs-lookup"><span data-stu-id="98348-232">For more information about how to program the profiler to walk managed stacks, see the [ICorProfilerInfo2::DoStackSnapshot](icorprofilerinfo2-dostacksnapshot-method.md) method in this documentation set, and [Profiler Stack Walking in the .NET Framework 2.0: Basics and Beyond](https://docs.microsoft.com/previous-versions/dotnet/articles/bb264782(v=msdn.10)).</span></span>

### <a name="shadow-stack"></a><span data-ttu-id="98348-233">Stínový zásobník</span><span class="sxs-lookup"><span data-stu-id="98348-233">Shadow Stack</span></span>

<span data-ttu-id="98348-234">Použití metody Snapshot moc často může rychle vytvořit problém s výkonem.</span><span class="sxs-lookup"><span data-stu-id="98348-234">Using the snapshot method too frequently can quickly create a performance issue.</span></span> <span data-ttu-id="98348-235">Pokud chcete přebírat trasování zásobníku často, váš Profiler by měl vytvořit stínový zásobník pomocí zpětného volání výjimek [FunctionEnter2](functionenter2-function.md), [FunctionLeave2 –](functionleave2-function.md), [FunctionTailcall2 –](functiontailcall2-function.md)a [ICorProfilerCallback2](icorprofilercallback2-interface.md) .</span><span class="sxs-lookup"><span data-stu-id="98348-235">If you want to take stack traces frequently, your profiler should instead build a shadow stack by using the [FunctionEnter2](functionenter2-function.md), [FunctionLeave2](functionleave2-function.md), [FunctionTailcall2](functiontailcall2-function.md), and [ICorProfilerCallback2](icorprofilercallback2-interface.md) exception callbacks.</span></span> <span data-ttu-id="98348-236">Stínový zásobník je vždycky aktuální a dá se rychle zkopírovat do úložiště, kdykoli je potřeba snímek zásobníku.</span><span class="sxs-lookup"><span data-stu-id="98348-236">The shadow stack is always current and can quickly be copied to storage whenever a stack snapshot is needed.</span></span>

<span data-ttu-id="98348-237">Stínový zásobník může získat argumenty funkce, vracet hodnoty a informace o obecných instancích.</span><span class="sxs-lookup"><span data-stu-id="98348-237">A shadow stack may obtain function arguments, return values, and information about generic instantiations.</span></span> <span data-ttu-id="98348-238">Tyto informace jsou k dispozici pouze prostřednictvím stínového zásobníku a lze je získat, pokud je ovládací prvek předán funkci.</span><span class="sxs-lookup"><span data-stu-id="98348-238">This information is available only through the shadow stack and may be obtained when control is handed to a function.</span></span> <span data-ttu-id="98348-239">Tyto informace ale nemusí být k dispozici později během spuštění funkce.</span><span class="sxs-lookup"><span data-stu-id="98348-239">However, this information may not be available later during the run of the function.</span></span>

## <a name="callbacks-and-stack-depth"></a><span data-ttu-id="98348-240">Zpětná volání a Hloubka zásobníku</span><span class="sxs-lookup"><span data-stu-id="98348-240">Callbacks and Stack Depth</span></span>

<span data-ttu-id="98348-241">Zpětná volání profileru mohou být vydávána v podmínkách s velmi omezenými zásobníky a přetečení zásobníku v rámci zpětného volání profileru vede k okamžitému ukončení procesu.</span><span class="sxs-lookup"><span data-stu-id="98348-241">Profiler callbacks may be issued in very stack-constrained circumstances, and a stack overflow in a profiler callback will lead to an immediate process exit.</span></span> <span data-ttu-id="98348-242">Profiler by měl v reakci na zpětná volání používat co nejmenší zásobník.</span><span class="sxs-lookup"><span data-stu-id="98348-242">A profiler should make sure to use as little stack as possible in response to callbacks.</span></span> <span data-ttu-id="98348-243">Pokud je profiler určený pro použití proti procesům, které jsou robustní proti přetečení zásobníku, měl by samotný Profiler také zabránit spuštění přetečení zásobníku.</span><span class="sxs-lookup"><span data-stu-id="98348-243">If the profiler is intended for use against processes that are robust against stack overflow, the profiler itself should also avoid triggering stack overflow.</span></span>

## <a name="related-topics"></a><span data-ttu-id="98348-244">Související témata</span><span class="sxs-lookup"><span data-stu-id="98348-244">Related Topics</span></span>

|<span data-ttu-id="98348-245">Název</span><span class="sxs-lookup"><span data-stu-id="98348-245">Title</span></span>|<span data-ttu-id="98348-246">Popis</span><span class="sxs-lookup"><span data-stu-id="98348-246">Description</span></span>|
|-----------|-----------------|
|[<span data-ttu-id="98348-247">Nastavení prostředí profilace</span><span class="sxs-lookup"><span data-stu-id="98348-247">Setting Up a Profiling Environment</span></span>](setting-up-a-profiling-environment.md)|<span data-ttu-id="98348-248">Vysvětluje, jak inicializovat Profiler, nastavit oznámení událostí a profilovat službu systému Windows.</span><span class="sxs-lookup"><span data-stu-id="98348-248">Explains how to initialize a profiler, set event notifications, and profile a Windows Service.</span></span>|
|[<span data-ttu-id="98348-249">Rozhraní pro profilaci</span><span class="sxs-lookup"><span data-stu-id="98348-249">Profiling Interfaces</span></span>](profiling-interfaces.md)|<span data-ttu-id="98348-250">Popisuje nespravovaná rozhraní, která používá profilování API.</span><span class="sxs-lookup"><span data-stu-id="98348-250">Describes the unmanaged interfaces that the profiling API uses.</span></span>|
|[<span data-ttu-id="98348-251">Globální statické funkce pro profilaci</span><span class="sxs-lookup"><span data-stu-id="98348-251">Profiling Global Static Functions</span></span>](profiling-global-static-functions.md)|<span data-ttu-id="98348-252">Popisuje nespravované globální statické funkce, které používá profilování API.</span><span class="sxs-lookup"><span data-stu-id="98348-252">Describes the unmanaged global static functions that the profiling API uses.</span></span>|
|[<span data-ttu-id="98348-253">Výčty pro profilaci</span><span class="sxs-lookup"><span data-stu-id="98348-253">Profiling Enumerations</span></span>](profiling-enumerations.md)|<span data-ttu-id="98348-254">Popisuje nespravované výčty, které používá profilování API.</span><span class="sxs-lookup"><span data-stu-id="98348-254">Describes the unmanaged enumerations that the profiling API uses.</span></span>|
|[<span data-ttu-id="98348-255">Struktury pro profilaci</span><span class="sxs-lookup"><span data-stu-id="98348-255">Profiling Structures</span></span>](profiling-structures.md)|<span data-ttu-id="98348-256">Popisuje nespravované struktury, které používá profilování API.</span><span class="sxs-lookup"><span data-stu-id="98348-256">Describes the unmanaged structures that the profiling API uses.</span></span>|
