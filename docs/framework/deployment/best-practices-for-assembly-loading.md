---
title: Doporučené postupy pro načtení sestavení
description: Prozkoumejte osvědčené postupy pro načítání sestavení v .NET. Vyhněte se problémům typu identity, které mohou vést k neplatným přetypování, chybějícím metodám a jiným výjimkám.
ms.date: 03/30/2017
helpviewer_keywords:
- assemblies,binding
- LoadFrom method
- default load context
- TypeLoadException class,causes
- assembly loading errors
- load contexts
- assemblies,loading
- LoadWithPartialName method
- load-from context
ms.assetid: 68d1c539-6a47-4614-ab59-4b071c9d4b4c
ms.openlocfilehash: 8ee5243258ea1b853b4690b79ec032c46d1b3777
ms.sourcegitcommit: c23d9666ec75b91741da43ee3d91c317d68c7327
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 07/01/2020
ms.locfileid: "85803494"
---
# <a name="best-practices-for-assembly-loading"></a><span data-ttu-id="10cf2-104">Doporučené postupy pro načtení sestavení</span><span class="sxs-lookup"><span data-stu-id="10cf2-104">Best Practices for Assembly Loading</span></span>
<span data-ttu-id="10cf2-105">Tento článek popisuje způsoby, jak zabránit problémům s typem identity, který může vést k <xref:System.InvalidCastException> <xref:System.MissingMethodException> chybám, a.</span><span class="sxs-lookup"><span data-stu-id="10cf2-105">This article discusses ways to avoid problems of type identity that can lead to <xref:System.InvalidCastException>, <xref:System.MissingMethodException>, and other errors.</span></span> <span data-ttu-id="10cf2-106">Tento článek popisuje následující doporučení:</span><span class="sxs-lookup"><span data-stu-id="10cf2-106">The article discusses the following recommendations:</span></span>  
  
- [<span data-ttu-id="10cf2-107">Porozumění výhodám a nevýhodám zátěžových kontextů</span><span class="sxs-lookup"><span data-stu-id="10cf2-107">Understand the advantages and disadvantages of load contexts</span></span>](#load_contexts)  
  
- [<span data-ttu-id="10cf2-108">Vyhněte se vazbě na částečných názvech sestavení</span><span class="sxs-lookup"><span data-stu-id="10cf2-108">Avoid binding on partial assembly names</span></span>](#avoid_partial_names)  
  
- [<span data-ttu-id="10cf2-109">Vyhnout se načítání sestavení do více kontextů</span><span class="sxs-lookup"><span data-stu-id="10cf2-109">Avoid loading an assembly into multiple contexts</span></span>](#avoid_loading_into_multiple_contexts)  
  
- [<span data-ttu-id="10cf2-110">Vyhněte se načítání více verzí sestavení do stejného kontextu</span><span class="sxs-lookup"><span data-stu-id="10cf2-110">Avoid loading multiple versions of an assembly into the same context</span></span>](#avoid_loading_multiple_versions)  
  
- [<span data-ttu-id="10cf2-111">Zvažte přechod na výchozí kontext načtení.</span><span class="sxs-lookup"><span data-stu-id="10cf2-111">Consider switching to the default load context</span></span>](#switch_to_default)  
  
 <span data-ttu-id="10cf2-112">První doporučení, [porozumět výhodám a nevýhodám zátěžových kontextů](#load_contexts), poskytuje základní informace o dalších doporučeních, protože všechny jsou závislé na znalostech kontextů zatížení.</span><span class="sxs-lookup"><span data-stu-id="10cf2-112">The first recommendation, [understand the advantages and disadvantages of load contexts](#load_contexts), provides background information for the other recommendations, because they all depend on a knowledge of load contexts.</span></span>  
  
<a name="load_contexts"></a>
## <a name="understand-the-advantages-and-disadvantages-of-load-contexts"></a><span data-ttu-id="10cf2-113">Porozumění výhodám a nevýhodám zátěžových kontextů</span><span class="sxs-lookup"><span data-stu-id="10cf2-113">Understand the Advantages and Disadvantages of Load Contexts</span></span>  
 <span data-ttu-id="10cf2-114">V rámci domény aplikace mohou být sestavení načtena do jednoho ze tří kontextů, nebo mohou být načtena bez kontextu:</span><span class="sxs-lookup"><span data-stu-id="10cf2-114">Within an application domain, assemblies can be loaded into one of three contexts, or they can be loaded without context:</span></span>  
  
- <span data-ttu-id="10cf2-115">Výchozí kontext načtení obsahuje sestavení zjištěná při zjišťování globální mezipaměti sestavení (GAC), úložiště sestavení hostitele, pokud je modul runtime hostován (například v SQL Server), a v <xref:System.AppDomainSetup.ApplicationBase%2A> <xref:System.AppDomainSetup.PrivateBinPath%2A> doméně aplikace.</span><span class="sxs-lookup"><span data-stu-id="10cf2-115">The default load context contains assemblies found by probing the global assembly cache, the host assembly store if the runtime is hosted (for example, in SQL Server), and the <xref:System.AppDomainSetup.ApplicationBase%2A> and <xref:System.AppDomainSetup.PrivateBinPath%2A> of the application domain.</span></span> <span data-ttu-id="10cf2-116">Většina přetížení <xref:System.Reflection.Assembly.Load%2A> metody načítají sestavení do tohoto kontextu.</span><span class="sxs-lookup"><span data-stu-id="10cf2-116">Most overloads of the <xref:System.Reflection.Assembly.Load%2A> method load assemblies into this context.</span></span>  
  
- <span data-ttu-id="10cf2-117">Kontext načtení z obsahuje sestavení, která jsou načtena z umístění, která nejsou prohledávána zavaděčem.</span><span class="sxs-lookup"><span data-stu-id="10cf2-117">The load-from context contains assemblies that are loaded from locations that are not searched by the loader.</span></span> <span data-ttu-id="10cf2-118">Například doplňky mohou být nainstalovány v adresáři, který není v cestě aplikace.</span><span class="sxs-lookup"><span data-stu-id="10cf2-118">For example, add-ins might be installed in a directory that is not under the application path.</span></span> <span data-ttu-id="10cf2-119"><xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType>, <xref:System.AppDomain.CreateInstanceFrom%2A?displayProperty=nameWithType> a <xref:System.AppDomain.ExecuteAssembly%2A?displayProperty=nameWithType> jsou příklady metod, které jsou načteny podle cesty.</span><span class="sxs-lookup"><span data-stu-id="10cf2-119"><xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType>, <xref:System.AppDomain.CreateInstanceFrom%2A?displayProperty=nameWithType>, and <xref:System.AppDomain.ExecuteAssembly%2A?displayProperty=nameWithType> are examples of methods that load by path.</span></span>  
  
- <span data-ttu-id="10cf2-120">Kontext pouze pro reflexi obsahuje sestavení načítaná s <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> metodami a.</span><span class="sxs-lookup"><span data-stu-id="10cf2-120">The reflection-only context contains assemblies loaded with the <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> and <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> methods.</span></span> <span data-ttu-id="10cf2-121">Kód v tomto kontextu nelze provést, takže zde není popsán.</span><span class="sxs-lookup"><span data-stu-id="10cf2-121">Code in this context cannot be executed, so it is not discussed here.</span></span> <span data-ttu-id="10cf2-122">Další informace naleznete v tématu [Postupy: načtení sestavení do kontextu pouze pro reflexi](../reflection-and-codedom/how-to-load-assemblies-into-the-reflection-only-context.md).</span><span class="sxs-lookup"><span data-stu-id="10cf2-122">For more information, see [How to: Load Assemblies into the Reflection-Only Context](../reflection-and-codedom/how-to-load-assemblies-into-the-reflection-only-context.md).</span></span>  
  
- <span data-ttu-id="10cf2-123">Pokud jste vygenerovali přechodné dynamické sestavení pomocí generování reflexe, sestavení není v žádném kontextu.</span><span class="sxs-lookup"><span data-stu-id="10cf2-123">If you generated a transient dynamic assembly by using reflection emit, the assembly is not in any context.</span></span> <span data-ttu-id="10cf2-124">Kromě toho většina sestavení, která jsou načtena pomocí <xref:System.Reflection.Assembly.LoadFile%2A> metody, je načítána bez kontextu a sestavení, která jsou načtena z bajtových polí, jsou načtena bez kontextu, pokud jejich identita (po použití zásady) zjistí, že jsou v globální mezipaměti sestavení (GAC).</span><span class="sxs-lookup"><span data-stu-id="10cf2-124">In addition, most assemblies that are loaded by using the <xref:System.Reflection.Assembly.LoadFile%2A> method are loaded without context, and assemblies that are loaded from byte arrays are loaded without context unless their identity (after policy is applied) establishes that they are in the global assembly cache.</span></span>  
  
 <span data-ttu-id="10cf2-125">Kontexty spuštění mají své výhody a nevýhody, jak je popsáno v následujících částech.</span><span class="sxs-lookup"><span data-stu-id="10cf2-125">The execution contexts have advantages and disadvantages, as discussed in the following sections.</span></span>  
  
### <a name="default-load-context"></a><span data-ttu-id="10cf2-126">Výchozí kontext načtení</span><span class="sxs-lookup"><span data-stu-id="10cf2-126">Default Load Context</span></span>  
 <span data-ttu-id="10cf2-127">Když jsou sestavení načtena do výchozího kontextu načtení, jejich závislosti jsou načteny automaticky.</span><span class="sxs-lookup"><span data-stu-id="10cf2-127">When assemblies are loaded into the default load context, their dependencies are loaded automatically.</span></span> <span data-ttu-id="10cf2-128">Závislosti, které jsou načteny do výchozího kontextu načtení, jsou automaticky nalezeny pro sestavení ve výchozím kontextu načtení nebo v kontextu načtení z.</span><span class="sxs-lookup"><span data-stu-id="10cf2-128">Dependencies that are loaded into the default load context are found automatically for assemblies in the default load context or the load-from context.</span></span> <span data-ttu-id="10cf2-129">Načítání podle identity sestavení zvyšuje stabilitu aplikací tím, že zajišťují, že nejsou použity neznámé verze sestavení (viz oddíl [Vyhněte se vazbám v částečných názvech sestavení](#avoid_partial_names) ).</span><span class="sxs-lookup"><span data-stu-id="10cf2-129">Loading by assembly identity increases the stability of applications by ensuring that unknown versions of assemblies are not used (see the [Avoid Binding on Partial Assembly Names](#avoid_partial_names) section).</span></span>  
  
 <span data-ttu-id="10cf2-130">Použití výchozího kontextu zatížení má následující nevýhody:</span><span class="sxs-lookup"><span data-stu-id="10cf2-130">Using the default load context has the following disadvantages:</span></span>  
  
- <span data-ttu-id="10cf2-131">Závislosti, které jsou načteny do jiných kontextů, nejsou k dispozici.</span><span class="sxs-lookup"><span data-stu-id="10cf2-131">Dependencies that are loaded into other contexts are not available.</span></span>  
  
- <span data-ttu-id="10cf2-132">Sestavení nelze načíst z umístění mimo cestu pro zjišťování do výchozího kontextu načtení.</span><span class="sxs-lookup"><span data-stu-id="10cf2-132">You cannot load assemblies from locations outside the probing path into the default load context.</span></span>  
  
### <a name="load-from-context"></a><span data-ttu-id="10cf2-133">Načíst z kontextu</span><span class="sxs-lookup"><span data-stu-id="10cf2-133">Load-From Context</span></span>  
 <span data-ttu-id="10cf2-134">Kontext načtení z umožňuje načíst sestavení z cesty, která není v cestě aplikace, a proto není zahrnuto do zjišťování.</span><span class="sxs-lookup"><span data-stu-id="10cf2-134">The load-from context lets you load an assembly from a path that is not under the application path, and therefore is not included in probing.</span></span> <span data-ttu-id="10cf2-135">Umožňuje umístění a načtení závislostí z této cesty, protože informace o cestě jsou udržovány v kontextu.</span><span class="sxs-lookup"><span data-stu-id="10cf2-135">It enables dependencies to be located and loaded from that path, because the path information is maintained by the context.</span></span> <span data-ttu-id="10cf2-136">Kromě toho sestavení v tomto kontextu mohou používat závislosti, které jsou načteny do výchozího kontextu načtení.</span><span class="sxs-lookup"><span data-stu-id="10cf2-136">In addition, assemblies in this context can use dependencies that are loaded into the default load context.</span></span>  
  
 <span data-ttu-id="10cf2-137">Načítání sestavení pomocí <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> metody nebo jedné z jiných metod, které jsou načítány pomocí cesty, má následující nevýhody:</span><span class="sxs-lookup"><span data-stu-id="10cf2-137">Loading assemblies by using the <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> method, or one of the other methods that load by path, has the following disadvantages:</span></span>  
  
- <span data-ttu-id="10cf2-138">Pokud je již načteno sestavení se stejnou identitou, <xref:System.Reflection.Assembly.LoadFrom%2A> vrátí načtené sestavení i v případě, že byla zadána jiná cesta.</span><span class="sxs-lookup"><span data-stu-id="10cf2-138">If an assembly with the same identity is already loaded, <xref:System.Reflection.Assembly.LoadFrom%2A> returns the loaded assembly even if a different path was specified.</span></span>  
  
- <span data-ttu-id="10cf2-139">Pokud je sestavení načteno pomocí <xref:System.Reflection.Assembly.LoadFrom%2A> a později se sestavení ve výchozím kontextu načtení pokusí načíst stejné sestavení pomocí zobrazovaného názvu, pokus o načtení se nezdaří.</span><span class="sxs-lookup"><span data-stu-id="10cf2-139">If an assembly is loaded with <xref:System.Reflection.Assembly.LoadFrom%2A>, and later an assembly in the default load context tries to load the same assembly by display name, the load attempt fails.</span></span> <span data-ttu-id="10cf2-140">K tomu může dojít, když je sestavení deserializováno.</span><span class="sxs-lookup"><span data-stu-id="10cf2-140">This can occur when an assembly is deserialized.</span></span>  
  
- <span data-ttu-id="10cf2-141">Pokud je sestavení načteno pomocí <xref:System.Reflection.Assembly.LoadFrom%2A> a cesta ke zjišťování obsahuje sestavení se stejnou identitou, ale v jiném umístění, <xref:System.InvalidCastException> <xref:System.MissingMethodException> může být, nebo jiné neočekávané chování.</span><span class="sxs-lookup"><span data-stu-id="10cf2-141">If an assembly is loaded with <xref:System.Reflection.Assembly.LoadFrom%2A>, and the probing path includes an assembly with the same identity but in a different location, an <xref:System.InvalidCastException>, <xref:System.MissingMethodException>, or other unexpected behavior can occur.</span></span>  
  
- <span data-ttu-id="10cf2-142"><xref:System.Reflection.Assembly.LoadFrom%2A>požaduje <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType> a <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType> , nebo <xref:System.Net.WebPermission> v zadané cestě.</span><span class="sxs-lookup"><span data-stu-id="10cf2-142"><xref:System.Reflection.Assembly.LoadFrom%2A> demands <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType> and <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType>, or <xref:System.Net.WebPermission>, on the specified path.</span></span>  
  
- <span data-ttu-id="10cf2-143">Pokud pro sestavení existuje nativní bitová kopie, není použita.</span><span class="sxs-lookup"><span data-stu-id="10cf2-143">If a native image exists for the assembly, it is not used.</span></span>  
  
- <span data-ttu-id="10cf2-144">Sestavení nelze načíst jako doménově neutrální.</span><span class="sxs-lookup"><span data-stu-id="10cf2-144">The assembly cannot be loaded as domain-neutral.</span></span>  
  
- <span data-ttu-id="10cf2-145">V .NET Framework verzích 1,0 a 1,1 se zásada nepoužívá.</span><span class="sxs-lookup"><span data-stu-id="10cf2-145">In the .NET Framework versions 1.0 and 1.1, policy is not applied.</span></span>  
  
### <a name="no-context"></a><span data-ttu-id="10cf2-146">Žádný kontext</span><span class="sxs-lookup"><span data-stu-id="10cf2-146">No Context</span></span>  
 <span data-ttu-id="10cf2-147">Načtení bez kontextu je jedinou možností pro přechodná sestavení, která jsou generována pomocí generování reflexe.</span><span class="sxs-lookup"><span data-stu-id="10cf2-147">Loading without context is the only option for transient assemblies that are generated with reflection emit.</span></span> <span data-ttu-id="10cf2-148">Načtení bez kontextu je jediným způsobem, jak načíst více sestavení, která mají stejnou identitu do jedné domény aplikace.</span><span class="sxs-lookup"><span data-stu-id="10cf2-148">Loading without context is the only way to load multiple assemblies that have the same identity into one application domain.</span></span> <span data-ttu-id="10cf2-149">Náklady na zjišťování se vyhne.</span><span class="sxs-lookup"><span data-stu-id="10cf2-149">The cost of probing is avoided.</span></span>  
  
 <span data-ttu-id="10cf2-150">Sestavení, která jsou načtena z polí bajtů, jsou načtena bez kontextu, pokud není identita sestavení, která je vytvořena při použití zásady, shodná s identitou sestavení v globální mezipaměti sestavení (GAC). v takovém případě je sestavení načteno z globální mezipaměti sestavení (GAC).</span><span class="sxs-lookup"><span data-stu-id="10cf2-150">Assemblies that are loaded from byte arrays are loaded without context unless the identity of the assembly, which is established when policy is applied, matches the identity of an assembly in the global assembly cache; in that case, the assembly is loaded from the global assembly cache.</span></span>  
  
 <span data-ttu-id="10cf2-151">Načítání sestavení bez kontextu má následující nevýhody:</span><span class="sxs-lookup"><span data-stu-id="10cf2-151">Loading assemblies without context has the following disadvantages:</span></span>  
  
- <span data-ttu-id="10cf2-152">Jiná sestavení nemohou vytvořit vazby na sestavení, která jsou načtena bez kontextu, pokud událost nezpracováváte <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="10cf2-152">Other assemblies cannot bind to assemblies that are loaded without context, unless you handle the <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> event.</span></span>  
  
- <span data-ttu-id="10cf2-153">Závislosti nejsou načteny automaticky.</span><span class="sxs-lookup"><span data-stu-id="10cf2-153">Dependencies are not loaded automatically.</span></span> <span data-ttu-id="10cf2-154">Můžete je předem načíst bez kontextu, předčítat je do výchozího kontextu načtení nebo je načíst pomocí zpracování <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> události.</span><span class="sxs-lookup"><span data-stu-id="10cf2-154">You can preload them without context, preload them into the default load context, or load them by handling the <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> event.</span></span>  
  
- <span data-ttu-id="10cf2-155">Načtení více sestavení se stejnou identitou bez kontextu může způsobit problémy s identitou typu podobné těm, které způsobily načtení sestavení se stejnou identitou do více kontextů.</span><span class="sxs-lookup"><span data-stu-id="10cf2-155">Loading multiple assemblies with the same identity without context can cause type identity problems similar to those caused by loading assemblies with the same identity into multiple contexts.</span></span> <span data-ttu-id="10cf2-156">Viz [Vyhněte se načítání sestavení do více kontextů](#avoid_loading_into_multiple_contexts).</span><span class="sxs-lookup"><span data-stu-id="10cf2-156">See [Avoid Loading an Assembly into Multiple Contexts](#avoid_loading_into_multiple_contexts).</span></span>  
  
- <span data-ttu-id="10cf2-157">Pokud pro sestavení existuje nativní bitová kopie, není použita.</span><span class="sxs-lookup"><span data-stu-id="10cf2-157">If a native image exists for the assembly, it is not used.</span></span>  
  
- <span data-ttu-id="10cf2-158">Sestavení nelze načíst jako doménově neutrální.</span><span class="sxs-lookup"><span data-stu-id="10cf2-158">The assembly cannot be loaded as domain-neutral.</span></span>  
  
- <span data-ttu-id="10cf2-159">V .NET Framework verzích 1,0 a 1,1 se zásada nepoužívá.</span><span class="sxs-lookup"><span data-stu-id="10cf2-159">In the .NET Framework versions 1.0 and 1.1, policy is not applied.</span></span>  
  
<a name="avoid_partial_names"></a>
## <a name="avoid-binding-on-partial-assembly-names"></a><span data-ttu-id="10cf2-160">Vyhněte se vazbě na částečných názvech sestavení</span><span class="sxs-lookup"><span data-stu-id="10cf2-160">Avoid Binding on Partial Assembly Names</span></span>  
 <span data-ttu-id="10cf2-161">Částečná vazba názvu nastane, pokud při načítání sestavení zadáte pouze část zobrazovaného názvu sestavení ( <xref:System.Reflection.Assembly.FullName%2A> ).</span><span class="sxs-lookup"><span data-stu-id="10cf2-161">Partial name binding occurs when you specify only part of the assembly display name (<xref:System.Reflection.Assembly.FullName%2A>) when you load an assembly.</span></span> <span data-ttu-id="10cf2-162">Například můžete zavolat <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> metodu pouze s jednoduchým názvem sestavení a vynechání verze, jazykové verze a tokenu veřejného klíče.</span><span class="sxs-lookup"><span data-stu-id="10cf2-162">For example, you might call the <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> method with only the simple name of the assembly, omitting the version, culture, and public key token.</span></span> <span data-ttu-id="10cf2-163">Případně můžete zavolat <xref:System.Reflection.Assembly.LoadWithPartialName%2A?displayProperty=nameWithType> metodu, která první volá <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> metodu a, pokud se nepovede najít sestavení, prohledá globální mezipaměť sestavení a načte nejnovější dostupnou verzi sestavení.</span><span class="sxs-lookup"><span data-stu-id="10cf2-163">Or you might call the <xref:System.Reflection.Assembly.LoadWithPartialName%2A?displayProperty=nameWithType> method, which first calls the <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> method and, if that fails to locate the assembly, searches the global assembly cache and loads the latest available version of the assembly.</span></span>  
  
 <span data-ttu-id="10cf2-164">Částečná vazba názvu může způsobit mnoho problémů, včetně následujících:</span><span class="sxs-lookup"><span data-stu-id="10cf2-164">Partial name binding can cause many problems, including the following:</span></span>  
  
- <span data-ttu-id="10cf2-165"><xref:System.Reflection.Assembly.LoadWithPartialName%2A?displayProperty=nameWithType>Metoda může načíst jiné sestavení se stejným jednoduchým názvem.</span><span class="sxs-lookup"><span data-stu-id="10cf2-165">The <xref:System.Reflection.Assembly.LoadWithPartialName%2A?displayProperty=nameWithType> method might load a different assembly with the same simple name.</span></span> <span data-ttu-id="10cf2-166">Například dvě aplikace mohou nainstalovat dvě zcela odlišná sestavení, která obě mají jednoduchý název `GraphicsLibrary` do globální mezipaměti sestavení (GAC).</span><span class="sxs-lookup"><span data-stu-id="10cf2-166">For example, two applications might install two completely different assemblies that both have the simple name `GraphicsLibrary` into the global assembly cache.</span></span>  
  
- <span data-ttu-id="10cf2-167">Sestavení, které je skutečně načteno, nemusí být zpětně kompatibilní.</span><span class="sxs-lookup"><span data-stu-id="10cf2-167">The assembly that is actually loaded might not be backward-compatible.</span></span> <span data-ttu-id="10cf2-168">Například pokud není zadána verze, může dojít k nasazování mnohem novější verze než verze, kterou program původně napsal.</span><span class="sxs-lookup"><span data-stu-id="10cf2-168">For example, not specifying the version might result in the loading of a much later version than the version your program was originally written to use.</span></span> <span data-ttu-id="10cf2-169">Změny v novější verzi můžou způsobit chyby ve vaší aplikaci.</span><span class="sxs-lookup"><span data-stu-id="10cf2-169">Changes in the later version might cause errors in your application.</span></span>  
  
- <span data-ttu-id="10cf2-170">Sestavení, které je skutečně načteno, nemusí být kompatibilní s dopředné.</span><span class="sxs-lookup"><span data-stu-id="10cf2-170">The assembly that is actually loaded might not be forward-compatible.</span></span> <span data-ttu-id="10cf2-171">Mohli jste například sestavit a otestovat aplikaci pomocí nejnovější verze sestavení, ale Částečná vazba může načíst mnohem starší verzi, která postrádá funkce, které vaše aplikace používá.</span><span class="sxs-lookup"><span data-stu-id="10cf2-171">For example, you might have built and tested your application with the latest version of an assembly, but partial binding might load a much earlier version that lacks features your application uses.</span></span>  
  
- <span data-ttu-id="10cf2-172">Instalace nových aplikací může přerušit stávající aplikace.</span><span class="sxs-lookup"><span data-stu-id="10cf2-172">Installing new applications can break existing applications.</span></span> <span data-ttu-id="10cf2-173">Aplikace, která používá <xref:System.Reflection.Assembly.LoadWithPartialName%2A> metodu, může být poškozena instalací novější nekompatibilní verze sdíleného sestavení.</span><span class="sxs-lookup"><span data-stu-id="10cf2-173">An application that uses the <xref:System.Reflection.Assembly.LoadWithPartialName%2A> method can be broken by installing a newer, incompatible version of a shared assembly.</span></span>  
  
- <span data-ttu-id="10cf2-174">Může dojít k neočekávanému načtení závislostí.</span><span class="sxs-lookup"><span data-stu-id="10cf2-174">Unexpected dependency loading can occur.</span></span> <span data-ttu-id="10cf2-175">Načtete dvě sestavení, která sdílejí závislost, a jejich načítání s částečnou vazbou může mít za následek jedno sestavení pomocí komponenty, kterou nebyl sestaven nebo testován pomocí.</span><span class="sxs-lookup"><span data-stu-id="10cf2-175">It you load two assemblies that share a dependency, loading them with partial binding might result in one assembly using a component that it was not built or tested with.</span></span>  
  
 <span data-ttu-id="10cf2-176">Z důvodu problémů, které může způsobit, byla <xref:System.Reflection.Assembly.LoadWithPartialName%2A> Metoda označena jako zastaralá.</span><span class="sxs-lookup"><span data-stu-id="10cf2-176">Because of the problems it can cause, the <xref:System.Reflection.Assembly.LoadWithPartialName%2A> method has been marked obsolete.</span></span> <span data-ttu-id="10cf2-177">Doporučujeme <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> místo toho použít metodu a zadat úplné zobrazované názvy sestavení.</span><span class="sxs-lookup"><span data-stu-id="10cf2-177">We recommend that you use the <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> method instead, and specify full assembly display names.</span></span> <span data-ttu-id="10cf2-178">Přečtěte si informace [o výhodách a nevýhodách zátěžových](#load_contexts) kontextů a [zvažte přechod na výchozí kontext načtení](#switch_to_default).</span><span class="sxs-lookup"><span data-stu-id="10cf2-178">See [Understand the Advantages and Disadvantages of Load Contexts](#load_contexts) and [Consider Switching to the Default Load Context](#switch_to_default).</span></span>  
  
 <span data-ttu-id="10cf2-179">Pokud chcete použít <xref:System.Reflection.Assembly.LoadWithPartialName%2A> metodu, protože usnadňuje načítání sestavení, zvažte, že aplikace selže s chybovou zprávou, která identifikuje chybějící sestavení, bude pravděpodobně poskytovat lepší uživatelské prostředí, než automaticky používá neznámou verzi sestavení, což může způsobit nepředvídatelné chování a bezpečnostní otvory.</span><span class="sxs-lookup"><span data-stu-id="10cf2-179">If you want to use the <xref:System.Reflection.Assembly.LoadWithPartialName%2A> method because it makes assembly loading easy, consider that having your application fail with an error message that identifies the missing assembly is likely to provide a better user experience than automatically using an unknown version of the assembly, which might cause unpredictable behavior and security holes.</span></span>  
  
<a name="avoid_loading_into_multiple_contexts"></a>
## <a name="avoid-loading-an-assembly-into-multiple-contexts"></a><span data-ttu-id="10cf2-180">Vyhnout se načítání sestavení do více kontextů</span><span class="sxs-lookup"><span data-stu-id="10cf2-180">Avoid Loading an Assembly into Multiple Contexts</span></span>  
 <span data-ttu-id="10cf2-181">Načtení sestavení do více kontextů může způsobit problémy s identitou typu.</span><span class="sxs-lookup"><span data-stu-id="10cf2-181">Loading an assembly into multiple contexts can cause type identity problems.</span></span> <span data-ttu-id="10cf2-182">Pokud je stejný typ načten ze stejného sestavení do dvou různých kontextů, jedná se o to, aby byly načteny dva různé typy se stejným názvem.</span><span class="sxs-lookup"><span data-stu-id="10cf2-182">If the same type is loaded from the same assembly into two different contexts, it is as if two different types with the same name had been loaded.</span></span> <span data-ttu-id="10cf2-183"><xref:System.InvalidCastException>Výjimka je vyvolána, pokud se pokusíte přetypovat jeden typ na druhý, přičemž zpráva, kterou typ není `MyType` možné přetypovat na typ `MyType` .</span><span class="sxs-lookup"><span data-stu-id="10cf2-183">An <xref:System.InvalidCastException> is thrown if you try to cast one type to the other, with the confusing message that type `MyType` cannot be cast to type `MyType`.</span></span>  
  
 <span data-ttu-id="10cf2-184">Předpokládejme například, že `ICommunicate` rozhraní je deklarováno v sestavení s názvem `Utility` , které je odkazováno v programu a také jinými sestaveními, které program načítá.</span><span class="sxs-lookup"><span data-stu-id="10cf2-184">For example, suppose that the `ICommunicate` interface is declared in an assembly named `Utility`, which is referenced by your program and also by other assemblies that your program loads.</span></span> <span data-ttu-id="10cf2-185">Tato další sestavení obsahují typy, které implementují `ICommunicate` rozhraní, což umožňuje programu jejich použití.</span><span class="sxs-lookup"><span data-stu-id="10cf2-185">These other assemblies contain types that implement the `ICommunicate` interface, allowing your program to use them.</span></span>  
  
 <span data-ttu-id="10cf2-186">Nyní zvažte, co se stane, když se program spustí.</span><span class="sxs-lookup"><span data-stu-id="10cf2-186">Now consider what happens when your program is run.</span></span> <span data-ttu-id="10cf2-187">Sestavení, na která se odkazuje váš program, se načtou do výchozího kontextu zatížení.</span><span class="sxs-lookup"><span data-stu-id="10cf2-187">Assemblies that are referenced by your program are loaded into the default load context.</span></span> <span data-ttu-id="10cf2-188">Pokud načtete cílové sestavení pomocí jeho identity pomocí <xref:System.Reflection.Assembly.Load%2A> metody, bude ve výchozím kontextu načtení, a proto bude jeho závislosti.</span><span class="sxs-lookup"><span data-stu-id="10cf2-188">If you load a target assembly by its identity, using the <xref:System.Reflection.Assembly.Load%2A> method, it will be in the default load context, and so will its dependencies.</span></span> <span data-ttu-id="10cf2-189">Aplikace i cílové sestavení budou používat stejné `Utility` sestavení.</span><span class="sxs-lookup"><span data-stu-id="10cf2-189">Both your program and the target assembly will use the same `Utility` assembly.</span></span>  
  
 <span data-ttu-id="10cf2-190">Předpokládejme však, že nahrajete cílové sestavení pomocí cesty k souboru pomocí <xref:System.Reflection.Assembly.LoadFile%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="10cf2-190">However, suppose you load the target assembly by its file path, using the <xref:System.Reflection.Assembly.LoadFile%2A> method.</span></span> <span data-ttu-id="10cf2-191">Sestavení je načteno bez kontextu, takže jeho závislosti nejsou automaticky načteny.</span><span class="sxs-lookup"><span data-stu-id="10cf2-191">The assembly is loaded without any context, so its dependencies are not automatically loaded.</span></span> <span data-ttu-id="10cf2-192">Je možné, že máte obslužnou rutinu pro <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> událost k poskytnutí závislosti a může načíst sestavení bez `Utility` kontextu pomocí <xref:System.Reflection.Assembly.LoadFile%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="10cf2-192">You might have a handler for the <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> event to supply the dependency, and it might load the `Utility` assembly with no context by using the <xref:System.Reflection.Assembly.LoadFile%2A> method.</span></span> <span data-ttu-id="10cf2-193">Nyní když vytvoříte instanci typu, která je obsažena v cílovém sestavení a pokusíte se ji přiřadit proměnné typu `ICommunicate` , <xref:System.InvalidCastException> je vyvolána výjimka, protože modul runtime považuje `ICommunicate` rozhraní ve dvou kopiích `Utility` sestavení za rozdílné typy.</span><span class="sxs-lookup"><span data-stu-id="10cf2-193">Now when you create an instance of a type that is contained in the target assembly and try to assign it to a variable of type `ICommunicate`, an <xref:System.InvalidCastException> is thrown because the runtime considers the `ICommunicate` interfaces in the two copies of the `Utility` assembly to be different types.</span></span>  
  
 <span data-ttu-id="10cf2-194">Existuje mnoho dalších scénářů, ve kterých může být sestavení načteno do více kontextů.</span><span class="sxs-lookup"><span data-stu-id="10cf2-194">There are many other scenarios in which an assembly can be loaded into multiple contexts.</span></span> <span data-ttu-id="10cf2-195">Nejlepším řešením je vyhnout se konfliktům tím, že v cestě aplikace přemístěte cílové sestavení a použijete <xref:System.Reflection.Assembly.Load%2A> metodu s úplným zobrazovaným názvem.</span><span class="sxs-lookup"><span data-stu-id="10cf2-195">The best approach is to avoid conflicts by relocating the target assembly in your application path and using the <xref:System.Reflection.Assembly.Load%2A> method with the full display name.</span></span> <span data-ttu-id="10cf2-196">Sestavení je poté načteno do výchozího kontextu zatížení a obě sestavení používají stejné `Utility` sestavení.</span><span class="sxs-lookup"><span data-stu-id="10cf2-196">The assembly is then loaded into the default load context, and both assemblies use the same `Utility` assembly.</span></span>  
  
 <span data-ttu-id="10cf2-197">Pokud cílové sestavení musí zůstat mimo cestu aplikace, můžete použít <xref:System.Reflection.Assembly.LoadFrom%2A> metodu pro načtení do kontextu load-from.</span><span class="sxs-lookup"><span data-stu-id="10cf2-197">If the target assembly must remain outside your application path, you can use the <xref:System.Reflection.Assembly.LoadFrom%2A> method to load it into the load-from context.</span></span> <span data-ttu-id="10cf2-198">Pokud bylo cílové sestavení zkompilováno s odkazem na sestavení vaší aplikace `Utility` , bude použito `Utility` sestavení, které vaše aplikace načetla do výchozího kontextu načtení.</span><span class="sxs-lookup"><span data-stu-id="10cf2-198">If the target assembly was compiled with a reference to your application's `Utility` assembly, it will use the `Utility` assembly that your application has loaded into the default load context.</span></span> <span data-ttu-id="10cf2-199">Všimněte si, že problémy mohou nastat, pokud cílové sestavení má závislost na kopii `Utility` sestavení nacházející se mimo cestu k vaší aplikaci.</span><span class="sxs-lookup"><span data-stu-id="10cf2-199">Note that problems can occur if the target assembly has a dependency on a copy of the `Utility` assembly located outside your application path.</span></span> <span data-ttu-id="10cf2-200">Pokud je toto sestavení načteno do kontextu load-from předtím, než vaše aplikace načte `Utility` sestavení, zatížení vaší aplikace selže.</span><span class="sxs-lookup"><span data-stu-id="10cf2-200">If that assembly is loaded into the load-from context before your application loads the `Utility` assembly, your application's load will fail.</span></span>  
  
 <span data-ttu-id="10cf2-201">[Přechod na výchozí část kontextu zatížení](#switch_to_default) se zabývá alternativami k použití načtených cest souborů, jako jsou <xref:System.Reflection.Assembly.LoadFile%2A> a <xref:System.Reflection.Assembly.LoadFrom%2A> .</span><span class="sxs-lookup"><span data-stu-id="10cf2-201">The [Consider Switching to the Default Load Context](#switch_to_default) section discusses alternatives to using file path loads such as <xref:System.Reflection.Assembly.LoadFile%2A> and <xref:System.Reflection.Assembly.LoadFrom%2A>.</span></span>  
  
<a name="avoid_loading_multiple_versions"></a>
## <a name="avoid-loading-multiple-versions-of-an-assembly-into-the-same-context"></a><span data-ttu-id="10cf2-202">Vyhněte se načítání více verzí sestavení do stejného kontextu</span><span class="sxs-lookup"><span data-stu-id="10cf2-202">Avoid Loading Multiple Versions of an Assembly into the Same Context</span></span>  
 <span data-ttu-id="10cf2-203">Načítání více verzí sestavení do jednoho kontextu načtení může způsobit problémy s identitou typu.</span><span class="sxs-lookup"><span data-stu-id="10cf2-203">Loading multiple versions of an assembly into one load context can cause type identity problems.</span></span> <span data-ttu-id="10cf2-204">Pokud je stejný typ načten ze dvou verzí stejného sestavení, je to tak, že byly načteny dva různé typy se stejným názvem.</span><span class="sxs-lookup"><span data-stu-id="10cf2-204">If the same type is loaded from two versions of the same assembly, it is as if two different types with the same name had been loaded.</span></span> <span data-ttu-id="10cf2-205"><xref:System.InvalidCastException>Výjimka je vyvolána, pokud se pokusíte přetypovat jeden typ na druhý, přičemž zpráva, kterou typ není `MyType` možné přetypovat na typ `MyType` .</span><span class="sxs-lookup"><span data-stu-id="10cf2-205">An <xref:System.InvalidCastException> is thrown if you try to cast one type to the other, with the confusing message that type `MyType` cannot be cast to type `MyType`.</span></span>  
  
 <span data-ttu-id="10cf2-206">Například váš program může načítat jednu verzi `Utility` sestavení přímo a později může načíst jiné sestavení, které načte jinou verzi `Utility` sestavení.</span><span class="sxs-lookup"><span data-stu-id="10cf2-206">For example, your program might load one version of the `Utility` assembly directly, and later it might load another assembly that loads a different version of the `Utility` assembly.</span></span> <span data-ttu-id="10cf2-207">Nebo Chyba kódování může v aplikaci způsobit dvě různé cesty kódu pro načtení různých verzí sestavení.</span><span class="sxs-lookup"><span data-stu-id="10cf2-207">Or a coding error might cause two different code paths in your application to load different versions of an assembly.</span></span>  
  
 <span data-ttu-id="10cf2-208">Ve výchozím kontextu načtení k tomuto problému může dojít při použití <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> metody a zadání úplných zobrazovaných názvů sestavení, které obsahují různá čísla verzí.</span><span class="sxs-lookup"><span data-stu-id="10cf2-208">In the default load context, this problem can occur when you use the <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> method and specify complete assembly display names that include different version numbers.</span></span> <span data-ttu-id="10cf2-209">Pro sestavení, která jsou načtena bez kontextu, může být problém způsoben použitím <xref:System.Reflection.Assembly.LoadFile%2A?displayProperty=nameWithType> metody pro načtení stejného sestavení z různých cest.</span><span class="sxs-lookup"><span data-stu-id="10cf2-209">For assemblies that are loaded without context, the problem can be caused by using the <xref:System.Reflection.Assembly.LoadFile%2A?displayProperty=nameWithType> method to load the same assembly from different paths.</span></span> <span data-ttu-id="10cf2-210">Modul runtime považuje dvě sestavení, která jsou načtena z různých cest v různých sestaveních, a to i v případě, že jsou jejich identity stejné.</span><span class="sxs-lookup"><span data-stu-id="10cf2-210">The runtime considers two assemblies that are loaded from different paths to be different assemblies, even if their identities are the same.</span></span>  
  
 <span data-ttu-id="10cf2-211">Kromě potíží s identitou typu může více verzí sestavení způsobit, že <xref:System.MissingMethodException> Pokud typ, který je načten z jedné verze sestavení, je předán kódu, který tento typ z jiné verze očekává.</span><span class="sxs-lookup"><span data-stu-id="10cf2-211">In addition to type identity problems, multiple versions of an assembly can cause a <xref:System.MissingMethodException> if a type that is loaded from one version of the assembly is passed to code that expects that type from a different version.</span></span> <span data-ttu-id="10cf2-212">Kód může například očekávat metodu, která byla přidána do novější verze.</span><span class="sxs-lookup"><span data-stu-id="10cf2-212">For example, the code might expect a method that was added to the later version.</span></span>  
  
 <span data-ttu-id="10cf2-213">K dalším drobným chybám může dojít, pokud se chování typu změnilo mezi verzemi.</span><span class="sxs-lookup"><span data-stu-id="10cf2-213">More subtle errors can occur if the behavior of the type changed between versions.</span></span> <span data-ttu-id="10cf2-214">Například metoda může vyvolat neočekávanou výjimku nebo vracet neočekávanou hodnotu.</span><span class="sxs-lookup"><span data-stu-id="10cf2-214">For example, a method might throw an unexpected exception or return an unexpected value.</span></span>  
  
 <span data-ttu-id="10cf2-215">Pečlivě zkontrolujte kód a zajistěte, aby byla načtena pouze jedna verze sestavení.</span><span class="sxs-lookup"><span data-stu-id="10cf2-215">Carefully review your code to ensure that only one version of an assembly is loaded.</span></span> <span data-ttu-id="10cf2-216">Můžete použít <xref:System.AppDomain.GetAssemblies%2A?displayProperty=nameWithType> metodu k určení, která sestavení jsou načtena v daném okamžiku.</span><span class="sxs-lookup"><span data-stu-id="10cf2-216">You can use the <xref:System.AppDomain.GetAssemblies%2A?displayProperty=nameWithType> method to determine which assemblies are loaded at any given time.</span></span>  
  
<a name="switch_to_default"></a>
## <a name="consider-switching-to-the-default-load-context"></a><span data-ttu-id="10cf2-217">Zvažte přechod na výchozí kontext načtení.</span><span class="sxs-lookup"><span data-stu-id="10cf2-217">Consider Switching to the Default Load Context</span></span>  
 <span data-ttu-id="10cf2-218">Prověřte načítání sestavení aplikace a vzory nasazení.</span><span class="sxs-lookup"><span data-stu-id="10cf2-218">Examine your application's assembly loading and deployment patterns.</span></span> <span data-ttu-id="10cf2-219">Můžete eliminovat sestavení, která jsou načtena z bajtových polí?</span><span class="sxs-lookup"><span data-stu-id="10cf2-219">Can you eliminate assemblies that are loaded from byte arrays?</span></span> <span data-ttu-id="10cf2-220">Můžete přesunout sestavení do cesty pro zjišťování?</span><span class="sxs-lookup"><span data-stu-id="10cf2-220">Can you move assemblies into the probing path?</span></span> <span data-ttu-id="10cf2-221">Pokud jsou sestavení umístěna v globální mezipaměti sestavení (GAC) nebo v cestě ke zjišťování domény aplikace (to znamená, že <xref:System.AppDomainSetup.ApplicationBase%2A> a <xref:System.AppDomainSetup.PrivateBinPath%2A> ), můžete sestavení načíst pomocí jeho identity.</span><span class="sxs-lookup"><span data-stu-id="10cf2-221">If assemblies are located in the global assembly cache or in the application domain's probing path (that is, its <xref:System.AppDomainSetup.ApplicationBase%2A> and <xref:System.AppDomainSetup.PrivateBinPath%2A>), you can load the assembly by its identity.</span></span>  
  
 <span data-ttu-id="10cf2-222">Pokud není možné umístit všechna vaše sestavení do cesty pro zjišťování, zvažte alternativy, jako je například použití modelu doplňku .NET Framework, umístění sestavení do globální mezipaměti sestavení (GAC) nebo vytváření domén aplikace.</span><span class="sxs-lookup"><span data-stu-id="10cf2-222">If it is not possible to put all your assemblies in the probing path, consider alternatives such as using the .NET Framework add-in model, placing assemblies into the global assembly cache, or creating application domains.</span></span>  
  
### <a name="consider-using-the-net-framework-add-in-model"></a><span data-ttu-id="10cf2-223">Zvažte použití .NET Frameworkho modelu doplňku</span><span class="sxs-lookup"><span data-stu-id="10cf2-223">Consider Using the .NET Framework Add-In Model</span></span>  
 <span data-ttu-id="10cf2-224">Pokud používáte kontext načtení z k implementaci doplňků, které obvykle nejsou nainstalovány v základu aplikace, použijte Model doplňku .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="10cf2-224">If you are using the load-from context to implement add-ins, which typically are not installed in the application base, use the .NET Framework add-in model.</span></span> <span data-ttu-id="10cf2-225">Tento model poskytuje izolaci na úrovni domény aplikace nebo procesu bez nutnosti spravovat domény aplikace sami.</span><span class="sxs-lookup"><span data-stu-id="10cf2-225">This model provides isolation at the application domain or process level, without requiring you to manage application domains yourself.</span></span> <span data-ttu-id="10cf2-226">Informace o modelu doplňku naleznete v tématu [Doplňky a rozšiřitelnost](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb384200(v%3dvs.100)).</span><span class="sxs-lookup"><span data-stu-id="10cf2-226">For information about the add-in model, see [Add-ins and Extensibility](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb384200(v%3dvs.100)).</span></span>  
  
### <a name="consider-using-the-global-assembly-cache"></a><span data-ttu-id="10cf2-227">Zvažte použití globální mezipaměti sestavení (GAC)</span><span class="sxs-lookup"><span data-stu-id="10cf2-227">Consider Using the Global Assembly Cache</span></span>  
 <span data-ttu-id="10cf2-228">Umístěte sestavení do globální mezipaměti sestavení (GAC), abyste získali výhodu sdílené cesty sestavení, která je mimo základ aplikace, aniž by došlo ke ztrátě výhod výchozího kontextu zatížení nebo k nevýhodám ostatních kontextů.</span><span class="sxs-lookup"><span data-stu-id="10cf2-228">Place assemblies in the global assembly cache to get the benefit of a shared assembly path that is outside the application base, without losing the advantages of the default load context or taking on the disadvantages of the other contexts.</span></span>  
  
### <a name="consider-using-application-domains"></a><span data-ttu-id="10cf2-229">Zvažte použití aplikačních domén.</span><span class="sxs-lookup"><span data-stu-id="10cf2-229">Consider Using Application Domains</span></span>  
 <span data-ttu-id="10cf2-230">Pokud určíte, že některá z vašich sestavení nelze nasadit v cestě ke zjišťování aplikace, zvažte vytvoření nové aplikační domény pro tato sestavení.</span><span class="sxs-lookup"><span data-stu-id="10cf2-230">If you determine that some of your assemblies cannot be deployed in the application's probing path, consider creating a new application domain for those assemblies.</span></span> <span data-ttu-id="10cf2-231">Použijte <xref:System.AppDomainSetup> k vytvoření nové domény aplikace a <xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType> vlastnost použijte k určení cesty obsahující sestavení, která chcete načíst.</span><span class="sxs-lookup"><span data-stu-id="10cf2-231">Use an <xref:System.AppDomainSetup> to create the new application domain, and use the <xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType> property to specify the path that contains the assemblies you want to load.</span></span> <span data-ttu-id="10cf2-232">Pokud máte k dispozici více adresářů, můžete nastavit <xref:System.AppDomainSetup.ApplicationBase%2A> kořenový adresář a použít <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType> vlastnost k identifikaci podadresářů k testování.</span><span class="sxs-lookup"><span data-stu-id="10cf2-232">If you have multiple directories to probe, you can set the <xref:System.AppDomainSetup.ApplicationBase%2A> to a root directory and use the <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType> property to identify the subdirectories to probe.</span></span> <span data-ttu-id="10cf2-233">Alternativně můžete vytvořit více domén aplikace a nastavit <xref:System.AppDomainSetup.ApplicationBase%2A> každou doménu aplikace na odpovídající cestu pro její sestavení.</span><span class="sxs-lookup"><span data-stu-id="10cf2-233">Alternatively, you can create multiple application domains and set the <xref:System.AppDomainSetup.ApplicationBase%2A> of each application domain to the appropriate path for its assemblies.</span></span>  
  
 <span data-ttu-id="10cf2-234">Všimněte si, že <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> k načtení těchto sestavení lze použít metodu.</span><span class="sxs-lookup"><span data-stu-id="10cf2-234">Note that you can use the <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> method to load these assemblies.</span></span> <span data-ttu-id="10cf2-235">Vzhledem k tomu, že jsou nyní v cestě zjišťování, budou načteny do výchozího kontextu zatížení namísto kontextu load-from.</span><span class="sxs-lookup"><span data-stu-id="10cf2-235">Because they are now in the probing path, they will be loaded into the default load context instead of the load-from context.</span></span> <span data-ttu-id="10cf2-236">Nicméně doporučujeme, abyste přešli na <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> metodu a poskytovali úplné zobrazované názvy sestavení, aby se zajistilo, že se vždy použijí správné verze.</span><span class="sxs-lookup"><span data-stu-id="10cf2-236">However, we recommend that you switch to the <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> method and supply full assembly display names to ensure that correct versions are always used.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="10cf2-237">Viz také:</span><span class="sxs-lookup"><span data-stu-id="10cf2-237">See also</span></span>

- <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>
- <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType>
- <xref:System.Reflection.Assembly.LoadFile%2A?displayProperty=nameWithType>
- <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType>
