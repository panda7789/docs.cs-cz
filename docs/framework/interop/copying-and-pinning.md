---
title: Kopírování a přichycování
description: Přečtěte si, jak může zařazovací modul Interop kopírovat nebo připnout data, která jsou zařazování. Kopírování dat umístí kopii dat z jednoho umístění v paměti do jiného umístění.
ms.date: 03/30/2017
helpviewer_keywords:
- pinning, interop marshaling
- copying, interop marshaling
- interop marshaling, copying
- interop marshaling, pinning
ms.assetid: 0059f576-e460-4e70-b257-668870e420b8
ms.openlocfilehash: b7931813cd5254375eda81515f388c85c78fa284
ms.sourcegitcommit: e02d17b2cf9c1258dadda4810a5e6072a0089aee
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 07/01/2020
ms.locfileid: "85618776"
---
# <a name="copying-and-pinning"></a><span data-ttu-id="70592-104">Kopírování a přichycování</span><span class="sxs-lookup"><span data-stu-id="70592-104">Copying and Pinning</span></span>

<span data-ttu-id="70592-105">Při zařazování dat může zařazovací modul spolupráce zkopírovat nebo připnout data, která jsou zařazování.</span><span class="sxs-lookup"><span data-stu-id="70592-105">When marshaling data, the interop marshaler can copy or pin the data being marshaled.</span></span> <span data-ttu-id="70592-106">Kopírování dat umístí kopii dat z jednoho umístění v paměti v jiném umístění v paměti.</span><span class="sxs-lookup"><span data-stu-id="70592-106">Copying the data places a copy of data from one memory location in another memory location.</span></span> <span data-ttu-id="70592-107">Následující ilustrace znázorňuje rozdíly mezi zkopírováním typu hodnoty a zkopírováním typu předaného odkazem ze spravovaného do nespravované paměti.</span><span class="sxs-lookup"><span data-stu-id="70592-107">The following illustration shows the differences between copying a value type and copying a type passed by reference from managed to unmanaged memory.</span></span>

![Diagram, který ukazuje, jak se zkopírují typy hodnot a odkazů](./media/copying-and-pinning/interop-marshal-copy.gif)

<span data-ttu-id="70592-109">Argumenty metody předané hodnotou jsou zařazeny do nespravovaného kódu jako hodnoty v zásobníku.</span><span class="sxs-lookup"><span data-stu-id="70592-109">Method arguments passed by value are marshaled to unmanaged code as values on the stack.</span></span> <span data-ttu-id="70592-110">Proces kopírování je přímý.</span><span class="sxs-lookup"><span data-stu-id="70592-110">The copying process is direct.</span></span> <span data-ttu-id="70592-111">Argumenty předané odkazem jsou předány jako ukazatelé na zásobníku.</span><span class="sxs-lookup"><span data-stu-id="70592-111">Arguments passed by reference are passed as pointers on the stack.</span></span> <span data-ttu-id="70592-112">Odkazové typy jsou také předávány hodnotou a odkazem.</span><span class="sxs-lookup"><span data-stu-id="70592-112">Reference types are also passed by value and by reference.</span></span> <span data-ttu-id="70592-113">Jak ukazuje následující obrázek, typy odkazů předané hodnotou jsou buď zkopírovány nebo připnuté:</span><span class="sxs-lookup"><span data-stu-id="70592-113">As the following illustration shows, reference types passed by value are either copied or pinned:</span></span>

![Diagram znázorňující typy odkazů předané hodnotou a odkazem.](./media/copying-and-pinning/interop-marshal-reference-pin.gif)

<span data-ttu-id="70592-115">Připnutí dočasně uzamkne data v jejich aktuálním umístění v paměti, takže tím brání jejich přemístění systémem uvolňování paměti společného jazykového modulu runtime.</span><span class="sxs-lookup"><span data-stu-id="70592-115">Pinning temporarily locks the data in its current memory location, thus keeping it from being relocated by the common language runtime's garbage collector.</span></span> <span data-ttu-id="70592-116">Data zařazovacího modulu připnete k omezení režijních nákladů na kopírování a zvýšení výkonu.</span><span class="sxs-lookup"><span data-stu-id="70592-116">The marshaler pins data to reduce the overhead of copying and enhance performance.</span></span> <span data-ttu-id="70592-117">Typ dat určuje, zda je zkopírován nebo připnuté během procesu zařazování.</span><span class="sxs-lookup"><span data-stu-id="70592-117">The type of the data determines whether it is copied or pinned during the marshaling process.</span></span>  <span data-ttu-id="70592-118">Připnutí se provádí automaticky během zařazování pro objekty, jako je <xref:System.String> , můžete ale také ručně připnout paměť pomocí <xref:System.Runtime.InteropServices.GCHandle> třídy.</span><span class="sxs-lookup"><span data-stu-id="70592-118">Pinning is automatically performed during marshaling for objects such as <xref:System.String>, however you can also manually pin memory using the <xref:System.Runtime.InteropServices.GCHandle> class.</span></span>

## <a name="formatted-blittable-classes"></a><span data-ttu-id="70592-119">Formátované přenositelné třídy</span><span class="sxs-lookup"><span data-stu-id="70592-119">Formatted Blittable Classes</span></span>

<span data-ttu-id="70592-120">Naformátované [přenositelné třídy mají](blittable-and-non-blittable-types.md) v spravované i nespravované paměti pevné rozložení (naformátované) a běžné reprezentace dat.</span><span class="sxs-lookup"><span data-stu-id="70592-120">Formatted [blittable](blittable-and-non-blittable-types.md) classes have fixed layout (formatted) and common data representation in both managed and unmanaged memory.</span></span> <span data-ttu-id="70592-121">Pokud tyto typy vyžadují zařazování, ukazatel na objekt v haldě je předán volanému přímo.</span><span class="sxs-lookup"><span data-stu-id="70592-121">When these types require marshaling, a pointer to the object in the heap is passed to the callee directly.</span></span> <span data-ttu-id="70592-122">Volaný může změnit obsah umístění v paměti, na které odkazuje ukazatel.</span><span class="sxs-lookup"><span data-stu-id="70592-122">The callee can change the contents of the memory location being referenced by the pointer.</span></span>

> [!NOTE]
> <span data-ttu-id="70592-123">Volaný může změnit obsah paměti, pokud je parametr označený jako out nebo out. Naproti tomu by volaný neměl měnit obsah, pokud je parametr nastaven na zařazování jako v, což je výchozí hodnota pro formátované přenositelné typy.</span><span class="sxs-lookup"><span data-stu-id="70592-123">The callee can change the memory contents if the parameter is marked Out or In/Out. In contrast, the callee should avoid changing the contents when the parameter is set to marshal as In, which is the default for formatted blittable types.</span></span> <span data-ttu-id="70592-124">Změna v objektu generuje problémy, pokud je stejná třída exportována do knihovny typů a použita k provedení volání křížového typu.</span><span class="sxs-lookup"><span data-stu-id="70592-124">Modifying an In object generates problems when the same class is exported to a type library and used to make cross-apartment calls.</span></span>

## <a name="formatted-non-blittable-classes"></a><span data-ttu-id="70592-125">Naformátované třídy, které nejsou přenositelné</span><span class="sxs-lookup"><span data-stu-id="70592-125">Formatted Non-Blittable Classes</span></span>

<span data-ttu-id="70592-126">Formátované nepřenositelné třídy mají pevně dané rozložení ( [naformátované](blittable-and-non-blittable-types.md) ), ale reprezentace dat se liší ve spravované a nespravované paměti.</span><span class="sxs-lookup"><span data-stu-id="70592-126">Formatted [non-blittable](blittable-and-non-blittable-types.md) classes have fixed layout (formatted) but the data representation is different in managed and unmanaged memory.</span></span> <span data-ttu-id="70592-127">Data mohou vyžadovat transformaci za následujících podmínek:</span><span class="sxs-lookup"><span data-stu-id="70592-127">The data can require transformation under the following conditions:</span></span>

- <span data-ttu-id="70592-128">Pokud je třída, která není přenositelná, zařazena podle hodnoty, Volaný obdrží ukazatel na kopii struktury dat.</span><span class="sxs-lookup"><span data-stu-id="70592-128">If a non-blittable class is marshaled by value, the callee receives a pointer to a copy of the data structure.</span></span>

- <span data-ttu-id="70592-129">Pokud je nepřenosná třída zařazená odkazem, Volaný obdrží ukazatel na ukazatel na kopii struktury dat.</span><span class="sxs-lookup"><span data-stu-id="70592-129">If a non-blittable class is marshaled by reference, the callee receives a pointer to a pointer to a copy of the data structure.</span></span>

- <span data-ttu-id="70592-130">Pokud <xref:System.Runtime.InteropServices.InAttribute> je atribut nastaven, bude tato kopie vždy inicializována se stavem instance, zařazování podle potřeby.</span><span class="sxs-lookup"><span data-stu-id="70592-130">If the <xref:System.Runtime.InteropServices.InAttribute> attribute is set, this copy is always initialized with the instance's state, marshaling as necessary.</span></span>

- <span data-ttu-id="70592-131">Pokud <xref:System.Runtime.InteropServices.OutAttribute> je atribut nastaven, stav je vždy zkopírován zpět do instance při návratu, zařazování podle potřeby.</span><span class="sxs-lookup"><span data-stu-id="70592-131">If the <xref:System.Runtime.InteropServices.OutAttribute> attribute is set, the state is always copied back to the instance on return, marshaling as necessary.</span></span>

- <span data-ttu-id="70592-132">Pokud jsou nastaveny atributy **InAttribute** i **subattribute** , jsou požadovány obě kopie.</span><span class="sxs-lookup"><span data-stu-id="70592-132">If both **InAttribute** and **OutAttribute** are set, both copies are required.</span></span> <span data-ttu-id="70592-133">Pokud je atribut vynechán, zařazovací modul může být optimalizován vyřazením buď zkopírování.</span><span class="sxs-lookup"><span data-stu-id="70592-133">If either attribute is omitted, the marshaler can optimize by eliminating either copy.</span></span>

## <a name="reference-types"></a><span data-ttu-id="70592-134">Typy odkazů</span><span class="sxs-lookup"><span data-stu-id="70592-134">Reference Types</span></span>

<span data-ttu-id="70592-135">Odkazové typy mohou být předány hodnotou nebo odkazem.</span><span class="sxs-lookup"><span data-stu-id="70592-135">Reference types can be passed by value or by reference.</span></span> <span data-ttu-id="70592-136">Když jsou předávány hodnotou, ukazatel na typ je předán do zásobníku.</span><span class="sxs-lookup"><span data-stu-id="70592-136">When they are passed by value, a pointer to the type is passed on the stack.</span></span> <span data-ttu-id="70592-137">Při předání odkazem je ukazatel na ukazatel na typ předán do zásobníku.</span><span class="sxs-lookup"><span data-stu-id="70592-137">When passed by reference, a pointer to a pointer to the type is passed on the stack.</span></span>

<span data-ttu-id="70592-138">Typy odkazů mají následující podmíněné chování:</span><span class="sxs-lookup"><span data-stu-id="70592-138">Reference types have the following conditional behavior:</span></span>

- <span data-ttu-id="70592-139">Pokud je odkazový typ předán podle hodnoty a má členy nepřenositelného typu, jsou typy převedeny dvakrát:</span><span class="sxs-lookup"><span data-stu-id="70592-139">If a reference type is passed by value and it has members of non-blittable types, the types are converted twice:</span></span>

  - <span data-ttu-id="70592-140">Při předání argumentu nespravované straně.</span><span class="sxs-lookup"><span data-stu-id="70592-140">When an argument is passed to the unmanaged side.</span></span>

  - <span data-ttu-id="70592-141">Při návratu z volání.</span><span class="sxs-lookup"><span data-stu-id="70592-141">On return from the call.</span></span>

  <span data-ttu-id="70592-142">Aby nedocházelo k zbytečnému kopírování a převodu, jsou tyto typy zařazeny jako v parametrech.</span><span class="sxs-lookup"><span data-stu-id="70592-142">To avoid unnecessarily copying and conversion, these types are marshaled as In parameters.</span></span> <span data-ttu-id="70592-143">Chcete-li zobrazit změny provedené volaným, je nutné explicitně použít atributy **InAttribute** a Attribute **atributu** na argument volajícího.</span><span class="sxs-lookup"><span data-stu-id="70592-143">You must explicitly apply the **InAttribute** and **OutAttribute** attributes to an argument for the caller to see changes made by the callee.</span></span>

- <span data-ttu-id="70592-144">Pokud je odkazový typ předán podle hodnoty a má pouze členy typů, lze jej připnout během zařazování a jakékoli změny provedené u členů typu volanými jsou viditelné volajícím.</span><span class="sxs-lookup"><span data-stu-id="70592-144">If a reference type is passed by value and it has only members of blittable types, it can be pinned during marshaling and any changes made to the members of the type by the callee are seen by the caller.</span></span> <span data-ttu-id="70592-145">Pokud chcete toto chování, použijte **atribut InAttribute** a **InAttribute** .</span><span class="sxs-lookup"><span data-stu-id="70592-145">Apply **InAttribute** and **OutAttribute** explicitly if you want this behavior.</span></span> <span data-ttu-id="70592-146">Bez těchto směrových atributů nezařazovací modul Interop neexportuje směrující informace do knihovny typů (exportuje se jako v, což je výchozí nastavení), což může způsobit problémy s zařazováním do více platforem modelu COM.</span><span class="sxs-lookup"><span data-stu-id="70592-146">Without these directional attributes, the interop marshaler does not export directional information to the type library (it exports as In, which is the default) and this can cause problems with COM cross-apartment marshaling.</span></span>

- <span data-ttu-id="70592-147">Pokud typ odkazu přechází odkazem, bude ve výchozím nastavení zařazen jako ve výchozím stavu.</span><span class="sxs-lookup"><span data-stu-id="70592-147">If a reference type is passed by reference, it will be marshaled as In/Out by default.</span></span>

## <a name="systemstring-and-systemtextstringbuilder"></a><span data-ttu-id="70592-148">System. String a System. text. StringBuilder</span><span class="sxs-lookup"><span data-stu-id="70592-148">System.String and System.Text.StringBuilder</span></span>

<span data-ttu-id="70592-149">Když jsou data zařazena do nespravovaného kódu pomocí hodnoty nebo odkazem, zařazovací objekt obvykle kopíruje data do sekundární vyrovnávací paměti (případně převádějí znakové sady během kopírování) a předá odkaz na vyrovnávací paměť volanému.</span><span class="sxs-lookup"><span data-stu-id="70592-149">When data is marshaled to unmanaged code by value or by reference, the marshaler typically copies the data to a secondary buffer (possibly converting character sets during the copy) and passes a reference to the buffer to the callee.</span></span> <span data-ttu-id="70592-150">Pokud odkaz není typu **BSTR** přidělený pomocí **případě**, je odkaz vždy přidělen pomocí **CoTaskMemAlloc**.</span><span class="sxs-lookup"><span data-stu-id="70592-150">Unless the reference is a **BSTR** allocated with **SysAllocString**, the reference is always allocated with **CoTaskMemAlloc**.</span></span>

<span data-ttu-id="70592-151">Jako optimalizace, pokud je typ řetězce zařazen podle hodnoty (například řetězce znaků Unicode), zařazovací modul před kopírováním do nové vyrovnávací paměti předává volaný přímý ukazatel na spravované řetězce v interní vyrovnávací paměti Unicode.</span><span class="sxs-lookup"><span data-stu-id="70592-151">As an optimization when either string type is marshaled by value (such as a Unicode character string), the marshaler passes the callee a direct pointer to managed strings in the internal Unicode buffer instead of copying it to a new buffer.</span></span>

> [!CAUTION]
> <span data-ttu-id="70592-152">Když je řetězec předán podle hodnoty, volaný nesmí nikdy změnit odkaz předaný zařazovacím objektem.</span><span class="sxs-lookup"><span data-stu-id="70592-152">When a string is passed by value, the callee must never alter the reference passed by the marshaler.</span></span> <span data-ttu-id="70592-153">V takovém případě může být poškozena spravovaná halda.</span><span class="sxs-lookup"><span data-stu-id="70592-153">Doing so can corrupt the managed heap.</span></span>

<span data-ttu-id="70592-154">Pokud <xref:System.String?displayProperty=nameWithType> je předána odkazem, zařazovací služba zkopíruje obsah řetězce do sekundární vyrovnávací paměti před provedením volání.</span><span class="sxs-lookup"><span data-stu-id="70592-154">When a <xref:System.String?displayProperty=nameWithType> is passed by reference, the marshaler copies the contents the string to a secondary buffer before making the call.</span></span> <span data-ttu-id="70592-155">Pak zkopíruje obsah vyrovnávací paměti do nového řetězce při návratu z volání.</span><span class="sxs-lookup"><span data-stu-id="70592-155">It then copies the contents of the buffer into a new string on return from the call.</span></span> <span data-ttu-id="70592-156">Tato technika zajišťuje, že neměnné spravované řetězce zůstávají beze změny.</span><span class="sxs-lookup"><span data-stu-id="70592-156">This technique ensures that the immutable managed string remains unaltered.</span></span>

<span data-ttu-id="70592-157">Když <xref:System.Text.StringBuilder?displayProperty=nameWithType> je předána hodnotou, zařazovací modul předává odkaz na vnitřní vyrovnávací paměť **StringBuilder** přímo volajícímu.</span><span class="sxs-lookup"><span data-stu-id="70592-157">When a <xref:System.Text.StringBuilder?displayProperty=nameWithType> is passed by value, the marshaler passes a reference to the internal buffer of the **StringBuilder** directly to the caller.</span></span> <span data-ttu-id="70592-158">Volající a volaný musí souhlasit s velikostí vyrovnávací paměti.</span><span class="sxs-lookup"><span data-stu-id="70592-158">The caller and callee must agree on the size of the buffer.</span></span> <span data-ttu-id="70592-159">Volající je zodpovědný za vytvoření **StringBuilder** s adekvátní délkou.</span><span class="sxs-lookup"><span data-stu-id="70592-159">The caller is responsible for creating a **StringBuilder** of adequate length.</span></span> <span data-ttu-id="70592-160">Volaný musí podniknout nezbytná opatření, aby se zajistilo, že vyrovnávací paměť nebude přetečení.</span><span class="sxs-lookup"><span data-stu-id="70592-160">The callee must take the necessary precautions to ensure that the buffer is not overrun.</span></span> <span data-ttu-id="70592-161">**StringBuilder** je výjimka pro pravidlo, které odkazuje na typy předané hodnotou, ve výchozím nastavení předány jako parametry v parametrech.</span><span class="sxs-lookup"><span data-stu-id="70592-161">**StringBuilder** is an exception to the rule that reference types passed by value are passed as In parameters by default.</span></span> <span data-ttu-id="70592-162">Vždycky se předává jako vstupně-výstupní.</span><span class="sxs-lookup"><span data-stu-id="70592-162">It is always passed as In/Out.</span></span>

## <a name="see-also"></a><span data-ttu-id="70592-163">Viz také:</span><span class="sxs-lookup"><span data-stu-id="70592-163">See also</span></span>

- [<span data-ttu-id="70592-164">Výchozí chování zařazování</span><span class="sxs-lookup"><span data-stu-id="70592-164">Default Marshaling Behavior</span></span>](default-marshaling-behavior.md)
- <span data-ttu-id="70592-165">[Směrové atributy](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/77e6taeh(v=vs.100))</span><span class="sxs-lookup"><span data-stu-id="70592-165">[Directional Attributes](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/77e6taeh(v=vs.100))</span></span>
- [<span data-ttu-id="70592-166">Zařazování spolupráce</span><span class="sxs-lookup"><span data-stu-id="70592-166">Interop Marshaling</span></span>](interop-marshaling.md)
