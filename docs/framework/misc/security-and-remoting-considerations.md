---
title: Důležité informace o zabezpečení a vzdálené komunikaci
description: Přečtěte si o otázkách zabezpečení v souvislosti se vzdálenou komunikací, která umožňuje nastavit transparentní volání mezi doménami aplikace, procesy nebo počítači.
ms.date: 03/30/2017
helpviewer_keywords:
- code security, remoting
- remoting, security
- security [.NET Framework], remoting
- secure coding, remoting
ms.assetid: 125d2ab8-55a4-4e5f-af36-a7d401a37ab0
ms.openlocfilehash: 019773b19eaca2e4364fb79c40fdb923093d4e7e
ms.sourcegitcommit: 0fa2b7b658bf137e813a7f4d09589d64c148ebf5
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 07/14/2020
ms.locfileid: "86309362"
---
# <a name="security-and-remoting-considerations"></a><span data-ttu-id="1be2c-103">Důležité informace o zabezpečení a vzdálené komunikaci</span><span class="sxs-lookup"><span data-stu-id="1be2c-103">Security and Remoting Considerations</span></span>
<span data-ttu-id="1be2c-104">Vzdálená komunikace umožňuje nastavit transparentní volání mezi doménami aplikace, procesy nebo počítači.</span><span class="sxs-lookup"><span data-stu-id="1be2c-104">Remoting allows you to set up transparent calling between application domains, processes, or computers.</span></span> <span data-ttu-id="1be2c-105">Procházení zásobníku zabezpečení přístupu kódu ale nemůže mezi procesy nebo počítači překročit hranice (používá se mezi aplikačními doménami stejného procesu).</span><span class="sxs-lookup"><span data-stu-id="1be2c-105">However, the code access security stack walk cannot cross process or machine boundaries (it does apply between application domains of the same process).</span></span>  
  
 <span data-ttu-id="1be2c-106">Jakákoliv třída, která je vzdáleně (odvozená od <xref:System.MarshalByRefObject> třídy), musí převzít zodpovědnost za zabezpečení.</span><span class="sxs-lookup"><span data-stu-id="1be2c-106">Any class that is remotable (derived from a <xref:System.MarshalByRefObject> class) needs to take responsibility for security.</span></span> <span data-ttu-id="1be2c-107">Kód by měl být použit pouze v uzavřených prostředích, kde může být volající kód implicitně důvěryhodný, nebo by volání vzdálené komunikace měla být navržena tak, aby nepředmětoval chráněný kód na vnější položku, která by mohla být použita škodlivě.</span><span class="sxs-lookup"><span data-stu-id="1be2c-107">Either the code should be used only in closed environments where the calling code can be implicitly trusted, or remoting calls should be designed so that they do not subject protected code to outside entry that could be used maliciously.</span></span>  
  
 <span data-ttu-id="1be2c-108">Obecně by nikdy neměly vystavovat metody, vlastnosti nebo události, které jsou chráněny pomocí deklarativního [LinkDemand](link-demands.md) a <xref:System.Security.Permissions.SecurityAction.InheritanceDemand> kontroly zabezpečení.</span><span class="sxs-lookup"><span data-stu-id="1be2c-108">Generally, you should never expose methods, properties, or events that are protected by declarative [LinkDemand](link-demands.md) and <xref:System.Security.Permissions.SecurityAction.InheritanceDemand> security checks.</span></span> <span data-ttu-id="1be2c-109">U vzdálené komunikace nejsou tyto kontroly vynutily.</span><span class="sxs-lookup"><span data-stu-id="1be2c-109">With remoting, these checks are not enforced.</span></span> <span data-ttu-id="1be2c-110">Další kontroly zabezpečení, například <xref:System.Security.Permissions.SecurityAction.Demand> , [Assert](using-the-assert-method.md)a tak dále, pracují mezi doménami aplikace v rámci procesu, ale nefungují ve scénářích mezi procesy a mezi počítači.</span><span class="sxs-lookup"><span data-stu-id="1be2c-110">Other security checks, such as <xref:System.Security.Permissions.SecurityAction.Demand>, [Assert](using-the-assert-method.md), and so on, work between application domains within a process but do not work in cross-process or cross-machine scenarios.</span></span>  
  
## <a name="protected-objects"></a><span data-ttu-id="1be2c-111">Chráněné objekty</span><span class="sxs-lookup"><span data-stu-id="1be2c-111">Protected objects</span></span>  
 <span data-ttu-id="1be2c-112">Některé objekty samy uchovávají stav zabezpečení.</span><span class="sxs-lookup"><span data-stu-id="1be2c-112">Some objects hold security state in themselves.</span></span> <span data-ttu-id="1be2c-113">Tyto objekty by neměly být předány nedůvěryhodnému kódu, což by pak získalo autorizaci zabezpečení nad rámec svých vlastních oprávnění.</span><span class="sxs-lookup"><span data-stu-id="1be2c-113">These objects should not be passed to untrusted code, which would then acquire security authorization beyond its own permissions.</span></span>  
  
 <span data-ttu-id="1be2c-114">Jedním z příkladů je vytvoření <xref:System.IO.FileStream> objektu.</span><span class="sxs-lookup"><span data-stu-id="1be2c-114">One example is creating a <xref:System.IO.FileStream> object.</span></span> <span data-ttu-id="1be2c-115"><xref:System.Security.Permissions.FileIOPermission>Je vyžádané v době vytvoření a v případě úspěchu je vrácen objekt File.</span><span class="sxs-lookup"><span data-stu-id="1be2c-115">The <xref:System.Security.Permissions.FileIOPermission> is demanded at the time of creation and, if it succeeds, the file object is returned.</span></span> <span data-ttu-id="1be2c-116">Pokud je však tento odkaz na objekt předán do kódu bez oprávnění k souboru, bude objekt moci číst a zapisovat do tohoto konkrétního souboru.</span><span class="sxs-lookup"><span data-stu-id="1be2c-116">However, if this object reference is passed to code without file permissions, the object will be able to read and write to this particular file.</span></span>  
  
 <span data-ttu-id="1be2c-117">Nejjednodušší obrana takového objektu je požadovat stejné **FileIOPermission** jakéhokoli kódu, který se snaží získat odkaz na objekt prostřednictvím veřejného prvku rozhraní API.</span><span class="sxs-lookup"><span data-stu-id="1be2c-117">The simplest defense for such an object is to demand the same **FileIOPermission** of any code that seeks to get the object reference through a public API element.</span></span>  
  
## <a name="application-domain-crossing-issues"></a><span data-ttu-id="1be2c-118">Problémy při křížení domény aplikace</span><span class="sxs-lookup"><span data-stu-id="1be2c-118">Application domain crossing issues</span></span>  
 <span data-ttu-id="1be2c-119">Chcete-li izolovat kód ve spravovaných hostujících prostředích, je běžné generovat více domén podřízené aplikace s explicitními zásadami, které snižují úrovně oprávnění pro různá sestavení.</span><span class="sxs-lookup"><span data-stu-id="1be2c-119">To isolate code in managed hosting environments, it is common to generate multiple child application domains with explicit policy reducing the permission levels for various assemblies.</span></span> <span data-ttu-id="1be2c-120">Nicméně zásady pro tato sestavení zůstávají beze změny ve výchozí aplikační doméně.</span><span class="sxs-lookup"><span data-stu-id="1be2c-120">However, the policy for those assemblies remains unchanged in the default application domain.</span></span> <span data-ttu-id="1be2c-121">Pokud jedna z podřízených domén aplikace může vynutit, aby výchozí doména aplikace načetla sestavení, účinek izolace kódu je ztracen a typy v nuceně načteném sestavení budou moci spustit kód na vyšší úrovni důvěryhodnosti.</span><span class="sxs-lookup"><span data-stu-id="1be2c-121">If one of the child application domains can force the default application domain to load an assembly, the effect of code isolation is lost and types in the forcibly loaded assembly will be able to run code at a higher level of trust.</span></span>  
  
 <span data-ttu-id="1be2c-122">Doména aplikace může vynutit jinou aplikační doménu, aby načetla sestavení a kód, který je v něm obsažený, voláním proxy na objekt hostovaný v jiné doméně aplikace.</span><span class="sxs-lookup"><span data-stu-id="1be2c-122">An application domain can force another application domain to load an assembly and run code contained therein by calling a proxy to an object hosted in the other application domain.</span></span> <span data-ttu-id="1be2c-123">Aby bylo možné získat proxy server mezi aplikačními aplikacemi, musí doména aplikace, která je hostitelem objektu, distribuovat jednu prostřednictvím parametru volání metody nebo návratové hodnoty.</span><span class="sxs-lookup"><span data-stu-id="1be2c-123">To obtain a cross-application-domain proxy, the application domain hosting the object must distribute one through a method call parameter or return value.</span></span> <span data-ttu-id="1be2c-124">Nebo, pokud byla doména aplikace právě vytvořena, tvůrce má <xref:System.AppDomain> ve výchozím nastavení proxy objekt k objektu.</span><span class="sxs-lookup"><span data-stu-id="1be2c-124">Or, if the application domain was just created, the creator has a proxy to the <xref:System.AppDomain> object by default.</span></span> <span data-ttu-id="1be2c-125">Proto k tomu, aby nedošlo k narušení izolace kódu, by doména aplikace s vyšší úrovní důvěryhodnosti neměla distribuovat odkazy na objekty zařazování podle referencí (instance tříd odvozené z <xref:System.MarshalByRefObject> ) ve své doméně do domén aplikace s nižšími úrovněmi důvěryhodnosti.</span><span class="sxs-lookup"><span data-stu-id="1be2c-125">Thus, to avoid breaking code isolation, an application domain with a higher level of trust should not distribute references to marshaled-by-reference objects (instances of classes derived from <xref:System.MarshalByRefObject>) in its domain to application domains with lower levels of trust.</span></span>  
  
 <span data-ttu-id="1be2c-126">Výchozí aplikační doména obvykle vytváří podřízené domény aplikace s objektem ovládacího prvku v každém z nich.</span><span class="sxs-lookup"><span data-stu-id="1be2c-126">Usually, the default application domain creates the child application domains with a control object in each one.</span></span> <span data-ttu-id="1be2c-127">Řídicí objekt spravuje novou doménu aplikace a občas bere objednávky z výchozí domény aplikace, ale nemůže ve skutečnosti kontaktovat doménu přímo.</span><span class="sxs-lookup"><span data-stu-id="1be2c-127">The control object manages the new application domain and occasionally takes orders from the default application domain, but it cannot actually contact the domain directly.</span></span> <span data-ttu-id="1be2c-128">V některých případech výchozí doména aplikace volá svůj proxy do objektu Control.</span><span class="sxs-lookup"><span data-stu-id="1be2c-128">Occasionally, the default application domain calls its proxy to the control object.</span></span> <span data-ttu-id="1be2c-129">Nicméně mohou nastat případy, kdy je nutné, aby objekt ovládacího prvku volal zpět do výchozí domény aplikace.</span><span class="sxs-lookup"><span data-stu-id="1be2c-129">However, there might be cases in which it is necessary for the control object to call back to the default application domain.</span></span> <span data-ttu-id="1be2c-130">V těchto případech výchozí doména aplikace předá objekt zpětného volání zařazovacího odkazu do konstruktoru objektu ovládacího prvku.</span><span class="sxs-lookup"><span data-stu-id="1be2c-130">In these cases, the default application domain passes a marshal-by-reference callback object to the constructor of the control object.</span></span> <span data-ttu-id="1be2c-131">Je zodpovědností za objekt Control k ochraně tohoto proxy serveru.</span><span class="sxs-lookup"><span data-stu-id="1be2c-131">It is the responsibility of the control object to protect this proxy.</span></span> <span data-ttu-id="1be2c-132">Pokud řídicí objekt umístil proxy na veřejné statické pole veřejné třídy nebo jinak veřejně vystavený proxy serveru, bude otevřen nebezpečný mechanismus pro jiný kód pro volání zpět do výchozí domény aplikace.</span><span class="sxs-lookup"><span data-stu-id="1be2c-132">If the control object placed the proxy on a public static field of a public class or otherwise publicly exposed the proxy, a dangerous mechanism for other code to call back into the default application domain would be opened up.</span></span> <span data-ttu-id="1be2c-133">Z tohoto důvodu jsou objekty ovládacího prvku vždy implicitně důvěryhodné, aby zůstaly proxy privátní.</span><span class="sxs-lookup"><span data-stu-id="1be2c-133">For this reason, control objects are always implicitly trusted to keep the proxy private.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="1be2c-134">Viz také</span><span class="sxs-lookup"><span data-stu-id="1be2c-134">See also</span></span>

- [<span data-ttu-id="1be2c-135">Pokyny pro zabezpečené kódování</span><span class="sxs-lookup"><span data-stu-id="1be2c-135">Secure Coding Guidelines</span></span>](../../standard/security/secure-coding-guidelines.md)
