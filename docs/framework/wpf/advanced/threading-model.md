---
title: Model vláken
description: Přečtěte si o situacích, kdy budete možná potřebovat více vláken v aplikaci Windows Presentation Foundation. Jsou upřednostňována řešení s jedním vláknem.
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- text on buttons [WPF], updating
- message processing [WPF], nested
- blocking operations [WPF]
- Common Language Runtime (CLR), locking mechanism
- locking mechanism of Common Language Runtime (CLR)
- threading model [WPF]
- Word [WPF], spelling checking
- button text [WPF], updating
- spelling checking in Word [WPF]
- asynchronous behavior [WPF], exposing
- nested message processing [WPF]
- reentrancy [WPF]
ms.assetid: 02d8fd00-8d7c-4604-874c-58e40786770b
ms.openlocfilehash: 9b67b6ea2896e9e6fec57dee8d1013d54fab03fc
ms.sourcegitcommit: 87cfeb69226fef01acb17c56c86f978f4f4a13db
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 07/24/2020
ms.locfileid: "87166384"
---
# <a name="threading-model"></a><span data-ttu-id="06f56-104">Model vláken</span><span class="sxs-lookup"><span data-stu-id="06f56-104">Threading Model</span></span>
[!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]<span data-ttu-id="06f56-105">je navržena pro ukládání vývojářů z potíží s vlákny.</span><span class="sxs-lookup"><span data-stu-id="06f56-105">is designed to save developers from the difficulties of threading.</span></span> <span data-ttu-id="06f56-106">V důsledku toho většina [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] vývojářů nebude muset psát rozhraní, které používá více než jedno vlákno.</span><span class="sxs-lookup"><span data-stu-id="06f56-106">As a result, the majority of [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] developers won't have to write an interface that uses more than one thread.</span></span> <span data-ttu-id="06f56-107">Vzhledem k tomu, že programy s více vlákny jsou složité a obtížné je ladit, měli byste se jim vyhnout v případě existence řešení s jedním vláknem.</span><span class="sxs-lookup"><span data-stu-id="06f56-107">Because multithreaded programs are complex and difficult to debug, they should be avoided when single-threaded solutions exist.</span></span>

 <span data-ttu-id="06f56-108">Bez ohledu na to, jak to bylo navrženo, ale žádné [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] rozhraní nikdy nebude moci poskytnout řešení s jedním vláknem pro každý problém.</span><span class="sxs-lookup"><span data-stu-id="06f56-108">No matter how well architected, however, no [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] framework will ever be able to provide a single-threaded solution for every sort of problem.</span></span> [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]<span data-ttu-id="06f56-109">je blízko, ale stále existují situace, kdy více vláken vylepšuje [!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)] odezvu nebo výkon aplikace.</span><span class="sxs-lookup"><span data-stu-id="06f56-109">comes close, but there are still situations where multiple threads improve [!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)] responsiveness or application performance.</span></span> <span data-ttu-id="06f56-110">Po prozkoumání některých materiálů se v tomto dokumentu prozkoumá některé z těchto situací a pak se dokončí diskuzí o některých podrobnostech nižší úrovně.</span><span class="sxs-lookup"><span data-stu-id="06f56-110">After discussing some background material, this paper explores some of these situations and then concludes with a discussion of some lower-level details.</span></span>

> [!NOTE]
> <span data-ttu-id="06f56-111">Toto téma popisuje dělení na vlákna pomocí <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> metody pro asynchronní volání.</span><span class="sxs-lookup"><span data-stu-id="06f56-111">This topic discusses threading by using the <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> method for asynchronous calls.</span></span> <span data-ttu-id="06f56-112">Můžete také provést asynchronní volání voláním <xref:System.Windows.Threading.Dispatcher.InvokeAsync%2A> metody, která přijímá <xref:System.Action> nebo <xref:System.Func%601> jako parametr.</span><span class="sxs-lookup"><span data-stu-id="06f56-112">You can also make asynchronous calls by calling the <xref:System.Windows.Threading.Dispatcher.InvokeAsync%2A> method, which take an <xref:System.Action> or <xref:System.Func%601> as a parameter.</span></span>  <span data-ttu-id="06f56-113"><xref:System.Windows.Threading.Dispatcher.InvokeAsync%2A>Metoda vrátí <xref:System.Windows.Threading.DispatcherOperation> nebo <xref:System.Windows.Threading.DispatcherOperation%601> , která má <xref:System.Windows.Threading.DispatcherOperation.Task%2A> vlastnost.</span><span class="sxs-lookup"><span data-stu-id="06f56-113">The <xref:System.Windows.Threading.Dispatcher.InvokeAsync%2A> method returns a <xref:System.Windows.Threading.DispatcherOperation> or <xref:System.Windows.Threading.DispatcherOperation%601>, which has a <xref:System.Windows.Threading.DispatcherOperation.Task%2A> property.</span></span> <span data-ttu-id="06f56-114">Klíčové slovo lze použít `await` buď s <xref:System.Windows.Threading.DispatcherOperation> přidruženým, nebo <xref:System.Threading.Tasks.Task> .</span><span class="sxs-lookup"><span data-stu-id="06f56-114">You can use the `await` keyword with either the <xref:System.Windows.Threading.DispatcherOperation> or the associated <xref:System.Threading.Tasks.Task>.</span></span> <span data-ttu-id="06f56-115">Pokud potřebujete počkat synchronně pro <xref:System.Threading.Tasks.Task> , který je vrácený <xref:System.Windows.Threading.DispatcherOperation> nebo <xref:System.Windows.Threading.DispatcherOperation%601> , zavolejte <xref:System.Windows.Threading.TaskExtensions.DispatcherOperationWait%2A> metodu rozšíření.</span><span class="sxs-lookup"><span data-stu-id="06f56-115">If you need to wait synchronously for the <xref:System.Threading.Tasks.Task> that is returned by a <xref:System.Windows.Threading.DispatcherOperation> or <xref:System.Windows.Threading.DispatcherOperation%601>, call the <xref:System.Windows.Threading.TaskExtensions.DispatcherOperationWait%2A> extension method.</span></span>  <span data-ttu-id="06f56-116">Volání <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> způsobí zablokování.</span><span class="sxs-lookup"><span data-stu-id="06f56-116">Calling <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> will result in a deadlock.</span></span> <span data-ttu-id="06f56-117">Další informace o použití nástroje <xref:System.Threading.Tasks.Task> k provedení asynchronních operací naleznete v tématu Task paralelismus.</span><span class="sxs-lookup"><span data-stu-id="06f56-117">For more information about using a <xref:System.Threading.Tasks.Task> to perform asynchronous operations, see Task Parallelism.</span></span>  <span data-ttu-id="06f56-118"><xref:System.Windows.Threading.Dispatcher.Invoke%2A>Metoda má také přetížení, která přijímají <xref:System.Action> nebo <xref:System.Func%601> jako parametr.</span><span class="sxs-lookup"><span data-stu-id="06f56-118">The <xref:System.Windows.Threading.Dispatcher.Invoke%2A> method also has overloads that take an <xref:System.Action> or <xref:System.Func%601> as a parameter.</span></span>  <span data-ttu-id="06f56-119">Metodu lze použít <xref:System.Windows.Threading.Dispatcher.Invoke%2A> k provádění synchronních volání předáním delegáta <xref:System.Action> nebo <xref:System.Func%601> .</span><span class="sxs-lookup"><span data-stu-id="06f56-119">You can use the <xref:System.Windows.Threading.Dispatcher.Invoke%2A> method to make synchronous calls by passing in a delegate, <xref:System.Action> or <xref:System.Func%601>.</span></span>

<a name="threading_overview"></a>
## <a name="overview-and-the-dispatcher"></a><span data-ttu-id="06f56-120">Přehled a dispečer</span><span class="sxs-lookup"><span data-stu-id="06f56-120">Overview and the Dispatcher</span></span>
 <span data-ttu-id="06f56-121">Obvykle [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] aplikace začínají dvěma vlákny: jeden pro zpracování vykreslování a další pro správu [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] .</span><span class="sxs-lookup"><span data-stu-id="06f56-121">Typically, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications start with two threads: one for handling rendering and another for managing the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)].</span></span> <span data-ttu-id="06f56-122">Vykreslování vlákna efektivně běží na pozadí, zatímco [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] vlákno přijímá vstup, zpracovává události, vykreslí obrazovku a spouští kód aplikace.</span><span class="sxs-lookup"><span data-stu-id="06f56-122">The rendering thread effectively runs hidden in the background while the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread receives input, handles events, paints the screen, and runs application code.</span></span> <span data-ttu-id="06f56-123">Většina aplikací používá jedno [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] vlákno, i když v některých případech je nejvhodnější použít několik.</span><span class="sxs-lookup"><span data-stu-id="06f56-123">Most applications use a single [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread, although in some situations it is best to use several.</span></span> <span data-ttu-id="06f56-124">Budeme s tímto příkladem pojednávat později.</span><span class="sxs-lookup"><span data-stu-id="06f56-124">We’ll discuss this with an example later.</span></span>

 <span data-ttu-id="06f56-125">[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]Vlákno vyřadí pracovní položky do fronty v rámci objektu s názvem <xref:System.Windows.Threading.Dispatcher> .</span><span class="sxs-lookup"><span data-stu-id="06f56-125">The [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread queues work items inside an object called a <xref:System.Windows.Threading.Dispatcher>.</span></span> <span data-ttu-id="06f56-126"><xref:System.Windows.Threading.Dispatcher>Vybere pracovní položky na základě priority a každý z nich provede dokončení.</span><span class="sxs-lookup"><span data-stu-id="06f56-126">The <xref:System.Windows.Threading.Dispatcher> selects work items on a priority basis and runs each one to completion.</span></span>  <span data-ttu-id="06f56-127">Každé [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] vlákno musí mít alespoň jeden <xref:System.Windows.Threading.Dispatcher> a každý z nich <xref:System.Windows.Threading.Dispatcher> může spouštět pracovní položky v přesně jednom vlákně.</span><span class="sxs-lookup"><span data-stu-id="06f56-127">Every [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread must have at least one <xref:System.Windows.Threading.Dispatcher>, and each <xref:System.Windows.Threading.Dispatcher> can execute work items in exactly one thread.</span></span>

 <span data-ttu-id="06f56-128">Schopnost vytvářet reakce na uživatelsky přívětivé aplikace je maximalizovat <xref:System.Windows.Threading.Dispatcher> propustnost tím, že se pracovní položky podrží malými.</span><span class="sxs-lookup"><span data-stu-id="06f56-128">The trick to building responsive, user-friendly applications is to maximize the <xref:System.Windows.Threading.Dispatcher> throughput by keeping the work items small.</span></span> <span data-ttu-id="06f56-129">Tímto způsobem se položky nikdy nevrátí do fronty, která <xref:System.Windows.Threading.Dispatcher> čeká na zpracování.</span><span class="sxs-lookup"><span data-stu-id="06f56-129">This way items never get stale sitting in the <xref:System.Windows.Threading.Dispatcher> queue waiting for processing.</span></span> <span data-ttu-id="06f56-130">Jakékoli vnímané zpoždění mezi vstupem a odpovědí může frustrovat uživatele.</span><span class="sxs-lookup"><span data-stu-id="06f56-130">Any perceivable delay between input and response can frustrate a user.</span></span>

 <span data-ttu-id="06f56-131">Jak [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] aplikace by pak měly zpracovávat velké operace?</span><span class="sxs-lookup"><span data-stu-id="06f56-131">How then are [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications supposed to handle big operations?</span></span> <span data-ttu-id="06f56-132">Co když váš kód zahrnuje velký výpočet nebo potřebuje dotaz na databázi na některém vzdáleném serveru?</span><span class="sxs-lookup"><span data-stu-id="06f56-132">What if your code involves a large calculation or needs to query a database on some remote server?</span></span> <span data-ttu-id="06f56-133">Obvykle je odpověď zpracovávat velkou operaci v samostatném vlákně, ale vlákno je volné, [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] aby bylo možné položky ve <xref:System.Windows.Threading.Dispatcher> frontě.</span><span class="sxs-lookup"><span data-stu-id="06f56-133">Usually, the answer is to handle the big operation in a separate thread, leaving the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread free to tend to items in the <xref:System.Windows.Threading.Dispatcher> queue.</span></span> <span data-ttu-id="06f56-134">Po dokončení velké operace může hlásit svůj výsledek zpátky do [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] vlákna pro zobrazení.</span><span class="sxs-lookup"><span data-stu-id="06f56-134">When the big operation is complete, it can report its result back to the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread for display.</span></span>

 <span data-ttu-id="06f56-135">V historickém režimu umožňuje systému Windows [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] přístup k elementům pouze pomocí vlákna, které je vytvořilo.</span><span class="sxs-lookup"><span data-stu-id="06f56-135">Historically, Windows allows [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] elements to be accessed only by the thread that created them.</span></span> <span data-ttu-id="06f56-136">To znamená, že vlákno na pozadí za určitou dlouhodobě běžící úlohu nemůže po dokončení aktualizovat textové pole.</span><span class="sxs-lookup"><span data-stu-id="06f56-136">This means that a background thread in charge of some long-running task cannot update a text box when it is finished.</span></span> <span data-ttu-id="06f56-137">Systém Windows To zajistí, aby se zajistila integrita [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] komponent.</span><span class="sxs-lookup"><span data-stu-id="06f56-137">Windows does this to ensure the integrity of [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] components.</span></span> <span data-ttu-id="06f56-138">Seznam by mohl vypadat neobvyklý, pokud jeho obsah byl během Malování aktualizován vláknem na pozadí.</span><span class="sxs-lookup"><span data-stu-id="06f56-138">A list box could look strange if its contents were updated by a background thread during painting.</span></span>

 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]<span data-ttu-id="06f56-139">má vestavěný mechanismus vzájemného vyloučení, který tuto koordinaci vynutil.</span><span class="sxs-lookup"><span data-stu-id="06f56-139">has a built-in mutual exclusion mechanism that enforces this coordination.</span></span> <span data-ttu-id="06f56-140">Většina tříd [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] je odvozena z <xref:System.Windows.Threading.DispatcherObject> .</span><span class="sxs-lookup"><span data-stu-id="06f56-140">Most classes in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] derive from <xref:System.Windows.Threading.DispatcherObject>.</span></span> <span data-ttu-id="06f56-141">V konstrukci <xref:System.Windows.Threading.DispatcherObject> ukládá odkaz na <xref:System.Windows.Threading.Dispatcher> vazbu k aktuálně běžícímu vláknu.</span><span class="sxs-lookup"><span data-stu-id="06f56-141">At construction, a <xref:System.Windows.Threading.DispatcherObject> stores a reference to the <xref:System.Windows.Threading.Dispatcher> linked to the currently running thread.</span></span> <span data-ttu-id="06f56-142">V důsledku toho <xref:System.Windows.Threading.DispatcherObject> přidruží ke vláknu, který ho vytvořil.</span><span class="sxs-lookup"><span data-stu-id="06f56-142">In effect, the <xref:System.Windows.Threading.DispatcherObject> associates with the thread that creates it.</span></span> <span data-ttu-id="06f56-143">Během provádění programu <xref:System.Windows.Threading.DispatcherObject> může zavolat jeho veřejnou <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> metodu.</span><span class="sxs-lookup"><span data-stu-id="06f56-143">During program execution, a <xref:System.Windows.Threading.DispatcherObject> can call its public <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> method.</span></span> <span data-ttu-id="06f56-144"><xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A>prověřuje <xref:System.Windows.Threading.Dispatcher> přidružení k aktuálnímu vláknu a porovná ho s <xref:System.Windows.Threading.Dispatcher> odkazem uloženým během konstrukce.</span><span class="sxs-lookup"><span data-stu-id="06f56-144"><xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> examines the <xref:System.Windows.Threading.Dispatcher> associated with the current thread and compares it to the <xref:System.Windows.Threading.Dispatcher> reference stored during construction.</span></span> <span data-ttu-id="06f56-145">Pokud se neshodují, <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> vyvolá výjimku.</span><span class="sxs-lookup"><span data-stu-id="06f56-145">If they don’t match, <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> throws an exception.</span></span> <span data-ttu-id="06f56-146"><xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A>má být volána na začátku každé metody patřící do <xref:System.Windows.Threading.DispatcherObject> .</span><span class="sxs-lookup"><span data-stu-id="06f56-146"><xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> is intended to be called at the beginning of every method belonging to a <xref:System.Windows.Threading.DispatcherObject>.</span></span>

 <span data-ttu-id="06f56-147">Pokud může upravit pouze jedno vlákno [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] , jak vlákna na pozadí pracují s uživatelem?</span><span class="sxs-lookup"><span data-stu-id="06f56-147">If only one thread can modify the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)], how do background threads interact with the user?</span></span> <span data-ttu-id="06f56-148">Vlákno na pozadí může požádat [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] vlákno o provedení operace za jeho jménem.</span><span class="sxs-lookup"><span data-stu-id="06f56-148">A background thread can ask the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread to perform an operation on its behalf.</span></span> <span data-ttu-id="06f56-149">Provede to registrací pracovní položky s <xref:System.Windows.Threading.Dispatcher> [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] vláknem.</span><span class="sxs-lookup"><span data-stu-id="06f56-149">It does this by registering a work item with the <xref:System.Windows.Threading.Dispatcher> of the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="06f56-150"><xref:System.Windows.Threading.Dispatcher>Třída poskytuje dvě metody pro registraci pracovních položek: <xref:System.Windows.Threading.Dispatcher.Invoke%2A> a <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> .</span><span class="sxs-lookup"><span data-stu-id="06f56-150">The <xref:System.Windows.Threading.Dispatcher> class provides two methods for registering work items: <xref:System.Windows.Threading.Dispatcher.Invoke%2A> and <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.</span></span> <span data-ttu-id="06f56-151">Obě metody naplánují delegáta pro spuštění.</span><span class="sxs-lookup"><span data-stu-id="06f56-151">Both methods schedule a delegate for execution.</span></span> <span data-ttu-id="06f56-152"><xref:System.Windows.Threading.Dispatcher.Invoke%2A>je synchronní volání – to znamená, že se nevrátí, dokud [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] vlákno dokončí provádění delegáta.</span><span class="sxs-lookup"><span data-stu-id="06f56-152"><xref:System.Windows.Threading.Dispatcher.Invoke%2A> is a synchronous call – that is, it doesn’t return until the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread actually finishes executing the delegate.</span></span> <span data-ttu-id="06f56-153"><xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>je asynchronní a vrátí se okamžitě.</span><span class="sxs-lookup"><span data-stu-id="06f56-153"><xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> is asynchronous and returns immediately.</span></span>

 <span data-ttu-id="06f56-154"><xref:System.Windows.Threading.Dispatcher>Seřadí prvky ve své frontě podle priority.</span><span class="sxs-lookup"><span data-stu-id="06f56-154">The <xref:System.Windows.Threading.Dispatcher> orders the elements in its queue by priority.</span></span> <span data-ttu-id="06f56-155">Při přidávání elementu do fronty je možné zadat deset úrovní <xref:System.Windows.Threading.Dispatcher> .</span><span class="sxs-lookup"><span data-stu-id="06f56-155">There are ten levels that may be specified when adding an element to the <xref:System.Windows.Threading.Dispatcher> queue.</span></span> <span data-ttu-id="06f56-156">Tyto priority se udržují ve <xref:System.Windows.Threading.DispatcherPriority> výčtu.</span><span class="sxs-lookup"><span data-stu-id="06f56-156">These priorities are maintained in the <xref:System.Windows.Threading.DispatcherPriority> enumeration.</span></span> <span data-ttu-id="06f56-157">Podrobné informace o <xref:System.Windows.Threading.DispatcherPriority> úrovních najdete v dokumentaci k Windows SDK.</span><span class="sxs-lookup"><span data-stu-id="06f56-157">Detailed information about <xref:System.Windows.Threading.DispatcherPriority> levels can be found in the Windows SDK documentation.</span></span>

<a name="samples"></a>
## <a name="threads-in-action-the-samples"></a><span data-ttu-id="06f56-158">Vlákna v akci: ukázky</span><span class="sxs-lookup"><span data-stu-id="06f56-158">Threads in Action: The Samples</span></span>

<a name="prime_number"></a>
### <a name="a-single-threaded-application-with-a-long-running-calculation"></a><span data-ttu-id="06f56-159">Aplikace s jedním vláknem s dlouhodobou kalkulací</span><span class="sxs-lookup"><span data-stu-id="06f56-159">A Single-Threaded Application with a Long-Running Calculation</span></span>
 <span data-ttu-id="06f56-160">Většina grafických uživatelských rozhraní (GUI) stráví velkou část času nečinnosti při čekání na události, které jsou vygenerovány v reakci na interakci uživatele.</span><span class="sxs-lookup"><span data-stu-id="06f56-160">Most graphical user interfaces (GUIs) spend a large portion of their time idle while waiting for events that are generated in response to user interactions.</span></span> <span data-ttu-id="06f56-161">S pečlivým programováním je možné tento čas nečinnosti použít, aniž by to ovlivnilo odezvu [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] .</span><span class="sxs-lookup"><span data-stu-id="06f56-161">With careful programming this idle time can be used constructively, without affecting the responsiveness of the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)].</span></span> <span data-ttu-id="06f56-162">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]Model vláken nepovoluje vstup k přerušení operace, která se odehrává ve [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] vlákně.</span><span class="sxs-lookup"><span data-stu-id="06f56-162">The [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] threading model doesn’t allow input to interrupt an operation happening in the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="06f56-163">To znamená, že musíte mít jistotu, že se budete muset <xref:System.Windows.Threading.Dispatcher> pravidelně vracet do procesu probíhajících vstupních událostí.</span><span class="sxs-lookup"><span data-stu-id="06f56-163">This means you must be sure to return to the <xref:System.Windows.Threading.Dispatcher> periodically to process pending input events before they get stale.</span></span>

 <span data-ttu-id="06f56-164">Uvažujte následující příklad:</span><span class="sxs-lookup"><span data-stu-id="06f56-164">Consider the following example:</span></span>

 ![Snímek obrazovky, který zobrazuje vlákna z primárních čísel.](./media/threading-model/threading-prime-numbers.png)

 <span data-ttu-id="06f56-166">Tato jednoduchá aplikace se počítá směrem nahoru od tří, hledá se čísla na apostrofech.</span><span class="sxs-lookup"><span data-stu-id="06f56-166">This simple application counts upwards from three, searching for prime numbers.</span></span> <span data-ttu-id="06f56-167">Když uživatel klikne na tlačítko **Start** , hledání začne.</span><span class="sxs-lookup"><span data-stu-id="06f56-167">When the user clicks the **Start** button, the search begins.</span></span> <span data-ttu-id="06f56-168">Když program najde primární, aktualizuje uživatelské rozhraní jeho zjišťováním.</span><span class="sxs-lookup"><span data-stu-id="06f56-168">When the program finds a prime, it updates the user interface with its discovery.</span></span> <span data-ttu-id="06f56-169">V jakémkoli okamžiku může uživatel hledání zastavit.</span><span class="sxs-lookup"><span data-stu-id="06f56-169">At any point, the user can stop the search.</span></span>

 <span data-ttu-id="06f56-170">I když je dostatek jednoduchého, hledání na základě prvotních čísel by mohlo jít trvale, což představuje některé problémy.</span><span class="sxs-lookup"><span data-stu-id="06f56-170">Although simple enough, the prime number search could go on forever, which presents some difficulties.</span></span>  <span data-ttu-id="06f56-171">Pokud jsme celé vyhledávání poznamenali v obslužné rutině události Click tlačítka, nikdy neposkytneme [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] vlákno možnost zpracovávat jiné události.</span><span class="sxs-lookup"><span data-stu-id="06f56-171">If we handled the entire search inside of the click event handler of the button, we would never give the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread a chance to handle other events.</span></span> <span data-ttu-id="06f56-172">By nebylo možné [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] reagovat na vstupní nebo procesní zprávy.</span><span class="sxs-lookup"><span data-stu-id="06f56-172">The [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] would be unable to respond to input or process messages.</span></span> <span data-ttu-id="06f56-173">Nikdy nepřekreslí a nikdy nereaguje na kliknutí na tlačítko.</span><span class="sxs-lookup"><span data-stu-id="06f56-173">It would never repaint and never respond to button clicks.</span></span>

 <span data-ttu-id="06f56-174">Hledání na primárním čísle můžeme provést v samostatném vlákně, ale musíme řešit problémy s synchronizací.</span><span class="sxs-lookup"><span data-stu-id="06f56-174">We could conduct the prime number search in a separate thread, but then we would need to deal with synchronization issues.</span></span> <span data-ttu-id="06f56-175">S přístupem s jedním vláknem můžeme přímo aktualizovat popisek, který uvádí největší nalezené apostrofy.</span><span class="sxs-lookup"><span data-stu-id="06f56-175">With a single-threaded approach, we can directly update the label that lists the largest prime found.</span></span>

 <span data-ttu-id="06f56-176">V případě, že úlohu výpočtu rozdělíte na spravovatelné bloky dat, můžeme se pravidelně vracet do <xref:System.Windows.Threading.Dispatcher> procesů a zpracovávat události.</span><span class="sxs-lookup"><span data-stu-id="06f56-176">If we break up the task of calculation into manageable chunks, we can periodically return to the <xref:System.Windows.Threading.Dispatcher> and process events.</span></span> <span data-ttu-id="06f56-177">Můžeme předat [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] možnost překreslit a zpracovat vstup.</span><span class="sxs-lookup"><span data-stu-id="06f56-177">We can give [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] an opportunity to repaint and process input.</span></span>

 <span data-ttu-id="06f56-178">Nejlepším způsobem, jak rozdělit dobu zpracování mezi výpočtem a zpracováním událostí, je spravovat výpočet z <xref:System.Windows.Threading.Dispatcher> .</span><span class="sxs-lookup"><span data-stu-id="06f56-178">The best way to split processing time between calculation and event handling is to manage calculation from the <xref:System.Windows.Threading.Dispatcher>.</span></span> <span data-ttu-id="06f56-179">Pomocí <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> metody můžeme naplánovat kontroly prvotních čísel ve stejné frontě, [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] z níž se události vykreslí.</span><span class="sxs-lookup"><span data-stu-id="06f56-179">By using the <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> method, we can schedule prime number checks in the same queue that [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] events are drawn from.</span></span> <span data-ttu-id="06f56-180">V našem příkladu plánujeme vždy jenom jednu kontrolu primárního čísla.</span><span class="sxs-lookup"><span data-stu-id="06f56-180">In our example, we schedule only a single prime number check at a time.</span></span> <span data-ttu-id="06f56-181">Po dokončení kontroly prvotního čísla naplánujeme další kontrolu hned.</span><span class="sxs-lookup"><span data-stu-id="06f56-181">After the prime number check is complete, we schedule the next check immediately.</span></span> <span data-ttu-id="06f56-182">Tato kontrolu pokračuje až po zpracování nevyřízených [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] událostí.</span><span class="sxs-lookup"><span data-stu-id="06f56-182">This check proceeds only after pending [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] events have been handled.</span></span>

 ![Snímek obrazovky, který zobrazuje frontu dispečera.](./media/threading-model/threading-dispatcher-queue.png)

 <span data-ttu-id="06f56-184">Microsoft Word provádí kontrolu pravopisu pomocí tohoto mechanismu.</span><span class="sxs-lookup"><span data-stu-id="06f56-184">Microsoft Word accomplishes spell checking using this mechanism.</span></span> <span data-ttu-id="06f56-185">Kontrola pravopisu se provádí na pozadí s použitím času nečinnosti [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] vlákna.</span><span class="sxs-lookup"><span data-stu-id="06f56-185">Spell checking is done in the background using the idle time of the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="06f56-186">Pojďme se podívat na kód.</span><span class="sxs-lookup"><span data-stu-id="06f56-186">Let's take a look at the code.</span></span>

 <span data-ttu-id="06f56-187">Následující příklad ukazuje kód XAML, který vytváří uživatelské rozhraní.</span><span class="sxs-lookup"><span data-stu-id="06f56-187">The following example shows the XAML that creates the user interface.</span></span>

 [!code-xaml[ThreadingPrimeNumbers#ThreadingPrimeNumberXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml#threadingprimenumberxaml)]

 <span data-ttu-id="06f56-188">Následující příklad ukazuje kód na pozadí.</span><span class="sxs-lookup"><span data-stu-id="06f56-188">The following example shows the code-behind.</span></span>

 [!code-csharp[ThreadingPrimeNumbers#ThreadingPrimeNumberCodeBehind](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml.cs#threadingprimenumbercodebehind)]
 [!code-vb[ThreadingPrimeNumbers#ThreadingPrimeNumberCodeBehind](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingPrimeNumbers/visualbasic/mainwindow.xaml.vb#threadingprimenumbercodebehind)]

 <span data-ttu-id="06f56-189">Následující příklad ukazuje obslužnou rutinu události pro <xref:System.Windows.Controls.Button> .</span><span class="sxs-lookup"><span data-stu-id="06f56-189">The following example shows the event handler for the <xref:System.Windows.Controls.Button>.</span></span>

 [!code-csharp[ThreadingPrimeNumbers#ThreadingPrimeNumberStartOrStop](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml.cs#threadingprimenumberstartorstop)]
 [!code-vb[ThreadingPrimeNumbers#ThreadingPrimeNumberStartOrStop](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingPrimeNumbers/visualbasic/mainwindow.xaml.vb#threadingprimenumberstartorstop)]

 <span data-ttu-id="06f56-190">Kromě aktualizace textu na <xref:System.Windows.Controls.Button> , je tato obslužná rutina zodpovědná za plánování prvotní kontroly prvotních čísel přidáním delegáta do <xref:System.Windows.Threading.Dispatcher> fronty.</span><span class="sxs-lookup"><span data-stu-id="06f56-190">Besides updating the text on the <xref:System.Windows.Controls.Button>, this handler is responsible for scheduling the first prime number check by adding a delegate to the <xref:System.Windows.Threading.Dispatcher> queue.</span></span> <span data-ttu-id="06f56-191">Po dokončení této obslužné rutiny události <xref:System.Windows.Threading.Dispatcher> bude tento delegát vybrán pro spuštění.</span><span class="sxs-lookup"><span data-stu-id="06f56-191">Sometime after this event handler has completed its work, the <xref:System.Windows.Threading.Dispatcher> will select this delegate for execution.</span></span>

 <span data-ttu-id="06f56-192">Jak jsme se už dozvěděli dřív, <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> je <xref:System.Windows.Threading.Dispatcher> člen použitý k naplánování delegáta pro provádění.</span><span class="sxs-lookup"><span data-stu-id="06f56-192">As we mentioned earlier, <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> is the <xref:System.Windows.Threading.Dispatcher> member used to schedule a delegate for execution.</span></span> <span data-ttu-id="06f56-193">V tomto případě zvolíme <xref:System.Windows.Threading.DispatcherPriority.SystemIdle> prioritu.</span><span class="sxs-lookup"><span data-stu-id="06f56-193">In this case, we choose the <xref:System.Windows.Threading.DispatcherPriority.SystemIdle> priority.</span></span> <span data-ttu-id="06f56-194">Spustí <xref:System.Windows.Threading.Dispatcher> tohoto delegáta pouze v případě, že neexistují žádné důležité události ke zpracování.</span><span class="sxs-lookup"><span data-stu-id="06f56-194">The <xref:System.Windows.Threading.Dispatcher> will execute this delegate only when there are no important events to process.</span></span> [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]<span data-ttu-id="06f56-195">odezva je důležitější než Kontrola čísla.</span><span class="sxs-lookup"><span data-stu-id="06f56-195">responsiveness is more important than number checking.</span></span> <span data-ttu-id="06f56-196">Také předáte novému delegátovi, který představuje rutinu pro kontrolu čísel.</span><span class="sxs-lookup"><span data-stu-id="06f56-196">We also pass a new delegate representing the number-checking routine.</span></span>

 [!code-csharp[ThreadingPrimeNumbers#ThreadingPrimeNumberCheckNextNumber](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml.cs#threadingprimenumberchecknextnumber)]
 [!code-vb[ThreadingPrimeNumbers#ThreadingPrimeNumberCheckNextNumber](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingPrimeNumbers/visualbasic/mainwindow.xaml.vb#threadingprimenumberchecknextnumber)]

 <span data-ttu-id="06f56-197">Tato metoda kontroluje, zda je následující liché číslo primární.</span><span class="sxs-lookup"><span data-stu-id="06f56-197">This method checks if the next odd number is prime.</span></span> <span data-ttu-id="06f56-198">Pokud je primární, metoda přímo aktualizuje rozhraní tak, `bigPrime` <xref:System.Windows.Controls.TextBlock> aby odráželo jeho zjišťování.</span><span class="sxs-lookup"><span data-stu-id="06f56-198">If it is prime, the method directly updates the `bigPrime`<xref:System.Windows.Controls.TextBlock> to reflect its discovery.</span></span> <span data-ttu-id="06f56-199">To můžeme udělat, protože výpočet se vyskytuje ve stejném vlákně, které jste použili k vytvoření komponenty.</span><span class="sxs-lookup"><span data-stu-id="06f56-199">We can do this because the calculation is occurring in the same thread that was used to create the component.</span></span> <span data-ttu-id="06f56-200">Zvolili jsme použití samostatného vlákna pro výpočet, musíme použít složitější synchronizační mechanismus a spustit aktualizaci ve [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] vlákně.</span><span class="sxs-lookup"><span data-stu-id="06f56-200">Had we chosen to use a separate thread for the calculation, we would have to use a more complicated synchronization mechanism and execute the update in the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="06f56-201">Tuto situaci si ukážeme dál.</span><span class="sxs-lookup"><span data-stu-id="06f56-201">We’ll demonstrate this situation next.</span></span>

 <span data-ttu-id="06f56-202">Úplný zdrojový kód pro tuto ukázku najdete v tématu [aplikace s jedním vláknem s ukázkou dlouho běžícího výpočtu](https://github.com/Microsoft/WPF-Samples/tree/master/Threading/SingleThreadedApplication) .</span><span class="sxs-lookup"><span data-stu-id="06f56-202">For the complete source code for this sample, see the [Single-Threaded Application with Long-Running Calculation Sample](https://github.com/Microsoft/WPF-Samples/tree/master/Threading/SingleThreadedApplication)</span></span>

<a name="weather_sim"></a>
### <a name="handling-a-blocking-operation-with-a-background-thread"></a><span data-ttu-id="06f56-203">Zpracování blokující operace s vláknem na pozadí</span><span class="sxs-lookup"><span data-stu-id="06f56-203">Handling a Blocking Operation with a Background Thread</span></span>
 <span data-ttu-id="06f56-204">Manipulace s blokujícími operacemi v grafické aplikaci může být obtížné.</span><span class="sxs-lookup"><span data-stu-id="06f56-204">Handling blocking operations in a graphical application can be difficult.</span></span> <span data-ttu-id="06f56-205">Nechceme volat metody blokování z obslužných rutin událostí, protože se zdá, že se aplikace zablokuje.</span><span class="sxs-lookup"><span data-stu-id="06f56-205">We don’t want to call blocking methods from event handlers because the application will appear to freeze up.</span></span> <span data-ttu-id="06f56-206">Pro zpracování těchto operací můžeme použít samostatné vlákno, ale po dokončení musíme synchronizaci s [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] vláknem, protože nemůžeme přímo změnit grafické uživatelské rozhraní z našeho pracovního vlákna.</span><span class="sxs-lookup"><span data-stu-id="06f56-206">We can use a separate thread to handle these operations, but when we’re done, we have to synchronize with the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread because we can’t directly modify the GUI from our worker thread.</span></span> <span data-ttu-id="06f56-207">Můžeme použít <xref:System.Windows.Threading.Dispatcher.Invoke%2A> nebo <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> pro vkládání delegátů do <xref:System.Windows.Threading.Dispatcher> [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] vlákna.</span><span class="sxs-lookup"><span data-stu-id="06f56-207">We can use <xref:System.Windows.Threading.Dispatcher.Invoke%2A> or <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> to insert delegates into the <xref:System.Windows.Threading.Dispatcher> of the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="06f56-208">Nakonec se tyto delegáty spustí s oprávněním pro úpravu [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] prvků.</span><span class="sxs-lookup"><span data-stu-id="06f56-208">Eventually, these delegates will be executed with permission to modify [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] elements.</span></span>

 <span data-ttu-id="06f56-209">V tomto příkladu Napodobme vzdálené volání procedur, které načte předpověď počasí.</span><span class="sxs-lookup"><span data-stu-id="06f56-209">In this example, we mimic a remote procedure call that retrieves a weather forecast.</span></span> <span data-ttu-id="06f56-210">K provedení tohoto volání používáme samostatné pracovní vlákno a při dokončení naplánujeme metodu aktualizace ve <xref:System.Windows.Threading.Dispatcher> [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] vlákně.</span><span class="sxs-lookup"><span data-stu-id="06f56-210">We use a separate worker thread to execute this call, and we schedule an update method in the <xref:System.Windows.Threading.Dispatcher> of the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread when we’re finished.</span></span>

 ![Snímek obrazovky zobrazující uživatelské rozhraní počasí](./media/threading-model/threading-weather-ui.png)

 [!code-csharp[ThreadingWeatherForecast#ThreadingWeatherCodeBehind](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweathercodebehind)]
 [!code-vb[ThreadingWeatherForecast#ThreadingWeatherCodeBehind](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweathercodebehind)]

 <span data-ttu-id="06f56-212">Níže jsou uvedeny některé podrobnosti.</span><span class="sxs-lookup"><span data-stu-id="06f56-212">The following are some of the details to be noted.</span></span>

- <span data-ttu-id="06f56-213">Vytvoření obslužné rutiny tlačítka</span><span class="sxs-lookup"><span data-stu-id="06f56-213">Creating the Button Handler</span></span>

     [!code-csharp[ThreadingWeatherForecast#ThreadingWeatherButtonHandler](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweatherbuttonhandler)]
     [!code-vb[ThreadingWeatherForecast#ThreadingWeatherButtonHandler](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweatherbuttonhandler)]

 <span data-ttu-id="06f56-214">Po kliknutí na tlačítko zobrazíme vykreslování hodin a začnete ho animovat.</span><span class="sxs-lookup"><span data-stu-id="06f56-214">When the button is clicked, we display the clock drawing and start animating it.</span></span> <span data-ttu-id="06f56-215">Zakážeme toto tlačítko.</span><span class="sxs-lookup"><span data-stu-id="06f56-215">We disable the button.</span></span> <span data-ttu-id="06f56-216">`FetchWeatherFromServer`Metodu vyvolá v novém vlákně a potom se vrátíme a umožníme <xref:System.Windows.Threading.Dispatcher> zpracování událostí během čekání na shromáždění předpovědi počasí.</span><span class="sxs-lookup"><span data-stu-id="06f56-216">We invoke the `FetchWeatherFromServer` method in a new thread, and then we return, allowing the <xref:System.Windows.Threading.Dispatcher> to process events while we wait to collect the weather forecast.</span></span>

- <span data-ttu-id="06f56-217">Načítají se počasí.</span><span class="sxs-lookup"><span data-stu-id="06f56-217">Fetching the Weather</span></span>

     [!code-csharp[ThreadingWeatherForecast#ThreadingWeatherFetchWeather](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweatherfetchweather)]
     [!code-vb[ThreadingWeatherForecast#ThreadingWeatherFetchWeather](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweatherfetchweather)]

 <span data-ttu-id="06f56-218">V tomto příkladu nemáme v tomto příkladu žádný kód sítě.</span><span class="sxs-lookup"><span data-stu-id="06f56-218">To keep things simple, we don’t actually have any networking code in this example.</span></span> <span data-ttu-id="06f56-219">Místo toho simulujeme zpoždění přístupu k síti tím, že jsme nové vlákno umístili do režimu spánku po dobu čtyř sekund.</span><span class="sxs-lookup"><span data-stu-id="06f56-219">Instead, we simulate the delay of network access by putting our new thread to sleep for four seconds.</span></span> <span data-ttu-id="06f56-220">V tuto chvíli [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] je původní vlákno pořád spuštěné a reaguje na události.</span><span class="sxs-lookup"><span data-stu-id="06f56-220">In this time, the original [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread is still running and responding to events.</span></span> <span data-ttu-id="06f56-221">Pokud to chcete zobrazit, opustili jsme animaci spuštěnou a tlačítky minimalizovat a maximalizovat i nadále fungují.</span><span class="sxs-lookup"><span data-stu-id="06f56-221">To show this, we’ve left an animation running, and the minimize and maximize buttons also continue to work.</span></span>

 <span data-ttu-id="06f56-222">Až se zpoždění dokončí a my jsme náhodně vybrali naši předpověď počasí, je čas nahlásit zpět do [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] vlákna.</span><span class="sxs-lookup"><span data-stu-id="06f56-222">When the delay is finished, and we’ve randomly selected our weather forecast, it’s time to report back to the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="06f56-223">Provedeme to naplánováním volání `UpdateUserInterface` ve [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] vlákně pomocí tohoto vlákna <xref:System.Windows.Threading.Dispatcher> .</span><span class="sxs-lookup"><span data-stu-id="06f56-223">We do this by scheduling a call to `UpdateUserInterface` in the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread using that thread’s <xref:System.Windows.Threading.Dispatcher>.</span></span> <span data-ttu-id="06f56-224">Předáte řetězec popisující počasí k tomuto plánovanému volání metody.</span><span class="sxs-lookup"><span data-stu-id="06f56-224">We pass a string describing the weather to this scheduled method call.</span></span>

- <span data-ttu-id="06f56-225">Aktualizuje se[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]</span><span class="sxs-lookup"><span data-stu-id="06f56-225">Updating the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]</span></span>

     [!code-csharp[ThreadingWeatherForecast#ThreadingWeatherUpdateUI](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweatherupdateui)]
     [!code-vb[ThreadingWeatherForecast#ThreadingWeatherUpdateUI](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweatherupdateui)]

 <span data-ttu-id="06f56-226">Pokud <xref:System.Windows.Threading.Dispatcher> [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] má vlákno ve vlákně čas, spustí plánované volání `UpdateUserInterface` .</span><span class="sxs-lookup"><span data-stu-id="06f56-226">When the <xref:System.Windows.Threading.Dispatcher> in the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread has time, it executes the scheduled call to `UpdateUserInterface`.</span></span> <span data-ttu-id="06f56-227">Tato metoda zastaví animaci hodin a vybere obrázek pro popis počasí.</span><span class="sxs-lookup"><span data-stu-id="06f56-227">This method stops the clock animation and chooses an image to describe the weather.</span></span> <span data-ttu-id="06f56-228">Zobrazuje tento obrázek a obnoví tlačítko "vyhodnotit předpověď".</span><span class="sxs-lookup"><span data-stu-id="06f56-228">It displays this image and restores the "fetch forecast" button.</span></span>

<a name="multi_browser"></a>
### <a name="multiple-windows-multiple-threads"></a><span data-ttu-id="06f56-229">Více oken, více vláken</span><span class="sxs-lookup"><span data-stu-id="06f56-229">Multiple Windows, Multiple Threads</span></span>
 <span data-ttu-id="06f56-230">Některé [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] aplikace vyžadují více oken nejvyšší úrovně.</span><span class="sxs-lookup"><span data-stu-id="06f56-230">Some [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications require multiple top-level windows.</span></span> <span data-ttu-id="06f56-231">Je zcela přijatelné pro jedno vlákno nebo <xref:System.Windows.Threading.Dispatcher> kombinaci ke správě více oken, ale někdy několik vláken má lepší úlohu.</span><span class="sxs-lookup"><span data-stu-id="06f56-231">It is perfectly acceptable for one Thread/<xref:System.Windows.Threading.Dispatcher> combination to manage multiple windows, but sometimes several threads do a better job.</span></span> <span data-ttu-id="06f56-232">To platí zejména v případě, že existuje možnost, že jedno z oken bude monopolizovat vlákno.</span><span class="sxs-lookup"><span data-stu-id="06f56-232">This is especially true if there is any chance that one of the windows will monopolize the thread.</span></span>

 <span data-ttu-id="06f56-233">Průzkumník Windows funguje tímto způsobem.</span><span class="sxs-lookup"><span data-stu-id="06f56-233">Windows Explorer works in this fashion.</span></span> <span data-ttu-id="06f56-234">Každé nové okno Průzkumníka patří původnímu procesu, ale je vytvořeno pod kontrolou nezávislého vlákna.</span><span class="sxs-lookup"><span data-stu-id="06f56-234">Each new Explorer window belongs to the original process, but it is created under the control of an independent thread.</span></span>

 <span data-ttu-id="06f56-235">Pomocí [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] <xref:System.Windows.Controls.Frame> ovládacího prvku můžeme zobrazit webové stránky.</span><span class="sxs-lookup"><span data-stu-id="06f56-235">By using a [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]<xref:System.Windows.Controls.Frame> control, we can display Web pages.</span></span> <span data-ttu-id="06f56-236">Snadno se dá vytvořit jednoduchá náhrada z Internet Exploreru.</span><span class="sxs-lookup"><span data-stu-id="06f56-236">We can easily create a simple Internet Explorer substitute.</span></span> <span data-ttu-id="06f56-237">Začneme s důležitou funkcí: možnost otevřít nové okno Průzkumníka.</span><span class="sxs-lookup"><span data-stu-id="06f56-237">We start with an important feature: the ability to open a new explorer window.</span></span> <span data-ttu-id="06f56-238">Když uživatel klikne na tlačítko "nové okno", spustíme kopii našeho okna v samostatném vlákně.</span><span class="sxs-lookup"><span data-stu-id="06f56-238">When the user clicks the "new window" button, we launch a copy of our window in a separate thread.</span></span> <span data-ttu-id="06f56-239">Tímto způsobem dlouho běžící nebo blokující operace v jednom z oken nezamkne všechna ostatní okna.</span><span class="sxs-lookup"><span data-stu-id="06f56-239">This way, long-running or blocking operations in one of the windows won’t lock all the other windows.</span></span>

 <span data-ttu-id="06f56-240">Ve skutečnosti má model webového prohlížeče svůj vlastní složitý model vláken.</span><span class="sxs-lookup"><span data-stu-id="06f56-240">In reality, the Web browser model has its own complicated threading model.</span></span> <span data-ttu-id="06f56-241">Zvolili jsme to proto, že by měl být známý pro většinu čtenářů.</span><span class="sxs-lookup"><span data-stu-id="06f56-241">We’ve chosen it because it should be familiar to most readers.</span></span>

 <span data-ttu-id="06f56-242">Následující příklad ukazuje kód.</span><span class="sxs-lookup"><span data-stu-id="06f56-242">The following example shows the code.</span></span>

 [!code-xaml[ThreadingMultipleBrowsers#ThreadingMultiBrowserXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingMultipleBrowsers/CSharp/Window1.xaml#threadingmultibrowserxaml)]

 [!code-csharp[ThreadingMultipleBrowsers#ThreadingMultiBrowserCodeBehind](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingMultipleBrowsers/CSharp/Window1.xaml.cs#threadingmultibrowsercodebehind)]
 [!code-vb[ThreadingMultipleBrowsers#ThreadingMultiBrowserCodeBehind](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingMultipleBrowsers/VisualBasic/Window1.xaml.vb#threadingmultibrowsercodebehind)]

 <span data-ttu-id="06f56-243">Následující segmenty vlákna tohoto kódu jsou pro nás v tomto kontextu nejzajímavější:</span><span class="sxs-lookup"><span data-stu-id="06f56-243">The following threading segments of this code are the most interesting to us in this context:</span></span>

 [!code-csharp[ThreadingMultipleBrowsers#ThreadingMultiBrowserNewWindow](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingMultipleBrowsers/CSharp/Window1.xaml.cs#threadingmultibrowsernewwindow)]
 [!code-vb[ThreadingMultipleBrowsers#ThreadingMultiBrowserNewWindow](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingMultipleBrowsers/VisualBasic/Window1.xaml.vb#threadingmultibrowsernewwindow)]

 <span data-ttu-id="06f56-244">Tato metoda je volána při kliknutí na tlačítko "nové okno".</span><span class="sxs-lookup"><span data-stu-id="06f56-244">This method is called when the "new window" button is clicked.</span></span> <span data-ttu-id="06f56-245">Vytvoří nové vlákno a spustí asynchronně.</span><span class="sxs-lookup"><span data-stu-id="06f56-245">It creates a new thread and starts it asynchronously.</span></span>

 [!code-csharp[ThreadingMultipleBrowsers#ThreadingMultiBrowserThreadStart](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingMultipleBrowsers/CSharp/Window1.xaml.cs#threadingmultibrowserthreadstart)]
 [!code-vb[ThreadingMultipleBrowsers#ThreadingMultiBrowserThreadStart](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingMultipleBrowsers/VisualBasic/Window1.xaml.vb#threadingmultibrowserthreadstart)]

 <span data-ttu-id="06f56-246">Tato metoda je výchozím bodem pro nové vlákno.</span><span class="sxs-lookup"><span data-stu-id="06f56-246">This method is the starting point for the new thread.</span></span> <span data-ttu-id="06f56-247">Pod kontrolou tohoto vlákna vytvoříme nové okno.</span><span class="sxs-lookup"><span data-stu-id="06f56-247">We create a new window under the control of this thread.</span></span> [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]<span data-ttu-id="06f56-248">automaticky vytvoří nový <xref:System.Windows.Threading.Dispatcher> pro správu nového vlákna.</span><span class="sxs-lookup"><span data-stu-id="06f56-248">automatically creates a new <xref:System.Windows.Threading.Dispatcher> to manage the new thread.</span></span> <span data-ttu-id="06f56-249">K tomu, aby bylo okno funkční, je třeba spustit <xref:System.Windows.Threading.Dispatcher> .</span><span class="sxs-lookup"><span data-stu-id="06f56-249">All we have to do to make the window functional is to start the <xref:System.Windows.Threading.Dispatcher>.</span></span>

<a name="stumbling_points"></a>
## <a name="technical-details-and-stumbling-points"></a><span data-ttu-id="06f56-250">Technické podrobnosti a body Stumbling</span><span class="sxs-lookup"><span data-stu-id="06f56-250">Technical Details and Stumbling Points</span></span>

### <a name="writing-components-using-threading"></a><span data-ttu-id="06f56-251">Zápis komponent pomocí dělení na vlákna</span><span class="sxs-lookup"><span data-stu-id="06f56-251">Writing Components Using Threading</span></span>
 <span data-ttu-id="06f56-252">Příručka pro vývojáře Microsoft .NET Framework popisuje vzor, jak může komponenta vystavovat asynchronní chování svým klientům (viz [Přehled asynchronních vzorů založených na událostech](../../../standard/asynchronous-programming-patterns/event-based-asynchronous-pattern-overview.md)).</span><span class="sxs-lookup"><span data-stu-id="06f56-252">The Microsoft .NET Framework Developer's Guide describes a pattern for how a component can expose asynchronous behavior to its clients (see [Event-based Asynchronous Pattern Overview](../../../standard/asynchronous-programming-patterns/event-based-asynchronous-pattern-overview.md)).</span></span> <span data-ttu-id="06f56-253">Předpokládejme například, že jsme chtěli zabalit `FetchWeatherFromServer` metodu do opakovaně použitelné, negrafované komponenty.</span><span class="sxs-lookup"><span data-stu-id="06f56-253">For instance, suppose we wanted to package the `FetchWeatherFromServer` method into a reusable, nongraphical component.</span></span> <span data-ttu-id="06f56-254">Po standardním vzoru Microsoft .NET Framework by to vypadalo podobně jako v následujícím.</span><span class="sxs-lookup"><span data-stu-id="06f56-254">Following the standard Microsoft .NET Framework pattern, this would look something like the following.</span></span>

 [!code-csharp[CommandingOverviewSnippets#ThreadingArticleWeatherComponent1](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandingOverviewSnippets/CSharp/Window1.xaml.cs#threadingarticleweathercomponent1)]
 [!code-vb[CommandingOverviewSnippets#ThreadingArticleWeatherComponent1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CommandingOverviewSnippets/visualbasic/window1.xaml.vb#threadingarticleweathercomponent1)]

 <span data-ttu-id="06f56-255">`GetWeatherAsync`použije jeden z výše popsaných postupů, jako je například vytvoření vlákna na pozadí pro asynchronní práci bez blokování volajícího vlákna.</span><span class="sxs-lookup"><span data-stu-id="06f56-255">`GetWeatherAsync` would use one of the techniques described earlier, such as creating a background thread, to do the work asynchronously, not blocking the calling thread.</span></span>

 <span data-ttu-id="06f56-256">Jednou z nejdůležitějších částí tohoto modelu je volání metody *methodName* `Completed` ve stejném vlákně, které volalo metodu *methodName* , `Async` která začíná na.</span><span class="sxs-lookup"><span data-stu-id="06f56-256">One of the most important parts of this pattern is calling the *MethodName*`Completed` method on the same thread that called the *MethodName*`Async` method to begin with.</span></span> <span data-ttu-id="06f56-257">To lze provést [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] poměrně snadno, protože je uložíte <xref:System.Windows.Threading.Dispatcher.CurrentDispatcher%2A> , ale negrafickou komponentu lze použít pouze v [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] aplikacích, nikoli v model Windows Forms nebo ASP.NETch programech.</span><span class="sxs-lookup"><span data-stu-id="06f56-257">You could do this using [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] fairly easily, by storing <xref:System.Windows.Threading.Dispatcher.CurrentDispatcher%2A>—but then the nongraphical component could only be used in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications, not in Windows Forms or ASP.NET programs.</span></span>

 <span data-ttu-id="06f56-258"><xref:System.Windows.Threading.DispatcherSynchronizationContext>Třída tuto potřebu řeší – považuje se za zjednodušenou verzi nástroje <xref:System.Windows.Threading.Dispatcher> , která funguje i v jiných [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] architekturách.</span><span class="sxs-lookup"><span data-stu-id="06f56-258">The <xref:System.Windows.Threading.DispatcherSynchronizationContext> class addresses this need—think of it as a simplified version of <xref:System.Windows.Threading.Dispatcher> that works with other [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] frameworks as well.</span></span>

 [!code-csharp[CommandingOverviewSnippets#ThreadingArticleWeatherComponent2](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandingOverviewSnippets/CSharp/Window1.xaml.cs#threadingarticleweathercomponent2)]
 [!code-vb[CommandingOverviewSnippets#ThreadingArticleWeatherComponent2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CommandingOverviewSnippets/visualbasic/window1.xaml.vb#threadingarticleweathercomponent2)]

### <a name="nested-pumping"></a><span data-ttu-id="06f56-259">Vnořená pumpa</span><span class="sxs-lookup"><span data-stu-id="06f56-259">Nested Pumping</span></span>
 <span data-ttu-id="06f56-260">V některých případech není možné vlákno kompletně Uzamknout [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] .</span><span class="sxs-lookup"><span data-stu-id="06f56-260">Sometimes it is not feasible to completely lock up the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="06f56-261">Pojďme vzít v úvahu <xref:System.Windows.MessageBox.Show%2A> metodu <xref:System.Windows.MessageBox> třídy.</span><span class="sxs-lookup"><span data-stu-id="06f56-261">Let’s consider the <xref:System.Windows.MessageBox.Show%2A> method of the <xref:System.Windows.MessageBox> class.</span></span> <span data-ttu-id="06f56-262"><xref:System.Windows.MessageBox.Show%2A>nevrátí se, dokud uživatel neklikne na tlačítko OK.</span><span class="sxs-lookup"><span data-stu-id="06f56-262"><xref:System.Windows.MessageBox.Show%2A> doesn’t return until the user clicks the OK button.</span></span> <span data-ttu-id="06f56-263">Ale vytvoří okno, které musí mít smyčku zpráv, aby mohla být interaktivní.</span><span class="sxs-lookup"><span data-stu-id="06f56-263">It does, however, create a window that must have a message loop in order to be interactive.</span></span> <span data-ttu-id="06f56-264">Čekáme na to, až uživatel klikne na tlačítko OK, původní okno aplikace nereaguje na vstup uživatele.</span><span class="sxs-lookup"><span data-stu-id="06f56-264">While we are waiting for the user to click OK, the original application window does not respond to user input.</span></span> <span data-ttu-id="06f56-265">Ale i nadále zpracovává zprávy o malování.</span><span class="sxs-lookup"><span data-stu-id="06f56-265">It does, however, continue to process paint messages.</span></span> <span data-ttu-id="06f56-266">Původní okno se překreslí samostatně, pokud je zahrnuto a odhaleno.</span><span class="sxs-lookup"><span data-stu-id="06f56-266">The original window redraws itself when covered and revealed.</span></span>

 ![Snímek obrazovky, který zobrazuje MessageBox s tlačítkem OK](./media/threading-model/threading-message-loop.png)

 <span data-ttu-id="06f56-268">U některých vláken se musí nacházet okno se zprávou.</span><span class="sxs-lookup"><span data-stu-id="06f56-268">Some thread must be in charge of the message box window.</span></span> [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]<span data-ttu-id="06f56-269">může vytvořit nové vlákno pouze pro okno se zprávou, ale toto vlákno nebude moci vykreslit zakázané prvky do původního okna (zapamatujte si předchozí diskuzi na vzájemné vyloučení).</span><span class="sxs-lookup"><span data-stu-id="06f56-269">could create a new thread just for the message box window, but this thread would be unable to paint the disabled elements in the original window (remember the earlier discussion of mutual exclusion).</span></span> <span data-ttu-id="06f56-270">Místo toho [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] používá vnořený systém zpracování zpráv.</span><span class="sxs-lookup"><span data-stu-id="06f56-270">Instead, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] uses a nested message processing system.</span></span> <span data-ttu-id="06f56-271"><xref:System.Windows.Threading.Dispatcher>Třída obsahuje speciální metodu s názvem <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> , která ukládá aktuální bod spuštění aplikace a následně zahájí novou smyčku zpráv.</span><span class="sxs-lookup"><span data-stu-id="06f56-271">The <xref:System.Windows.Threading.Dispatcher> class includes a special method called <xref:System.Windows.Threading.Dispatcher.PushFrame%2A>, which stores an application’s current execution point then begins a new message loop.</span></span> <span data-ttu-id="06f56-272">Po dokončení vnořené smyčky zpráv bude spuštění pokračovat po původním <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> volání.</span><span class="sxs-lookup"><span data-stu-id="06f56-272">When the nested message loop finishes, execution resumes after the original <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> call.</span></span>

 <span data-ttu-id="06f56-273">V tomto případě <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> udržuje kontext programu při volání <xref:System.Windows.MessageBox.Show%2A?displayProperty=nameWithType> a spustí novou smyčku zpráv pro překreslení okna na pozadí a zpracování vstupu do okna se zprávou.</span><span class="sxs-lookup"><span data-stu-id="06f56-273">In this case, <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> maintains the program context at the call to <xref:System.Windows.MessageBox.Show%2A?displayProperty=nameWithType>, and it starts a new message loop to repaint the background window and handle input to the message box window.</span></span> <span data-ttu-id="06f56-274">Když uživatel klikne na tlačítko OK a vymaže automaticky otevírané okno, vnořená smyčka skončí a řízení pokračuje po volání <xref:System.Windows.MessageBox.Show%2A> .</span><span class="sxs-lookup"><span data-stu-id="06f56-274">When the user clicks OK and clears the pop-up window, the nested loop exits and control resumes after the call to <xref:System.Windows.MessageBox.Show%2A>.</span></span>

### <a name="stale-routed-events"></a><span data-ttu-id="06f56-275">Zastaralé směrované události</span><span class="sxs-lookup"><span data-stu-id="06f56-275">Stale Routed Events</span></span>
 <span data-ttu-id="06f56-276">Systém směrovaného Event v nástroji [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] upozorní celé stromy na vyvolání událostí.</span><span class="sxs-lookup"><span data-stu-id="06f56-276">The routed event system in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] notifies entire trees when events are raised.</span></span>

 [!code-xaml[InputOvw#ThreadingArticleStaticRoutedEvent](~/samples/snippets/csharp/VS_Snippets_Wpf/InputOvw/CSharp/Page1.xaml#threadingarticlestaticroutedevent)]

 <span data-ttu-id="06f56-277">Po stisknutí levého tlačítka myši na elipsu se `handler2` spustí.</span><span class="sxs-lookup"><span data-stu-id="06f56-277">When the left mouse button is pressed over the ellipse, `handler2` is executed.</span></span> <span data-ttu-id="06f56-278">Po `handler2` dokončení se událost předává spolu s <xref:System.Windows.Controls.Canvas> objektem, který používá `handler1` ke zpracování.</span><span class="sxs-lookup"><span data-stu-id="06f56-278">After `handler2` finishes, the event is passed along to the <xref:System.Windows.Controls.Canvas> object, which uses `handler1` to process it.</span></span> <span data-ttu-id="06f56-279">K tomu dojde pouze v případě, že `handler2` objekt události explicitně neoznačí jako zpracovávaný.</span><span class="sxs-lookup"><span data-stu-id="06f56-279">This happens only if `handler2` does not explicitly mark the event object as handled.</span></span>

 <span data-ttu-id="06f56-280">Je možné, že `handler2` bude trvat značnou dobu zpracování této události.</span><span class="sxs-lookup"><span data-stu-id="06f56-280">It’s possible that `handler2` will take a great deal of time processing this event.</span></span> <span data-ttu-id="06f56-281">`handler2`může použít <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> k zahájení vnořené smyčky zpráv, která se nevrátí na hodiny.</span><span class="sxs-lookup"><span data-stu-id="06f56-281">`handler2` might use <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> to begin a nested message loop that doesn’t return for hours.</span></span> <span data-ttu-id="06f56-282">Pokud `handler2` aplikace neoznačí událost jako zpracovanou, když je tato smyčka dokončená, událost se předá do stromu, i když je to hodně staré.</span><span class="sxs-lookup"><span data-stu-id="06f56-282">If `handler2` does not mark the event as handled when this message loop is complete, the event is passed up the tree even though it is very old.</span></span>

### <a name="reentrancy-and-locking"></a><span data-ttu-id="06f56-283">Vícenásobný přístup a uzamykání</span><span class="sxs-lookup"><span data-stu-id="06f56-283">Reentrancy and Locking</span></span>
 <span data-ttu-id="06f56-284">Blokovací mechanizmus modulu CLR (Common Language Runtime) se chová přesně tak, jak je možné ho představit. může se stát, že vlákno ukončí operaci kompletně při požadavku na zámek.</span><span class="sxs-lookup"><span data-stu-id="06f56-284">The locking mechanism of the common language runtime (CLR) doesn’t behave exactly as one might imagine; one might expect a thread to cease operation completely when requesting a lock.</span></span> <span data-ttu-id="06f56-285">Ve skutečnosti vlákno nadále přijímá a zpracovává zprávy s vysokou prioritou.</span><span class="sxs-lookup"><span data-stu-id="06f56-285">In actuality, the thread continues to receive and process high-priority messages.</span></span> <span data-ttu-id="06f56-286">To pomáhá zabránit zablokování a dávat rozhraní s minimální odezvou, ale zavádí možnost drobných chyb.</span><span class="sxs-lookup"><span data-stu-id="06f56-286">This helps prevent deadlocks and make interfaces minimally responsive, but it introduces the possibility for subtle bugs.</span></span>  <span data-ttu-id="06f56-287">Velká většina času, o které nepotřebujete nic vědět, ale za výjimečných okolností (obvykle se týká zpráv oken Win32 nebo komponent modelu COM STA), se může jednat o znalost.</span><span class="sxs-lookup"><span data-stu-id="06f56-287">The vast majority of the time you don’t need to know anything about this, but under rare circumstances (usually involving Win32 window messages or COM STA components) this can be worth knowing.</span></span>

 <span data-ttu-id="06f56-288">Většina rozhraní není sestavena s ohledem na bezpečnost vlákna, protože vývojáři pracují s předpokladem, že k [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] přístupu nikdy nemá přístup více než jedno vlákno.</span><span class="sxs-lookup"><span data-stu-id="06f56-288">Most interfaces are not built with thread safety in mind because developers work under the assumption that a [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] is never accessed by more than one thread.</span></span> <span data-ttu-id="06f56-289">V takovém případě může toto jediné vlákno provádět změny v prostředí v neočekávaných časech, což způsobuje, že by se <xref:System.Windows.Threading.DispatcherObject> měl vyřešit mechanismus vzájemného vyloučení.</span><span class="sxs-lookup"><span data-stu-id="06f56-289">In this case, that single thread may make environmental changes at unexpected times, causing those ill effects that the <xref:System.Windows.Threading.DispatcherObject> mutual exclusion mechanism is supposed to solve.</span></span> <span data-ttu-id="06f56-290">Vezměte v úvahu následující pseudokódu:</span><span class="sxs-lookup"><span data-stu-id="06f56-290">Consider the following pseudocode:</span></span>

 <span data-ttu-id="06f56-291">![Diagram, který zobrazuje Vícenásobný přístup zřetězení.](./media/threading-model/threading-reentrancy.png "ThreadingReentrancy")</span><span class="sxs-lookup"><span data-stu-id="06f56-291">![Diagram that shows threading reentrancy.](./media/threading-model/threading-reentrancy.png "ThreadingReentrancy")</span></span>

 <span data-ttu-id="06f56-292">Ve většině času to je správné, ale v některých případech se může stát, že by [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] takové neočekávané vícenásobný přístupy skutečně způsobily problémy.</span><span class="sxs-lookup"><span data-stu-id="06f56-292">Most of the time that’s the right thing, but there are times in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] where such unexpected reentrancy can really cause problems.</span></span> <span data-ttu-id="06f56-293">Takže v určitých klíčových časech [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] volání <xref:System.Windows.Threading.Dispatcher.DisableProcessing%2A> , která mění instrukci zámku pro toto vlákno, aby používala [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] Zámek Vícenásobný přístup bez normálního zámku CLR.</span><span class="sxs-lookup"><span data-stu-id="06f56-293">So, at certain key times, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] calls <xref:System.Windows.Threading.Dispatcher.DisableProcessing%2A>, which changes the lock instruction for that thread to use the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] reentrancy-free lock, instead of the usual CLR lock.</span></span>

 <span data-ttu-id="06f56-294">Proč tým CLR zvolí toto chování?</span><span class="sxs-lookup"><span data-stu-id="06f56-294">So why did the CLR team choose this behavior?</span></span> <span data-ttu-id="06f56-295">Musela se provádět s objekty modelu COM STA a s dokončovacím vláknem.</span><span class="sxs-lookup"><span data-stu-id="06f56-295">It had to do with COM STA objects and the finalization thread.</span></span> <span data-ttu-id="06f56-296">Když je objekt uvolněn z paměti, `Finalize` je jeho metoda spuštěna ve vyhrazeném vlákně finalizační metody, nikoli v [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] vlákně.</span><span class="sxs-lookup"><span data-stu-id="06f56-296">When an object is garbage collected, its `Finalize` method is run on the dedicated finalizer thread, not the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="06f56-297">V tomto případě se jedná o problém, protože objekt COM STA, který byl vytvořen ve [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] vlákně, lze odstranit pouze ve [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] vlákně.</span><span class="sxs-lookup"><span data-stu-id="06f56-297">And therein lies the problem, because a COM STA object that was created on the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread can only be disposed on the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="06f56-298">CLR odpovídá <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> (v tomto případě použití Win32's `SendMessage` ).</span><span class="sxs-lookup"><span data-stu-id="06f56-298">The CLR does the equivalent of a <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> (in this case using Win32’s `SendMessage`).</span></span> <span data-ttu-id="06f56-299">Pokud je ale [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] vlákno zaneprázdněno, vlákno finalizační metody je zastaveno a objekt COM STA nelze uvolnit, což způsobí závažnou nevracení paměti.</span><span class="sxs-lookup"><span data-stu-id="06f56-299">But if the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread is busy, the finalizer thread is stalled and the COM STA object can’t be disposed, which creates a serious memory leak.</span></span> <span data-ttu-id="06f56-300">Proto tým CLR provedl obtížné volání, aby zámky pracovaly způsobem, jakým dělají.</span><span class="sxs-lookup"><span data-stu-id="06f56-300">So the CLR team made the tough call to make locks work the way they do.</span></span>

 <span data-ttu-id="06f56-301">Úkolem [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] je zabránit neočekávanému Vícenásobný přístup, aniž byste museli znovu zavádět nevrácenou paměť, což znamená, že nebudeme zablokovat Vícenásobný přístup všude.</span><span class="sxs-lookup"><span data-stu-id="06f56-301">The task for [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] is to avoid unexpected reentrancy without reintroducing the memory leak, which is why we don’t block reentrancy everywhere.</span></span>

## <a name="see-also"></a><span data-ttu-id="06f56-302">Viz také</span><span class="sxs-lookup"><span data-stu-id="06f56-302">See also</span></span>

- [<span data-ttu-id="06f56-303">Vícevláknová aplikace s ukázkou dlouhotrvajícího výpočtu</span><span class="sxs-lookup"><span data-stu-id="06f56-303">Single-Threaded Application with Long-Running Calculation Sample</span></span>](https://github.com/Microsoft/WPF-Samples/tree/master/Threading/SingleThreadedApplication)
