---
title: Architektura
ms.date: 03/30/2017
helpviewer_keywords:
- properties [WPF], attached
- attached properties [WPF]
- architecture [WPF]
- unmanaged components [WPF]
- affinity thread [WPF]
- Storyboards [WPF]
- milcore [WPF]
- components [WPF], unmanaged
- painter's algorithm
- interfaces [WPF], INotifyPropertyChange
- CommandBindings [WPF]
- data templates [WPF]
- thread [WPF], affinity
ms.assetid: 8579c10b-76ab-4c52-9691-195ce02333c8
ms.openlocfilehash: b16be8470a47f3e8e362feb0b13e10aa901baacb
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 03/12/2020
ms.locfileid: "79187123"
---
# <a name="wpf-architecture"></a><span data-ttu-id="62fd2-102">Architektura WPF</span><span class="sxs-lookup"><span data-stu-id="62fd2-102">WPF Architecture</span></span>
<span data-ttu-id="62fd2-103">Toto téma obsahuje prohlídku hierarchie tříd YPF (Windows Presentation Foundation).</span><span class="sxs-lookup"><span data-stu-id="62fd2-103">This topic provides a guided tour of the Windows Presentation Foundation (WPF) class hierarchy.</span></span> <span data-ttu-id="62fd2-104">Pokrývá většinu hlavních subsystémů WPF a popisuje, jak interagují.</span><span class="sxs-lookup"><span data-stu-id="62fd2-104">It covers most of the major subsystems of WPF, and describes how they interact.</span></span> <span data-ttu-id="62fd2-105">Rovněž podrobně popisuje některá rozhodnutí učiněná architekty WPF.</span><span class="sxs-lookup"><span data-stu-id="62fd2-105">It also details some of the choices made by the architects of WPF.</span></span>  

<a name="System_Object"></a>
## <a name="systemobject"></a><span data-ttu-id="62fd2-106">System.Object</span><span class="sxs-lookup"><span data-stu-id="62fd2-106">System.Object</span></span>  
 <span data-ttu-id="62fd2-107">Primární wpf programovací model je vystaven prostřednictvím spravovaného kódu.</span><span class="sxs-lookup"><span data-stu-id="62fd2-107">The primary WPF programming model is exposed through managed code.</span></span> <span data-ttu-id="62fd2-108">V rané fázi návrhu WPF se diskutovalo o tom, kde by měla být čára mezi spravovanými součástmi systému a neřízenými součástmi.</span><span class="sxs-lookup"><span data-stu-id="62fd2-108">Early in the design phase of WPF there were a number of debates about where the line should be drawn between the managed components of the system and the unmanaged ones.</span></span> <span data-ttu-id="62fd2-109">CLR poskytuje řadu funkcí, které činí vývoj produktivnější a robustnější (včetně správy paměti, zpracování chyb, systému běžného typu atd.), ale jejich náklady.</span><span class="sxs-lookup"><span data-stu-id="62fd2-109">The CLR provides a number of features that make development more productive and robust (including memory management, error handling, common type system, etc.) but they come at a cost.</span></span>  
  
 <span data-ttu-id="62fd2-110">Hlavní složky WPF jsou znázorněny na obrázku níže.</span><span class="sxs-lookup"><span data-stu-id="62fd2-110">The major components of WPF are illustrated in the figure below.</span></span> <span data-ttu-id="62fd2-111">Červené části diagramu (PresentationFramework, PresentationCore a milcore) jsou hlavní části kódu WPF.</span><span class="sxs-lookup"><span data-stu-id="62fd2-111">The red sections of the diagram (PresentationFramework, PresentationCore, and milcore) are the major code portions of WPF.</span></span> <span data-ttu-id="62fd2-112">Z nich pouze jedna je neřízená součást - milcore.</span><span class="sxs-lookup"><span data-stu-id="62fd2-112">Of these, only one is an unmanaged component – milcore.</span></span> <span data-ttu-id="62fd2-113">Milcore je napsán v nespravovaném kódu, aby bylo možné úzce integrace s DirectX.</span><span class="sxs-lookup"><span data-stu-id="62fd2-113">Milcore is written in unmanaged code in order to enable tight integration with DirectX.</span></span> <span data-ttu-id="62fd2-114">Všechny displeje ve WPF se provádějí pomocí modulu DirectX, což umožňuje efektivní vykreslování hardwaru a softwaru.</span><span class="sxs-lookup"><span data-stu-id="62fd2-114">All display in WPF is done through the DirectX engine, allowing for efficient hardware and software rendering.</span></span> <span data-ttu-id="62fd2-115">WPF také vyžaduje jemnou kontrolu nad pamětí a spuštění.</span><span class="sxs-lookup"><span data-stu-id="62fd2-115">WPF also required fine control over memory and execution.</span></span> <span data-ttu-id="62fd2-116">Kompozice motoru v milcore je velmi citlivý na výkon, a vyžaduje vzdát se mnoha výhod CLR získat výkon.</span><span class="sxs-lookup"><span data-stu-id="62fd2-116">The composition engine in milcore is extremely performance sensitive, and required giving up many advantages of the CLR to gain performance.</span></span>  
  
 <span data-ttu-id="62fd2-117">![Pozice WPF v rámci .NET Framework.](./media/wpf-architect1.PNG "wpf_architect1")</span><span class="sxs-lookup"><span data-stu-id="62fd2-117">![The position of WPF within the .NET Framework.](./media/wpf-architect1.PNG "wpf_architect1")</span></span>  
  
 <span data-ttu-id="62fd2-118">Komunikace mezi spravované a nespravované části WPF je popsána dále v tomto tématu.</span><span class="sxs-lookup"><span data-stu-id="62fd2-118">Communication between the managed and unmanaged portions of WPF is discussed later in this topic.</span></span> <span data-ttu-id="62fd2-119">Zbývající část spravovaného programovacího modelu je popsána níže.</span><span class="sxs-lookup"><span data-stu-id="62fd2-119">The remainder of the managed programming model is described below.</span></span>  
  
<a name="System_Threading_DispatcherObject"></a>
## <a name="systemthreadingdispatcherobject"></a><span data-ttu-id="62fd2-120">System.Threading.DispatcherObject</span><span class="sxs-lookup"><span data-stu-id="62fd2-120">System.Threading.DispatcherObject</span></span>  
 <span data-ttu-id="62fd2-121">Většina objektů v <xref:System.Windows.Threading.DispatcherObject>WPF odvozuje od , který poskytuje základní konstrukce pro práci s souběžnosti a zřetězení.</span><span class="sxs-lookup"><span data-stu-id="62fd2-121">Most objects in WPF derive from <xref:System.Windows.Threading.DispatcherObject>, which provides the basic constructs for dealing with concurrency and threading.</span></span> <span data-ttu-id="62fd2-122">WPF je založen na systému zasílání zpráv implementovaném dispečerem.</span><span class="sxs-lookup"><span data-stu-id="62fd2-122">WPF is based on a messaging system implemented by the dispatcher.</span></span> <span data-ttu-id="62fd2-123">To funguje podobně jako známé Win32 zpráva čerpadlo; ve skutečnosti WPF dispečer používá User32 zprávy pro provádění volání mezi vlákny.</span><span class="sxs-lookup"><span data-stu-id="62fd2-123">This works much like the familiar Win32 message pump; in fact, the WPF dispatcher uses User32 messages for performing cross thread calls.</span></span>  
  
 <span data-ttu-id="62fd2-124">Existují opravdu dva základní koncepty pochopit při diskusi souběžnosti v WPF – dispečer a vlákno spřažení.</span><span class="sxs-lookup"><span data-stu-id="62fd2-124">There are really two core concepts to understand when discussing concurrency in WPF – the dispatcher and thread affinity.</span></span>  
  
 <span data-ttu-id="62fd2-125">Během fáze návrhu WPF bylo cílem přesunout se do jednoho vlákna provádění, ale model bez podprocesu "spřažené".</span><span class="sxs-lookup"><span data-stu-id="62fd2-125">During the design phase of WPF, the goal was to move to a single thread of execution, but a non-thread "affinitized" model.</span></span> <span data-ttu-id="62fd2-126">Spřažení vláken se stane, když komponenta používá identitu vykonávajícího vlákna k uložení určitého typu stavu.</span><span class="sxs-lookup"><span data-stu-id="62fd2-126">Thread affinity happens when a component uses the identity of the executing thread to store some type of state.</span></span> <span data-ttu-id="62fd2-127">Nejběžnější formou je použití místního úložiště vlákna (TLS) k uložení stavu.</span><span class="sxs-lookup"><span data-stu-id="62fd2-127">The most common form of this is to use the thread local store (TLS) to store state.</span></span> <span data-ttu-id="62fd2-128">Spřažení vláken vyžaduje, aby každé logické vlákno spuštění bylo vlastněno pouze jedním fyzickým vláknem v operačním systému, které může být náročné na paměť.</span><span class="sxs-lookup"><span data-stu-id="62fd2-128">Thread affinity requires that each logical thread of execution be owned by only one physical thread in the operating system, which can become memory intensive.</span></span> <span data-ttu-id="62fd2-129">Nakonec wpf model zřetězení byl udržován v synchronizaci s existující montovny User32 modelu s jedním podprocesem spuštění s spřažení vláken.</span><span class="sxs-lookup"><span data-stu-id="62fd2-129">In the end, WPF’s threading model was kept in sync with the existing User32 threading model of single threaded execution with thread affinity.</span></span> <span data-ttu-id="62fd2-130">Hlavním důvodem byla interoperabilita – systémy jako OLE 2.0, schránka a aplikace Internet Explorer vyžadují spuštění spřažení jednoho vlákna (STA).</span><span class="sxs-lookup"><span data-stu-id="62fd2-130">The primary reason for this was interoperability – systems like OLE 2.0, the clipboard, and Internet Explorer all require single thread affinity (STA) execution.</span></span>  
  
 <span data-ttu-id="62fd2-131">Vzhledem k tomu, že máte objekty s STA zřetězení, potřebujete způsob, jak komunikovat mezi vlákny a ověřit, že jste ve správném vlákně.</span><span class="sxs-lookup"><span data-stu-id="62fd2-131">Given that you have objects with STA threading, you need a way to communicate between threads, and validate that you are on the correct thread.</span></span> <span data-ttu-id="62fd2-132">V tom spočívá role dispečera.</span><span class="sxs-lookup"><span data-stu-id="62fd2-132">Herein lies the role of the dispatcher.</span></span> <span data-ttu-id="62fd2-133">Dispečer je základní systém dispečinku zpráv s více prioritními frontami.</span><span class="sxs-lookup"><span data-stu-id="62fd2-133">The dispatcher is a basic message dispatching system, with multiple prioritized queues.</span></span> <span data-ttu-id="62fd2-134">Příklady zpráv zahrnují nezpracovaná vstupní oznámení (přesunutí myši), rámcové funkce (rozložení) nebo uživatelské příkazy (spusťte tuto metodu).</span><span class="sxs-lookup"><span data-stu-id="62fd2-134">Examples of messages include raw input notifications (mouse moved), framework functions (layout), or user commands (execute this method).</span></span> <span data-ttu-id="62fd2-135">Odvozením z <xref:System.Windows.Threading.DispatcherObject>, vytvoříte objekt CLR, který má chování STA a bude mít ukazatel na dispečera v době vytvoření.</span><span class="sxs-lookup"><span data-stu-id="62fd2-135">By deriving from <xref:System.Windows.Threading.DispatcherObject>, you create a CLR object that has STA behavior, and will be given a pointer to a dispatcher at creation time.</span></span>  
  
<a name="System_Windows_DependencyObject"></a>
## <a name="systemwindowsdependencyobject"></a><span data-ttu-id="62fd2-136">System.Windows.DependencyObject</span><span class="sxs-lookup"><span data-stu-id="62fd2-136">System.Windows.DependencyObject</span></span>  
 <span data-ttu-id="62fd2-137">Jednou z primárních architektonických filozofií používaných při vytváření WPF bylo upřednostňování vlastností před metodami nebo událostmi.</span><span class="sxs-lookup"><span data-stu-id="62fd2-137">One of the primary architectural philosophies used in building WPF was a preference for properties over methods or events.</span></span> <span data-ttu-id="62fd2-138">Vlastnosti jsou deklarativní a umožňují snadněji určit záměr namísto akce.</span><span class="sxs-lookup"><span data-stu-id="62fd2-138">Properties are declarative and allow you to more easily specify intent instead of action.</span></span> <span data-ttu-id="62fd2-139">To také podporovalo modelřízený nebo řízený data, systém pro zobrazení obsahu uživatelského rozhraní.</span><span class="sxs-lookup"><span data-stu-id="62fd2-139">This also supported a model driven, or data driven, system for displaying user interface content.</span></span> <span data-ttu-id="62fd2-140">Tato filozofie měla zamýšlený účinek vytváření více vlastností, které můžete vázat, aby bylo možné lépe řídit chování aplikace.</span><span class="sxs-lookup"><span data-stu-id="62fd2-140">This philosophy had the intended effect of creating more properties that you could bind to, in order to better control the behavior of an application.</span></span>  
  
 <span data-ttu-id="62fd2-141">Aby bylo možné mít více systému řízenévlastnosti, bohatší vlastnost systému, než co poskytuje CLR bylo zapotřebí.</span><span class="sxs-lookup"><span data-stu-id="62fd2-141">In order to have more of the system driven by properties, a richer property system than what the CLR provides was needed.</span></span> <span data-ttu-id="62fd2-142">Jednoduchým příkladem tohoto bohatství je změna oznámení.</span><span class="sxs-lookup"><span data-stu-id="62fd2-142">A simple example of this richness is change notifications.</span></span> <span data-ttu-id="62fd2-143">Chcete-li povolit obousměrnou vazbu, potřebujete obě strany vazby pro podporu oznámení o změně.</span><span class="sxs-lookup"><span data-stu-id="62fd2-143">In order to enable two way binding, you need both sides of the bind to support change notification.</span></span> <span data-ttu-id="62fd2-144">Chcete-li mít chování vázané na hodnoty vlastností, musíte být upozorněni, když se změní hodnota vlastnosti.</span><span class="sxs-lookup"><span data-stu-id="62fd2-144">In order to have behavior tied to property values, you need to be notified when the property value changes.</span></span> <span data-ttu-id="62fd2-145">Rozhraní Microsoft .NET Framework má rozhraní **INotifyPropertyChange**, které umožňuje objektu publikovat oznámení o změnách, ale je volitelné.</span><span class="sxs-lookup"><span data-stu-id="62fd2-145">The Microsoft .NET Framework has an interface, **INotifyPropertyChange**, which allows an object to publish change notifications, however it is optional.</span></span>  
  
 <span data-ttu-id="62fd2-146">WPF poskytuje bohatší vlastnostsystém, odvozený od <xref:System.Windows.DependencyObject> typu.</span><span class="sxs-lookup"><span data-stu-id="62fd2-146">WPF provides a richer property system, derived from the <xref:System.Windows.DependencyObject> type.</span></span> <span data-ttu-id="62fd2-147">Systém vlastností je skutečně systém vlastností "závislostí" v tom, že sleduje závislosti mezi výrazy vlastností a automaticky znovu ověří hodnoty vlastností při změně závislostí.</span><span class="sxs-lookup"><span data-stu-id="62fd2-147">The property system is truly a "dependency" property system in that it tracks dependencies between property expressions and automatically revalidates property values when dependencies change.</span></span> <span data-ttu-id="62fd2-148">Například pokud máte vlastnost, která dědí (jako <xref:System.Windows.Controls.Control.FontSize%2A>) systém se automaticky aktualizuje, pokud se změní vlastnost na nadřazený prvek, který dědí hodnotu.</span><span class="sxs-lookup"><span data-stu-id="62fd2-148">For example, if you have a property that inherits (like <xref:System.Windows.Controls.Control.FontSize%2A>), the system is automatically updated if the property changes on a parent of an element that inherits the value.</span></span>  
  
 <span data-ttu-id="62fd2-149">Základem systému vlastností WPF je koncept výrazu vlastnosti.</span><span class="sxs-lookup"><span data-stu-id="62fd2-149">The foundation of the WPF property system is the concept of a property expression.</span></span> <span data-ttu-id="62fd2-150">V této první verzi WPF je uzavřen systém výrazu vlastností a všechny výrazy jsou k dispozici jako součást rámce.</span><span class="sxs-lookup"><span data-stu-id="62fd2-150">In this first release of WPF, the property expression system is closed, and the expressions are all provided as part of the framework.</span></span> <span data-ttu-id="62fd2-151">Výrazy jsou důvod, proč systém vlastností nemá pevně zakódované datové vazby, styly nebo dědičnost, ale spíše je poskytuje novější vrstvy v rámci.</span><span class="sxs-lookup"><span data-stu-id="62fd2-151">Expressions are why the property system doesn’t have data binding, styling, or inheritance hard coded, but rather provided by later layers within the framework.</span></span>  
  
 <span data-ttu-id="62fd2-152">Systém vlastností také zajišťuje řídké ukládání hodnot vlastností.</span><span class="sxs-lookup"><span data-stu-id="62fd2-152">The property system also provides for sparse storage of property values.</span></span> <span data-ttu-id="62fd2-153">Vzhledem k tomu, že objekty mohou mít desítky (ne-li stovky) vlastností a většina hodnot je ve výchozím stavu (zděděné, nastavené styly atd.), nemusí mít každá instance objektu plnou váhu každé vlastnosti definované na něm.</span><span class="sxs-lookup"><span data-stu-id="62fd2-153">Because objects can have dozens (if not hundreds) of properties, and most of the values are in their default state (inherited, set by styles, etc.), not every instance of an object needs to have the full weight of every property defined on it.</span></span>  
  
 <span data-ttu-id="62fd2-154">Poslední novinkou systému vlastností je pojem připojených vlastností.</span><span class="sxs-lookup"><span data-stu-id="62fd2-154">The final new feature of the property system is the notion of attached properties.</span></span> <span data-ttu-id="62fd2-155">WPF prvky jsou postaveny na principu složení a opětovné použití komponent.</span><span class="sxs-lookup"><span data-stu-id="62fd2-155">WPF elements are built on the principle of composition and component reuse.</span></span> <span data-ttu-id="62fd2-156">Často se stává, že některé obsahující <xref:System.Windows.Controls.Grid> prvek (jako prvek rozložení) potřebuje další data na podřízené prvky řídit jeho chování (jako řádek/ sloupec informace).</span><span class="sxs-lookup"><span data-stu-id="62fd2-156">It is often the case that some containing element (like a <xref:System.Windows.Controls.Grid> layout element) needs additional data on child elements to control its behavior (like the Row/Column information).</span></span> <span data-ttu-id="62fd2-157">Namísto připojování všech těchto vlastností s každým elementem je každému objektu povoleno poskytovat definice vlastností pro jakýkoli jiný objekt.</span><span class="sxs-lookup"><span data-stu-id="62fd2-157">Instead of associating all of these properties with every element, any object is allowed to provide property definitions for any other object.</span></span> <span data-ttu-id="62fd2-158">To je podobné "expando" funkce JavaScriptu.</span><span class="sxs-lookup"><span data-stu-id="62fd2-158">This is similar to the "expando" features of JavaScript.</span></span>  
  
<a name="System_Windows_Media_Visual"></a>
## <a name="systemwindowsmediavisual"></a><span data-ttu-id="62fd2-159">System.Windows.Media.Visual</span><span class="sxs-lookup"><span data-stu-id="62fd2-159">System.Windows.Media.Visual</span></span>  
 <span data-ttu-id="62fd2-160">S definovaným systémem je dalším krokem získání pixelů nakreslených na obrazovku.</span><span class="sxs-lookup"><span data-stu-id="62fd2-160">With a system defined, the next step is getting pixels drawn to the screen.</span></span> <span data-ttu-id="62fd2-161">Třída <xref:System.Windows.Media.Visual> poskytuje vytváření stromu vizuálních objektů, z nichž každý volitelně obsahuje pokyny k výkresu a metadata o tom, jak tyto pokyny (oříznutí, transformace atd.).</span><span class="sxs-lookup"><span data-stu-id="62fd2-161">The <xref:System.Windows.Media.Visual> class provides for building a tree of visual objects, each optionally containing drawing instructions and metadata about how to render those instructions (clipping, transformation, etc.).</span></span> <span data-ttu-id="62fd2-162"><xref:System.Windows.Media.Visual>je navržen tak, aby byl extrémně lehký a flexibilní, takže většina funkcí nemá žádnou public API a silně se spoléhá na chráněné funkce zpětného volání.</span><span class="sxs-lookup"><span data-stu-id="62fd2-162"><xref:System.Windows.Media.Visual> is designed to be extremely lightweight and flexible, so most of the features have no public API exposure and rely heavily on protected callback functions.</span></span>  
  
 <span data-ttu-id="62fd2-163"><xref:System.Windows.Media.Visual>je skutečně vstupním bodem do systému složení WPF.</span><span class="sxs-lookup"><span data-stu-id="62fd2-163"><xref:System.Windows.Media.Visual> is really the entry point to the WPF composition system.</span></span> <span data-ttu-id="62fd2-164"><xref:System.Windows.Media.Visual>je bod připojení mezi těmito dvěma subsystémy, spravované rozhraní API a nespravované milcore.</span><span class="sxs-lookup"><span data-stu-id="62fd2-164"><xref:System.Windows.Media.Visual> is the point of connection between these two subsystems, the managed API and the unmanaged milcore.</span></span>  
  
 <span data-ttu-id="62fd2-165">WPF zobrazuje data procházením nespravovaných datových struktur spravovaných milcore.</span><span class="sxs-lookup"><span data-stu-id="62fd2-165">WPF displays data by traversing the unmanaged data structures managed by the milcore.</span></span> <span data-ttu-id="62fd2-166">Tyto struktury, nazývané uzly kompozice, představují hierarchický strom zobrazení s pokyny k vykreslování v každém uzlu.</span><span class="sxs-lookup"><span data-stu-id="62fd2-166">These structures, called composition nodes, represent a hierarchical display tree with rendering instructions at each node.</span></span> <span data-ttu-id="62fd2-167">Tento strom, ilustrovaný na pravé straně obrázku níže, je přístupný pouze prostřednictvím protokolu zasílání zpráv.</span><span class="sxs-lookup"><span data-stu-id="62fd2-167">This tree, illustrated on the right hand side of the figure below, is only accessible through a messaging protocol.</span></span>  
  
 <span data-ttu-id="62fd2-168">Při programování WPF <xref:System.Windows.Media.Visual> vytvoříte prvky a odvozené typy, které interně komunikují se stromem kompozice prostřednictvím tohoto protokolu zasílání zpráv.</span><span class="sxs-lookup"><span data-stu-id="62fd2-168">When programming WPF, you create <xref:System.Windows.Media.Visual> elements, and derived types, which internally communicate to the composition tree through this messaging protocol.</span></span> <span data-ttu-id="62fd2-169">Každý <xref:System.Windows.Media.Visual> v WPF může vytvořit jeden, žádný nebo několik uzlů složení.</span><span class="sxs-lookup"><span data-stu-id="62fd2-169">Each <xref:System.Windows.Media.Visual> in WPF may create one, none, or several composition nodes.</span></span>  
  
 <span data-ttu-id="62fd2-170">![Vizuální strom Windows Presentation Foundation.](./media/wpf-architecture2.PNG "wpf_architecture2")</span><span class="sxs-lookup"><span data-stu-id="62fd2-170">![The Windows Presentation Foundation Visual Tree.](./media/wpf-architecture2.PNG "wpf_architecture2")</span></span>  
  
 <span data-ttu-id="62fd2-171">Tam je velmi důležitý architektonický detail si všimnout zde - celý strom vizuálů a kreslení pokyny je uložen do mezipaměti.</span><span class="sxs-lookup"><span data-stu-id="62fd2-171">There is a very important architectural detail to notice here – the entire tree of visuals and drawing instructions is cached.</span></span> <span data-ttu-id="62fd2-172">Z grafického hlediska WPF používá zachovaný vykreslovací systém.</span><span class="sxs-lookup"><span data-stu-id="62fd2-172">In graphics terms, WPF uses a retained rendering system.</span></span> <span data-ttu-id="62fd2-173">To umožňuje systému překreslit při vysokých obnovovacích frekvencích bez blokování kompozičního systému na zpětná volání uživatelského kódu.</span><span class="sxs-lookup"><span data-stu-id="62fd2-173">This enables the system to repaint at high refresh rates without the composition system blocking on callbacks to user code.</span></span> <span data-ttu-id="62fd2-174">To pomáhá zabránit výskytu nereagující aplikace.</span><span class="sxs-lookup"><span data-stu-id="62fd2-174">This helps prevent the appearance of an unresponsive application.</span></span>  
  
 <span data-ttu-id="62fd2-175">Dalším důležitým detailem, který není v diagramu skutečně patrný, je, jak systém skutečně provádí složení.</span><span class="sxs-lookup"><span data-stu-id="62fd2-175">Another important detail that isn’t really noticeable in the diagram is how the system actually performs composition.</span></span>  
  
 <span data-ttu-id="62fd2-176">V User32 a GDI, systém pracuje na okamžitém režimu ořezávací systém.</span><span class="sxs-lookup"><span data-stu-id="62fd2-176">In User32 and GDI, the system works on an immediate mode clipping system.</span></span> <span data-ttu-id="62fd2-177">Když je potřeba komponentu vykreslit, systém vytvoří hranice oříznutí, mimo které se součást nesmí dotýkat obrazových bodů, a pak je komponenta vyzvána k malování obrazových bodů v tomto poli.</span><span class="sxs-lookup"><span data-stu-id="62fd2-177">When a component needs to be rendered, the system establishes a clipping bounds outside of which the component isn’t allowed to touch the pixels, and then the component is asked to paint pixels in that box.</span></span> <span data-ttu-id="62fd2-178">Tento systém funguje velmi dobře v paměťových omezených systémech, protože když se něco změní, stačí se dotknout postižené součásti - žádné dvě součásti nikdy nepřispívají k barvě jednoho pixelu.</span><span class="sxs-lookup"><span data-stu-id="62fd2-178">This system works very well in memory constrained systems because when something changes you only have to touch the affected component – no two components ever contribute to the color of a single pixel.</span></span>  
  
 <span data-ttu-id="62fd2-179">WPF používá model malby "malířův algoritmus".</span><span class="sxs-lookup"><span data-stu-id="62fd2-179">WPF uses a "painter's algorithm" painting model.</span></span> <span data-ttu-id="62fd2-180">To znamená, že místo oříznutí každé součásti je každá komponenta vyzvána k vykreslení ze zadní strany na přední stranu displeje.</span><span class="sxs-lookup"><span data-stu-id="62fd2-180">This means that instead of clipping each component, each component is asked to render from the back to the front of the display.</span></span> <span data-ttu-id="62fd2-181">To umožňuje, aby každá komponenta přemalovala zobrazení předchozí součásti.</span><span class="sxs-lookup"><span data-stu-id="62fd2-181">This allows each component to paint over the previous component's display.</span></span> <span data-ttu-id="62fd2-182">Výhodou tohoto modelu je, že můžete mít složité, částečně průhledné tvary.</span><span class="sxs-lookup"><span data-stu-id="62fd2-182">The advantage of this model is that you can have complex, partially transparent shapes.</span></span> <span data-ttu-id="62fd2-183">S dnešním moderním grafickým hardwarem je tento model poměrně rychlý (což nebyl případ, kdy byly vytvořeny User32 / GDI).</span><span class="sxs-lookup"><span data-stu-id="62fd2-183">With today’s modern graphics hardware, this model is relatively fast (which wasn’t the case when User32/ GDI were created).</span></span>  
  
 <span data-ttu-id="62fd2-184">Jak již bylo zmíněno dříve, základní filozofií WPF je přejít na více deklarativní, "vlastnosti" model programování.</span><span class="sxs-lookup"><span data-stu-id="62fd2-184">As mentioned previously, a core philosophy of WPF is to move to a more declarative, "property centric" model of programming.</span></span> <span data-ttu-id="62fd2-185">Ve vizuálním systému se to objeví na několika zajímavých místech.</span><span class="sxs-lookup"><span data-stu-id="62fd2-185">In the visual system, this shows up in a couple of interesting places.</span></span>  
  
 <span data-ttu-id="62fd2-186">Za prvé, pokud si myslíte o zachovaném režimu grafického systému, je to opravdu odklon od imperativní DrawLine / DrawLine typ modelu, na data orientovaný model - nový Line()/new Line().</span><span class="sxs-lookup"><span data-stu-id="62fd2-186">First, if you think about the retained mode graphic system, this is really moving away from an imperative DrawLine/DrawLine type model, to a data oriented model – new Line()/new Line().</span></span> <span data-ttu-id="62fd2-187">Tento přechod na vykreslování řízené daty umožňuje vyjádřit složité operace v pokynech k výkresu pomocí vlastností.</span><span class="sxs-lookup"><span data-stu-id="62fd2-187">This move to data driven rendering allows complex operations on the drawing instructions to be expressed using properties.</span></span> <span data-ttu-id="62fd2-188">Typy odvozené z <xref:System.Windows.Media.Drawing> jsou účinně objektový model pro vykreslování.</span><span class="sxs-lookup"><span data-stu-id="62fd2-188">The types deriving from <xref:System.Windows.Media.Drawing> are effectively the object model for rendering.</span></span>  
  
 <span data-ttu-id="62fd2-189">Za druhé, pokud vyhodnotíte animační systém, uvidíte, že je téměř zcela deklarativní.</span><span class="sxs-lookup"><span data-stu-id="62fd2-189">Second, if you evaluate the animation system, you'll see that it is almost completely declarative.</span></span> <span data-ttu-id="62fd2-190">Namísto vyžadování vývojáře vypočítat další umístění nebo další barvu, můžete vyjádřit animace jako sadu vlastností na objekt animace.</span><span class="sxs-lookup"><span data-stu-id="62fd2-190">Instead of requiring a developer to compute the next location, or next color, you can express animations as a set of properties on an animation object.</span></span> <span data-ttu-id="62fd2-191">Tyto animace pak můžete vyjádřit záměr vývojáře nebo návrháře (přesunout toto tlačítko odtud tam za 5 sekund) a systém může určit nejúčinnější způsob, jak toho dosáhnout.</span><span class="sxs-lookup"><span data-stu-id="62fd2-191">These animations can then express the intent of the developer or designer (move this button from here to there in 5 seconds), and the system can determine the most efficient way to accomplish that.</span></span>  
  
<a name="System_Windows_UIElement"></a>
## <a name="systemwindowsuielement"></a><span data-ttu-id="62fd2-192">System.Windows.UIElement</span><span class="sxs-lookup"><span data-stu-id="62fd2-192">System.Windows.UIElement</span></span>  
 <span data-ttu-id="62fd2-193"><xref:System.Windows.UIElement>definuje základní subsystémy včetně rozložení, vstupu a událostí.</span><span class="sxs-lookup"><span data-stu-id="62fd2-193"><xref:System.Windows.UIElement> defines core subsystems including Layout, Input, and Events.</span></span>  
  
 <span data-ttu-id="62fd2-194">Layout je základní koncept wpf.</span><span class="sxs-lookup"><span data-stu-id="62fd2-194">Layout is a core concept in WPF.</span></span> <span data-ttu-id="62fd2-195">V mnoha systémech je buď pevná sada modelů rozložení (HTML podporuje tři modely pro rozvržení; tok, absolutní a tabulky) nebo žádný model pro rozvržení (Uživatel32 opravdu podporuje pouze absolutní umístění).</span><span class="sxs-lookup"><span data-stu-id="62fd2-195">In many systems there is either a fixed set of layout models (HTML supports three models for layout; flow, absolute, and tables) or no model for layout (User32 really only supports absolute positioning).</span></span> <span data-ttu-id="62fd2-196">WPF začal s předpokladem, že vývojáři a návrháři chtěli flexibilní, rozšiřitelný model rozložení, který by mohl být řízen hodnotami vlastností spíše než imperativní logikou.</span><span class="sxs-lookup"><span data-stu-id="62fd2-196">WPF started with the assumption that developers and designers wanted a flexible, extensible layout model, which could be driven by property values rather than imperative logic.</span></span> <span data-ttu-id="62fd2-197">Na <xref:System.Windows.UIElement> úrovni je zavedena základní smlouva o rozvržení <xref:System.Windows.UIElement.Measure%2A> <xref:System.Windows.UIElement.Arrange%2A> – dvoufázový model s a projde.</span><span class="sxs-lookup"><span data-stu-id="62fd2-197">At the <xref:System.Windows.UIElement> level, the basic contract for layout is introduced – a two phase model with <xref:System.Windows.UIElement.Measure%2A> and <xref:System.Windows.UIElement.Arrange%2A> passes.</span></span>  
  
 <span data-ttu-id="62fd2-198"><xref:System.Windows.UIElement.Measure%2A>umožňuje komponentě určit, jakou velikost by chtěla mít.</span><span class="sxs-lookup"><span data-stu-id="62fd2-198"><xref:System.Windows.UIElement.Measure%2A> allows a component to determine how much size it would like to take.</span></span> <span data-ttu-id="62fd2-199">Toto je samostatná fáze od, <xref:System.Windows.UIElement.Arrange%2A> protože existuje mnoho situací, kdy nadřazený prvek požádá dítě, aby několikrát změřilo, aby určilo jeho optimální polohu a velikost.</span><span class="sxs-lookup"><span data-stu-id="62fd2-199">This is a separate phase from <xref:System.Windows.UIElement.Arrange%2A> because there are many situations where a parent element will ask a child to measure several times to determine its optimal position and size.</span></span> <span data-ttu-id="62fd2-200">Skutečnost, že nadřazené prvky požádat podřízené prvky k měření demonstruje další klíčovou filozofii WPF – velikost obsahu.</span><span class="sxs-lookup"><span data-stu-id="62fd2-200">The fact that parent elements ask child elements to measure demonstrates another key philosophy of WPF – size to content.</span></span> <span data-ttu-id="62fd2-201">Všechny ovládací prvky v WPF podporují možnost velikosti na přirozenou velikost jejich obsahu.</span><span class="sxs-lookup"><span data-stu-id="62fd2-201">All controls in WPF support the ability to size to the natural size of their content.</span></span> <span data-ttu-id="62fd2-202">To usnadňuje lokalizaci a umožňuje dynamické rozložení prvků při změně velikosti.</span><span class="sxs-lookup"><span data-stu-id="62fd2-202">This makes localization much easier, and allows for dynamic layout of elements as things resize.</span></span> <span data-ttu-id="62fd2-203">Fáze <xref:System.Windows.UIElement.Arrange%2A> umožňuje rodiči umístit a určit konečnou velikost každého dítěte.</span><span class="sxs-lookup"><span data-stu-id="62fd2-203">The <xref:System.Windows.UIElement.Arrange%2A> phase allows a parent to position and determine the final size of each child.</span></span>  
  
 <span data-ttu-id="62fd2-204">Mnoho času je často strávil mluvit o výstupní <xref:System.Windows.Media.Visual> straně WPF - a související objekty.</span><span class="sxs-lookup"><span data-stu-id="62fd2-204">A lot of time is often spent talking about the output side of WPF – <xref:System.Windows.Media.Visual> and related objects.</span></span> <span data-ttu-id="62fd2-205">Nicméně tam je obrovské množství inovací na vstupní straně stejně.</span><span class="sxs-lookup"><span data-stu-id="62fd2-205">However there is a tremendous amount of innovation on the input side as well.</span></span> <span data-ttu-id="62fd2-206">Pravděpodobně nejzásadnější změnou vstupního modelu pro WPF je konzistentní model, podle kterého jsou vstupní události směrovány systémem.</span><span class="sxs-lookup"><span data-stu-id="62fd2-206">Probably the most fundamental change in the input model for WPF is the consistent model by which input events are routed through the system.</span></span>  
  
 <span data-ttu-id="62fd2-207">Vstup pochází jako signál na ovladači zařízení režimu jádra a dostane směrovány do správného procesu a vlákna prostřednictvím složitého procesu zahrnující jádro systému Windows a User32.</span><span class="sxs-lookup"><span data-stu-id="62fd2-207">Input originates as a signal on a kernel mode device driver and gets routed to the correct process and thread through an intricate process involving the Windows kernel and User32.</span></span> <span data-ttu-id="62fd2-208">Jakmile user32 zpráva odpovídající vstupu je směrována na WPF, je převeden na WPF nezpracované vstupní zprávy a odeslány dispečer.</span><span class="sxs-lookup"><span data-stu-id="62fd2-208">Once the User32 message corresponding to the input is routed to WPF, it is converted into a WPF raw input message and sent to the dispatcher.</span></span> <span data-ttu-id="62fd2-209">WPF umožňuje nezpracované vstupní události, které mají být převedeny na více skutečných událostí, povolení funkce jako "MouseEnter" mají být implementovány na nízké úrovni systému se zaručeným doručením.</span><span class="sxs-lookup"><span data-stu-id="62fd2-209">WPF allows for raw input events to be converted to multiple actual events, enabling features like "MouseEnter" to be implemented at a low level of the system with guaranteed delivery.</span></span>  
  
 <span data-ttu-id="62fd2-210">Každá vstupní událost je převedena alespoň na dvě události – událost "náhled" a skutečná událost.</span><span class="sxs-lookup"><span data-stu-id="62fd2-210">Each input event is converted to at least two events – a "preview" event and the actual event.</span></span> <span data-ttu-id="62fd2-211">Všechny události v WPF mají pojem směrování prostřednictvím stromu elementu.</span><span class="sxs-lookup"><span data-stu-id="62fd2-211">All events in WPF have a notion of routing through the element tree.</span></span> <span data-ttu-id="62fd2-212">Události jsou řekl, aby "bublina", pokud se procházet z cíle do stromu ke kořeni, a jsou řekl, aby "tunel", pokud začínají na kořen a přejít dolů k cíli.</span><span class="sxs-lookup"><span data-stu-id="62fd2-212">Events are said to "bubble" if they traverse from a target up the tree to the root, and are said to "tunnel" if they start at the root and traverse down to a target.</span></span> <span data-ttu-id="62fd2-213">Vstupní náhled událostí tunelového propojení, povolení libovolný prvek ve stromu příležitost filtrovat nebo provést akci na události.</span><span class="sxs-lookup"><span data-stu-id="62fd2-213">Input preview events tunnel, enabling any element in the tree an opportunity to filter or take action on the event.</span></span> <span data-ttu-id="62fd2-214">Pravidelné (non-preview) události pak bublina od cíle až do kořene.</span><span class="sxs-lookup"><span data-stu-id="62fd2-214">The regular (non-preview) events then bubble from the target up to the root.</span></span>  
  
 <span data-ttu-id="62fd2-215">Toto rozdělení mezi tunelovou a bublinovou fázi umožňuje, aby implementace funkcí, jako jsou akcelerátory klávesnice, fungovala konzistentním způsobem ve složeném světě.</span><span class="sxs-lookup"><span data-stu-id="62fd2-215">This split between the tunnel and bubble phase makes implementation of features like keyboard accelerators work in a consistent fashion in a composite world.</span></span> <span data-ttu-id="62fd2-216">V User32 byste implementovat akcelerátory klávesnice tím, že má jednu globální tabulku obsahující všechny akcelerátory, které chcete podporovat (Ctrl+ N mapování na "Nový").</span><span class="sxs-lookup"><span data-stu-id="62fd2-216">In User32 you would implement keyboard accelerators by having a single global table containing all the accelerators you wanted to support (Ctrl+N mapping to "New").</span></span> <span data-ttu-id="62fd2-217">V dispečer pro vaši aplikaci byste volat **TranslateAccelerator,** který by sniff vstupní zprávy v User32 a zjistit, zda všechny uzavřeno registrovaný akcelerátor.</span><span class="sxs-lookup"><span data-stu-id="62fd2-217">In the dispatcher for your application you would call **TranslateAccelerator** which would sniff the input messages in User32 and determine if any matched a registered accelerator.</span></span> <span data-ttu-id="62fd2-218">V WPF by to nefungovalo, protože systém je plně "kompozitelný" - každý prvek zvládne a používá jakýkoli klávesový akcelerátor.</span><span class="sxs-lookup"><span data-stu-id="62fd2-218">In WPF this wouldn’t work because the system is fully "composable" – any element can handle and use any keyboard accelerator.</span></span> <span data-ttu-id="62fd2-219">S tímto dvoufázový model pro vstup umožňuje komponenty implementovat vlastní "TranslateAccelerator".</span><span class="sxs-lookup"><span data-stu-id="62fd2-219">Having this two phase model for input allows components to implement their own "TranslateAccelerator".</span></span>  
  
 <span data-ttu-id="62fd2-220">Chcete-li tento krok <xref:System.Windows.UIElement> dále, také zavádí pojem CommandBindings.</span><span class="sxs-lookup"><span data-stu-id="62fd2-220">To take this one step further, <xref:System.Windows.UIElement> also introduces the notion of CommandBindings.</span></span> <span data-ttu-id="62fd2-221">Příkazový systém WPF umožňuje vývojářům definovat funkce z hlediska koncového <xref:System.Windows.Input.ICommand>bodu příkazu – něco, co implementuje .</span><span class="sxs-lookup"><span data-stu-id="62fd2-221">The WPF command system allows developers to define functionality in terms of a command end point – something that implements <xref:System.Windows.Input.ICommand>.</span></span> <span data-ttu-id="62fd2-222">Vazby příkazů umožňují elementu definovat mapování mezi vstupním gestem (Ctrl+N) a příkazem (Nový).</span><span class="sxs-lookup"><span data-stu-id="62fd2-222">Command bindings enable an element to define a mapping between an input gesture (Ctrl+N) and a command (New).</span></span> <span data-ttu-id="62fd2-223">Vstupní gesta a definice příkazů jsou rozšiřitelné a mohou být propojeny v době použití.</span><span class="sxs-lookup"><span data-stu-id="62fd2-223">Both the input gestures and command definitions are extensible, and can be wired together at usage time.</span></span> <span data-ttu-id="62fd2-224">Díky tomu je triviální, například umožnit koncovému uživateli přizpůsobit vazby klíčů, které chtějí použít v rámci aplikace.</span><span class="sxs-lookup"><span data-stu-id="62fd2-224">This makes it trivial, for example, to allow an end user to customize the key bindings that they want to use within an application.</span></span>  
  
 <span data-ttu-id="62fd2-225">K tomuto bodu v tématu, "jádro" funkce WPF – funkce implementované v sestavení PresentationCore, byly zaměření.</span><span class="sxs-lookup"><span data-stu-id="62fd2-225">To this point in the topic, "core" features of WPF – features implemented in the PresentationCore assembly, have been the focus.</span></span> <span data-ttu-id="62fd2-226">Při vytváření WPF, čisté oddělení mezi základní kusy (jako je smlouva o rozvržení s opatření <xref:System.Windows.Controls.Grid> **a** **uspořádat)** a rámcové kusy (jako je implementace konkrétního rozložení, jako je) byl požadovaný výsledek.</span><span class="sxs-lookup"><span data-stu-id="62fd2-226">When building WPF, a clean separation between foundational pieces (like the contract for layout with **Measure** and **Arrange**) and framework pieces (like the implementation of a specific layout like <xref:System.Windows.Controls.Grid>) was the desired outcome.</span></span> <span data-ttu-id="62fd2-227">Cílem bylo poskytnout bod rozšiřitelnosti nízko v zásobníku, který by umožnil externím vývojářům v případě potřeby vytvořit vlastní architektury.</span><span class="sxs-lookup"><span data-stu-id="62fd2-227">The goal was to provide an extensibility point low in the stack that would allow external developers to create their own frameworks if needed.</span></span>  
  
<a name="System_Windows_FrameworkElement"></a>
## <a name="systemwindowsframeworkelement"></a><span data-ttu-id="62fd2-228">System.Windows.FrameworkElement</span><span class="sxs-lookup"><span data-stu-id="62fd2-228">System.Windows.FrameworkElement</span></span>  
 <span data-ttu-id="62fd2-229"><xref:System.Windows.FrameworkElement>lze na ně pohlížet dvěma různými způsoby.</span><span class="sxs-lookup"><span data-stu-id="62fd2-229"><xref:System.Windows.FrameworkElement> can be looked at in two different ways.</span></span> <span data-ttu-id="62fd2-230">Zavádí sadu zásad a přizpůsobení v subsystémech zavedených v nižších vrstvách WPF.</span><span class="sxs-lookup"><span data-stu-id="62fd2-230">It introduces a set of policies and customizations on the subsystems introduced in lower layers of WPF.</span></span> <span data-ttu-id="62fd2-231">Zavádí také sadu nových subsystémů.</span><span class="sxs-lookup"><span data-stu-id="62fd2-231">It also introduces a set of new subsystems.</span></span>  
  
 <span data-ttu-id="62fd2-232">Primární zásady <xref:System.Windows.FrameworkElement> zavedené je kolem rozložení aplikace.</span><span class="sxs-lookup"><span data-stu-id="62fd2-232">The primary policy introduced by <xref:System.Windows.FrameworkElement> is around application layout.</span></span> <span data-ttu-id="62fd2-233"><xref:System.Windows.FrameworkElement>navazuje na základní layout smlouvy <xref:System.Windows.UIElement> zavedené a přidává pojem rozložení "slot", který usnadňuje pro autory rozložení mít konzistentní sadu vlastnosti řízené rozložení sémantiku.</span><span class="sxs-lookup"><span data-stu-id="62fd2-233"><xref:System.Windows.FrameworkElement> builds on the basic layout contract introduced by <xref:System.Windows.UIElement> and adds the notion of a layout "slot" that makes it easier for layout authors to have a consistent set of property driven layout semantics.</span></span> <span data-ttu-id="62fd2-234">Vlastnosti <xref:System.Windows.FrameworkElement.HorizontalAlignment%2A> <xref:System.Windows.FrameworkElement.VerticalAlignment%2A>jako <xref:System.Windows.FrameworkElement.MinWidth%2A>, <xref:System.Windows.FrameworkElement.Margin%2A> , a (abychom jmenovali několik) poskytují všechny součásti odvozené z <xref:System.Windows.FrameworkElement> konzistentního chování uvnitř kontejnerů rozložení.</span><span class="sxs-lookup"><span data-stu-id="62fd2-234">Properties like <xref:System.Windows.FrameworkElement.HorizontalAlignment%2A>, <xref:System.Windows.FrameworkElement.VerticalAlignment%2A>, <xref:System.Windows.FrameworkElement.MinWidth%2A>, and <xref:System.Windows.FrameworkElement.Margin%2A> (to name a few) give all components derived from <xref:System.Windows.FrameworkElement> consistent behavior inside of layout containers.</span></span>  
  
 <span data-ttu-id="62fd2-235"><xref:System.Windows.FrameworkElement>také poskytuje snadnější api expozice mnoha funkcí matné vrstvy WPF.</span><span class="sxs-lookup"><span data-stu-id="62fd2-235"><xref:System.Windows.FrameworkElement> also provides easier API exposure to many features found in the core layers of WPF.</span></span> <span data-ttu-id="62fd2-236">Například <xref:System.Windows.FrameworkElement> poskytuje přímý přístup k <xref:System.Windows.FrameworkElement.BeginStoryboard%2A> animaci prostřednictvím metody.</span><span class="sxs-lookup"><span data-stu-id="62fd2-236">For example, <xref:System.Windows.FrameworkElement> provides direct access to animation through the <xref:System.Windows.FrameworkElement.BeginStoryboard%2A> method.</span></span> <span data-ttu-id="62fd2-237">A <xref:System.Windows.Media.Animation.Storyboard> poskytuje způsob, jak skript více animací proti sadu vlastností.</span><span class="sxs-lookup"><span data-stu-id="62fd2-237">A <xref:System.Windows.Media.Animation.Storyboard> provides a way to script multiple animations against a set of properties.</span></span>  
  
 <span data-ttu-id="62fd2-238">Dvě nejdůležitější věci, <xref:System.Windows.FrameworkElement> které zavádí jsou datové vazby a styly.</span><span class="sxs-lookup"><span data-stu-id="62fd2-238">The two most critical things that <xref:System.Windows.FrameworkElement> introduces are data binding and styles.</span></span>  
  
 <span data-ttu-id="62fd2-239">Podsystém datové vazby ve WPF by měl být poměrně známý každému, kdo použil formuláře systému Windows nebo ASP.NET pro vytvoření aplikace [!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)].</span><span class="sxs-lookup"><span data-stu-id="62fd2-239">The data binding subsystem in WPF should be relatively familiar to anyone that has used Windows Forms or ASP.NET for creating an application [!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)].</span></span> <span data-ttu-id="62fd2-240">V každém z těchto systémů existuje jednoduchý způsob, jak vyjádřit, že chcete, aby jedna nebo více vlastností z daného prvku byla vázána na část dat.</span><span class="sxs-lookup"><span data-stu-id="62fd2-240">In each of these systems, there is a simple way to express that you want one or more properties from a given element to be bound to a piece of data.</span></span> <span data-ttu-id="62fd2-241">WPF má plnou podporu pro vazby vlastností, transformace a seznam vazby.</span><span class="sxs-lookup"><span data-stu-id="62fd2-241">WPF has full support for property binding, transformation, and list binding.</span></span>  
  
 <span data-ttu-id="62fd2-242">Jednou z nejzajímavějších vlastností datové vazby ve WPF je zavedení datových šablon.</span><span class="sxs-lookup"><span data-stu-id="62fd2-242">One of the most interesting features of data binding in WPF is the introduction of data templates.</span></span> <span data-ttu-id="62fd2-243">Šablony dat umožňují deklarativně určit, jak by měla být část dat vizualizována.</span><span class="sxs-lookup"><span data-stu-id="62fd2-243">Data templates allow you to declaratively specify how a piece of data should be visualized.</span></span> <span data-ttu-id="62fd2-244">Namísto vytváření vlastního uživatelského rozhraní, které může být vázáno na data, můžete problém místo toho otočit a nechat data určit zobrazení, které bude vytvořeno.</span><span class="sxs-lookup"><span data-stu-id="62fd2-244">Instead of creating a custom user interface that can be bound to data, you can instead turn the problem around and let the data determine the display that will be created.</span></span>  
  
 <span data-ttu-id="62fd2-245">Styling je opravdu lehká forma datové vazby.</span><span class="sxs-lookup"><span data-stu-id="62fd2-245">Styling is really a lightweight form of data binding.</span></span> <span data-ttu-id="62fd2-246">Pomocí stylu můžete svázat sadu vlastností ze sdílené definice s jednou nebo více instancemi prvku.</span><span class="sxs-lookup"><span data-stu-id="62fd2-246">Using styling you can bind a set of properties from a shared definition to one or more instances of an element.</span></span> <span data-ttu-id="62fd2-247">Styly získat použít na prvek buď explicitní <xref:System.Windows.FrameworkElement.Style%2A> odkaz (nastavením vlastnosti) nebo implicitně přisunutím styl s typem CLR prvku.</span><span class="sxs-lookup"><span data-stu-id="62fd2-247">Styles get applied to an element either by explicit reference (by setting the <xref:System.Windows.FrameworkElement.Style%2A> property) or implicitly by associating a style with the CLR type of the element.</span></span>  
  
<a name="System_Windows_Controls_Control"></a>
## <a name="systemwindowscontrolscontrol"></a><span data-ttu-id="62fd2-248">System.Windows.Controls.Control</span><span class="sxs-lookup"><span data-stu-id="62fd2-248">System.Windows.Controls.Control</span></span>  
 <span data-ttu-id="62fd2-249">Nejdůležitější funkcí ovládacího prvku je šablonování.</span><span class="sxs-lookup"><span data-stu-id="62fd2-249">Control’s most significant feature is templating.</span></span> <span data-ttu-id="62fd2-250">Pokud si myslíte o wpf složení systému jako systém uchování režimu vykreslování, šablonování umožňuje ovládací prvek popsat jeho vykreslování parametrizovaným, deklarativním způsobem.</span><span class="sxs-lookup"><span data-stu-id="62fd2-250">If you think about WPF’s composition system as a retained mode rendering system, templating allows a control to describe its rendering in a parameterized, declarative manner.</span></span> <span data-ttu-id="62fd2-251">A <xref:System.Windows.Controls.ControlTemplate> je opravdu nic víc než skript k vytvoření sadu podřízených prvků, s vazby na vlastnosti, které nabízí ovládací prvek.</span><span class="sxs-lookup"><span data-stu-id="62fd2-251">A <xref:System.Windows.Controls.ControlTemplate> is really nothing more than a script to create a set of child elements, with bindings to properties offered by the control.</span></span>  
  
 <span data-ttu-id="62fd2-252"><xref:System.Windows.Controls.Control>Poskytuje sadu vlastností <xref:System.Windows.Controls.Control.Foreground%2A>zásob <xref:System.Windows.Controls.Control.Background%2A> <xref:System.Windows.Controls.Control.Padding%2A>, , abychom jmenovali několik, které autoři šablony pak mohou použít k přizpůsobení zobrazení ovládacího prvku.</span><span class="sxs-lookup"><span data-stu-id="62fd2-252"><xref:System.Windows.Controls.Control> provides a set of stock properties, <xref:System.Windows.Controls.Control.Foreground%2A>, <xref:System.Windows.Controls.Control.Background%2A>, <xref:System.Windows.Controls.Control.Padding%2A>, to name a few, which template authors can then use to customize the display of a control.</span></span> <span data-ttu-id="62fd2-253">Implementace ovládacího prvku poskytuje datový model a model interakce.</span><span class="sxs-lookup"><span data-stu-id="62fd2-253">The implementation of a control provides a data model and interaction model.</span></span> <span data-ttu-id="62fd2-254">Model interakce definuje sadu příkazů (například Zavřít pro okno) a vazby na vstupní gesta (jako je klepnutí na červený Kříže v horním rohu okna).</span><span class="sxs-lookup"><span data-stu-id="62fd2-254">The interaction model defines a set of commands (like Close for a window) and bindings to input gestures (like clicking the red X in the upper corner of the window).</span></span> <span data-ttu-id="62fd2-255">Datový model poskytuje sadu vlastností pro přizpůsobení modelu interakce nebo přizpůsobení zobrazení (určeno šablonou).</span><span class="sxs-lookup"><span data-stu-id="62fd2-255">The data model provides a set of properties to either customize the interaction model or customize the display (determined by the template).</span></span>  
  
 <span data-ttu-id="62fd2-256">Toto rozdělení mezi datový model (vlastnosti), model interakce (příkazy a události) a model zobrazení (šablony) umožňuje úplné přizpůsobení vzhledu a chování ovládacího prvku.</span><span class="sxs-lookup"><span data-stu-id="62fd2-256">This split between the data model (properties), interaction model (commands and events), and display model (templates) enables complete customization of a control’s look and behavior.</span></span>  
  
 <span data-ttu-id="62fd2-257">Společným aspektem datového modelu ovládacích prvků je model obsahu.</span><span class="sxs-lookup"><span data-stu-id="62fd2-257">A common aspect of the data model of controls is the content model.</span></span> <span data-ttu-id="62fd2-258">Pokud se podíváte <xref:System.Windows.Controls.Button>na ovládací prvek jako , uvidíte, že <xref:System.Object>má vlastnost s názvem "Obsah" typu .</span><span class="sxs-lookup"><span data-stu-id="62fd2-258">If you look at a control like <xref:System.Windows.Controls.Button>, you will see that it has a property named "Content" of type <xref:System.Object>.</span></span> <span data-ttu-id="62fd2-259">Ve formulářích Windows a ASP.NET by tato vlastnost obvykle byla řetězcem , který však omezuje typ obsahu, který můžete umístit do tlačítka.</span><span class="sxs-lookup"><span data-stu-id="62fd2-259">In Windows Forms and ASP.NET, this property would typically be a string – however that limits the type of content you can put in a button.</span></span> <span data-ttu-id="62fd2-260">Obsah tlačítka může být jednoduchý řetězec, komplexní datový objekt nebo celý strom prvků.</span><span class="sxs-lookup"><span data-stu-id="62fd2-260">Content for a button can either be a simple string, a complex data object, or an entire element tree.</span></span> <span data-ttu-id="62fd2-261">V případě datového objektu se šablona dat používá k vytvoření zobrazení.</span><span class="sxs-lookup"><span data-stu-id="62fd2-261">In the case of a data object, the data template is used to construct a display.</span></span>  
  
<a name="Summary"></a>
## <a name="summary"></a><span data-ttu-id="62fd2-262">Souhrn</span><span class="sxs-lookup"><span data-stu-id="62fd2-262">Summary</span></span>  
 <span data-ttu-id="62fd2-263">WPF je navržen tak, aby vám umožnil vytvářet dynamické prezentační systémy založené na datech.</span><span class="sxs-lookup"><span data-stu-id="62fd2-263">WPF is designed to allow you to create dynamic, data driven presentation systems.</span></span> <span data-ttu-id="62fd2-264">Každá část systému je navržena tak, aby vytvářela objekty prostřednictvím sad vlastností, které řídí chování.</span><span class="sxs-lookup"><span data-stu-id="62fd2-264">Every part of the system is designed to create objects through property sets that drive behavior.</span></span> <span data-ttu-id="62fd2-265">Datová vazba je základní součástí systému a je integrována v každé vrstvě.</span><span class="sxs-lookup"><span data-stu-id="62fd2-265">Data binding is a fundamental part of the system, and is integrated at every layer.</span></span>  
  
 <span data-ttu-id="62fd2-266">Tradiční aplikace vytvoří zobrazení a pak se svážou na některá data.</span><span class="sxs-lookup"><span data-stu-id="62fd2-266">Traditional applications create a display and then bind to some data.</span></span> <span data-ttu-id="62fd2-267">V WPF je vše o ovládacím prvku, každý aspekt zobrazení, generován nějakým typem datové vazby.</span><span class="sxs-lookup"><span data-stu-id="62fd2-267">In WPF, everything about the control, every aspect of the display, is generated by some type of data binding.</span></span> <span data-ttu-id="62fd2-268">Text nalezený uvnitř tlačítka se zobrazí vytvořením složeného ovládacího prvku uvnitř tlačítka a vazbou jeho zobrazení na vlastnost obsahu tlačítka.</span><span class="sxs-lookup"><span data-stu-id="62fd2-268">The text found inside a button is displayed by creating a composed control inside of the button and binding its display to the button’s content property.</span></span>  
  
 <span data-ttu-id="62fd2-269">Když začnete vyvíjet aplikace založené na WPF, měl by se cítit velmi povědomě.</span><span class="sxs-lookup"><span data-stu-id="62fd2-269">When you begin developing WPF based applications, it should feel very familiar.</span></span> <span data-ttu-id="62fd2-270">Vlastnosti, použití objektů a vazbu dat můžete nastavit v podstatě stejným způsobem jako pomocí formulářů Windows nebo ASP.NET.</span><span class="sxs-lookup"><span data-stu-id="62fd2-270">You can set properties, use objects, and data bind in much the same way that you can using Windows Forms or ASP.NET.</span></span> <span data-ttu-id="62fd2-271">S hlubší zkoumání architektury WPF, zjistíte, že existuje možnost pro vytváření mnohem bohatší aplikace, které zásadně zacházet s daty jako základní ovladač aplikace.</span><span class="sxs-lookup"><span data-stu-id="62fd2-271">With a deeper investigation into the architecture of WPF, you'll find that the possibility exists for creating much richer applications that fundamentally treat data as the core driver of the application.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="62fd2-272">Viz také</span><span class="sxs-lookup"><span data-stu-id="62fd2-272">See also</span></span>

- <xref:System.Windows.Media.Visual>
- <xref:System.Windows.UIElement>
- <xref:System.Windows.Input.ICommand>
- <xref:System.Windows.FrameworkElement>
- <xref:System.Windows.Threading.DispatcherObject>
- <xref:System.Windows.Input.CommandBinding>
- <xref:System.Windows.Controls.Control>
- [<span data-ttu-id="62fd2-273">Přehled datových vazeb</span><span class="sxs-lookup"><span data-stu-id="62fd2-273">Data Binding Overview</span></span>](../../../desktop-wpf/data/data-binding-overview.md)
- [<span data-ttu-id="62fd2-274">Rozložení</span><span class="sxs-lookup"><span data-stu-id="62fd2-274">Layout</span></span>](layout.md)
- [<span data-ttu-id="62fd2-275">Přehled animace</span><span class="sxs-lookup"><span data-stu-id="62fd2-275">Animation Overview</span></span>](../graphics-multimedia/animation-overview.md)
