---
title: Architektura WPF
ms.date: 03/30/2017
helpviewer_keywords:
- properties [WPF], attached
- attached properties [WPF]
- architecture [WPF]
- unmanaged components [WPF]
- affinity thread [WPF]
- Storyboards [WPF]
- milcore [WPF]
- components [WPF], unmanaged
- painter's algorithm
- interfaces [WPF], INotifyPropertyChange
- CommandBindings [WPF]
- data templates [WPF]
- thread [WPF], affinity
ms.assetid: 8579c10b-76ab-4c52-9691-195ce02333c8
ms.openlocfilehash: 382facef15e79c4ce49fdedaeb1a072b7591e4a0
ms.sourcegitcommit: 9a97c76e141333394676bc5d264c6624b6f45bcf
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 01/08/2020
ms.locfileid: "75740214"
---
# <a name="wpf-architecture"></a><span data-ttu-id="c3824-102">Architektura WPF</span><span class="sxs-lookup"><span data-stu-id="c3824-102">WPF Architecture</span></span>
<span data-ttu-id="c3824-103">Toto téma poskytuje vodítko v hierarchii tříd Windows Presentation Foundation (WPF).</span><span class="sxs-lookup"><span data-stu-id="c3824-103">This topic provides a guided tour of the Windows Presentation Foundation (WPF) class hierarchy.</span></span> <span data-ttu-id="c3824-104">Pokrývá většinu hlavních subsystémů WPF a popisuje, jak jejich interakce funguje.</span><span class="sxs-lookup"><span data-stu-id="c3824-104">It covers most of the major subsystems of WPF, and describes how they interact.</span></span> <span data-ttu-id="c3824-105">Také podrobně popisuje některé z možností provedených architekty WPF.</span><span class="sxs-lookup"><span data-stu-id="c3824-105">It also details some of the choices made by the architects of WPF.</span></span>  

<a name="System_Object"></a>   
## <a name="systemobject"></a><span data-ttu-id="c3824-106">System.Object</span><span class="sxs-lookup"><span data-stu-id="c3824-106">System.Object</span></span>  
 <span data-ttu-id="c3824-107">Primární programovací model WPF je zveřejněn prostřednictvím spravovaného kódu.</span><span class="sxs-lookup"><span data-stu-id="c3824-107">The primary WPF programming model is exposed through managed code.</span></span> <span data-ttu-id="c3824-108">V rané fázi návrhu WPF existovalo několik jednání o tom, kde by se měl řádek vykreslovat mezi spravovanými komponentami systému a nespravovanými systémy.</span><span class="sxs-lookup"><span data-stu-id="c3824-108">Early in the design phase of WPF there were a number of debates about where the line should be drawn between the managed components of the system and the unmanaged ones.</span></span> <span data-ttu-id="c3824-109">CLR nabízí celou řadu funkcí, které zvýší produktivitu a robustní vývoj (včetně správy paměti, zpracování chyb, společného systému typů atd.), ale dostanou za cenu.</span><span class="sxs-lookup"><span data-stu-id="c3824-109">The CLR provides a number of features that make development more productive and robust (including memory management, error handling, common type system, etc.) but they come at a cost.</span></span>  
  
 <span data-ttu-id="c3824-110">Hlavní komponenty WPF jsou znázorněny na následujícím obrázku.</span><span class="sxs-lookup"><span data-stu-id="c3824-110">The major components of WPF are illustrated in the figure below.</span></span> <span data-ttu-id="c3824-111">Červené části diagramu (PresentationFramework, PresentationCore a milcore) jsou hlavní části kódu WPF.</span><span class="sxs-lookup"><span data-stu-id="c3824-111">The red sections of the diagram (PresentationFramework, PresentationCore, and milcore) are the major code portions of WPF.</span></span> <span data-ttu-id="c3824-112">Z těchto, pouze jedna je nespravovanou komponentou – milcore.</span><span class="sxs-lookup"><span data-stu-id="c3824-112">Of these, only one is an unmanaged component – milcore.</span></span> <span data-ttu-id="c3824-113">Milcore je zapsán v nespravovaném kódu, aby bylo možné povolit úzkou integraci s rozhraním DirectX.</span><span class="sxs-lookup"><span data-stu-id="c3824-113">Milcore is written in unmanaged code in order to enable tight integration with DirectX.</span></span> <span data-ttu-id="c3824-114">Všechna zobrazení v WPF se provádí prostřednictvím modulu DirectX, což umožňuje efektivní vykreslování hardwaru a softwaru.</span><span class="sxs-lookup"><span data-stu-id="c3824-114">All display in WPF is done through the DirectX engine, allowing for efficient hardware and software rendering.</span></span> <span data-ttu-id="c3824-115">WPF také vyžadovala přesnější kontrolu paměti a provádění.</span><span class="sxs-lookup"><span data-stu-id="c3824-115">WPF also required fine control over memory and execution.</span></span> <span data-ttu-id="c3824-116">Modul kompozice v milcore je extrémně citlivý na výkon a vyžaduje mnoho výhod CLR pro získání výkonu.</span><span class="sxs-lookup"><span data-stu-id="c3824-116">The composition engine in milcore is extremely performance sensitive, and required giving up many advantages of the CLR to gain performance.</span></span>  
  
 <span data-ttu-id="c3824-117">![Pozice WPF v rámci .NET Framework.](./media/wpf-architect1.PNG "wpf_architect1")</span><span class="sxs-lookup"><span data-stu-id="c3824-117">![The position of WPF within the .NET Framework.](./media/wpf-architect1.PNG "wpf_architect1")</span></span>  
  
 <span data-ttu-id="c3824-118">Komunikace mezi spravovanými a nespravovanými částmi WPF je popsána dále v tomto tématu.</span><span class="sxs-lookup"><span data-stu-id="c3824-118">Communication between the managed and unmanaged portions of WPF is discussed later in this topic.</span></span> <span data-ttu-id="c3824-119">Zbývající část spravovaného programovacího modelu je popsána níže.</span><span class="sxs-lookup"><span data-stu-id="c3824-119">The remainder of the managed programming model is described below.</span></span>  
  
<a name="System_Threading_DispatcherObject"></a>   
## <a name="systemthreadingdispatcherobject"></a><span data-ttu-id="c3824-120">System.Threading.DispatcherObject</span><span class="sxs-lookup"><span data-stu-id="c3824-120">System.Threading.DispatcherObject</span></span>  
 <span data-ttu-id="c3824-121">Většina objektů v subsystému WPF je odvozená od <xref:System.Windows.Threading.DispatcherObject>, která poskytuje základní konstrukce pro práci s souběžnou a vláknovou operací.</span><span class="sxs-lookup"><span data-stu-id="c3824-121">Most objects in WPF derive from <xref:System.Windows.Threading.DispatcherObject>, which provides the basic constructs for dealing with concurrency and threading.</span></span> <span data-ttu-id="c3824-122">WPF je založen na systému zasílání zpráv, který implementuje dispečer.</span><span class="sxs-lookup"><span data-stu-id="c3824-122">WPF is based on a messaging system implemented by the dispatcher.</span></span> <span data-ttu-id="c3824-123">To funguje podobně jako u známého pumpy zpráv Win32; dispečer WPF ve skutečnosti používá zprávy User32 pro provádění volání mezi vlákny.</span><span class="sxs-lookup"><span data-stu-id="c3824-123">This works much like the familiar Win32 message pump; in fact, the WPF dispatcher uses User32 messages for performing cross thread calls.</span></span>  
  
 <span data-ttu-id="c3824-124">Existují dva základní koncepty, které je potřeba pochopit při diskuzi o souběžnosti v technologii WPF – Spřažení dispečera a vlákna.</span><span class="sxs-lookup"><span data-stu-id="c3824-124">There are really two core concepts to understand when discussing concurrency in WPF – the dispatcher and thread affinity.</span></span>  
  
 <span data-ttu-id="c3824-125">Během fáze návrhu WPF byl cíl přesunut do jediného podprocesu provádění, ale nejedná se o nevlákenný model "spřažené".</span><span class="sxs-lookup"><span data-stu-id="c3824-125">During the design phase of WPF, the goal was to move to a single thread of execution, but a non-thread "affinitized" model.</span></span> <span data-ttu-id="c3824-126">Spřažení vlákna se stane, když komponenta používá identitu vykonávajícího vlákna k uložení určitého typu stavu.</span><span class="sxs-lookup"><span data-stu-id="c3824-126">Thread affinity happens when a component uses the identity of the executing thread to store some type of state.</span></span> <span data-ttu-id="c3824-127">Nejběžnějším formulářem je použití úložiště thread local Store (TLS) k uložení stavu.</span><span class="sxs-lookup"><span data-stu-id="c3824-127">The most common form of this is to use the thread local store (TLS) to store state.</span></span> <span data-ttu-id="c3824-128">Spřažení vlákna vyžaduje, aby jednotlivé logické vlákno provádění bylo vlastněné pouze jedním fyzickým vláknem v operačním systému, což může být náročné na paměť.</span><span class="sxs-lookup"><span data-stu-id="c3824-128">Thread affinity requires that each logical thread of execution be owned by only one physical thread in the operating system, which can become memory intensive.</span></span> <span data-ttu-id="c3824-129">V tomto konci byl model vláken WPF udržován v synchronizaci s existujícím modelem vláken User32 s jedním vláknovým spuštěním s spřažením vlákna.</span><span class="sxs-lookup"><span data-stu-id="c3824-129">In the end, WPF’s threading model was kept in sync with the existing User32 threading model of single threaded execution with thread affinity.</span></span> <span data-ttu-id="c3824-130">Hlavním důvodem pro tuto spolupráci byla interoperabilita – systémy, jako je například technologie OLE 2,0, schránka a aplikace Internet Explorer, vyžadují spuštění s jedním vláknem (STA).</span><span class="sxs-lookup"><span data-stu-id="c3824-130">The primary reason for this was interoperability – systems like OLE 2.0, the clipboard, and Internet Explorer all require single thread affinity (STA) execution.</span></span>  
  
 <span data-ttu-id="c3824-131">Vzhledem k tom, že máte objekty s vlákny STA, potřebujete způsob, jak komunikovat mezi vlákny a ověřit, zda jste ve správném vlákně.</span><span class="sxs-lookup"><span data-stu-id="c3824-131">Given that you have objects with STA threading, you need a way to communicate between threads, and validate that you are on the correct thread.</span></span> <span data-ttu-id="c3824-132">V této části je role dispečera.</span><span class="sxs-lookup"><span data-stu-id="c3824-132">Herein lies the role of the dispatcher.</span></span> <span data-ttu-id="c3824-133">Dispečer je základní systém odesílání zpráv s více frontami s více prioritami.</span><span class="sxs-lookup"><span data-stu-id="c3824-133">The dispatcher is a basic message dispatching system, with multiple prioritized queues.</span></span> <span data-ttu-id="c3824-134">Příklady zpráv zahrnují nezpracovaná vstupní oznámení (přesunutí myši), funkce architektury (rozložení) nebo uživatelské příkazy (spustit tuto metodu).</span><span class="sxs-lookup"><span data-stu-id="c3824-134">Examples of messages include raw input notifications (mouse moved), framework functions (layout), or user commands (execute this method).</span></span> <span data-ttu-id="c3824-135">Odvozením z <xref:System.Windows.Threading.DispatcherObject>vytvoříte objekt CLR, který má chování STA, a bude předána ukazatel na dispečera v okamžiku vytvoření.</span><span class="sxs-lookup"><span data-stu-id="c3824-135">By deriving from <xref:System.Windows.Threading.DispatcherObject>, you create a CLR object that has STA behavior, and will be given a pointer to a dispatcher at creation time.</span></span>  
  
<a name="System_Windows_DependencyObject"></a>   
## <a name="systemwindowsdependencyobject"></a><span data-ttu-id="c3824-136">System.Windows.DependencyObject</span><span class="sxs-lookup"><span data-stu-id="c3824-136">System.Windows.DependencyObject</span></span>  
 <span data-ttu-id="c3824-137">Jedna z primárních filozofiemi architektury používaných při vytváření WPF byla preference pro vlastnosti přes metody nebo události.</span><span class="sxs-lookup"><span data-stu-id="c3824-137">One of the primary architectural philosophies used in building WPF was a preference for properties over methods or events.</span></span> <span data-ttu-id="c3824-138">Vlastnosti jsou deklarativní a umožňují snadněji zadat záměr namísto akce.</span><span class="sxs-lookup"><span data-stu-id="c3824-138">Properties are declarative and allow you to more easily specify intent instead of action.</span></span> <span data-ttu-id="c3824-139">To také podporuje modelem řízený nebo datově řízený systém pro zobrazení obsahu uživatelského rozhraní.</span><span class="sxs-lookup"><span data-stu-id="c3824-139">This also supported a model driven, or data driven, system for displaying user interface content.</span></span> <span data-ttu-id="c3824-140">Tento filozofie měl zamýšlený účinek vytvoření dalších vlastností, které můžete vytvořit s cílem zajistit lepší kontrolu nad chováním aplikace.</span><span class="sxs-lookup"><span data-stu-id="c3824-140">This philosophy had the intended effect of creating more properties that you could bind to, in order to better control the behavior of an application.</span></span>  
  
 <span data-ttu-id="c3824-141">Aby bylo možné mít více systémů řízených vlastnostmi, bohatší systém vlastností, než který je potřebný pro CLR.</span><span class="sxs-lookup"><span data-stu-id="c3824-141">In order to have more of the system driven by properties, a richer property system than what the CLR provides was needed.</span></span> <span data-ttu-id="c3824-142">Jednoduchým příkladem této bohatosti je oznámení o změně.</span><span class="sxs-lookup"><span data-stu-id="c3824-142">A simple example of this richness is change notifications.</span></span> <span data-ttu-id="c3824-143">Aby bylo možné povolit oboustrannou vazbu, potřebujete obě strany vazby, aby podporovaly oznámení o změně.</span><span class="sxs-lookup"><span data-stu-id="c3824-143">In order to enable two way binding, you need both sides of the bind to support change notification.</span></span> <span data-ttu-id="c3824-144">Aby bylo chování vázané na hodnoty vlastností, musíte být upozorněni, když se změní hodnota vlastnosti.</span><span class="sxs-lookup"><span data-stu-id="c3824-144">In order to have behavior tied to property values, you need to be notified when the property value changes.</span></span> <span data-ttu-id="c3824-145">Microsoft .NET Framework má rozhraní **INotifyPropertyChange**, které umožňuje objektu publikovat oznámení o změnách, ale je nepovinný.</span><span class="sxs-lookup"><span data-stu-id="c3824-145">The Microsoft .NET Framework has an interface, **INotifyPropertyChange**, which allows an object to publish change notifications, however it is optional.</span></span>  
  
 <span data-ttu-id="c3824-146">WPF poskytuje bohatší systém vlastností odvozený z <xref:System.Windows.DependencyObject>ho typu.</span><span class="sxs-lookup"><span data-stu-id="c3824-146">WPF provides a richer property system, derived from the <xref:System.Windows.DependencyObject> type.</span></span> <span data-ttu-id="c3824-147">Systém vlastností je skutečně "systém vlastností" závislosti "v tom, že sleduje závislosti mezi výrazy vlastností a automaticky znovu ověřuje hodnoty vlastností při změně závislosti.</span><span class="sxs-lookup"><span data-stu-id="c3824-147">The property system is truly a "dependency" property system in that it tracks dependencies between property expressions and automatically revalidates property values when dependencies change.</span></span> <span data-ttu-id="c3824-148">Například pokud máte vlastnost, která dědí (například <xref:System.Windows.Controls.Control.FontSize%2A>), systém se automaticky aktualizuje, pokud se změní vlastnost u nadřazené položky prvku, který dědí hodnotu.</span><span class="sxs-lookup"><span data-stu-id="c3824-148">For example, if you have a property that inherits (like <xref:System.Windows.Controls.Control.FontSize%2A>), the system is automatically updated if the property changes on a parent of an element that inherits the value.</span></span>  
  
 <span data-ttu-id="c3824-149">Základem systému vlastností WPF je koncept výrazu vlastnosti.</span><span class="sxs-lookup"><span data-stu-id="c3824-149">The foundation of the WPF property system is the concept of a property expression.</span></span> <span data-ttu-id="c3824-150">V této první verzi WPF je systém výrazu vlastnosti uzavřen a všechny výrazy jsou k dispozici jako součást architektury.</span><span class="sxs-lookup"><span data-stu-id="c3824-150">In this first release of WPF, the property expression system is closed, and the expressions are all provided as part of the framework.</span></span> <span data-ttu-id="c3824-151">Výrazy jsou důvody, proč systém vlastností nemá datovou vazbu, styl nebo dědění, které jsou pevně kódované, ale jsou k dispozici v rámci rozhraní později.</span><span class="sxs-lookup"><span data-stu-id="c3824-151">Expressions are why the property system doesn’t have data binding, styling, or inheritance hard coded, but rather provided by later layers within the framework.</span></span>  
  
 <span data-ttu-id="c3824-152">Systém vlastností také poskytuje pro zhuštěné úložiště hodnot vlastností.</span><span class="sxs-lookup"><span data-stu-id="c3824-152">The property system also provides for sparse storage of property values.</span></span> <span data-ttu-id="c3824-153">Vzhledem k tomu, že objekty mohou mít desítky (pokud nejsou stovky) vlastností a většina hodnot je ve výchozím stavu (Zděděno, nastaveno styly atd.), ne každá instance objektu musí mít úplnou váhu každé definované vlastnosti.</span><span class="sxs-lookup"><span data-stu-id="c3824-153">Because objects can have dozens (if not hundreds) of properties, and most of the values are in their default state (inherited, set by styles, etc.), not every instance of an object needs to have the full weight of every property defined on it.</span></span>  
  
 <span data-ttu-id="c3824-154">Poslední novou funkcí systému vlastností je pojem připojených vlastností.</span><span class="sxs-lookup"><span data-stu-id="c3824-154">The final new feature of the property system is the notion of attached properties.</span></span> <span data-ttu-id="c3824-155">Prvky WPF jsou postaveny na principu složení a opětovného použití komponenty.</span><span class="sxs-lookup"><span data-stu-id="c3824-155">WPF elements are built on the principle of composition and component reuse.</span></span> <span data-ttu-id="c3824-156">Často se jedná o případ, že některé obsahující prvky (například <xref:System.Windows.Controls.Grid> prvek rozložení) potřebují další data podřízených prvků pro řízení jeho chování (například informace o řádku nebo sloupci).</span><span class="sxs-lookup"><span data-stu-id="c3824-156">It is often the case that some containing element (like a <xref:System.Windows.Controls.Grid> layout element) needs additional data on child elements to control its behavior (like the Row/Column information).</span></span> <span data-ttu-id="c3824-157">Namísto přidružení všech těchto vlastností ke každému prvku může libovolný objekt poskytovat definice vlastností pro jakýkoliv jiný objekt.</span><span class="sxs-lookup"><span data-stu-id="c3824-157">Instead of associating all of these properties with every element, any object is allowed to provide property definitions for any other object.</span></span> <span data-ttu-id="c3824-158">To se podobá funkcím "Expanded" jazyka JavaScript.</span><span class="sxs-lookup"><span data-stu-id="c3824-158">This is similar to the "expando" features of JavaScript.</span></span>  
  
<a name="System_Windows_Media_Visual"></a>   
## <a name="systemwindowsmediavisual"></a><span data-ttu-id="c3824-159">System.Windows.Media.Visual</span><span class="sxs-lookup"><span data-stu-id="c3824-159">System.Windows.Media.Visual</span></span>  
 <span data-ttu-id="c3824-160">V dalším kroku, který je definovaný systémem, se na obrazovku nakreslí pixely.</span><span class="sxs-lookup"><span data-stu-id="c3824-160">With a system defined, the next step is getting pixels drawn to the screen.</span></span> <span data-ttu-id="c3824-161">Třída <xref:System.Windows.Media.Visual> poskytuje pro vytváření stromové struktury vizuálních objektů, každou volitelně obsahující pokyny pro kreslení a metadata o způsobu vykreslování těchto instrukcí (oříznutí, transformace atd.).</span><span class="sxs-lookup"><span data-stu-id="c3824-161">The <xref:System.Windows.Media.Visual> class provides for building a tree of visual objects, each optionally containing drawing instructions and metadata about how to render those instructions (clipping, transformation, etc.).</span></span> <span data-ttu-id="c3824-162"><xref:System.Windows.Media.Visual> je navržený tak, aby byl extrémně lehký a flexibilní, takže většina funkcí nemá žádnou veřejnou expozici rozhraní API a spoléhat na chráněné funkce zpětného volání.</span><span class="sxs-lookup"><span data-stu-id="c3824-162"><xref:System.Windows.Media.Visual> is designed to be extremely lightweight and flexible, so most of the features have no public API exposure and rely heavily on protected callback functions.</span></span>  
  
 <span data-ttu-id="c3824-163"><xref:System.Windows.Media.Visual> je skutečně vstupním bodem pro systém kompozice WPF.</span><span class="sxs-lookup"><span data-stu-id="c3824-163"><xref:System.Windows.Media.Visual> is really the entry point to the WPF composition system.</span></span> <span data-ttu-id="c3824-164"><xref:System.Windows.Media.Visual> je bod připojení mezi těmito dvěma subsystémy, spravovaným rozhraním API a nespravovaným milcore.</span><span class="sxs-lookup"><span data-stu-id="c3824-164"><xref:System.Windows.Media.Visual> is the point of connection between these two subsystems, the managed API and the unmanaged milcore.</span></span>  
  
 <span data-ttu-id="c3824-165">WPF zobrazuje data přecházením do nespravovaných datových struktur spravovaných pomocí milcore.</span><span class="sxs-lookup"><span data-stu-id="c3824-165">WPF displays data by traversing the unmanaged data structures managed by the milcore.</span></span> <span data-ttu-id="c3824-166">Tyto struktury označované jako uzly kompozice reprezentují hierarchický strom zobrazení s pokyny pro vykreslování v jednotlivých uzlech.</span><span class="sxs-lookup"><span data-stu-id="c3824-166">These structures, called composition nodes, represent a hierarchical display tree with rendering instructions at each node.</span></span> <span data-ttu-id="c3824-167">Tento strom, který je znázorněn na pravé straně obrázku níže, je přístupný pouze prostřednictvím protokolu zasílání zpráv.</span><span class="sxs-lookup"><span data-stu-id="c3824-167">This tree, illustrated on the right hand side of the figure below, is only accessible through a messaging protocol.</span></span>  
  
 <span data-ttu-id="c3824-168">Při programování WPF vytvoříte <xref:System.Windows.Media.Visual> prvky a odvozené typy, které interně komunikují do stromu kompozice prostřednictvím tohoto protokolu pro zasílání zpráv.</span><span class="sxs-lookup"><span data-stu-id="c3824-168">When programming WPF, you create <xref:System.Windows.Media.Visual> elements, and derived types, which internally communicate to the composition tree through this messaging protocol.</span></span> <span data-ttu-id="c3824-169">Každý <xref:System.Windows.Media.Visual> v subsystému WPF může vytvořit jeden, žádný nebo několik uzlů kompozice.</span><span class="sxs-lookup"><span data-stu-id="c3824-169">Each <xref:System.Windows.Media.Visual> in WPF may create one, none, or several composition nodes.</span></span>  
  
 <span data-ttu-id="c3824-170">![Windows Presentation Foundation vizuální strom.](./media/wpf-architecture2.PNG "wpf_architecture2")</span><span class="sxs-lookup"><span data-stu-id="c3824-170">![The Windows Presentation Foundation Visual Tree.](./media/wpf-architecture2.PNG "wpf_architecture2")</span></span>  
  
 <span data-ttu-id="c3824-171">Tady si můžete všimnout podrobných podrobností o architektuře – celý strom vizuálů a instrukcí pro kreslení se ukládá do mezipaměti.</span><span class="sxs-lookup"><span data-stu-id="c3824-171">There is a very important architectural detail to notice here – the entire tree of visuals and drawing instructions is cached.</span></span> <span data-ttu-id="c3824-172">V grafických výrazech používá WPF systém zadrženého vykreslování.</span><span class="sxs-lookup"><span data-stu-id="c3824-172">In graphics terms, WPF uses a retained rendering system.</span></span> <span data-ttu-id="c3824-173">To umožňuje systému překreslit s vysokou mírou aktualizace bez blokování systému kompozice při zpětných voláních kódu uživatele.</span><span class="sxs-lookup"><span data-stu-id="c3824-173">This enables the system to repaint at high refresh rates without the composition system blocking on callbacks to user code.</span></span> <span data-ttu-id="c3824-174">To pomáhá zabránit vzhledu nereagujících aplikací.</span><span class="sxs-lookup"><span data-stu-id="c3824-174">This helps prevent the appearance of an unresponsive application.</span></span>  
  
 <span data-ttu-id="c3824-175">Další důležité podrobnosti, které v diagramu opravdu nevšimnete, je způsob, jakým systém skutečně provádí složení.</span><span class="sxs-lookup"><span data-stu-id="c3824-175">Another important detail that isn’t really noticeable in the diagram is how the system actually performs composition.</span></span>  
  
 <span data-ttu-id="c3824-176">V User32 a GDI systém funguje v režimu ořezového systému přímo v režimu.</span><span class="sxs-lookup"><span data-stu-id="c3824-176">In User32 and GDI, the system works on an immediate mode clipping system.</span></span> <span data-ttu-id="c3824-177">V případě, že je nutné vykreslit komponentu, systém vytvoří ořezové meze mimo prvek, který není povolen k dotyku s pixely, a poté, co je komponenta požádána o Malování pixelů v tomto poli.</span><span class="sxs-lookup"><span data-stu-id="c3824-177">When a component needs to be rendered, the system establishes a clipping bounds outside of which the component isn’t allowed to touch the pixels, and then the component is asked to paint pixels in that box.</span></span> <span data-ttu-id="c3824-178">Tento systém funguje velmi dobře v omezených systémech paměti, protože když se něco změní jenom na ovlivněnou součást – žádné dvě komponenty nepřispívají k barvě jednoho pixelu.</span><span class="sxs-lookup"><span data-stu-id="c3824-178">This system works very well in memory constrained systems because when something changes you only have to touch the affected component – no two components ever contribute to the color of a single pixel.</span></span>  
  
 <span data-ttu-id="c3824-179">WPF používá model Malování "Algorithm 's".</span><span class="sxs-lookup"><span data-stu-id="c3824-179">WPF uses a "painter's algorithm" painting model.</span></span> <span data-ttu-id="c3824-180">To znamená, že místo oříznutí jednotlivých komponent je každá komponenta požádána o vykreslení od zpátky po začátek zobrazení.</span><span class="sxs-lookup"><span data-stu-id="c3824-180">This means that instead of clipping each component, each component is asked to render from the back to the front of the display.</span></span> <span data-ttu-id="c3824-181">Díky tomu mohou jednotlivé komponenty malovat přes zobrazení předchozí součásti.</span><span class="sxs-lookup"><span data-stu-id="c3824-181">This allows each component to paint over the previous component's display.</span></span> <span data-ttu-id="c3824-182">Výhodou tohoto modelu je, že můžete mít složité a částečně transparentní tvary.</span><span class="sxs-lookup"><span data-stu-id="c3824-182">The advantage of this model is that you can have complex, partially transparent shapes.</span></span> <span data-ttu-id="c3824-183">Díky dnešnímu modernímu grafickému hardwaru je tento model poměrně rychlý (což neplatí při vytvoření User32/GDI).</span><span class="sxs-lookup"><span data-stu-id="c3824-183">With today’s modern graphics hardware, this model is relatively fast (which wasn’t the case when User32/ GDI were created).</span></span>  
  
 <span data-ttu-id="c3824-184">Jak již bylo zmíněno dříve, základní filozofie WPF je přesunout na více deklarativní model "orientovaný na vlastnosti".</span><span class="sxs-lookup"><span data-stu-id="c3824-184">As mentioned previously, a core philosophy of WPF is to move to a more declarative, "property centric" model of programming.</span></span> <span data-ttu-id="c3824-185">V vizuálním systému se to zobrazuje na několika zajímavých místech.</span><span class="sxs-lookup"><span data-stu-id="c3824-185">In the visual system, this shows up in a couple of interesting places.</span></span>  
  
 <span data-ttu-id="c3824-186">Za prvé, pokud si myslíte o grafickém systému uchovávaného režimu, je to skutečně přesun z imperativního modelu typu DrawLine/DrawLine na model s daty orientovaný na nový řádek ()/New řádek ().</span><span class="sxs-lookup"><span data-stu-id="c3824-186">First, if you think about the retained mode graphic system, this is really moving away from an imperative DrawLine/DrawLine type model, to a data oriented model – new Line()/new Line().</span></span> <span data-ttu-id="c3824-187">Tato operace přejít na vykreslování řízené daty umožňuje, aby se v pokynech pro kreslení vyjádřily informace pomocí vlastností.</span><span class="sxs-lookup"><span data-stu-id="c3824-187">This move to data driven rendering allows complex operations on the drawing instructions to be expressed using properties.</span></span> <span data-ttu-id="c3824-188">Typy odvozené od <xref:System.Windows.Media.Drawing> jsou efektivně objektový model pro vykreslování.</span><span class="sxs-lookup"><span data-stu-id="c3824-188">The types deriving from <xref:System.Windows.Media.Drawing> are effectively the object model for rendering.</span></span>  
  
 <span data-ttu-id="c3824-189">Za druhé, pokud vyhodnocujete animační systém, uvidíte, že je skoro zcela deklarativní.</span><span class="sxs-lookup"><span data-stu-id="c3824-189">Second, if you evaluate the animation system, you'll see that it is almost completely declarative.</span></span> <span data-ttu-id="c3824-190">Místo vyžadování vývojářů pro výpočet dalšího umístění nebo další barvy můžete vyjádřit animace jako sadu vlastností objektu animace.</span><span class="sxs-lookup"><span data-stu-id="c3824-190">Instead of requiring a developer to compute the next location, or next color, you can express animations as a set of properties on an animation object.</span></span> <span data-ttu-id="c3824-191">Tyto animace mohou následně vyjádřit záměr vývojáře nebo návrháře (přesunout toto tlačítko sem za 5 sekund) a systém může určit nejúčinnější způsob, jak to provést.</span><span class="sxs-lookup"><span data-stu-id="c3824-191">These animations can then express the intent of the developer or designer (move this button from here to there in 5 seconds), and the system can determine the most efficient way to accomplish that.</span></span>  
  
<a name="System_Windows_UIElement"></a>   
## <a name="systemwindowsuielement"></a><span data-ttu-id="c3824-192">System.Windows.UIElement</span><span class="sxs-lookup"><span data-stu-id="c3824-192">System.Windows.UIElement</span></span>  
 <span data-ttu-id="c3824-193"><xref:System.Windows.UIElement> definuje základní subsystémy, včetně rozložení, vstupu a událostí.</span><span class="sxs-lookup"><span data-stu-id="c3824-193"><xref:System.Windows.UIElement> defines core subsystems including Layout, Input, and Events.</span></span>  
  
 <span data-ttu-id="c3824-194">Rozložení je základní koncept v subsystému WPF.</span><span class="sxs-lookup"><span data-stu-id="c3824-194">Layout is a core concept in WPF.</span></span> <span data-ttu-id="c3824-195">V mnoha systémech existuje buď pevná sada modelů rozložení (HTML podporuje tři modely pro rozložení, flow, absolutní a tabulky), nebo žádný model pro rozložení (User32 skutečně podporuje pouze absolutní umístění).</span><span class="sxs-lookup"><span data-stu-id="c3824-195">In many systems there is either a fixed set of layout models (HTML supports three models for layout; flow, absolute, and tables) or no model for layout (User32 really only supports absolute positioning).</span></span> <span data-ttu-id="c3824-196">WPF začala s předpokladem, že vývojáři a návrháři chtěli flexibilní a rozšiřitelný model rozložení, který by mohl být založen na hodnotách vlastností, a ne na imperativní logice.</span><span class="sxs-lookup"><span data-stu-id="c3824-196">WPF started with the assumption that developers and designers wanted a flexible, extensible layout model, which could be driven by property values rather than imperative logic.</span></span> <span data-ttu-id="c3824-197">Na úrovni <xref:System.Windows.UIElement> zavádíme základní kontrakt pro rozložení – dva fáze modelu s <xref:System.Windows.UIElement.Measure%2A> a <xref:System.Windows.UIElement.Arrange%2A> průchody.</span><span class="sxs-lookup"><span data-stu-id="c3824-197">At the <xref:System.Windows.UIElement> level, the basic contract for layout is introduced – a two phase model with <xref:System.Windows.UIElement.Measure%2A> and <xref:System.Windows.UIElement.Arrange%2A> passes.</span></span>  
  
 <span data-ttu-id="c3824-198"><xref:System.Windows.UIElement.Measure%2A> umožňuje komponentě určit, jakou velikost by chtěli provést.</span><span class="sxs-lookup"><span data-stu-id="c3824-198"><xref:System.Windows.UIElement.Measure%2A> allows a component to determine how much size it would like to take.</span></span> <span data-ttu-id="c3824-199">Jedná se o samostatnou fázi od <xref:System.Windows.UIElement.Arrange%2A>, protože je k dispozici mnoho situací, kdy nadřazený prvek bude pokládat podřízeným elementem k měření jeho optimální polohy a velikosti.</span><span class="sxs-lookup"><span data-stu-id="c3824-199">This is a separate phase from <xref:System.Windows.UIElement.Arrange%2A> because there are many situations where a parent element will ask a child to measure several times to determine its optimal position and size.</span></span> <span data-ttu-id="c3824-200">Skutečnost, že nadřazené prvky žádají podřízené prvky k měření ukazuje další klíč filozofie WPF – velikost obsahu.</span><span class="sxs-lookup"><span data-stu-id="c3824-200">The fact that parent elements ask child elements to measure demonstrates another key philosophy of WPF – size to content.</span></span> <span data-ttu-id="c3824-201">Všechny ovládací prvky v subsystému WPF podporují možnost velikosti na přirozené velikosti jejich obsahu.</span><span class="sxs-lookup"><span data-stu-id="c3824-201">All controls in WPF support the ability to size to the natural size of their content.</span></span> <span data-ttu-id="c3824-202">Díky tomu je lokalizace mnohem jednodušší a umožňuje dynamické rozložení prvků pro změny velikosti.</span><span class="sxs-lookup"><span data-stu-id="c3824-202">This makes localization much easier, and allows for dynamic layout of elements as things resize.</span></span> <span data-ttu-id="c3824-203"><xref:System.Windows.UIElement.Arrange%2A> fáze umožňuje nadřazenému umístění a určení konečné velikosti jednotlivých podřízených objektů.</span><span class="sxs-lookup"><span data-stu-id="c3824-203">The <xref:System.Windows.UIElement.Arrange%2A> phase allows a parent to position and determine the final size of each child.</span></span>  
  
 <span data-ttu-id="c3824-204">Spousta času často stráví rozhovorem o výstupní straně WPF – <xref:System.Windows.Media.Visual> a souvisejících objektů.</span><span class="sxs-lookup"><span data-stu-id="c3824-204">A lot of time is often spent talking about the output side of WPF – <xref:System.Windows.Media.Visual> and related objects.</span></span> <span data-ttu-id="c3824-205">Na straně vstupu je ale také obrovské množství inovací.</span><span class="sxs-lookup"><span data-stu-id="c3824-205">However there is a tremendous amount of innovation on the input side as well.</span></span> <span data-ttu-id="c3824-206">Nejvýznamnější změnou vstupního modelu pro WPF je pravděpodobně konzistentní model, podle kterého jsou vstupní události směrovány přes systém.</span><span class="sxs-lookup"><span data-stu-id="c3824-206">Probably the most fundamental change in the input model for WPF is the consistent model by which input events are routed through the system.</span></span>  
  
 <span data-ttu-id="c3824-207">Vstup pochází jako signál pro ovladač zařízení režimu jádra a je směrován do správného procesu a vlákna prostřednictvím komplikovaného procesu zahrnujícího jádro Windows a User32.</span><span class="sxs-lookup"><span data-stu-id="c3824-207">Input originates as a signal on a kernel mode device driver and gets routed to the correct process and thread through an intricate process involving the Windows kernel and User32.</span></span> <span data-ttu-id="c3824-208">Jakmile je zpráva User32 odpovídající vstupu směrována do WPF, je převedena do nezpracované vstupní zprávy WPF a odeslána do dispečera.</span><span class="sxs-lookup"><span data-stu-id="c3824-208">Once the User32 message corresponding to the input is routed to WPF, it is converted into a WPF raw input message and sent to the dispatcher.</span></span> <span data-ttu-id="c3824-209">WPF umožňuje převod nezpracovaných vstupních událostí na více skutečných událostí a povolení funkcí, jako je "MouseEnter", bude implementováno na nízké úrovni systému se zaručeným doručením.</span><span class="sxs-lookup"><span data-stu-id="c3824-209">WPF allows for raw input events to be converted to multiple actual events, enabling features like "MouseEnter" to be implemented at a low level of the system with guaranteed delivery.</span></span>  
  
 <span data-ttu-id="c3824-210">Každá vstupní událost se převede na alespoň dvě události – na událost Preview a na skutečnou událost.</span><span class="sxs-lookup"><span data-stu-id="c3824-210">Each input event is converted to at least two events – a "preview" event and the actual event.</span></span> <span data-ttu-id="c3824-211">Všechny události v subsystému WPF mají pojem směrování prostřednictvím stromu elementu.</span><span class="sxs-lookup"><span data-stu-id="c3824-211">All events in WPF have a notion of routing through the element tree.</span></span> <span data-ttu-id="c3824-212">Události jsou označeny jako "bublina", pokud procházejí z cíle stromu stromu do kořenového adresáře a jsou označeny jako "tunel", pokud se spustí v kořenovém adresáři a přesměruje na cíl.</span><span class="sxs-lookup"><span data-stu-id="c3824-212">Events are said to "bubble" if they traverse from a target up the tree to the root, and are said to "tunnel" if they start at the root and traverse down to a target.</span></span> <span data-ttu-id="c3824-213">Vstupní tunelové události ve verzi Preview umožňují všem prvkům ve stromu možnost filtrovat nebo provést akci s událostí.</span><span class="sxs-lookup"><span data-stu-id="c3824-213">Input preview events tunnel, enabling any element in the tree an opportunity to filter or take action on the event.</span></span> <span data-ttu-id="c3824-214">Běžné události (bez verze Preview) jsou pak z cíle až do kořenového adresáře.</span><span class="sxs-lookup"><span data-stu-id="c3824-214">The regular (non-preview) events then bubble from the target up to the root.</span></span>  
  
 <span data-ttu-id="c3824-215">Tento rozdělení mezi fází tunelového propojení a bublinový postup umožňuje implementaci funkcí, jako jsou klávesové zkratky, fungovat konzistentně způsobem ve složeném světě.</span><span class="sxs-lookup"><span data-stu-id="c3824-215">This split between the tunnel and bubble phase makes implementation of features like keyboard accelerators work in a consistent fashion in a composite world.</span></span> <span data-ttu-id="c3824-216">V User32 byste implementovali klávesové zkratky s jednou globální tabulkou obsahující všechny akcelerátory, které chcete podporovat (CTRL + N mapování na "New").</span><span class="sxs-lookup"><span data-stu-id="c3824-216">In User32 you would implement keyboard accelerators by having a single global table containing all the accelerators you wanted to support (Ctrl+N mapping to "New").</span></span> <span data-ttu-id="c3824-217">V dispečeru vaší aplikace byste volali **TranslateAccelerator** , která by mohla sledovat vstupní zprávy v User32 a zjistit, jestli se nějaký odpovídající registrovaný akcelerátor.</span><span class="sxs-lookup"><span data-stu-id="c3824-217">In the dispatcher for your application you would call **TranslateAccelerator** which would sniff the input messages in User32 and determine if any matched a registered accelerator.</span></span> <span data-ttu-id="c3824-218">V subsystému WPF to nefunguje, protože systém je plně "sestavitelný" – libovolný prvek může zpracovat a použít jakékoli klávesové zkratky.</span><span class="sxs-lookup"><span data-stu-id="c3824-218">In WPF this wouldn’t work because the system is fully "composable" – any element can handle and use any keyboard accelerator.</span></span> <span data-ttu-id="c3824-219">Má-li tento model dvou fází vstup, umožňuje komponentám implementovat vlastní "TranslateAccelerator".</span><span class="sxs-lookup"><span data-stu-id="c3824-219">Having this two phase model for input allows components to implement their own "TranslateAccelerator".</span></span>  
  
 <span data-ttu-id="c3824-220">Chcete-li provést tento krok dál, <xref:System.Windows.UIElement> také zavádí pojem CommandBindings.</span><span class="sxs-lookup"><span data-stu-id="c3824-220">To take this one step further, <xref:System.Windows.UIElement> also introduces the notion of CommandBindings.</span></span> <span data-ttu-id="c3824-221">Systém příkazů WPF umožňuje vývojářům definovat funkce v souvislosti s koncovým bodem příkazu – něco, co implementuje <xref:System.Windows.Input.ICommand>.</span><span class="sxs-lookup"><span data-stu-id="c3824-221">The WPF command system allows developers to define functionality in terms of a command end point – something that implements <xref:System.Windows.Input.ICommand>.</span></span> <span data-ttu-id="c3824-222">Vazby příkazů umožňují elementu definovat mapování mezi vstupním gestem (CTRL + N) a příkazem (New).</span><span class="sxs-lookup"><span data-stu-id="c3824-222">Command bindings enable an element to define a mapping between an input gesture (Ctrl+N) and a command (New).</span></span> <span data-ttu-id="c3824-223">Vstupní gesta i definice příkazů jsou rozšiřitelné a můžou být v čase použití kabelové.</span><span class="sxs-lookup"><span data-stu-id="c3824-223">Both the input gestures and command definitions are extensible, and can be wired together at usage time.</span></span> <span data-ttu-id="c3824-224">Díky tomu je to triviální, například umožňuje koncovému uživateli přizpůsobit klíčové vazby, které chtějí používat v rámci aplikace.</span><span class="sxs-lookup"><span data-stu-id="c3824-224">This makes it trivial, for example, to allow an end user to customize the key bindings that they want to use within an application.</span></span>  
  
 <span data-ttu-id="c3824-225">K tomuto bodu v tématu, byly základem funkce "Core" funkcí WPF – funkcí implementovaných v sestavení PresentationCore.</span><span class="sxs-lookup"><span data-stu-id="c3824-225">To this point in the topic, "core" features of WPF – features implemented in the PresentationCore assembly, have been the focus.</span></span> <span data-ttu-id="c3824-226">Při sestavování WPF je požadovaný výsledek čistým oddělením mezi základními částmi (jako je kontrakt pro rozložení s **měřením** a **uspořádáním**) a rámec částí (jako je implementace konkrétního rozložení, jako je <xref:System.Windows.Controls.Grid>).</span><span class="sxs-lookup"><span data-stu-id="c3824-226">When building WPF, a clean separation between foundational pieces (like the contract for layout with **Measure** and **Arrange**) and framework pieces (like the implementation of a specific layout like <xref:System.Windows.Controls.Grid>) was the desired outcome.</span></span> <span data-ttu-id="c3824-227">Cílem bylo poskytnout v zásobníku nedostatek bodu rozšiřitelnosti, který by umožnil externím vývojářům vytvořit v případě potřeby vlastní rozhraní.</span><span class="sxs-lookup"><span data-stu-id="c3824-227">The goal was to provide an extensibility point low in the stack that would allow external developers to create their own frameworks if needed.</span></span>  
  
<a name="System_Windows_FrameworkElement"></a>   
## <a name="systemwindowsframeworkelement"></a><span data-ttu-id="c3824-228">System.Windows.FrameworkElement</span><span class="sxs-lookup"><span data-stu-id="c3824-228">System.Windows.FrameworkElement</span></span>  
 <span data-ttu-id="c3824-229"><xref:System.Windows.FrameworkElement> lze prohledat dvěma různými způsoby.</span><span class="sxs-lookup"><span data-stu-id="c3824-229"><xref:System.Windows.FrameworkElement> can be looked at in two different ways.</span></span> <span data-ttu-id="c3824-230">Zavádí sadu zásad a přizpůsobení v subsystémech představených v nižších vrstvách WPF.</span><span class="sxs-lookup"><span data-stu-id="c3824-230">It introduces a set of policies and customizations on the subsystems introduced in lower layers of WPF.</span></span> <span data-ttu-id="c3824-231">Zavádí také sadu nových subsystémů.</span><span class="sxs-lookup"><span data-stu-id="c3824-231">It also introduces a set of new subsystems.</span></span>  
  
 <span data-ttu-id="c3824-232">Primární zásada, kterou zavádí <xref:System.Windows.FrameworkElement>, je okolo rozložení aplikace.</span><span class="sxs-lookup"><span data-stu-id="c3824-232">The primary policy introduced by <xref:System.Windows.FrameworkElement> is around application layout.</span></span> <span data-ttu-id="c3824-233"><xref:System.Windows.FrameworkElement> sestaví na základní smlouvě o rozložení, kterou zavádí <xref:System.Windows.UIElement> a přidává pojem rozložení "slot", který usnadňuje tvůrci rozložení, aby měli konzistentní sadu vlastností řízených rozložení.</span><span class="sxs-lookup"><span data-stu-id="c3824-233"><xref:System.Windows.FrameworkElement> builds on the basic layout contract introduced by <xref:System.Windows.UIElement> and adds the notion of a layout "slot" that makes it easier for layout authors to have a consistent set of property driven layout semantics.</span></span> <span data-ttu-id="c3824-234">Vlastnosti jako <xref:System.Windows.FrameworkElement.HorizontalAlignment%2A>, <xref:System.Windows.FrameworkElement.VerticalAlignment%2A>, <xref:System.Windows.FrameworkElement.MinWidth%2A>a <xref:System.Windows.FrameworkElement.Margin%2A> (pro pojmenování) poskytují všechny komponenty odvozené od <xref:System.Windows.FrameworkElement> konzistentního chování uvnitř kontejnerů rozložení.</span><span class="sxs-lookup"><span data-stu-id="c3824-234">Properties like <xref:System.Windows.FrameworkElement.HorizontalAlignment%2A>, <xref:System.Windows.FrameworkElement.VerticalAlignment%2A>, <xref:System.Windows.FrameworkElement.MinWidth%2A>, and <xref:System.Windows.FrameworkElement.Margin%2A> (to name a few) give all components derived from <xref:System.Windows.FrameworkElement> consistent behavior inside of layout containers.</span></span>  
  
 <span data-ttu-id="c3824-235"><xref:System.Windows.FrameworkElement> také nabízí snadnější vystavení rozhraní API pro mnoho funkcí, které se nacházejí v základních vrstvách WPF.</span><span class="sxs-lookup"><span data-stu-id="c3824-235"><xref:System.Windows.FrameworkElement> also provides easier API exposure to many features found in the core layers of WPF.</span></span> <span data-ttu-id="c3824-236">Například <xref:System.Windows.FrameworkElement> poskytuje přímý přístup k animaci prostřednictvím metody <xref:System.Windows.FrameworkElement.BeginStoryboard%2A>.</span><span class="sxs-lookup"><span data-stu-id="c3824-236">For example, <xref:System.Windows.FrameworkElement> provides direct access to animation through the <xref:System.Windows.FrameworkElement.BeginStoryboard%2A> method.</span></span> <span data-ttu-id="c3824-237"><xref:System.Windows.Media.Animation.Storyboard> poskytuje způsob, jak skriptovat více animací proti sadě vlastností.</span><span class="sxs-lookup"><span data-stu-id="c3824-237">A <xref:System.Windows.Media.Animation.Storyboard> provides a way to script multiple animations against a set of properties.</span></span>  
  
 <span data-ttu-id="c3824-238">Dvě nejdůležitější věci, které <xref:System.Windows.FrameworkElement> zavádí, jsou datové vazby a styly.</span><span class="sxs-lookup"><span data-stu-id="c3824-238">The two most critical things that <xref:System.Windows.FrameworkElement> introduces are data binding and styles.</span></span>  
  
 <span data-ttu-id="c3824-239">Podsystém datových vazeb v subsystému WPF by měl být poměrně obeznámen s kýmkoli, kdo používal [!INCLUDE[TLA#tla_winforms](../../../../includes/tlasharptla-winforms-md.md)] nebo ASP.NET pro vytvoření [!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)]aplikace.</span><span class="sxs-lookup"><span data-stu-id="c3824-239">The data binding subsystem in WPF should be relatively familiar to anyone that has used [!INCLUDE[TLA#tla_winforms](../../../../includes/tlasharptla-winforms-md.md)] or ASP.NET for creating an application [!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)].</span></span> <span data-ttu-id="c3824-240">V každém z těchto systémů existuje jednoduchý způsob, jak vyjádřit, že chcete, aby jedna nebo více vlastností z daného prvku bylo vázáno na určitou část dat.</span><span class="sxs-lookup"><span data-stu-id="c3824-240">In each of these systems, there is a simple way to express that you want one or more properties from a given element to be bound to a piece of data.</span></span> <span data-ttu-id="c3824-241">WPF má plnou podporu pro vazby vlastností, transformaci a vazby seznamu.</span><span class="sxs-lookup"><span data-stu-id="c3824-241">WPF has full support for property binding, transformation, and list binding.</span></span>  
  
 <span data-ttu-id="c3824-242">Jednou z nejzajímavějších funkcí datové vazby v subsystému WPF je zavedení šablon dat.</span><span class="sxs-lookup"><span data-stu-id="c3824-242">One of the most interesting features of data binding in WPF is the introduction of data templates.</span></span> <span data-ttu-id="c3824-243">Šablony dat umožňují deklarativní určení způsobu vizuálního zobrazení části dat.</span><span class="sxs-lookup"><span data-stu-id="c3824-243">Data templates allow you to declaratively specify how a piece of data should be visualized.</span></span> <span data-ttu-id="c3824-244">Místo vytvoření vlastního uživatelského rozhraní, které může být vázáno na data, můžete místo toho problém vyřešit a nechat data určit zobrazení, které bude vytvořeno.</span><span class="sxs-lookup"><span data-stu-id="c3824-244">Instead of creating a custom user interface that can be bound to data, you can instead turn the problem around and let the data determine the display that will be created.</span></span>  
  
 <span data-ttu-id="c3824-245">Stylování je ve skutečnosti odlehčená forma datové vazby.</span><span class="sxs-lookup"><span data-stu-id="c3824-245">Styling is really a lightweight form of data binding.</span></span> <span data-ttu-id="c3824-246">Pomocí stylů můžete navazovat sadu vlastností ze sdílené definice na jednu nebo více instancí elementu.</span><span class="sxs-lookup"><span data-stu-id="c3824-246">Using styling you can bind a set of properties from a shared definition to one or more instances of an element.</span></span> <span data-ttu-id="c3824-247">Styly se aplikují na element buď explicitním odkazem (nastavením vlastnosti <xref:System.Windows.FrameworkElement.Style%2A>), nebo implicitně přidružením stylu k typu CLR elementu.</span><span class="sxs-lookup"><span data-stu-id="c3824-247">Styles get applied to an element either by explicit reference (by setting the <xref:System.Windows.FrameworkElement.Style%2A> property) or implicitly by associating a style with the CLR type of the element.</span></span>  
  
<a name="System_Windows_Controls_Control"></a>   
## <a name="systemwindowscontrolscontrol"></a><span data-ttu-id="c3824-248">System.Windows.Controls.Control</span><span class="sxs-lookup"><span data-stu-id="c3824-248">System.Windows.Controls.Control</span></span>  
 <span data-ttu-id="c3824-249">Nejvýznamnější funkcí ovládacího prvku je šablonování.</span><span class="sxs-lookup"><span data-stu-id="c3824-249">Control’s most significant feature is templating.</span></span> <span data-ttu-id="c3824-250">Pokud si myslíte o systému kompozice WPF jako systém vykreslování v zachované podobě, šablonování umožňuje ovládacímu prvku popsat jeho vykreslování v parametrizovaném, deklarativním způsobu.</span><span class="sxs-lookup"><span data-stu-id="c3824-250">If you think about WPF’s composition system as a retained mode rendering system, templating allows a control to describe its rendering in a parameterized, declarative manner.</span></span> <span data-ttu-id="c3824-251"><xref:System.Windows.Controls.ControlTemplate> není nic více než skript pro vytvoření sady podřízených prvků s vazbami na vlastnosti nabízené ovládacím prvkem.</span><span class="sxs-lookup"><span data-stu-id="c3824-251">A <xref:System.Windows.Controls.ControlTemplate> is really nothing more than a script to create a set of child elements, with bindings to properties offered by the control.</span></span>  
  
 <span data-ttu-id="c3824-252"><xref:System.Windows.Controls.Control> poskytuje sadu základních vlastností, <xref:System.Windows.Controls.Control.Foreground%2A>, <xref:System.Windows.Controls.Control.Background%2A><xref:System.Windows.Controls.Control.Padding%2A>, pro pojmenování několika, které autoři šablon mohou použít k přizpůsobení zobrazení ovládacího prvku.</span><span class="sxs-lookup"><span data-stu-id="c3824-252"><xref:System.Windows.Controls.Control> provides a set of stock properties, <xref:System.Windows.Controls.Control.Foreground%2A>, <xref:System.Windows.Controls.Control.Background%2A>, <xref:System.Windows.Controls.Control.Padding%2A>, to name a few, which template authors can then use to customize the display of a control.</span></span> <span data-ttu-id="c3824-253">Implementace ovládacího prvku poskytuje model datového modelu a interakce.</span><span class="sxs-lookup"><span data-stu-id="c3824-253">The implementation of a control provides a data model and interaction model.</span></span> <span data-ttu-id="c3824-254">Model interakce definuje sadu příkazů (například zavřít pro okno) a vazby na vstupní gesta (například kliknutím na červený symbol X v horním rohu okna).</span><span class="sxs-lookup"><span data-stu-id="c3824-254">The interaction model defines a set of commands (like Close for a window) and bindings to input gestures (like clicking the red X in the upper corner of the window).</span></span> <span data-ttu-id="c3824-255">Datový model poskytuje sadu vlastností buď k přizpůsobení modelu interakce, nebo přizpůsobení zobrazení (určené šablonou).</span><span class="sxs-lookup"><span data-stu-id="c3824-255">The data model provides a set of properties to either customize the interaction model or customize the display (determined by the template).</span></span>  
  
 <span data-ttu-id="c3824-256">Tento rozdělení mezi datovým modelem (vlastnosti), modelem interakce (příkazy a události) a modelem zobrazení (šablony) umožňuje kompletní přizpůsobení vzhledu a chování ovládacího prvku.</span><span class="sxs-lookup"><span data-stu-id="c3824-256">This split between the data model (properties), interaction model (commands and events), and display model (templates) enables complete customization of a control’s look and behavior.</span></span>  
  
 <span data-ttu-id="c3824-257">Běžný aspekt datového modelu ovládacího prvku je model obsahu.</span><span class="sxs-lookup"><span data-stu-id="c3824-257">A common aspect of the data model of controls is the content model.</span></span> <span data-ttu-id="c3824-258">Pokud se podíváte na ovládací prvek, jako je <xref:System.Windows.Controls.Button>, uvidíte, že má vlastnost s názvem "obsah" typu <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="c3824-258">If you look at a control like <xref:System.Windows.Controls.Button>, you will see that it has a property named "Content" of type <xref:System.Object>.</span></span> <span data-ttu-id="c3824-259">V [!INCLUDE[TLA#tla_winforms](../../../../includes/tlasharptla-winforms-md.md)] a ASP.NET by tato vlastnost byla obvykle řetězec – ale omezuje typ obsahu, který lze vložit do tlačítka.</span><span class="sxs-lookup"><span data-stu-id="c3824-259">In [!INCLUDE[TLA#tla_winforms](../../../../includes/tlasharptla-winforms-md.md)] and ASP.NET, this property would typically be a string – however that limits the type of content you can put in a button.</span></span> <span data-ttu-id="c3824-260">Obsah pro tlačítko může být buď jednoduchý řetězec, komplexní datový objekt, nebo celý strom elementu.</span><span class="sxs-lookup"><span data-stu-id="c3824-260">Content for a button can either be a simple string, a complex data object, or an entire element tree.</span></span> <span data-ttu-id="c3824-261">V případě datového objektu se k sestavení zobrazení použije šablona dat.</span><span class="sxs-lookup"><span data-stu-id="c3824-261">In the case of a data object, the data template is used to construct a display.</span></span>  
  
<a name="Summary"></a>   
## <a name="summary"></a><span data-ttu-id="c3824-262">Přehled</span><span class="sxs-lookup"><span data-stu-id="c3824-262">Summary</span></span>  
 <span data-ttu-id="c3824-263">WPF je navržená tak, aby umožňovala vytvářet dynamické prezentační systémy založené na datech.</span><span class="sxs-lookup"><span data-stu-id="c3824-263">WPF is designed to allow you to create dynamic, data driven presentation systems.</span></span> <span data-ttu-id="c3824-264">Každá část systému je navržena tak, aby vytvářela objekty prostřednictvím sad vlastností, které řídí chování jednotky.</span><span class="sxs-lookup"><span data-stu-id="c3824-264">Every part of the system is designed to create objects through property sets that drive behavior.</span></span> <span data-ttu-id="c3824-265">Datová vazba je základní součástí systému a je integrovaná na všech vrstvách.</span><span class="sxs-lookup"><span data-stu-id="c3824-265">Data binding is a fundamental part of the system, and is integrated at every layer.</span></span>  
  
 <span data-ttu-id="c3824-266">Tradiční aplikace vytvoří zobrazení a pak vytvoří vazby k některým datům.</span><span class="sxs-lookup"><span data-stu-id="c3824-266">Traditional applications create a display and then bind to some data.</span></span> <span data-ttu-id="c3824-267">V WPF je vše o ovládacím prvku, každý aspekt zobrazení, vygenerováno nějakým typem datové vazby.</span><span class="sxs-lookup"><span data-stu-id="c3824-267">In WPF, everything about the control, every aspect of the display, is generated by some type of data binding.</span></span> <span data-ttu-id="c3824-268">Text, který se nachází uvnitř tlačítka, se zobrazí tak, že se vytvoří složený ovládací prvek uvnitř tlačítka a vazba jeho zobrazení na vlastnost obsahu tlačítka.</span><span class="sxs-lookup"><span data-stu-id="c3824-268">The text found inside a button is displayed by creating a composed control inside of the button and binding its display to the button’s content property.</span></span>  
  
 <span data-ttu-id="c3824-269">Když začnete vyvíjet aplikace založené na WPF, měla by se velmi seznámit.</span><span class="sxs-lookup"><span data-stu-id="c3824-269">When you begin developing WPF based applications, it should feel very familiar.</span></span> <span data-ttu-id="c3824-270">Můžete nastavit vlastnosti, použít objekty a vytvořit datovou vazby podobným způsobem, jakým můžete použít [!INCLUDE[TLA#tla_winforms](../../../../includes/tlasharptla-winforms-md.md)] nebo ASP.NET.</span><span class="sxs-lookup"><span data-stu-id="c3824-270">You can set properties, use objects, and data bind in much the same way that you can using [!INCLUDE[TLA#tla_winforms](../../../../includes/tlasharptla-winforms-md.md)] or ASP.NET.</span></span> <span data-ttu-id="c3824-271">Díky hlubšímu šetření architektury WPF zjistíte, že existuje možnost pro vytváření mnohem rozsáhlejších aplikací, které v podstatě považují data za základní ovladač aplikace.</span><span class="sxs-lookup"><span data-stu-id="c3824-271">With a deeper investigation into the architecture of WPF, you'll find that the possibility exists for creating much richer applications that fundamentally treat data as the core driver of the application.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="c3824-272">Viz také:</span><span class="sxs-lookup"><span data-stu-id="c3824-272">See also</span></span>

- <xref:System.Windows.Media.Visual>
- <xref:System.Windows.UIElement>
- <xref:System.Windows.Input.ICommand>
- <xref:System.Windows.FrameworkElement>
- <xref:System.Windows.Threading.DispatcherObject>
- <xref:System.Windows.Input.CommandBinding>
- <xref:System.Windows.Controls.Control>
- [<span data-ttu-id="c3824-273">Přehled datových vazeb</span><span class="sxs-lookup"><span data-stu-id="c3824-273">Data Binding Overview</span></span>](../../../desktop-wpf/data/data-binding-overview.md)
- [<span data-ttu-id="c3824-274">Rozložení</span><span class="sxs-lookup"><span data-stu-id="c3824-274">Layout</span></span>](layout.md)
- [<span data-ttu-id="c3824-275">Přehled animace</span><span class="sxs-lookup"><span data-stu-id="c3824-275">Animation Overview</span></span>](../graphics-multimedia/animation-overview.md)
