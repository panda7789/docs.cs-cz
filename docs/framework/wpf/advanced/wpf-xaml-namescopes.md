---
title: Obory názvů WPF XAML
ms.date: 03/30/2017
helpviewer_keywords:
- namescopes [WPF]
- styles [WPF], namescopes in
- templates [WPF], namescopes in
- APIs [WPF], name-related
- name-related APIs
- XAML [WPF], namescopes
- classes [WPF], FrameworkContentElement
ms.assetid: 52bbf4f2-15fc-40d4-837b-bb4c21ead7d4
ms.openlocfilehash: 97889b302aac06e118c93f2d000b0eeeed8b71bb
ms.sourcegitcommit: f8c36054eab877de4d40a705aacafa2552ce70e9
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 12/31/2019
ms.locfileid: "75559934"
---
# <a name="wpf-xaml-namescopes"></a><span data-ttu-id="9807f-102">Obory názvů WPF XAML</span><span class="sxs-lookup"><span data-stu-id="9807f-102">WPF XAML Namescopes</span></span>
<span data-ttu-id="9807f-103">XAML obory názvů WPF jsou koncept, který identifikuje objekty, které jsou definovány v jazyce XAML.</span><span class="sxs-lookup"><span data-stu-id="9807f-103">XAML namescopes are a concept that identifies objects that are defined in XAML.</span></span> <span data-ttu-id="9807f-104">Názvy v jazyce XAML namescope lze použít k vytvoření vztahů mezi názvy objektů definovaných v jazyce XAML a jejich ekvivalenty instancí ve stromu objektů.</span><span class="sxs-lookup"><span data-stu-id="9807f-104">The names in a XAML namescope can be used to establish relationships between the XAML-defined names of objects and their instance equivalents in an object tree.</span></span> <span data-ttu-id="9807f-105">Při načítání jednotlivých kořenových adresářů stránek XAML pro aplikaci XAML se obvykle vytvoří kód XAML obory názvů WPF v [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] spravovaném kódu.</span><span class="sxs-lookup"><span data-stu-id="9807f-105">Typically, XAML namescopes in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] managed code are created when loading the individual XAML page roots for a XAML application.</span></span> <span data-ttu-id="9807f-106">XAML obory názvů WPF jako programovací objekt jsou definovány rozhraním <xref:System.Windows.Markup.INameScope> a jsou implementovány také pomocí <xref:System.Windows.NameScope>praktické třídy.</span><span class="sxs-lookup"><span data-stu-id="9807f-106">XAML namescopes as the programming object are defined by the <xref:System.Windows.Markup.INameScope> interface and are also implemented by the practical class <xref:System.Windows.NameScope>.</span></span>  

<a name="Namescopes_in_Loaded_XAML_Applications"></a>   
## <a name="namescopes-in-loaded-xaml-applications"></a><span data-ttu-id="9807f-107">Obory názvů WPF v načtených aplikacích XAML</span><span class="sxs-lookup"><span data-stu-id="9807f-107">Namescopes in Loaded XAML Applications</span></span>  
 <span data-ttu-id="9807f-108">V širším programovacím nebo počítačových kontextech programování často programovací pojmy často zahrnují princip jedinečného identifikátoru nebo názvu, který lze použít pro přístup k objektu.</span><span class="sxs-lookup"><span data-stu-id="9807f-108">In a broader programming or computer science context, programming concepts often include the principle of a unique identifier or name that can be used to access an object.</span></span> <span data-ttu-id="9807f-109">V systémech, které používají identifikátory nebo názvy, definuje namescope hranice, v rámci kterých bude proces nebo technika Hledat, pokud je požadován objekt daného názvu, nebo dojde k vykonání hranic, na kterých je ZAA jedinečnost identifikace názvů.</span><span class="sxs-lookup"><span data-stu-id="9807f-109">For systems that use identifiers or names, the namescope defines the boundaries within which a process or technique will search if an object of that name is requested, or the boundaries wherein uniqueness of identifying names is enforced.</span></span> <span data-ttu-id="9807f-110">Tyto obecné principy jsou pro XAML obory názvů WPF pravdivé.</span><span class="sxs-lookup"><span data-stu-id="9807f-110">These general principles are true for XAML namescopes.</span></span> <span data-ttu-id="9807f-111">V jazyce WPF se při načtení stránky v kořenovém elementu stránky XAML vytvoří obory názvů WPF XAML.</span><span class="sxs-lookup"><span data-stu-id="9807f-111">In WPF, XAML namescopes are created on the root element for a XAML page when the page is loaded.</span></span> <span data-ttu-id="9807f-112">Každý název zadaný v rámci stránky XAML začínající na kořenu stránky se přidá do relevantního namescope XAML.</span><span class="sxs-lookup"><span data-stu-id="9807f-112">Each name specified within the XAML page starting at the page root is added to a pertinent XAML namescope.</span></span>  
  
 <span data-ttu-id="9807f-113">V jazyce WPF XAML elementy, které jsou běžnými kořenovými prvky (například <xref:System.Windows.Controls.Page>a <xref:System.Windows.Window>) vždy ovládají namescope XAML.</span><span class="sxs-lookup"><span data-stu-id="9807f-113">In WPF XAML, elements that are common root elements (such as <xref:System.Windows.Controls.Page>, and <xref:System.Windows.Window>) always control a XAML namescope.</span></span> <span data-ttu-id="9807f-114">Pokud je prvek jako <xref:System.Windows.FrameworkElement> nebo <xref:System.Windows.FrameworkContentElement> kořenovým prvkem stránky v kódu, [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] procesor přidá kořen <xref:System.Windows.Controls.Page> implicitně, aby <xref:System.Windows.Controls.Page> mohl poskytnout funkční namescope jazyka XAML.</span><span class="sxs-lookup"><span data-stu-id="9807f-114">If an element such as <xref:System.Windows.FrameworkElement> or <xref:System.Windows.FrameworkContentElement> is the root element of the page in markup, a [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] processor adds a <xref:System.Windows.Controls.Page> root implicitly so that the <xref:System.Windows.Controls.Page> can provide a working XAML namescope.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="9807f-115">Akce sestavení WPF vytvoří namescope XAML pro produkci XAML i v případě, že nejsou definovány žádné `Name` ani `x:Name` atributů na žádném elementu v kódu [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)].</span><span class="sxs-lookup"><span data-stu-id="9807f-115">WPF build actions create a XAML namescope for a XAML production even if no `Name` or `x:Name` attributes are defined on any elements in the [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] markup.</span></span>  
  
 <span data-ttu-id="9807f-116">Pokud se pokusíte použít stejný název dvakrát v namescope XAML, je vyvolána výjimka.</span><span class="sxs-lookup"><span data-stu-id="9807f-116">If you try to use the same name twice in any XAML namescope, an exception is raised.</span></span> <span data-ttu-id="9807f-117">Pro WPF XAML, který má kód na pozadí a je součástí zkompilované aplikace, je výjimka vyvolána při sestavení pomocí akcí sestavení WPF při vytváření vygenerované třídy pro stránku během počáteční kompilace kódu.</span><span class="sxs-lookup"><span data-stu-id="9807f-117">For WPF XAML that has code-behind and is part of a compiled application, the exception is raised at build time by WPF build actions, when creating the generated class for the page during the initial markup compile.</span></span> <span data-ttu-id="9807f-118">Pro kódování XAML, které není zkompilováno pomocí žádné akce sestavení, mohou být při načtení XAML výjimky související s problémy s XAML namescope vyvolány.</span><span class="sxs-lookup"><span data-stu-id="9807f-118">For XAML that is not markup-compiled by any build action, exceptions related to XAML namescope issues might be raised when the XAML is loaded.</span></span> <span data-ttu-id="9807f-119">Návrháři XAML mohou také odhadnout problémy namescope XAML v době návrhu.</span><span class="sxs-lookup"><span data-stu-id="9807f-119">XAML designers might also anticipate XAML namescope issues at design time.</span></span>  
  
### <a name="adding-objects-to-runtime-object-trees"></a><span data-ttu-id="9807f-120">Přidání objektů do stromů objektů za běhu</span><span class="sxs-lookup"><span data-stu-id="9807f-120">Adding Objects to Runtime Object Trees</span></span>  
 <span data-ttu-id="9807f-121">Okamžik, kdy je analyzován XAML, představuje moment v čase, kdy je vytvořen a definován namescope WPF XAML.</span><span class="sxs-lookup"><span data-stu-id="9807f-121">The moment that XAML is parsed represents the moment in time that a WPF XAML namescope is created and defined.</span></span> <span data-ttu-id="9807f-122">Pokud přidáte objekt do stromové struktury objektů v určitém bodě v čase poté, co byl vytvořen tento strom, `Name` nebo `x:Name` hodnota nového objektu automaticky neaktualizuje informace v namescope XAML.</span><span class="sxs-lookup"><span data-stu-id="9807f-122">If you add an object to an object tree at a point in time after the XAML that produced that tree was parsed, a `Name` or `x:Name` value on the new object does not automatically update the information in a XAML namescope.</span></span> <span data-ttu-id="9807f-123">Chcete-li přidat název pro objekt do namescope WPF XAML po načtení XAML, je nutné volat odpovídající implementaci <xref:System.Windows.Markup.INameScope.RegisterName%2A> pro objekt, který definuje namescope XAML, což je obvykle kořenový adresář stránky XAML.</span><span class="sxs-lookup"><span data-stu-id="9807f-123">To add a name for an object into a WPF XAML namescope after XAML is loaded, you must call the appropriate implementation of <xref:System.Windows.Markup.INameScope.RegisterName%2A> on the object that defines the XAML namescope, which is typically the XAML page root.</span></span> <span data-ttu-id="9807f-124">Pokud název není zaregistrován, nelze přidaný objekt odkazovat podle názvu prostřednictvím metod, jako je například <xref:System.Windows.FrameworkElement.FindName%2A>, a nelze použít tento název pro cílení animace.</span><span class="sxs-lookup"><span data-stu-id="9807f-124">If the name is not registered, the added object cannot be referenced by name through methods such as <xref:System.Windows.FrameworkElement.FindName%2A>, and you cannot use that name for animation targeting.</span></span>  
  
 <span data-ttu-id="9807f-125">Nejběžnější scénář pro vývojáře aplikací je, že použijete <xref:System.Windows.FrameworkElement.RegisterName%2A> k registraci názvů do namescope XAML v aktuálním kořenu stránky.</span><span class="sxs-lookup"><span data-stu-id="9807f-125">The most common scenario for application developers is that you will use <xref:System.Windows.FrameworkElement.RegisterName%2A> to register names into the XAML namescope on the current root of the page.</span></span> <span data-ttu-id="9807f-126"><xref:System.Windows.FrameworkElement.RegisterName%2A> je součástí důležitého scénáře pro scénáře, které cílí na objekty pro animace.</span><span class="sxs-lookup"><span data-stu-id="9807f-126"><xref:System.Windows.FrameworkElement.RegisterName%2A> is part of an important scenario for storyboards that target objects for animations.</span></span> <span data-ttu-id="9807f-127">Další informace najdete v tématu [Přehled scénářů](../graphics-multimedia/storyboards-overview.md).</span><span class="sxs-lookup"><span data-stu-id="9807f-127">For more information, see [Storyboards Overview](../graphics-multimedia/storyboards-overview.md).</span></span>  
  
 <span data-ttu-id="9807f-128">Pokud zavoláte <xref:System.Windows.FrameworkElement.RegisterName%2A> na jiném objektu, než je objekt, který definuje namescope XAML, název je stále zaregistrován pro namescope XAML, že volající objekt je držen v, jako kdyby byla volána <xref:System.Windows.FrameworkElement.RegisterName%2A> v namescope definujícím objektu XAML.</span><span class="sxs-lookup"><span data-stu-id="9807f-128">If you call <xref:System.Windows.FrameworkElement.RegisterName%2A> on an object other than the object that defines the XAML namescope, the name is still registered to the XAML namescope that the calling object is held within, as if you had called <xref:System.Windows.FrameworkElement.RegisterName%2A> on the XAML namescope defining object.</span></span>  
  
### <a name="xaml-namescopes-in-code"></a><span data-ttu-id="9807f-129">Obory názvů WPF XAML v kódu</span><span class="sxs-lookup"><span data-stu-id="9807f-129">XAML Namescopes in Code</span></span>  
 <span data-ttu-id="9807f-130">V kódu můžete vytvořit a potom použít XAML obory názvů WPF.</span><span class="sxs-lookup"><span data-stu-id="9807f-130">You can create and then use XAML namescopes in code.</span></span> <span data-ttu-id="9807f-131">Rozhraní API a koncepty spojené s vytvářením XAML namescope jsou stejné i pro použití čistě kódu, protože procesor XAML pro [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] používá tato rozhraní API a koncepty při zpracovávání samotného XAML.</span><span class="sxs-lookup"><span data-stu-id="9807f-131">The APIs and the concepts involved in XAML namescope creation are the same even for a pure code usage, because the XAML processor for [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] uses these APIs and concepts when it processes XAML itself.</span></span> <span data-ttu-id="9807f-132">Koncepty a rozhraní API existují hlavně k tomu, aby bylo možné najít objekty podle názvu v rámci stromu objektů, které je obvykle definováno částečně nebo zcela v jazyce XAML.</span><span class="sxs-lookup"><span data-stu-id="9807f-132">The concepts and API exist mainly for the purpose of being able to find objects by name within an object tree that is typically defined partially or entirely in XAML.</span></span>  
  
 <span data-ttu-id="9807f-133">Pro aplikace, které jsou vytvořeny programově a nikoli z načteného XAML, musí objekt definující namescope jazyka XAML implementovat <xref:System.Windows.Markup.INameScope>, nebo být odvozenou třídou <xref:System.Windows.FrameworkElement> nebo <xref:System.Windows.FrameworkContentElement>, aby bylo možné podporovat vytváření namescopey XAML na svých instancích.</span><span class="sxs-lookup"><span data-stu-id="9807f-133">For applications that are created programmatically, and not from loaded XAML, the object that defines a XAML namescope must implement <xref:System.Windows.Markup.INameScope>, or be a <xref:System.Windows.FrameworkElement> or <xref:System.Windows.FrameworkContentElement> derived class, in order to support creation of a XAML namescope on its instances.</span></span>  
  
 <span data-ttu-id="9807f-134">Také pro všechny prvky, které nejsou načteny a zpracovány procesorem XAML, není ve výchozím nastavení vytvořen nebo inicializován namescope XAML pro objekt.</span><span class="sxs-lookup"><span data-stu-id="9807f-134">Also, for any element that is not loaded and processed by a XAML processor, the XAML namescope for the object is not created or initialized by default.</span></span> <span data-ttu-id="9807f-135">Je nutné explicitně vytvořit nové namescope XAML pro libovolný objekt, na který chcete později zaregistrovat názvy.</span><span class="sxs-lookup"><span data-stu-id="9807f-135">You must explicitly create a new XAML namescope for any object that you intend to register names into subsequently.</span></span> <span data-ttu-id="9807f-136">Chcete-li vytvořit namescope XAML, zavoláte statickou metodu <xref:System.Windows.NameScope.SetNameScope%2A>.</span><span class="sxs-lookup"><span data-stu-id="9807f-136">To create a XAML namescope, you call the static <xref:System.Windows.NameScope.SetNameScope%2A> method.</span></span> <span data-ttu-id="9807f-137">Zadejte objekt, který bude vlastnit jako parametr `dependencyObject` a nové volání konstruktoru <xref:System.Windows.NameScope.%23ctor%2A> jako parametr `value`.</span><span class="sxs-lookup"><span data-stu-id="9807f-137">Specify the object that will own it as the `dependencyObject` parameter, and a new <xref:System.Windows.NameScope.%23ctor%2A> constructor call as the `value` parameter.</span></span>  
  
 <span data-ttu-id="9807f-138">Pokud objekt zadaný jako `dependencyObject` pro <xref:System.Windows.NameScope.SetNameScope%2A> není <xref:System.Windows.Markup.INameScope> implementace, <xref:System.Windows.FrameworkElement> nebo <xref:System.Windows.FrameworkContentElement>, volání <xref:System.Windows.FrameworkElement.RegisterName%2A> na všech podřízených prvcích nebude mít žádný vliv.</span><span class="sxs-lookup"><span data-stu-id="9807f-138">If the object provided as `dependencyObject` for <xref:System.Windows.NameScope.SetNameScope%2A> is not a <xref:System.Windows.Markup.INameScope> implementation, <xref:System.Windows.FrameworkElement> or <xref:System.Windows.FrameworkContentElement>, calling <xref:System.Windows.FrameworkElement.RegisterName%2A> on any child elements will have no effect.</span></span> <span data-ttu-id="9807f-139">Pokud se nedaří vytvořit nový namescope XAML explicitně, volání <xref:System.Windows.FrameworkElement.RegisterName%2A> vyvolá výjimku.</span><span class="sxs-lookup"><span data-stu-id="9807f-139">If you fail to create the new XAML namescope explicitly, then calls to <xref:System.Windows.FrameworkElement.RegisterName%2A> will raise an exception.</span></span>  
  
 <span data-ttu-id="9807f-140">Příklad použití rozhraní API XAML namescope v kódu najdete v tématu [definice oboru názvů](../graphics-multimedia/how-to-define-a-name-scope.md).</span><span class="sxs-lookup"><span data-stu-id="9807f-140">For an example of using XAML namescope APIs in code, see [Define a Name Scope](../graphics-multimedia/how-to-define-a-name-scope.md).</span></span>  
  
<a name="Namescopes_in_Styles_and_Templates"></a>   
## <a name="xaml-namescopes-in-styles-and-templates"></a><span data-ttu-id="9807f-141">Obory názvů WPF XAML v stylech a šablonách</span><span class="sxs-lookup"><span data-stu-id="9807f-141">XAML Namescopes in Styles and Templates</span></span>  
 <span data-ttu-id="9807f-142">Styly a šablony v [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] poskytují možnost opakovaného použití a opětovného použití obsahu jednoduchým způsobem.</span><span class="sxs-lookup"><span data-stu-id="9807f-142">Styles and templates in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] provide the ability to reuse and reapply content in a straightforward way.</span></span> <span data-ttu-id="9807f-143">Styly a šablony však mohou obsahovat také prvky s názvy XAML definovanými na úrovni šablony.</span><span class="sxs-lookup"><span data-stu-id="9807f-143">However, styles and templates might also include elements with XAML names defined at the template level.</span></span> <span data-ttu-id="9807f-144">Stejnou šablonu můžete použít několikrát na stránce.</span><span class="sxs-lookup"><span data-stu-id="9807f-144">That same template might be used multiple times in a page.</span></span> <span data-ttu-id="9807f-145">Z tohoto důvodu styly a šablony definují vlastní obory názvů WPF XAML, nezávisle na jakémkoli umístění ve stromu objektů, kde je použit styl nebo šablona.</span><span class="sxs-lookup"><span data-stu-id="9807f-145">For this reason, styles and templates both define their own XAML namescopes, independent of whatever location in an object tree where the style or template is applied.</span></span>  
  
 <span data-ttu-id="9807f-146">Vezměte v úvahu v následujícím příkladu:</span><span class="sxs-lookup"><span data-stu-id="9807f-146">Consider the following example:</span></span>  
  
 [!code-xaml[XamlOvwSupport#NameScopeTemplates](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page6.xaml#namescopetemplates)]  
  
 <span data-ttu-id="9807f-147">V tomto případě se stejná šablona aplikuje na dvě různá tlačítka.</span><span class="sxs-lookup"><span data-stu-id="9807f-147">Here, the same template is applied to two different buttons.</span></span> <span data-ttu-id="9807f-148">Pokud šablony neobsahovaly diskrétní obory názvů WPF XAML, název `TheBorder` použitý v šabloně způsobí kolizi názvů v namescope XAML.</span><span class="sxs-lookup"><span data-stu-id="9807f-148">If templates did not have discrete XAML namescopes, the `TheBorder` name used in the template would cause a name collision in the XAML namescope.</span></span> <span data-ttu-id="9807f-149">Každé vytvoření instance šablony má vlastní namescope XAML, takže v tomto příkladu by měla být v tomto příkladu každá vytvořená instance XAML namescope šablony obsahovat přesně jeden název.</span><span class="sxs-lookup"><span data-stu-id="9807f-149">Each instantiation of the template has its own XAML namescope, so in this example each instantiated template's XAML namescope would contain exactly one name.</span></span>  
  
 <span data-ttu-id="9807f-150">Styly také definují vlastní namescope XAML, což většinou umožňuje, aby části scénářů měly přiřazeny konkrétní názvy.</span><span class="sxs-lookup"><span data-stu-id="9807f-150">Styles also define their own XAML namescope, mostly so that parts of storyboards can have particular names assigned.</span></span> <span data-ttu-id="9807f-151">Tyto názvy umožňují řídit konkrétní chování ovládacího prvku, které budou cílem prvků daného názvu, a to i v případě, že byla šablona znovu definovaná jako součást přizpůsobení ovládacího prvku.</span><span class="sxs-lookup"><span data-stu-id="9807f-151">These names enable control specific behaviors that will target elements of that name, even if the template was re-defined as part of control customization.</span></span>  
  
 <span data-ttu-id="9807f-152">Z důvodu samostatného obory názvů WPF jazyka XAML je hledání pojmenovaných prvků v šabloně náročnější než hledání pojmenovaného prvku, který není šablonou na stránce.</span><span class="sxs-lookup"><span data-stu-id="9807f-152">Because of the separate XAML namescopes, finding named elements in a template is more challenging than finding a non-templated named element in a page.</span></span> <span data-ttu-id="9807f-153">Nejdříve je nutné určit použitou šablonu tím, že získáte hodnotu vlastnosti <xref:System.Windows.Controls.Control.Template%2A> ovládacího prvku, ve kterém je šablona použita.</span><span class="sxs-lookup"><span data-stu-id="9807f-153">You first need to determine the applied template, by getting the <xref:System.Windows.Controls.Control.Template%2A> property value of the control where the template is applied.</span></span> <span data-ttu-id="9807f-154">Pak zavolejte šablonu verze <xref:System.Windows.FrameworkTemplate.FindName%2A>a předáním ovládacího prvku, kde byla šablona použita, jako druhý parametr.</span><span class="sxs-lookup"><span data-stu-id="9807f-154">Then, you call the template version of <xref:System.Windows.FrameworkTemplate.FindName%2A>, passing the control where the template was applied as the second parameter.</span></span>  
  
 <span data-ttu-id="9807f-155">Pokud jste autorem ovládacího prvku a generujete konvenci, kde konkrétní pojmenovaný element v použité šabloně je cílem pro chování, které je definováno samotným ovládacím prvkem, můžete použít metodu <xref:System.Windows.FrameworkElement.GetTemplateChild%2A> z kódu implementace ovládacího prvku.</span><span class="sxs-lookup"><span data-stu-id="9807f-155">If you are a control author and you are generating a convention where a particular named element in an applied template is the target for a behavior that is defined by the control itself, you can use the <xref:System.Windows.FrameworkElement.GetTemplateChild%2A> method from your control implementation code.</span></span> <span data-ttu-id="9807f-156">Metoda <xref:System.Windows.FrameworkElement.GetTemplateChild%2A> je chráněna, takže k ní má přístup pouze autor ovládacího prvku.</span><span class="sxs-lookup"><span data-stu-id="9807f-156">The <xref:System.Windows.FrameworkElement.GetTemplateChild%2A> method is protected, so only the control author has access to it.</span></span>  
  
 <span data-ttu-id="9807f-157">Pokud pracujete v rámci šablony a potřebujete získat přístup k namescope XAML, kde je šablona použita, Získejte hodnotu <xref:System.Windows.FrameworkElement.TemplatedParent%2A>a potom zavolejte <xref:System.Windows.FrameworkElement.FindName%2A>.</span><span class="sxs-lookup"><span data-stu-id="9807f-157">If you are working from within a template, and need to get to the XAML namescope where the template is applied, get the value of <xref:System.Windows.FrameworkElement.TemplatedParent%2A>, and then call <xref:System.Windows.FrameworkElement.FindName%2A> there.</span></span> <span data-ttu-id="9807f-158">Příklad práce v rámci šablony by byl, pokud píšete implementaci obslužné rutiny události, kde se událost vyvolá z prvku v použité šabloně.</span><span class="sxs-lookup"><span data-stu-id="9807f-158">An example of working within the template would be if you are writing the event handler implementation where the event will be raised from an element in an applied template.</span></span>  
  
<a name="Namescopes_and_Name_related_APIs"></a>   
## <a name="xaml-namescopes-and-name-related-apis"></a><span data-ttu-id="9807f-159">Obory názvů WPF XAML a rozhraní API související s názvem</span><span class="sxs-lookup"><span data-stu-id="9807f-159">XAML Namescopes and Name-related APIs</span></span>  
 <span data-ttu-id="9807f-160"><xref:System.Windows.FrameworkElement> má metody <xref:System.Windows.FrameworkElement.FindName%2A>, <xref:System.Windows.FrameworkElement.RegisterName%2A> a <xref:System.Windows.FrameworkElement.UnregisterName%2A>.</span><span class="sxs-lookup"><span data-stu-id="9807f-160"><xref:System.Windows.FrameworkElement> has <xref:System.Windows.FrameworkElement.FindName%2A>, <xref:System.Windows.FrameworkElement.RegisterName%2A> and <xref:System.Windows.FrameworkElement.UnregisterName%2A> methods.</span></span> <span data-ttu-id="9807f-161">Pokud objekt, který zavoláte tyto metody pro vlastní namescope XAML, metody volají do metod relevantního XAML namescope.</span><span class="sxs-lookup"><span data-stu-id="9807f-161">If the object you call these methods on owns a XAML namescope, the methods call into the methods of the relevant XAML namescope.</span></span> <span data-ttu-id="9807f-162">V opačném případě je kontrolován nadřazený prvek, zda je vlastníkem XAML namescope a tento proces pokračuje rekurzivně, dokud není nalezen namescope XAML (vzhledem k chování procesoru XAML, je zaručeno, že by to byl namescope XAML v kořenu).</span><span class="sxs-lookup"><span data-stu-id="9807f-162">Otherwise, the parent element is checked to see if it owns a XAML namescope, and this process continues recursively until a XAML namescope is found (because of the XAML processor behavior, there is guaranteed to be a XAML namescope at the root).</span></span> <span data-ttu-id="9807f-163"><xref:System.Windows.FrameworkContentElement> má podobné chování s výjimkou, že žádné <xref:System.Windows.FrameworkContentElement> by nikdy nevlastní namescope XAML.</span><span class="sxs-lookup"><span data-stu-id="9807f-163"><xref:System.Windows.FrameworkContentElement> has analogous behaviors, with the exception that no <xref:System.Windows.FrameworkContentElement> will ever own a XAML namescope.</span></span> <span data-ttu-id="9807f-164">Metody existují na <xref:System.Windows.FrameworkContentElement>, aby bylo možné volat nakonec do <xref:System.Windows.FrameworkElement> nadřazeného elementu.</span><span class="sxs-lookup"><span data-stu-id="9807f-164">The methods exist on <xref:System.Windows.FrameworkContentElement> so that the calls can be forwarded eventually to a <xref:System.Windows.FrameworkElement> parent element.</span></span>  
  
 <span data-ttu-id="9807f-165"><xref:System.Windows.NameScope.SetNameScope%2A> slouží k namapování nového objektu XAML namescope na existující objekt.</span><span class="sxs-lookup"><span data-stu-id="9807f-165"><xref:System.Windows.NameScope.SetNameScope%2A> is used to map a new XAML namescope to an existing object.</span></span> <span data-ttu-id="9807f-166">Můžete volat <xref:System.Windows.NameScope.SetNameScope%2A> více než jednou, aby bylo možné resetovat nebo vymazat namescope XAML, ale to není běžné použití.</span><span class="sxs-lookup"><span data-stu-id="9807f-166">You can call <xref:System.Windows.NameScope.SetNameScope%2A> more than once in order to reset or clear the XAML namescope, but that is not a common usage.</span></span> <span data-ttu-id="9807f-167"><xref:System.Windows.NameScope.GetNameScope%2A> se také obvykle nepoužívá z kódu.</span><span class="sxs-lookup"><span data-stu-id="9807f-167">Also, <xref:System.Windows.NameScope.GetNameScope%2A> is not typically used from code.</span></span>  
  
### <a name="xaml-namescope-implementations"></a><span data-ttu-id="9807f-168">Implementace XAML namescope</span><span class="sxs-lookup"><span data-stu-id="9807f-168">XAML Namescope Implementations</span></span>  
 <span data-ttu-id="9807f-169">Následující třídy implementují <xref:System.Windows.Markup.INameScope> přímo:</span><span class="sxs-lookup"><span data-stu-id="9807f-169">The following classes implement <xref:System.Windows.Markup.INameScope> directly:</span></span>  
  
- <xref:System.Windows.NameScope>  
  
- <xref:System.Windows.Style>  
  
- <xref:System.Windows.ResourceDictionary>  
  
- <xref:System.Windows.FrameworkTemplate>  
  
 <span data-ttu-id="9807f-170"><xref:System.Windows.ResourceDictionary> nepoužívá názvy XAML ani obory názvů WPF; místo toho používá klíče, protože se jedná o implementaci slovníku.</span><span class="sxs-lookup"><span data-stu-id="9807f-170"><xref:System.Windows.ResourceDictionary> does not use XAML names or namescopes ; it uses keys instead, because it is a dictionary implementation.</span></span> <span data-ttu-id="9807f-171">Jediným důvodem, proč <xref:System.Windows.ResourceDictionary> implementuje <xref:System.Windows.Markup.INameScope>, je, že může vyvolávat výjimky pro uživatelský kód, které vám pomohou objasnit rozdíl mezi skutečným namescope XAML a způsob, jakým <xref:System.Windows.ResourceDictionary> zpracovává klíče, a také zajistit, aby obory názvů wpfy XAML nebyly aplikovány na <xref:System.Windows.ResourceDictionary> nadřazenými prvky.</span><span class="sxs-lookup"><span data-stu-id="9807f-171">The only reason that <xref:System.Windows.ResourceDictionary> implements <xref:System.Windows.Markup.INameScope> is so it can raise exceptions to user code that help clarify the distinction between a true XAML namescope and how a <xref:System.Windows.ResourceDictionary> handles keys, and also to assure that XAML namescopes are not applied to a <xref:System.Windows.ResourceDictionary> by parent elements.</span></span>  
  
 <span data-ttu-id="9807f-172"><xref:System.Windows.FrameworkTemplate> a <xref:System.Windows.Style> implementují <xref:System.Windows.Markup.INameScope> prostřednictvím explicitních definic rozhraní.</span><span class="sxs-lookup"><span data-stu-id="9807f-172"><xref:System.Windows.FrameworkTemplate> and <xref:System.Windows.Style> implement <xref:System.Windows.Markup.INameScope> through explicit interface definitions.</span></span> <span data-ttu-id="9807f-173">Explicitní implementace umožňují, aby se tyto XAML obory názvů WPF chovat bez konvence, když jsou dostupné prostřednictvím rozhraní <xref:System.Windows.Markup.INameScope>, což je způsob, jakým [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] interní procesy komunikuje s XAML obory názvů WPF.</span><span class="sxs-lookup"><span data-stu-id="9807f-173">The explicit implementations allow these XAML namescopes to behave conventionally when they are accessed through the <xref:System.Windows.Markup.INameScope> interface, which is how XAML namescopes are communicated by [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] internal processes.</span></span> <span data-ttu-id="9807f-174">Definice explicitního rozhraní ale nejsou součástí konvenčního prostoru rozhraní API <xref:System.Windows.FrameworkTemplate> a <xref:System.Windows.Style>, protože není zřídka nutné volat <xref:System.Windows.Markup.INameScope> metody pro <xref:System.Windows.FrameworkTemplate> a <xref:System.Windows.Style> přímo a místo toho použít jiné rozhraní API, jako je <xref:System.Windows.FrameworkElement.GetTemplateChild%2A>.</span><span class="sxs-lookup"><span data-stu-id="9807f-174">But the explicit interface definitions are not part of the conventional API surface of <xref:System.Windows.FrameworkTemplate> and <xref:System.Windows.Style>, because you seldom need to call the <xref:System.Windows.Markup.INameScope> methods on <xref:System.Windows.FrameworkTemplate> and <xref:System.Windows.Style> directly, and instead would use other API such as <xref:System.Windows.FrameworkElement.GetTemplateChild%2A>.</span></span>  
  
 <span data-ttu-id="9807f-175">Následující třídy definují vlastní namescope XAML pomocí pomocné třídy <xref:System.Windows.NameScope?displayProperty=nameWithType> a připojují se ke své implementaci XAML namescope prostřednictvím vlastnosti připojené <xref:System.Windows.NameScope.NameScope%2A?displayProperty=nameWithType>:</span><span class="sxs-lookup"><span data-stu-id="9807f-175">The following classes define their own XAML namescope, by using the <xref:System.Windows.NameScope?displayProperty=nameWithType> helper class and connecting to its XAML namescope implementation through the <xref:System.Windows.NameScope.NameScope%2A?displayProperty=nameWithType> attached property:</span></span>  
  
- <xref:System.Windows.FrameworkElement>  
  
- <xref:System.Windows.FrameworkContentElement>  
  
## <a name="see-also"></a><span data-ttu-id="9807f-176">Viz také:</span><span class="sxs-lookup"><span data-stu-id="9807f-176">See also</span></span>

- [<span data-ttu-id="9807f-177">Obory názvů XAML a mapování oboru názvů pro WPF XAML</span><span class="sxs-lookup"><span data-stu-id="9807f-177">XAML Namespaces and Namespace Mapping for WPF XAML</span></span>](xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md)
- [<span data-ttu-id="9807f-178">x:Name – direktiva</span><span class="sxs-lookup"><span data-stu-id="9807f-178">x:Name Directive</span></span>](../../../desktop-wpf/xaml-services/xname-directive.md)
