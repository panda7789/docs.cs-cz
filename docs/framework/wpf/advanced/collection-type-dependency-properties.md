---
title: Vlastnosti závislostí typu kolekce
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- properties [WPF], dependency
- properties [WPF], collection-type
- dependency properties [WPF]
- collection-type properties [WPF]
ms.assetid: 99f96a42-3ab7-4f64-a16b-2e10d654e97c
ms.openlocfilehash: e783ce4b95b52b86671181dfe4b316d4b91d8fc6
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 03/12/2020
ms.locfileid: "79141534"
---
# <a name="collection-type-dependency-properties"></a><span data-ttu-id="ee7ba-102">Vlastnosti závislostí typu kolekce</span><span class="sxs-lookup"><span data-stu-id="ee7ba-102">Collection-Type Dependency Properties</span></span>
<span data-ttu-id="ee7ba-103">Toto téma obsahuje pokyny a navrhované vzory pro implementaci vlastnosti závislosti, kde je typ vlastnosti typ kolekce.</span><span class="sxs-lookup"><span data-stu-id="ee7ba-103">This topic provides guidance and suggested patterns for how to implement a dependency property where the type of the property is a collection type.</span></span>  

<a name="implementing"></a>
## <a name="implementing-a-collection-type-dependency-property"></a><span data-ttu-id="ee7ba-104">Implementace vlastnosti závislosti typu kolekce</span><span class="sxs-lookup"><span data-stu-id="ee7ba-104">Implementing a Collection-Type Dependency Property</span></span>  
 <span data-ttu-id="ee7ba-105">Pro vlastnost závislosti obecně je vzor implementace, který budete postupovat, je, že definujete obálku <xref:System.Windows.DependencyProperty> vlastnosti CLR, kde je tato vlastnost zálohována identifikátorem spíše než polem nebo jinou konstrukcí.</span><span class="sxs-lookup"><span data-stu-id="ee7ba-105">For a dependency property in general, the implementation pattern that you follow is that you define a CLR property wrapper, where that property is backed by a <xref:System.Windows.DependencyProperty> identifier rather than a field or other construct.</span></span> <span data-ttu-id="ee7ba-106">Postupujte podle stejného vzoru při implementaci vlastnosti typu kolekce.</span><span class="sxs-lookup"><span data-stu-id="ee7ba-106">You follow this same pattern when you implement a collection-type property.</span></span> <span data-ttu-id="ee7ba-107">Vlastnost typu kolekce však zavádí některé složitosti vzoru vždy, když typ, který <xref:System.Windows.DependencyObject> je <xref:System.Windows.Freezable> obsažen v kolekci je sám nebo odvozené třídy.</span><span class="sxs-lookup"><span data-stu-id="ee7ba-107">However, a collection-type property introduces some complexity to the pattern whenever the type that is contained within the collection is itself a <xref:System.Windows.DependencyObject> or <xref:System.Windows.Freezable> derived class.</span></span>  
  
<a name="initializing"></a>
## <a name="initializing-the-collection-beyond-the-default-value"></a><span data-ttu-id="ee7ba-108">Inicializace kolekce nad rámec výchozí hodnoty</span><span class="sxs-lookup"><span data-stu-id="ee7ba-108">Initializing the Collection Beyond the Default Value</span></span>  
 <span data-ttu-id="ee7ba-109">Při vytváření vlastnosti závislosti nezadáte výchozí hodnotu vlastnosti jako počáteční hodnotu pole.</span><span class="sxs-lookup"><span data-stu-id="ee7ba-109">When you create a dependency property, you do not specify the property default value as the initial field value.</span></span> <span data-ttu-id="ee7ba-110">Místo toho zadáte výchozí hodnotu prostřednictvím metadat vlastnosti závislosti.</span><span class="sxs-lookup"><span data-stu-id="ee7ba-110">Instead, you specify the default value through the dependency property metadata.</span></span> <span data-ttu-id="ee7ba-111">Pokud je vaše vlastnost typ odkazu, výchozí hodnota zadaná v metadatech vlastnosti závislostí není výchozí hodnotou pro instanci. místo toho se jedná o výchozí hodnotu, která se vztahuje na všechny instance typu.</span><span class="sxs-lookup"><span data-stu-id="ee7ba-111">If your property is a reference type, the default value specified in dependency property metadata is not a default value per instance; instead it is a default value that applies to all instances of the type.</span></span> <span data-ttu-id="ee7ba-112">Proto musíte být opatrní, abyste nepoužívali jedinečnou statickou kolekci definovanou metadaty vlastností kolekce jako pracovní výchozí hodnotu pro nově vytvořené instance vašeho typu.</span><span class="sxs-lookup"><span data-stu-id="ee7ba-112">Therefore you must be careful to not use the singular static collection defined by the collection property metadata as the working default value for newly created instances of your type.</span></span> <span data-ttu-id="ee7ba-113">Místo toho je nutné se ujistit, že záměrně nastavit hodnotu kolekce na jedinečnou kolekci (instance) jako součást logiky konstruktoru třídy.</span><span class="sxs-lookup"><span data-stu-id="ee7ba-113">Instead, you must make sure that you deliberately set the collection value to a unique (instance) collection as part of your class constructor logic.</span></span> <span data-ttu-id="ee7ba-114">V opačném případě vytvoříte neúmyslnou třídu singleton.</span><span class="sxs-lookup"><span data-stu-id="ee7ba-114">Otherwise you will have created an unintentional singleton class.</span></span>  
  
 <span data-ttu-id="ee7ba-115">Představte si následující příklad.</span><span class="sxs-lookup"><span data-stu-id="ee7ba-115">Consider the following example.</span></span> <span data-ttu-id="ee7ba-116">Následující část příkladu ukazuje definici `Aquarium`třídy , která obsahuje chybu s výchozí hodnotou.</span><span class="sxs-lookup"><span data-stu-id="ee7ba-116">The following section of the example shows the definition for a class `Aquarium`, which contains a flaw with the default value.</span></span> <span data-ttu-id="ee7ba-117">Třída definuje vlastnost `AquariumObjects`závislosti typu kolekce , která <xref:System.Collections.Generic.List%601> používá <xref:System.Windows.FrameworkElement> obecný typ s omezením typu.</span><span class="sxs-lookup"><span data-stu-id="ee7ba-117">The class defines the collection type dependency property `AquariumObjects`, which uses the generic <xref:System.Collections.Generic.List%601> type with a <xref:System.Windows.FrameworkElement> type constraint.</span></span> <span data-ttu-id="ee7ba-118">Ve <xref:System.Windows.DependencyProperty.Register%28System.String%2CSystem.Type%2CSystem.Type%2CSystem.Windows.PropertyMetadata%29> volání vlastnosti závislost metadata vytvoří výchozí hodnotu jako nový <xref:System.Collections.Generic.List%601>obecný .</span><span class="sxs-lookup"><span data-stu-id="ee7ba-118">In the <xref:System.Windows.DependencyProperty.Register%28System.String%2CSystem.Type%2CSystem.Type%2CSystem.Windows.PropertyMetadata%29> call for the dependency property, the metadata establishes the default value to be a new generic <xref:System.Collections.Generic.List%601>.</span></span>

> [!WARNING]
> <span data-ttu-id="ee7ba-119">Následující kód se nechová správně.</span><span class="sxs-lookup"><span data-stu-id="ee7ba-119">The following code does not behave correctly.</span></span>

 [!code-csharp[PropertiesOvwSupport2#CollectionProblemDefinition](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertiesOvwSupport2/CSharp/page.xaml.cs#collectionproblemdefinition)]
 [!code-vb[PropertiesOvwSupport2#CollectionProblemDefinition](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertiesOvwSupport2/visualbasic/page.xaml.vb#collectionproblemdefinition)]  
  
 <span data-ttu-id="ee7ba-120">Pokud jste však kód opustili, jak je znázorněno, je `Aquarium`tato výchozí hodnota jednoho seznamu sdílena pro všechny instance aplikace .</span><span class="sxs-lookup"><span data-stu-id="ee7ba-120">However, if you just left the code as shown, that single list default value is shared for all instances of `Aquarium`.</span></span> <span data-ttu-id="ee7ba-121">Pokud jste spustili následující testovací kód, který má ukázat, jak `Aquarium` byste vytvořit konkretizovat dvě samostatné instance a přidat jeden jiný pro `Fish` každou z nich, uvidíte překvapivý výsledek:</span><span class="sxs-lookup"><span data-stu-id="ee7ba-121">If you ran the following test code, which is intended to show how you would instantiate two separate `Aquarium` instances and add a single different `Fish` to each of them, you would see a surprising result:</span></span>  
  
 [!code-csharp[PropertiesOvwSupport#CollectionProblemTestCode](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertiesOvwSupport/CSharp/page4.xaml.cs#collectionproblemtestcode)]
 [!code-vb[PropertiesOvwSupport#CollectionProblemTestCode](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertiesOvwSupport/visualbasic/page4.xaml.vb#collectionproblemtestcode)]  
  
 <span data-ttu-id="ee7ba-122">Namísto každé kolekce s počtem jednoho, každá kolekce má počet dvou!</span><span class="sxs-lookup"><span data-stu-id="ee7ba-122">Instead of each collection having a count of one, each collection has a count of two!</span></span> <span data-ttu-id="ee7ba-123">Důvodem je, že každý `Aquarium` přidal jeho `Fish` do výchozí kolekce hodnot, které vyplývá z jednoho konstruktoru volání v metadatech a je proto sdílena mezi všechny instance.</span><span class="sxs-lookup"><span data-stu-id="ee7ba-123">This is because each `Aquarium` added its `Fish` to the default value collection, which resulted from a single constructor call in the metadata and is therefore shared between all instances.</span></span> <span data-ttu-id="ee7ba-124">Tato situace je téměř nikdy to, co chcete.</span><span class="sxs-lookup"><span data-stu-id="ee7ba-124">This situation is almost never what you want.</span></span>  
  
 <span data-ttu-id="ee7ba-125">Chcete-li tento problém vyřešit, je nutné obnovit hodnotu vlastnosti závislosti kolekce na jedinečnou instanci jako součást volání konstruktoru třídy.</span><span class="sxs-lookup"><span data-stu-id="ee7ba-125">To correct this problem, you must reset the collection dependency property value to a unique instance, as part of the class constructor call.</span></span> <span data-ttu-id="ee7ba-126">Vzhledem k tomu, <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29> <xref:System.Windows.DependencyPropertyKey> že vlastnost je jen pro čtení vlastnost závislosti, použijte metodu k nastavení, pomocí který je přístupný pouze v rámci třídy.</span><span class="sxs-lookup"><span data-stu-id="ee7ba-126">Because the property is a read-only dependency property, you use the <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29> method to set it, using the <xref:System.Windows.DependencyPropertyKey> that is only accessible within the class.</span></span>  
  
 [!code-csharp[PropertiesOvwSupport#CollectionProblemCtor](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertiesOvwSupport/CSharp/page4.xaml.cs#collectionproblemctor)]
 [!code-vb[PropertiesOvwSupport#CollectionProblemCtor](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertiesOvwSupport/visualbasic/page4.xaml.vb#collectionproblemctor)]  
  
 <span data-ttu-id="ee7ba-127">Nyní, pokud jste spustili stejný testovací kód znovu, můžete `Aquarium` zobrazit další očekávané výsledky, kde každý podporoval svou vlastní jedinečnou kolekci.</span><span class="sxs-lookup"><span data-stu-id="ee7ba-127">Now, if you ran that same test code again, you could see more expected results, where each `Aquarium` supported its own unique collection.</span></span>  
  
 <span data-ttu-id="ee7ba-128">Pokud jste zvolili, aby byla vlastnost kolekce pro čtení a zápis, došlo by k nepatrné změně v tomto vzoru.</span><span class="sxs-lookup"><span data-stu-id="ee7ba-128">There would be a slight variation on this pattern if you chose to have your collection property be read-write.</span></span> <span data-ttu-id="ee7ba-129">V takovém případě můžete volat přístupový odkaz veřejné sady z konstruktoru provést inicializaci, <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyProperty%2CSystem.Object%29> která by stále volání <xref:System.Windows.DependencyProperty> podpisu neklíč v rámci obálky sady, pomocí veřejného identifikátoru.</span><span class="sxs-lookup"><span data-stu-id="ee7ba-129">In that case, you could call the public set accessor from the constructor to do the initialization, which would still be calling the nonkey signature of <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyProperty%2CSystem.Object%29> within your set wrapper, using a public <xref:System.Windows.DependencyProperty> identifier.</span></span>  
  
## <a name="reporting-binding-value-changes-from-collection-properties"></a><span data-ttu-id="ee7ba-130">Vykazování změn hodnoty vazby z vlastností kolekce</span><span class="sxs-lookup"><span data-stu-id="ee7ba-130">Reporting Binding Value Changes from Collection Properties</span></span>  
 <span data-ttu-id="ee7ba-131">Vlastnost kolekce, která je sama o sobě vlastnost závislostí není automaticky hlásit změny jeho podvlastnosti.</span><span class="sxs-lookup"><span data-stu-id="ee7ba-131">A collection property that is itself a dependency property does not automatically report changes to its subproperties.</span></span> <span data-ttu-id="ee7ba-132">Pokud vytváříte vazby do kolekce, to může zabránit vazby z vykazování změny, tedy zrušení některých scénářů datové vazby.</span><span class="sxs-lookup"><span data-stu-id="ee7ba-132">If you are creating bindings into a collection, this can prevent the binding from reporting changes, thus invalidating some data binding scenarios.</span></span> <span data-ttu-id="ee7ba-133">Pokud však použijete <xref:System.Windows.FreezableCollection%601> typ kolekce jako typ kolekce, pak dílčí vlastnost změny obsažené prvky v kolekci jsou správně hlášeny a vazba funguje podle očekávání.</span><span class="sxs-lookup"><span data-stu-id="ee7ba-133">However, if you use the collection type <xref:System.Windows.FreezableCollection%601> as your collection type, then subproperty changes to contained elements in the collection are properly reported, and binding works as expected.</span></span>  
  
 <span data-ttu-id="ee7ba-134">Chcete-li povolit vazbu podvlastnosti v kolekci <xref:System.Windows.FreezableCollection%601>objektů závislostí, vytvořte <xref:System.Windows.DependencyObject> vlastnost kolekce jako typ s omezením typu pro tuto kolekci pro libovolnou odvozenou třídu.</span><span class="sxs-lookup"><span data-stu-id="ee7ba-134">To enable subproperty binding in a dependency object collection, create the collection property as type <xref:System.Windows.FreezableCollection%601>, with a type constraint for that collection to any <xref:System.Windows.DependencyObject> derived class.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="ee7ba-135">Viz také</span><span class="sxs-lookup"><span data-stu-id="ee7ba-135">See also</span></span>

- <xref:System.Windows.FreezableCollection%601>
- [<span data-ttu-id="ee7ba-136">XAML a vlastní třídy pro WPF</span><span class="sxs-lookup"><span data-stu-id="ee7ba-136">XAML and Custom Classes for WPF</span></span>](xaml-and-custom-classes-for-wpf.md)
- [<span data-ttu-id="ee7ba-137">Přehled datových vazeb</span><span class="sxs-lookup"><span data-stu-id="ee7ba-137">Data Binding Overview</span></span>](../../../desktop-wpf/data/data-binding-overview.md)
- [<span data-ttu-id="ee7ba-138">Přehled vlastností závislosti</span><span class="sxs-lookup"><span data-stu-id="ee7ba-138">Dependency Properties Overview</span></span>](dependency-properties-overview.md)
- [<span data-ttu-id="ee7ba-139">Vlastní vlastnosti závislosti</span><span class="sxs-lookup"><span data-stu-id="ee7ba-139">Custom Dependency Properties</span></span>](custom-dependency-properties.md)
- [<span data-ttu-id="ee7ba-140">Metadata vlastností závislosti</span><span class="sxs-lookup"><span data-stu-id="ee7ba-140">Dependency Property Metadata</span></span>](dependency-property-metadata.md)
