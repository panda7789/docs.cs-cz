---
title: XAML a vlastní třídy pro WPF
ms.date: 03/30/2017
helpviewer_keywords:
- custom classes in XAML [WPF]
- XAML [WPF], custom classes
- classes [WPF], custom classes in XAML
ms.assetid: e7313137-581e-4a64-8453-d44e15a6164a
ms.openlocfilehash: aa2dd7a5c30894f85ed1d4aae0228b76ece3c005
ms.sourcegitcommit: f8c36054eab877de4d40a705aacafa2552ce70e9
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 12/31/2019
ms.locfileid: "75559869"
---
# <a name="xaml-and-custom-classes-for-wpf"></a><span data-ttu-id="880ef-102">XAML a vlastní třídy pro WPF</span><span class="sxs-lookup"><span data-stu-id="880ef-102">XAML and Custom Classes for WPF</span></span>
<span data-ttu-id="880ef-103">XAML, jak je implementováno v architekturách modulu CLR (Common Language Runtime), podporuje možnost definovat vlastní třídu nebo strukturu v jakémkoli jazyce modulu CLR (Common Language Runtime) a pak k této třídě přistupovat pomocí kódu XAML.</span><span class="sxs-lookup"><span data-stu-id="880ef-103">XAML as implemented in common language runtime (CLR) frameworks supports the ability to define a custom class or structure in any common language runtime (CLR) language, and then access that class using XAML markup.</span></span> <span data-ttu-id="880ef-104">Můžete použít kombinaci [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]typů a vašich vlastních typů v rámci stejného souboru s označením, obvykle mapováním vlastních typů na předponu oboru názvů XAML.</span><span class="sxs-lookup"><span data-stu-id="880ef-104">You can use a mixture of [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]-defined types and your custom types within the same markup file, typically by mapping the custom types to a XAML namespace prefix.</span></span> <span data-ttu-id="880ef-105">Toto téma popisuje požadavky, které musí vlastní třída splňovat, aby ji bylo možné použít jako prvek XAML.</span><span class="sxs-lookup"><span data-stu-id="880ef-105">This topic discusses the requirements that a custom class must satisfy to be usable as a XAML element.</span></span>  

<a name="Custom_Classes_in_Applications_vs__in_Assemblies"></a>   
## <a name="custom-classes-in-applications-or-assemblies"></a><span data-ttu-id="880ef-106">Vlastní třídy v aplikacích nebo sestaveních</span><span class="sxs-lookup"><span data-stu-id="880ef-106">Custom Classes in Applications or Assemblies</span></span>  
 <span data-ttu-id="880ef-107">Vlastní třídy, které jsou používány v jazyce XAML, lze definovat dvěma různými způsoby: v rámci kódu na pozadí nebo jiném kódu, který vytváří primární [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] aplikaci, nebo jako třídu v samostatném sestavení, jako je například spustitelný soubor nebo knihovna DLL používané jako knihovna tříd.</span><span class="sxs-lookup"><span data-stu-id="880ef-107">Custom classes that are used in XAML can be defined in two distinct ways: within the code-behind or other code that produces the primary [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] application, or as a class in a separate assembly, such as an executable or DLL used as a class library.</span></span> <span data-ttu-id="880ef-108">Každý z těchto přístupů má konkrétní výhody a nevýhody.</span><span class="sxs-lookup"><span data-stu-id="880ef-108">Each of these approaches has particular advantages and disadvantages.</span></span>  
  
- <span data-ttu-id="880ef-109">Výhodou vytvoření knihovny tříd je, že jakékoli takové vlastní třídy lze sdílet v mnoha různých možných aplikacích.</span><span class="sxs-lookup"><span data-stu-id="880ef-109">The advantage of creating a class library is that any such custom classes can be shared across many different possible applications.</span></span> <span data-ttu-id="880ef-110">Samostatná knihovna také usnadňuje řízení správy verzí aplikací a zjednodušuje vytváření třídy, kde je zamýšlené použití třídy jako kořenový element na stránce XAML.</span><span class="sxs-lookup"><span data-stu-id="880ef-110">A separate library also makes versioning issues of applications easier to control, and simplifies creating a class where the intended class usage is as a root element on a XAML page.</span></span>  
  
- <span data-ttu-id="880ef-111">Výhodou definování vlastních tříd v aplikaci je, že tato technika je poměrně odlehčená a minimalizuje problémy při nasazení a testování, ke kterým došlo při zavedení samostatných sestavení mimo hlavní spustitelný soubor aplikace.</span><span class="sxs-lookup"><span data-stu-id="880ef-111">The advantage of defining the custom classes in the application is that this technique is relatively lightweight and minimizes the deployment and testing issues encountered when you introduce separate assemblies beyond the main application executable.</span></span>  
  
- <span data-ttu-id="880ef-112">Bez ohledu na to, zda jsou definovány ve stejném nebo jiném sestavení, musí být vlastní třídy mapovány mezi oborem názvů CLR a oborem názvů XML, aby je bylo možné použít v jazyce XAML jako prvky.</span><span class="sxs-lookup"><span data-stu-id="880ef-112">Whether defined in the same or different assembly, custom classes need to be mapped between CLR  namespace and XML  namespace in order to be used in XAML as elements.</span></span> <span data-ttu-id="880ef-113">Viz [obory názvů XAML a mapování oboru názvů pro WPF XAML](xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md).</span><span class="sxs-lookup"><span data-stu-id="880ef-113">See [XAML Namespaces and Namespace Mapping for WPF XAML](xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md).</span></span>  
  
<a name="Requirements_for_a_Custom_Class_as_a_XAML_Element"></a>   
## <a name="requirements-for-a-custom-class-as-a-xaml-element"></a><span data-ttu-id="880ef-114">Požadavky na vlastní třídu jako element XAML</span><span class="sxs-lookup"><span data-stu-id="880ef-114">Requirements for a Custom Class as a XAML Element</span></span>  
 <span data-ttu-id="880ef-115">Aby bylo možné vytvořit instanci jako prvek objektu, musí vaše třída splňovat následující požadavky:</span><span class="sxs-lookup"><span data-stu-id="880ef-115">In order to be able to be instantiated as an object element, your class must meet the following requirements:</span></span>  
  
- <span data-ttu-id="880ef-116">Vaše vlastní třída musí být veřejná a podporovat výchozí veřejný konstruktor (bez parametrů).</span><span class="sxs-lookup"><span data-stu-id="880ef-116">Your custom class must be public and support a default (parameterless) public constructor.</span></span> <span data-ttu-id="880ef-117">(Poznámky týkající se struktur najdete v následující části.)</span><span class="sxs-lookup"><span data-stu-id="880ef-117">(See following section for notes regarding structures.)</span></span>  
  
- <span data-ttu-id="880ef-118">Vaše vlastní třída nesmí být vnořená třída.</span><span class="sxs-lookup"><span data-stu-id="880ef-118">Your custom class must not be a nested class.</span></span> <span data-ttu-id="880ef-119">Vnořené třídy a "tečka" v obecné syntaxi použití CLR jsou v konfliktu s jinými funkcemi [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] nebo XAML, jako jsou například připojené vlastnosti.</span><span class="sxs-lookup"><span data-stu-id="880ef-119">Nested classes and the "dot" in their general CLR usage syntax interfere with other [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] and/or XAML features such as attached properties.</span></span>  
  
 <span data-ttu-id="880ef-120">Kromě povolení syntaxe elementů objektu umožňuje definice objektu také syntaxi elementu Property pro jakékoli jiné veřejné vlastnosti, které tento objekt přebírají jako typ hodnoty.</span><span class="sxs-lookup"><span data-stu-id="880ef-120">In addition to enabling object element syntax, your object definition also enables property element syntax for any other public properties that take that object as the value type.</span></span> <span data-ttu-id="880ef-121">Důvodem je, že objekt se teď může vytvořit jako prvek objektu a může vyplnit hodnotu elementu vlastnosti takové vlastnosti.</span><span class="sxs-lookup"><span data-stu-id="880ef-121">This is because the object can now be instantiated as an object element and can fill the property element value of such a property.</span></span>  
  
### <a name="structures"></a><span data-ttu-id="880ef-122">Struktury</span><span class="sxs-lookup"><span data-stu-id="880ef-122">Structures</span></span>  
 <span data-ttu-id="880ef-123">Struktury, které definujete jako vlastní typy, je vždy možné sestavit v jazyce XAML v [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]. Důvodem je, že kompilátory CLR implicitně vytvoří konstruktor bez parametrů pro strukturu, která inicializuje všechny hodnoty vlastností na jejich výchozí hodnoty.</span><span class="sxs-lookup"><span data-stu-id="880ef-123">Structures that you define as custom types are always able to be constructed in XAML  in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] .This is because the CLR compilers implicitly create a parameterless constructor for a structure that initializes all property values to their defaults.</span></span> <span data-ttu-id="880ef-124">V některých případech není vhodné výchozí chování konstrukce nebo použití prvků objektu pro strukturu.</span><span class="sxs-lookup"><span data-stu-id="880ef-124">In some cases, the default construction behavior and/or object element usage for a structure is not desirable.</span></span> <span data-ttu-id="880ef-125">Důvodem může být to, že struktura má plnit hodnoty a funkce koncepčně jako sjednocení, kde uvedené hodnoty mohou mít vzájemně exkluzivní interpretaci, a proto žádnou z vlastností nelze nastavit.</span><span class="sxs-lookup"><span data-stu-id="880ef-125">This might be because the structure is intended to fill values and function conceptually as a union, where the values contained might have mutually exclusive interpretations and thus none of its properties are settable.</span></span> <span data-ttu-id="880ef-126">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] příklad takové struktury je <xref:System.Windows.GridLength>.</span><span class="sxs-lookup"><span data-stu-id="880ef-126">A [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] example of such a structure is <xref:System.Windows.GridLength>.</span></span> <span data-ttu-id="880ef-127">Obecně by tyto struktury měly implementovat konvertor typu, aby hodnoty mohly být vyjádřeny ve formě atributu pomocí konvencí řetězců, které vytvářejí různé interpretace nebo režimy hodnot struktury.</span><span class="sxs-lookup"><span data-stu-id="880ef-127">Generally, such structures should implement a type converter such that the values can be expressed in attribute form, using string conventions that create the different interpretations or modes of the structure's values.</span></span> <span data-ttu-id="880ef-128">Struktura by měla také vystavovat podobné chování pro vytváření kódu prostřednictvím konstruktoru bez parametrů.</span><span class="sxs-lookup"><span data-stu-id="880ef-128">The structure should also expose similar behavior for code construction through a non-parameterless constructor.</span></span>  
  
<a name="Requirements_for_Properties_of_a_Custom_Class_as_XAML"></a>   
## <a name="requirements-for-properties-of-a-custom-class-as-xaml-attributes"></a><span data-ttu-id="880ef-129">Požadavky na vlastnosti vlastní třídy jako atributů XAML</span><span class="sxs-lookup"><span data-stu-id="880ef-129">Requirements for Properties of a Custom Class as XAML Attributes</span></span>  
 <span data-ttu-id="880ef-130">Vlastnosti musí odkazovat na typ podle hodnoty (například primitivní), nebo použít třídu pro typ, který má buď konstruktor bez parametrů, nebo vyhrazený konvertor typu, ke kterému má procesor XAML přístup.</span><span class="sxs-lookup"><span data-stu-id="880ef-130">Properties must reference a by-value type (such as a primitive), or use a class for type that has either a parameterless constructor or a dedicated type converter that a XAML processor can access.</span></span> <span data-ttu-id="880ef-131">V implementaci CLR XAML, procesory XAML buď tyto převaděče najdou pomocí nativní podpory pro jazykové primitivy, nebo prostřednictvím aplikace <xref:System.ComponentModel.TypeConverterAttribute> do typu nebo členu v definicích zálohování typu.</span><span class="sxs-lookup"><span data-stu-id="880ef-131">In the CLR XAML implementation, XAML processors either find such converters through native support for language primitives, or through application of <xref:System.ComponentModel.TypeConverterAttribute> to a type or member in backing type definitions</span></span>  
  
 <span data-ttu-id="880ef-132">Alternativně může vlastnost odkazovat na abstraktní typ třídy nebo na rozhraní.</span><span class="sxs-lookup"><span data-stu-id="880ef-132">Alternatively, the property may reference an abstract class type, or an interface.</span></span> <span data-ttu-id="880ef-133">U abstraktních tříd nebo rozhraní je očekávána analýza XAML, že hodnota vlastnosti musí být vyplněna s praktickými instancemi třídy, které implementují rozhraní, nebo instancemi typů, které jsou odvozeny z abstraktní třídy.</span><span class="sxs-lookup"><span data-stu-id="880ef-133">For abstract classes or interfaces, the expectation for XAML parsing is that the property value must be filled with practical class instances that implement the interface, or instances of types that derive from the abstract class.</span></span>  
  
 <span data-ttu-id="880ef-134">Vlastnosti lze deklarovat u abstraktní třídy, ale lze je nastavit pouze v praktických třídách, které jsou odvozeny z abstraktní třídy.</span><span class="sxs-lookup"><span data-stu-id="880ef-134">Properties can be declared on an abstract class, but can only be set on practical classes that derive from the abstract class.</span></span> <span data-ttu-id="880ef-135">Je to proto, že při vytváření elementu Object pro třídu, která vůbec vyžaduje veřejný konstruktor bez parametrů pro třídu.</span><span class="sxs-lookup"><span data-stu-id="880ef-135">This is because creating the object element for the class at all requires a public parameterless constructor on the class.</span></span>  
  
### <a name="typeconverter-enabled-attribute-syntax"></a><span data-ttu-id="880ef-136">Syntaxe atributu s povolenou TypeConverter</span><span class="sxs-lookup"><span data-stu-id="880ef-136">TypeConverter Enabled Attribute Syntax</span></span>  
 <span data-ttu-id="880ef-137">Pokud zadáte vyhrazený typ konvertoru s atributem na úrovni třídy, použije se převod typu na syntaxi atributu pro jakoukoliv vlastnost, která vyžaduje vytvoření instance daného typu.</span><span class="sxs-lookup"><span data-stu-id="880ef-137">If you provide a dedicated, attributed type converter at the class level, the applied type conversion enables attribute syntax for any property that needs to instantiate that type.</span></span> <span data-ttu-id="880ef-138">Konvertor typu nepovoluje použití elementu Object typu; pouze přítomnost konstruktoru bez parametrů pro tento typ povoluje použití prvku objektu.</span><span class="sxs-lookup"><span data-stu-id="880ef-138">A type converter does not enable object element usage of the type; only the presence of a parameterless constructor for that type enables object element usage.</span></span> <span data-ttu-id="880ef-139">Proto jsou vlastnosti, které jsou povoleny konvertoru typu, obecně řečeno nepoužitelné v syntaxi vlastnosti, pokud samotný typ také nepodporuje syntaxi elementu objektu.</span><span class="sxs-lookup"><span data-stu-id="880ef-139">Therefore, properties that are type-converter enabled are generally speaking not usable in property syntax, unless the type itself also supports object element syntax.</span></span> <span data-ttu-id="880ef-140">Výjimkou je, že můžete zadat syntaxi elementu vlastnosti, ale element Property obsahuje řetězec.</span><span class="sxs-lookup"><span data-stu-id="880ef-140">The exception to this is that you can specify a property element syntax, but have the property element contain a string.</span></span> <span data-ttu-id="880ef-141">Toto využití je skutečně v podstatě ekvivalentem použití syntaxe atributu a takové použití není běžné, pokud není potřeba pružnější zpracování prázdných míst v hodnotě atributu.</span><span class="sxs-lookup"><span data-stu-id="880ef-141">That usage is really essentially equivalent to an attribute syntax usage, and such a usage is not common unless there is a need for more robust white-space handling of the attribute value.</span></span> <span data-ttu-id="880ef-142">Například Následuje příklad použití prvku vlastnosti, který přebírá řetězec a ekvivalent použití atributu:</span><span class="sxs-lookup"><span data-stu-id="880ef-142">For example, the following is a property element usage that takes a string, and the attribute usage equivalent:</span></span>  
  
 [!code-xaml[XamlOvwSupport#GoofyTCPE](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page8.xaml#goofytcpe)]  
  
 [!code-xaml[XamlOvwSupport#GoofyTCPE2](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page8.xaml#goofytcpe2)]  
  
 <span data-ttu-id="880ef-143">Příklady vlastností, kde je povolena syntaxe atributu, ale syntaxe elementu vlastností, která obsahuje prvek objektu je zakázán prostřednictvím jazyka XAML, jsou různé vlastnosti, které přijímají <xref:System.Windows.Input.Cursor> typ.</span><span class="sxs-lookup"><span data-stu-id="880ef-143">Examples of properties where attribute syntax is allowed but property element syntax that contains an object element is disallowed through XAML are various properties that take the <xref:System.Windows.Input.Cursor> type.</span></span> <span data-ttu-id="880ef-144">Třída <xref:System.Windows.Input.Cursor> má vyhrazený konvertor typu <xref:System.Windows.Input.CursorConverter>, ale nevystavuje konstruktor bez parametrů, takže vlastnost <xref:System.Windows.FrameworkElement.Cursor%2A> lze nastavit pouze prostřednictvím syntaxe atributu, i když skutečný typ <xref:System.Windows.Input.Cursor> je odkazový typ.</span><span class="sxs-lookup"><span data-stu-id="880ef-144">The <xref:System.Windows.Input.Cursor> class has a dedicated type converter <xref:System.Windows.Input.CursorConverter>, but does not expose a parameterless constructor, so the <xref:System.Windows.FrameworkElement.Cursor%2A> property can only be set through attribute syntax even though the actual <xref:System.Windows.Input.Cursor> type is a reference type.</span></span>  
  
### <a name="per-property-type-converters"></a><span data-ttu-id="880ef-145">Převaděče typů per-Property</span><span class="sxs-lookup"><span data-stu-id="880ef-145">Per-Property Type Converters</span></span>  
 <span data-ttu-id="880ef-146">Alternativně může samotná vlastnost deklarovat konvertor typu na úrovni vlastnosti.</span><span class="sxs-lookup"><span data-stu-id="880ef-146">Alternatively, the property itself may declare a type converter at the property level.</span></span> <span data-ttu-id="880ef-147">To umožňuje "" zkrácenému jazyku ", který vytváří instance objektů typu vložené vlastnosti, zpracováním hodnot příchozích řetězců atributu jako vstupu pro operaci <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> na základě příslušného typu.</span><span class="sxs-lookup"><span data-stu-id="880ef-147">This enables a "mini language" that instantiates objects of the type of the property inline, by processing incoming string values of the attribute as input for a <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> operation based on the appropriate type.</span></span> <span data-ttu-id="880ef-148">Obvykle je to provedeno pro usnadnění přístupu, a ne jako jediný způsob, jak povolit nastavení vlastnosti v jazyce XAML.</span><span class="sxs-lookup"><span data-stu-id="880ef-148">Typically this is done to provide a convenience accessor, and not as the sole means to enable setting a property in XAML.</span></span> <span data-ttu-id="880ef-149">Je však také možné použít převaděče typů pro atributy, kde chcete použít existující typy CLR, které neposkytují konstruktor bez parametrů ani konvertor typu s atributy.</span><span class="sxs-lookup"><span data-stu-id="880ef-149">However, it is also possible to use type converters for attributes where you want to use existing CLR types that do not supply either a parameterless constructor or an attributed type converter.</span></span> <span data-ttu-id="880ef-150">Příklady z rozhraní [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] API jsou některé vlastnosti, které přebírají typ <xref:System.Globalization.CultureInfo>.</span><span class="sxs-lookup"><span data-stu-id="880ef-150">Examples from the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] API are certain properties that take the <xref:System.Globalization.CultureInfo> type.</span></span> <span data-ttu-id="880ef-151">V tomto případě [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] používali existující typ <xref:System.Globalization.CultureInfo> Microsoft .NET Framework, aby lépe vyhovovaly scénářům kompatibility a migrace, které byly použity v dřívějších verzích rozhraní, ale typ <xref:System.Globalization.CultureInfo> nepodporoval potřebné konstruktory nebo převod typu na úrovni typu, aby jej bylo možné použít jako hodnotu vlastnosti XAML přímo.</span><span class="sxs-lookup"><span data-stu-id="880ef-151">In this case, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] used the existing Microsoft .NET Framework <xref:System.Globalization.CultureInfo> type to better address compatibility and migration scenarios that were used in earlier versions of frameworks, but the <xref:System.Globalization.CultureInfo> type did not support the necessary constructors or type-level type conversion to be usable as a XAML property value directly.</span></span>  
  
 <span data-ttu-id="880ef-152">Pokaždé, když vystavíte vlastnost, která má použití XAML, zejména pokud jste autorem ovládacího prvku, měli byste důrazně zvážit, zda tuto vlastnost obsahuje vlastnost závislosti.</span><span class="sxs-lookup"><span data-stu-id="880ef-152">Whenever you expose a property that has a XAML usage, particularly if you are a control author, you should strongly consider backing that property with a dependency property.</span></span> <span data-ttu-id="880ef-153">To platí zejména v případě, že použijete existující [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] implementaci procesoru XAML, protože můžete zvýšit výkon pomocí <xref:System.Windows.DependencyProperty>ho zálohování.</span><span class="sxs-lookup"><span data-stu-id="880ef-153">This is particularly true if you use the existing [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] implementation of the XAML processor, because you can improve performance by using <xref:System.Windows.DependencyProperty> backing.</span></span> <span data-ttu-id="880ef-154">Vlastnost závislosti vystaví funkce systému vlastností pro vaši vlastnost, které budou uživatelé chtít očekávat pro vlastnost přístupnou pomocí XAML.</span><span class="sxs-lookup"><span data-stu-id="880ef-154">A dependency property will expose property system features for your property that users will come to expect for a XAML accessible property.</span></span> <span data-ttu-id="880ef-155">To zahrnuje funkce, jako je například animace, datová vazba a podpora stylu.</span><span class="sxs-lookup"><span data-stu-id="880ef-155">This includes features such as animation, data binding, and style support.</span></span> <span data-ttu-id="880ef-156">Další informace najdete v tématu [vlastnosti vlastní závislosti](custom-dependency-properties.md) a [načítání XAML a vlastnosti závislostí](xaml-loading-and-dependency-properties.md).</span><span class="sxs-lookup"><span data-stu-id="880ef-156">For more information, see [Custom Dependency Properties](custom-dependency-properties.md) and [XAML Loading and Dependency Properties](xaml-loading-and-dependency-properties.md).</span></span>  
  
### <a name="writing-and-attributing-a-type-converter"></a><span data-ttu-id="880ef-157">Zápis a označení konvertoru typu</span><span class="sxs-lookup"><span data-stu-id="880ef-157">Writing and Attributing a Type Converter</span></span>  
 <span data-ttu-id="880ef-158">Příležitostně budete muset napsat vlastní <xref:System.ComponentModel.TypeConverter> odvozenou třídu, která poskytuje převod typu pro typ vlastnosti.</span><span class="sxs-lookup"><span data-stu-id="880ef-158">You occasionally will need to write a custom <xref:System.ComponentModel.TypeConverter> derived class to provide type conversion for your property type.</span></span> <span data-ttu-id="880ef-159">Pokyny, jak odvodit z a vytvořit konvertor typu, který může podporovat použití XAML a jak použít <xref:System.ComponentModel.TypeConverterAttribute>, naleznete v tématu [TypeConverters a XAML](typeconverters-and-xaml.md).</span><span class="sxs-lookup"><span data-stu-id="880ef-159">For instructions on how to derive from and create a type converter that can support XAML usages, and how to apply the <xref:System.ComponentModel.TypeConverterAttribute>, see [TypeConverters and XAML](typeconverters-and-xaml.md).</span></span>  
  
<a name="Requirements_for_Events_of_a_Custom_Class_as_XAML"></a>   
## <a name="requirements-for-xaml-event-handler-attribute-syntax-on-events-of-a-custom-class"></a><span data-ttu-id="880ef-160">Požadavky na syntaxi atributů obslužné rutiny událostí XAML u událostí vlastní třídy</span><span class="sxs-lookup"><span data-stu-id="880ef-160">Requirements for XAML Event Handler Attribute Syntax on Events of a Custom Class</span></span>  
 <span data-ttu-id="880ef-161">Aby bylo možné použít jako událost CLR, musí být událost vystavena jako veřejná událost ve třídě, která podporuje konstruktor bez parametrů, nebo na abstraktní třídě, kde je k události možné přistupovat v odvozených třídách.</span><span class="sxs-lookup"><span data-stu-id="880ef-161">To be usable as a CLR event, the event must be exposed as a public event on a class that supports a parameterless constructor, or on an abstract class where the event can be accessed on derived classes.</span></span> <span data-ttu-id="880ef-162">Aby bylo možné používat pohodlný postup jako směrované události, měla by vaše událost CLR implementovat explicitní `add` a `remove` metody, které přidávají a odebírají obslužné rutiny pro signaturu události CLR a předávají tyto obslužné rutiny metodám <xref:System.Windows.UIElement.AddHandler%2A> a <xref:System.Windows.UIElement.RemoveHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="880ef-162">In order to be used conveniently as a routed event, your CLR event should implement explicit `add` and `remove` methods, which add and remove handlers for the CLR event signature and forward those handlers to the <xref:System.Windows.UIElement.AddHandler%2A> and <xref:System.Windows.UIElement.RemoveHandler%2A> methods.</span></span> <span data-ttu-id="880ef-163">Tyto metody přidávají nebo odebírají obslužné rutiny do úložiště obslužné rutiny směrované události v instanci, ke které je událost připojena.</span><span class="sxs-lookup"><span data-stu-id="880ef-163">These methods add or remove the handlers to the routed event handler store on the instance that the event is attached to.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="880ef-164">Je možné zaregistrovat obslužné rutiny přímo pro směrované události pomocí <xref:System.Windows.UIElement.AddHandler%2A>a záměrně nedefinovat událost modulu CLR, která zpřístupňuje směrovanou událost.</span><span class="sxs-lookup"><span data-stu-id="880ef-164">It is possible to register handlers directly for routed events using <xref:System.Windows.UIElement.AddHandler%2A>, and to deliberately not define a CLR event that exposes the routed event.</span></span> <span data-ttu-id="880ef-165">Obecně se to nedoporučuje, protože událost nepovoluje syntaxi atributu XAML pro připojení obslužných rutin a výsledná třída nabízí méně transparentní zobrazení XAML pro tyto možnosti typu.</span><span class="sxs-lookup"><span data-stu-id="880ef-165">This is not generally recommended because the event will not enable XAML attribute syntax for attaching handlers, and your resulting class will offer a less transparent XAML view of that type's capabilities.</span></span>  
  
<a name="Collection_Properties"></a>   
## <a name="writing-collection-properties"></a><span data-ttu-id="880ef-166">Zápis vlastností kolekce</span><span class="sxs-lookup"><span data-stu-id="880ef-166">Writing Collection Properties</span></span>  
 <span data-ttu-id="880ef-167">Vlastnosti, které přijímají typ kolekce, mají syntaxi jazyka XAML, která umožňuje určit objekty, které jsou přidány do kolekce.</span><span class="sxs-lookup"><span data-stu-id="880ef-167">Properties that take a collection type have a XAML syntax that enables you to specify objects that are added to the collection.</span></span> <span data-ttu-id="880ef-168">Tato syntaxe má dvě významné funkce.</span><span class="sxs-lookup"><span data-stu-id="880ef-168">This syntax has two notable features.</span></span>  
  
- <span data-ttu-id="880ef-169">Objekt, který je objektem kolekce, nemusí být specifikován v syntaxi elementu Object.</span><span class="sxs-lookup"><span data-stu-id="880ef-169">The object that is the collection object does not need to be specified in object element syntax.</span></span> <span data-ttu-id="880ef-170">Přítomnost tohoto typu kolekce je implicitní pokaždé, když zadáte vlastnost v jazyce XAML, která přebírá typ kolekce.</span><span class="sxs-lookup"><span data-stu-id="880ef-170">The presence of that collection type is implicit whenever you specify a property in XAML that takes a collection type.</span></span>  
  
- <span data-ttu-id="880ef-171">Podřízené prvky vlastnosti Collection v kódu jsou zpracovávány tak, aby se staly členy kolekce.</span><span class="sxs-lookup"><span data-stu-id="880ef-171">Child elements of the collection property in markup are processed to become members of the collection.</span></span> <span data-ttu-id="880ef-172">Obvykle je přístup kódu k členům kolekce prováděn prostřednictvím metod typu list/Dictionary, jako je například `Add`nebo prostřednictvím indexeru.</span><span class="sxs-lookup"><span data-stu-id="880ef-172">Ordinarily, the code access to the members of a collection is performed through list/dictionary methods such as `Add`, or through an indexer.</span></span> <span data-ttu-id="880ef-173">Ale Syntaxe XAML nepodporuje metody nebo indexery (výjimka: XAML 2009 může podporovat metody, ale použití XAML 2009 omezuje možné použití WPF; viz [xaml 2009 jazykové funkce](../../../desktop-wpf/xaml-services/xaml-2009-language-features.md)).</span><span class="sxs-lookup"><span data-stu-id="880ef-173">But XAML syntax does not support methods or indexers (exception: XAML 2009 can support methods, but using XAML 2009 restricts the possible WPF usages; see [XAML 2009 Language Features](../../../desktop-wpf/xaml-services/xaml-2009-language-features.md)).</span></span> <span data-ttu-id="880ef-174">Kolekce jsou zjevně velice běžným požadavkem pro vytváření stromové struktury prvků a potřebujete nějaký způsob, jak tyto kolekce naplnit v deklarativních XAML.</span><span class="sxs-lookup"><span data-stu-id="880ef-174">Collections are obviously a very common requirement for building a tree of elements, and you need some way to populate these collections in declarative XAML.</span></span> <span data-ttu-id="880ef-175">Proto podřízené prvky vlastnosti kolekce jsou zpracovány jejich přidáním do kolekce, která je hodnotou typu vlastnosti kolekce.</span><span class="sxs-lookup"><span data-stu-id="880ef-175">Therefore, child elements of a collection property are processed by adding them to the collection that is the collection property type value.</span></span>  
  
 <span data-ttu-id="880ef-176">Implementace .NET Framework XAML Services, takže procesor WPF XAML používá následující definici pro to, co představuje vlastnost kolekce.</span><span class="sxs-lookup"><span data-stu-id="880ef-176">The .NET Framework XAML Services implementation and thus the WPF XAML processor uses the following definition for what constitutes a collection property.</span></span> <span data-ttu-id="880ef-177">Typ vlastnosti vlastnosti musí implementovat jednu z následujících možností:</span><span class="sxs-lookup"><span data-stu-id="880ef-177">The property type of the property must implement one of the following:</span></span>  
  
- <span data-ttu-id="880ef-178">Implementuje <xref:System.Collections.IList>.</span><span class="sxs-lookup"><span data-stu-id="880ef-178">Implements <xref:System.Collections.IList>.</span></span>  
  
- <span data-ttu-id="880ef-179">Implementuje <xref:System.Collections.IDictionary> nebo obecný ekvivalent (<xref:System.Collections.Generic.IDictionary%602>).</span><span class="sxs-lookup"><span data-stu-id="880ef-179">Implements <xref:System.Collections.IDictionary> or the generic equivalent (<xref:System.Collections.Generic.IDictionary%602>).</span></span>  
  
- <span data-ttu-id="880ef-180">Je odvozen z <xref:System.Array> (Další informace o polích v jazyce XAML naleznete v tématu [X:Array Markup Extension](../../../desktop-wpf/xaml-services/xarray-markup-extension.md)).</span><span class="sxs-lookup"><span data-stu-id="880ef-180">Derives from <xref:System.Array> (for more information about arrays in XAML, see [x:Array Markup Extension](../../../desktop-wpf/xaml-services/xarray-markup-extension.md).)</span></span>  
  
- <span data-ttu-id="880ef-181">Implementuje <xref:System.Windows.Markup.IAddChild> (rozhraní definované [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]).</span><span class="sxs-lookup"><span data-stu-id="880ef-181">Implements <xref:System.Windows.Markup.IAddChild> (an interface defined by [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]).</span></span>  
  
 <span data-ttu-id="880ef-182">Každý z těchto typů v modulu CLR má `Add` metodu, kterou používá procesor XAML k přidávání položek do základní kolekce při vytváření grafu objektů.</span><span class="sxs-lookup"><span data-stu-id="880ef-182">Each of these types in CLR has an `Add` method, which is used by the XAML processor to add items to the underlying collection when creating the object graph.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="880ef-183">Obecné `List` a rozhraní `Dictionary` (<xref:System.Collections.Generic.IList%601> a <xref:System.Collections.Generic.IDictionary%602>) nejsou podporovány pro zjišťování kolekce procesorem [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] XAML.</span><span class="sxs-lookup"><span data-stu-id="880ef-183">The generic `List` and `Dictionary` interfaces (<xref:System.Collections.Generic.IList%601> and <xref:System.Collections.Generic.IDictionary%602>) are not supported for collection detection by the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] XAML processor.</span></span> <span data-ttu-id="880ef-184">Můžete však použít třídu <xref:System.Collections.Generic.List%601> jako základní třídu, protože implementuje <xref:System.Collections.IList> přímo nebo <xref:System.Collections.Generic.Dictionary%602> jako základní třídu, protože implementuje <xref:System.Collections.IDictionary> přímo.</span><span class="sxs-lookup"><span data-stu-id="880ef-184">However, you can use the <xref:System.Collections.Generic.List%601> class as a base class, because it implements <xref:System.Collections.IList> directly, or <xref:System.Collections.Generic.Dictionary%602> as a base class, because it implements <xref:System.Collections.IDictionary> directly.</span></span>  
  
 <span data-ttu-id="880ef-185">Pokud deklarujete vlastnost, která přebírá kolekci, buďte opatrní při inicializaci této hodnoty vlastnosti v nových instancích typu.</span><span class="sxs-lookup"><span data-stu-id="880ef-185">When you declare a property that takes a collection, be cautious about how that property value is initialized in new instances of the type.</span></span> <span data-ttu-id="880ef-186">Pokud vlastnost neimplementujete jako vlastnost závislosti, pak vlastnost používá pole pro zálohování, které volá konstruktor typu kolekce.</span><span class="sxs-lookup"><span data-stu-id="880ef-186">If you are not implementing the property as a dependency property, then having the property use a backing field that calls the collection type constructor is adequate.</span></span> <span data-ttu-id="880ef-187">Pokud je vlastnost závislá na vlastnosti, může být nutné inicializovat vlastnost kolekce jako součást výchozího konstruktoru typu.</span><span class="sxs-lookup"><span data-stu-id="880ef-187">If your property is a dependency property, then you may need to initialize the collection property as part of the default type constructor.</span></span> <span data-ttu-id="880ef-188">Důvodem je to, že vlastnost závislosti přebírá svou výchozí hodnotu z metadat a obvykle nechcete, aby byla počáteční hodnota vlastnosti kolekce statická, sdílená kolekce.</span><span class="sxs-lookup"><span data-stu-id="880ef-188">This is because a dependency property takes its default value from metadata, and you typically do not want the initial value of a collection property to be a static, shared collection.</span></span> <span data-ttu-id="880ef-189">Měla by existovat instance kolekce pro každý z nich obsahující instanci typu.</span><span class="sxs-lookup"><span data-stu-id="880ef-189">There should be a collection instance per each containing type instance.</span></span> <span data-ttu-id="880ef-190">Další informace najdete v tématu [vlastnosti vlastních závislostí](custom-dependency-properties.md).</span><span class="sxs-lookup"><span data-stu-id="880ef-190">For more information, see [Custom Dependency Properties](custom-dependency-properties.md).</span></span>  
  
 <span data-ttu-id="880ef-191">Můžete implementovat vlastní typ kolekce pro vlastnost kolekce.</span><span class="sxs-lookup"><span data-stu-id="880ef-191">You can implement a custom collection type for your collection property.</span></span> <span data-ttu-id="880ef-192">Z důvodu implicitního zpracování vlastností kolekce není nutné, aby typ vlastní kolekce poskytoval konstruktor bez parametrů, aby jej bylo možné použít v jazyce XAML implicitně.</span><span class="sxs-lookup"><span data-stu-id="880ef-192">Because of implicit collection property treatment, the custom collection type does not need to provide a parameterless constructor in order to be used in XAML implicitly.</span></span> <span data-ttu-id="880ef-193">Můžete však volitelně poskytnout konstruktor bez parametrů pro typ kolekce.</span><span class="sxs-lookup"><span data-stu-id="880ef-193">However, you can optionally provide a parameterless constructor for the collection type.</span></span> <span data-ttu-id="880ef-194">To může být vhodný postup.</span><span class="sxs-lookup"><span data-stu-id="880ef-194">This can be a worthwhile practice.</span></span> <span data-ttu-id="880ef-195">Pokud nezadáte konstruktor bez parametrů, nelze kolekci explicitně deklarovat jako prvek objektu.</span><span class="sxs-lookup"><span data-stu-id="880ef-195">Unless you do provide a parameterless constructor, you cannot explicitly declare the collection as an object element.</span></span> <span data-ttu-id="880ef-196">Někteří autoři značek mohou chtít zobrazit explicitní kolekci jako druh značky.</span><span class="sxs-lookup"><span data-stu-id="880ef-196">Some markup authors might prefer to see the explicit collection as a matter of markup style.</span></span> <span data-ttu-id="880ef-197">Konstruktor bez parametrů může také zjednodušit požadavky na inicializaci při vytváření nových objektů, které používají typ kolekce jako hodnotu vlastnosti.</span><span class="sxs-lookup"><span data-stu-id="880ef-197">Also, a parameterless constructor can simplify the initialization requirements when you create new objects that use your collection type as a property value.</span></span>  
  
<a name="XAMLCONtent"></a>   
## <a name="declaring-xaml-content-properties"></a><span data-ttu-id="880ef-198">Deklarace vlastností obsahu XAML</span><span class="sxs-lookup"><span data-stu-id="880ef-198">Declaring XAML Content Properties</span></span>  
 <span data-ttu-id="880ef-199">Jazyk XAML definuje koncept vlastnosti [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] obsahu.</span><span class="sxs-lookup"><span data-stu-id="880ef-199">The XAML language defines the concept of a [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] content property.</span></span> <span data-ttu-id="880ef-200">Každá třída, která je použitelná v syntaxi objektu, může mít přesně jednu vlastnost obsahu XAML.</span><span class="sxs-lookup"><span data-stu-id="880ef-200">Each class that is usable in object syntax can have exactly one XAML content property.</span></span> <span data-ttu-id="880ef-201">Chcete-li deklarovat vlastnost, která má být vlastností obsahu XAML pro vaši třídu, použijte <xref:System.Windows.Markup.ContentPropertyAttribute> jako součást definice třídy.</span><span class="sxs-lookup"><span data-stu-id="880ef-201">To declare a property to be the XAML content property for your class, apply the <xref:System.Windows.Markup.ContentPropertyAttribute> as part of the class definition.</span></span> <span data-ttu-id="880ef-202">Zadejte název zamýšlené vlastnosti obsahu XAML jako <xref:System.Windows.Markup.ContentPropertyAttribute.Name%2A> v atributu.</span><span class="sxs-lookup"><span data-stu-id="880ef-202">Specify the name of the intended XAML content property as the <xref:System.Windows.Markup.ContentPropertyAttribute.Name%2A> in the attribute.</span></span> <span data-ttu-id="880ef-203">Vlastnost je zadána jako řetězec podle názvu, nikoli jako konstrukce reflexe, jako je například <xref:System.Reflection.PropertyInfo>.</span><span class="sxs-lookup"><span data-stu-id="880ef-203">The property is specified as a string by name, not as a reflection construct such as <xref:System.Reflection.PropertyInfo>.</span></span>  
  
 <span data-ttu-id="880ef-204">Můžete určit vlastnost kolekce jako vlastnost obsahu XAML.</span><span class="sxs-lookup"><span data-stu-id="880ef-204">You can specify a collection property to be the XAML content property.</span></span> <span data-ttu-id="880ef-205">Výsledkem je použití této vlastnosti, kdy prvek objektu může mít jeden nebo více podřízených elementů, aniž by se musely přesáhnout prvky objektu kolekce nebo značky prvků vlastností.</span><span class="sxs-lookup"><span data-stu-id="880ef-205">This results in a usage for that property whereby the object element can have one or more child elements, without any intervening collection object elements or property element tags.</span></span> <span data-ttu-id="880ef-206">Tyto prvky se pak považují za hodnotu vlastnosti obsahu XAML a přidají se do instance back-Collection.</span><span class="sxs-lookup"><span data-stu-id="880ef-206">These elements are then treated as the value for the XAML content property and added to the backing collection instance.</span></span>  
  
 <span data-ttu-id="880ef-207">Některé existující vlastnosti obsahu XAML používají typ vlastnosti `Object`.</span><span class="sxs-lookup"><span data-stu-id="880ef-207">Some existing XAML content properties use the property type of `Object`.</span></span> <span data-ttu-id="880ef-208">To umožňuje vlastnost obsahu XAML, která může přijímat primitivní hodnoty, jako je například <xref:System.String>, a také přebírat hodnotu jediného referenčního objektu.</span><span class="sxs-lookup"><span data-stu-id="880ef-208">This enables a XAML content property that can take primitive values such as a <xref:System.String> as well as taking a single reference object value.</span></span> <span data-ttu-id="880ef-209">Pokud budete postupovat podle tohoto modelu, je váš typ zodpovědný za určení typu a také pro zpracování možných typů.</span><span class="sxs-lookup"><span data-stu-id="880ef-209">If you follow this model, your type is responsible for type determination as well as the handling of possible types.</span></span> <span data-ttu-id="880ef-210">Typickým důvodem pro <xref:System.Object> typu obsahu je podpora jednoduchého způsobu přidání obsahu objektu jako řetězce (který přijímá výchozí úpravu prezentace) nebo pokročilým způsobům přidání obsahu objektu, který určuje nevýchozí nebo dodatečná data.</span><span class="sxs-lookup"><span data-stu-id="880ef-210">The typical reason for an <xref:System.Object> content type is to support both a simple means of adding object content as a string (which receives a default presentation treatment), or an advanced means of adding object content that specifies a non-default presentation or additional data.</span></span>  
  
<a name="Serializing"></a>   
## <a name="serializing-xaml"></a><span data-ttu-id="880ef-211">Serializace XAML</span><span class="sxs-lookup"><span data-stu-id="880ef-211">Serializing XAML</span></span>  
 <span data-ttu-id="880ef-212">V některých případech, například pokud jste autorem ovládacího prvku, můžete také zajistit, aby všechny reprezentace objektů, které lze vytvořit v jazyce XAML, mohla být také serializována zpět na ekvivalentní kód XAML.</span><span class="sxs-lookup"><span data-stu-id="880ef-212">For certain scenarios, such as if you are a control author, you may also want to assure that any object representation that can be instantiated in XAML can also be serialized back to equivalent XAML markup.</span></span> <span data-ttu-id="880ef-213">Požadavky na serializaci nejsou popsány v tomto tématu.</span><span class="sxs-lookup"><span data-stu-id="880ef-213">Serialization requirements are not described in this topic.</span></span> <span data-ttu-id="880ef-214">Viz téma [Přehled vytváření](../controls/control-authoring-overview.md) a [strom elementů a serializace prvku](element-tree-and-serialization.md).</span><span class="sxs-lookup"><span data-stu-id="880ef-214">See [Control Authoring Overview](../controls/control-authoring-overview.md) and [Element Tree and Serialization](element-tree-and-serialization.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="880ef-215">Viz také:</span><span class="sxs-lookup"><span data-stu-id="880ef-215">See also</span></span>

- [<span data-ttu-id="880ef-216">Přehled XAML (WPF)</span><span class="sxs-lookup"><span data-stu-id="880ef-216">XAML Overview (WPF)</span></span>](../../../desktop-wpf/fundamentals/xaml.md)
- [<span data-ttu-id="880ef-217">Vlastní vlastnosti závislosti</span><span class="sxs-lookup"><span data-stu-id="880ef-217">Custom Dependency Properties</span></span>](custom-dependency-properties.md)
- [<span data-ttu-id="880ef-218">Přehled vytváření ovládacích prvků</span><span class="sxs-lookup"><span data-stu-id="880ef-218">Control Authoring Overview</span></span>](../controls/control-authoring-overview.md)
- [<span data-ttu-id="880ef-219">Přehled základních elementů</span><span class="sxs-lookup"><span data-stu-id="880ef-219">Base Elements Overview</span></span>](base-elements-overview.md)
- [<span data-ttu-id="880ef-220">Vlastnosti závislostí a načítání XAML</span><span class="sxs-lookup"><span data-stu-id="880ef-220">XAML Loading and Dependency Properties</span></span>](xaml-loading-and-dependency-properties.md)
