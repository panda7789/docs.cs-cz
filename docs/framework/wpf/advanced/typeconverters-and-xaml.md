---
title: TypeConverters a XAML
ms.date: 03/30/2017
helpviewer_keywords:
- XAML [WPF], TypeConverter class
ms.assetid: f6313e4d-e89d-497d-ac87-b43511a1ae4b
ms.openlocfilehash: 94cfce44d5702e0550310723ec56184096165436
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 03/12/2020
ms.locfileid: "79187298"
---
# <a name="typeconverters-and-xaml"></a><span data-ttu-id="d7b74-102">TypeConverters a XAML</span><span class="sxs-lookup"><span data-stu-id="d7b74-102">TypeConverters and XAML</span></span>
<span data-ttu-id="d7b74-103">Toto téma představuje účel převodu typu z řetězce jako obecné funkce jazyka XAML.</span><span class="sxs-lookup"><span data-stu-id="d7b74-103">This topic introduces the purpose of type conversion from string as a general XAML language feature.</span></span> <span data-ttu-id="d7b74-104">V rozhraní .NET <xref:System.ComponentModel.TypeConverter> Framework slouží třída konkrétnímu účelu jako součást implementace spravované vlastní třídy, kterou lze použít jako hodnotu vlastnosti v použití atributu XAML.</span><span class="sxs-lookup"><span data-stu-id="d7b74-104">In the .NET Framework, the <xref:System.ComponentModel.TypeConverter> class serves a particular purpose as part of the implementation for a managed custom class that can be used as a property value in XAML attribute usage.</span></span> <span data-ttu-id="d7b74-105">Pokud napíšete vlastní třídu a chcete, aby instance vaší třídy byly použitelné jako hodnoty atributů nastavitelné XAML, možná budete muset použít a <xref:System.ComponentModel.TypeConverterAttribute> pro vaši třídu, napsat vlastní <xref:System.ComponentModel.TypeConverter> třídu nebo obojí.</span><span class="sxs-lookup"><span data-stu-id="d7b74-105">If you write a custom class, and you want instances of your class to be usable as XAML settable attribute values, you might need to apply a <xref:System.ComponentModel.TypeConverterAttribute> to your class, write a custom <xref:System.ComponentModel.TypeConverter> class, or both.</span></span>  

## <a name="type-conversion-concepts"></a><span data-ttu-id="d7b74-106">Koncepty převodu typů</span><span class="sxs-lookup"><span data-stu-id="d7b74-106">Type Conversion Concepts</span></span>  
  
### <a name="xaml-and-string-values"></a><span data-ttu-id="d7b74-107">Hodnoty XAML a řetězce</span><span class="sxs-lookup"><span data-stu-id="d7b74-107">XAML and String Values</span></span>  
 <span data-ttu-id="d7b74-108">Když nastavíte hodnotu atributu v souboru XAML, počáteční typ této hodnoty je řetězec v čistém textu.</span><span class="sxs-lookup"><span data-stu-id="d7b74-108">When you set an attribute value in a XAML file, the initial type of that value is a string in pure text.</span></span> <span data-ttu-id="d7b74-109">Dokonce i další <xref:System.Double> primitiva, jako jsou zpočátku textové řetězce procesoru XAML.</span><span class="sxs-lookup"><span data-stu-id="d7b74-109">Even other primitives such as <xref:System.Double> are initially text strings to a XAML processor.</span></span>  
  
 <span data-ttu-id="d7b74-110">Procesor XAML potřebuje ke zpracování hodnoty atributu dva kusy informací.</span><span class="sxs-lookup"><span data-stu-id="d7b74-110">A XAML processor needs two pieces of information in order to process an attribute value.</span></span> <span data-ttu-id="d7b74-111">První informace je typ hodnoty vlastnosti, která je nastavena.</span><span class="sxs-lookup"><span data-stu-id="d7b74-111">The first piece of information is the value type of the property that is being set.</span></span> <span data-ttu-id="d7b74-112">Libovolný řetězec, který definuje hodnotu atributu a který je zpracován v XAML, musí být nakonec převeden nebo vyřešen na hodnotu tohoto typu.</span><span class="sxs-lookup"><span data-stu-id="d7b74-112">Any string that defines an attribute value and that is processed in XAML must ultimately be converted or resolved to a value of that type.</span></span> <span data-ttu-id="d7b74-113">Pokud je hodnota primitivní, který je chápán analyzátorem XAML (například číselnou hodnotou), dojde k přímému převodu řetězce.</span><span class="sxs-lookup"><span data-stu-id="d7b74-113">If the value is a primitive that is understood by the XAML parser (such as a numeric value), a direct conversion of the string is attempted.</span></span> <span data-ttu-id="d7b74-114">Pokud je hodnota výčtu, řetězec se používá ke kontrole shody názvu s pojmenovanou konstantou v tomto výčtu.</span><span class="sxs-lookup"><span data-stu-id="d7b74-114">If the value is an enumeration, the string is used to check for a name match to a named constant in that enumeration.</span></span> <span data-ttu-id="d7b74-115">Pokud hodnota není ani parser pochopil primitivní ani výčtu, pak dotyčný typ musí být schopen poskytnout instanci typu nebo hodnotu, na základě převedeného řetězce.</span><span class="sxs-lookup"><span data-stu-id="d7b74-115">If the value is neither a parser-understood primitive nor an enumeration, then the type in question must be able to provide an instance of the type, or a value, based on a converted string.</span></span> <span data-ttu-id="d7b74-116">To se provádí označením třídy převaděče typu.</span><span class="sxs-lookup"><span data-stu-id="d7b74-116">This is done by indicating a type converter class.</span></span> <span data-ttu-id="d7b74-117">Převaděč typu je efektivně pomocná třída pro poskytování hodnot jiné třídy, a to jak pro scénář XAML, tak potenciálně pro volání kódu v kódu .NET.</span><span class="sxs-lookup"><span data-stu-id="d7b74-117">The type converter is effectively a helper class for providing values of another class, both for the XAML scenario and also potentially for code calls in .NET code.</span></span>  
  
### <a name="using-existing-type-conversion-behavior-in-xaml"></a><span data-ttu-id="d7b74-118">Použití existujícího chování převodu typu v xaml</span><span class="sxs-lookup"><span data-stu-id="d7b74-118">Using Existing Type Conversion Behavior in XAML</span></span>  
 <span data-ttu-id="d7b74-119">V závislosti na vaší obeznámenosti s základními koncepty XAML je možné, že již používáte chování převodu typu v základní aplikaci XAML, aniž byste si to uvědomili.</span><span class="sxs-lookup"><span data-stu-id="d7b74-119">Depending on your familiarity with the underlying XAML concepts, you may already be using type conversion behavior in basic application XAML without realizing it.</span></span> <span data-ttu-id="d7b74-120">Například WPF definuje doslova stovky vlastností, které <xref:System.Windows.Point>berou hodnotu typu .</span><span class="sxs-lookup"><span data-stu-id="d7b74-120">For instance, WPF defines literally hundreds of properties that take a value of type <xref:System.Windows.Point>.</span></span> <span data-ttu-id="d7b74-121">A <xref:System.Windows.Point> je hodnota, která popisuje souřadnici ve dvourozměrném souřadnicovém prostoru a ve skutečnosti má pouze dvě důležité vlastnosti: <xref:System.Windows.Point.X%2A> a <xref:System.Windows.Point.Y%2A>.</span><span class="sxs-lookup"><span data-stu-id="d7b74-121">A <xref:System.Windows.Point> is a value that describes a coordinate in a two-dimensional coordinate space, and it really just has two important properties: <xref:System.Windows.Point.X%2A> and <xref:System.Windows.Point.Y%2A>.</span></span> <span data-ttu-id="d7b74-122">Když zadáte bod v XAML, zadáte jej jako řetězec s oddělovačem (obvykle <xref:System.Windows.Point.X%2A> čárkou) mezi hodnotami a <xref:System.Windows.Point.Y%2A> hodnotami, které zadáte.</span><span class="sxs-lookup"><span data-stu-id="d7b74-122">When you specify a point in XAML, you specify it as a string with a delimiter (typically a comma) between the <xref:System.Windows.Point.X%2A> and <xref:System.Windows.Point.Y%2A> values you provide.</span></span> <span data-ttu-id="d7b74-123">Například: `<LinearGradientBrush StartPoint="0,0" EndPoint="1,1"/>`.</span><span class="sxs-lookup"><span data-stu-id="d7b74-123">For example: `<LinearGradientBrush StartPoint="0,0" EndPoint="1,1"/>`.</span></span>  
  
 <span data-ttu-id="d7b74-124">Dokonce i tento <xref:System.Windows.Point> jednoduchý typ a jeho jednoduché použití v XAML zahrnují typ ový převodník.</span><span class="sxs-lookup"><span data-stu-id="d7b74-124">Even this simple type of <xref:System.Windows.Point> and its simple usage in XAML involve a type converter.</span></span> <span data-ttu-id="d7b74-125">V tomto případě je <xref:System.Windows.PointConverter>třída .</span><span class="sxs-lookup"><span data-stu-id="d7b74-125">In this case that is the class <xref:System.Windows.PointConverter>.</span></span>  
  
 <span data-ttu-id="d7b74-126">Převaděč <xref:System.Windows.Point> typu pro definované na úrovni třídy zjednodušuje <xref:System.Windows.Point>použití značek všech vlastností, které se .</span><span class="sxs-lookup"><span data-stu-id="d7b74-126">The type converter for <xref:System.Windows.Point> defined at the class level streamlines the markup usages of all properties that take <xref:System.Windows.Point>.</span></span> <span data-ttu-id="d7b74-127">Bez převaděče typu zde budete potřebovat následující mnohem podrobnější značky pro stejný příklad, který byl uveden dříve:</span><span class="sxs-lookup"><span data-stu-id="d7b74-127">Without a type converter here, you would need the following much more verbose markup for the same example shown previously:</span></span>  

```xaml
<LinearGradientBrush>
  <LinearGradientBrush.StartPoint>
    <Point X="0" Y="0"/>
  </LinearGradientBrush.StartPoint>
  <LinearGradientBrush.EndPoint>
    <Point X="1" Y="1"/>
  </LinearGradientBrush.EndPoint>
</LinearGradientBrush>
 ```
  
 <span data-ttu-id="d7b74-128">Zda použít typ převodní řetězec nebo podrobnější ekvivalentní syntaxe je obecně volba stylu kódování.</span><span class="sxs-lookup"><span data-stu-id="d7b74-128">Whether to use the type conversion string or a more verbose equivalent syntax is generally a coding style choice.</span></span> <span data-ttu-id="d7b74-129">Pracovní postup nástrojů XAML může také ovlivnit nastavení hodnot.</span><span class="sxs-lookup"><span data-stu-id="d7b74-129">Your XAML tooling workflow might also influence how values are set.</span></span> <span data-ttu-id="d7b74-130">Některé nástroje XAML mají tendenci vyzařovat nejpodrobnější formu značky, protože je snazší round-trip na návrháře zobrazení nebo vlastní serializace mechanismus.</span><span class="sxs-lookup"><span data-stu-id="d7b74-130">Some XAML tools tend to emit the most verbose form of the markup because it is easier to round-trip to designer views or its own serialization mechanism.</span></span>  
  
 <span data-ttu-id="d7b74-131">Existující převaděče typu lze obecně zjistit na WPF a .NET Framework typy kontrolou <xref:System.ComponentModel.TypeConverterAttribute>třídy (nebo vlastnost) na přítomnost aplikované .</span><span class="sxs-lookup"><span data-stu-id="d7b74-131">Existing type converters can generally be discovered on WPF and .NET Framework types by checking a class (or property) for the presence of an applied <xref:System.ComponentModel.TypeConverterAttribute>.</span></span> <span data-ttu-id="d7b74-132">Tento atribut pojmenuje třídu, která je podpůrným převaděčem typu pro hodnoty tohoto typu, pro účely XAML i potenciálně pro jiné účely.</span><span class="sxs-lookup"><span data-stu-id="d7b74-132">This attribute will name the class that is the supporting type converter for values of that type, for XAML purposes as well as potentially other purposes.</span></span>  
  
### <a name="type-converters-and-markup-extensions"></a><span data-ttu-id="d7b74-133">Převaděče typů a rozšíření o značky</span><span class="sxs-lookup"><span data-stu-id="d7b74-133">Type Converters and Markup Extensions</span></span>  
 <span data-ttu-id="d7b74-134">Rozšíření značek a převaděče typů vyplňují ortogonové role z hlediska chování procesoru XAML a scénářů, u kterých jsou použity.</span><span class="sxs-lookup"><span data-stu-id="d7b74-134">Markup extensions and type converters fill orthogonal roles in terms of XAML processor behavior and the scenarios that they are applied to.</span></span> <span data-ttu-id="d7b74-135">Přestože kontext je k dispozici pro použití rozšíření značek, typ převodu chování vlastností, kde rozšíření značky poskytuje hodnotu je obecně není kontrolována v implementacích rozšíření značky.</span><span class="sxs-lookup"><span data-stu-id="d7b74-135">Although context is available for markup extension usages, type conversion behavior of properties where a markup extension provides a value is generally is not checked in the markup extension implementations.</span></span> <span data-ttu-id="d7b74-136">Jinými slovy, i když rozšíření značky vrátí `ProvideValue` textový řetězec jako svůj výstup, zadejte chování převodu na tento řetězec, jak je použito na konkrétní vlastnost nebo typ hodnoty vlastnosti není vyvolána, Obecně, účelem rozšíření značky je zpracovat řetězec a vrátit objekt bez jakéhokoli převaděče typu.</span><span class="sxs-lookup"><span data-stu-id="d7b74-136">In other words, even if a markup extension returns a text string as its `ProvideValue` output, type conversion behavior on that string as applied to a specific property or property value type is not invoked, Generally, the purpose of a markup extension is to process a string and return an object without any type converter involved.</span></span>  
  
 <span data-ttu-id="d7b74-137">Jedna běžná situace, kdy je nutné rozšíření značek, nikoli převaděč typu, je odkaz na objekt, který již existuje.</span><span class="sxs-lookup"><span data-stu-id="d7b74-137">One common situation where a markup extension is necessary rather than a type converter is to make a reference to an object that already exists.</span></span> <span data-ttu-id="d7b74-138">V nejlepším případě převaděč bezstavového typu může generovat pouze novou instanci, která nemusí být žádoucí.</span><span class="sxs-lookup"><span data-stu-id="d7b74-138">At best, a stateless type converter could only generate a new instance, which might not be desirable.</span></span> <span data-ttu-id="d7b74-139">Další informace o rozšířeních značek naleznete v [tématech Rozšíření značek a WPF XAML](markup-extensions-and-wpf-xaml.md).</span><span class="sxs-lookup"><span data-stu-id="d7b74-139">For more information on markup extensions, see [Markup Extensions and WPF XAML](markup-extensions-and-wpf-xaml.md).</span></span>  
  
### <a name="native-type-converters"></a><span data-ttu-id="d7b74-140">Převaděče nativního typu</span><span class="sxs-lookup"><span data-stu-id="d7b74-140">Native Type Converters</span></span>  
 <span data-ttu-id="d7b74-141">V wpf a .NET Framework implementace analyzátoru XAML existují určité typy, které mají nativní typ zpracování převodu, ale nejsou typy, které by mohly být konvenčně považovány za primitiva.</span><span class="sxs-lookup"><span data-stu-id="d7b74-141">In the WPF and .NET Framework implementation of the XAML parser, there are certain types that have native type conversion handling, yet are not types that might conventionally be thought of as primitives.</span></span> <span data-ttu-id="d7b74-142">Příkladem takového typu je <xref:System.DateTime>.</span><span class="sxs-lookup"><span data-stu-id="d7b74-142">An example of such a type is <xref:System.DateTime>.</span></span> <span data-ttu-id="d7b74-143">Důvod je založen na tom, jak funguje architektura <xref:System.DateTime> rozhraní .NET Framework: typ je definován v mscorlib, nejzákladnější knihovně v rozhraní .NET.</span><span class="sxs-lookup"><span data-stu-id="d7b74-143">The reason for this is based on how the .NET Framework architecture works: the type <xref:System.DateTime> is defined in mscorlib, the most basic library in .NET.</span></span> <span data-ttu-id="d7b74-144"><xref:System.DateTime>není povoleno připsat atribut, který pochází z jiného sestavení, které<xref:System.ComponentModel.TypeConverterAttribute> zavádí závislost (je ze systému), takže obvyklý mechanismus zjišťování převaděče typu přiřazením nelze podporovat.</span><span class="sxs-lookup"><span data-stu-id="d7b74-144"><xref:System.DateTime> is not permitted to be attributed with an attribute that comes from another assembly that introduces a dependency (<xref:System.ComponentModel.TypeConverterAttribute> is from System) so the usual type converter discovery mechanism by attributing cannot be supported.</span></span> <span data-ttu-id="d7b74-145">Místo toho analyzátor XAML má seznam typů, které potřebují takové nativní zpracování a zpracovává je podobně jako zpracování skutečných primitiv.</span><span class="sxs-lookup"><span data-stu-id="d7b74-145">Instead, the XAML parser has a list of types that need such native processing and processes these similarly to how the true primitives are processed.</span></span> <span data-ttu-id="d7b74-146">(V <xref:System.DateTime> případě, že se <xref:System.DateTime.Parse%2A>jedná o volání .)</span><span class="sxs-lookup"><span data-stu-id="d7b74-146">(In the case of <xref:System.DateTime> this involves a call to <xref:System.DateTime.Parse%2A>.)</span></span>  
  
<a name="Implementing_a_Type_Converter"></a>
## <a name="implementing-a-type-converter"></a><span data-ttu-id="d7b74-147">Implementace převaděče typů</span><span class="sxs-lookup"><span data-stu-id="d7b74-147">Implementing a Type Converter</span></span>  
  
### <a name="typeconverter"></a><span data-ttu-id="d7b74-148">TypeConverter</span><span class="sxs-lookup"><span data-stu-id="d7b74-148">TypeConverter</span></span>  
 <span data-ttu-id="d7b74-149">V <xref:System.Windows.Point> předchozím příkladu byla <xref:System.Windows.PointConverter> uvedena třída.</span><span class="sxs-lookup"><span data-stu-id="d7b74-149">In the <xref:System.Windows.Point> example given previously, the class <xref:System.Windows.PointConverter> was mentioned.</span></span> <span data-ttu-id="d7b74-150">Pro implementací .NET XAML jsou všechny převaděče typu, které se používají <xref:System.ComponentModel.TypeConverter>pro účely XAML, třídy, které jsou odvozeny ze základní třídy .</span><span class="sxs-lookup"><span data-stu-id="d7b74-150">For .NET implementations of XAML, all type converters that are used for XAML purposes are classes that derive from the base class <xref:System.ComponentModel.TypeConverter>.</span></span> <span data-ttu-id="d7b74-151">Třída <xref:System.ComponentModel.TypeConverter> existovala ve verzích rozhraní .NET Framework, které předcházejí existenci xaml; jedním z jeho původních použití bylo poskytnout převod řetězců pro dialogy vlastností ve vizuálních návrhářích.</span><span class="sxs-lookup"><span data-stu-id="d7b74-151">The <xref:System.ComponentModel.TypeConverter> class existed in versions of .NET Framework that precede the existence of XAML; one of its original usages was to provide string conversion for property dialogs in visual designers.</span></span> <span data-ttu-id="d7b74-152">Pro XAML <xref:System.ComponentModel.TypeConverter> role je rozšířena tak, aby zahrnovala základní třídu pro převody na řetězec a z řetězce, které umožňují analýzu hodnoty atributu řetězce a případně zpracování hodnoty run-time určité vlastnosti objektu zpět do řetězce pro serializaci jako atribut.</span><span class="sxs-lookup"><span data-stu-id="d7b74-152">For XAML, the role of <xref:System.ComponentModel.TypeConverter> is expanded to include being the base class for to-string and from-string conversions that enable parsing a string attribute value, and possibly processing a run-time value of a particular object property back into a string for serialization as an attribute.</span></span>  
  
 <span data-ttu-id="d7b74-153"><xref:System.ComponentModel.TypeConverter>definuje čtyři členy, které jsou důležité pro převod do a z řetězců pro účely zpracování XAML:</span><span class="sxs-lookup"><span data-stu-id="d7b74-153"><xref:System.ComponentModel.TypeConverter> defines four members that are relevant for converting to and from strings for XAML processing purposes:</span></span>  
  
- <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A>  
  
- <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A>  
  
- <xref:System.ComponentModel.TypeConverter.ConvertTo%2A>  
  
- <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A>  
  
 <span data-ttu-id="d7b74-154">Z nich je <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A>nejdůležitější metodou .</span><span class="sxs-lookup"><span data-stu-id="d7b74-154">Of these, the most important method is <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A>.</span></span> <span data-ttu-id="d7b74-155">Tato metoda převede vstupní řetězec na požadovaný typ objektu.</span><span class="sxs-lookup"><span data-stu-id="d7b74-155">This method converts the input string to the required object type.</span></span> <span data-ttu-id="d7b74-156">Přísně vzato, <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> metoda by mohla být implementována převést mnohem širší škálu typů do zamýšleného typu určení převaděče, a tak sloužit účelům, které přesahují XAML, jako je podpora převodů za běhu, ale pro účely XAML je to pouze cesta kódu, která může zpracovat <xref:System.String> vstup, na kterém záleží.</span><span class="sxs-lookup"><span data-stu-id="d7b74-156">Strictly speaking, the <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> method could be implemented to convert a much wider range of types into the converter's intended destination type, and thus serve purposes that extend beyond XAML such as supporting run-time conversions, but for XAML purposes it is only the code path that can process a <xref:System.String> input that matters.</span></span>  
  
 <span data-ttu-id="d7b74-157">Další nejdůležitější metodou <xref:System.ComponentModel.TypeConverter.ConvertTo%2A>je .</span><span class="sxs-lookup"><span data-stu-id="d7b74-157">The next most important method is <xref:System.ComponentModel.TypeConverter.ConvertTo%2A>.</span></span> <span data-ttu-id="d7b74-158">Pokud je aplikace převedena na reprezentaci značek (například pokud je uložena <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> do XAML jako soubor), je zodpovědná za vytvoření reprezentace značek.</span><span class="sxs-lookup"><span data-stu-id="d7b74-158">If an application is converted to a markup representation (for instance, if it is saved to XAML as a file), <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> is responsible for producing a markup representation.</span></span> <span data-ttu-id="d7b74-159">V tomto případě cesta kódu, která je důležitá pro `destinationType` <xref:System.String> XAML je při předání a .</span><span class="sxs-lookup"><span data-stu-id="d7b74-159">In this case, the code path that matters for XAML is when you pass a `destinationType` of <xref:System.String> .</span></span>  
  
 <span data-ttu-id="d7b74-160"><xref:System.ComponentModel.TypeConverter.CanConvertTo%2A>a <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A> jsou podpůrné metody, které se používají, <xref:System.ComponentModel.TypeConverter> když služba dotazuje možnosti implementace.</span><span class="sxs-lookup"><span data-stu-id="d7b74-160"><xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> and <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A> are support methods that are used when a service queries the capabilities of the <xref:System.ComponentModel.TypeConverter> implementation.</span></span> <span data-ttu-id="d7b74-161">Je nutné implementovat `true` tyto metody vrátit pro případy specifické pro typ, které ekvivalentní metody převodu podporují převaděč.</span><span class="sxs-lookup"><span data-stu-id="d7b74-161">You must implement these methods to return `true` for type-specific cases that the equivalent conversion methods of your converter support.</span></span> <span data-ttu-id="d7b74-162">Pro účely XAML to <xref:System.String> obecně znamená typ.</span><span class="sxs-lookup"><span data-stu-id="d7b74-162">For XAML purposes, this generally means the <xref:System.String> type.</span></span>  
  
### <a name="culture-information-and-type-converters-for-xaml"></a><span data-ttu-id="d7b74-163">Informace o jazykové verzi a převaděče typů pro XAML</span><span class="sxs-lookup"><span data-stu-id="d7b74-163">Culture Information and Type Converters for XAML</span></span>  

 <span data-ttu-id="d7b74-164">Každá <xref:System.ComponentModel.TypeConverter> implementace může mít vlastní interpretaci toho, co představuje platný řetězec pro převod a můžete také použít nebo ignorovat popis typu předaný jako parametry.</span><span class="sxs-lookup"><span data-stu-id="d7b74-164">Each <xref:System.ComponentModel.TypeConverter> implementation can have its own interpretation of what constitutes a valid string for a conversion, and can also use or ignore the type description passed as parameters.</span></span> <span data-ttu-id="d7b74-165">Je důležité hledisko s ohledem na jazykovou verzi a převod typu XAML.</span><span class="sxs-lookup"><span data-stu-id="d7b74-165">There is an important consideration with regard to culture and XAML type conversion.</span></span> <span data-ttu-id="d7b74-166">Použití lokalizovatelných řetězců jako hodnot atributů je zcela podporováno xaml.</span><span class="sxs-lookup"><span data-stu-id="d7b74-166">Using localizable strings as attribute values is entirely supported by XAML.</span></span> <span data-ttu-id="d7b74-167">Ale použití tohoto lokalizovatelného řetězce jako vstupu převaděče typů se specifickými požadavky na jazykovou verzi není podporováno, protože převaděče typů pro hodnoty atributů XAML zahrnují nutně chování analýzy pevného jazyka pomocí `en-US` jazykové verze.</span><span class="sxs-lookup"><span data-stu-id="d7b74-167">But using that localizable string as type converter input with specific culture requirements is not supported, because type converters for XAML attribute values involve a necessarily fixed-language parsing behavior, using `en-US` culture.</span></span> <span data-ttu-id="d7b74-168">Další informace o důvodech návrhu tohoto omezení naleznete ve specifikaci jazyka XAML ([\[MS-XAML\]](https://download.microsoft.com/download/0/A/6/0A6F7755-9AF5-448B-907D-13985ACCF53E/[MS-XAML].pdf).</span><span class="sxs-lookup"><span data-stu-id="d7b74-168">For more information on the design reasons for this restriction, you should consult the XAML language specification ([\[MS-XAML\]](https://download.microsoft.com/download/0/A/6/0A6F7755-9AF5-448B-907D-13985ACCF53E/[MS-XAML].pdf).</span></span>  
  
 <span data-ttu-id="d7b74-169">Jako příklad, kde může být problém jazykové verze, některé jazykové verze používají čárku jako oddělovač desetinných bodů pro čísla.</span><span class="sxs-lookup"><span data-stu-id="d7b74-169">As an example where culture can be an issue, some cultures use a comma as their decimal point delimiter for numbers.</span></span> <span data-ttu-id="d7b74-170">To bude kolidovat s chováním, které mají mnoho převaděčů typu WPF XAML, což je použití čárky jako oddělovače (na základě historických precedentů, jako je například společný formulář X,Y nebo seznamy oddělené čárkami).</span><span class="sxs-lookup"><span data-stu-id="d7b74-170">This will collide with the behavior that many of the WPF XAML type converters have, which is to use a comma as a delimiter (based on historical precedents such as the common X,Y form, or comma delimited lists).</span></span> <span data-ttu-id="d7b74-171">Problém nevyřeší ani předání moru `Language` `xml:lang` v `sl-SI` okolním xaml (nastavení nebo jazykové verzi, příklad jazykové verze, která používá čárku pro desetinné číslo tímto způsobem).</span><span class="sxs-lookup"><span data-stu-id="d7b74-171">Even passing a culture in the surrounding XAML (setting `Language` or `xml:lang` to the `sl-SI` culture, an example of a culture that uses a comma for decimal in this way) does not solve the issue.</span></span>  
  
### <a name="implementing-convertfrom"></a><span data-ttu-id="d7b74-172">Implementace convertfrom</span><span class="sxs-lookup"><span data-stu-id="d7b74-172">Implementing ConvertFrom</span></span>  
 <span data-ttu-id="d7b74-173">Chcete-li být <xref:System.ComponentModel.TypeConverter> použitelné jako implementace, která <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> podporuje XAML, metoda pro `value` tento převaděč musí přijmout řetězec jako parametr.</span><span class="sxs-lookup"><span data-stu-id="d7b74-173">To be usable as a <xref:System.ComponentModel.TypeConverter> implementation that supports XAML, the <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> method for that converter must accept a string as the `value` parameter.</span></span> <span data-ttu-id="d7b74-174">Pokud řetězec byl v platném formátu a <xref:System.ComponentModel.TypeConverter> může být převeden implementací, pak vrácený objekt musí podporovat přetypování na typ očekávaný vlastností.</span><span class="sxs-lookup"><span data-stu-id="d7b74-174">If the string was in valid format, and can be converted by the <xref:System.ComponentModel.TypeConverter> implementation, then the returned object must support a cast to the type expected by the property.</span></span> <span data-ttu-id="d7b74-175">V opačném <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> případě `null`musí být implementace vrácena .</span><span class="sxs-lookup"><span data-stu-id="d7b74-175">Otherwise, the <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> implementation must return `null`.</span></span>  
  
 <span data-ttu-id="d7b74-176">Každá <xref:System.ComponentModel.TypeConverter> implementace může mít vlastní interpretaci toho, co představuje platný řetězec pro převod a můžete také použít nebo ignorovat popis typu nebo kontexty jazykové verze předané jako parametry.</span><span class="sxs-lookup"><span data-stu-id="d7b74-176">Each <xref:System.ComponentModel.TypeConverter> implementation can have its own interpretation of what constitutes a valid string for a conversion, and can also use or ignore the type description or culture contexts passed as parameters.</span></span> <span data-ttu-id="d7b74-177">Zpracování WPF XAML však nemusí předat hodnoty kontextu popisu typu ve všech případech `xml:lang`a také nemusí předat jazykovou verzi založenou na .</span><span class="sxs-lookup"><span data-stu-id="d7b74-177">However, the WPF XAML processing might not pass values to the type description context in all cases, and also might not pass culture based on `xml:lang`.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="d7b74-178">Nepoužívejte znaky složené závorky, zejména {, jako možný prvek formátu řetězce.</span><span class="sxs-lookup"><span data-stu-id="d7b74-178">Do not use the curly brace characters, particularly {, as a possible element of your string format.</span></span> <span data-ttu-id="d7b74-179">Tyto znaky jsou vyhrazeny jako položka a ukončení pro posloupnost rozšíření značek.</span><span class="sxs-lookup"><span data-stu-id="d7b74-179">These characters are reserved as the entry and exit for a markup extension sequence.</span></span>  
  
### <a name="implementing-convertto"></a><span data-ttu-id="d7b74-180">Implementace převodu</span><span class="sxs-lookup"><span data-stu-id="d7b74-180">Implementing ConvertTo</span></span>  
 <span data-ttu-id="d7b74-181"><xref:System.ComponentModel.TypeConverter.ConvertTo%2A>je potenciálně používán pro podporu serializace.</span><span class="sxs-lookup"><span data-stu-id="d7b74-181"><xref:System.ComponentModel.TypeConverter.ConvertTo%2A> is potentially used for serialization support.</span></span> <span data-ttu-id="d7b74-182">Podpora serializace <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> prostřednictvím pro vlastní typ a jeho převaděč typu není absolutní požadavek.</span><span class="sxs-lookup"><span data-stu-id="d7b74-182">Serialization support through <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> for your custom type and its type converter is not an absolute requirement.</span></span> <span data-ttu-id="d7b74-183">Pokud však implementujete ovládací prvek nebo používáte serializaci jako součást funkcí nebo <xref:System.ComponentModel.TypeConverter.ConvertTo%2A>návrhu vaší třídy, měli byste implementovat .</span><span class="sxs-lookup"><span data-stu-id="d7b74-183">However, if you are implementing a control, or using serialization of as part of the features or design of your class, you should implement <xref:System.ComponentModel.TypeConverter.ConvertTo%2A>.</span></span>  
  
 <span data-ttu-id="d7b74-184">Chcete-li být <xref:System.ComponentModel.TypeConverter> použitelné jako implementace, která <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> podporuje XAML, metoda pro tento převaděč musí `value` přijmout instanci typu (nebo hodnoty) je podporován jako parametr.</span><span class="sxs-lookup"><span data-stu-id="d7b74-184">To be usable as a <xref:System.ComponentModel.TypeConverter> implementation that supports XAML, the <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> method for that converter must accept an instance of the type (or a value) being supported as the `value` parameter.</span></span> <span data-ttu-id="d7b74-185">Pokud `destinationType` je parametrem <xref:System.String>typ , musí být vrácený <xref:System.String>objekt schopen být přetypován jako .</span><span class="sxs-lookup"><span data-stu-id="d7b74-185">When the `destinationType` parameter is the type <xref:System.String>, then the returned object must be able to be cast as <xref:System.String>.</span></span> <span data-ttu-id="d7b74-186">Vrácený řetězec musí představovat `value`serializovanou hodnotu .</span><span class="sxs-lookup"><span data-stu-id="d7b74-186">The returned string must represent a serialized value of `value`.</span></span> <span data-ttu-id="d7b74-187">V ideálním případě by měl být formát serializace, který zvolíte, schopen <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> generovat stejnou hodnotu, pokud byl tento řetězec předán implementaci stejného převaděče, bez významné ztráty informací.</span><span class="sxs-lookup"><span data-stu-id="d7b74-187">Ideally, the serialization format you choose should be capable of generating the same value if that string were passed to the <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> implementation of the same converter, without significant loss of information.</span></span>  
  
 <span data-ttu-id="d7b74-188">Pokud hodnotu nelze serializovat nebo převaděč nepodporuje <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> serializaci, implementace musí vrátit `null`a je povoleno vyvolat výjimku v tomto případě.</span><span class="sxs-lookup"><span data-stu-id="d7b74-188">If the value cannot be serialized, or the converter does not support serialization, the <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> implementation must return `null`, and is permitted to throw an exception in this case.</span></span> <span data-ttu-id="d7b74-189">Ale pokud vyvoláte výjimky, měli byste nahlásit neschopnost použít <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> tento převod jako součást implementace <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> tak, aby byl podporován osvědčený postup kontroly s první, aby se zabránilo výjimkám.</span><span class="sxs-lookup"><span data-stu-id="d7b74-189">But if you do throw exceptions, you should report the inability to use that conversion as part of your <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> implementation so that the best practice of checking with <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> first to avoid exceptions is supported.</span></span>  
  
 <span data-ttu-id="d7b74-190">Pokud `destinationType` parametr není <xref:System.String>typu , můžete zvolit vlastní zpracování převaděče.</span><span class="sxs-lookup"><span data-stu-id="d7b74-190">If `destinationType` parameter is not of type <xref:System.String>, you can choose your own converter handling.</span></span> <span data-ttu-id="d7b74-191">Obvykle byste se vrátit k základní zpracování implementace, <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> která v basemost vyvolává konkrétní výjimku.</span><span class="sxs-lookup"><span data-stu-id="d7b74-191">Typically, you would revert to base implementation handling, which in the basemost <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> raises a specific exception.</span></span>  
  
### <a name="implementing-canconvertto"></a><span data-ttu-id="d7b74-192">Implementace canconvertto</span><span class="sxs-lookup"><span data-stu-id="d7b74-192">Implementing CanConvertTo</span></span>  
 <span data-ttu-id="d7b74-193">Implementace <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> by `true` se `destinationType` měla <xref:System.String>vrátit pro typ a jinak odložit na základní implementaci.</span><span class="sxs-lookup"><span data-stu-id="d7b74-193">Your <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> implementation should return `true` for `destinationType` of type <xref:System.String>, and otherwise defer to the base implementation.</span></span>  
  
### <a name="implementing-canconvertfrom"></a><span data-ttu-id="d7b74-194">Implementace CanConvertFrom</span><span class="sxs-lookup"><span data-stu-id="d7b74-194">Implementing CanConvertFrom</span></span>  
 <span data-ttu-id="d7b74-195">Implementace <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A> by `true` se `sourceType` měla <xref:System.String>vrátit pro typ a jinak odložit na základní implementaci.</span><span class="sxs-lookup"><span data-stu-id="d7b74-195">Your <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A> implementation should return `true` for `sourceType` of type <xref:System.String>, and otherwise defer to the base implementation.</span></span>  
  
<a name="Applying_the_TypeConverterAttribute"></a>
## <a name="applying-the-typeconverterattribute"></a><span data-ttu-id="d7b74-196">Použití atributu TypeConverterAttribute</span><span class="sxs-lookup"><span data-stu-id="d7b74-196">Applying the TypeConverterAttribute</span></span>  
 <span data-ttu-id="d7b74-197">Aby byl převaděč vlastního typu použit jako převaděč působícího typu pro vlastní třídu procesorem XAML, musíte použít <xref:System.ComponentModel.TypeConverterAttribute> definici třídy.</span><span class="sxs-lookup"><span data-stu-id="d7b74-197">In order for your custom type converter to be used as the acting type converter for a custom class by a XAML processor, you must apply the <xref:System.ComponentModel.TypeConverterAttribute> to your class definition.</span></span> <span data-ttu-id="d7b74-198">Zadaný <xref:System.ComponentModel.TypeConverterAttribute.ConverterTypeName%2A> prostřednictvím atributu musí být název typu vlastního převaděče typu.</span><span class="sxs-lookup"><span data-stu-id="d7b74-198">The <xref:System.ComponentModel.TypeConverterAttribute.ConverterTypeName%2A> that you specify through the attribute must be the type name of your custom type converter.</span></span> <span data-ttu-id="d7b74-199">S tímto atributem použít, když procesor XAML zpracovává hodnoty, kde typ vlastnosti používá váš vlastní typ třídy, může zadávat řetězce a vrátit instance objektu.</span><span class="sxs-lookup"><span data-stu-id="d7b74-199">With this attribute applied, when a XAML processor handles values where the property type uses your custom class type, it can input strings and return object instances.</span></span>  
  
 <span data-ttu-id="d7b74-200">Můžete také zadat převaděč typu na základě vlastnosti.</span><span class="sxs-lookup"><span data-stu-id="d7b74-200">You can also provide a type converter on a per-property basis.</span></span> <span data-ttu-id="d7b74-201"><xref:System.ComponentModel.TypeConverterAttribute> Místo použití definice třídy ji použijte na definici vlastnosti (hlavní definice, `get` / `set` nikoli implementace v ní).</span><span class="sxs-lookup"><span data-stu-id="d7b74-201">Instead of applying a <xref:System.ComponentModel.TypeConverterAttribute> to the class definition, apply it to a property definition (the main definition, not the `get`/`set` implementations within it).</span></span> <span data-ttu-id="d7b74-202">Typ vlastnosti musí odpovídat typu, který je zpracován převaděčem vlastního typu.</span><span class="sxs-lookup"><span data-stu-id="d7b74-202">The type of the property must match the type that is processed by your custom type converter.</span></span> <span data-ttu-id="d7b74-203">S tímto atributem použít, když procesor XAML zpracovává hodnoty této vlastnosti, může zpracovat vstupní řetězce a vrátit instance objektu.</span><span class="sxs-lookup"><span data-stu-id="d7b74-203">With this attribute applied, when a XAML processor handles values of that property, it can process input strings and return object instances.</span></span> <span data-ttu-id="d7b74-204">Technika převaděče typu vlastností je užitečná zejména v případě, že se rozhodnete použít typ vlastnosti z rozhraní <xref:System.ComponentModel.TypeConverterAttribute> Microsoft .NET Framework nebo z jiné knihovny, kde nelze řídit definici třídy a nelze použít tam.</span><span class="sxs-lookup"><span data-stu-id="d7b74-204">The per-property type converter technique is particularly useful if you choose to use a property type from Microsoft .NET Framework or from some other library where you cannot control the class definition and cannot apply a <xref:System.ComponentModel.TypeConverterAttribute> there.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="d7b74-205">Viz také</span><span class="sxs-lookup"><span data-stu-id="d7b74-205">See also</span></span>

- <xref:System.ComponentModel.TypeConverter>
- [<span data-ttu-id="d7b74-206">Přehled XAML (WPF)</span><span class="sxs-lookup"><span data-stu-id="d7b74-206">XAML Overview (WPF)</span></span>](../../../desktop-wpf/fundamentals/xaml.md)
- [<span data-ttu-id="d7b74-207">Rozšíření značek a WPF XAML</span><span class="sxs-lookup"><span data-stu-id="d7b74-207">Markup Extensions and WPF XAML</span></span>](markup-extensions-and-wpf-xaml.md)
- [<span data-ttu-id="d7b74-208">Podrobná syntaxe XAML</span><span class="sxs-lookup"><span data-stu-id="d7b74-208">XAML Syntax In Detail</span></span>](xaml-syntax-in-detail.md)
