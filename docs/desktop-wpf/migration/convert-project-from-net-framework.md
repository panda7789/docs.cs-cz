---
title: Migrace aplikací WPF do rozhraní .NET Core 3.0
description: Přečtěte si, jak migrovat aplikaci WPF (Windows Presentation Foundation) do rozhraní .NET Core 3.0.
author: mjrousos
ms.date: 09/12/2019
ms.author: mikerou
ms.openlocfilehash: f52005e7c8a6312b8c4e09a950f1f635af1894e4
ms.sourcegitcommit: cdf5084648bf5e77970cbfeaa23f1cab3e6e234e
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 02/01/2020
ms.locfileid: "82071309"
---
# <a name="migrating-wpf-apps-to-net-core"></a><span data-ttu-id="5c6b7-103">Migrace aplikací WPF do jádra rozhraní .NET Core</span><span class="sxs-lookup"><span data-stu-id="5c6b7-103">Migrating WPF apps to .NET Core</span></span>

<span data-ttu-id="5c6b7-104">Tento článek popisuje kroky potřebné k migraci aplikace WPF (Windows Presentation Foundation) z rozhraní .NET Framework do .NET Core 3.0.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-104">This article covers the steps necessary to migrate a Windows Presentation Foundation (WPF) app from .NET Framework to .NET Core 3.0.</span></span> <span data-ttu-id="5c6b7-105">Pokud nemáte aplikaci WPF po ruce k portu, ale chtěli byste vyzkoušet proces, můžete použít ukázkovou aplikaci **Bean Trader,** která je k dispozici na [GitHubu](https://github.com/dotnet/windows-desktop/tree/master/Samples/BeanTrader).</span><span class="sxs-lookup"><span data-stu-id="5c6b7-105">If you don't have a WPF app on hand to port, but would like to try out the process, you can use the **Bean Trader** sample app available on [GitHub](https://github.com/dotnet/windows-desktop/tree/master/Samples/BeanTrader).</span></span> <span data-ttu-id="5c6b7-106">Původní aplikace (cílení na rozhraní .NET Framework 4.7.2) je k dispozici ve složce NetFx\BeanTraderClient.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-106">The original app (targeting .NET Framework 4.7.2) is available in the NetFx\BeanTraderClient folder.</span></span> <span data-ttu-id="5c6b7-107">Nejprve vysvětlíme kroky nezbytné k portování aplikací obecně a pak projdeme konkrétní změny, které se vztahují na ukázku **Bean Trader.**</span><span class="sxs-lookup"><span data-stu-id="5c6b7-107">First we'll explain the steps necessary to port apps in general, and then we'll walk through the specific changes that apply to the **Bean Trader** sample.</span></span>

[!INCLUDE [desktop guide under construction](../../../includes/desktop-guide-preview-note.md)]

<span data-ttu-id="5c6b7-108">Chcete-li migrovat do jádra .NET, musíte nejprve:</span><span class="sxs-lookup"><span data-stu-id="5c6b7-108">To migrate to .NET Core, you must first:</span></span>

01. <span data-ttu-id="5c6b7-109">Pochopit a aktualizovat závislosti NuGet:</span><span class="sxs-lookup"><span data-stu-id="5c6b7-109">Understand and update NuGet dependencies:</span></span>

    01. <span data-ttu-id="5c6b7-110">Upgrade NuGet závislosti používat `<PackageReference>` formát.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-110">Upgrade NuGet dependencies to use the `<PackageReference>` format.</span></span>
    01. <span data-ttu-id="5c6b7-111">Zkontrolujte závislosti NuGet nejvyšší úrovně pro kompatibilitu s jádrem .NET nebo .NET Standard.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-111">Review top-level NuGet dependencies for .NET Core or .NET Standard compatibility.</span></span>
    01. <span data-ttu-id="5c6b7-112">Upgradujte balíčky NuGet na novější verze.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-112">Upgrade NuGet packages to newer versions.</span></span>
    01. <span data-ttu-id="5c6b7-113">Pomocí [analyzátoru přenositelnosti rozhraní .NET](../../standard/analyzers/portability-analyzer.md) porozumíte závislostem rozhraní .NET.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-113">Use the [.NET Portability Analyzer](../../standard/analyzers/portability-analyzer.md) to understand .NET dependencies.</span></span>

01. <span data-ttu-id="5c6b7-114">Migrujte soubor projektu do nového formátu ve stylu sady SDK:</span><span class="sxs-lookup"><span data-stu-id="5c6b7-114">Migrate the project file to the new SDK-style format:</span></span>

    01. <span data-ttu-id="5c6b7-115">Zvolte, zda chcete cílit na rozhraní .NET Core i .NET Framework nebo pouze na .NET Core.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-115">Choose whether to target both .NET Core and .NET Framework, or only .NET Core.</span></span>
    01. <span data-ttu-id="5c6b7-116">Zkopírujte příslušné vlastnosti a položky souboru projektu do nového souboru projektu.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-116">Copy relevant project file properties and items to the new project file.</span></span>

01. <span data-ttu-id="5c6b7-117">Řešení problémů se sestavením:</span><span class="sxs-lookup"><span data-stu-id="5c6b7-117">Fix build issues:</span></span>

    01. <span data-ttu-id="5c6b7-118">Přidejte odkaz na balíček [Microsoft.Windows.Compatibility.](https://www.nuget.org/packages/Microsoft.Windows.Compatibility/)</span><span class="sxs-lookup"><span data-stu-id="5c6b7-118">Add a reference to the [Microsoft.Windows.Compatibility](https://www.nuget.org/packages/Microsoft.Windows.Compatibility/) package.</span></span>
    01. <span data-ttu-id="5c6b7-119">Najděte a opravte rozdíly na úrovni rozhraní API.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-119">Find and fix API-level differences.</span></span>
    01. <span data-ttu-id="5c6b7-120">Odebrání jiných oddílů *app.config* než `appSettings` nebo `connectionStrings`.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-120">Remove *app.config* sections other than `appSettings` or `connectionStrings`.</span></span>
    01. <span data-ttu-id="5c6b7-121">V případě potřeby vygenerujte generovaný kód.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-121">Regenerate generated code, if necessary.</span></span>

01. <span data-ttu-id="5c6b7-122">Testování za běhu:</span><span class="sxs-lookup"><span data-stu-id="5c6b7-122">Runtime testing:</span></span>

    01. <span data-ttu-id="5c6b7-123">Potvrďte, že přenesená aplikace funguje podle očekávání.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-123">Confirm the ported app works as expected.</span></span>
    01. <span data-ttu-id="5c6b7-124">Dejte si <xref:System.NotSupportedException> pozor na výjimky.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-124">Beware of <xref:System.NotSupportedException> exceptions.</span></span>

## <a name="about-the-sample"></a><span data-ttu-id="5c6b7-125">O vzorku</span><span class="sxs-lookup"><span data-stu-id="5c6b7-125">About the sample</span></span>

<span data-ttu-id="5c6b7-126">Tento článek odkazuje na [ukázkovou aplikaci Bean Trader,](https://github.com/dotnet/windows-desktop/tree/master/Samples/BeanTrader) protože používá různé závislosti podobné těm, které mohou mít skutečné aplikace WPF.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-126">This article references the [Bean Trader sample app](https://github.com/dotnet/windows-desktop/tree/master/Samples/BeanTrader) because it uses a variety of dependencies similar to those that real-world WPF apps might have.</span></span> <span data-ttu-id="5c6b7-127">Aplikace není velká, ale má být krok nahoru od "Hello World" z hlediska složitosti.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-127">The app isn't large, but is meant to be a step up from 'Hello World' in terms of complexity.</span></span> <span data-ttu-id="5c6b7-128">Aplikace ukazuje některé problémy, se kterými se uživatelé mohou setkat při přenosu skutečných aplikací.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-128">The app demonstrates some issues users may encounter while porting real apps.</span></span> <span data-ttu-id="5c6b7-129">Aplikace komunikuje se službou WCF, takže aby správně běžela, budete také muset spustit projekt BeanTraderServer (k dispozici ve stejném úložišti GitHub) a ujistěte se, že konfigurace BeanTraderClient odkazuje na správný koncový bod.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-129">The app communicates with a WCF service, so for it to run properly, you'll also need to run the BeanTraderServer project (available in the same GitHub repository) and make sure the BeanTraderClient configuration points to the correct endpoint.</span></span> <span data-ttu-id="5c6b7-130">(Ve výchozím nastavení ukázka předpokládá, že server *http://localhost:8090*běží na stejném počítači na , což bude pravda, pokud spustíte BeanTraderServer místně.)</span><span class="sxs-lookup"><span data-stu-id="5c6b7-130">(By default, the sample assumes the server is running on the same machine at *http://localhost:8090*, which will be true if you launch BeanTraderServer locally.)</span></span>

<span data-ttu-id="5c6b7-131">Mějte na paměti, že tato ukázková aplikace je určena k předvedení rozhraní .NET Core výzvy a řešení.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-131">Keep in mind that this sample app is meant to demonstrate .NET Core porting challenges and solutions.</span></span> <span data-ttu-id="5c6b7-132">Není určen k prokázání WPF osvědčené postupy.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-132">It's not meant to demonstrate WPF best practices.</span></span> <span data-ttu-id="5c6b7-133">Ve skutečnosti, to záměrně obsahuje některé anti-vzory, aby se ujistil, narazíte alespoň na pár zajímavých výzev při portování.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-133">In fact, it deliberately includes some anti-patterns to make sure you come across at least a couple of interesting challenges while porting.</span></span>

## <a name="getting-ready"></a><span data-ttu-id="5c6b7-134">Příprava</span><span class="sxs-lookup"><span data-stu-id="5c6b7-134">Getting ready</span></span>

<span data-ttu-id="5c6b7-135">Primární výzvou migrace aplikace rozhraní .NET Framework do služby .NET Core je, že její závislosti mohou fungovat jinak nebo vůbec.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-135">The primary challenge of migrating a .NET Framework app to .NET Core is that its dependencies may work differently or not at all.</span></span> <span data-ttu-id="5c6b7-136">Migrace je mnohem jednodušší, než bývala; mnoho balíčků NuGet nyní cílí na standard .NET.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-136">Migration is much easier than it used to be; many NuGet packages now target .NET Standard.</span></span> <span data-ttu-id="5c6b7-137">Počínaje rozhraním .NET Core 2.0 se oblasti .NET Framework a .NET Core staly podobnými.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-137">Starting with .NET Core 2.0, the .NET Framework and .NET Core surface areas have become similar.</span></span> <span data-ttu-id="5c6b7-138">I tak zůstávají některé rozdíly (jak v podpoře z balíčků NuGet, tak v dostupných rozhraních API .NET).</span><span class="sxs-lookup"><span data-stu-id="5c6b7-138">Even so, some differences (both in support from NuGet packages and in available .NET APIs) remain.</span></span> <span data-ttu-id="5c6b7-139">Prvním krokem při migraci je kontrola závislostí aplikace a ujistěte se, že odkazy jsou ve formátu, který se snadno migruje do jádra .NET Core.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-139">The first step in migrating is to review the app's dependencies and make sure references are in a format that's easily migrated to .NET Core.</span></span>

### <a name="upgrade-to-packagereference-nuget-references"></a><span data-ttu-id="5c6b7-140">Upgrade `<PackageReference>` na odkazy NuGet</span><span class="sxs-lookup"><span data-stu-id="5c6b7-140">Upgrade to `<PackageReference>` NuGet references</span></span>

<span data-ttu-id="5c6b7-141">Starší projekty rozhraní .NET Framework obvykle uvádějí své závislosti NuGet v souboru *packages.config.*</span><span class="sxs-lookup"><span data-stu-id="5c6b7-141">Older .NET Framework projects typically list their NuGet dependencies in a *packages.config* file.</span></span> <span data-ttu-id="5c6b7-142">Nový formát souboru projektu ve stylu sady SDK odkazuje na balíčky NuGet jako [`<PackageReference>`](/nuget/consume-packages/package-references-in-project-files) na prvky v samotném souboru csproj, nikoli v samostatném konfiguračním souboru.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-142">The new SDK-style project file format references NuGet packages as [`<PackageReference>`](/nuget/consume-packages/package-references-in-project-files) elements in the csproj file itself rather than in a separate config file.</span></span>

<span data-ttu-id="5c6b7-143">Při migraci existují dvě výhody `<PackageReference>`použití odkazů ve stylu:</span><span class="sxs-lookup"><span data-stu-id="5c6b7-143">When migrating, there are two advantages to using `<PackageReference>`-style references:</span></span>

- <span data-ttu-id="5c6b7-144">Toto je styl odkazu NuGet, který je vyžadován pro nový soubor projektu .NET Core.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-144">This is the style of NuGet reference that is required for the new .NET Core project file.</span></span> <span data-ttu-id="5c6b7-145">Pokud již používáte `<PackageReference>`, tyto prvky souboru projektu lze zkopírovat a vložit přímo do nového projektu.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-145">If you're already using `<PackageReference>`, those project file elements can be copied and pasted directly into the new project.</span></span>
- <span data-ttu-id="5c6b7-146">Na rozdíl od souboru `<PackageReference>` packages.config elementy odkazují pouze na závislosti nejvyšší úrovně, na kterých projekt přímo závisí.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-146">Unlike a packages.config file, `<PackageReference>` elements only refer to the top-level dependencies that your project depends on directly.</span></span> <span data-ttu-id="5c6b7-147">Všechny ostatní přenosité balíčky NuGet budou určeny v době obnovení a zaznamenány v automaticky generovaném souboru obj\project.assets.json.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-147">All other transitive NuGet packages will be determined at restore time and recorded in the autogenerated obj\project.assets.json file.</span></span> <span data-ttu-id="5c6b7-148">To usnadňuje určení, jaké závislosti má váš projekt, což je užitečné při určování, zda nezbytné závislosti bude fungovat na .NET Core nebo ne.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-148">This makes it much easier to determine what dependencies your project has, which is useful when determining whether the necessary dependencies will work on .NET Core or not.</span></span>

<span data-ttu-id="5c6b7-149">Prvním krokem migrace aplikace rozhraní .NET Framework do jádra .NET `<PackageReference>` je aktualizace tak, aby používala odkazy NuGet.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-149">The first step to migrating a .NET Framework app to .NET Core is to update it to use `<PackageReference>` NuGet references.</span></span> <span data-ttu-id="5c6b7-150">Visual Studio je to jednoduché.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-150">Visual Studio makes this simple.</span></span> <span data-ttu-id="5c6b7-151">Stačí klepnout pravým tlačítkem myši na soubor *packages.config* projektu v **Průzkumníku řešení**sady Visual Studio a potom vybrat **příkaz Migrovat packages.config na PackageReference**.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-151">Just right-click the project's *packages.config* file in Visual Studio's **Solution Explorer**, and then select **Migrate packages.config to PackageReference**.</span></span>

![Upgrade na odkaz na balíček](./media/convert-project-from-net-framework/package-reference-migration.png)

<span data-ttu-id="5c6b7-153">Zobrazí se dialogové okno zobrazující vypočtené závislosti NuGet nejvyšší úrovně a dotaz, které další balíčky NuGet by měly být povýšeny na nejvyšší úroveň.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-153">A dialog appears showing calculated top-level NuGet dependencies and asking which other NuGet packages should be promoted to top-level.</span></span> <span data-ttu-id="5c6b7-154">Žádný z těchto dalších balíčků nemusí být nejvyšší úroveň pro ukázku Bean Trader, takže můžete zrušit zaškrtnutí všech těchto políček.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-154">None of these other packages need to be top-level for the Bean Trader sample, so you can uncheck all of those boxes.</span></span> <span data-ttu-id="5c6b7-155">Potom klepněte na tlačítko **Ok** a soubor `<PackageReference>` *packages.config* je odebrán a prvky jsou přidány do souboru projektu.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-155">Then, click **Ok** and the *packages.config* file is removed and `<PackageReference>` elements are added to the project file.</span></span>

<span data-ttu-id="5c6b7-156">`<PackageReference>`-style odkazy neukládají balíčky NuGet místně ve složce balíčky.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-156">`<PackageReference>`-style references don't store NuGet packages locally in a packages folder.</span></span> <span data-ttu-id="5c6b7-157">Místo toho jsou uloženy globálně jako optimalizace.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-157">Instead, they're stored globally as an optimization.</span></span> <span data-ttu-id="5c6b7-158">Po dokončení migrace upravte soubor csproj `<Analyzer>` a odstraňte všechny prvky odkazující na analyzátory, které dříve pocházely z *.. \packages* adresáře.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-158">After the migration completes, edit the csproj file and remove any `<Analyzer>` elements referring to the analyzers that previously came from the *..\packages* directory.</span></span> <span data-ttu-id="5c6b7-159">Nebojte se; vzhledem k tomu, že stále máte odkazy na balíček NuGet, analyzátory budou zahrnuty do projektu.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-159">Don't worry; since you still have the NuGet package references, the analyzers will be included in the project.</span></span> <span data-ttu-id="5c6b7-160">Stačí vyčistit staré elementy packages.config `<Analyzer>` stylu.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-160">You just need to clean up the old packages.config-style `<Analyzer>` elements.</span></span>

### <a name="review-nuget-packages"></a><span data-ttu-id="5c6b7-161">Projděte si balíčky NuGet</span><span class="sxs-lookup"><span data-stu-id="5c6b7-161">Review NuGet packages</span></span>

<span data-ttu-id="5c6b7-162">Teď, když můžete vidět balíčky NuGet nejvyšší úrovně, na kterých projekt závisí, můžete zkontrolovat, zda jsou tyto balíčky k dispozici na .NET Core.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-162">Now that you can see the top-level NuGet packages that the project depends on, you can review whether those packages are available on .NET Core.</span></span> <span data-ttu-id="5c6b7-163">Můžete určit, zda balíček podporuje .NET Core při pohledu na jeho závislosti na [nuget.org](https://www.nuget.org/). Fuget.org [web](https://www.fuget.org/) vytvořený komunitou zobrazuje tyto informace výrazně v horní části informační stránky balíčku.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-163">You can determine whether a package supports .NET Core by looking at its dependencies on [nuget.org](https://www.nuget.org/). The community-created [fuget.org](https://www.fuget.org/) site shows this information prominently at the top of the package information page.</span></span>

<span data-ttu-id="5c6b7-164">Při cílení na rozhraní .NET Core 3.0 by měly fungovat všechny balíčky zaměřené na rozhraní .NET Core nebo .NET Standard (protože rozhraní .NET Core implementuje plochu .NET Standard).</span><span class="sxs-lookup"><span data-stu-id="5c6b7-164">When targeting .NET Core 3.0, any packages targeting .NET Core or .NET Standard should work (since .NET Core implements the .NET Standard surface area).</span></span> <span data-ttu-id="5c6b7-165">V některých případech konkrétní verze balíčku, který se používá nebude cílit .NET Core nebo .NET Standard, ale novější verze bude.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-165">In some cases, the specific version of a package that's used won't target .NET Core or .NET Standard, but newer versions will.</span></span> <span data-ttu-id="5c6b7-166">V takovém případě byste měli zvážit upgrade na nejnovější verzi balíčku.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-166">In this case, you should consider upgrading to the latest version of the package.</span></span>

<span data-ttu-id="5c6b7-167">Můžete také použít balíčky zaměřené na rozhraní .NET Framework, ale to představuje určité riziko.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-167">You can use packages targeting .NET Framework, as well, but that introduces some risk.</span></span> <span data-ttu-id="5c6b7-168">Závislosti rozhraní .NET Core to .NET Framework jsou povoleny, protože oblasti povrchu rozhraní .NET Core a .NET Framework jsou natolik podobné, že tyto závislosti *často* fungují.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-168">.NET Core to .NET Framework dependencies are allowed because .NET Core and .NET Framework surface areas are similar enough that such dependencies *often* work.</span></span> <span data-ttu-id="5c6b7-169">Pokud se však balíček pokusí použít rozhraní .NET API, které není v jádru .NET, dojde k výjimce za běhu.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-169">However, if the package tries to use a .NET API that isn't present in .NET Core, you'll encounter a runtime exception.</span></span> <span data-ttu-id="5c6b7-170">Z tohoto důvodu byste měli odkazovat pouze na balíčky rozhraní .NET Framework, pokud nejsou k dispozici žádné jiné možnosti, a pochopit, že tím se ukládá zkušební zátěž.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-170">Because of that, you should only reference .NET Framework packages when no other options are available and understand that doing so imposes a test burden.</span></span>

<span data-ttu-id="5c6b7-171">Pokud existují odkazy na balíčky, které necílí na .NET Core nebo .NET Standard, budete muset přemýšlet o dalších alternativách:</span><span class="sxs-lookup"><span data-stu-id="5c6b7-171">If there are packages referenced that don't target .NET Core or .NET Standard, you'll have to think about other alternatives:</span></span>

- <span data-ttu-id="5c6b7-172">Existují jiné podobné balíčky, které lze použít místo?</span><span class="sxs-lookup"><span data-stu-id="5c6b7-172">Are there other similar packages that can be used instead?</span></span> <span data-ttu-id="5c6b7-173">Někdy NuGet autoři publikovat samostatné '. Core' verze jejich knihoven specificky zaměřené na .NET Core.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-173">Sometimes NuGet authors publish separate '.Core' versions of their libraries specifically targeting .NET Core.</span></span> <span data-ttu-id="5c6b7-174">Balíčky enterprise knihovny jsou příkladem publikování komunity ". NetCore" alternativy.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-174">Enterprise Library packages are an example of the community publishing ".NetCore" alternatives.</span></span> <span data-ttu-id="5c6b7-175">V ostatních případech jsou pro soubor .NET Standard k dispozici novější sady SDK pro určitou službu (někdy s různými názvy balíčků).</span><span class="sxs-lookup"><span data-stu-id="5c6b7-175">In other cases, newer SDKs for a particular service (sometimes with different package names) are available for .NET Standard.</span></span> <span data-ttu-id="5c6b7-176">Pokud nejsou k dispozici žádné alternativy, můžete pokračovat pomocí balíčků cílených na rozhraní .NET Framework, s ohledem na to, že je budete muset důkladně otestovat po spuštění v .NET Core.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-176">If no alternatives are available, you can proceed using the .NET Framework-targeted packages, bearing in mind that you'll need to test them thoroughly once running on .NET Core.</span></span>

<span data-ttu-id="5c6b7-177">Ukázka Bean Trader má následující závislosti NuGet nejvyšší úrovně:</span><span class="sxs-lookup"><span data-stu-id="5c6b7-177">The Bean Trader sample has the following top-level NuGet dependencies:</span></span>

- [<span data-ttu-id="5c6b7-178">**Castle.Windsor, verze 4.1.1**</span><span class="sxs-lookup"><span data-stu-id="5c6b7-178">**Castle.Windsor, version 4.1.1**</span></span>](https://www.castleproject.org/projects/windsor/)  

  <span data-ttu-id="5c6b7-179">Tento balíček se zaměřuje na standard .NET Standard 1.6, takže funguje na .NET Core.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-179">This package targets .NET Standard 1.6, so it works on .NET Core.</span></span>

- [<span data-ttu-id="5c6b7-180">**Microsoft.CodeAnalysis.FxCopAnalyzers, verze 2.6.3**</span><span class="sxs-lookup"><span data-stu-id="5c6b7-180">**Microsoft.CodeAnalysis.FxCopAnalyzers, version 2.6.3**</span></span>](https://www.nuget.org/packages/Microsoft.CodeAnalysis.FxCopAnalyzers/2.6.3)  
  <span data-ttu-id="5c6b7-181">Toto je meta balíček, takže není okamžitě zřejmé, které platformy podporuje, ale [dokumentace](https://github.com/dotnet/roslyn-analyzers#microsoftcodeanalysisfxcopanalyzers) znamená, že jeho nejnovější verze (2.9.2) bude fungovat jak pro rozhraní .NET Framework, tak pro .NET Core.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-181">This is a meta-package, so it's not immediately obvious which platforms it supports, but [documentation](https://github.com/dotnet/roslyn-analyzers#microsoftcodeanalysisfxcopanalyzers) indicates that its newest version (2.9.2) will work for both .NET Framework and .NET Core.</span></span>

- [<span data-ttu-id="5c6b7-182">**Nito.AsyncEx, verze 4.0.1**</span><span class="sxs-lookup"><span data-stu-id="5c6b7-182">**Nito.AsyncEx, version 4.0.1**</span></span>](https://www.nuget.org/packages/Nito.AsyncEx/4.0.1)  

  <span data-ttu-id="5c6b7-183">Tento balíček necílí na .NET Core, ale novější verze 5.0 ano.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-183">This package doesn't target .NET Core, but the newer 5.0 version does.</span></span> <span data-ttu-id="5c6b7-184">To je běžné při migraci, protože mnoho balíčků NuGet nedávno přidalo podporu .NET Standard, ale starší verze projektu se zaměří pouze na rozhraní .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-184">This is common when migrating because many NuGet packages have added .NET Standard support recently, but older project versions will only target .NET Framework.</span></span> <span data-ttu-id="5c6b7-185">Pokud je rozdíl verzí pouze menší verze rozdíl, je to často snadné upgradovat na novější verzi.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-185">If the version difference is only a minor version difference, it's often easy to upgrade to the newer version.</span></span> <span data-ttu-id="5c6b7-186">Vzhledem k tomu, že se jedná o hlavní změnu verze, musíte být opatrní při upgradu, protože v balíčku může dojít k porušení změn.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-186">Because this is a major version change, you need to be cautious upgrading since there could be breaking changes in the package.</span></span> <span data-ttu-id="5c6b7-187">Existuje však cesta vpřed, což je dobré.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-187">There is a path forward, though, which is good.</span></span>

- [<span data-ttu-id="5c6b7-188">**MahApps.Metro, verze 1.6.5**</span><span class="sxs-lookup"><span data-stu-id="5c6b7-188">**MahApps.Metro, version 1.6.5**</span></span>](https://www.nuget.org/packages/MahApps.Metro/1.6.5)  

  <span data-ttu-id="5c6b7-189">Tento balíček také necílí na .NET Core, ale má novější předběžnou verzi (2.0-alpha), která ano.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-189">This package also doesn't target .NET Core, but has a newer pre-release (2.0-alpha) that does.</span></span> <span data-ttu-id="5c6b7-190">Opět platí, že budete muset dávat pozor na lámání změny, ale novější balíček je povzbudivý.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-190">Again, you have to look out for breaking changes, but the newer package is encouraging.</span></span>

<span data-ttu-id="5c6b7-191">Bean Trader ukázkové nuget závislosti všechny cíl .NET Standard/.NET Core nebo novější verze, které dělají, takže je nepravděpodobné, že žádné problémy blokování zde.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-191">The Bean Trader sample's NuGet dependencies all either target .NET Standard/.NET Core or have newer versions that do, so there are unlikely to be any blocking issues here.</span></span>

### <a name="upgrade-nuget-packages"></a><span data-ttu-id="5c6b7-192">Upgrade balíčků NuGet</span><span class="sxs-lookup"><span data-stu-id="5c6b7-192">Upgrade NuGet packages</span></span>

<span data-ttu-id="5c6b7-193">Pokud je to možné, bylo by vhodné inovovat verze všech balíčků, které se zaměřují pouze na rozhraní .NET Core nebo .NET Standard s novějšími verzemi v tomto okamžiku (s projektem stále zaměřeným na rozhraní .NET Framework) za účelem včasného zjištění a řešení všech narušujících změn.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-193">If possible, it would be good to upgrade the versions of any packages that only target .NET Core or .NET Standard with more recent versions at this point (with the project still targeting .NET Framework) to discover and address any breaking changes early.</span></span>

<span data-ttu-id="5c6b7-194">Pokud byste raději neprováděli žádné podstatné změny v existující verzi aplikace rozhraní .NET Framework, může to počkat, dokud nebudete mít nový soubor projektu zaměřený na .NET Core.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-194">If you would rather not make any material changes to the existing .NET Framework version of the app, this can wait until you have a new project file targeting .NET Core.</span></span> <span data-ttu-id="5c6b7-195">Upgrade balíčků NuGet na verze kompatibilní s rozhraním .NET Core však po vytvoření nového souboru projektu proces migrace ještě více zjednoduší a sníží počet rozdílů mezi verzemi rozhraní .NET Framework a .NET Core aplikace.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-195">However, upgrading the NuGet packages to .NET Core-compatible versions ahead of time makes the migration process even easier once you create the new project file and reduces the number of differences between the .NET Framework and .NET Core versions of the app.</span></span>

<span data-ttu-id="5c6b7-196">S ukázkou Bean Trader lze všechny potřebné upgrady snadno provést (pomocí správce balíčků NuGet sady Visual Studio) s jednou výjimkou: upgrade z **MahApps.Metro 1.6.5** na **2.0** odhalí nejnovější změny související s tématem a nastaveními pro správu zvýraznění.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-196">With the Bean Trader sample, all of the necessary upgrades can be made easily (using Visual Studio's NuGet package manager) with one exception: upgrading from **MahApps.Metro 1.6.5** to **2.0** reveals breaking changes related to theme and accent management APIs.</span></span>

<span data-ttu-id="5c6b7-197">V ideálním případě by aplikace být aktualizovány použít novější verzi balíčku (vzhledem k tomu, že je pravděpodobnější, že pracovat na .NET Core).</span><span class="sxs-lookup"><span data-stu-id="5c6b7-197">Ideally, the app would be updated to use the newer version of the package (since that is more likely to work on .NET Core).</span></span> <span data-ttu-id="5c6b7-198">V některých případech to však nemusí být proveditelné.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-198">In some cases, however, that may not be feasible.</span></span> <span data-ttu-id="5c6b7-199">V těchto případech neupgradujte **MahApps.Metro,** protože nezbytné změny nejsou triviální a tento kurz se zaměřuje na migraci na .NET Core 3, nikoli na **MahApps.Metro 2.**</span><span class="sxs-lookup"><span data-stu-id="5c6b7-199">In these cases, don't upgrade **MahApps.Metro** because the necessary changes are non-trivial and this tutorial focuses on migrating to .NET Core 3, not to **MahApps.Metro 2.**</span></span> <span data-ttu-id="5c6b7-200">Také se jedná o závislost na rozhraní .NET Framework s nízkým rizikem, protože aplikace Bean Trader používá pouze malou část **mahapps.metro**.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-200">Also, this is a low-risk .NET Framework dependency because the Bean Trader app only exercises a small part of **MahApps.Metro**.</span></span> <span data-ttu-id="5c6b7-201">Bude to samozřejmě vyžadovat testování, aby se ujistil, že vše funguje, jakmile je migrace dokončena.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-201">It will, of course, require testing to make sure everything's working once the migration is complete.</span></span> <span data-ttu-id="5c6b7-202">Pokud by se jednalo o skutečný scénář, bylo by dobré podat problém sledovat práci přesunout do **MahApps.Metro** verze 2.0, protože nedělá migrace nyní zanechává některé technické dluhy.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-202">If this were a real-world scenario, it would be good to file an issue to track the work to move to **MahApps.Metro** version 2.0 since not doing the migration now leaves behind some technical debt.</span></span>

<span data-ttu-id="5c6b7-203">Jakmile jsou balíčky NuGet aktualizovány `<PackageReference>` na nejnovější verze, skupina položek v souboru projektu ukázkového souboru Bean Trader by měla vypadat takto.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-203">Once the NuGet packages are updated to recent versions, the `<PackageReference>` item group in the Bean Trader sample's project file should look like this.</span></span>

```xml
<ItemGroup>
  <PackageReference Include="Castle.Windsor">
    <Version>4.1.1</Version>
  </PackageReference>
  <PackageReference Include="MahApps.Metro">
    <Version>1.6.5</Version>
  </PackageReference>
  <PackageReference Include="Microsoft.CodeAnalysis.FxCopAnalyzers">
    <Version>2.9.2</Version>
  </PackageReference>
  <PackageReference Include="Nito.AsyncEx">
    <Version>5.0.0</Version>
  </PackageReference>
</ItemGroup>
```

### <a name="net-framework-portability-analysis"></a><span data-ttu-id="5c6b7-204">Analýza přenositelnosti rozhraní .NET Framework</span><span class="sxs-lookup"><span data-stu-id="5c6b7-204">.NET Framework portability analysis</span></span>

<span data-ttu-id="5c6b7-205">Jakmile porozumíte stavu závislostí NuGet vašeho projektu, další věc, kterou je třeba zvážit, je .NET Framework API závislosti.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-205">Once you understand the state of your project's NuGet dependencies, the next thing to consider is .NET Framework API dependencies.</span></span> <span data-ttu-id="5c6b7-206">Nástroj [.NET Portability Analyzer](../../standard/analyzers/portability-analyzer.md) je užitečný pro pochopení toho, která rozhraní API .NET, která projekt používá, jsou k dispozici na jiných platformách .NET.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-206">The [.NET Portability Analyzer](../../standard/analyzers/portability-analyzer.md) tool is useful for understanding which of the .NET APIs your project uses are available on other .NET platforms.</span></span>

<span data-ttu-id="5c6b7-207">Nástroj je dodáván jako [plugin Visual Studio](https://marketplace.visualstudio.com/items?itemName=ConnieYau.NETPortabilityAnalyzer), nástroj [příkazového řádku](https://github.com/Microsoft/dotnet-apiport/releases)nebo zabalený do [jednoduchého grafického uživatelského rozhraní](https://github.com/Microsoft/dotnet-apiport-ui), které zjednodušuje jeho možnosti.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-207">The tool comes as a [Visual Studio plugin](https://marketplace.visualstudio.com/items?itemName=ConnieYau.NETPortabilityAnalyzer), a [command-line tool](https://github.com/Microsoft/dotnet-apiport/releases), or wrapped in a [simple GUI](https://github.com/Microsoft/dotnet-apiport-ui), which simplifies its options.</span></span> <span data-ttu-id="5c6b7-208">Další informace o použití nástroje .NET Portability Analyzer (PORT Port Port) pomocí grafického uživatelského rozhraní v příspěvku blogu [Porting desktopových aplikací na .NET Core.](https://devblogs.microsoft.com/dotnet/porting-desktop-apps-to-net-core/)</span><span class="sxs-lookup"><span data-stu-id="5c6b7-208">You can read more about using the .NET Portability Analyzer (API Port) using the GUI in the [Porting desktop apps to .NET Core](https://devblogs.microsoft.com/dotnet/porting-desktop-apps-to-net-core/) blog post.</span></span> <span data-ttu-id="5c6b7-209">Pokud dáváte přednost použití příkazového řádku, jsou nezbytné kroky:</span><span class="sxs-lookup"><span data-stu-id="5c6b7-209">If you prefer to use the command line, the necessary steps are:</span></span>

1. <span data-ttu-id="5c6b7-210">Stáhněte si [analyzátor přenositelnosti .NET,](https://github.com/Microsoft/dotnet-apiport/releases) pokud ho ještě nemáte.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-210">Download the [.NET Portability Analyzer](https://github.com/Microsoft/dotnet-apiport/releases) if you don't already have it.</span></span>
1. <span data-ttu-id="5c6b7-211">Ujistěte se, že aplikace .NET Framework, která má být portována sestavení úspěšně (to je dobrý nápad před migrací bez ohledu na to).</span><span class="sxs-lookup"><span data-stu-id="5c6b7-211">Make sure the .NET Framework app to be ported builds successfully (this is a good idea prior to migration regardless).</span></span>
1. <span data-ttu-id="5c6b7-212">Spusťte port rozhraní API s příkazovým řádkem, jako je tento.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-212">Run API Port with a command line like this.</span></span>

    ```console
    ApiPort.exe analyze -f <PathToBeanTraderBinaries> -r html -r excel -t ".NET Core"
    ```

    <span data-ttu-id="5c6b7-213">Argument `-f` určuje cestu obsahující binární soubory k analýze.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-213">The `-f` argument specifies the path containing the binaries to analyze.</span></span> <span data-ttu-id="5c6b7-214">Argument `-r` určuje, který formát výstupního souboru chcete.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-214">The `-r` argument specifies which output file format you want.</span></span> <span data-ttu-id="5c6b7-215">Argument `-t` určuje, proti které platformě .NET má být analyzovat využití rozhraní API.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-215">The `-t` argument specifies which .NET platform to analyze API usage against.</span></span> <span data-ttu-id="5c6b7-216">V tomto případě chcete .NET Core.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-216">In this case, you want .NET Core.</span></span>

<span data-ttu-id="5c6b7-217">Když otevřete sestavu HTML, první část zobrazí všechny analyzované binární soubory a jaké procento rozhraní API .NET, které používají, jsou k dispozici na cílové platformě.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-217">When you open the HTML report, the first section will list all of the analyzed binaries and what percentage of the .NET APIs they use are available on the targeted platform.</span></span> <span data-ttu-id="5c6b7-218">Procento není smysluplné samo o sobě.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-218">The percentage is not meaningful by itself.</span></span> <span data-ttu-id="5c6b7-219">Co je užitečnější je vidět konkrétní api, které chybí.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-219">What's more useful is to see the specific APIs that are missing.</span></span> <span data-ttu-id="5c6b7-220">Chcete-li to provést, vyberte název sestavy nebo posuňte dolů k sestavám pro jednotlivá sestavení.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-220">To do that, either select an assembly name or scroll down to the reports for individual assemblies.</span></span>

<span data-ttu-id="5c6b7-221">Zaměřte se na sestavení, pro která vlastníte zdrojový kód.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-221">Focus on the assemblies that you own the source code for.</span></span> <span data-ttu-id="5c6b7-222">V sestavě ApiPort Bean Trader je například mnoho binárních souborů, ale většina z nich patří do balíčků NuGet.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-222">In the Bean Trader ApiPort report, for example, there are many binaries listed, but most of them belong to NuGet packages.</span></span> <span data-ttu-id="5c6b7-223">`Castle.Windsor`ukazuje, že závisí na některých rozhraních API System.Web, které chybí v rozhraní .NET Core.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-223">`Castle.Windsor` shows that it depends on some System.Web APIs that are missing in .NET Core.</span></span> <span data-ttu-id="5c6b7-224">To není problém, protože jste `Castle.Windsor` dříve ověřili, že podporuje .NET Core.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-224">This isn't a concern because you previously verified that `Castle.Windsor` supports .NET Core.</span></span> <span data-ttu-id="5c6b7-225">Je běžné, že balíčky NuGet mají různé binární soubory pro použití s různými `Castle.Windsor` platformami .NET, takže zda je verze rozhraní .NET Framework používá rozhraní API System.Web nebo ne, irelevantní, pokud balíček také cílí na standard .NET nebo .NET Core (což ano).</span><span class="sxs-lookup"><span data-stu-id="5c6b7-225">It is common for NuGet packages to have different binaries for use with different .NET platforms, so whether the .NET Framework version of `Castle.Windsor` uses System.Web APIs or not is irrelevant as long as the package also targets .NET Standard or .NET Core (which it does).</span></span>

<span data-ttu-id="5c6b7-226">S ukázkou Bean Trader je jediným binárním souborem, který je třeba **zvážit, BeanTraderClient** a sestava ukazuje, že chybí pouze dvě rozhraní API .NET: `System.ServiceModel.ClientBase<T>.Close` a `System.ServiceModel.ClientBase<T>.Open`.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-226">With the Bean Trader sample, the only binary that you need to consider is **BeanTraderClient** and the report shows that only two .NET APIs are missing: `System.ServiceModel.ClientBase<T>.Close` and `System.ServiceModel.ClientBase<T>.Open`.</span></span>

![Sestava přenositelnosti klienta BeanTrader](./media/convert-project-from-net-framework/portability-report.png)

<span data-ttu-id="5c6b7-228">Ty pravděpodobně neblokují problémy, protože rozhraní API klientů WCF jsou (většinou) podporována v jádru .NET, takže pro tato centrální rozhraní API musí být k dispozici alternativy.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-228">These are unlikely to be blocking issues because WCF Client APIs are (mostly) supported on .NET Core, so there must be alternatives available for these central APIs.</span></span> <span data-ttu-id="5c6b7-229">Ve skutečnosti při `System.ServiceModel`pohledu na 's <https://apisof.net>.NET Core plochy (pomocí ), uvidíte, že existují asynchronní alternativy v .NET Core místo.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-229">In fact, looking at `System.ServiceModel`'s .NET Core surface area (using <https://apisof.net>), you see that there are async alternatives in .NET Core instead.</span></span>

<span data-ttu-id="5c6b7-230">Na základě této sestavy a předchozí analýzy závislostí NuGet, vypadá to, že by měly být žádné hlavní problémy migrace bean Trader vzorku .NET Core.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-230">Based on this report and the previous NuGet dependency analysis, it looks like there should be no major issues migrating the Bean Trader sample to .NET Core.</span></span> <span data-ttu-id="5c6b7-231">Jste připraveni na další krok, ve kterém skutečně zahájíte migraci.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-231">You're ready for the next step in which you'll actually start the migration.</span></span>

## <a name="migrating-the-project-file"></a><span data-ttu-id="5c6b7-232">Migrace souboru projektu</span><span class="sxs-lookup"><span data-stu-id="5c6b7-232">Migrating the project file</span></span>

<span data-ttu-id="5c6b7-233">Pokud vaše aplikace nepoužívá nový [formát souboru projektu ve stylu sady SDK](../../core/tools/csproj.md), budete k cílení na jádro .NET potřebovat nový soubor projektu.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-233">If your app isn't using the new [SDK-style project file format](../../core/tools/csproj.md), you'll need a new project file to target .NET Core.</span></span> <span data-ttu-id="5c6b7-234">Můžete nahradit existující soubor csproj, nebo pokud dáváte přednost tomu, aby byl existující projekt v aktuálním stavu nedotčený, můžete přidat nový soubor csproj zaměřený na .NET Core.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-234">You can replace the existing csproj file or, if you prefer to keep the existing project untouched in its current state, you can add a new csproj file targeting .NET Core.</span></span> <span data-ttu-id="5c6b7-235">Můžete vytvořit verze aplikace pro rozhraní .NET Framework a .NET Core s jedním souborem projektu ve `<TargetFrameworks>` stylu sady SDK s [více cíleními](../../standard/library-guidance/cross-platform-targeting.md) (určením více cílů).</span><span class="sxs-lookup"><span data-stu-id="5c6b7-235">You can build versions of the app for .NET Framework and .NET Core with a single SDK-style project file with [multi-targeting](../../standard/library-guidance/cross-platform-targeting.md) (specifying multiple `<TargetFrameworks>` targets).</span></span>

<span data-ttu-id="5c6b7-236">Chcete-li vytvořit nový soubor projektu, můžete vytvořit nový projekt `dotnet new wpf` WPF v sadě Visual Studio nebo pomocí příkazu v dočasném adresáři vygenerovat soubor projektu a potom jej zkopírovat nebo přejmenovat do správného umístění.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-236">To create the new project file, you can create a new WPF project in Visual Studio or use the `dotnet new wpf` command in a temporary directory to generate the project file and then copy/rename it to the correct location.</span></span> <span data-ttu-id="5c6b7-237">K dispozici je také nástroj vytvořený [komunitou, CsprojToVs2017](https://github.com/hvanbakel/CsprojToVs2017), který může automatizovat některé migrace souboru projektu.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-237">There is also a community-created tool, [CsprojToVs2017](https://github.com/hvanbakel/CsprojToVs2017), that can automate some of the project file migration.</span></span> <span data-ttu-id="5c6b7-238">Nástroj je užitečný, ale stále potřebuje člověka, aby přezkoumal výsledky, aby se ujistil, že všechny podrobnosti o migraci jsou správné.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-238">The tool is helpful but still needs a human to review the results to make sure all the details of the migration are correct.</span></span> <span data-ttu-id="5c6b7-239">Jednou z konkrétních oblastí, které nástroj nezpracovává optimálně je migrace balíčků NuGet ze souborů *packages.config.*</span><span class="sxs-lookup"><span data-stu-id="5c6b7-239">One particular area that the tool doesn't handle optimally is migrating NuGet packages from *packages.config* files.</span></span> <span data-ttu-id="5c6b7-240">Pokud nástroj běží na soubor projektu, který stále používá *soubor packages.config* odkazovat NuGet balíčky, bude migrovat na `<PackageReference>` prvky automaticky, ale přidá `<PackageReference>` prvky pro *všechny* balíčky namísto pouze ty nejvyšší úrovně.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-240">If the tool runs on a project file that still uses a *packages.config* file to reference NuGet packages, it will migrate to `<PackageReference>` elements automatically, but will add `<PackageReference>` elements for *all* of the packages instead of just top-level ones.</span></span> <span data-ttu-id="5c6b7-241">Pokud jste již migrovali na`<PackageReference>` prvky s Visual Studio (jako jste to udělali v této ukázce), pak nástroj může pomoci se zbytkem převodu.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-241">If you have already migrated to`<PackageReference>` elements with Visual Studio (as you've done in this sample), then the tool can help with the rest of the conversion.</span></span> <span data-ttu-id="5c6b7-242">Stejně jako Scott Hanselman doporučuje ve [svém blogu o migraci csproj soubory](https://www.hanselman.com/blog/UpgradingAnExistingNETProjectFilesToTheLeanNewCSPROJFormatFromNETCore.aspx), portování ručně je vzdělávací a dá lepší výsledky, pokud máte jen několik projektů na port.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-242">Like Scott Hanselman recommends in [his blog post on migrating csproj files](https://www.hanselman.com/blog/UpgradingAnExistingNETProjectFilesToTheLeanNewCSPROJFormatFromNETCore.aspx), porting by hand is educational and will give better results if you only have a few projects to port.</span></span> <span data-ttu-id="5c6b7-243">Ale pokud portujete desítky nebo stovky projektových souborů, pak nástroj jako [CsprojToVs2017] může být nápovědou.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-243">But if you are porting dozens or hundreds of project files, then a tool like [CsprojToVs2017] can be a help.</span></span>

<span data-ttu-id="5c6b7-244">Chcete-li vytvořit nový soubor projektu pro `dotnet new wpf` ukázku Bean Trader, spusťte v dočasném adresáři a přesuňte generovaný soubor *.csproj* do složky *BeanTraderClient* a přejmenujte jej **na BeanTraderClient.Core.csproj**.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-244">To create a new project file for the Bean Trader sample, run `dotnet new wpf` in a temporary directory and move the generated *.csproj* file into the *BeanTraderClient* folder and rename it **BeanTraderClient.Core.csproj**.</span></span>

<span data-ttu-id="5c6b7-245">Vzhledem k tomu, že nový formát souboru projektu automaticky obsahuje soubory Jazyka C#, *soubory resx* a soubory XAML, které najde v adresáři nebo pod ním, je soubor projektu již téměř dokončen!</span><span class="sxs-lookup"><span data-stu-id="5c6b7-245">Because the new project file format automatically includes C# files, *resx* files, and XAML files that it finds in or under its directory, the project file is already almost complete!</span></span> <span data-ttu-id="5c6b7-246">Chcete-li migraci dokončit, otevřete staré a nové soubory projektu vedle sebe a prohlédněte si staré soubory a zjistěte, zda je třeba migrovat nějaké informace, které obsahuje.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-246">To finish the migration, open the old and new project files side-by-side and look through the old one to see if any information it contains needs to be migrated.</span></span> <span data-ttu-id="5c6b7-247">V případě vzorku Bean Trader by měly být do nového projektu zkopírovány následující položky:</span><span class="sxs-lookup"><span data-stu-id="5c6b7-247">In the Bean Trader sample case, the following items should be copied to the new project:</span></span>

- <span data-ttu-id="5c6b7-248">Všechny `<RootNamespace>` `<AssemblyName>`vlastnosti `<ApplicationIcon>` , a by měly být zkopírovány.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-248">The `<RootNamespace>`, `<AssemblyName>`, and `<ApplicationIcon>` properties should all be copied.</span></span>

- <span data-ttu-id="5c6b7-249">Také je třeba `<GenerateAssemblyInfo>false</GenerateAssemblyInfo>` přidat vlastnost do nového souboru projektu, protože ukázka `[AssemblyTitle]`Bean Trader obsahuje atributy na úrovni sestavení (například ) v souboru AssemblyInfo.cs.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-249">You also need to add a `<GenerateAssemblyInfo>false</GenerateAssemblyInfo>` property to the new project file since the Bean Trader sample includes assembly-level attributes (like `[AssemblyTitle]`) in an AssemblyInfo.cs file.</span></span> <span data-ttu-id="5c6b7-250">Ve výchozím nastavení budou nové projekty ve stylu sady SDK automaticky generovat tyto atributy na základě vlastností v souboru csproj.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-250">By default, new SDK-style projects will autogenerate these attributes based on properties in the csproj file.</span></span> <span data-ttu-id="5c6b7-251">Protože nechcete, aby se tak stalo v tomto případě (automaticky generované atributy by v konfliktu s `<GenerateAssemblyInfo>`těmi z AssemblyInfo.cs), můžete zakázat automaticky generované atributy s .</span><span class="sxs-lookup"><span data-stu-id="5c6b7-251">Because you don't want that to happen in this case (the autogenerated attributes would conflict with those from AssemblyInfo.cs), you disable the autogenerated attributes with `<GenerateAssemblyInfo>`.</span></span>

- <span data-ttu-id="5c6b7-252">Přestože *resx* soubory jsou automaticky zahrnuty jako vložené prostředky, jiné `<Resource>` položky, jako jsou obrázky nejsou.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-252">Although *resx* files are automatically included as embedded resources, other `<Resource>` items like images are not.</span></span> <span data-ttu-id="5c6b7-253">Takže zkopírujte `<Resource>` prvky pro vkládání souborů obrázků a ikon.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-253">So, copy the `<Resource>` elements for embedding image and icon files.</span></span> <span data-ttu-id="5c6b7-254">Odkazy png na jeden řádek můžete zjednodušit pomocí podpory nového formátu souboru `<Resource Include="**\*.png" />`projektu pro globbing patterns: .</span><span class="sxs-lookup"><span data-stu-id="5c6b7-254">You can simplify the png references to a single line by using the new project file format's support for globbing patterns: `<Resource Include="**\*.png" />`.</span></span>

- <span data-ttu-id="5c6b7-255">Podobně `<None>` jsou položky zahrnuty automaticky, ale ve výchozím nastavení nejsou zkopírovány do výstupního adresáře.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-255">Similarly, `<None>` items are included automatically, but they aren't copied to the output directory, by default.</span></span> <span data-ttu-id="5c6b7-256">Vzhledem k tomu, `<None>` že projekt Bean Trader obsahuje `PreserveNewest` položku, která *je* zkopírována do výstupního adresáře (pomocí chování), je třeba aktualizovat automaticky vyplněnou `<None>` položku pro tento soubor, takto.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-256">Because the Bean Trader project includes a `<None>` item that *is* copied to the output directory (using `PreserveNewest` behaviors), you need to update the automatically populated `<None>` item for that file, like this.</span></span>

  ```xml
  <None Update="BeanTrader.pfx">
    <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
  </None>
  ```

- <span data-ttu-id="5c6b7-257">Ukázka Bean Trader obsahuje soubor XAML (Default.Accent.xaml) `Content` `Page`jako (spíše než jako ) protože motivy a akcenty definované v tomto souboru jsou načteny z XAML souboru za běhu, spíše než vložené do samotné aplikace.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-257">The Bean Trader sample includes a XAML file (Default.Accent.xaml) as `Content` (rather than as a `Page`) because themes and accents defined in this file are loaded from the file's XAML at runtime, rather than being embedded in the app itself.</span></span> <span data-ttu-id="5c6b7-258">Nový projektový systém automaticky zahrnuje `<Page>`tento soubor jako , nicméně, protože je to soubor XAML.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-258">The new project system automatically includes this file as a `<Page>`, however, since it's a XAML file.</span></span> <span data-ttu-id="5c6b7-259">Takže musíte odstranit soubor XAML jako stránku`<Page Remove="**\Default.Accent.xaml" />`( ) a přidat jej jako obsah.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-259">So, you need to both remove the XAML file as a page (`<Page Remove="**\Default.Accent.xaml" />`) and add it as content.</span></span>

  ```xml
  <Content Include="Resources\Themes\Default.Accent.xaml">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
  </Content>
  ```

- <span data-ttu-id="5c6b7-260">Nakonec přidejte odkazy NuGet zkopírováním `<ItemGroup>` `<PackageReference>` se všemi prvky.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-260">Finally, add NuGet references by copying the `<ItemGroup>` with all the `<PackageReference>` elements.</span></span> <span data-ttu-id="5c6b7-261">Pokud jste dříve upgradovali balíčky NuGet na verze kompatibilní s jádrem .NET, můžete to udělat nyní, když jsou odkazy na balíček v projektu specifickém pro jádro .NET.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-261">If you hadn't previously upgraded the NuGet packages to .NET Core-compatible versions, you could do that now that the package references are in a .NET Core-specific project.</span></span>

<span data-ttu-id="5c6b7-262">V tomto okamžiku by mělo být možné přidat nový projekt do řešení BeanTrader a otevřít jej v sadě Visual Studio.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-262">At this point, it should be possible to add the new project to the BeanTrader solution and open it in Visual Studio.</span></span> <span data-ttu-id="5c6b7-263">Projekt by měl vypadat správně `dotnet restore BeanTraderClient.Core.csproj` v **Průzkumníku řešení**a měl by úspěšně obnovit balíčky (se dvěma očekávanými upozorněními souvisejícími s verzí MahApps.Metro, kterou používáte cílení .NET Framework).</span><span class="sxs-lookup"><span data-stu-id="5c6b7-263">The project should look correct in **Solution Explorer**, and `dotnet restore BeanTraderClient.Core.csproj` should successfully restore packages (with two expected warnings related to the MahApps.Metro version you're using targeting .NET Framework).</span></span>

<span data-ttu-id="5c6b7-264">I když je možné zachovat oba soubory projektu vedle sebe (a může být dokonce žádoucí, pokud chcete zachovat vytváření starého projektu přesně tak, jak byl), komplikuje proces migrace (dva projekty se pokusí použít stejné bin a obj složky) a obvykle není nutné.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-264">Although it's possible to keep both project files side-by-side (and may even be desirable if you want to keep building the old project exactly as it was), it complicates the migration process (the two projects will try to use the same bin and obj folders) and usually isn't necessary.</span></span> <span data-ttu-id="5c6b7-265">Pokud chcete vytvořit pro cíle .NET Core a .NET `<TargetFramework>netcoreapp3.0</TargetFramework>` Framework, můžete `<TargetFrameworks>netcoreapp3.0;net472</TargetFrameworks>` místo toho nahradit vlastnost v novém souboru projektu.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-265">If you want to build for both .NET Core and .NET Framework targets, you can replace the `<TargetFramework>netcoreapp3.0</TargetFramework>` property in the new project file with `<TargetFrameworks>netcoreapp3.0;net472</TargetFrameworks>` instead.</span></span> <span data-ttu-id="5c6b7-266">Pro ukázku Bean Trader odstraňte starý soubor projektu (BeanTraderClient.csproj), protože již není potřeba.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-266">For the Bean Trader sample, delete the old project file (BeanTraderClient.csproj) since it's no longer needed.</span></span> <span data-ttu-id="5c6b7-267">Pokud dáváte přednost zachovat oba soubory projektu, ujistěte se, že je sestavení na jiný výstup a zprostředkující výstupní cesty.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-267">If you prefer to keep both project files, be sure to have them build to different output and intermediate output paths.</span></span>

## <a name="fix-build-issues"></a><span data-ttu-id="5c6b7-268">Řešení problémů se sestavením</span><span class="sxs-lookup"><span data-stu-id="5c6b7-268">Fix build issues</span></span>

<span data-ttu-id="5c6b7-269">Třetím krokem procesu přenosu je získání projektu k sestavení.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-269">The third step of the porting process is getting the project to build.</span></span> <span data-ttu-id="5c6b7-270">Některé aplikace se již úspěšně vytvoří, jakmile je soubor projektu převeden na projekt ve stylu sady SDK.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-270">Some apps will already build successfully once the project file is converted to an SDK-style project.</span></span> <span data-ttu-id="5c6b7-271">Pokud je to váš případ pro vaši aplikaci, gratulujeme!</span><span class="sxs-lookup"><span data-stu-id="5c6b7-271">If that's the case for your app, congratulations!</span></span> <span data-ttu-id="5c6b7-272">Můžete přejít na krok 4.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-272">You can go on to Step 4.</span></span> <span data-ttu-id="5c6b7-273">Ostatní aplikace budou potřebovat některé aktualizace, aby je získaly pro .NET Core.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-273">Other apps will need some updates to get them building for .NET Core.</span></span> <span data-ttu-id="5c6b7-274">Pokud se pokusíte spustit `dotnet build` na ukázkový projekt Bean Trader nyní, například (nebo jej sestavit v sadě Visual Studio), bude mnoho chyb, ale dostanete je rychle opravit.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-274">If you try to run `dotnet build` on the Bean Trader sample project now, for example, (or build it in Visual Studio), there will be many errors, but you'll get them fixed quickly.</span></span>

### <a name="systemservicemodel-references-and-microsoftwindowscompatibility"></a><span data-ttu-id="5c6b7-275">Reference System.ServiceModel a Microsoft.Windows.Compatibility</span><span class="sxs-lookup"><span data-stu-id="5c6b7-275">System.ServiceModel references and Microsoft.Windows.Compatibility</span></span>

<span data-ttu-id="5c6b7-276">Běžným zdrojem chyb chybí odkazy na rozhraní API, které jsou k dispozici pro rozhraní .NET Core, ale nejsou automaticky zahrnuty do metabalíčku aplikace .NET Core.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-276">A common source of errors is missing references for APIs that are available for .NET Core but not automatically included in the .NET Core app metapackage.</span></span> <span data-ttu-id="5c6b7-277">Chcete-li tento problém `Microsoft.Windows.Compatibility` vyřešit, měli byste odkazovat na balíček.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-277">To address this, you should reference the `Microsoft.Windows.Compatibility` package.</span></span> <span data-ttu-id="5c6b7-278">Balíček kompatibility obsahuje širokou sadu rozhraní API, která jsou běžná v aplikacích klasické pracovní plochy systému Windows, jako je klient WCF, adresářové služby, registr, konfigurace, rozhraní API ACA a další.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-278">The compatibility package includes a broad set of APIs that are common in Windows desktop apps, such as WCF client, directory services, registry, configuration, ACLs APIs, and more.</span></span>

<span data-ttu-id="5c6b7-279">U ukázky Bean Trader je většina chyb sestavení <xref:System.ServiceModel> způsobena chybějícími typy.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-279">With the Bean Trader sample, the majority of the build errors are due to missing <xref:System.ServiceModel> types.</span></span> <span data-ttu-id="5c6b7-280">Ty by mohly být vyřešeny odkazem na nezbytné balíčky WCF NuGet.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-280">These could be addressed by referencing the necessary WCF NuGet packages.</span></span> <span data-ttu-id="5c6b7-281">WCF klientská rozhraní API patří `Microsoft.Windows.Compatibility` mezi ty, které jsou k dispozici v balíčku, i když, takže odkazování na balíček kompatibility je ještě lepší řešení (protože také řeší všechny problémy související s rozhraní api, stejně jako řešení problémů WCF, že balíček kompatibility zpřístupní).</span><span class="sxs-lookup"><span data-stu-id="5c6b7-281">WCF client APIs are among those present in the `Microsoft.Windows.Compatibility` package, though, so referencing the compatibility package is an even better solution (since it also addresses any issues related to APIs as well as solutions to the WCF issues that the compatibility package makes available).</span></span> <span data-ttu-id="5c6b7-282">Balíček `Microsoft.Windows.Compatibility` pomáhá ve většině scénářů přenosu .NET Core 3.0 WPF a WinForms.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-282">The `Microsoft.Windows.Compatibility` package helps in most .NET Core 3.0 WPF and WinForms porting scenarios.</span></span> <span data-ttu-id="5c6b7-283">Po přidání odkazu NuGet do `Microsoft.Windows.Compatibility`, zůstane pouze jedna chyba sestavení!</span><span class="sxs-lookup"><span data-stu-id="5c6b7-283">After adding the NuGet reference to `Microsoft.Windows.Compatibility`, only one build error remains!</span></span>

### <a name="cleaning-up-unused-files"></a><span data-ttu-id="5c6b7-284">Čištění nepoužívaných souborů</span><span class="sxs-lookup"><span data-stu-id="5c6b7-284">Cleaning up unused files</span></span>

<span data-ttu-id="5c6b7-285">Jeden typ problému migrace, který přichází často se týká C# a XAML soubory, které nebyly dříve zahrnuty v sestavení získání zvedl nové projekty ve stylu Sady SDK, které obsahují *všechny* zdroje automaticky.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-285">One type of migration issue that comes up often relates to C# and XAML files that weren't previously included in the build getting picked up by the new SDK-style projects that include *all* source automatically.</span></span>

<span data-ttu-id="5c6b7-286">Další chyba sestavení, kterou vidíte v ukázce Bean Trader, odkazuje na chybné implementaci rozhraní v *OldUnusedViewModel.cs*.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-286">The next build error you see in the Bean Trader sample refers to a bad interface implementation in *OldUnusedViewModel.cs*.</span></span> <span data-ttu-id="5c6b7-287">Název souboru je nápověda, ale při kontrole zjistíte, že tento zdrojový soubor je nesprávný.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-287">The file name is a hint, but on inspection, you'll find that this source file is incorrect.</span></span> <span data-ttu-id="5c6b7-288">Dříve nezpůsobila problémy, protože nebyla zahrnuta v původním projektu rozhraní .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-288">It didn't cause issues previously because it wasn't included in the original .NET Framework project.</span></span> <span data-ttu-id="5c6b7-289">Zdrojové soubory, které byly přítomny na disku, ale nebyly zahrnuty do starého *csproj* jsou zahrnuty automaticky nyní.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-289">Source files that were present on disk but not included in the old *csproj* are included automatically now.</span></span>

<span data-ttu-id="5c6b7-290">U jednorázových problémů, jako je tento, je snadné porovnat s předchozím *csproj* potvrdit, že `<Compile Remove="" />` soubor není potřeba, a pak buď to, nebo, pokud zdrojový soubor není potřeba nikde už, odstranit.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-290">For one-off issues like this, it's easy to compare to the previous *csproj* to confirm that the file isn't needed, and then either `<Compile Remove="" />` it or, if the source file isn't needed anywhere anymore, delete it.</span></span> <span data-ttu-id="5c6b7-291">V tomto případě je bezpečné jen odstranit *OldUnusedViewModel.cs*.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-291">In this case, it's safe to just delete *OldUnusedViewModel.cs*.</span></span>

<span data-ttu-id="5c6b7-292">Pokud máte mnoho zdrojových souborů, které by bylo nutné vyloučit tímto způsobem, můžete `<EnableDefaultCompileItems>` zakázat automatické zahrnutí souborů Jazyka C# nastavením vlastnosti false v souboru projektu.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-292">If you have many source files that would need to be excluded this way, you can disable auto-inclusion of C# files by setting the `<EnableDefaultCompileItems>` property to false in the project file.</span></span> <span data-ttu-id="5c6b7-293">Potom můžete zkopírovat `<Compile Include>` položky ze starého souboru projektu do nového, abyste mohli vytvářet pouze zdroje, které jste chtěli zahrnout.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-293">Then, you can copy `<Compile Include>` items from the old project file to the new one in order to only build sources you intended to include.</span></span> <span data-ttu-id="5c6b7-294">Podobně `<EnableDefaultPageItems>` lze vypnout automatické zahrnutí stránek XAML `<EnableDefaultItems>` a můžete řídit jak s jednou vlastností.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-294">Similarly, `<EnableDefaultPageItems>` can be used to turn off auto-inclusion of XAML pages and `<EnableDefaultItems>` can control both with a single property.</span></span>

### <a name="a-brief-aside-on-multi-pass-compilers"></a><span data-ttu-id="5c6b7-295">Stručný stranou na multi-pass kompilátory</span><span class="sxs-lookup"><span data-stu-id="5c6b7-295">A brief aside on multi-pass compilers</span></span>

<span data-ttu-id="5c6b7-296">Po odstranění problematického souboru z ukázky Bean Trader můžete znovu sestavit a získáte čtyři chyby.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-296">After removing the offending file from the Bean Trader sample, you can re-build and will get four errors.</span></span> <span data-ttu-id="5c6b7-297">Neměl jsi ho předtím?</span><span class="sxs-lookup"><span data-stu-id="5c6b7-297">Didn't you have one before?</span></span> <span data-ttu-id="5c6b7-298">Proč se počet chyb zvýšil?</span><span class="sxs-lookup"><span data-stu-id="5c6b7-298">Why did the number of errors go up?</span></span> <span data-ttu-id="5c6b7-299">Kompilátor Jazyka C# je [víceprůchodový kompilátor](https://docs.microsoft.com/archive/blogs/ericlippert/how-many-passes).</span><span class="sxs-lookup"><span data-stu-id="5c6b7-299">The C# compiler is a [multi-pass compiler](https://docs.microsoft.com/archive/blogs/ericlippert/how-many-passes).</span></span> <span data-ttu-id="5c6b7-300">To znamená, že prochází každý zdrojový soubor dvakrát.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-300">This means that it goes through each source file twice.</span></span> <span data-ttu-id="5c6b7-301">Nejprve kompilátor pouze vyhledá metadata a deklarace v každém zdrojovém souboru a identifikuje všechny problémy na úrovni deklarace.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-301">First, the compiler just looks at metadata and declarations in each source file and identifies any declaration-level problems.</span></span> <span data-ttu-id="5c6b7-302">To jsou chyby, které jste opravili.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-302">Those are the errors you've fixed.</span></span> <span data-ttu-id="5c6b7-303">Pak znovu projde kódem k sestavení zdroje C# do IL; to jsou druhá sada chyb, které vidíte nyní.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-303">Then it goes through the code again to build the C# source into IL; those are the second set of errors that you're seeing now.</span></span>

> [!NOTE]
> <span data-ttu-id="5c6b7-304">Kompilátor Jazyka C# provádí [více než jen dva průchody](https://docs.microsoft.com/archive/blogs/ericlippert/how-many-passes), ale konečným výsledkem je, že chyby kompilátoru pro velké změny kódu, jako je tento, mají tendenci přijít ve dvou vlnách.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-304">The C# compiler does [more than just two passes](https://docs.microsoft.com/archive/blogs/ericlippert/how-many-passes), but the end result is that compiler errors for large code changes like this tend to come in two waves.</span></span>

### <a name="third-party-dependency-fixes-castlewindsor"></a><span data-ttu-id="5c6b7-305">Opravy závislostí třetích stran (Castle.Windsor)</span><span class="sxs-lookup"><span data-stu-id="5c6b7-305">Third-party dependency fixes (Castle.Windsor)</span></span>

<span data-ttu-id="5c6b7-306">Další třídou problému, která se objevuje v některých scénářích migrace, jsou rozdíly rozhraní API mezi rozhraním .NET Framework a .NET Core verzemi závislostí.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-306">Another class of issue that comes up in some migration scenarios is API differences between .NET Framework and .NET Core versions of dependencies.</span></span> <span data-ttu-id="5c6b7-307">I v případě, že balíček NuGet cílí na rozhraní .NET Framework i na rozhraní .NET Standard nebo .NET Core, mohou existovat různé knihovny pro použití s různými cíli .NET.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-307">Even if a NuGet package targets both .NET Framework and .NET Standard or .NET Core, there may be different libraries for use with different .NET targets.</span></span> <span data-ttu-id="5c6b7-308">To umožňuje balíčky pro podporu mnoha různých platforem .NET, které mohou vyžadovat různé implementace.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-308">This allows the packages to support many different .NET platforms, which may require different implementations.</span></span> <span data-ttu-id="5c6b7-309">To také znamená, že může být malé rozdíly rozhraní API v knihovnách při cílení různých platformách .NET.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-309">It also means that there may be small API differences in the libraries when targeting different .NET platforms.</span></span>

<span data-ttu-id="5c6b7-310">Další sada chyb, které se zobrazí ve vzorku Bean Trader, souvisí `Castle.Windsor` s api.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-310">The next set of errors you'll see in the Bean Trader sample are related to `Castle.Windsor` APIs.</span></span> <span data-ttu-id="5c6b7-311">Projekt .NET Core Bean Trader používá `Castle.Windsor` stejnou verzi jako projekt cílený na rozhraní .NET Framework (4.1.1), ale implementace pro tyto dvě platformy se mírně liší.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-311">The .NET Core Bean Trader project uses the same version of `Castle.Windsor` as the .NET Framework-targeted project (4.1.1), but the implementations for those two platforms are slightly different.</span></span>

<span data-ttu-id="5c6b7-312">V takovém případě se zobrazí následující problémy, které je třeba opravit:</span><span class="sxs-lookup"><span data-stu-id="5c6b7-312">In this case, you see the following issues that need to be fixed:</span></span>

1. <span data-ttu-id="5c6b7-313">`Castle.MicroKernel.Registration.Classes.FromThisAssembly`není k dispozici na .NET Core.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-313">`Castle.MicroKernel.Registration.Classes.FromThisAssembly` isn't available on .NET Core.</span></span> <span data-ttu-id="5c6b7-314">Existuje však podobné rozhraní `Classes.FromAssemblyContaining` API k dispozici, takže `Classes.FromThisAssembly()` můžeme `Classes.FromAssemblyContaining(t)`nahradit `t` obě použití s voláním , kde je typ volání.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-314">There is, however, the similar API `Classes.FromAssemblyContaining` available, so we can replace both uses of `Classes.FromThisAssembly()` with calls to `Classes.FromAssemblyContaining(t)`, where `t` is the type making the call.</span></span>
1. <span data-ttu-id="5c6b7-315">Podobně v *Bootstrapper.cs* `Castle.Windsor.Installer.FromAssembly`. . To to není k dispozici na .NET Core.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-315">Similarly, in *Bootstrapper.cs*, `Castle.Windsor.Installer.FromAssembly`.This is unavailable on .NET Core.</span></span> <span data-ttu-id="5c6b7-316">Místo toho může být toto volání nahrazeno . `FromAssembly.Containing(typeof(Bootstrapper))`</span><span class="sxs-lookup"><span data-stu-id="5c6b7-316">Instead, that call can be replaced with `FromAssembly.Containing(typeof(Bootstrapper))`.</span></span>

### <a name="updating-wcf-client-usage"></a><span data-ttu-id="5c6b7-317">Aktualizace využití klienta WCF</span><span class="sxs-lookup"><span data-stu-id="5c6b7-317">Updating WCF client usage</span></span>

<span data-ttu-id="5c6b7-318">`Castle.Windsor` Po opevnění rozdílů je poslední zbývající chyba sestavení v projektu .NET Core Bean Trader ta `Open` `BeanTraderServiceClient` (která je odvozena z) `DuplexClientBase`nemá metodu.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-318">Having fixed the `Castle.Windsor` differences, the last remaining build error in the .NET Core Bean Trader project is that `BeanTraderServiceClient` (which derives from `DuplexClientBase`) doesn't have an `Open` method.</span></span> <span data-ttu-id="5c6b7-319">To není překvapující, protože se jedná o rozhraní API, které bylo zvýrazněno analyzátorem přenosové schopnosti .NET na začátku tohoto procesu migrace.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-319">This isn't surprising since this is an API that was highlighted by the .NET Portability Analyzer at the beginning of this migration process.</span></span> <span data-ttu-id="5c6b7-320">Při `BeanTraderServiceClient` pohledu na upozorňuje me na větší problém, ačkoli.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-320">Looking at `BeanTraderServiceClient` draws our attention to a larger issue, though.</span></span> <span data-ttu-id="5c6b7-321">Tento klient WCF byl automaticky generován nástrojem [Svcutil.exe.](../../framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md)</span><span class="sxs-lookup"><span data-stu-id="5c6b7-321">This WCF client was autogenerated by the [Svcutil.exe](../../framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md) tool.</span></span>

<span data-ttu-id="5c6b7-322">**WCF klienti generované Svcutil jsou určeny pro použití na rozhraní .NET Framework.**</span><span class="sxs-lookup"><span data-stu-id="5c6b7-322">**WCF clients generated by Svcutil are meant for use on .NET Framework.**</span></span>

<span data-ttu-id="5c6b7-323">Řešení, která používají klienty WCF generované svcutil, budou muset znovu vygenerovat klienty kompatibilní se standardem .NET pro použití s rozhraním .NET Core.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-323">Solutions that use svcutil-generated WCF clients will need to regenerate .NET Standard-compatible clients for use with .NET Core.</span></span> <span data-ttu-id="5c6b7-324">Jedním z hlavních důvodů, proč staří klienti nebudou fungovat, je, že závisí na konfiguraci aplikace pro definování vazby WCF a koncových bodů.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-324">One of the main reasons the old clients won't work is that they depend on app configuration for defining WCF bindings and endpoints.</span></span> <span data-ttu-id="5c6b7-325">Vzhledem k tomu, že rozhraní API WCF standardu .NET mohou fungovat napříč platformami (kde rozhraní API System.Configuration NEJSOU k dispozici), musí klienti WCF pro scénáře .NET Core a .NET Standard definovat vazby a koncové body programově namísto v konfiguraci.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-325">Because .NET Standard WCF APIs can work cross-platform (where System.Configuration APIs aren't available), WCF clients for .NET Core and .NET Standard scenarios must define bindings and endpoints programmatically instead of in configuration.</span></span>

<span data-ttu-id="5c6b7-326">Ve skutečnosti jakékoli wcf využití klienta, který závisí na `<system.serviceModel>` app.config části (zda vytvořené s Svcutil nebo ručně) bude muset být změněn a pracovat na .NET Core.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-326">In fact, any WCF client usage that depends on the `<system.serviceModel>` app.config section (whether created with Svcutil or manually) will need to be changed to work on .NET Core.</span></span>

<span data-ttu-id="5c6b7-327">Existují dva způsoby automatického generování klientů WCF kompatibilních se standardem .NET:</span><span class="sxs-lookup"><span data-stu-id="5c6b7-327">There are two ways to automatically generate .NET Standard-compatible WCF clients:</span></span>

- <span data-ttu-id="5c6b7-328">Nástroj `dotnet-svcutil` je nástroj .NET, který generuje wcf klienty způsobem, který je podobný tomu, jak Svcutil pracoval dříve.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-328">The `dotnet-svcutil` tool is a .NET tool that generates WCF clients in a way that is similar to how Svcutil worked previously.</span></span>
- <span data-ttu-id="5c6b7-329">Visual Studio může generovat klienty WCF pomocí [možnosti WCF Web Service Reference](../../core/additional-tools/wcf-web-service-reference-guide.md) jeho funkce Připojené služby.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-329">Visual Studio can generate WCF clients using the [WCF Web Service Reference](../../core/additional-tools/wcf-web-service-reference-guide.md) option of its Connected Services feature.</span></span>

<span data-ttu-id="5c6b7-330">Oba přístup funguje dobře.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-330">Either approach works well.</span></span> <span data-ttu-id="5c6b7-331">Případně, samozřejmě, můžete napsat kód klienta WCF sami.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-331">Alternatively, of course, you could write the WCF client code yourself.</span></span> <span data-ttu-id="5c6b7-332">V této ukázce jsem se rozhodl použít funkci Visual Studio Connected Service.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-332">For this sample, I chose to use the Visual Studio Connected Service feature.</span></span> <span data-ttu-id="5c6b7-333">Chcete-li to provést, klikněte pravým tlačítkem myši na projekt *BeanTraderClient.Core* v průzkumníku řešení sady Visual Studio a vyberte **přidat** > **připojenou službu**.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-333">To do that, right-click on the *BeanTraderClient.Core* project in Visual Studio's solution explorer and select **Add** > **Connected Service**.</span></span> <span data-ttu-id="5c6b7-334">Dále zvolte wcf webové služby referenčního zprostředkovatele.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-334">Next, choose the WCF Web Service Reference Provider.</span></span> <span data-ttu-id="5c6b7-335">Tím se zobrazí dialogové okno, kde můžete zadat adresu webové služby back-end Bean Trader (pokud`localhost:8080` používáte server místně) a obor názvů, který by měl ygenerovat typy ( například**BeanTrader.Service).**</span><span class="sxs-lookup"><span data-stu-id="5c6b7-335">This will bring up a dialog where you can specify the address of the backend Bean Trader web service (`localhost:8080` if you are running the server locally) and the namespace that generated types should use (**BeanTrader.Service**, for example).</span></span>

![Dialogové okno Připojené služby wcf webové služby](./media/convert-project-from-net-framework/connected-service-dialog.png)

<span data-ttu-id="5c6b7-337">Po výběru tlačítka **Dokončit** je do projektu přidán nový uzel Připojené služby a pod tento uzel, který obsahuje nového klienta WCF standardu .NET pro přístup ke službě Bean Trader, je přidán soubor Reference.cs.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-337">After you select the **Finish** button, a new Connected Services node is added to the project and a Reference.cs file is added under that node containing the new .NET Standard WCF client for accessing the Bean Trader service.</span></span> <span data-ttu-id="5c6b7-338">Pokud se podíváte na `GetEndpointAddress` metody nebo `GetBindingForEndpoint` v tomto souboru, uvidíte, že vazby a koncové body jsou nyní generovány programově (namísto prostřednictvím konfigurace aplikace).</span><span class="sxs-lookup"><span data-stu-id="5c6b7-338">If you look at the `GetEndpointAddress` or `GetBindingForEndpoint` methods in that file, you'll see that bindings and endpoints are now generated programmatically (instead of via app config).</span></span> <span data-ttu-id="5c6b7-339">Funkce Přidat připojené služby může také přidat odkazy na některé balíčky System.ServiceModel v souboru projektu, které nejsou potřeba, protože všechny potřebné balíčky WCF jsou zahrnuty prostřednictvím Microsoft.Windows.Compatibility.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-339">The 'Add Connected Services' feature may also add references to some System.ServiceModel packages in the project file, which aren't needed since all necessary WCF packages are included via Microsoft.Windows.Compatibility.</span></span> <span data-ttu-id="5c6b7-340">Zkontrolujte csproj, zda byly přidány `<PackageReference>` nějaké další položky System.ServiceModel, a pokud ano, odstraňte je.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-340">Check the csproj to see if any extra System.ServiceModel `<PackageReference>` items have been added, and if so, remove them.</span></span>

<span data-ttu-id="5c6b7-341">Náš projekt má nyní nové třídy klientů WCF (v *Reference.cs),* ale stále má i ty staré (v BeanTrader.cs).</span><span class="sxs-lookup"><span data-stu-id="5c6b7-341">Our project has new WCF client classes now (in *Reference.cs*), but it also still has the old ones (in BeanTrader.cs).</span></span> <span data-ttu-id="5c6b7-342">V tomto okamžiku existují dvě možnosti:</span><span class="sxs-lookup"><span data-stu-id="5c6b7-342">There are two options at this point:</span></span>

- <span data-ttu-id="5c6b7-343">Pokud chcete mít možnost sestavit původní projekt rozhraní .NET Framework (vedle nového projektu cíleného na jádro .NET), můžete použít položku `<Compile Remove="BeanTrader.cs" />` v souboru csproj projektu .NET Core tak, aby verze .NET Framework a .NET Core aplikace používaly různé klienty WCF.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-343">If you want to be able to build the original .NET Framework project (alongside the new .NET Core-targeted one), you can use a `<Compile Remove="BeanTrader.cs" />` item in the .NET Core project's csproj file so that the .NET Framework and .NET Core versions of the app use different WCF clients.</span></span> <span data-ttu-id="5c6b7-344">To má tu výhodu, že ponechává existující projekt rozhraní .NET Framework beze změny, ale má nevýhodu, že kód pomocí generované wcf klienty může být nutné mírně `#if` lišit v případě .NET Core, než tomu bylo v projektu rozhraní .NET Framework, takže budete pravděpodobně muset použít direktivy podmíněně zkompilovat některé wcf klienta použití (vytváření klientů, například) pracovat jedním způsobem při sestavení pro .NET Core a jiným způsobem při sestavení pro rozhraní .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-344">This has the advantage of leaving the existing .NET Framework project unchanged, but has the disadvantage that code using the generated WCF clients may need to be slightly different in the .NET Core case than it was in the .NET Framework project, so you'll likely need to use `#if` directives to conditionally compile some WCF client usage (creating clients, for example) to work one way when built for .NET Core and another way when built for .NET Framework.</span></span>

- <span data-ttu-id="5c6b7-345">Pokud na druhé straně některé změny kódu v existujícím projektu rozhraní .NET Framework je přijatelné, můžete odebrat *BeanTrader.cs* všechny dohromady.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-345">If, on the other hand, some code churn in the existing .NET Framework project is acceptable, you can remove *BeanTrader.cs* all together.</span></span> <span data-ttu-id="5c6b7-346">Vzhledem k tomu, že nový klient WCF je vytvořen pro standard .NET, bude fungovat ve scénářích .NET Core i .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-346">Because the new WCF client is built for .NET Standard, it will work in both .NET Core and .NET Framework scenarios.</span></span> <span data-ttu-id="5c6b7-347">Pokud vytváříte rozhraní .NET Framework navíc k rozhraní .NET Core (buď pomocí více násobného cílení, nebo dvěma soubory csproj), můžete tento nový *soubor Reference.cs* použít pro oba cíle.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-347">If you are building for .NET Framework in addition to .NET Core (either by multi-targeting or by having two csproj files), you can use this new *Reference.cs* file for both targets.</span></span> <span data-ttu-id="5c6b7-348">Tento přístup má výhodu, že kód nebude muset rozdvojit pro podporu dvou různých klientů WCF; stejný kód bude použit všude.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-348">This approach has the advantage that the code won't need to bifurcate to support two different WCF clients; the same code will be used everywhere.</span></span> <span data-ttu-id="5c6b7-349">Nevýhodou je, že zahrnuje změnu (pravděpodobně stabilní) .NET Framework projektu.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-349">The drawback is that it involves changing the (presumably stable) .NET Framework project.</span></span>

<span data-ttu-id="5c6b7-350">V případě ukázky Bean Trader můžete provést malé změny původního projektu, pokud usnadňuje migraci, postupujte takto a odsouhlasete využití klienta WCF:</span><span class="sxs-lookup"><span data-stu-id="5c6b7-350">In the case of the Bean Trader sample, you can make small changes to the original project if it makes migration easier, so follow these steps to reconcile WCF client usage:</span></span>

01. <span data-ttu-id="5c6b7-351">Přidejte nový soubor Reference.cs do projektu .NET Framework *BeanTraderClient.csproj* pomocí kontextové nabídky "Přidat existující položku" z průzkumníka řešení.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-351">Add the new Reference.cs file to the .NET Framework *BeanTraderClient.csproj* project using the 'Add existing item' context menu from the solution explorer.</span></span> <span data-ttu-id="5c6b7-352">Nezapomeňte přidat "jako odkaz", takže stejný soubor je používán oběma projekty (na rozdíl od kopírování souboru C#).</span><span class="sxs-lookup"><span data-stu-id="5c6b7-352">Be sure to add 'as link' so that the same file is used by both projects (as opposed to copying the C# file).</span></span> <span data-ttu-id="5c6b7-353">Pokud vytváříte pro rozhraní .NET Core i .NET Framework pomocí jednoho csproj (pomocí vícenásobného cílení), není tento krok nutný.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-353">If you are building for both .NET Core and .NET Framework with a single csproj (using multi-targeting) then this step isn't necessary.</span></span>

01. <span data-ttu-id="5c6b7-354">Odstranit *BeanTrader.cs*.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-354">Delete *BeanTrader.cs*.</span></span>

01. <span data-ttu-id="5c6b7-355">Nový klient WCF je podobný starému, ale počet oborů názvů ve generovaném kódu se liší.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-355">The new WCF client is similar to the old one, but a number of namespaces in the generated code are different.</span></span> <span data-ttu-id="5c6b7-356">Z tohoto důvodu je nutné aktualizovat projekt tak, aby wcf typy klientů jsou používány z BeanTrader.Service (nebo bez ohledu na název oboru názvů, který jste zvolili) namísto BeanTrader.Model nebo bez oboru názvů.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-356">Because of this, it is necessary to update the project so that WCF client types are used from BeanTrader.Service (or whatever namespace name you chose) instead of BeanTrader.Model or without a namespace.</span></span> <span data-ttu-id="5c6b7-357">Budování *BeanTraderClient.Core.csproj* pomůže určit, kde je třeba tyto změny provést.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-357">Building *BeanTraderClient.Core.csproj* will help to identify where these changes need to be made.</span></span> <span data-ttu-id="5c6b7-358">Opravy budou potřebné jak v C# a ve zdrojových souborech XAML.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-358">Fixes will be needed both in C# and in XAML source files.</span></span>

01. <span data-ttu-id="5c6b7-359">Nakonec zjistíte, že je chyba v *BeanTraderServiceClientFactory.cs* protože dostupné konstruktory pro `BeanTraderServiceClient` typ se změnily.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-359">Finally, you'll discover that there is an error in *BeanTraderServiceClientFactory.cs* because the available constructors for the `BeanTraderServiceClient` type have changed.</span></span> <span data-ttu-id="5c6b7-360">Dříve bylo možné zadat `InstanceContext` argument (který byl `CallbackHandler` vytvořen `Castle.Windsor` pomocí kontejneru IoC).</span><span class="sxs-lookup"><span data-stu-id="5c6b7-360">It used to be possible to supply an `InstanceContext` argument (which was created using a `CallbackHandler` from the `Castle.Windsor` IoC container).</span></span> <span data-ttu-id="5c6b7-361">Nové konstruktory vytvořit `CallbackHandler`nové s.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-361">The new constructors create new `CallbackHandler`s.</span></span> <span data-ttu-id="5c6b7-362">Existují však konstruktory `BeanTraderServiceClient`v základním typu společnosti , které odpovídají tomu, co chcete.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-362">There are, however, constructors in `BeanTraderServiceClient`'s base type that match what you want.</span></span> <span data-ttu-id="5c6b7-363">Vzhledem k tomu, že automaticky vygenerovaný kód klienta WCF existuje všechny existují v částečné třídy, můžete jej snadno rozšířit.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-363">Since the autogenerated WCF client code all exists in partial classes, you can easily extend it.</span></span> <span data-ttu-id="5c6b7-364">Chcete-li to provést, vytvořte nový soubor s názvem *BeanTraderServiceClient.cs* a potom vytvořte částečnou třídu se stejným názvem (pomocí oboru názvů BeanTrader.Service).</span><span class="sxs-lookup"><span data-stu-id="5c6b7-364">To do this, create a new file called *BeanTraderServiceClient.cs* and then create a partial class with that same name (using the BeanTrader.Service namespace).</span></span> <span data-ttu-id="5c6b7-365">Potom přidejte jeden konstruktor k částečnému typu, jak je znázorněno zde.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-365">Then, add one constructor to the partial type as shown here.</span></span>

    ```csharp
    public BeanTraderServiceClient(System.ServiceModel.InstanceContext callbackInstance) :
        base(callbackInstance, EndpointConfiguration.NetTcpBinding_BeanTraderService)
            { }
    ```

<span data-ttu-id="5c6b7-366">S těmito změnami provedené, bude Bean Trader ukázka nyní používat nový klient WCF kompatibilní `Open` se standardem `await OpenAsync` .NET a můžete provést konečnou opravu změny volání v *TradingService.cs* použít místo.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-366">With those changes made, the Bean Trader sample will now be using a new .NET Standard-compatible WCF client and you can make the final fix of changing the `Open` call in *TradingService.cs* to use `await OpenAsync` instead.</span></span>

<span data-ttu-id="5c6b7-367">S problémy WCF vyřešeny , .NET Core verze ukázky Bean Trader nyní staví čistě!</span><span class="sxs-lookup"><span data-stu-id="5c6b7-367">With the WCF issues addressed, the .NET Core version of the Bean Trader sample now builds cleanly!</span></span>

## <a name="runtime-testing"></a><span data-ttu-id="5c6b7-368">Testování za běhu</span><span class="sxs-lookup"><span data-stu-id="5c6b7-368">Runtime testing</span></span>

<span data-ttu-id="5c6b7-369">Je snadné zapomenout, že migrace práce není provedeno, jakmile projekt vytvoří čistě proti .NET Core.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-369">It's easy to forget that migration work isn't done as soon as the project builds cleanly against .NET Core.</span></span> <span data-ttu-id="5c6b7-370">Je důležité ponechat čas na testování portované aplikace.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-370">It's important to leave time for testing the ported app, too.</span></span> <span data-ttu-id="5c6b7-371">Jakmile se věci úspěšně vytvoří, ujistěte se, že aplikace běží a funguje podle očekávání, zejména pokud používáte všechny balíčky zaměřené na rozhraní .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-371">Once things build successfully, make sure the app runs and works as expected, especially if you are using any packages targeting .NET Framework.</span></span>

<span data-ttu-id="5c6b7-372">Zkusme spustit portovnu Bean Trader app a uvidíme, co se stane.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-372">Let's try launching the ported Bean Trader app and see what happens.</span></span> <span data-ttu-id="5c6b7-373">Aplikace se nedostane daleko před selháním s následující výjimkou.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-373">The app doesn't get far before failing with the following exception.</span></span>

```output
System.Configuration.ConfigurationErrorsException: 'Configuration system failed to initialize'

Inner Exception
ConfigurationErrorsException: Unrecognized configuration section system.serviceModel.
```

<span data-ttu-id="5c6b7-374">To dává smysl, samozřejmě.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-374">This makes sense, of course.</span></span> <span data-ttu-id="5c6b7-375">Nezapomeňte, že WCF již nepoužívá konfiguraci aplikace, takže je třeba odebrat starou část system.serviceModel souboru app.config.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-375">Remember that WCF no longer uses app configuration, so the old system.serviceModel section of the app.config file needs to be removed.</span></span> <span data-ttu-id="5c6b7-376">Aktualizovaný klient WCF obsahuje všechny stejné informace ve svém kódu, takže konfigurační část již není potřeba.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-376">The updated WCF client includes all of the same information in its code, so the config section isn't needed anymore.</span></span> <span data-ttu-id="5c6b7-377">Pokud jste chtěli, aby koncový bod WCF byl konfigurovatelný v souboru app.config, můžete jej přidat jako nastavení aplikace a aktualizovat kód klienta WCF, abyste načetli koncový bod služby WCF z konfigurace.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-377">If you wanted the WCF endpoint to be configurable in app.config, you could add it as an app setting and update the WCF client code to retrieve the WCF service endpoint from configuration.</span></span>

<span data-ttu-id="5c6b7-378">Po odebrání system.serviceModel části *app.config*, aplikace spustí, ale selže s jinou výjimkou při přihlášení uživatele.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-378">After removing the system.serviceModel section of *app.config*, the app launches but fails with another exception when a user signs in.</span></span>

```output
System.PlatformNotSupportedException: 'Operation is not supported on this platform.'
```

<span data-ttu-id="5c6b7-379">Nepodporované rozhraní `Func<T>.BeginInvoke`API je .</span><span class="sxs-lookup"><span data-stu-id="5c6b7-379">The unsupported API is `Func<T>.BeginInvoke`.</span></span> <span data-ttu-id="5c6b7-380">Jak je vysvětleno v [dotnet/corefx#5940](https://github.com/dotnet/corefx/issues/5940), `BeginInvoke` .NET Core nepodporuje metody a `EndInvoke` na typy delegátů z důvodu základních závislostí vzdálené komunikace.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-380">As explained in [dotnet/corefx#5940](https://github.com/dotnet/corefx/issues/5940), .NET Core doesn't support the `BeginInvoke` and `EndInvoke` methods on delegate types due to underlying remoting dependencies.</span></span> <span data-ttu-id="5c6b7-381">Tento problém a jeho oprava jsou podrobněji vysvětleny v [migrující Delegate.BeginInvoke volání pro .NET Core](https://devblogs.microsoft.com/dotnet/migrating-delegate-begininvoke-calls-for-net-core/) blogu, ale podstata je, že `BeginInvoke` a `EndInvoke` volání by měla být nahrazena `Task.Run` (nebo asynchronní alternativy, pokud je to možné).</span><span class="sxs-lookup"><span data-stu-id="5c6b7-381">This issue and its fix are explained in more detail in the [Migrating Delegate.BeginInvoke Calls for .NET Core](https://devblogs.microsoft.com/dotnet/migrating-delegate-begininvoke-calls-for-net-core/) blog post, but the gist is that `BeginInvoke` and `EndInvoke` calls should be replaced with `Task.Run` (or async alternatives, if possible).</span></span> <span data-ttu-id="5c6b7-382">Použití obecné řešení zde `BeginInvoke` volání může být `Invoke` nahrazen o `Task.Run`volání zahájené .</span><span class="sxs-lookup"><span data-stu-id="5c6b7-382">Applying the general solution here, the `BeginInvoke` call can be replaced with an `Invoke` call launched by `Task.Run`.</span></span>

```csharp
Task.Run(() =>
{
    return userInfoRetriever.Invoke();
}).ContinueWith(result =>
{
    // BeginInvoke's callback is replaced with ContinueWith
    var task = result.ConfigureAwait(false);
    CurrentTrader = task.GetAwaiter().GetResult();
}, TaskScheduler.Default);
```

<span data-ttu-id="5c6b7-383">Po odebrání `BeginInvoke` využití se aplikace Bean Trader úspěšně spustí na .NET Core!</span><span class="sxs-lookup"><span data-stu-id="5c6b7-383">After removing the `BeginInvoke` usage, the Bean Trader app runs successfully on .NET Core!</span></span>

![Obchodník s beanem běžící na jádru .NET](./media/convert-project-from-net-framework/running-on-core.png)

<span data-ttu-id="5c6b7-385">Všechny aplikace se liší, takže konkrétní kroky potřebné k migraci vlastních aplikací do .NET Core se budou lišit.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-385">All apps are different, so the specific steps needed to migrate your own apps to .NET Core will vary.</span></span> <span data-ttu-id="5c6b7-386">Ale doufejme, že ukázka Bean Trader demonstruje obecný pracovní postup a typy problémů, které lze očekávat.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-386">But hopefully the Bean Trader sample demonstrates the general workflow and the types of issues that can be expected.</span></span> <span data-ttu-id="5c6b7-387">A navzdory délce tohoto článku byly skutečné změny potřebné ve vzorku Bean Trader, aby fungovaly na .NET Core, poměrně omezené.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-387">And, despite this article's length, the actual changes needed in the Bean Trader sample to make it work on .NET Core were fairly limited.</span></span> <span data-ttu-id="5c6b7-388">Mnoho aplikací migruje do .NET Core stejným způsobem; s omezenými nebo dokonce žádnými potřebnými změnami kódu.</span><span class="sxs-lookup"><span data-stu-id="5c6b7-388">Many apps migrate to .NET Core in this same way; with limited or even no code changes needed.</span></span>
