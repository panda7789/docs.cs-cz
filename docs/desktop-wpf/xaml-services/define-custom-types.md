---
title: Definování vlastních typů pro použití s .NET XAML Services
ms.date: 03/30/2017
helpviewer_keywords:
- defining custom types [XAML Services]
ms.assetid: c2667cbd-2f46-4a7f-9dfc-53696e35e8e4
ms.openlocfilehash: ff7e4229450e801a6d618c5141efde8cdcbef03d
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 03/12/2020
ms.locfileid: "82071855"
---
# <a name="define-custom-types-for-use-with-net-xaml-services"></a><span data-ttu-id="b9276-102">Definování vlastních typů pro použití se službami .NET XAML Services</span><span class="sxs-lookup"><span data-stu-id="b9276-102">Define custom types for use with .NET XAML Services</span></span>

<span data-ttu-id="b9276-103">Při definování vlastní typy, které jsou obchodní objekty nebo typy, které nemají závislost na konkrétní rozhraní, existují určité osvědčené postupy pro XAML můžete sledovat.</span><span class="sxs-lookup"><span data-stu-id="b9276-103">When you define custom types that are business objects or are types that do not have a dependency on specific frameworks, there are certain best practices for XAML you can follow.</span></span> <span data-ttu-id="b9276-104">Pokud budete postupovat podle těchto postupů, .NET XAML Services a jeho XAML čtečky a Zapisovače XAML můžete zjistit xaml charakteristiky vašeho typu a poskytnout mu odpovídající reprezentaci v datovém proudu uzlu XAML pomocí systému typu XAML.</span><span class="sxs-lookup"><span data-stu-id="b9276-104">If you follow these practices, .NET XAML Services and its XAML readers and XAML writers can discover the XAML characteristics of your type and give it appropriate representation in a XAML node stream using the XAML type system.</span></span> <span data-ttu-id="b9276-105">Toto téma popisuje osvědčené postupy pro definice typů, definice členů a clr přiřazení typů nebo členů.</span><span class="sxs-lookup"><span data-stu-id="b9276-105">This topic describes best practices for type definitions, member definitions, and CLR attributing of types or members.</span></span>

## <a name="constructor-patterns-and-type-definitions-for-xaml"></a><span data-ttu-id="b9276-106">Vzory konstruktoru a definice typů pro XAML</span><span class="sxs-lookup"><span data-stu-id="b9276-106">Constructor Patterns and Type Definitions for XAML</span></span>

<span data-ttu-id="b9276-107">Chcete-li vytvořit instanci jako prvek objektu v XAML, vlastní třída musí splňovat následující požadavky:</span><span class="sxs-lookup"><span data-stu-id="b9276-107">To be instantiated as an object element in XAML, a custom class must meet the following requirements:</span></span>

- <span data-ttu-id="b9276-108">Vlastní třída musí být veřejné a musí vystavit public konstruktor bez parametrů.</span><span class="sxs-lookup"><span data-stu-id="b9276-108">The custom class must be public and must expose a parameterless public constructor.</span></span> <span data-ttu-id="b9276-109">(Poznámky týkající se struktur naleznete v následující části.)</span><span class="sxs-lookup"><span data-stu-id="b9276-109">(See following section for notes regarding structures.)</span></span>

- <span data-ttu-id="b9276-110">Vlastní třída nesmí být vnořenou třídou.</span><span class="sxs-lookup"><span data-stu-id="b9276-110">The custom class must not be a nested class.</span></span> <span data-ttu-id="b9276-111">Extra "tečka" v cestě celého názvu způsobí, že dělení oboru názvů třídy je nejednoznačné a narušuje jiné funkce XAML, jako jsou připojené vlastnosti.</span><span class="sxs-lookup"><span data-stu-id="b9276-111">The extra "dot" in the full-name path makes the class-namespace division ambiguous, and interferes with other XAML features such as attached properties.</span></span>
<span data-ttu-id="b9276-112">Pokud objekt může být vytvořena jako prvek objektu, vytvořený objekt může vyplnit formulář prvku vlastnosti všech vlastností, které berou objekt jako jejich základní typ.</span><span class="sxs-lookup"><span data-stu-id="b9276-112">If an object can be instantiated as an object element, the created object can fill the property element form of any properties that take the object as their underlying type.</span></span>

<span data-ttu-id="b9276-113">Stále můžete zadat hodnoty objektů pro typy, které nesplňují tato kritéria, pokud povolíte převaděč hodnot.</span><span class="sxs-lookup"><span data-stu-id="b9276-113">You can still provide object values for types that do not meet these criteria, if you enable a value converter.</span></span> <span data-ttu-id="b9276-114">Další informace naleznete v [tématu Type Converters and Markup Extensions for XAML](type-converters-and-markup-extensions.md).</span><span class="sxs-lookup"><span data-stu-id="b9276-114">For more information, see [Type Converters and Markup Extensions for XAML](type-converters-and-markup-extensions.md).</span></span>

### <a name="structures"></a><span data-ttu-id="b9276-115">Struktury</span><span class="sxs-lookup"><span data-stu-id="b9276-115">Structures</span></span>

<span data-ttu-id="b9276-116">Struktury lze vždy sestavit v XAML podle definice CLR.</span><span class="sxs-lookup"><span data-stu-id="b9276-116">Structures are always able to be constructed in XAML, by CLR definition.</span></span> <span data-ttu-id="b9276-117">Důvodem je, že kompilátor CLR implicitně vytvoří konstruktor bez parametrů pro strukturu.</span><span class="sxs-lookup"><span data-stu-id="b9276-117">This is because a CLR compiler implicitly creates a parameterless constructor for a structure.</span></span> <span data-ttu-id="b9276-118">Tento konstruktor inicializuje všechny hodnoty vlastností na jejich výchozí hodnoty.</span><span class="sxs-lookup"><span data-stu-id="b9276-118">This constructor initializes all property values to their defaults.</span></span>

<span data-ttu-id="b9276-119">V některých případech není žádoucí výchozí konstrukční chování pro strukturu.</span><span class="sxs-lookup"><span data-stu-id="b9276-119">In some cases, the default construction behavior for a structure is not desirable.</span></span> <span data-ttu-id="b9276-120">To může být způsobeno tím, že struktura je určena k vyplnění hodnot a funkce koncepčně jako unie.</span><span class="sxs-lookup"><span data-stu-id="b9276-120">This might be because the structure is intended to fill values and function conceptually as a union.</span></span> <span data-ttu-id="b9276-121">Jako unie obsažené hodnoty může mít vzájemně se vylučující interpretace, a proto žádné z jeho vlastností jsou taelné.</span><span class="sxs-lookup"><span data-stu-id="b9276-121">As a union, the contained values might have mutually exclusive interpretations, and therefore, none of its properties are settable.</span></span> <span data-ttu-id="b9276-122">Příkladem takové struktury ve slovníku WPF <xref:System.Windows.GridLength>je .</span><span class="sxs-lookup"><span data-stu-id="b9276-122">An example of such a structure in the WPF vocabulary is <xref:System.Windows.GridLength>.</span></span> <span data-ttu-id="b9276-123">Tyto struktury by měly implementovat převaděč typu tak, aby hodnoty mohou být vyjádřeny ve formě atributu pomocí konvence řetězce, které vytvářejí různé interpretace nebo režimy hodnoty struktury.</span><span class="sxs-lookup"><span data-stu-id="b9276-123">Such structures should implement a type converter so that the values can be expressed in attribute form, by using string conventions that create the different interpretations or modes of the structure values.</span></span> <span data-ttu-id="b9276-124">Struktura by měla také vystavit podobné chování pro konstrukci kódu prostřednictvím konstruktoru bez parametrů.</span><span class="sxs-lookup"><span data-stu-id="b9276-124">The structure should also expose similar behavior for code construction through a non-parameterless constructor.</span></span>

### <a name="interfaces"></a><span data-ttu-id="b9276-125">Rozhraní</span><span class="sxs-lookup"><span data-stu-id="b9276-125">Interfaces</span></span>

<span data-ttu-id="b9276-126">Rozhraní lze použít jako základní typy členů.</span><span class="sxs-lookup"><span data-stu-id="b9276-126">Interfaces can be used as underlying types of members.</span></span> <span data-ttu-id="b9276-127">Systém typu XAML zkontroluje přiřaditelný seznam a očekává, že objekt, který je k dispozici jako hodnota může být přiřazen a rozhraní.</span><span class="sxs-lookup"><span data-stu-id="b9276-127">The XAML type system checks the assignable list and expects that the object that is provided as the value can be assigned to the interface.</span></span> <span data-ttu-id="b9276-128">Neexistuje žádný koncept, jak rozhraní musí být prezentovány jako typ XAML tak dlouho, dokud příslušný přiřaditelný typ podporuje požadavky na konstrukci XAML.</span><span class="sxs-lookup"><span data-stu-id="b9276-128">There is no concept of how the interface must be presented as a XAML type as long as a relevant assignable type supports the XAML construction requirements.</span></span>

### <a name="factory-methods"></a><span data-ttu-id="b9276-129">Výrobní metody</span><span class="sxs-lookup"><span data-stu-id="b9276-129">Factory Methods</span></span>

<span data-ttu-id="b9276-130">Metody výroby jsou funkcí XAML 2009.</span><span class="sxs-lookup"><span data-stu-id="b9276-130">Factory methods are a XAML 2009 feature.</span></span> <span data-ttu-id="b9276-131">Upravují princip XAML, že objekty musí mít konstruktory bez parametrů.</span><span class="sxs-lookup"><span data-stu-id="b9276-131">They modify the XAML principle that objects must have parameterless constructors.</span></span> <span data-ttu-id="b9276-132">Metody výroby nejsou v tomto článku popsány.</span><span class="sxs-lookup"><span data-stu-id="b9276-132">Factory methods are not documented in this article.</span></span> <span data-ttu-id="b9276-133">Viz [x:Směrnice metod výroby](xfactorymethod-directive.md).</span><span class="sxs-lookup"><span data-stu-id="b9276-133">See [x:FactoryMethod Directive](xfactorymethod-directive.md).</span></span>

## <a name="enumerations"></a><span data-ttu-id="b9276-134">Výčty</span><span class="sxs-lookup"><span data-stu-id="b9276-134">Enumerations</span></span>

<span data-ttu-id="b9276-135">Výčty mají chování převodu nativního typu XAML.</span><span class="sxs-lookup"><span data-stu-id="b9276-135">Enumerations have XAML native type conversion behavior.</span></span> <span data-ttu-id="b9276-136">Názvy konstant výčtu zadané v xaml jsou vyřešeny proti základní typ výčtu a vrátit hodnotu výčtu zapisovačobjektu XAML.</span><span class="sxs-lookup"><span data-stu-id="b9276-136">Enumeration constant names specified in XAML are resolved against the underlying enumeration type, and return the enumeration value to a XAML object writer.</span></span>

<span data-ttu-id="b9276-137">XAML podporuje použití ve stylu příznaků pro <xref:System.FlagsAttribute> výčty s aplikovaným.</span><span class="sxs-lookup"><span data-stu-id="b9276-137">XAML supports a flags-style usage for enumerations with <xref:System.FlagsAttribute> applied.</span></span> <span data-ttu-id="b9276-138">Další informace naleznete [v tématu Syntaxe XAML v detailu](../../framework/wpf/advanced/xaml-syntax-in-detail.md).</span><span class="sxs-lookup"><span data-stu-id="b9276-138">For more information, see [XAML Syntax In Detail](../../framework/wpf/advanced/xaml-syntax-in-detail.md).</span></span> <span data-ttu-id="b9276-139">([Syntaxe XAML V detailu](../../framework/wpf/advanced/xaml-syntax-in-detail.md) je napsána pro cílovou skupinu WPF, ale většina informací v tomto tématu je relevantní pro XAML, který není specifický pro konkrétní prováděcí rámec.)</span><span class="sxs-lookup"><span data-stu-id="b9276-139">([XAML Syntax In Detail](../../framework/wpf/advanced/xaml-syntax-in-detail.md) is written for the WPF audience, but most of the information in that topic is relevant for XAML that is not specific to a particular implementing framework.)</span></span>

## <a name="member-definitions"></a><span data-ttu-id="b9276-140">Definice členů</span><span class="sxs-lookup"><span data-stu-id="b9276-140">Member Definitions</span></span>

<span data-ttu-id="b9276-141">Typy můžete definovat členy pro použití XAML.</span><span class="sxs-lookup"><span data-stu-id="b9276-141">Types can define members for XAML usage.</span></span> <span data-ttu-id="b9276-142">Je možné pro typy definovat členy, které jsou xaml použitelné i v případě, že tento konkrétní typ není xaml použitelné.</span><span class="sxs-lookup"><span data-stu-id="b9276-142">It's possible for types to define members that are XAML-usable even if that specific type is not XAML-usable.</span></span> <span data-ttu-id="b9276-143">To je možné z důvodu dědičnosti CLR.</span><span class="sxs-lookup"><span data-stu-id="b9276-143">This is possible because of CLR inheritance.</span></span> <span data-ttu-id="b9276-144">Tak dlouho, dokud některé typy, které dědí člen podporuje xaml použití jako typ a člen podporuje xaml použití pro jeho základní typ nebo má nativní syntaxi XAML k dispozici, tento člen je XAML použitelné.</span><span class="sxs-lookup"><span data-stu-id="b9276-144">So long as some type that inherits the member supports XAML usage as a type, and the member supports XAML usage for its underlying type or has a native XAML syntax available, that member is XAML-usable.</span></span>

### <a name="properties"></a><span data-ttu-id="b9276-145">Vlastnosti</span><span class="sxs-lookup"><span data-stu-id="b9276-145">Properties</span></span>

<span data-ttu-id="b9276-146">Pokud definujete vlastnosti jako veřejnou vlastnost `get` CLR pomocí typických vzorů CLR a `set` přistupujícího objektu a klíčových slov <xref:System.Xaml.XamlMember> odpovídajících jazyku, systém typu XAML může tuto vlastnost hlásit jako člena s příslušnými informacemi pro vlastnosti, například <xref:System.Xaml.XamlMember.IsReadPublic%2A> a <xref:System.Xaml.XamlMember.IsWritePublic%2A>.</span><span class="sxs-lookup"><span data-stu-id="b9276-146">If you define properties as a public CLR property using the typical CLR `get` and `set` accessor patterns and language-appropriate keywording, the XAML type system can report the property as a member with appropriate information provided for <xref:System.Xaml.XamlMember> properties, such as <xref:System.Xaml.XamlMember.IsReadPublic%2A> and <xref:System.Xaml.XamlMember.IsWritePublic%2A>.</span></span>

<span data-ttu-id="b9276-147">Specifické vlastnosti mohou povolit <xref:System.ComponentModel.TypeConverterAttribute>syntaxi textu použitím aplikace .</span><span class="sxs-lookup"><span data-stu-id="b9276-147">Specific properties can enable a text syntax by applying <xref:System.ComponentModel.TypeConverterAttribute>.</span></span> <span data-ttu-id="b9276-148">Další informace naleznete v [tématu Type Converters and Markup Extensions for XAML](type-converters-and-markup-extensions.md).</span><span class="sxs-lookup"><span data-stu-id="b9276-148">For more information, see [Type Converters and Markup Extensions for XAML](type-converters-and-markup-extensions.md).</span></span>

<span data-ttu-id="b9276-149">Při absenci syntaxe textu nebo nativního převodu XAML a při absenci dalšího dereference, jako<xref:System.Xaml.XamlMember.TargetType%2A> je například použití rozšíření značek, musí být typ vlastnosti ( v systému typu XAML) schopen vrátit instanci zapisovateli objektu XAML tím, že bude cílový typ považován za typ CLR.</span><span class="sxs-lookup"><span data-stu-id="b9276-149">In the absence of a text syntax or native XAML conversion and in the absence of further indirection, such as a markup extension usage, the type of a property (<xref:System.Xaml.XamlMember.TargetType%2A> in the XAML type system) must be able to return an instance to a XAML object writer by treating the target type as a CLR type.</span></span>

<span data-ttu-id="b9276-150">Pokud používáte XAML 2009, [x:Reference Markup Extension](xreference-markup-extension.md) lze použít k zadání hodnot, pokud nejsou splněny předchozí aspekty; to je však spíše problém s použitím než problém definice typu.</span><span class="sxs-lookup"><span data-stu-id="b9276-150">If using XAML 2009, [x:Reference Markup Extension](xreference-markup-extension.md) can be used to provide values if the previous considerations are not met; however, that is more of a usage issue than a type definition issue.</span></span>

### <a name="events"></a><span data-ttu-id="b9276-151">Události</span><span class="sxs-lookup"><span data-stu-id="b9276-151">Events</span></span>

<span data-ttu-id="b9276-152">Pokud definujete události jako veřejnou událost CLR, systém typu XAML <xref:System.Xaml.XamlMember.IsEvent%2A> `true`může hlásit událost jako člen s jako .</span><span class="sxs-lookup"><span data-stu-id="b9276-152">If you define events as a public CLR event, the XAML type system can report the event as a member with <xref:System.Xaml.XamlMember.IsEvent%2A> as `true`.</span></span> <span data-ttu-id="b9276-153">Zapojení obslužných rutin událostí není v rámci možností služby .NET XAML Services. zapojení je ponecháno na konkrétních rámcích a implementacích.</span><span class="sxs-lookup"><span data-stu-id="b9276-153">Wiring the event handlers is not within the scope of .NET XAML Services capabilities; wiring is left to specific frameworks and implementations.</span></span>

### <a name="methods"></a><span data-ttu-id="b9276-154">Metody</span><span class="sxs-lookup"><span data-stu-id="b9276-154">Methods</span></span>

<span data-ttu-id="b9276-155">Vsazený kód pro metody není výchozí funkcí XAML.</span><span class="sxs-lookup"><span data-stu-id="b9276-155">Inline code for methods is not a default XAML capability.</span></span> <span data-ttu-id="b9276-156">Ve většině případů není přímo odkazovat na členy metody z XAML a role metod v XAML je pouze poskytovat podporu pro konkrétní vzory XAML.</span><span class="sxs-lookup"><span data-stu-id="b9276-156">In most cases, you do not directly reference method members from XAML, and the role of methods in XAML is only to provide support for specific XAML patterns.</span></span> <span data-ttu-id="b9276-157">[x:FactoryMethod směrnice](xfactorymethod-directive.md) je výjimkou.</span><span class="sxs-lookup"><span data-stu-id="b9276-157">[x:FactoryMethod Directive](xfactorymethod-directive.md) is an exception.</span></span>

### <a name="fields"></a><span data-ttu-id="b9276-158">Pole</span><span class="sxs-lookup"><span data-stu-id="b9276-158">Fields</span></span>

<span data-ttu-id="b9276-159">Pokyny pro návrh CLR odrazují od nestatických polí.</span><span class="sxs-lookup"><span data-stu-id="b9276-159">CLR design guidelines discourage nonstatic fields.</span></span> <span data-ttu-id="b9276-160">U statických polí můžete přistupovat ke statickým hodnotám polí pouze prostřednictvím [x:Static Markup Extension](xstatic-markup-extension.md); v tomto případě neděláte nic zvláštního v definici CLR vystavit pole pro [x:Statické](xstatic-markup-extension.md) použití.</span><span class="sxs-lookup"><span data-stu-id="b9276-160">For static fields, you can access static field values only through [x:Static Markup Extension](xstatic-markup-extension.md); in this case you are not doing anything special in the CLR definition to expose a field for [x:Static](xstatic-markup-extension.md) usages.</span></span>

## <a name="attachable-members"></a><span data-ttu-id="b9276-161">Připojitelné členy</span><span class="sxs-lookup"><span data-stu-id="b9276-161">Attachable Members</span></span>

<span data-ttu-id="b9276-162">Připojitelné členy jsou vystaveny XAML prostřednictvím vzoru přistupující metody na definující typ.</span><span class="sxs-lookup"><span data-stu-id="b9276-162">Attachable members are exposed to XAML through an accessor method pattern on a defining type.</span></span> <span data-ttu-id="b9276-163">Samotný definující typ nemusí být xaml použitelný jako objekt.</span><span class="sxs-lookup"><span data-stu-id="b9276-163">The defining type itself does not need to be XAML-usable as an object.</span></span> <span data-ttu-id="b9276-164">Ve skutečnosti společný vzor je deklarovat třídu služby, jejíž úlohou je vlastnit připojitelný člen a implementovat související chování, ale slouží žádné jiné funkce, jako je například reprezentace rozhraní.</span><span class="sxs-lookup"><span data-stu-id="b9276-164">In fact, a common pattern is to declare a service class whose role is to own the attachable member and implement the related behaviors, but serve no other function such as a UI representation.</span></span> <span data-ttu-id="b9276-165">Pro následující části zástupný *název PropertyName* představuje název připojitelného člena.</span><span class="sxs-lookup"><span data-stu-id="b9276-165">For the following sections, the placeholder *PropertyName* represents the name of your attachable member.</span></span> <span data-ttu-id="b9276-166">Tento název musí být platný v [xamlname gramatiky](xamlname-grammar.md).</span><span class="sxs-lookup"><span data-stu-id="b9276-166">That name must be valid in the [XamlName Grammar](xamlname-grammar.md).</span></span>

<span data-ttu-id="b9276-167">Buďte opatrní při kolizi názvů mezi těmito vzory a jinými metodami typu.</span><span class="sxs-lookup"><span data-stu-id="b9276-167">Be cautious of name collisions between these patterns and other methods of a type.</span></span> <span data-ttu-id="b9276-168">Pokud člen existuje, který odpovídá jeden ze vzorů, může být interpretován jako připojitelné členské cesty využití procesorem XAML i v případě, že to nebyl váš záměr.</span><span class="sxs-lookup"><span data-stu-id="b9276-168">If a member exists that matches one of the patterns, it can be interpreted as an attachable member usage pathway by a XAML processor even if that was not your intention.</span></span>

#### <a name="the-getpropertyname-accessor"></a><span data-ttu-id="b9276-169">Přistupující objekt GetPropertyName</span><span class="sxs-lookup"><span data-stu-id="b9276-169">The GetPropertyName Accessor</span></span>

<span data-ttu-id="b9276-170">Podpis pro `GetPropertyName` přistupujícího ortu musí být:</span><span class="sxs-lookup"><span data-stu-id="b9276-170">The signature for the `GetPropertyName` accessor must be:</span></span>

`public static object GetPropertyName(object target)`

- <span data-ttu-id="b9276-171">Objekt `target` lze zadat jako konkrétnější typ v implementaci.</span><span class="sxs-lookup"><span data-stu-id="b9276-171">The `target` object can be specified as a more specific type in your implementation.</span></span> <span data-ttu-id="b9276-172">Můžete použít k vymezení použití připojitelný člen; použití mimo zamýšlený obor vyvolá neplatné výjimky přetypovacího vysílání, které jsou pak objeveny chybou analýzy XAML.</span><span class="sxs-lookup"><span data-stu-id="b9276-172">You can use this to scope the usage of your attachable member; usages outside your intended scope will throw invalid cast exceptions that are then surfaced by a XAML parse error.</span></span> <span data-ttu-id="b9276-173">Název `target` parametru není požadavek, `target` ale je pojmenován podle konvence ve většině implementací.</span><span class="sxs-lookup"><span data-stu-id="b9276-173">The parameter name `target` is not a requirement, but is named `target` by convention in most implementations.</span></span>

- <span data-ttu-id="b9276-174">Vrácená hodnota může být zadána jako konkrétnější typ v implementaci.</span><span class="sxs-lookup"><span data-stu-id="b9276-174">The return value can be specified as a more specific type in your implementation.</span></span>

<span data-ttu-id="b9276-175">Chcete-li <xref:System.ComponentModel.TypeConverter> podporovat povolenou textovou syntaxi pro <xref:System.ComponentModel.TypeConverterAttribute> použití `GetPropertyName` atributu připojitelného člena, použijte přistupujícího pole.</span><span class="sxs-lookup"><span data-stu-id="b9276-175">To support a <xref:System.ComponentModel.TypeConverter> enabled text syntax for attribute usage of the attachable member, apply <xref:System.ComponentModel.TypeConverterAttribute> to the `GetPropertyName` accessor.</span></span> <span data-ttu-id="b9276-176">Použití `get` na místo `set` se může zdát neintuitivní; Tato konvence však může podporovat koncept připojitelných členů jen pro čtení, které lze serializovat, což je užitečné v návrhářských scénářích.</span><span class="sxs-lookup"><span data-stu-id="b9276-176">Applying to the `get` instead of the `set` may seem non-intuitive; however, this convention can support the concept of read-only attachable members that are serializable, which is useful in designer scenarios.</span></span>

#### <a name="the-setpropertyname-accessor"></a><span data-ttu-id="b9276-177">Přistupující objekt SetPropertyName</span><span class="sxs-lookup"><span data-stu-id="b9276-177">The SetPropertyName Accessor</span></span>

<span data-ttu-id="b9276-178">Podpis pro `SetPropertyName` přistupujícího ortu musí být:</span><span class="sxs-lookup"><span data-stu-id="b9276-178">The signature for the `SetPropertyName` accessor must be:</span></span>

`public static void SetPropertyName(object target, object value)`

- <span data-ttu-id="b9276-179">Objekt `target` lze zadat jako konkrétnější typ v implementaci, se stejnou logikou a důsledky, jak je popsáno v předchozí části.</span><span class="sxs-lookup"><span data-stu-id="b9276-179">The `target` object can be specified as a more specific type in your implementation, with same logic and consequences as described in the previous section.</span></span>

- <span data-ttu-id="b9276-180">Objekt `value` lze zadat jako konkrétnější typ v implementaci.</span><span class="sxs-lookup"><span data-stu-id="b9276-180">The `value` object can be specified as a more specific type in your implementation.</span></span>

<span data-ttu-id="b9276-181">Nezapomeňte, že hodnota pro tuto metodu je vstup pocházející z využití XAML, obvykle ve formě atributu.</span><span class="sxs-lookup"><span data-stu-id="b9276-181">Remember that the value for this method is the input coming from the XAML usage, typically in attribute form.</span></span> <span data-ttu-id="b9276-182">Z formuláře atributu musí být podpora převaděče hodnot `GetPropertyName`pro syntaxi textu a atribut v přistupujícím s.</span><span class="sxs-lookup"><span data-stu-id="b9276-182">From attribute form there must be value converter support for a text syntax, and you attribute on the `GetPropertyName`s accessor.</span></span>

### <a name="attachable-member-stores"></a><span data-ttu-id="b9276-183">Připojitelné členské obchody</span><span class="sxs-lookup"><span data-stu-id="b9276-183">Attachable Member Stores</span></span>

<span data-ttu-id="b9276-184">Přistupující metody obvykle nestačí k poskytnutí prostředků k umístění připojitelných hodnot členů do grafu objektu nebo k načtení hodnot z grafu objektu a jejich serializaci správně.</span><span class="sxs-lookup"><span data-stu-id="b9276-184">The accessor methods are typically not enough to provide a means to place attachable member values into an object graph, or to retrieve values out of the object graph and serialize them properly.</span></span> <span data-ttu-id="b9276-185">Chcete-li poskytnout tuto `target` funkci, musí být objekty v předchozích přistupujících podpisech schopny ukládat hodnoty.</span><span class="sxs-lookup"><span data-stu-id="b9276-185">To provide this functionality, the `target` objects in the previous accessor signatures must be capable of storing values.</span></span> <span data-ttu-id="b9276-186">Mechanismus úložiště by měl být v souladu s principem připojitelný člen, že člen je připojitelný k cílům, kde připojitelný člen není v seznamu členů.</span><span class="sxs-lookup"><span data-stu-id="b9276-186">The storage mechanism should be consistent with the attachable member principle that the member is attachable to targets where the attachable member is not in the members list.</span></span> <span data-ttu-id="b9276-187">Služba .NET XAML Services poskytuje techniku implementace pro <xref:System.Xaml.IAttachedPropertyStore> <xref:System.Xaml.AttachablePropertyServices>připojitelná úložiště členů prostřednictvím rozhraní API a .</span><span class="sxs-lookup"><span data-stu-id="b9276-187">.NET XAML Services provides an implementation technique for attachable member stores through the APIs <xref:System.Xaml.IAttachedPropertyStore> and <xref:System.Xaml.AttachablePropertyServices>.</span></span> <span data-ttu-id="b9276-188"><xref:System.Xaml.IAttachedPropertyStore>používá autoři XAML ke zjištění implementace úložiště a by měla být `target` implementována na typu, který je přístupových částí.</span><span class="sxs-lookup"><span data-stu-id="b9276-188"><xref:System.Xaml.IAttachedPropertyStore> is used by the XAML writers to discover the store implementation, and should be implemented on the type that is the `target` of the accessors.</span></span> <span data-ttu-id="b9276-189">Statická <xref:System.Xaml.AttachablePropertyServices> připojení k dispozici jsou používány v těle přístupových částí a <xref:System.Xaml.AttachableMemberIdentifier>odkazují na připojitelný člen jeho .</span><span class="sxs-lookup"><span data-stu-id="b9276-189">The static <xref:System.Xaml.AttachablePropertyServices> APIs are used within the body of the accessors, and refer to the attachable member by its <xref:System.Xaml.AttachableMemberIdentifier>.</span></span>

## <a name="xaml-related-clr-attributes"></a><span data-ttu-id="b9276-190">Atributy CLR související s XAML</span><span class="sxs-lookup"><span data-stu-id="b9276-190">XAML-Related CLR Attributes</span></span>

<span data-ttu-id="b9276-191">Správné přiřazení typů, členů a sestavení je důležité pro vykazování informací o systému typu XAML do služby .NET XAML Services.</span><span class="sxs-lookup"><span data-stu-id="b9276-191">Correctly attributing your types, members, and assemblies is important in order to report XAML type system information to .NET XAML Services.</span></span> <span data-ttu-id="b9276-192">Hlášení informací o typu systému XAML je relevantní, pokud platí některá z následujících situací:</span><span class="sxs-lookup"><span data-stu-id="b9276-192">Reporting XAML type system information is relevant if either of the following situations apply:</span></span>

- <span data-ttu-id="b9276-193">Máte v úmyslu typy pro použití se systémy XAML, které jsou přímo založeny na .NET XAML služby XAML čtečky a Zapisovače XAML.</span><span class="sxs-lookup"><span data-stu-id="b9276-193">You intend your types for use with XAML systems that are directly based on .NET XAML Services XAML readers and XAML writers.</span></span>
- <span data-ttu-id="b9276-194">Definujete nebo používáte rozhraní S Využití XAML, které je založeno na těchto čtecích čtecích a zapisovačích XAML.</span><span class="sxs-lookup"><span data-stu-id="b9276-194">You define or use a XAML-utilizing framework that's based on those XAML readers and XAML writers.</span></span>

<span data-ttu-id="b9276-195">Seznam jednotlivých atributů souvisejících s XAML, který je relevantní pro podporu XAML vašich vlastních typů, naleznete v [tématu Atributy CLR související s XAML pro vlastní typy a knihovny](clr-attributes-with-custom-types-and-libraries.md).</span><span class="sxs-lookup"><span data-stu-id="b9276-195">For a listing of each XAML-related attribute that's relevant for XAML support of your custom types, see [XAML-Related CLR Attributes for Custom Types and Libraries](clr-attributes-with-custom-types-and-libraries.md).</span></span>

## <a name="usage"></a><span data-ttu-id="b9276-196">Využití</span><span class="sxs-lookup"><span data-stu-id="b9276-196">Usage</span></span>

<span data-ttu-id="b9276-197">Použití vlastních typů vyžaduje, aby autor značek musel mapovat předponu pro soubor sestavení a obor názvů CLR, které obsahují vlastní typ.</span><span class="sxs-lookup"><span data-stu-id="b9276-197">Usage of custom types requires that the markup author must map a prefix for the assembly and CLR namespace that contain the custom type.</span></span> <span data-ttu-id="b9276-198">Tento postup není v tomto tématu popsán.</span><span class="sxs-lookup"><span data-stu-id="b9276-198">This procedure is not documented in this topic.</span></span>

## <a name="access-level"></a><span data-ttu-id="b9276-199">Úroveň přístupu</span><span class="sxs-lookup"><span data-stu-id="b9276-199">Access Level</span></span>

<span data-ttu-id="b9276-200">XAML poskytuje prostředky k načtení a vytvoření `internal` instance typů, které mají úroveň přístupu.</span><span class="sxs-lookup"><span data-stu-id="b9276-200">XAML provides a means to load and instantiate types that have an `internal` access level.</span></span> <span data-ttu-id="b9276-201">Tato funkce je k dispozici tak, aby uživatelský kód můžete definovat své vlastní typy a potom vytvořit instanci těchto tříd ze značek, která je také součástí stejného oboru kódu uživatele.</span><span class="sxs-lookup"><span data-stu-id="b9276-201">This capability is provided so that user code can define its own types, and then instantiate those classes from markup that is also part of the same user code scope.</span></span>

<span data-ttu-id="b9276-202">Příkladem z WPF je vždy, <xref:System.Windows.Controls.UserControl> když uživatelský kód definuje, který je určen jako způsob refaktorování chování uživatelského rozhraní, ale ne `public` jako součást jakéhokoli možného mechanismu rozšíření, který může být implikován deklarováním podpůrné třídy s úrovní přístupu.</span><span class="sxs-lookup"><span data-stu-id="b9276-202">An example from WPF is whenever user code defines a <xref:System.Windows.Controls.UserControl> that is intended as a way to refactor a UI behavior, but not as part of any possible extension mechanism that might be implied by declaring the supporting class with `public` access level.</span></span> <span data-ttu-id="b9276-203">Takový <xref:System.Windows.Controls.UserControl> může být `internal` deklarován s přístupem, pokud je záložní kód zkompilován do stejného sestavení, ze kterého je odkazován jako typ XAML.</span><span class="sxs-lookup"><span data-stu-id="b9276-203">Such a <xref:System.Windows.Controls.UserControl> can be declared with `internal` access if the backing code is compiled into the same assembly from which it is referenced as a XAML type.</span></span>

<span data-ttu-id="b9276-204">Pro aplikaci, která načte XAML pod plnou důvěryhodnost a používá <xref:System.Xaml.XamlObjectWriter>, načítání tříd s `internal` úrovní přístupu je vždy povolena.</span><span class="sxs-lookup"><span data-stu-id="b9276-204">For an application that loads XAML under full trust and uses <xref:System.Xaml.XamlObjectWriter>, loading classes with `internal` access level is always enabled.</span></span>

<span data-ttu-id="b9276-205">Pro aplikaci, která načte XAML pod částečný medaiontistikou důvěryhodnosti, můžete řídit charakteristiky úrovně přístupu <xref:System.Xaml.Permissions.XamlAccessLevel> pomocí rozhraní API.</span><span class="sxs-lookup"><span data-stu-id="b9276-205">For an application that loads XAML under partial trust, you can control the access level characteristics by using the <xref:System.Xaml.Permissions.XamlAccessLevel> API.</span></span> <span data-ttu-id="b9276-206">Mechanismy časování (například systém šablony WPF) musí být také schopny šířit všechna oprávnění na úrovni přístupu a zachovat je pro případné vyhodnocení doby běhu; to je zpracována interně předáním <xref:System.Xaml.Permissions.XamlAccessLevel> informací.</span><span class="sxs-lookup"><span data-stu-id="b9276-206">Also, deferral mechanisms (such as the WPF template system) must be able to propagate any access level permissions and preserve them for the eventual run time evaluations; this is handled internally by passing the <xref:System.Xaml.Permissions.XamlAccessLevel> information.</span></span>

### <a name="wpf-implementation"></a><span data-ttu-id="b9276-207">Implementace WPF</span><span class="sxs-lookup"><span data-stu-id="b9276-207">WPF Implementation</span></span>

<span data-ttu-id="b9276-208">WPF XAML používá model přístupu částečné důvěryhodnosti, kde pokud BAML <xref:System.Xaml.Permissions.XamlAccessLevel.AssemblyAccessTo%2A> je načten pod částečný vztah důvěryhodnosti, přístup je omezen na sestavení, které je zdrojem BAML.</span><span class="sxs-lookup"><span data-stu-id="b9276-208">WPF XAML uses a partial-trust access model where if BAML is loaded under partial trust, access is restricted to <xref:System.Xaml.Permissions.XamlAccessLevel.AssemblyAccessTo%2A> for the assembly that is the BAML source.</span></span> <span data-ttu-id="b9276-209">Pro časově rozlišené WPF používá <xref:System.Xaml.IXamlObjectWriterFactory.GetParentSettings%2A?displayProperty=nameWithType> jako mechanismus pro předávání informací o úrovni přístupu.</span><span class="sxs-lookup"><span data-stu-id="b9276-209">For deferral, WPF uses <xref:System.Xaml.IXamlObjectWriterFactory.GetParentSettings%2A?displayProperty=nameWithType> as a mechanism for passing the access level information.</span></span>

<span data-ttu-id="b9276-210">V terminologii WPF XAML je *interní typ* typ, který je definován stejným sestavením, které také zahrnuje odkazující XAML.</span><span class="sxs-lookup"><span data-stu-id="b9276-210">In WPF XAML terminology, an *internal type* is a type that is defined by the same assembly that also includes the referencing XAML.</span></span> <span data-ttu-id="b9276-211">Takový typ lze mapovat prostřednictvím oboru názvů XAML, který záměrně vynese sestavení `xmlns:local="clr-namespace:WPFApplication1"`= část mapování, například .</span><span class="sxs-lookup"><span data-stu-id="b9276-211">Such a type can be mapped through a XAML namespace that deliberately omits the assembly= portion of a mapping, for example, `xmlns:local="clr-namespace:WPFApplication1"`.</span></span> <span data-ttu-id="b9276-212">Pokud BAML odkazuje na interní typ `internal` a tento typ `GeneratedInternalTypeHelper` má úroveň přístupu, vygeneruje se třída pro sestavení.</span><span class="sxs-lookup"><span data-stu-id="b9276-212">If BAML references an internal type and that type has `internal` access level, this generates a `GeneratedInternalTypeHelper` class for the assembly.</span></span> <span data-ttu-id="b9276-213">Pokud se chcete `GeneratedInternalTypeHelper`vyhnout , `public` musíte buď použít úroveň přístupu, nebo musíte faktor příslušné třídy do samostatného sestavení a učinit toto sestavení závislé.</span><span class="sxs-lookup"><span data-stu-id="b9276-213">If you want to avoid `GeneratedInternalTypeHelper`, you either must use `public` access level, or must factor the relevant class into a separate assembly and make that assembly dependent.</span></span>

## <a name="see-also"></a><span data-ttu-id="b9276-214">Viz také</span><span class="sxs-lookup"><span data-stu-id="b9276-214">See also</span></span>

- [<span data-ttu-id="b9276-215">Atributy CLR související s jazykem XAML pro vlastní typy a knihovny</span><span class="sxs-lookup"><span data-stu-id="b9276-215">XAML-Related CLR Attributes for Custom Types and Libraries</span></span>](clr-attributes-with-custom-types-and-libraries.md)
- [<span data-ttu-id="b9276-216">XAML Services</span><span class="sxs-lookup"><span data-stu-id="b9276-216">XAML Services</span></span>](../../../api/index.md)
